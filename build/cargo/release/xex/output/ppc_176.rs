pub fn sub_82E6F998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E6F998 size=64
    let mut pc: u32 = 0x82E6F998;
    'dispatch: loop {
        match pc {
            0x82E6F998 => {
    //   block [0x82E6F998..0x82E6F9D8)
	// 82E6F998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E6F99C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E6F9A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E6F9A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E6F9A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E6F9AC: 4B7A594D  bl 0x826152f8
	ctx.lr = 0x82E6F9B0;
	sub_826152F8(ctx, base);
	// 82E6F9B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E6F9B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E6F9B8: C00B0BEC  lfs f0, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E6F9BC: D01F005C  stfs f0, 0x5c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82E6F9C0: 915F006C  stw r10, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 82E6F9C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E6F9C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E6F9CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E6F9D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E6F9D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E6F9D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E6F9D8 size=20
    let mut pc: u32 = 0x82E6F9D8;
    'dispatch: loop {
        match pc {
            0x82E6F9D8 => {
    //   block [0x82E6F9D8..0x82E6F9EC)
	// 82E6F9D8: 89630010  lbz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E6F9DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E6F9E0: 4082000C  bne 0x82e6f9ec
	if !ctx.cr[0].eq {
		sub_82E6F9EC(ctx, base);
		return;
	}
	// 82E6F9E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E6F9E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E6F9EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E6F9EC size=8
    let mut pc: u32 = 0x82E6F9EC;
    'dispatch: loop {
        match pc {
            0x82E6F9EC => {
    //   block [0x82E6F9EC..0x82E6F9F4)
	// 82E6F9EC: 80630060  lwz r3, 0x60(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E6F9F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E6F9F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E6F9F8 size=480
    let mut pc: u32 = 0x82E6F9F8;
    'dispatch: loop {
        match pc {
            0x82E6F9F8 => {
    //   block [0x82E6F9F8..0x82E6FBD8)
	// 82E6F9F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E6F9FC: 4BE39A0D  bl 0x82ca9408
	ctx.lr = 0x82E6FA00;
	sub_82CA93D0(ctx, base);
	// 82E6FA00: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82E6FA04: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82E6FA08: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E6FA0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E6FA10: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E6FA14: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82E6FA18: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E6FA1C: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E6FA20: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E6FA24: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E6FA28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E6FA2C: EFC00032  fmuls f30, f0, f0
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E6FA30: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E6FA34: 816301A0  lwz r11, 0x1a0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(416 as u32) ) } as u64;
	// 82E6FA38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E6FA3C: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 82E6FA40: 40990070  ble cr6, 0x82e6fab0
	if !ctx.cr[6].gt {
	pc = 0x82E6FAB0; continue 'dispatch;
	}
	// 82E6FA44: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E6FA48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E6FA4C: 4B325E55  bl 0x821958a0
	ctx.lr = 0x82E6FA50;
	sub_821958A0(ctx, base);
	// 82E6FA50: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E6FA54: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E6FA58: 409A0044  bne cr6, 0x82e6fa9c
	if !ctx.cr[6].eq {
	pc = 0x82E6FA9C; continue 'dispatch;
	}
	// 82E6FA5C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E6FA60: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E6FA64: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E6FA68: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E6FA6C: C16B0034  lfs f11, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E6FA70: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E6FA74: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E6FA78: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E6FA7C: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E6FA80: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E6FA84: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E6FA88: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E6FA8C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E6FA90: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82E6FA94: 40980008  bge cr6, 0x82e6fa9c
	if !ctx.cr[6].lt {
	pc = 0x82E6FA9C; continue 'dispatch;
	}
	// 82E6FA98: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 82E6FA9C: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E6FAA0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E6FAA4: 816301A0  lwz r11, 0x1a0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(416 as u32) ) } as u64;
	// 82E6FAA8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E6FAAC: 4198FF98  blt cr6, 0x82e6fa44
	if ctx.cr[6].lt {
	pc = 0x82E6FA44; continue 'dispatch;
	}
	// 82E6FAB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E6FAB4: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E6FAB8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E6FABC: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E6FAC0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E6FAC4: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82E6FAC8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E6FACC: 81630194  lwz r11, 0x194(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(404 as u32) ) } as u64;
	// 82E6FAD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E6FAD4: 4099007C  ble cr6, 0x82e6fb50
	if !ctx.cr[6].gt {
	pc = 0x82E6FB50; continue 'dispatch;
	}
	// 82E6FAD8: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82E6FADC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82E6FAE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E6FAE4: 480013BD  bl 0x82e70ea0
	ctx.lr = 0x82E6FAE8;
	sub_82E70EA0(ctx, base);
	// 82E6FAE8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E6FAEC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E6FAF0: 409A004C  bne cr6, 0x82e6fb3c
	if !ctx.cr[6].eq {
	pc = 0x82E6FB3C; continue 'dispatch;
	}
	// 82E6FAF4: C1810058  lfs f12, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E6FAF8: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E6FAFC: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E6FB00: C181005C  lfs f12, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E6FB04: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E6FB08: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E6FB0C: C1610060  lfs f11, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E6FB10: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E6FB14: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E6FB18: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E6FB1C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E6FB20: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E6FB24: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E6FB28: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E6FB2C: 40980010  bge cr6, 0x82e6fb3c
	if !ctx.cr[6].lt {
	pc = 0x82E6FB3C; continue 'dispatch;
	}
	// 82E6FB30: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82E6FB34: 40980008  bge cr6, 0x82e6fb3c
	if !ctx.cr[6].lt {
	pc = 0x82E6FB3C; continue 'dispatch;
	}
	// 82E6FB38: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 82E6FB3C: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E6FB40: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E6FB44: 81630194  lwz r11, 0x194(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(404 as u32) ) } as u64;
	// 82E6FB48: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E6FB4C: 4198FF8C  blt cr6, 0x82e6fad8
	if ctx.cr[6].lt {
	pc = 0x82E6FAD8; continue 'dispatch;
	}
	// 82E6FB50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E6FB54: 2B1C0001  cmplwi cr6, r28, 1
	ctx.cr[6].compare_u32(ctx.r[28].u32, 1 as u32, &mut ctx.xer);
	// 82E6FB58: C14B0C14  lfs f10, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E6FB5C: 409A000C  bne cr6, 0x82e6fb68
	if !ctx.cr[6].eq {
	pc = 0x82E6FB68; continue 'dispatch;
	}
	// 82E6FB60: FC205090  fmr f1, f10
	ctx.f[1].f64 = ctx.f[10].f64;
	// 82E6FB64: 4800000C  b 0x82e6fb70
	pc = 0x82E6FB70; continue 'dispatch;
	// 82E6FB68: EC1EF828  fsubs f0, f30, f31
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 82E6FB6C: EC20F024  fdivs f1, f0, f30
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[30].f64) as f32) as f64;
	// 82E6FB70: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E6FB74: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E6FB78: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E6FB7C: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E6FB80: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E6FB84: C16B0010  lfs f11, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E6FB88: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E6FB8C: C12B0034  lfs f9, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E6FB90: EC004828  fsubs f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[9].f64) as f32) as f64);
	// 82E6FB94: C10B0038  lfs f8, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82E6FB98: EDAD4028  fsubs f13, f13, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[8].f64) as f32) as f64);
	// 82E6FB9C: C12B003C  lfs f9, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E6FBA0: ED8C4828  fsubs f12, f12, f9
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82E6FBA4: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E6FBA8: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E6FBAC: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E6FBB0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E6FBB4: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82E6FBB8: 40990010  ble cr6, 0x82e6fbc8
	if !ctx.cr[6].gt {
	pc = 0x82E6FBC8; continue 'dispatch;
	}
	// 82E6FBBC: EC005824  fdivs f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82E6FBC0: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E6FBC4: EC20082A  fadds f1, f0, f1
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 82E6FBC8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E6FBCC: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82E6FBD0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82E6FBD4: 4BE39884  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E6FBD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E6FBD8 size=20
    let mut pc: u32 = 0x82E6FBD8;
    'dispatch: loop {
        match pc {
            0x82E6FBD8 => {
    //   block [0x82E6FBD8..0x82E6FBEC)
	// 82E6FBD8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E6FBDC: 814BB6A8  lwz r10, -0x4958(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18776 as u32) ) } as u64;
	// 82E6FBE0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E6FBE4: 914BB6A8  stw r10, -0x4958(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-18776 as u32), ctx.r[10].u32 ) };
	// 82E6FBE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E6FBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E6FBF0 size=56
    let mut pc: u32 = 0x82E6FBF0;
    'dispatch: loop {
        match pc {
            0x82E6FBF0 => {
    //   block [0x82E6FBF0..0x82E6FC28)
	// 82E6FBF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E6FBF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E6FBF8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E6FBFC: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 82E6FC00: 4B7A6D29  bl 0x82616928
	ctx.lr = 0x82E6FC04;
	sub_82616928(ctx, base);
	// 82E6FC04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E6FC08: 4182000C  beq 0x82e6fc14
	if ctx.cr[0].eq {
	pc = 0x82E6FC14; continue 'dispatch;
	}
	// 82E6FC0C: 4BFFFB05  bl 0x82e6f710
	ctx.lr = 0x82E6FC10;
	sub_82E6F710(ctx, base);
	// 82E6FC10: 48000008  b 0x82e6fc18
	pc = 0x82E6FC18; continue 'dispatch;
	// 82E6FC14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E6FC18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E6FC1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E6FC20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E6FC24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E6FC28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E6FC28 size=88
    let mut pc: u32 = 0x82E6FC28;
    'dispatch: loop {
        match pc {
            0x82E6FC28 => {
    //   block [0x82E6FC28..0x82E6FC80)
	// 82E6FC28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E6FC2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E6FC30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E6FC34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E6FC38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E6FC3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E6FC40: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E6FC44: 4B7A547D  bl 0x826150c0
	ctx.lr = 0x82E6FC48;
	sub_826150C0(ctx, base);
	// 82E6FC48: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E6FC4C: 41820018  beq 0x82e6fc64
	if ctx.cr[0].eq {
	pc = 0x82E6FC64; continue 'dispatch;
	}
	// 82E6FC50: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E6FC54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E6FC58: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E6FC5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E6FC60: 4E800421  bctrl
	ctx.lr = 0x82E6FC64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E6FC64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E6FC68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E6FC6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E6FC70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E6FC74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E6FC78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E6FC7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E6FC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E6FC80 size=76
    let mut pc: u32 = 0x82E6FC80;
    'dispatch: loop {
        match pc {
            0x82E6FC80 => {
    //   block [0x82E6FC80..0x82E6FCCC)
	// 82E6FC80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E6FC84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E6FC88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E6FC8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E6FC90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E6FC94: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E6FC98: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E6FC9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E6FCA0: 4B7B4B61  bl 0x82624800
	ctx.lr = 0x82E6FCA4;
	sub_82624800(ctx, base);
	// 82E6FCA4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82E6FCA8: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82E6FCAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E6FCB0: 4BFFFD49  bl 0x82e6f9f8
	ctx.lr = 0x82E6FCB4;
	sub_82E6F9F8(ctx, base);
	// 82E6FCB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E6FCB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E6FCBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E6FCC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E6FCC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E6FCC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E6FCD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E6FCD0 size=184
    let mut pc: u32 = 0x82E6FCD0;
    'dispatch: loop {
        match pc {
            0x82E6FCD0 => {
    //   block [0x82E6FCD0..0x82E6FD88)
	// 82E6FCD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E6FCD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E6FCD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E6FCDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E6FCE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E6FCE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E6FCE8: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E6FCEC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E6FCF0: 40820008  bne 0x82e6fcf8
	if !ctx.cr[0].eq {
	pc = 0x82E6FCF8; continue 'dispatch;
	}
	// 82E6FCF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E6FCF8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E6FCFC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E6FD00: 409A0008  bne cr6, 0x82e6fd08
	if !ctx.cr[6].eq {
	pc = 0x82E6FD08; continue 'dispatch;
	}
	// 82E6FD04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E6FD08: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E6FD0C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E6FD10: 409A0008  bne cr6, 0x82e6fd18
	if !ctx.cr[6].eq {
	pc = 0x82E6FD18; continue 'dispatch;
	}
	// 82E6FD14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E6FD18: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E6FD1C: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 82E6FD20: 409A0008  bne cr6, 0x82e6fd28
	if !ctx.cr[6].eq {
	pc = 0x82E6FD28; continue 'dispatch;
	}
	// 82E6FD24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E6FD28: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E6FD2C: 4082000C  bne 0x82e6fd38
	if !ctx.cr[0].eq {
	pc = 0x82E6FD38; continue 'dispatch;
	}
	// 82E6FD30: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E6FD34: 48000040  b 0x82e6fd74
	pc = 0x82E6FD74; continue 'dispatch;
	// 82E6FD38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E6FD3C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E6FD40: 388A01B4  addi r4, r10, 0x1b4
	ctx.r[4].s64 = ctx.r[10].s64 + 436;
	// 82E6FD44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E6FD48: C00B0BEC  lfs f0, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E6FD4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E6FD50: D01F005C  stfs f0, 0x5c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82E6FD54: 997F0058  stb r11, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82E6FD58: 4BFFFCA1  bl 0x82e6f9f8
	ctx.lr = 0x82E6FD5C;
	sub_82E6F9F8(ctx, base);
	// 82E6FD5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E6FD60: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E6FD64: D03F0064  stfs f1, 0x64(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E6FD68: 4BFFFF19  bl 0x82e6fc80
	ctx.lr = 0x82E6FD6C;
	sub_82E6FC80(ctx, base);
	// 82E6FD6C: D03F0068  stfs f1, 0x68(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E6FD70: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E6FD74: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E6FD78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E6FD7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E6FD80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E6FD84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E6FD88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E6FD88 size=80
    let mut pc: u32 = 0x82E6FD88;
    'dispatch: loop {
        match pc {
            0x82E6FD88 => {
    //   block [0x82E6FD88..0x82E6FDD8)
	// 82E6FD88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E6FD8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E6FD90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E6FD94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E6FD98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E6FD9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E6FDA0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E6FDA4: 4BFFFEDD  bl 0x82e6fc80
	ctx.lr = 0x82E6FDA8;
	sub_82E6FC80(ctx, base);
	// 82E6FDA8: C01F005C  lfs f0, 0x5c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E6FDAC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82E6FDB0: 4098000C  bge cr6, 0x82e6fdbc
	if !ctx.cr[6].lt {
	pc = 0x82E6FDBC; continue 'dispatch;
	}
	// 82E6FDB4: D03F005C  stfs f1, 0x5c(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82E6FDB8: 93DF006C  stw r30, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82E6FDBC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E6FDC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E6FDC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E6FDC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E6FDCC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E6FDD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E6FDD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E6FDD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E6FDD8 size=184
    let mut pc: u32 = 0x82E6FDD8;
    'dispatch: loop {
        match pc {
            0x82E6FDD8 => {
    //   block [0x82E6FDD8..0x82E6FE90)
	// 82E6FDD8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E6FDDC: 396BB8D4  addi r11, r11, -0x472c
	ctx.r[11].s64 = ctx.r[11].s64 + -18220;
	// 82E6FDE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E6FDE4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E6FDE8: 419A00A8  beq cr6, 0x82e6fe90
	if ctx.cr[6].eq {
		sub_82E6FE90(ctx, base);
		return;
	}
	// 82E6FDEC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E6FDF0: 396BB7C0  addi r11, r11, -0x4840
	ctx.r[11].s64 = ctx.r[11].s64 + -18496;
	// 82E6FDF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E6FDF8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E6FDFC: 419A0094  beq cr6, 0x82e6fe90
	if ctx.cr[6].eq {
		sub_82E6FE90(ctx, base);
		return;
	}
	// 82E6FE00: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E6FE04: 396BBC10  addi r11, r11, -0x43f0
	ctx.r[11].s64 = ctx.r[11].s64 + -17392;
	// 82E6FE08: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E6FE0C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E6FE10: 419A0080  beq cr6, 0x82e6fe90
	if ctx.cr[6].eq {
		sub_82E6FE90(ctx, base);
		return;
	}
	// 82E6FE14: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E6FE18: 396BB9E8  addi r11, r11, -0x4618
	ctx.r[11].s64 = ctx.r[11].s64 + -17944;
	// 82E6FE1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E6FE20: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E6FE24: 419A006C  beq cr6, 0x82e6fe90
	if ctx.cr[6].eq {
		sub_82E6FE90(ctx, base);
		return;
	}
	// 82E6FE28: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E6FE2C: 396BBF50  addi r11, r11, -0x40b0
	ctx.r[11].s64 = ctx.r[11].s64 + -16560;
	// 82E6FE30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E6FE34: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E6FE38: 419A0058  beq cr6, 0x82e6fe90
	if ctx.cr[6].eq {
		sub_82E6FE90(ctx, base);
		return;
	}
	// 82E6FE3C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E6FE40: 396BBE3C  addi r11, r11, -0x41c4
	ctx.r[11].s64 = ctx.r[11].s64 + -16836;
	// 82E6FE44: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E6FE48: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E6FE4C: 419A0044  beq cr6, 0x82e6fe90
	if ctx.cr[6].eq {
		sub_82E6FE90(ctx, base);
		return;
	}
	// 82E6FE50: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E6FE54: 396BBAFC  addi r11, r11, -0x4504
	ctx.r[11].s64 = ctx.r[11].s64 + -17668;
	// 82E6FE58: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E6FE5C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E6FE60: 419A0030  beq cr6, 0x82e6fe90
	if ctx.cr[6].eq {
		sub_82E6FE90(ctx, base);
		return;
	}
	// 82E6FE64: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E6FE68: 396BBD28  addi r11, r11, -0x42d8
	ctx.r[11].s64 = ctx.r[11].s64 + -17112;
	// 82E6FE6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E6FE70: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E6FE74: 419A001C  beq cr6, 0x82e6fe90
	if ctx.cr[6].eq {
		sub_82E6FE90(ctx, base);
		return;
	}
	// 82E6FE78: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E6FE7C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E6FE80: 396BB6AC  addi r11, r11, -0x4954
	ctx.r[11].s64 = ctx.r[11].s64 + -18772;
	// 82E6FE84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E6FE88: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E6FE8C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E6FE90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E6FE90 size=8
    let mut pc: u32 = 0x82E6FE90;
    'dispatch: loop {
        match pc {
            0x82E6FE90 => {
    //   block [0x82E6FE90..0x82E6FE98)
	// 82E6FE90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E6FE94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E6FE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E6FE98 size=92
    let mut pc: u32 = 0x82E6FE98;
    'dispatch: loop {
        match pc {
            0x82E6FE98 => {
    //   block [0x82E6FE98..0x82E6FEF4)
	// 82E6FE98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E6FE9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E6FEA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E6FEA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E6FEA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E6FEAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E6FEB0: 419A002C  beq cr6, 0x82e6fedc
	if ctx.cr[6].eq {
	pc = 0x82E6FEDC; continue 'dispatch;
	}
	// 82E6FEB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E6FEB8: 4834C1A9  bl 0x831bc060
	ctx.lr = 0x82E6FEBC;
	sub_831BC060(ctx, base);
	// 82E6FEBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E6FEC0: 4182001C  beq 0x82e6fedc
	if ctx.cr[0].eq {
	pc = 0x82E6FEDC; continue 'dispatch;
	}
	// 82E6FEC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E6FEC8: 4834C199  bl 0x831bc060
	ctx.lr = 0x82E6FECC;
	sub_831BC060(ctx, base);
	// 82E6FECC: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E6FED0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E6FED4: 2B0B005F  cmplwi cr6, r11, 0x5f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 95 as u32, &mut ctx.xer);
	// 82E6FED8: 419A0008  beq cr6, 0x82e6fee0
	if ctx.cr[6].eq {
	pc = 0x82E6FEE0; continue 'dispatch;
	}
	// 82E6FEDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E6FEE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E6FEE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E6FEE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E6FEEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E6FEF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E6FEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E6FEF8 size=84
    let mut pc: u32 = 0x82E6FEF8;
    'dispatch: loop {
        match pc {
            0x82E6FEF8 => {
    //   block [0x82E6FEF8..0x82E6FF4C)
	// 82E6FEF8: C0040004  lfs f0, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E6FEFC: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 82E6FF00: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E6FF04: 7D232050  subf r9, r3, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 82E6FF08: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E6FF0C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82E6FF10: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E6FF14: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E6FF18: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E6FF1C: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E6FF20: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E6FF24: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82E6FF28: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E6FF2C: 4082FFF0  bne 0x82e6ff1c
	if !ctx.cr[0].eq {
	pc = 0x82E6FF1C; continue 'dispatch;
	}
	// 82E6FF30: 89640058  lbz r11, 0x58(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E6FF34: 99630058  stb r11, 0x58(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82E6FF38: 81640050  lwz r11, 0x50(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E6FF3C: 91630050  stw r11, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E6FF40: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E6FF44: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E6FF48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E6FF50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E6FF50 size=12
    let mut pc: u32 = 0x82E6FF50;
    'dispatch: loop {
        match pc {
            0x82E6FF50 => {
    //   block [0x82E6FF50..0x82E6FF5C)
	// 82E6FF50: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E6FF54: 386BB7C0  addi r3, r11, -0x4840
	ctx.r[3].s64 = ctx.r[11].s64 + -18496;
	// 82E6FF58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E6FF60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E6FF60 size=20
    let mut pc: u32 = 0x82E6FF60;
    'dispatch: loop {
        match pc {
            0x82E6FF60 => {
    //   block [0x82E6FF60..0x82E6FF74)
	// 82E6FF60: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E6FF64: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82E6FF68: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82E6FF6C: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82E6FF70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E6FF78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E6FF78 size=24
    let mut pc: u32 = 0x82E6FF78;
    'dispatch: loop {
        match pc {
            0x82E6FF78 => {
    //   block [0x82E6FF78..0x82E6FF90)
	// 82E6FF78: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E6FF7C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E6FF80: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82E6FF84: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82E6FF88: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82E6FF8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E6FF90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E6FF90 size=76
    let mut pc: u32 = 0x82E6FF90;
    'dispatch: loop {
        match pc {
            0x82E6FF90 => {
    //   block [0x82E6FF90..0x82E6FFDC)
	// 82E6FF90: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E6FF94: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E6FF98: 41820044  beq 0x82e6ffdc
	if ctx.cr[0].eq {
		sub_82E6FFDC(ctx, base);
		return;
	}
	// 82E6FF9C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E6FFA0: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E6FFA4: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E6FFA8: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E6FFAC: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E6FFB0: C16A0034  lfs f11, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E6FFB4: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E6FFB8: C14A0038  lfs f10, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E6FFBC: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E6FFC0: C16A003C  lfs f11, 0x3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E6FFC4: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E6FFC8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E6FFCC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E6FFD0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E6FFD4: EC20002C  fsqrts f1, f0
	ctx.f[1].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E6FFD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E6FFDC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E6FFDC size=12
    let mut pc: u32 = 0x82E6FFDC;
    'dispatch: loop {
        match pc {
            0x82E6FFDC => {
    //   block [0x82E6FFDC..0x82E6FFE8)
	// 82E6FFDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E6FFE0: C02B0C18  lfs f1, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E6FFE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E6FFE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E6FFE8 size=228
    let mut pc: u32 = 0x82E6FFE8;
    'dispatch: loop {
        match pc {
            0x82E6FFE8 => {
    //   block [0x82E6FFE8..0x82E700CC)
	// 82E6FFE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E6FFEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E6FFF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E6FFF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E6FFF8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E6FFFC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E70000: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E70004: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E70008: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7000C: 41820084  beq 0x82e70090
	if ctx.cr[0].eq {
	pc = 0x82E70090; continue 'dispatch;
	}
	// 82E70010: C00B0040  lfs f0, 0x40(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70014: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E70018: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E7001C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E70020: C00B0044  lfs f0, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70024: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E70028: C18B0048  lfs f12, 0x48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E7002C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E70030: C1BE0014  lfs f13, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E70034: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E70038: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E7003C: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E70040: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70044: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E70048: 48015C59  bl 0x82e85ca0
	ctx.lr = 0x82E7004C;
	sub_82E85CA0(ctx, base);
	// 82E7004C: C01E0010  lfs f0, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70050: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E70054: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E70058: C1810064  lfs f12, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E7005C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E70060: C1610068  lfs f11, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E70064: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E70068: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E7006C: C16B0034  lfs f11, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E70070: C12B003C  lfs f9, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E70074: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E70078: EDAB682A  fadds f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E7007C: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E70080: EDAA602A  fadds f13, f10, f12
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E70084: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E70088: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E7008C: 48000020  b 0x82e700ac
	pc = 0x82E700AC; continue 'dispatch;
	// 82E70090: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E70094: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E70098: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7009C: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E700A0: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E700A4: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E700A8: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E700AC: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E700B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E700B4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E700B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E700BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E700C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E700C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E700C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E700D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E700D0 size=108
    let mut pc: u32 = 0x82E700D0;
    'dispatch: loop {
        match pc {
            0x82E700D0 => {
    //   block [0x82E700D0..0x82E7013C)
	// 82E700D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E700D4: 4BE39339  bl 0x82ca940c
	ctx.lr = 0x82E700D8;
	sub_82CA93D0(ctx, base);
	// 82E700D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E700DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E700E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E700E4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E700E8: 4B3F0E49  bl 0x82260f30
	ctx.lr = 0x82E700EC;
	sub_82260F30(ctx, base);
	// 82E700EC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E700F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E700F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E700F8: 48011661  bl 0x82e81758
	ctx.lr = 0x82E700FC;
	sub_82E81758(ctx, base);
	// 82E700FC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E70100: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E70104: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E70108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7010C: 41820020  beq 0x82e7012c
	if ctx.cr[0].eq {
	pc = 0x82E7012C; continue 'dispatch;
	}
	// 82E70110: 48011961  bl 0x82e81a70
	ctx.lr = 0x82E70114;
	sub_82E81A70(ctx, base);
	// 82E70114: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E70118: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E7011C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E70120: 480119D1  bl 0x82e81af0
	ctx.lr = 0x82E70124;
	sub_82E81AF0(ctx, base);
	// 82E70124: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E70128: 4800000C  b 0x82e70134
	pc = 0x82E70134; continue 'dispatch;
	// 82E7012C: 48011B0D  bl 0x82e81c38
	ctx.lr = 0x82E70130;
	sub_82E81C38(ctx, base);
	// 82E70130: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E70134: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E70138: 4BE39324  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E70140 size=200
    let mut pc: u32 = 0x82E70140;
    'dispatch: loop {
        match pc {
            0x82E70140 => {
    //   block [0x82E70140..0x82E70208)
	// 82E70140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E70144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E70148: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E7014C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E70150: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E70154: 48019085  bl 0x82e891d8
	ctx.lr = 0x82E70158;
	sub_82E891D8(ctx, base);
	// 82E70158: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E7015C: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 82E70160: 397F0044  addi r11, r31, 0x44
	ctx.r[11].s64 = ctx.r[31].s64 + 68;
	// 82E70164: 39089128  addi r8, r8, -0x6ed8
	ctx.r[8].s64 = ctx.r[8].s64 + -28376;
	// 82E70168: 38EB0010  addi r7, r11, 0x10
	ctx.r[7].s64 = ctx.r[11].s64 + 16;
	// 82E7016C: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70170: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E70174: 392A2D88  addi r9, r10, 0x2d88
	ctx.r[9].s64 = ctx.r[10].s64 + 11656;
	// 82E70178: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E7017C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E70180: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82E70184: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82E70188: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82E7018C: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82E70190: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82E70194: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82E70198: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82E7019C: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82E701A0: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82E701A4: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82E701A8: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82E701AC: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E701B0: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E701B4: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E701B8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82E701BC: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E701C0: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82E701C4: 4200FFF8  bdnz 0x82e701bc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E701BC; continue 'dispatch;
	}
	// 82E701C8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E701CC: 994B0058  stb r10, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[10].u8 ) };
	// 82E701D0: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 82E701D4: 915F00A4  stw r10, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[10].u32 ) };
	// 82E701D8: 392910BC  addi r9, r9, 0x10bc
	ctx.r[9].s64 = ctx.r[9].s64 + 4284;
	// 82E701DC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82E701E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E701E4: 911F00A8  stw r8, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	// 82E701E8: 913F00A0  stw r9, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	// 82E701EC: 98FF00B0  stb r7, 0xb0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[7].u8 ) };
	// 82E701F0: 995F00B2  stb r10, 0xb2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(178 as u32), ctx.r[10].u8 ) };
	// 82E701F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E701F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E701FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E70200: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E70204: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E70208 size=116
    let mut pc: u32 = 0x82E70208;
    'dispatch: loop {
        match pc {
            0x82E70208 => {
    //   block [0x82E70208..0x82E7027C)
	// 82E70208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7020C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E70210: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E70214: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E70218: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7021C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E70220: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E70224: 394B2D88  addi r10, r11, 0x2d88
	ctx.r[10].s64 = ctx.r[11].s64 + 11656;
	// 82E70228: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E7022C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E70230: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E70234: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E70238: 917F00A0  stw r11, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82E7023C: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82E70240: 48018FB9  bl 0x82e891f8
	ctx.lr = 0x82E70244;
	sub_82E891F8(ctx, base);
	// 82E70244: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E70248: 41820018  beq 0x82e70260
	if ctx.cr[0].eq {
	pc = 0x82E70260; continue 'dispatch;
	}
	// 82E7024C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E70250: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E70254: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E70258: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E7025C: 4E800421  bctrl
	ctx.lr = 0x82E70260;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E70260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E70264: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E70268: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E7026C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E70270: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E70274: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E70278: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E70280 size=520
    let mut pc: u32 = 0x82E70280;
    'dispatch: loop {
        match pc {
            0x82E70280 => {
    //   block [0x82E70280..0x82E70488)
	// 82E70280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E70284: 4BE39189  bl 0x82ca940c
	ctx.lr = 0x82E70288;
	sub_82CA93D0(ctx, base);
	// 82E70288: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82E7028C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82E70290: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E70294: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E70298: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E7029C: 4B3F071D  bl 0x822609b8
	ctx.lr = 0x82E702A0;
	sub_822609B8(ctx, base);
	// 82E702A0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E702A4: 388B8798  addi r4, r11, -0x7868
	ctx.r[4].s64 = ctx.r[11].s64 + -30824;
	// 82E702A8: 48010EC1  bl 0x82e81168
	ctx.lr = 0x82E702AC;
	sub_82E81168(ctx, base);
	// 82E702AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E702B0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E702B4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E702B8: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 82E702BC: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82E702C0: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82E702C4: C3CB0C18  lfs f30, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E702C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E702CC: D3DF0024  stfs f30, 0x24(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82E702D0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E702D4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E702D8: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E702DC: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82E702E0: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E702E4: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E702E8: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E702EC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E702F0: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E702F4: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82E702F8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E702FC: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82E70300: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82E70304: 4200FFF8  bdnz 0x82e702fc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E702FC; continue 'dispatch;
	}
	// 82E70308: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E7030C: 9BC100A8  stb r30, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[30].u8 ) };
	// 82E70310: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 82E70314: 4BFFFBE5  bl 0x82e6fef8
	ctx.lr = 0x82E70318;
	sub_82E6FEF8(ctx, base);
	// 82E70318: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7031C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E70320: D3DF0010  stfs f30, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E70324: 388B1048  addi r4, r11, 0x1048
	ctx.r[4].s64 = ctx.r[11].s64 + 4168;
	// 82E70328: D3DF0014  stfs f30, 0x14(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E7032C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E70330: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82E70334: 9BDF00B1  stb r30, 0xb1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(177 as u32), ctx.r[30].u8 ) };
	// 82E70338: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E7033C: D3FF00B4  stfs f31, 0xb4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82E70340: 4B3F71D1  bl 0x82267510
	ctx.lr = 0x82E70344;
	sub_82267510(ctx, base);
	// 82E70344: 3FC08334  lis r30, -0x7ccc
	ctx.r[30].s64 = -2093744128;
	// 82E70348: 907F0018  stw r3, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 82E7034C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E70350: 388BE4AC  addi r4, r11, -0x1b54
	ctx.r[4].s64 = ctx.r[11].s64 + -6996;
	// 82E70354: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E70358: 4B3F78C9  bl 0x82267c20
	ctx.lr = 0x82E7035C;
	sub_82267C20(ctx, base);
	// 82E7035C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E70360: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E70364: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E70368: 907F001C  stw r3, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 82E7036C: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82E70370: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E70374: 4B378305  bl 0x821e8678
	ctx.lr = 0x82E70378;
	sub_821E8678(ctx, base);
	// 82E70378: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7037C: 4182000C  beq 0x82e70388
	if ctx.cr[0].eq {
	pc = 0x82E70388; continue 'dispatch;
	}
	// 82E70380: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70384: 4800001C  b 0x82e703a0
	pc = 0x82E703A0; continue 'dispatch;
	// 82E70388: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E7038C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E70390: 4182000C  beq 0x82e7039c
	if ctx.cr[0].eq {
	pc = 0x82E7039C; continue 'dispatch;
	}
	// 82E70394: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70398: 48000008  b 0x82e703a0
	pc = 0x82E703A0; continue 'dispatch;
	// 82E7039C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82E703A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E703A4: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82E703A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E703AC: 48018F1D  bl 0x82e892c8
	ctx.lr = 0x82E703B0;
	sub_82E892C8(ctx, base);
	// 82E703B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E703B4: 418200C0  beq 0x82e70474
	if ctx.cr[0].eq {
	pc = 0x82E70474; continue 'dispatch;
	}
	// 82E703B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E703BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E703C0: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E703C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E703C8: 4E800421  bctrl
	ctx.lr = 0x82E703CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E703CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E703D0: 418200A4  beq 0x82e70474
	if ctx.cr[0].eq {
	pc = 0x82E70474; continue 'dispatch;
	}
	// 82E703D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E703D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E703DC: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E703E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E703E4: 4E800421  bctrl
	ctx.lr = 0x82E703E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E703E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E703EC: 41820088  beq 0x82e70474
	if ctx.cr[0].eq {
	pc = 0x82E70474; continue 'dispatch;
	}
	// 82E703F0: C01F00B4  lfs f0, 0xb4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E703F4: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82E703F8: 4198007C  blt cr6, 0x82e70474
	if ctx.cr[6].lt {
	pc = 0x82E70474; continue 'dispatch;
	}
	// 82E703FC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E70400: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E70404: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E70408: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82E7040C: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E70410: 4B378269  bl 0x821e8678
	ctx.lr = 0x82E70414;
	sub_821E8678(ctx, base);
	// 82E70414: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E70418: 41820018  beq 0x82e70430
	if ctx.cr[0].eq {
	pc = 0x82E70430; continue 'dispatch;
	}
	// 82E7041C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E70420: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E70424: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70428: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E7042C: 48000028  b 0x82e70454
	pc = 0x82E70454; continue 'dispatch;
	// 82E70430: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E70434: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E70438: 4182000C  beq 0x82e70444
	if ctx.cr[0].eq {
	pc = 0x82E70444; continue 'dispatch;
	}
	// 82E7043C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70440: 48000008  b 0x82e70448
	pc = 0x82E70448; continue 'dispatch;
	// 82E70444: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82E70448: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E7044C: C1AB0BFC  lfs f13, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E70450: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E70454: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E70458: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82E7045C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E70460: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E70464: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E70468: 4E800421  bctrl
	ctx.lr = 0x82E7046C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E7046C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E70470: 48000008  b 0x82e70478
	pc = 0x82E70478; continue 'dispatch;
	// 82E70474: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E70478: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82E7047C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82E70480: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82E70484: 4BE38FD8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E70488 size=492
    let mut pc: u32 = 0x82E70488;
    'dispatch: loop {
        match pc {
            0x82E70488 => {
    //   block [0x82E70488..0x82E70674)
	// 82E70488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7048C: 4BE38F81  bl 0x82ca940c
	ctx.lr = 0x82E70490;
	sub_82CA93D0(ctx, base);
	// 82E70490: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82E70494: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E70498: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E7049C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E704A0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E704A4: 409A000C  bne cr6, 0x82e704b0
	if !ctx.cr[6].eq {
	pc = 0x82E704B0; continue 'dispatch;
	}
	// 82E704A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E704AC: 480001BC  b 0x82e70668
	pc = 0x82E70668; continue 'dispatch;
	// 82E704B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E704B4: 4834BBAD  bl 0x831bc060
	ctx.lr = 0x82E704B8;
	sub_831BC060(ctx, base);
	// 82E704B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E704BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E704C0: 388B87E8  addi r4, r11, -0x7818
	ctx.r[4].s64 = ctx.r[11].s64 + -30744;
	// 82E704C4: 4BE3C68D  bl 0x82cacb50
	ctx.lr = 0x82E704C8;
	sub_82CACB50(ctx, base);
	// 82E704C8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E704CC: 4082004C  bne 0x82e70518
	if !ctx.cr[0].eq {
	pc = 0x82E70518; continue 'dispatch;
	}
	// 82E704D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E704D4: 4BA9D835  bl 0x8290dd08
	ctx.lr = 0x82E704D8;
	sub_8290DD08(ctx, base);
	// 82E704D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E704DC: 41820180  beq 0x82e7065c
	if ctx.cr[0].eq {
	pc = 0x82E7065C; continue 'dispatch;
	}
	// 82E704E0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E704E4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E704E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E704EC: 4182000C  beq 0x82e704f8
	if ctx.cr[0].eq {
	pc = 0x82E704F8; continue 'dispatch;
	}
	// 82E704F0: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E704F4: 4800000C  b 0x82e70500
	pc = 0x82E70500; continue 'dispatch;
	// 82E704F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E704FC: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E70500: 4BE3B6B1  bl 0x82cabbb0
	ctx.lr = 0x82E70504;
	sub_82CABBB0(ctx, base);
	// 82E70504: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E70508: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E7050C: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E70510: D01D0010  stfs f0, 0x10(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E70514: 48000154  b 0x82e70668
	pc = 0x82E70668; continue 'dispatch;
	// 82E70518: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E7051C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E70520: 388B87D8  addi r4, r11, -0x7828
	ctx.r[4].s64 = ctx.r[11].s64 + -30760;
	// 82E70524: 4BE3C62D  bl 0x82cacb50
	ctx.lr = 0x82E70528;
	sub_82CACB50(ctx, base);
	// 82E70528: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E7052C: 40820028  bne 0x82e70554
	if !ctx.cr[0].eq {
	pc = 0x82E70554; continue 'dispatch;
	}
	// 82E70530: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E70534: 4BA9D7D5  bl 0x8290dd08
	ctx.lr = 0x82E70538;
	sub_8290DD08(ctx, base);
	// 82E70538: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7053C: 41820120  beq 0x82e7065c
	if ctx.cr[0].eq {
	pc = 0x82E7065C; continue 'dispatch;
	}
	// 82E70540: 4BE3B671  bl 0x82cabbb0
	ctx.lr = 0x82E70544;
	sub_82CABBB0(ctx, base);
	// 82E70544: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E70548: D01D0014  stfs f0, 0x14(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E7054C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E70550: 48000118  b 0x82e70668
	pc = 0x82E70668; continue 'dispatch;
	// 82E70554: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82E70558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7055C: 388B4F80  addi r4, r11, 0x4f80
	ctx.r[4].s64 = ctx.r[11].s64 + 20352;
	// 82E70560: 4BE3C5F1  bl 0x82cacb50
	ctx.lr = 0x82E70564;
	sub_82CACB50(ctx, base);
	// 82E70564: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E70568: 40820030  bne 0x82e70598
	if !ctx.cr[0].eq {
	pc = 0x82E70598; continue 'dispatch;
	}
	// 82E7056C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E70570: 4BA9D799  bl 0x8290dd08
	ctx.lr = 0x82E70574;
	sub_8290DD08(ctx, base);
	// 82E70574: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82E70578: 418200E4  beq 0x82e7065c
	if ctx.cr[0].eq {
	pc = 0x82E7065C; continue 'dispatch;
	}
	// 82E7057C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E70580: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E70584: 48013285  bl 0x82e83808
	ctx.lr = 0x82E70588;
	sub_82E83808(ctx, base);
	// 82E70588: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E7058C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E70590: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E70594: 480000D4  b 0x82e70668
	pc = 0x82E70668; continue 'dispatch;
	// 82E70598: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E7059C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E705A0: 388B87C0  addi r4, r11, -0x7840
	ctx.r[4].s64 = ctx.r[11].s64 + -30784;
	// 82E705A4: 4BE3C5AD  bl 0x82cacb50
	ctx.lr = 0x82E705A8;
	sub_82CACB50(ctx, base);
	// 82E705A8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E705AC: 4082004C  bne 0x82e705f8
	if !ctx.cr[0].eq {
	pc = 0x82E705F8; continue 'dispatch;
	}
	// 82E705B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E705B4: 4BA9D755  bl 0x8290dd08
	ctx.lr = 0x82E705B8;
	sub_8290DD08(ctx, base);
	// 82E705B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E705BC: 418200A0  beq 0x82e7065c
	if ctx.cr[0].eq {
	pc = 0x82E7065C; continue 'dispatch;
	}
	// 82E705C0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E705C4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E705C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E705CC: 4182000C  beq 0x82e705d8
	if ctx.cr[0].eq {
	pc = 0x82E705D8; continue 'dispatch;
	}
	// 82E705D0: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E705D4: 4800000C  b 0x82e705e0
	pc = 0x82E705E0; continue 'dispatch;
	// 82E705D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E705DC: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E705E0: 4BE3B5D1  bl 0x82cabbb0
	ctx.lr = 0x82E705E4;
	sub_82CABBB0(ctx, base);
	// 82E705E4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E705E8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E705EC: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E705F0: D01D00B4  stfs f0, 0xb4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82E705F4: 48000074  b 0x82e70668
	pc = 0x82E70668; continue 'dispatch;
	// 82E705F8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82E705FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E70600: 388B293C  addi r4, r11, 0x293c
	ctx.r[4].s64 = ctx.r[11].s64 + 10556;
	// 82E70604: 4BE3C54D  bl 0x82cacb50
	ctx.lr = 0x82E70608;
	sub_82CACB50(ctx, base);
	// 82E70608: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E7060C: 40820050  bne 0x82e7065c
	if !ctx.cr[0].eq {
	pc = 0x82E7065C; continue 'dispatch;
	}
	// 82E70610: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E70614: 4BA9D6F5  bl 0x8290dd08
	ctx.lr = 0x82E70618;
	sub_8290DD08(ctx, base);
	// 82E70618: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7061C: 41820040  beq 0x82e7065c
	if ctx.cr[0].eq {
	pc = 0x82E7065C; continue 'dispatch;
	}
	// 82E70620: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E70624: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E70628: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7062C: 4182000C  beq 0x82e70638
	if ctx.cr[0].eq {
	pc = 0x82E70638; continue 'dispatch;
	}
	// 82E70630: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E70634: 4800000C  b 0x82e70640
	pc = 0x82E70640; continue 'dispatch;
	// 82E70638: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E7063C: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E70640: 4BE3B571  bl 0x82cabbb0
	ctx.lr = 0x82E70644;
	sub_82CABBB0(ctx, base);
	// 82E70644: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E70648: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E7064C: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E70650: 4B377EA9  bl 0x821e84f8
	ctx.lr = 0x82E70654;
	sub_821E84F8(ctx, base);
	// 82E70654: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E70658: 48000010  b 0x82e70668
	pc = 0x82E70668; continue 'dispatch;
	// 82E7065C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E70660: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E70664: 4BFFF835  bl 0x82e6fe98
	ctx.lr = 0x82E70668;
	sub_82E6FE98(ctx, base);
	// 82E70668: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E7066C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82E70670: 4BE38DEC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E70678 size=176
    let mut pc: u32 = 0x82E70678;
    'dispatch: loop {
        match pc {
            0x82E70678 => {
    //   block [0x82E70678..0x82E70728)
	// 82E70678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7067C: 4BE38D91  bl 0x82ca940c
	ctx.lr = 0x82E70680;
	sub_82CA93D0(ctx, base);
	// 82E70680: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E70684: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E70688: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E7068C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E70690: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E70694: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E70698: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E7069C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82E706A0: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82E706A4: 995F00B0  stb r10, 0xb0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[10].u8 ) };
	// 82E706A8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82E706AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E706B0: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E706B4: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E706B8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E706BC: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E706C0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E706C4: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E706C8: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82E706CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E706D0: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82E706D4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82E706D8: 4200FFF8  bdnz 0x82e706d0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E706D0; continue 'dispatch;
	}
	// 82E706DC: 3BBF0044  addi r29, r31, 0x44
	ctx.r[29].s64 = ctx.r[31].s64 + 68;
	// 82E706E0: 9BC100A8  stb r30, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[30].u8 ) };
	// 82E706E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E706E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E706EC: 4BFFF80D  bl 0x82e6fef8
	ctx.lr = 0x82E706F0;
	sub_82E6FEF8(ctx, base);
	// 82E706F0: 389F00A0  addi r4, r31, 0xa0
	ctx.r[4].s64 = ctx.r[31].s64 + 160;
	// 82E706F4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E706F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E706FC: 93C40004  stw r30, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82E70700: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E70704: 4B33DFA5  bl 0x821ae6a8
	ctx.lr = 0x82E70708;
	sub_821AE6A8(ctx, base);
	// 82E70708: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E7070C: 9BDF00B1  stb r30, 0xb1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(177 as u32), ctx.r[30].u8 ) };
	// 82E70710: 9BDF00B2  stb r30, 0xb2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(178 as u32), ctx.r[30].u8 ) };
	// 82E70714: 9BDF00B3  stb r30, 0xb3(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(179 as u32), ctx.r[30].u8 ) };
	// 82E70718: C00B0EE0  lfs f0, 0xee0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7071C: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82E70720: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82E70724: 4BE38D38  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E70728 size=504
    let mut pc: u32 = 0x82E70728;
    'dispatch: loop {
        match pc {
            0x82E70728 => {
    //   block [0x82E70728..0x82E70920)
	// 82E70728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7072C: 4BE38CDD  bl 0x82ca9408
	ctx.lr = 0x82E70730;
	sub_82CA93D0(ctx, base);
	// 82E70730: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82E70734: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E70738: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E7073C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E70740: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70744: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E70748: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82E7074C: 419A0168  beq cr6, 0x82e708b4
	if ctx.cr[6].eq {
	pc = 0x82E708B4; continue 'dispatch;
	}
	// 82E70750: 3BBF0048  addi r29, r31, 0x48
	ctx.r[29].s64 = ctx.r[31].s64 + 72;
	// 82E70754: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E70758: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E7075C: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70760: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E70764: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70768: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E7076C: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70770: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E70774: 4BFFF875  bl 0x82e6ffe8
	ctx.lr = 0x82E70778;
	sub_82E6FFE8(ctx, base);
	// 82E70778: 3BDF0044  addi r30, r31, 0x44
	ctx.r[30].s64 = ctx.r[31].s64 + 68;
	// 82E7077C: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70780: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E70784: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E70788: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 82E7078C: 394B9128  addi r10, r11, -0x6ed8
	ctx.r[10].s64 = ctx.r[11].s64 + -28376;
	// 82E70790: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E70794: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82E70798: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7079C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82E707A0: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E707A4: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E707A8: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E707AC: 9B9E0058  stb r28, 0x58(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[28].u8 ) };
	// 82E707B0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E707B4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E707B8: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82E707BC: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E707C0: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82E707C4: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E707C8: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82E707CC: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E707D0: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82E707D4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82E707D8: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82E707DC: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82E707E0: 4200FFF8  bdnz 0x82e707d8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E707D8; continue 'dispatch;
	}
	// 82E707E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E707E8: 9B8100C8  stb r28, 0xc8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[28].u8 ) };
	// 82E707EC: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82E707F0: 4B33C261  bl 0x821aca50
	ctx.lr = 0x82E707F4;
	sub_821ACA50(ctx, base);
	// 82E707F4: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E707F8: 38A10130  addi r5, r1, 0x130
	ctx.r[5].s64 = ctx.r[1].s64 + 304;
	// 82E707FC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82E70800: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E70804: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82E70808: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E7080C: 4E800421  bctrl
	ctx.lr = 0x82E70810;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E70810: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E70814: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E70818: 4082004C  bne 0x82e70864
	if !ctx.cr[0].eq {
	pc = 0x82E70864; continue 'dispatch;
	}
	// 82E7081C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E70820: 41820014  beq 0x82e70834
	if ctx.cr[0].eq {
	pc = 0x82E70834; continue 'dispatch;
	}
	// 82E70824: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E70828: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E7082C: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E70830: 48057BD1  bl 0x82ec8400
	ctx.lr = 0x82E70834;
	sub_82EC8400(ctx, base);
	// 82E70834: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E70838: 389F00A0  addi r4, r31, 0xa0
	ctx.r[4].s64 = ctx.r[31].s64 + 160;
	// 82E7083C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E70840: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70844: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E70848: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7084C: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E70850: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70854: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E70858: 9B9E0058  stb r28, 0x58(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[28].u8 ) };
	// 82E7085C: 4B33DE4D  bl 0x821ae6a8
	ctx.lr = 0x82E70860;
	sub_821AE6A8(ctx, base);
	// 82E70860: 480000AC  b 0x82e7090c
	pc = 0x82E7090C; continue 'dispatch;
	// 82E70864: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E70868: 418200AC  beq 0x82e70914
	if ctx.cr[0].eq {
	pc = 0x82E70914; continue 'dispatch;
	}
	// 82E7086C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E70870: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E70874: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E70878: 48057B89  bl 0x82ec8400
	ctx.lr = 0x82E7087C;
	sub_82EC8400(ctx, base);
	// 82E7087C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E70880: C03F0040  lfs f1, 0x40(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E70884: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E70888: 480583B9  bl 0x82ec8c40
	ctx.lr = 0x82E7088C;
	sub_82EC8C40(ctx, base);
	// 82E7088C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E70890: 4082FFA4  bne 0x82e70834
	if !ctx.cr[0].eq {
	pc = 0x82E70834; continue 'dispatch;
	}
	// 82E70894: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E70898: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E7089C: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E708A0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E708A4: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E708A8: 4B438971  bl 0x822a9218
	ctx.lr = 0x82E708AC;
	sub_822A9218(ctx, base);
	// 82E708AC: 9B9F00B2  stb r28, 0xb2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(178 as u32), ctx.r[28].u8 ) };
	// 82E708B0: 48000064  b 0x82e70914
	pc = 0x82E70914; continue 'dispatch;
	// 82E708B4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E708B8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82E708BC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E708C0: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82E708C4: 392100E0  addi r9, r1, 0xe0
	ctx.r[9].s64 = ctx.r[1].s64 + 224;
	// 82E708C8: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82E708CC: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E708D0: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82E708D4: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E708D8: 914100D0  stw r10, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 82E708DC: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82E708E0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82E708E4: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E708E8: D00100DC  stfs f0, 0xdc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82E708EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E708F0: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82E708F4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82E708F8: 4200FFF8  bdnz 0x82e708f0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E708F0; continue 'dispatch;
	}
	// 82E708FC: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82E70900: 9B810128  stb r28, 0x128(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), ctx.r[28].u8 ) };
	// 82E70904: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 82E70908: 4BFFF5F1  bl 0x82e6fef8
	ctx.lr = 0x82E7090C;
	sub_82E6FEF8(ctx, base);
	// 82E7090C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E70910: 997F00B2  stb r11, 0xb2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(178 as u32), ctx.r[11].u8 ) };
	// 82E70914: 382101C0  addi r1, r1, 0x1c0
	ctx.r[1].s64 = ctx.r[1].s64 + 448;
	// 82E70918: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82E7091C: 4BE38B3C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E70920 size=748
    let mut pc: u32 = 0x82E70920;
    'dispatch: loop {
        match pc {
            0x82E70920 => {
    //   block [0x82E70920..0x82E70C0C)
	// 82E70920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E70924: 4BE38AE5  bl 0x82ca9408
	ctx.lr = 0x82E70928;
	sub_82CA93D0(ctx, base);
	// 82E70928: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82E7092C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E70930: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E70934: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E70938: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E7093C: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E70940: 418202C0  beq 0x82e70c00
	if ctx.cr[0].eq {
	pc = 0x82E70C00; continue 'dispatch;
	}
	// 82E70944: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E70948: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E7094C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E70950: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E70954: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82E70958: C00A0C18  lfs f0, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7095C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82E70960: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E70964: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E70968: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E7096C: 9BDF00B0  stb r30, 0xb0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[30].u8 ) };
	// 82E70970: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82E70974: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82E70978: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E7097C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E70980: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82E70984: 4200FFF8  bdnz 0x82e7097c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E7097C; continue 'dispatch;
	}
	// 82E70988: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E7098C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E70990: 9BC100A8  stb r30, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[30].u8 ) };
	// 82E70994: 38880034  addi r4, r8, 0x34
	ctx.r[4].s64 = ctx.r[8].s64 + 52;
	// 82E70998: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E7099C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E709A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E709A4: 4E800421  bctrl
	ctx.lr = 0x82E709A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E709A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E709AC: 40820040  bne 0x82e709ec
	if !ctx.cr[0].eq {
	pc = 0x82E709EC; continue 'dispatch;
	}
	// 82E709B0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E709B4: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 82E709B8: 389F00A0  addi r4, r31, 0xa0
	ctx.r[4].s64 = ctx.r[31].s64 + 160;
	// 82E709BC: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82E709C0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E709C4: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E709C8: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E709CC: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E709D0: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E709D4: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E709D8: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E709DC: 9BC30058  stb r30, 0x58(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82E709E0: 93C40004  stw r30, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82E709E4: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E709E8: 48000214  b 0x82e70bfc
	pc = 0x82E70BFC; continue 'dispatch;
	// 82E709EC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E709F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E709F4: 388B60C0  addi r4, r11, 0x60c0
	ctx.r[4].s64 = ctx.r[11].s64 + 24768;
	// 82E709F8: 48018CE9  bl 0x82e896e0
	ctx.lr = 0x82E709FC;
	sub_82E896E0(ctx, base);
	// 82E709FC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E70A00: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E70A04: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E70A08: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E70A0C: 38AA0034  addi r5, r10, 0x34
	ctx.r[5].s64 = ctx.r[10].s64 + 52;
	// 82E70A10: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82E70A14: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E70A18: 816A0050  lwz r11, 0x50(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E70A1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E70A20: 4E800421  bctrl
	ctx.lr = 0x82E70A24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E70A24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E70A28: 40820060  bne 0x82e70a88
	if !ctx.cr[0].eq {
	pc = 0x82E70A88; continue 'dispatch;
	}
	// 82E70A2C: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 82E70A30: C0010054  lfs f0, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70A34: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E70A38: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E70A3C: C181005C  lfs f12, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E70A40: 389F00A0  addi r4, r31, 0xa0
	ctx.r[4].s64 = ctx.r[31].s64 + 160;
	// 82E70A44: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E70A48: D1A30008  stfs f13, 8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E70A4C: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E70A50: 9BC30058  stb r30, 0x58(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82E70A54: 419A0018  beq cr6, 0x82e70a6c
	if ctx.cr[6].eq {
	pc = 0x82E70A6C; continue 'dispatch;
	}
	// 82E70A58: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E70A5C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82E70A60: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E70A64: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E70A68: 48000010  b 0x82e70a78
	pc = 0x82E70A78; continue 'dispatch;
	// 82E70A6C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E70A70: 93C40004  stw r30, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82E70A74: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E70A78: 4B33DC31  bl 0x821ae6a8
	ctx.lr = 0x82E70A7C;
	sub_821AE6A8(ctx, base);
	// 82E70A7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E70A80: 997F00B3  stb r11, 0xb3(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(179 as u32), ctx.r[11].u8 ) };
	// 82E70A84: 4800017C  b 0x82e70c00
	pc = 0x82E70C00; continue 'dispatch;
	// 82E70A88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E70A8C: 4BFFF505  bl 0x82e6ff90
	ctx.lr = 0x82E70A90;
	sub_82E6FF90(ctx, base);
	// 82E70A90: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E70A94: 4B3EFF25  bl 0x822609b8
	ctx.lr = 0x82E70A98;
	sub_822609B8(ctx, base);
	// 82E70A98: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70A9C: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E70AA0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E70AA4: 4198001C  blt cr6, 0x82e70ac0
	if ctx.cr[6].lt {
	pc = 0x82E70AC0; continue 'dispatch;
	}
	// 82E70AA8: 897F00B1  lbz r11, 0xb1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(177 as u32) ) } as u64;
	// 82E70AAC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E70AB0: 40820010  bne 0x82e70ac0
	if !ctx.cr[0].eq {
	pc = 0x82E70AC0; continue 'dispatch;
	}
	// 82E70AB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E70AB8: C1AB0BEC  lfs f13, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E70ABC: 4800003C  b 0x82e70af8
	pc = 0x82E70AF8; continue 'dispatch;
	// 82E70AC0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E70AC4: C01F0028  lfs f0, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70AC8: C1BF002C  lfs f13, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E70ACC: C18B0034  lfs f12, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E70AD0: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E70AD4: C16B0038  lfs f11, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E70AD8: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E70ADC: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E70AE0: C17F0030  lfs f11, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E70AE4: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E70AE8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E70AEC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E70AF0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E70AF4: EDA0002C  fsqrts f13, f0
	ctx.f[13].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E70AF8: 895F00B3  lbz r10, 0xb3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(179 as u32) ) } as u64;
	// 82E70AFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E70B00: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82E70B04: 409A000C  bne cr6, 0x82e70b10
	if !ctx.cr[6].eq {
	pc = 0x82E70B10; continue 'dispatch;
	}
	// 82E70B08: 997F00B0  stb r11, 0xb0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[11].u8 ) };
	// 82E70B0C: 9BDF00B3  stb r30, 0xb3(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(179 as u32), ctx.r[30].u8 ) };
	// 82E70B10: 895F00B1  lbz r10, 0xb1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(177 as u32) ) } as u64;
	// 82E70B14: C19F0010  lfs f12, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E70B18: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82E70B1C: 409A0030  bne cr6, 0x82e70b4c
	if !ctx.cr[6].eq {
	pc = 0x82E70B4C; continue 'dispatch;
	}
	// 82E70B20: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82E70B24: C00A8790  lfs f0, -0x7870(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70B28: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E70B2C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82E70B30: 4099000C  ble cr6, 0x82e70b3c
	if !ctx.cr[6].gt {
	pc = 0x82E70B3C; continue 'dispatch;
	}
	// 82E70B34: 9BDF00B1  stb r30, 0xb1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(177 as u32), ctx.r[30].u8 ) };
	// 82E70B38: 4800004C  b 0x82e70b84
	pc = 0x82E70B84; continue 'dispatch;
	// 82E70B3C: 578A063F  clrlwi. r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E70B40: 40820044  bne 0x82e70b84
	if !ctx.cr[0].eq {
	pc = 0x82E70B84; continue 'dispatch;
	}
	// 82E70B44: C01F00B4  lfs f0, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70B48: 48000034  b 0x82e70b7c
	pc = 0x82E70B7C; continue 'dispatch;
	// 82E70B4C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82E70B50: C00A878C  lfs f0, -0x7874(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30836 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70B54: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E70B58: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82E70B5C: 4098000C  bge cr6, 0x82e70b68
	if !ctx.cr[6].lt {
	pc = 0x82E70B68; continue 'dispatch;
	}
	// 82E70B60: 997F00B1  stb r11, 0xb1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(177 as u32), ctx.r[11].u8 ) };
	// 82E70B64: 48000020  b 0x82e70b84
	pc = 0x82E70B84; continue 'dispatch;
	// 82E70B68: 578A063F  clrlwi. r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E70B6C: 40820018  bne 0x82e70b84
	if !ctx.cr[0].eq {
	pc = 0x82E70B84; continue 'dispatch;
	}
	// 82E70B70: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82E70B74: C00A8794  lfs f0, -0x786c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30828 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70B78: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E70B7C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E70B80: 40990008  ble cr6, 0x82e70b88
	if !ctx.cr[6].gt {
	pc = 0x82E70B88; continue 'dispatch;
	}
	// 82E70B84: 997F00B0  stb r11, 0xb0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[11].u8 ) };
	// 82E70B88: 897F00B0  lbz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 82E70B8C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E70B90: 409A0070  bne cr6, 0x82e70c00
	if !ctx.cr[6].eq {
	pc = 0x82E70C00; continue 'dispatch;
	}
	// 82E70B94: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E70B98: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E70B9C: 389F00A0  addi r4, r31, 0xa0
	ctx.r[4].s64 = ctx.r[31].s64 + 160;
	// 82E70BA0: C00B004C  lfs f0, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70BA4: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82E70BA8: C00B0050  lfs f0, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70BAC: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82E70BB0: C00B0054  lfs f0, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70BB4: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82E70BB8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E70BBC: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70BC0: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82E70BC4: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70BC8: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82E70BCC: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70BD0: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82E70BD4: 419A0018  beq cr6, 0x82e70bec
	if ctx.cr[6].eq {
	pc = 0x82E70BEC; continue 'dispatch;
	}
	// 82E70BD8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E70BDC: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82E70BE0: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E70BE4: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E70BE8: 48000010  b 0x82e70bf8
	pc = 0x82E70BF8; continue 'dispatch;
	// 82E70BEC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E70BF0: 93C40004  stw r30, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82E70BF4: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E70BF8: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 82E70BFC: 4B33DAAD  bl 0x821ae6a8
	ctx.lr = 0x82E70C00;
	sub_821AE6A8(ctx, base);
	// 82E70C00: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82E70C04: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82E70C08: 4BE38850  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E70C10 size=72
    let mut pc: u32 = 0x82E70C10;
    'dispatch: loop {
        match pc {
            0x82E70C10 => {
    //   block [0x82E70C10..0x82E70C58)
	// 82E70C10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E70C14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E70C18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E70C1C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E70C20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E70C24: 386000B8  li r3, 0xb8
	ctx.r[3].s64 = 184;
	// 82E70C28: 4B7A5D01  bl 0x82616928
	ctx.lr = 0x82E70C2C;
	sub_82616928(ctx, base);
	// 82E70C2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E70C30: 41820010  beq 0x82e70c40
	if ctx.cr[0].eq {
	pc = 0x82E70C40; continue 'dispatch;
	}
	// 82E70C34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E70C38: 4BFFF509  bl 0x82e70140
	ctx.lr = 0x82E70C3C;
	sub_82E70140(ctx, base);
	// 82E70C3C: 48000008  b 0x82e70c44
	pc = 0x82E70C44; continue 'dispatch;
	// 82E70C40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E70C44: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E70C48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E70C4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E70C50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E70C54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E70C58 size=196
    let mut pc: u32 = 0x82E70C58;
    'dispatch: loop {
        match pc {
            0x82E70C58 => {
    //   block [0x82E70C58..0x82E70D1C)
	// 82E70C58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E70C5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E70C60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E70C64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E70C68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E70C6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E70C70: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E70C74: 396B299C  addi r11, r11, 0x299c
	ctx.r[11].s64 = ctx.r[11].s64 + 10652;
	// 82E70C78: 809F002C  lwz r4, 0x2c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E70C7C: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E70C80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E70C84: 4182001C  beq 0x82e70ca0
	if ctx.cr[0].eq {
	pc = 0x82E70CA0; continue 'dispatch;
	}
	// 82E70C88: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E70C8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E70C90: 41820010  beq 0x82e70ca0
	if ctx.cr[0].eq {
	pc = 0x82E70CA0; continue 'dispatch;
	}
	// 82E70C94: 4801C91D  bl 0x82e8d5b0
	ctx.lr = 0x82E70C98;
	sub_82E8D5B0(ctx, base);
	// 82E70C98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E70C9C: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82E70CA0: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82E70CA4: 3FC08330  lis r30, -0x7cd0
	ctx.r[30].s64 = -2094006272;
	// 82E70CA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E70CAC: 41820010  beq 0x82e70cbc
	if ctx.cr[0].eq {
	pc = 0x82E70CBC; continue 'dispatch;
	}
	// 82E70CB0: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E70CB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E70CB8: 4E800421  bctrl
	ctx.lr = 0x82E70CBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E70CBC: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82E70CC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E70CC4: 41820010  beq 0x82e70cd4
	if ctx.cr[0].eq {
	pc = 0x82E70CD4; continue 'dispatch;
	}
	// 82E70CC8: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E70CCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E70CD0: 4E800421  bctrl
	ctx.lr = 0x82E70CD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E70CD4: 807F019C  lwz r3, 0x19c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82E70CD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E70CDC: 41820010  beq 0x82e70cec
	if ctx.cr[0].eq {
	pc = 0x82E70CEC; continue 'dispatch;
	}
	// 82E70CE0: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E70CE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E70CE8: 4E800421  bctrl
	ctx.lr = 0x82E70CEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E70CEC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E70CF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E70CF4: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E70CF8: 917F01C0  stw r11, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[11].u32 ) };
	// 82E70CFC: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82E70D00: 480184F9  bl 0x82e891f8
	ctx.lr = 0x82E70D04;
	sub_82E891F8(ctx, base);
	// 82E70D04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E70D08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E70D0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E70D10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E70D14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E70D18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E70D20 size=12
    let mut pc: u32 = 0x82E70D20;
    'dispatch: loop {
        match pc {
            0x82E70D20 => {
    //   block [0x82E70D20..0x82E70D2C)
	// 82E70D20: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E70D24: 386BB8D4  addi r3, r11, -0x472c
	ctx.r[3].s64 = ctx.r[11].s64 + -18220;
	// 82E70D28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E70D30 size=148
    let mut pc: u32 = 0x82E70D30;
    'dispatch: loop {
        match pc {
            0x82E70D30 => {
    //   block [0x82E70D30..0x82E70DC4)
	// 82E70D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E70D34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E70D38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E70D3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E70D40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E70D44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E70D48: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E70D4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E70D50: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E70D54: 93DF01CC  stw r30, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[30].u32 ) };
	// 82E70D58: 9BDF01E0  stb r30, 0x1e0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[30].u8 ) };
	// 82E70D5C: C00B0EE0  lfs f0, 0xee0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70D60: 9BDF01E1  stb r30, 0x1e1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(481 as u32), ctx.r[30].u8 ) };
	// 82E70D64: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E70D68: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E70D6C: D1BF01B4  stfs f13, 0x1b4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 82E70D70: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E70D74: D1BF01B8  stfs f13, 0x1b8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 82E70D78: C1AB003C  lfs f13, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E70D7C: D1BF01BC  stfs f13, 0x1bc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), tmp.u32 ) };
	// 82E70D80: 809F002C  lwz r4, 0x2c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E70D84: D01F01D0  stfs f0, 0x1d0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 82E70D88: 93DF01AC  stw r30, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[30].u32 ) };
	// 82E70D8C: 9BDF01B0  stb r30, 0x1b0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[30].u8 ) };
	// 82E70D90: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E70D94: 41820018  beq 0x82e70dac
	if ctx.cr[0].eq {
	pc = 0x82E70DAC; continue 'dispatch;
	}
	// 82E70D98: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E70D9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E70DA0: 4182000C  beq 0x82e70dac
	if ctx.cr[0].eq {
	pc = 0x82E70DAC; continue 'dispatch;
	}
	// 82E70DA4: 4801C80D  bl 0x82e8d5b0
	ctx.lr = 0x82E70DA8;
	sub_82E8D5B0(ctx, base);
	// 82E70DA8: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 82E70DAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E70DB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E70DB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E70DB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E70DBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E70DC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E70DC8 size=60
    let mut pc: u32 = 0x82E70DC8;
    'dispatch: loop {
        match pc {
            0x82E70DC8 => {
    //   block [0x82E70DC8..0x82E70E04)
	// 82E70DC8: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E70DCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E70DD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E70DD4: 409A0008  bne cr6, 0x82e70ddc
	if !ctx.cr[6].eq {
	pc = 0x82E70DDC; continue 'dispatch;
	}
	// 82E70DD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E70DDC: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E70DE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E70DE4: 409A0008  bne cr6, 0x82e70dec
	if !ctx.cr[6].eq {
	pc = 0x82E70DEC; continue 'dispatch;
	}
	// 82E70DE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E70DEC: 81430030  lwz r10, 0x30(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E70DF0: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82E70DF4: 409A0008  bne cr6, 0x82e70dfc
	if !ctx.cr[6].eq {
	pc = 0x82E70DFC; continue 'dispatch;
	}
	// 82E70DF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E70DFC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E70E00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E70E08 size=44
    let mut pc: u32 = 0x82E70E08;
    'dispatch: loop {
        match pc {
            0x82E70E08 => {
    //   block [0x82E70E08..0x82E70E34)
	// 82E70E08: 814301DC  lwz r10, 0x1dc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(476 as u32) ) } as u64;
	// 82E70E0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E70E10: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82E70E14: 409A0008  bne cr6, 0x82e70e1c
	if !ctx.cr[6].eq {
	pc = 0x82E70E1C; continue 'dispatch;
	}
	// 82E70E18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E70E1C: 814301D8  lwz r10, 0x1d8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(472 as u32) ) } as u64;
	// 82E70E20: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82E70E24: 409A0008  bne cr6, 0x82e70e2c
	if !ctx.cr[6].eq {
	pc = 0x82E70E2C; continue 'dispatch;
	}
	// 82E70E28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E70E2C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E70E30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E70E38 size=28
    let mut pc: u32 = 0x82E70E38;
    'dispatch: loop {
        match pc {
            0x82E70E38 => {
    //   block [0x82E70E38..0x82E70E54)
	// 82E70E38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E70E3C: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82E70E40: 812B0198  lwz r9, 0x198(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) } as u64;
	// 82E70E44: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E70E48: 4198000C  blt cr6, 0x82e70e54
	if ctx.cr[6].lt {
		sub_82E70E54(ctx, base);
		return;
	}
	// 82E70E4C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E70E50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70E54(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E70E54 size=76
    let mut pc: u32 = 0x82E70E54;
    'dispatch: loop {
        match pc {
            0x82E70E54 => {
    //   block [0x82E70E54..0x82E70EA0)
	// 82E70E54: 812B018C  lwz r9, 0x18c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(396 as u32) ) } as u64;
	// 82E70E58: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 * 12;
	// 82E70E5C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E70E60: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70E64: EDA10072  fmuls f13, f1, f1
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[1].f64) as f32) as f64);
	// 82E70E68: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E70E6C: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E70E70: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70E74: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E70E78: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70E7C: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E70E80: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82E70E84: 812B0190  lwz r9, 0x190(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(400 as u32) ) } as u64;
	// 82E70E88: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E70E8C: 7DAA4D2E  stfsx f13, r10, r9
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82E70E90: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82E70E94: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E70E98: 914B0194  stw r10, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[10].u32 ) };
	// 82E70E9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E70EA0 size=24
    let mut pc: u32 = 0x82E70EA0;
    'dispatch: loop {
        match pc {
            0x82E70EA0 => {
    //   block [0x82E70EA0..0x82E70EB8)
	// 82E70EA0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82E70EA4: 816A0194  lwz r11, 0x194(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(404 as u32) ) } as u64;
	// 82E70EA8: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E70EAC: 4198000C  blt cr6, 0x82e70eb8
	if ctx.cr[6].lt {
		sub_82E70EB8(ctx, base);
		return;
	}
	// 82E70EB0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E70EB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E70EB8 size=60
    let mut pc: u32 = 0x82E70EB8;
    'dispatch: loop {
        match pc {
            0x82E70EB8 => {
    //   block [0x82E70EB8..0x82E70EF4)
	// 82E70EB8: 816A018C  lwz r11, 0x18c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(396 as u32) ) } as u64;
	// 82E70EBC: 1D24000C  mulli r9, r4, 0xc
	ctx.r[9].s64 = ctx.r[4].s64 * 12;
	// 82E70EC0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82E70EC4: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E70EC8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E70ECC: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70ED0: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E70ED4: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70ED8: D0050004  stfs f0, 4(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E70EDC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70EE0: D0050008  stfs f0, 8(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E70EE4: 816A0190  lwz r11, 0x190(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(400 as u32) ) } as u64;
	// 82E70EE8: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E70EEC: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E70EF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E70EF8 size=28
    let mut pc: u32 = 0x82E70EF8;
    'dispatch: loop {
        match pc {
            0x82E70EF8 => {
    //   block [0x82E70EF8..0x82E70F14)
	// 82E70EF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E70EFC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E70F00: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E70F04: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E70F08: 409A000C  bne cr6, 0x82e70f14
	if !ctx.cr[6].eq {
		sub_82E70F14(ctx, base);
		return;
	}
	// 82E70F0C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E70F10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70F14(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E70F14 size=48
    let mut pc: u32 = 0x82E70F14;
    'dispatch: loop {
        match pc {
            0x82E70F14 => {
    //   block [0x82E70F14..0x82E70F44)
	// 82E70F14: 814B01A0  lwz r10, 0x1a0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(416 as u32) ) } as u64;
	// 82E70F18: 812B01A4  lwz r9, 0x1a4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(420 as u32) ) } as u64;
	// 82E70F1C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E70F20: 4098FFEC  bge cr6, 0x82e70f0c
	if !ctx.cr[6].lt {
		sub_82E70EF8(ctx, base);
		return;
	}
	// 82E70F24: 812B019C  lwz r9, 0x19c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(412 as u32) ) } as u64;
	// 82E70F28: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E70F2C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E70F30: 7C8A492E  stwx r4, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[4].u32) };
	// 82E70F34: 814B01A0  lwz r10, 0x1a0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(416 as u32) ) } as u64;
	// 82E70F38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E70F3C: 914B01A0  stw r10, 0x1a0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(416 as u32), ctx.r[10].u32 ) };
	// 82E70F40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E70F48 size=12
    let mut pc: u32 = 0x82E70F48;
    'dispatch: loop {
        match pc {
            0x82E70F48 => {
    //   block [0x82E70F48..0x82E70F54)
	// 82E70F48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E70F4C: 916301A0  stw r11, 0x1a0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(416 as u32), ctx.r[11].u32 ) };
	// 82E70F50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E70F58 size=100
    let mut pc: u32 = 0x82E70F58;
    'dispatch: loop {
        match pc {
            0x82E70F58 => {
    //   block [0x82E70F58..0x82E70FBC)
	// 82E70F58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E70F5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E70F60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E70F64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E70F68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E70F6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E70F70: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E70F74: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82E70F78: 909F01EC  stw r4, 0x1ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(492 as u32), ctx.r[4].u32 ) };
	// 82E70F7C: 90BF01F0  stw r5, 0x1f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), ctx.r[5].u32 ) };
	// 82E70F80: 93DF01AC  stw r30, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[30].u32 ) };
	// 82E70F84: 419A0008  beq cr6, 0x82e70f8c
	if ctx.cr[6].eq {
	pc = 0x82E70F8C; continue 'dispatch;
	}
	// 82E70F88: 9BDF01E0  stb r30, 0x1e0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[30].u8 ) };
	// 82E70F8C: 809F002C  lwz r4, 0x2c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E70F90: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E70F94: 41820010  beq 0x82e70fa4
	if ctx.cr[0].eq {
	pc = 0x82E70FA4; continue 'dispatch;
	}
	// 82E70F98: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E70F9C: 4801C615  bl 0x82e8d5b0
	ctx.lr = 0x82E70FA0;
	sub_82E8D5B0(ctx, base);
	// 82E70FA0: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 82E70FA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E70FA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E70FAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E70FB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E70FB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E70FB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E70FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E70FC0 size=92
    let mut pc: u32 = 0x82E70FC0;
    'dispatch: loop {
        match pc {
            0x82E70FC0 => {
    //   block [0x82E70FC0..0x82E7101C)
	// 82E70FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E70FC4: 4BE38449  bl 0x82ca940c
	ctx.lr = 0x82E70FC8;
	sub_82CA93D0(ctx, base);
	// 82E70FC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E70FCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E70FD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E70FD4: 809F002C  lwz r4, 0x2c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E70FD8: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E70FDC: 4182000C  beq 0x82e70fe8
	if ctx.cr[0].eq {
	pc = 0x82E70FE8; continue 'dispatch;
	}
	// 82E70FE0: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E70FE4: 4801C5CD  bl 0x82e8d5b0
	ctx.lr = 0x82E70FE8;
	sub_82E8D5B0(ctx, base);
	// 82E70FE8: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E70FEC: 40820020  bne 0x82e7100c
	if !ctx.cr[0].eq {
	pc = 0x82E7100C; continue 'dispatch;
	}
	// 82E70FF0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E70FF4: 83DF01D8  lwz r30, 0x1d8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) } as u64;
	// 82E70FF8: 83AB0014  lwz r29, 0x14(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E70FFC: 4B3EF9BD  bl 0x822609b8
	ctx.lr = 0x82E71000;
	sub_822609B8(ctx, base);
	// 82E71000: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E71004: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E71008: 48010A69  bl 0x82e81a70
	ctx.lr = 0x82E7100C;
	sub_82E81A70(ctx, base);
	// 82E7100C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E71010: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82E71014: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E71018: 4BE38444  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E71020 size=84
    let mut pc: u32 = 0x82E71020;
    'dispatch: loop {
        match pc {
            0x82E71020 => {
    //   block [0x82E71020..0x82E71074)
	// 82E71020: 81640064  lwz r11, 0x64(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E71024: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E71028: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E7102C: 409A0040  bne cr6, 0x82e7106c
	if !ctx.cr[6].eq {
	pc = 0x82E7106C; continue 'dispatch;
	}
	// 82E71030: 81050064  lwz r8, 0x64(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E71034: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E71038: 41820034  beq 0x82e7106c
	if ctx.cr[0].eq {
	pc = 0x82E7106C; continue 'dispatch;
	}
	// 82E7103C: 81230078  lwz r9, 0x78(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E71040: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E71044: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71048: 41820024  beq 0x82e7106c
	if ctx.cr[0].eq {
	pc = 0x82E7106C; continue 'dispatch;
	}
	// 82E7104C: 81630070  lwz r11, 0x70(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 82E71050: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E71054: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82E71058: 419A001C  beq cr6, 0x82e71074
	if ctx.cr[6].eq {
		sub_82E71074(ctx, base);
		return;
	}
	// 82E7105C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E71060: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E71064: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E71068: 4198FFE8  blt cr6, 0x82e71050
	if ctx.cr[6].lt {
	pc = 0x82E71050; continue 'dispatch;
	}
	// 82E7106C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E71070: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71074(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E71074 size=8
    let mut pc: u32 = 0x82E71074;
    'dispatch: loop {
        match pc {
            0x82E71074 => {
    //   block [0x82E71074..0x82E7107C)
	// 82E71074: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E71078: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E71080 size=16
    let mut pc: u32 = 0x82E71080;
    'dispatch: loop {
        match pc {
            0x82E71080 => {
    //   block [0x82E71080..0x82E71090)
	// 82E71080: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E71084: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E71088: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E7108C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E71090 size=212
    let mut pc: u32 = 0x82E71090;
    'dispatch: loop {
        match pc {
            0x82E71090 => {
    //   block [0x82E71090..0x82E71164)
	// 82E71090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E71094: 4BE38379  bl 0x82ca940c
	ctx.lr = 0x82E71098;
	sub_82CA93D0(ctx, base);
	// 82E71098: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7109C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E710A0: 48018139  bl 0x82e891d8
	ctx.lr = 0x82E710A4;
	sub_82E891D8(ctx, base);
	// 82E710A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E710A8: 396B299C  addi r11, r11, 0x299c
	ctx.r[11].s64 = ctx.r[11].s64 + 10652;
	// 82E710AC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E710B0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E710B4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E710B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E710BC: 4182000C  beq 0x82e710c8
	if ctx.cr[0].eq {
	pc = 0x82E710C8; continue 'dispatch;
	}
	// 82E710C0: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E710C4: 4800000C  b 0x82e710d0
	pc = 0x82E710D0; continue 'dispatch;
	// 82E710C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E710CC: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E710D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E710D4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E710D8: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 82E710DC: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 82E710E0: C00B0AEC  lfs f0, 0xaec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2796 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E710E4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E710E8: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82E710EC: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E710F0: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82E710F4: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82E710F8: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82E710FC: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82E71100: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 82E71104: 93BF0030  stw r29, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[29].u32 ) };
	// 82E71108: 4801E079  bl 0x82e8f180
	ctx.lr = 0x82E7110C;
	sub_82E8F180(ctx, base);
	// 82E7110C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E71110: 93DF018C  stw r30, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[30].u32 ) };
	// 82E71114: 93DF0190  stw r30, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[30].u32 ) };
	// 82E71118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7111C: 93DF0194  stw r30, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[30].u32 ) };
	// 82E71120: 93DF0198  stw r30, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[30].u32 ) };
	// 82E71124: 93DF019C  stw r30, 0x19c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[30].u32 ) };
	// 82E71128: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7112C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E71130: 93DF01A0  stw r30, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[30].u32 ) };
	// 82E71134: 396B10BC  addi r11, r11, 0x10bc
	ctx.r[11].s64 = ctx.r[11].s64 + 4284;
	// 82E71138: 93DF01A4  stw r30, 0x1a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[30].u32 ) };
	// 82E7113C: D01F01B4  stfs f0, 0x1b4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 82E71140: D01F01B8  stfs f0, 0x1b8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 82E71144: D01F01BC  stfs f0, 0x1bc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), tmp.u32 ) };
	// 82E71148: 93DF01C4  stw r30, 0x1c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), ctx.r[30].u32 ) };
	// 82E7114C: 93BF01C8  stw r29, 0x1c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[29].u32 ) };
	// 82E71150: 917F01C0  stw r11, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[11].u32 ) };
	// 82E71154: 93DF01EC  stw r30, 0x1ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(492 as u32), ctx.r[30].u32 ) };
	// 82E71158: 93DF01F0  stw r30, 0x1f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), ctx.r[30].u32 ) };
	// 82E7115C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E71160: 4BE382FC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E71168 size=88
    let mut pc: u32 = 0x82E71168;
    'dispatch: loop {
        match pc {
            0x82E71168 => {
    //   block [0x82E71168..0x82E711C0)
	// 82E71168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7116C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E71170: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E71174: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E71178: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7117C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E71180: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E71184: 4BFFFAD5  bl 0x82e70c58
	ctx.lr = 0x82E71188;
	sub_82E70C58(ctx, base);
	// 82E71188: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E7118C: 41820018  beq 0x82e711a4
	if ctx.cr[0].eq {
	pc = 0x82E711A4; continue 'dispatch;
	}
	// 82E71190: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E71194: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71198: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E7119C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E711A0: 4E800421  bctrl
	ctx.lr = 0x82E711A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E711A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E711A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E711AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E711B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E711B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E711B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E711BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E711C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E711C0 size=268
    let mut pc: u32 = 0x82E711C0;
    'dispatch: loop {
        match pc {
            0x82E711C0 => {
    //   block [0x82E711C0..0x82E712CC)
	// 82E711C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E711C4: 4BE38245  bl 0x82ca9408
	ctx.lr = 0x82E711C8;
	sub_82CA93D0(ctx, base);
	// 82E711C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E711CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E711D0: 54AB063F  clrlwi. r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E711D4: 40820010  bne 0x82e711e4
	if !ctx.cr[0].eq {
	pc = 0x82E711E4; continue 'dispatch;
	}
	// 82E711D8: 817E0198  lwz r11, 0x198(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(408 as u32) ) } as u64;
	// 82E711DC: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E711E0: 409900E4  ble cr6, 0x82e712c4
	if !ctx.cr[6].gt {
	pc = 0x82E712C4; continue 'dispatch;
	}
	// 82E711E4: 807E018C  lwz r3, 0x18c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(396 as u32) ) } as u64;
	// 82E711E8: 3FE08330  lis r31, -0x7cd0
	ctx.r[31].s64 = -2094006272;
	// 82E711EC: 909E0198  stw r4, 0x198(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(408 as u32), ctx.r[4].u32 ) };
	// 82E711F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E711F4: 41820010  beq 0x82e71204
	if ctx.cr[0].eq {
	pc = 0x82E71204; continue 'dispatch;
	}
	// 82E711F8: 817FDAB4  lwz r11, -0x254c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E711FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E71200: 4E800421  bctrl
	ctx.lr = 0x82E71204;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E71204: 807E0190  lwz r3, 0x190(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(400 as u32) ) } as u64;
	// 82E71208: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7120C: 41820010  beq 0x82e7121c
	if ctx.cr[0].eq {
	pc = 0x82E7121C; continue 'dispatch;
	}
	// 82E71210: 817FDAB4  lwz r11, -0x254c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E71214: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E71218: 4E800421  bctrl
	ctx.lr = 0x82E7121C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E7121C: 83FE0198  lwz r31, 0x198(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(408 as u32) ) } as u64;
	// 82E71220: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71224: 40820014  bne 0x82e71238
	if !ctx.cr[0].eq {
	pc = 0x82E71238; continue 'dispatch;
	}
	// 82E71228: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E7122C: 93BE018C  stw r29, 0x18c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(396 as u32), ctx.r[29].u32 ) };
	// 82E71230: 93BE0190  stw r29, 0x190(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(400 as u32), ctx.r[29].u32 ) };
	// 82E71234: 4800008C  b 0x82e712c0
	pc = 0x82E712C0; continue 'dispatch;
	// 82E71238: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 82E7123C: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 82E71240: 616B5555  ori r11, r11, 0x5555
	ctx.r[11].u64 = ctx.r[11].u64 | 21845;
	// 82E71244: 1C7F000C  mulli r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 * 12;
	// 82E71248: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E7124C: 40990008  ble cr6, 0x82e71254
	if !ctx.cr[6].gt {
	pc = 0x82E71254; continue 'dispatch;
	}
	// 82E71250: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E71254: 4B7A56D5  bl 0x82616928
	ctx.lr = 0x82E71258;
	sub_82616928(ctx, base);
	// 82E71258: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E7125C: 7C6A1B79  or. r10, r3, r3
	ctx.r[10].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E71260: 41820034  beq 0x82e71294
	if ctx.cr[0].eq {
	pc = 0x82E71294; continue 'dispatch;
	}
	// 82E71264: 353FFFFF  addic. r9, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82E71268: 41800030  blt 0x82e71298
	if ctx.cr[0].lt {
	pc = 0x82E71298; continue 'dispatch;
	}
	// 82E7126C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82E71270: 396A0008  addi r11, r10, 8
	ctx.r[11].s64 = ctx.r[10].s64 + 8;
	// 82E71274: C0080C18  lfs f0, 0xc18(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E71278: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82E7127C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82E71280: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82E71284: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E71288: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82E7128C: 4080FFEC  bge 0x82e71278
	if !ctx.cr[0].lt {
	pc = 0x82E71278; continue 'dispatch;
	}
	// 82E71290: 48000008  b 0x82e71298
	pc = 0x82E71298; continue 'dispatch;
	// 82E71294: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82E71298: 3D203FFF  lis r9, 0x3fff
	ctx.r[9].s64 = 1073676288;
	// 82E7129C: 817E0198  lwz r11, 0x198(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(408 as u32) ) } as u64;
	// 82E712A0: 915E018C  stw r10, 0x18c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(396 as u32), ctx.r[10].u32 ) };
	// 82E712A4: 6129FFFF  ori r9, r9, 0xffff
	ctx.r[9].u64 = ctx.r[9].u64 | 65535;
	// 82E712A8: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82E712AC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E712B0: 40990008  ble cr6, 0x82e712b8
	if !ctx.cr[6].gt {
	pc = 0x82E712B8; continue 'dispatch;
	}
	// 82E712B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E712B8: 4B7A5671  bl 0x82616928
	ctx.lr = 0x82E712BC;
	sub_82616928(ctx, base);
	// 82E712BC: 907E0190  stw r3, 0x190(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(400 as u32), ctx.r[3].u32 ) };
	// 82E712C0: 93BE0194  stw r29, 0x194(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(404 as u32), ctx.r[29].u32 ) };
	// 82E712C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E712C8: 4BE38190  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E712D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E712D0 size=160
    let mut pc: u32 = 0x82E712D0;
    'dispatch: loop {
        match pc {
            0x82E712D0 => {
    //   block [0x82E712D0..0x82E71370)
	// 82E712D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E712D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E712D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E712DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E712E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E712E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E712E8: 54AB063F  clrlwi. r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E712EC: 40820010  bne 0x82e712fc
	if !ctx.cr[0].eq {
	pc = 0x82E712FC; continue 'dispatch;
	}
	// 82E712F0: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82E712F4: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E712F8: 40990060  ble cr6, 0x82e71358
	if !ctx.cr[6].gt {
	pc = 0x82E71358; continue 'dispatch;
	}
	// 82E712FC: 807F019C  lwz r3, 0x19c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82E71300: 909F01A4  stw r4, 0x1a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[4].u32 ) };
	// 82E71304: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71308: 41820014  beq 0x82e7131c
	if ctx.cr[0].eq {
	pc = 0x82E7131C; continue 'dispatch;
	}
	// 82E7130C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E71310: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E71314: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E71318: 4E800421  bctrl
	ctx.lr = 0x82E7131C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E7131C: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82E71320: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E71324: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71328: 4082000C  bne 0x82e71334
	if !ctx.cr[0].eq {
	pc = 0x82E71334; continue 'dispatch;
	}
	// 82E7132C: 93DF019C  stw r30, 0x19c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[30].u32 ) };
	// 82E71330: 48000024  b 0x82e71354
	pc = 0x82E71354; continue 'dispatch;
	// 82E71334: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82E71338: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82E7133C: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82E71340: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E71344: 40990008  ble cr6, 0x82e7134c
	if !ctx.cr[6].gt {
	pc = 0x82E7134C; continue 'dispatch;
	}
	// 82E71348: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82E7134C: 4B7A55DD  bl 0x82616928
	ctx.lr = 0x82E71350;
	sub_82616928(ctx, base);
	// 82E71350: 907F019C  stw r3, 0x19c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[3].u32 ) };
	// 82E71354: 93DF01A0  stw r30, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[30].u32 ) };
	// 82E71358: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E7135C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E71360: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E71364: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E71368: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E7136C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E71370 size=168
    let mut pc: u32 = 0x82E71370;
    'dispatch: loop {
        match pc {
            0x82E71370 => {
    //   block [0x82E71370..0x82E71418)
	// 82E71370: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82E71374: 83E30008  lwz r31, 8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E71378: 81640064  lwz r11, 0x64(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E7137C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E71380: 409A004C  bne cr6, 0x82e713cc
	if !ctx.cr[6].eq {
	pc = 0x82E713CC; continue 'dispatch;
	}
	// 82E71384: 81030078  lwz r8, 0x78(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E71388: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E7138C: 81450064  lwz r10, 0x64(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E71390: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82E71394: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71398: 41820034  beq 0x82e713cc
	if ctx.cr[0].eq {
	pc = 0x82E713CC; continue 'dispatch;
	}
	// 82E7139C: 80C30070  lwz r6, 0x70(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 82E713A0: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E713A4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E713A8: 41820014  beq 0x82e713bc
	if ctx.cr[0].eq {
	pc = 0x82E713BC; continue 'dispatch;
	}
	// 82E713AC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E713B0: 419A0028  beq cr6, 0x82e713d8
	if ctx.cr[6].eq {
	pc = 0x82E713D8; continue 'dispatch;
	}
	// 82E713B4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E713B8: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82E713BC: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82E713C0: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82E713C4: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82E713C8: 4198FFD8  blt cr6, 0x82e713a0
	if ctx.cr[6].lt {
	pc = 0x82E713A0; continue 'dispatch;
	}
	// 82E713CC: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82E713D0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82E713D4: 4E800020  blr
	return;
	// 82E713D8: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E713DC: 39600014  li r11, 0x14
	ctx.r[11].s64 = 20;
	// 82E713E0: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E713E4: 80E4006C  lwz r7, 0x6c(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E713E8: 80C5006C  lwz r6, 0x6c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E713EC: 80A30068  lwz r5, 0x68(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 82E713F0: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E713F4: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E713F8: 7D083850  subf r8, r8, r7
	ctx.r[8].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 82E713FC: 7D4A3050  subf r10, r10, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82E71400: 7D085B96  divwu r8, r8, r11
	ctx.r[8].u32 = ctx.r[8].u32 / ctx.r[11].u32;
	// 82E71404: 7D4A5B96  divwu r10, r10, r11
	ctx.r[10].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 82E71408: 7D6829D6  mullw r11, r8, r5
	ctx.r[11].s64 = (ctx.r[8].s32 as i64) * (ctx.r[5].s32 as i64);
	// 82E7140C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E71410: 7C6B4A14  add r3, r11, r9
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82E71414: 4BFFFFBC  b 0x82e713d0
	pc = 0x82E713D0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E71418 size=352
    let mut pc: u32 = 0x82E71418;
    'dispatch: loop {
        match pc {
            0x82E71418 => {
    //   block [0x82E71418..0x82E71578)
	// 82E71418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7141C: 4BE37FDD  bl 0x82ca93f8
	ctx.lr = 0x82E71420;
	sub_82CA93D0(ctx, base);
	// 82E71420: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82E71424: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E71428: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E7142C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E71430: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 82E71434: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82E71438: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82E7143C: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E71440: 48017C41  bl 0x82e89080
	ctx.lr = 0x82E71444;
	sub_82E89080(ctx, base);
	// 82E71444: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E71448: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E7144C: 48015F05  bl 0x82e87350
	ctx.lr = 0x82E71450;
	sub_82E87350(ctx, base);
	// 82E71450: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E71454: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E71458: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82E7145C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82E71460: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 82E71464: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E71468: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82E7146C: 419A0010  beq cr6, 0x82e7147c
	if ctx.cr[6].eq {
	pc = 0x82E7147C; continue 'dispatch;
	}
	// 82E71470: 4B3EF549  bl 0x822609b8
	ctx.lr = 0x82E71474;
	sub_822609B8(ctx, base);
	// 82E71474: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E71478: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82E7147C: C1BF003C  lfs f13, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E71480: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E71484: 4098000C  bge cr6, 0x82e71490
	if !ctx.cr[6].lt {
	pc = 0x82E71490; continue 'dispatch;
	}
	// 82E71488: 3B600002  li r27, 2
	ctx.r[27].s64 = 2;
	// 82E7148C: 4800002C  b 0x82e714b8
	pc = 0x82E714B8; continue 'dispatch;
	// 82E71490: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E71494: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E71498: 40980014  bge cr6, 0x82e714ac
	if !ctx.cr[6].lt {
	pc = 0x82E714AC; continue 'dispatch;
	}
	// 82E7149C: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 82E714A0: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 82E714A4: 409A0014  bne cr6, 0x82e714b8
	if !ctx.cr[6].eq {
	pc = 0x82E714B8; continue 'dispatch;
	}
	// 82E714A8: 4800000C  b 0x82e714b4
	pc = 0x82E714B4; continue 'dispatch;
	// 82E714AC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82E714B0: 40990008  ble cr6, 0x82e714b8
	if !ctx.cr[6].gt {
	pc = 0x82E714B8; continue 'dispatch;
	}
	// 82E714B4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E714B8: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E714BC: 4082009C  bne 0x82e71558
	if !ctx.cr[0].eq {
	pc = 0x82E71558; continue 'dispatch;
	}
	// 82E714C0: 2F1A0001  cmpwi cr6, r26, 1
	ctx.cr[6].compare_i32(ctx.r[26].s32, 1, &mut ctx.xer);
	// 82E714C4: 409A0054  bne cr6, 0x82e71518
	if !ctx.cr[6].eq {
	pc = 0x82E71518; continue 'dispatch;
	}
	// 82E714C8: 4B3EF4F1  bl 0x822609b8
	ctx.lr = 0x82E714CC;
	sub_822609B8(ctx, base);
	// 82E714CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E714D0: 48000030  b 0x82e71500
	pc = 0x82E71500; continue 'dispatch;
	// 82E714D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E714D8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E714DC: 9B210050  stb r25, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u8 ) };
	// 82E714E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E714E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E714E8: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E714EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E714F0: 4E800421  bctrl
	ctx.lr = 0x82E714F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E714F4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E714F8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E714FC: 40820050  bne 0x82e7154c
	if !ctx.cr[0].eq {
	pc = 0x82E7154C; continue 'dispatch;
	}
	// 82E71500: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E71504: 4801014D  bl 0x82e81650
	ctx.lr = 0x82E71508;
	sub_82E81650(ctx, base);
	// 82E71508: 897E006C  lbz r11, 0x6c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E7150C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E71510: 409AFFC4  bne cr6, 0x82e714d4
	if !ctx.cr[6].eq {
	pc = 0x82E714D4; continue 'dispatch;
	}
	// 82E71514: 48000044  b 0x82e71558
	pc = 0x82E71558; continue 'dispatch;
	// 82E71518: 2F1A0002  cmpwi cr6, r26, 2
	ctx.cr[6].compare_i32(ctx.r[26].s32, 2, &mut ctx.xer);
	// 82E7151C: 409A003C  bne cr6, 0x82e71558
	if !ctx.cr[6].eq {
	pc = 0x82E71558; continue 'dispatch;
	}
	// 82E71520: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E71524: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E71528: 9B210050  stb r25, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u8 ) };
	// 82E7152C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E71530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71534: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E71538: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E7153C: 4E800421  bctrl
	ctx.lr = 0x82E71540;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E71540: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E71544: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71548: 4182FFD8  beq 0x82e71520
	if ctx.cr[0].eq {
	pc = 0x82E71520; continue 'dispatch;
	}
	// 82E7154C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E71550: 41820008  beq 0x82e71558
	if ctx.cr[0].eq {
	pc = 0x82E71558; continue 'dispatch;
	}
	// 82E71554: 3B600002  li r27, 2
	ctx.r[27].s64 = 2;
	// 82E71558: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E7155C: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E71560: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E71564: 7C0B542E  lfsx f0, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E71568: D0180000  stfs f0, 0(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E7156C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E71570: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82E71574: 4BE37ED4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E71578 size=72
    let mut pc: u32 = 0x82E71578;
    'dispatch: loop {
        match pc {
            0x82E71578 => {
    //   block [0x82E71578..0x82E715C0)
	// 82E71578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7157C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E71580: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E71584: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E71588: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E7158C: 386001F4  li r3, 0x1f4
	ctx.r[3].s64 = 500;
	// 82E71590: 4B7A5399  bl 0x82616928
	ctx.lr = 0x82E71594;
	sub_82616928(ctx, base);
	// 82E71594: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71598: 41820010  beq 0x82e715a8
	if ctx.cr[0].eq {
	pc = 0x82E715A8; continue 'dispatch;
	}
	// 82E7159C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E715A0: 4BFFFAF1  bl 0x82e71090
	ctx.lr = 0x82E715A4;
	sub_82E71090(ctx, base);
	// 82E715A4: 48000008  b 0x82e715ac
	pc = 0x82E715AC; continue 'dispatch;
	// 82E715A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E715AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E715B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E715B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E715B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E715BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E715C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E715C0 size=492
    let mut pc: u32 = 0x82E715C0;
    'dispatch: loop {
        match pc {
            0x82E715C0 => {
    //   block [0x82E715C0..0x82E717AC)
	// 82E715C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E715C4: 4BE37E45  bl 0x82ca9408
	ctx.lr = 0x82E715C8;
	sub_82CA93D0(ctx, base);
	// 82E715C8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82E715CC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E715D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E715D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E715D8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E715DC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82E715E0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E715E4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E715E8: 917F01CC  stw r11, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[11].u32 ) };
	// 82E715EC: 997F01E0  stb r11, 0x1e0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[11].u8 ) };
	// 82E715F0: C3EA0C14  lfs f31, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E715F4: 997F01E1  stb r11, 0x1e1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(481 as u32), ctx.r[11].u8 ) };
	// 82E715F8: 81490014  lwz r10, 0x14(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E715FC: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82E71600: 38891048  addi r4, r9, 0x1048
	ctx.r[4].s64 = ctx.r[9].s64 + 4168;
	// 82E71604: C00A0034  lfs f0, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E71608: D01F01B4  stfs f0, 0x1b4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 82E7160C: C00A0038  lfs f0, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E71610: D01F01B8  stfs f0, 0x1b8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 82E71614: C00A003C  lfs f0, 0x3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E71618: D01F01BC  stfs f0, 0x1bc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), tmp.u32 ) };
	// 82E7161C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E71620: D3FF01D4  stfs f31, 0x1d4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), tmp.u32 ) };
	// 82E71624: 997F01B0  stb r11, 0x1b0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[11].u8 ) };
	// 82E71628: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 82E7162C: 917F01A0  stw r11, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[11].u32 ) };
	// 82E71630: 991F000C  stb r8, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u8 ) };
	// 82E71634: 917F01EC  stw r11, 0x1ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(492 as u32), ctx.r[11].u32 ) };
	// 82E71638: 4B3F5ED9  bl 0x82267510
	ctx.lr = 0x82E7163C;
	sub_82267510(ctx, base);
	// 82E7163C: 3FA08334  lis r29, -0x7ccc
	ctx.r[29].s64 = -2093744128;
	// 82E71640: 907F0014  stw r3, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82E71644: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E71648: 388BDF68  addi r4, r11, -0x2098
	ctx.r[4].s64 = ctx.r[11].s64 + -8344;
	// 82E7164C: 807D0718  lwz r3, 0x718(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E71650: 4B3F65D1  bl 0x82267c20
	ctx.lr = 0x82E71654;
	sub_82267C20(ctx, base);
	// 82E71654: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E71658: 907F0018  stw r3, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 82E7165C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E71660: 806B0064  lwz r3, 0x64(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E71664: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E71668: 41820014  beq 0x82e7167c
	if ctx.cr[0].eq {
	pc = 0x82E7167C; continue 'dispatch;
	}
	// 82E7166C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E71670: 388BE284  addi r4, r11, -0x1d7c
	ctx.r[4].s64 = ctx.r[11].s64 + -7548;
	// 82E71674: 4801605D  bl 0x82e876d0
	ctx.lr = 0x82E71678;
	sub_82E876D0(ctx, base);
	// 82E71678: 907F0024  stw r3, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 82E7167C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E71680: 807D0718  lwz r3, 0x718(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E71684: 388B2E38  addi r4, r11, 0x2e38
	ctx.r[4].s64 = ctx.r[11].s64 + 11832;
	// 82E71688: 4B3F6599  bl 0x82267c20
	ctx.lr = 0x82E7168C;
	sub_82267C20(ctx, base);
	// 82E7168C: 907F001C  stw r3, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 82E71690: 4B3EF329  bl 0x822609b8
	ctx.lr = 0x82E71694;
	sub_822609B8(ctx, base);
	// 82E71694: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E71698: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E7169C: 388B882C  addi r4, r11, -0x77d4
	ctx.r[4].s64 = ctx.r[11].s64 + -30676;
	// 82E716A0: 4800FB31  bl 0x82e811d0
	ctx.lr = 0x82E716A4;
	sub_82E811D0(ctx, base);
	// 82E716A4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82E716A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E716AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E716B0: 388B880C  addi r4, r11, -0x77f4
	ctx.r[4].s64 = ctx.r[11].s64 + -30708;
	// 82E716B4: 915F01DC  stw r10, 0x1dc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), ctx.r[10].u32 ) };
	// 82E716B8: 4800FAB1  bl 0x82e81168
	ctx.lr = 0x82E716BC;
	sub_82E81168(ctx, base);
	// 82E716BC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E716C0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E716C4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E716C8: 907F01D8  stw r3, 0x1d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), ctx.r[3].u32 ) };
	// 82E716CC: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82E716D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E716D4: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E716D8: D01F01D0  stfs f0, 0x1d0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 82E716DC: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E716E0: 4B376F99  bl 0x821e8678
	ctx.lr = 0x82E716E4;
	sub_821E8678(ctx, base);
	// 82E716E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E716E8: 4182000C  beq 0x82e716f4
	if ctx.cr[0].eq {
	pc = 0x82E716F4; continue 'dispatch;
	}
	// 82E716EC: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E716F0: 4800001C  b 0x82e7170c
	pc = 0x82E7170C; continue 'dispatch;
	// 82E716F4: 817D0718  lwz r11, 0x718(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E716F8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E716FC: 4182000C  beq 0x82e71708
	if ctx.cr[0].eq {
	pc = 0x82E71708; continue 'dispatch;
	}
	// 82E71700: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E71704: 48000008  b 0x82e7170c
	pc = 0x82E7170C; continue 'dispatch;
	// 82E71708: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82E7170C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E71710: D01F01E8  stfs f0, 0x1e8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 82E71714: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E71718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7171C: 917F01A0  stw r11, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[11].u32 ) };
	// 82E71720: 48017BA9  bl 0x82e892c8
	ctx.lr = 0x82E71724;
	sub_82E892C8(ctx, base);
	// 82E71724: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E71728: 41820074  beq 0x82e7179c
	if ctx.cr[0].eq {
	pc = 0x82E7179C; continue 'dispatch;
	}
	// 82E7172C: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 82E71730: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E71734: 409A0014  bne cr6, 0x82e71748
	if !ctx.cr[6].eq {
	pc = 0x82E71748; continue 'dispatch;
	}
	// 82E71738: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E7173C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82E71740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71744: 4BFFFB8D  bl 0x82e712d0
	ctx.lr = 0x82E71748;
	sub_82E712D0(ctx, base);
	// 82E71748: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E7174C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71750: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E71754: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E71758: 4E800421  bctrl
	ctx.lr = 0x82E7175C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E7175C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E71760: 4182003C  beq 0x82e7179c
	if ctx.cr[0].eq {
	pc = 0x82E7179C; continue 'dispatch;
	}
	// 82E71764: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E71768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7176C: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E71770: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E71774: 4E800421  bctrl
	ctx.lr = 0x82E71778;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E71778: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E7177C: 41820020  beq 0x82e7179c
	if ctx.cr[0].eq {
	pc = 0x82E7179C; continue 'dispatch;
	}
	// 82E71780: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E71784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71788: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E7178C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E71790: 4E800421  bctrl
	ctx.lr = 0x82E71794;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E71794: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E71798: 48000008  b 0x82e717a0
	pc = 0x82E717A0; continue 'dispatch;
	// 82E7179C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E717A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E717A4: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82E717A8: 4BE37CB0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E717B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E717B0 size=912
    let mut pc: u32 = 0x82E717B0;
    'dispatch: loop {
        match pc {
            0x82E717B0 => {
    //   block [0x82E717B0..0x82E71B40)
	// 82E717B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E717B4: 4BE37C59  bl 0x82ca940c
	ctx.lr = 0x82E717B8;
	sub_82CA93D0(ctx, base);
	// 82E717B8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82E717BC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E717C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E717C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E717C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E717CC: 409A000C  bne cr6, 0x82e717d8
	if !ctx.cr[6].eq {
	pc = 0x82E717D8; continue 'dispatch;
	}
	// 82E717D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E717D4: 48000360  b 0x82e71b34
	pc = 0x82E71B34; continue 'dispatch;
	// 82E717D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E717DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E717E0: 3BCB88B4  addi r30, r11, -0x774c
	ctx.r[30].s64 = ctx.r[11].s64 + -30540;
	// 82E717E4: 4834A87D  bl 0x831bc060
	ctx.lr = 0x82E717E8;
	sub_831BC060(ctx, base);
	// 82E717E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E717EC: 4BE3B365  bl 0x82cacb50
	ctx.lr = 0x82E717F0;
	sub_82CACB50(ctx, base);
	// 82E717F0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E717F4: 40820044  bne 0x82e71838
	if !ctx.cr[0].eq {
	pc = 0x82E71838; continue 'dispatch;
	}
	// 82E717F8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E717FC: 388B2E38  addi r4, r11, 0x2e38
	ctx.r[4].s64 = ctx.r[11].s64 + 11832;
	// 82E71800: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E71804: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E71808: 4B3F6419  bl 0x82267c20
	ctx.lr = 0x82E7180C;
	sub_82267C20(ctx, base);
	// 82E7180C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82E71810: 4182FFC0  beq 0x82e717d0
	if ctx.cr[0].eq {
	pc = 0x82E717D0; continue 'dispatch;
	}
	// 82E71814: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71818: 4BA9C4F1  bl 0x8290dd08
	ctx.lr = 0x82E7181C;
	sub_8290DD08(ctx, base);
	// 82E7181C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E71820: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E71824: 4801B995  bl 0x82e8d1b8
	ctx.lr = 0x82E71828;
	sub_82E8D1B8(ctx, base);
	// 82E71828: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E7182C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E71830: 917D0030  stw r11, 0x30(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82E71834: 48000300  b 0x82e71b34
	pc = 0x82E71B34; continue 'dispatch;
	// 82E71838: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E7183C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71840: 3BCB88AC  addi r30, r11, -0x7754
	ctx.r[30].s64 = ctx.r[11].s64 + -30548;
	// 82E71844: 4834A81D  bl 0x831bc060
	ctx.lr = 0x82E71848;
	sub_831BC060(ctx, base);
	// 82E71848: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E7184C: 4BE3B305  bl 0x82cacb50
	ctx.lr = 0x82E71850;
	sub_82CACB50(ctx, base);
	// 82E71850: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E71854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71858: 40820064  bne 0x82e718bc
	if !ctx.cr[0].eq {
	pc = 0x82E718BC; continue 'dispatch;
	}
	// 82E7185C: 4BA9C4AD  bl 0x8290dd08
	ctx.lr = 0x82E71860;
	sub_8290DD08(ctx, base);
	// 82E71860: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82E71864: 418202C4  beq 0x82e71b28
	if ctx.cr[0].eq {
	pc = 0x82E71B28; continue 'dispatch;
	}
	// 82E71868: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E7186C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71870: 4182FF60  beq 0x82e717d0
	if ctx.cr[0].eq {
	pc = 0x82E717D0; continue 'dispatch;
	}
	// 82E71874: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E71878: 4800AA51  bl 0x82e7c2c8
	ctx.lr = 0x82E7187C;
	sub_82E7C2C8(ctx, base);
	// 82E7187C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82E71880: 4182FF50  beq 0x82e717d0
	if ctx.cr[0].eq {
	pc = 0x82E717D0; continue 'dispatch;
	}
	// 82E71884: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E71888: 807D001C  lwz r3, 0x1c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E7188C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E71890: 38AB5D84  addi r5, r11, 0x5d84
	ctx.r[5].s64 = ctx.r[11].s64 + 23940;
	// 82E71894: 4801B7FD  bl 0x82e8d090
	ctx.lr = 0x82E71898;
	sub_82E8D090(ctx, base);
	// 82E71898: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E7189C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82E718A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E718A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E718A8: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E718AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E718B0: 4E800421  bctrl
	ctx.lr = 0x82E718B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E718B4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E718B8: 4800027C  b 0x82e71b34
	pc = 0x82E71B34; continue 'dispatch;
	// 82E718BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E718C0: 3BCB8898  addi r30, r11, -0x7768
	ctx.r[30].s64 = ctx.r[11].s64 + -30568;
	// 82E718C4: 4834A79D  bl 0x831bc060
	ctx.lr = 0x82E718C8;
	sub_831BC060(ctx, base);
	// 82E718C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E718CC: 4BE3B285  bl 0x82cacb50
	ctx.lr = 0x82E718D0;
	sub_82CACB50(ctx, base);
	// 82E718D0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E718D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E718D8: 40820028  bne 0x82e71900
	if !ctx.cr[0].eq {
	pc = 0x82E71900; continue 'dispatch;
	}
	// 82E718DC: 4BA9C42D  bl 0x8290dd08
	ctx.lr = 0x82E718E0;
	sub_8290DD08(ctx, base);
	// 82E718E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E718E4: 41820244  beq 0x82e71b28
	if ctx.cr[0].eq {
	pc = 0x82E71B28; continue 'dispatch;
	}
	// 82E718E8: 4BE38AD9  bl 0x82caa3c0
	ctx.lr = 0x82E718EC;
	sub_82CAA3C0(ctx, base);
	// 82E718EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E718F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E718F4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E718F8: 4BFFF8C9  bl 0x82e711c0
	ctx.lr = 0x82E718FC;
	sub_82E711C0(ctx, base);
	// 82E718FC: 4BFFFFB8  b 0x82e718b4
	pc = 0x82E718B4; continue 'dispatch;
	// 82E71900: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E71904: 3BCB8880  addi r30, r11, -0x7780
	ctx.r[30].s64 = ctx.r[11].s64 + -30592;
	// 82E71908: 4834A759  bl 0x831bc060
	ctx.lr = 0x82E7190C;
	sub_831BC060(ctx, base);
	// 82E7190C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E71910: 4BE3B241  bl 0x82cacb50
	ctx.lr = 0x82E71914;
	sub_82CACB50(ctx, base);
	// 82E71914: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E71918: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7191C: 40820028  bne 0x82e71944
	if !ctx.cr[0].eq {
	pc = 0x82E71944; continue 'dispatch;
	}
	// 82E71920: 4BA9C3E9  bl 0x8290dd08
	ctx.lr = 0x82E71924;
	sub_8290DD08(ctx, base);
	// 82E71924: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71928: 41820200  beq 0x82e71b28
	if ctx.cr[0].eq {
	pc = 0x82E71B28; continue 'dispatch;
	}
	// 82E7192C: 4BE38A95  bl 0x82caa3c0
	ctx.lr = 0x82E71930;
	sub_82CAA3C0(ctx, base);
	// 82E71930: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E71934: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E71938: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E7193C: 4BFFF995  bl 0x82e712d0
	ctx.lr = 0x82E71940;
	sub_82E712D0(ctx, base);
	// 82E71940: 4BFFFF74  b 0x82e718b4
	pc = 0x82E718B4; continue 'dispatch;
	// 82E71944: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E71948: 3BCB8870  addi r30, r11, -0x7790
	ctx.r[30].s64 = ctx.r[11].s64 + -30608;
	// 82E7194C: 4834A715  bl 0x831bc060
	ctx.lr = 0x82E71950;
	sub_831BC060(ctx, base);
	// 82E71950: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E71954: 4BE3B1FD  bl 0x82cacb50
	ctx.lr = 0x82E71958;
	sub_82CACB50(ctx, base);
	// 82E71958: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E7195C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71960: 40820054  bne 0x82e719b4
	if !ctx.cr[0].eq {
	pc = 0x82E719B4; continue 'dispatch;
	}
	// 82E71964: 4BA9C3A5  bl 0x8290dd08
	ctx.lr = 0x82E71968;
	sub_8290DD08(ctx, base);
	// 82E71968: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7196C: 418201BC  beq 0x82e71b28
	if ctx.cr[0].eq {
	pc = 0x82E71B28; continue 'dispatch;
	}
	// 82E71970: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E71974: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E71978: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7197C: 4182000C  beq 0x82e71988
	if ctx.cr[0].eq {
	pc = 0x82E71988; continue 'dispatch;
	}
	// 82E71980: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E71984: 4800000C  b 0x82e71990
	pc = 0x82E71990; continue 'dispatch;
	// 82E71988: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E7198C: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E71990: 4BE3A221  bl 0x82cabbb0
	ctx.lr = 0x82E71994;
	sub_82CABBB0(ctx, base);
	// 82E71994: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E71998: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E7199C: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E719A0: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E719A4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E719A8: 4099FF0C  ble cr6, 0x82e718b4
	if !ctx.cr[6].gt {
	pc = 0x82E718B4; continue 'dispatch;
	}
	// 82E719AC: D01D0010  stfs f0, 0x10(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E719B0: 4BFFFF04  b 0x82e718b4
	pc = 0x82E718B4; continue 'dispatch;
	// 82E719B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E719B8: 3BCB885C  addi r30, r11, -0x77a4
	ctx.r[30].s64 = ctx.r[11].s64 + -30628;
	// 82E719BC: 4834A6A5  bl 0x831bc060
	ctx.lr = 0x82E719C0;
	sub_831BC060(ctx, base);
	// 82E719C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E719C4: 4BE3B18D  bl 0x82cacb50
	ctx.lr = 0x82E719C8;
	sub_82CACB50(ctx, base);
	// 82E719C8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E719CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E719D0: 40820024  bne 0x82e719f4
	if !ctx.cr[0].eq {
	pc = 0x82E719F4; continue 'dispatch;
	}
	// 82E719D4: 4BA9C335  bl 0x8290dd08
	ctx.lr = 0x82E719D8;
	sub_8290DD08(ctx, base);
	// 82E719D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E719DC: 4182014C  beq 0x82e71b28
	if ctx.cr[0].eq {
	pc = 0x82E71B28; continue 'dispatch;
	}
	// 82E719E0: 4BE3A1D1  bl 0x82cabbb0
	ctx.lr = 0x82E719E4;
	sub_82CABBB0(ctx, base);
	// 82E719E4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E719E8: D01D01D4  stfs f0, 0x1d4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(468 as u32), tmp.u32 ) };
	// 82E719EC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E719F0: 48000144  b 0x82e71b34
	pc = 0x82E71B34; continue 'dispatch;
	// 82E719F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E719F8: 3BCB884C  addi r30, r11, -0x77b4
	ctx.r[30].s64 = ctx.r[11].s64 + -30644;
	// 82E719FC: 4834A665  bl 0x831bc060
	ctx.lr = 0x82E71A00;
	sub_831BC060(ctx, base);
	// 82E71A00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E71A04: 4BE3B14D  bl 0x82cacb50
	ctx.lr = 0x82E71A08;
	sub_82CACB50(ctx, base);
	// 82E71A08: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E71A0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71A10: 408200B4  bne 0x82e71ac4
	if !ctx.cr[0].eq {
	pc = 0x82E71AC4; continue 'dispatch;
	}
	// 82E71A14: 4BA9C2F5  bl 0x8290dd08
	ctx.lr = 0x82E71A18;
	sub_8290DD08(ctx, base);
	// 82E71A18: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82E71A1C: 4182010C  beq 0x82e71b28
	if ctx.cr[0].eq {
	pc = 0x82E71B28; continue 'dispatch;
	}
	// 82E71A20: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82E71A24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E71A28: 388B1694  addi r4, r11, 0x1694
	ctx.r[4].s64 = ctx.r[11].s64 + 5780;
	// 82E71A2C: 4BE3B125  bl 0x82cacb50
	ctx.lr = 0x82E71A30;
	sub_82CACB50(ctx, base);
	// 82E71A30: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E71A34: 41820084  beq 0x82e71ab8
	if ctx.cr[0].eq {
	pc = 0x82E71AB8; continue 'dispatch;
	}
	// 82E71A38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E71A3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E71A40: 388B0F40  addi r4, r11, 0xf40
	ctx.r[4].s64 = ctx.r[11].s64 + 3904;
	// 82E71A44: 4BE3B10D  bl 0x82cacb50
	ctx.lr = 0x82E71A48;
	sub_82CACB50(ctx, base);
	// 82E71A48: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E71A4C: 4182006C  beq 0x82e71ab8
	if ctx.cr[0].eq {
	pc = 0x82E71AB8; continue 'dispatch;
	}
	// 82E71A50: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82E71A54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E71A58: 388BD56C  addi r4, r11, -0x2a94
	ctx.r[4].s64 = ctx.r[11].s64 + -10900;
	// 82E71A5C: 4BE3B0F5  bl 0x82cacb50
	ctx.lr = 0x82E71A60;
	sub_82CACB50(ctx, base);
	// 82E71A60: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E71A64: 41820054  beq 0x82e71ab8
	if ctx.cr[0].eq {
	pc = 0x82E71AB8; continue 'dispatch;
	}
	// 82E71A68: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82E71A6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E71A70: 388B1698  addi r4, r11, 0x1698
	ctx.r[4].s64 = ctx.r[11].s64 + 5784;
	// 82E71A74: 4BE3B0DD  bl 0x82cacb50
	ctx.lr = 0x82E71A78;
	sub_82CACB50(ctx, base);
	// 82E71A78: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E71A7C: 41820034  beq 0x82e71ab0
	if ctx.cr[0].eq {
	pc = 0x82E71AB0; continue 'dispatch;
	}
	// 82E71A80: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82E71A84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E71A88: 388B1700  addi r4, r11, 0x1700
	ctx.r[4].s64 = ctx.r[11].s64 + 5888;
	// 82E71A8C: 4BE3B0C5  bl 0x82cacb50
	ctx.lr = 0x82E71A90;
	sub_82CACB50(ctx, base);
	// 82E71A90: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E71A94: 4182001C  beq 0x82e71ab0
	if ctx.cr[0].eq {
	pc = 0x82E71AB0; continue 'dispatch;
	}
	// 82E71A98: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82E71A9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E71AA0: 388B7088  addi r4, r11, 0x7088
	ctx.r[4].s64 = ctx.r[11].s64 + 28808;
	// 82E71AA4: 4BE3B0AD  bl 0x82cacb50
	ctx.lr = 0x82E71AA8;
	sub_82CACB50(ctx, base);
	// 82E71AA8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E71AAC: 4082FD24  bne 0x82e717d0
	if !ctx.cr[0].eq {
	pc = 0x82E717D0; continue 'dispatch;
	}
	// 82E71AB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E71AB4: 48000008  b 0x82e71abc
	pc = 0x82E71ABC; continue 'dispatch;
	// 82E71AB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E71ABC: 997D000C  stb r11, 0xc(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82E71AC0: 4BFFFDF4  b 0x82e718b4
	pc = 0x82E718B4; continue 'dispatch;
	// 82E71AC4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82E71AC8: 3BCB293C  addi r30, r11, 0x293c
	ctx.r[30].s64 = ctx.r[11].s64 + 10556;
	// 82E71ACC: 4834A595  bl 0x831bc060
	ctx.lr = 0x82E71AD0;
	sub_831BC060(ctx, base);
	// 82E71AD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E71AD4: 4BE3B07D  bl 0x82cacb50
	ctx.lr = 0x82E71AD8;
	sub_82CACB50(ctx, base);
	// 82E71AD8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E71ADC: 4082004C  bne 0x82e71b28
	if !ctx.cr[0].eq {
	pc = 0x82E71B28; continue 'dispatch;
	}
	// 82E71AE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71AE4: 4BA9C225  bl 0x8290dd08
	ctx.lr = 0x82E71AE8;
	sub_8290DD08(ctx, base);
	// 82E71AE8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71AEC: 4182003C  beq 0x82e71b28
	if ctx.cr[0].eq {
	pc = 0x82E71B28; continue 'dispatch;
	}
	// 82E71AF0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E71AF4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E71AF8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71AFC: 4182000C  beq 0x82e71b08
	if ctx.cr[0].eq {
	pc = 0x82E71B08; continue 'dispatch;
	}
	// 82E71B00: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E71B04: 4800000C  b 0x82e71b10
	pc = 0x82E71B10; continue 'dispatch;
	// 82E71B08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E71B0C: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E71B10: 4BE3A0A1  bl 0x82cabbb0
	ctx.lr = 0x82E71B14;
	sub_82CABBB0(ctx, base);
	// 82E71B14: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E71B18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E71B1C: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E71B20: 4B376959  bl 0x821e8478
	ctx.lr = 0x82E71B24;
	sub_821E8478(ctx, base);
	// 82E71B24: 4BFFFD90  b 0x82e718b4
	pc = 0x82E718B4; continue 'dispatch;
	// 82E71B28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E71B2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E71B30: 4BFFE369  bl 0x82e6fe98
	ctx.lr = 0x82E71B34;
	sub_82E6FE98(ctx, base);
	// 82E71B34: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E71B38: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82E71B3C: 4BE37920  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E71B40 size=376
    let mut pc: u32 = 0x82E71B40;
    'dispatch: loop {
        match pc {
            0x82E71B40 => {
    //   block [0x82E71B40..0x82E71CB8)
	// 82E71B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E71B44: 4BE378B9  bl 0x82ca93fc
	ctx.lr = 0x82E71B48;
	sub_82CA93D0(ctx, base);
	// 82E71B48: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E71B4C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82E71B50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E71B54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E71B58: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E71B5C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82E71B60: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82E71B64: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82E71B68: 409A000C  bne cr6, 0x82e71b74
	if !ctx.cr[6].eq {
	pc = 0x82E71B74; continue 'dispatch;
	}
	// 82E71B6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E71B70: 480000D4  b 0x82e71c44
	pc = 0x82E71C44; continue 'dispatch;
	// 82E71B74: 8B3F0044  lbz r25, 0x44(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E71B78: 28190000  cmplwi r25, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71B7C: 40820050  bne 0x82e71bcc
	if !ctx.cr[0].eq {
	pc = 0x82E71BCC; continue 'dispatch;
	}
	// 82E71B80: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E71B84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E71B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71B8C: 4BFFF495  bl 0x82e71020
	ctx.lr = 0x82E71B90;
	sub_82E71020(ctx, base);
	// 82E71B90: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E71B94: 41820038  beq 0x82e71bcc
	if ctx.cr[0].eq {
	pc = 0x82E71BCC; continue 'dispatch;
	}
	// 82E71B98: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E71B9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E71BA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71BA4: 4BFFF7CD  bl 0x82e71370
	ctx.lr = 0x82E71BA8;
	sub_82E71370(ctx, base);
	// 82E71BA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E71BAC: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 82E71BB0: 419AFFBC  beq cr6, 0x82e71b6c
	if ctx.cr[6].eq {
	pc = 0x82E71B6C; continue 'dispatch;
	}
	// 82E71BB4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82E71BB8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82E71BBC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82E71BC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71BC4: 4BFFF855  bl 0x82e71418
	ctx.lr = 0x82E71BC8;
	sub_82E71418(ctx, base);
	// 82E71BC8: 4800007C  b 0x82e71c44
	pc = 0x82E71C44; continue 'dispatch;
	// 82E71BCC: 2F1A0001  cmpwi cr6, r26, 1
	ctx.cr[6].compare_i32(ctx.r[26].s32, 1, &mut ctx.xer);
	// 82E71BD0: 419A007C  beq cr6, 0x82e71c4c
	if ctx.cr[6].eq {
	pc = 0x82E71C4C; continue 'dispatch;
	}
	// 82E71BD4: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82E71BD8: 419A000C  beq cr6, 0x82e71be4
	if ctx.cr[6].eq {
	pc = 0x82E71BE4; continue 'dispatch;
	}
	// 82E71BDC: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82E71BE0: 419A006C  beq cr6, 0x82e71c4c
	if ctx.cr[6].eq {
	pc = 0x82E71C4C; continue 'dispatch;
	}
	// 82E71BE4: 2F1A0002  cmpwi cr6, r26, 2
	ctx.cr[6].compare_i32(ctx.r[26].s32, 2, &mut ctx.xer);
	// 82E71BE8: 409AFF84  bne cr6, 0x82e71b6c
	if !ctx.cr[6].eq {
	pc = 0x82E71B6C; continue 'dispatch;
	}
	// 82E71BEC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82E71BF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E71BF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71BF8: 4B461761  bl 0x822d3358
	ctx.lr = 0x82E71BFC;
	sub_822D3358(ctx, base);
	// 82E71BFC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E71C00: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E71C04: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82E71C08: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82E71C0C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E71C10: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E71C14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E71C18: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82E71C1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71C20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E71C24: 4E800421  bctrl
	ctx.lr = 0x82E71C28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E71C28: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E71C2C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71C30: 4182FFBC  beq 0x82e71bec
	if ctx.cr[0].eq {
	pc = 0x82E71BEC; continue 'dispatch;
	}
	// 82E71C34: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E71C38: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 82E71C3C: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82E71C40: 556307BC  rlwinm r3, r11, 0, 0x1e, 0x1e
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82E71C44: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E71C48: 4BE37804  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 82E71C4C: 4B3EED6D  bl 0x822609b8
	ctx.lr = 0x82E71C50;
	sub_822609B8(ctx, base);
	// 82E71C50: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E71C54: 4800004C  b 0x82e71ca0
	pc = 0x82E71CA0; continue 'dispatch;
	// 82E71C58: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82E71C5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E71C60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71C64: 4B4616F5  bl 0x822d3358
	ctx.lr = 0x82E71C68;
	sub_822D3358(ctx, base);
	// 82E71C68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E71C6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E71C70: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82E71C74: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82E71C78: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E71C7C: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E71C80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E71C84: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82E71C88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71C8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E71C90: 4E800421  bctrl
	ctx.lr = 0x82E71C94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E71C94: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E71C98: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71C9C: 4082FF98  bne 0x82e71c34
	if !ctx.cr[0].eq {
	pc = 0x82E71C34; continue 'dispatch;
	}
	// 82E71CA0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E71CA4: 4800F9AD  bl 0x82e81650
	ctx.lr = 0x82E71CA8;
	sub_82E81650(ctx, base);
	// 82E71CA8: 897C006C  lbz r11, 0x6c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E71CAC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E71CB0: 409AFFA8  bne cr6, 0x82e71c58
	if !ctx.cr[6].eq {
	pc = 0x82E71C58; continue 'dispatch;
	}
	// 82E71CB4: 4BFFFEB8  b 0x82e71b6c
	pc = 0x82E71B6C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E71CB8 size=180
    let mut pc: u32 = 0x82E71CB8;
    'dispatch: loop {
        match pc {
            0x82E71CB8 => {
    //   block [0x82E71CB8..0x82E71D6C)
	// 82E71CB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E71CBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E71CC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E71CC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E71CC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E71CCC: 4801750D  bl 0x82e891d8
	ctx.lr = 0x82E71CD0;
	sub_82E891D8(ctx, base);
	// 82E71CD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E71CD4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E71CD8: 3D0082EA  lis r8, -0x7d16
	ctx.r[8].s64 = -2098593792;
	// 82E71CDC: 394B2DF4  addi r10, r11, 0x2df4
	ctx.r[10].s64 = ctx.r[11].s64 + 11764;
	// 82E71CE0: 3D6082EA  lis r11, -0x7d16
	ctx.r[11].s64 = -2098593792;
	// 82E71CE4: 38E89C78  addi r7, r8, -0x6388
	ctx.r[7].s64 = ctx.r[8].s64 + -25480;
	// 82E71CE8: 38CB9D98  addi r6, r11, -0x6268
	ctx.r[6].s64 = ctx.r[11].s64 + -25192;
	// 82E71CEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E71CF0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E71CF4: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82E71CF8: 390B10BC  addi r8, r11, 0x10bc
	ctx.r[8].s64 = ctx.r[11].s64 + 4284;
	// 82E71CFC: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82E71D00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E71D04: 90DF0010  stw r6, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 82E71D08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71D0C: 80E90014  lwz r7, 0x14(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E71D10: 90FF0014  stw r7, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 82E71D14: 81290014  lwz r9, 0x14(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E71D18: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82E71D1C: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82E71D20: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 82E71D24: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82E71D28: 913F0018  stw r9, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82E71D2C: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82E71D30: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82E71D34: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82E71D38: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82E71D3C: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82E71D40: 911F0058  stw r8, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 82E71D44: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E71D48: 915F0060  stw r10, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82E71D4C: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82E71D50: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82E71D54: 997F006C  stb r11, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u8 ) };
	// 82E71D58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E71D5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E71D60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E71D64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E71D68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E71D70 size=12
    let mut pc: u32 = 0x82E71D70;
    'dispatch: loop {
        match pc {
            0x82E71D70 => {
    //   block [0x82E71D70..0x82E71D7C)
	// 82E71D70: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E71D74: 386BB9E8  addi r3, r11, -0x4618
	ctx.r[3].s64 = ctx.r[11].s64 + -17944;
	// 82E71D78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E71D80 size=160
    let mut pc: u32 = 0x82E71D80;
    'dispatch: loop {
        match pc {
            0x82E71D80 => {
    //   block [0x82E71D80..0x82E71E20)
	// 82E71D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E71D84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E71D88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E71D8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E71D90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E71D94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E71D98: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E71D9C: 396B2DF4  addi r11, r11, 0x2df4
	ctx.r[11].s64 = ctx.r[11].s64 + 11764;
	// 82E71DA0: 809F0030  lwz r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E71DA4: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71DA8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E71DAC: 41820014  beq 0x82e71dc0
	if ctx.cr[0].eq {
	pc = 0x82E71DC0; continue 'dispatch;
	}
	// 82E71DB0: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E71DB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71DB8: 41820008  beq 0x82e71dc0
	if ctx.cr[0].eq {
	pc = 0x82E71DC0; continue 'dispatch;
	}
	// 82E71DBC: 4801B7F5  bl 0x82e8d5b0
	ctx.lr = 0x82E71DC0;
	sub_82E8D5B0(ctx, base);
	// 82E71DC0: 807F0044  lwz r3, 0x44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E71DC4: 3FC08330  lis r30, -0x7cd0
	ctx.r[30].s64 = -2094006272;
	// 82E71DC8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71DCC: 41820010  beq 0x82e71ddc
	if ctx.cr[0].eq {
	pc = 0x82E71DDC; continue 'dispatch;
	}
	// 82E71DD0: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E71DD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E71DD8: 4E800421  bctrl
	ctx.lr = 0x82E71DDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E71DDC: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E71DE0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71DE4: 41820010  beq 0x82e71df4
	if ctx.cr[0].eq {
	pc = 0x82E71DF4; continue 'dispatch;
	}
	// 82E71DE8: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E71DEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E71DF0: 4E800421  bctrl
	ctx.lr = 0x82E71DF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E71DF4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E71DF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E71DFC: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E71E00: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E71E04: 480173F5  bl 0x82e891f8
	ctx.lr = 0x82E71E08;
	sub_82E891F8(ctx, base);
	// 82E71E08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E71E0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E71E10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E71E14: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E71E18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E71E1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E71E20 size=104
    let mut pc: u32 = 0x82E71E20;
    'dispatch: loop {
        match pc {
            0x82E71E20 => {
    //   block [0x82E71E20..0x82E71E88)
	// 82E71E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E71E24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E71E28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E71E2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E71E30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E71E34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E71E38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E71E3C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E71E40: 809F0030  lwz r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E71E44: C00B0EE0  lfs f0, 0xee0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E71E48: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E71E4C: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82E71E50: 9BDF006C  stb r30, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[30].u8 ) };
	// 82E71E54: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71E58: 41820018  beq 0x82e71e70
	if ctx.cr[0].eq {
	pc = 0x82E71E70; continue 'dispatch;
	}
	// 82E71E5C: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E71E60: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71E64: 4182000C  beq 0x82e71e70
	if ctx.cr[0].eq {
	pc = 0x82E71E70; continue 'dispatch;
	}
	// 82E71E68: 4801B749  bl 0x82e8d5b0
	ctx.lr = 0x82E71E6C;
	sub_82E8D5B0(ctx, base);
	// 82E71E6C: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82E71E70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E71E74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E71E78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E71E7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E71E80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E71E84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E71E88 size=20
    let mut pc: u32 = 0x82E71E88;
    'dispatch: loop {
        match pc {
            0x82E71E88 => {
    //   block [0x82E71E88..0x82E71E9C)
	// 82E71E88: 81630034  lwz r11, 0x34(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E71E8C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E71E90: 409A000C  bne cr6, 0x82e71e9c
	if !ctx.cr[6].eq {
		sub_82E71E9C(ctx, base);
		return;
	}
	// 82E71E94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E71E98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71E9C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E71E9C size=20
    let mut pc: u32 = 0x82E71E9C;
    'dispatch: loop {
        match pc {
            0x82E71E9C => {
    //   block [0x82E71E9C..0x82E71EB0)
	// 82E71E9C: 81630064  lwz r11, 0x64(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E71EA0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82E71EA4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82E71EA8: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82E71EAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E71EB0 size=60
    let mut pc: u32 = 0x82E71EB0;
    'dispatch: loop {
        match pc {
            0x82E71EB0 => {
    //   block [0x82E71EB0..0x82E71EEC)
	// 82E71EB0: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E71EB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E71EB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E71EBC: 409A0008  bne cr6, 0x82e71ec4
	if !ctx.cr[6].eq {
	pc = 0x82E71EC4; continue 'dispatch;
	}
	// 82E71EC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E71EC4: 81430024  lwz r10, 0x24(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E71EC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E71ECC: 409A0008  bne cr6, 0x82e71ed4
	if !ctx.cr[6].eq {
	pc = 0x82E71ED4; continue 'dispatch;
	}
	// 82E71ED0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E71ED4: 81430034  lwz r10, 0x34(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E71ED8: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82E71EDC: 409A0008  bne cr6, 0x82e71ee4
	if !ctx.cr[6].eq {
	pc = 0x82E71EE4; continue 'dispatch;
	}
	// 82E71EE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E71EE4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E71EE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E71EF0 size=24
    let mut pc: u32 = 0x82E71EF0;
    'dispatch: loop {
        match pc {
            0x82E71EF0 => {
    //   block [0x82E71EF0..0x82E71F08)
	// 82E71EF0: 81630074  lwz r11, 0x74(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E71EF4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E71EF8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82E71EFC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82E71F00: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82E71F04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E71F08 size=20
    let mut pc: u32 = 0x82E71F08;
    'dispatch: loop {
        match pc {
            0x82E71F08 => {
    //   block [0x82E71F08..0x82E71F1C)
	// 82E71F08: 8163003C  lwz r11, 0x3c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E71F0C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E71F10: 4198000C  blt cr6, 0x82e71f1c
	if ctx.cr[6].lt {
		sub_82E71F1C(ctx, base);
		return;
	}
	// 82E71F14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E71F18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71F1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E71F1C size=44
    let mut pc: u32 = 0x82E71F1C;
    'dispatch: loop {
        match pc {
            0x82E71F1C => {
    //   block [0x82E71F1C..0x82E71F48)
	// 82E71F1C: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E71F20: 1D44000C  mulli r10, r4, 0xc
	ctx.r[10].s64 = ctx.r[4].s64 * 12;
	// 82E71F24: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E71F28: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E71F2C: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E71F30: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E71F34: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E71F38: D0050004  stfs f0, 4(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E71F3C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E71F40: D0050008  stfs f0, 8(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E71F44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E71F48 size=12
    let mut pc: u32 = 0x82E71F48;
    'dispatch: loop {
        match pc {
            0x82E71F48 => {
    //   block [0x82E71F48..0x82E71F54)
	// 82E71F48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E71F4C: 91630048  stw r11, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82E71F50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E71F58 size=28
    let mut pc: u32 = 0x82E71F58;
    'dispatch: loop {
        match pc {
            0x82E71F58 => {
    //   block [0x82E71F58..0x82E71F74)
	// 82E71F58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E71F5C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E71F60: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E71F64: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E71F68: 409A000C  bne cr6, 0x82e71f74
	if !ctx.cr[6].eq {
		sub_82E71F74(ctx, base);
		return;
	}
	// 82E71F6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E71F70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71F74(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E71F74 size=48
    let mut pc: u32 = 0x82E71F74;
    'dispatch: loop {
        match pc {
            0x82E71F74 => {
    //   block [0x82E71F74..0x82E71FA4)
	// 82E71F74: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E71F78: 812B004C  lwz r9, 0x4c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82E71F7C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E71F80: 4098FFEC  bge cr6, 0x82e71f6c
	if !ctx.cr[6].lt {
		sub_82E71F58(ctx, base);
		return;
	}
	// 82E71F84: 812B0044  lwz r9, 0x44(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E71F88: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E71F8C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E71F90: 7C8A492E  stwx r4, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[4].u32) };
	// 82E71F94: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E71F98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E71F9C: 914B0048  stw r10, 0x48(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 82E71FA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E71FA8 size=20
    let mut pc: u32 = 0x82E71FA8;
    'dispatch: loop {
        match pc {
            0x82E71FA8 => {
    //   block [0x82E71FA8..0x82E71FBC)
	// 82E71FA8: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E71FAC: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E71FB0: 4198000C  blt cr6, 0x82e71fbc
	if ctx.cr[6].lt {
		sub_82E71FBC(ctx, base);
		return;
	}
	// 82E71FB4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E71FB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71FBC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E71FBC size=24
    let mut pc: u32 = 0x82E71FBC;
    'dispatch: loop {
        match pc {
            0x82E71FBC => {
    //   block [0x82E71FBC..0x82E71FD4)
	// 82E71FBC: 81630044  lwz r11, 0x44(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E71FC0: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E71FC4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E71FC8: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E71FCC: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E71FD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E71FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E71FD8 size=224
    let mut pc: u32 = 0x82E71FD8;
    'dispatch: loop {
        match pc {
            0x82E71FD8 => {
    //   block [0x82E71FD8..0x82E720B8)
	// 82E71FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E71FDC: 4BE3742D  bl 0x82ca9408
	ctx.lr = 0x82E71FE0;
	sub_82CA93D0(ctx, base);
	// 82E71FE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E71FE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E71FE8: 897F006C  lbz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E71FEC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E71FF0: 41820014  beq 0x82e72004
	if ctx.cr[0].eq {
	pc = 0x82E72004; continue 'dispatch;
	}
	// 82E71FF4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E71FF8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E71FFC: 3B8B0034  addi r28, r11, 0x34
	ctx.r[28].s64 = ctx.r[11].s64 + 52;
	// 82E72000: 4800000C  b 0x82e7200c
	pc = 0x82E7200C; continue 'dispatch;
	// 82E72004: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E72008: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 82E7200C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E72010: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E72014: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E72018: 40990040  ble cr6, 0x82e72058
	if !ctx.cr[6].gt {
	pc = 0x82E72058; continue 'dispatch;
	}
	// 82E7201C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E72020: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E72024: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E72028: 80BF0018  lwz r5, 0x18(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E7202C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E72030: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E72034: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E72038: 4E800421  bctrl
	ctx.lr = 0x82E7203C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E7203C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E72040: 40820070  bne 0x82e720b0
	if !ctx.cr[0].eq {
	pc = 0x82E720B0; continue 'dispatch;
	}
	// 82E72044: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E72048: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E7204C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E72050: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E72054: 4198FFCC  blt cr6, 0x82e72020
	if ctx.cr[6].lt {
	pc = 0x82E72020; continue 'dispatch;
	}
	// 82E72058: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E7205C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E72060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E72064: 40990040  ble cr6, 0x82e720a4
	if !ctx.cr[6].gt {
	pc = 0x82E720A4; continue 'dispatch;
	}
	// 82E72068: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E7206C: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E72070: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E72074: 80BF0014  lwz r5, 0x14(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E72078: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E7207C: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82E72080: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E72084: 4E800421  bctrl
	ctx.lr = 0x82E72088;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E72088: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E7208C: 40820024  bne 0x82e720b0
	if !ctx.cr[0].eq {
	pc = 0x82E720B0; continue 'dispatch;
	}
	// 82E72090: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E72094: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E72098: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82E7209C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E720A0: 4198FFCC  blt cr6, 0x82e7206c
	if ctx.cr[6].lt {
	pc = 0x82E7206C; continue 'dispatch;
	}
	// 82E720A4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E720A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E720AC: 4BE373AC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 82E720B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E720B4: 4BFFFFF4  b 0x82e720a8
	pc = 0x82E720A8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E720B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E720B8 size=92
    let mut pc: u32 = 0x82E720B8;
    'dispatch: loop {
        match pc {
            0x82E720B8 => {
    //   block [0x82E720B8..0x82E72114)
	// 82E720B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E720BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E720C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E720C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E720C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E720CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E720D0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E720D4: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E720D8: 909F0064  stw r4, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[4].u32 ) };
	// 82E720DC: 90BF0068  stw r5, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[5].u32 ) };
	// 82E720E0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E720E4: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82E720E8: 41820014  beq 0x82e720fc
	if ctx.cr[0].eq {
	pc = 0x82E720FC; continue 'dispatch;
	}
	// 82E720EC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82E720F0: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E720F4: 4801B4BD  bl 0x82e8d5b0
	ctx.lr = 0x82E720F8;
	sub_82E8D5B0(ctx, base);
	// 82E720F8: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82E720FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E72100: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E72104: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E72108: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E7210C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E72110: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E72118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E72118 size=72
    let mut pc: u32 = 0x82E72118;
    'dispatch: loop {
        match pc {
            0x82E72118 => {
    //   block [0x82E72118..0x82E72160)
	// 82E72118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7211C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E72120: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E72124: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E72128: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E7212C: 38600078  li r3, 0x78
	ctx.r[3].s64 = 120;
	// 82E72130: 4B7A47F9  bl 0x82616928
	ctx.lr = 0x82E72134;
	sub_82616928(ctx, base);
	// 82E72134: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E72138: 41820010  beq 0x82e72148
	if ctx.cr[0].eq {
	pc = 0x82E72148; continue 'dispatch;
	}
	// 82E7213C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E72140: 4BFFFB79  bl 0x82e71cb8
	ctx.lr = 0x82E72144;
	sub_82E71CB8(ctx, base);
	// 82E72144: 48000008  b 0x82e7214c
	pc = 0x82E7214C; continue 'dispatch;
	// 82E72148: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E7214C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E72150: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E72154: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E72158: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E7215C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E72160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E72160 size=88
    let mut pc: u32 = 0x82E72160;
    'dispatch: loop {
        match pc {
            0x82E72160 => {
    //   block [0x82E72160..0x82E721B8)
	// 82E72160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E72164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E72168: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E7216C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E72170: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E72174: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E72178: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E7217C: 4BFFFC05  bl 0x82e71d80
	ctx.lr = 0x82E72180;
	sub_82E71D80(ctx, base);
	// 82E72180: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E72184: 41820018  beq 0x82e7219c
	if ctx.cr[0].eq {
	pc = 0x82E7219C; continue 'dispatch;
	}
	// 82E72188: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E7218C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E72190: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E72194: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E72198: 4E800421  bctrl
	ctx.lr = 0x82E7219C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E7219C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E721A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E721A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E721A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E721AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E721B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E721B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E721B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E721B8 size=680
    let mut pc: u32 = 0x82E721B8;
    'dispatch: loop {
        match pc {
            0x82E721B8 => {
    //   block [0x82E721B8..0x82E72460)
	// 82E721B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E721BC: 4BE3724D  bl 0x82ca9408
	ctx.lr = 0x82E721C0;
	sub_82CA93D0(ctx, base);
	// 82E721C0: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82E721C4: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82E721C8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E721CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E721D0: 4B3F7391  bl 0x82269560
	ctx.lr = 0x82E721D4;
	sub_82269560(ctx, base);
	// 82E721D4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82E721D8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E721DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E721E0: 9B9F002C  stb r28, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[28].u8 ) };
	// 82E721E4: 409A0028  bne cr6, 0x82e7220c
	if !ctx.cr[6].eq {
	pc = 0x82E7220C; continue 'dispatch;
	}
	// 82E721E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E721EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E721F0: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E721F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E721F8: 4E800421  bctrl
	ctx.lr = 0x82E721FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E721FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E72200: 4082000C  bne 0x82e7220c
	if !ctx.cr[0].eq {
	pc = 0x82E7220C; continue 'dispatch;
	}
	// 82E72204: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E72208: 48000248  b 0x82e72450
	pc = 0x82E72450; continue 'dispatch;
	// 82E7220C: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E72210: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E72214: 419A0238  beq cr6, 0x82e7244c
	if ctx.cr[6].eq {
	pc = 0x82E7244C; continue 'dispatch;
	}
	// 82E72218: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E7221C: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82E72220: 4B3EE799  bl 0x822609b8
	ctx.lr = 0x82E72224;
	sub_822609B8(ctx, base);
	// 82E72224: 8963006C  lbz r11, 0x6c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E72228: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7222C: 40820050  bne 0x82e7227c
	if !ctx.cr[0].eq {
	pc = 0x82E7227C; continue 'dispatch;
	}
	// 82E72230: 4B3EE789  bl 0x822609b8
	ctx.lr = 0x82E72234;
	sub_822609B8(ctx, base);
	// 82E72234: C01F0050  lfs f0, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72238: C3E3004C  lfs f31, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E7223C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E72240: EDBF0028  fsubs f13, f31, f0
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E72244: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72248: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E7224C: 40990030  ble cr6, 0x82e7227c
	if !ctx.cr[6].gt {
	pc = 0x82E7227C; continue 'dispatch;
	}
	// 82E72250: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E72254: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E72258: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E7225C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E72260: 4E800421  bctrl
	ctx.lr = 0x82E72264;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E72264: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E72268: 40820010  bne 0x82e72278
	if !ctx.cr[0].eq {
	pc = 0x82E72278; continue 'dispatch;
	}
	// 82E7226C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82E72270: 93BF0054  stw r29, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82E72274: 48000008  b 0x82e7227c
	pc = 0x82E7227C; continue 'dispatch;
	// 82E72278: D3FF0050  stfs f31, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E7227C: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E72280: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E72284: 419A01C4  beq cr6, 0x82e72448
	if ctx.cr[6].eq {
	pc = 0x82E72448; continue 'dispatch;
	}
	// 82E72288: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7228C: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E72290: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E72294: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E72298: C3E30014  lfs f31, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E7229C: C3C30018  lfs f30, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E722A0: C02A0C14  lfs f1, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E722A4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E722A8: 4182000C  beq 0x82e722b4
	if ctx.cr[0].eq {
	pc = 0x82E722B4; continue 'dispatch;
	}
	// 82E722AC: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E722B0: 48000008  b 0x82e722b8
	pc = 0x82E722B8; continue 'dispatch;
	// 82E722B4: FDA00890  fmr f13, f1
	ctx.f[13].f64 = ctx.f[1].f64;
	// 82E722B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E722BC: 41820008  beq 0x82e722c4
	if ctx.cr[0].eq {
	pc = 0x82E722C4; continue 'dispatch;
	}
	// 82E722C0: C02B000C  lfs f1, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E722C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E722C8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E722CC: C00B0A98  lfs f0, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E722D0: 816A0030  lwz r11, 0x30(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E722D4: EC4D0032  fmuls f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E722D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E722DC: 4E800421  bctrl
	ctx.lr = 0x82E722E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E722E0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82E722E4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E722E8: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82E722EC: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82E722F0: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82E722F4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82E722F8: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E722FC: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E72300: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82E72304: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72308: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E7230C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72310: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82E72314: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E72318: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82E7231C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82E72320: 4200FFF8  bdnz 0x82e72318
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E72318; continue 'dispatch;
	}
	// 82E72324: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E72328: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E7232C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E72330: 9BA100B8  stb r29, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[29].u8 ) };
	// 82E72334: 394A10BC  addi r10, r10, 0x10bc
	ctx.r[10].s64 = ctx.r[10].s64 + 4284;
	// 82E72338: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E7233C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E72340: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E72344: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82E72348: 4B33C361  bl 0x821ae6a8
	ctx.lr = 0x82E7234C;
	sub_821AE6A8(ctx, base);
	// 82E7234C: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E72350: C03F0070  lfs f1, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E72354: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E72358: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E7235C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E72360: 4E800421  bctrl
	ctx.lr = 0x82E72364;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E72364: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E72368: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E7236C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E72370: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E72374: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E72378: 4E800421  bctrl
	ctx.lr = 0x82E7237C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E7237C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E72380: 41820020  beq 0x82e723a0
	if ctx.cr[0].eq {
	pc = 0x82E723A0; continue 'dispatch;
	}
	// 82E72384: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E72388: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E7238C: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E72390: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E72394: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E72398: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E7239C: 4E800421  bctrl
	ctx.lr = 0x82E723A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E723A0: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E723A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E723A8: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E723AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E723B0: 4E800421  bctrl
	ctx.lr = 0x82E723B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E723B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E723B8: 41820008  beq 0x82e723c0
	if ctx.cr[0].eq {
	pc = 0x82E723C0; continue 'dispatch;
	}
	// 82E723BC: 9B9F006C  stb r28, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[28].u8 ) };
	// 82E723C0: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E723C4: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82E723C8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E723CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E723D0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E723D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E723D8: 4E800421  bctrl
	ctx.lr = 0x82E723DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E723DC: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E723E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E723E4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E723E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E723EC: 4E800421  bctrl
	ctx.lr = 0x82E723F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E723F0: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82E723F4: 419AFE10  beq cr6, 0x82e72204
	if ctx.cr[6].eq {
	pc = 0x82E72204; continue 'dispatch;
	}
	// 82E723F8: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E723FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E72400: 4182004C  beq 0x82e7244c
	if ctx.cr[0].eq {
	pc = 0x82E7244C; continue 'dispatch;
	}
	// 82E72404: 897F006C  lbz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E72408: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7240C: 4182001C  beq 0x82e72428
	if ctx.cr[0].eq {
	pc = 0x82E72428; continue 'dispatch;
	}
	// 82E72410: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E72414: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E72418: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E7241C: C02B0C18  lfs f1, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E72420: 38A40034  addi r5, r4, 0x34
	ctx.r[5].s64 = ctx.r[4].s64 + 52;
	// 82E72424: 4800001C  b 0x82e72440
	pc = 0x82E72440; continue 'dispatch;
	// 82E72428: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E7242C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E72430: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E72434: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	// 82E72438: C02A0C18  lfs f1, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E7243C: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E72440: 4B436DD9  bl 0x822a9218
	ctx.lr = 0x82E72444;
	sub_822A9218(ctx, base);
	// 82E72444: 48000008  b 0x82e7244c
	pc = 0x82E7244C; continue 'dispatch;
	// 82E72448: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E7244C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E72450: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82E72454: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82E72458: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82E7245C: 4BE36FFC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E72460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E72460 size=216
    let mut pc: u32 = 0x82E72460;
    'dispatch: loop {
        match pc {
            0x82E72460 => {
    //   block [0x82E72460..0x82E72538)
	// 82E72460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E72464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E72468: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E7246C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E72470: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E72474: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E72478: 54AB063F  clrlwi. r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E7247C: 40820010  bne 0x82e7248c
	if !ctx.cr[0].eq {
	pc = 0x82E7248C; continue 'dispatch;
	}
	// 82E72480: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E72484: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E72488: 40990098  ble cr6, 0x82e72520
	if !ctx.cr[6].gt {
	pc = 0x82E72520; continue 'dispatch;
	}
	// 82E7248C: 807E0038  lwz r3, 0x38(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E72490: 909E0040  stw r4, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[4].u32 ) };
	// 82E72494: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E72498: 41820014  beq 0x82e724ac
	if ctx.cr[0].eq {
	pc = 0x82E724AC; continue 'dispatch;
	}
	// 82E7249C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E724A0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E724A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E724A8: 4E800421  bctrl
	ctx.lr = 0x82E724AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E724AC: 83FE0040  lwz r31, 0x40(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E724B0: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E724B4: 4182005C  beq 0x82e72510
	if ctx.cr[0].eq {
	pc = 0x82E72510; continue 'dispatch;
	}
	// 82E724B8: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 82E724BC: 1C7F000C  mulli r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 * 12;
	// 82E724C0: 616B5555  ori r11, r11, 0x5555
	ctx.r[11].u64 = ctx.r[11].u64 | 21845;
	// 82E724C4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E724C8: 40990008  ble cr6, 0x82e724d0
	if !ctx.cr[6].gt {
	pc = 0x82E724D0; continue 'dispatch;
	}
	// 82E724CC: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82E724D0: 4B7A4459  bl 0x82616928
	ctx.lr = 0x82E724D4;
	sub_82616928(ctx, base);
	// 82E724D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E724D8: 41820038  beq 0x82e72510
	if ctx.cr[0].eq {
	pc = 0x82E72510; continue 'dispatch;
	}
	// 82E724DC: 355FFFFF  addic. r10, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E724E0: 41800028  blt 0x82e72508
	if ctx.cr[0].lt {
	pc = 0x82E72508; continue 'dispatch;
	}
	// 82E724E4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E724E8: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 82E724EC: C0090C18  lfs f0, 0xc18(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E724F0: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82E724F4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E724F8: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82E724FC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E72500: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82E72504: 4080FFEC  bge 0x82e724f0
	if !ctx.cr[0].lt {
	pc = 0x82E724F0; continue 'dispatch;
	}
	// 82E72508: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E7250C: 48000008  b 0x82e72514
	pc = 0x82E72514; continue 'dispatch;
	// 82E72510: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E72514: 917E0038  stw r11, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82E72518: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E7251C: 917E003C  stw r11, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82E72520: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E72524: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E72528: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E7252C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E72530: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E72534: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E72538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E72538 size=160
    let mut pc: u32 = 0x82E72538;
    'dispatch: loop {
        match pc {
            0x82E72538 => {
    //   block [0x82E72538..0x82E725D8)
	// 82E72538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7253C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E72540: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E72544: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E72548: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7254C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E72550: 54AB063F  clrlwi. r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E72554: 40820010  bne 0x82e72564
	if !ctx.cr[0].eq {
	pc = 0x82E72564; continue 'dispatch;
	}
	// 82E72558: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82E7255C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E72560: 40990060  ble cr6, 0x82e725c0
	if !ctx.cr[6].gt {
	pc = 0x82E725C0; continue 'dispatch;
	}
	// 82E72564: 807F0044  lwz r3, 0x44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E72568: 909F004C  stw r4, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[4].u32 ) };
	// 82E7256C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E72570: 41820014  beq 0x82e72584
	if ctx.cr[0].eq {
	pc = 0x82E72584; continue 'dispatch;
	}
	// 82E72574: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E72578: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E7257C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E72580: 4E800421  bctrl
	ctx.lr = 0x82E72584;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E72584: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82E72588: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E7258C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E72590: 4082000C  bne 0x82e7259c
	if !ctx.cr[0].eq {
	pc = 0x82E7259C; continue 'dispatch;
	}
	// 82E72594: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 82E72598: 48000024  b 0x82e725bc
	pc = 0x82E725BC; continue 'dispatch;
	// 82E7259C: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82E725A0: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82E725A4: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82E725A8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E725AC: 40990008  ble cr6, 0x82e725b4
	if !ctx.cr[6].gt {
	pc = 0x82E725B4; continue 'dispatch;
	}
	// 82E725B0: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82E725B4: 4B7A4375  bl 0x82616928
	ctx.lr = 0x82E725B8;
	sub_82616928(ctx, base);
	// 82E725B8: 907F0044  stw r3, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[3].u32 ) };
	// 82E725BC: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 82E725C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E725C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E725C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E725CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E725D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E725D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E725D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E725D8 size=852
    let mut pc: u32 = 0x82E725D8;
    'dispatch: loop {
        match pc {
            0x82E725D8 => {
    //   block [0x82E725D8..0x82E7292C)
	// 82E725D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E725DC: 4BE36E29  bl 0x82ca9404
	ctx.lr = 0x82E725E0;
	sub_82CA93D0(ctx, base);
	// 82E725E0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E725E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E725E8: 4B3EE3D1  bl 0x822609b8
	ctx.lr = 0x82E725EC;
	sub_822609B8(ctx, base);
	// 82E725EC: C01F0050  lfs f0, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E725F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E725F4: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E725F8: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E725FC: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72600: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E72604: 4198031C  blt cr6, 0x82e72920
	if ctx.cr[6].lt {
	pc = 0x82E72920; continue 'dispatch;
	}
	// 82E72608: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E7260C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E72610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E72614: 409A0270  bne cr6, 0x82e72884
	if !ctx.cr[6].eq {
	pc = 0x82E72884; continue 'dispatch;
	}
	// 82E72618: 809F0034  lwz r4, 0x34(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E7261C: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E72620: 4801AF19  bl 0x82e8d538
	ctx.lr = 0x82E72624;
	sub_82E8D538(ctx, base);
	// 82E72624: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E72628: 4182025C  beq 0x82e72884
	if ctx.cr[0].eq {
	pc = 0x82E72884; continue 'dispatch;
	}
	// 82E7262C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E72630: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 82E72634: 9BBF006C  stb r29, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[29].u8 ) };
	// 82E72638: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82E7263C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E72640: 9BA30054  stb r29, 0x54(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[29].u8 ) };
	// 82E72644: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82E72648: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82E7264C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82E72650: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E72654: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72658: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82E7265C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82E72660: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82E72664: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E72668: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82E7266C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82E72670: 4200FFF8  bdnz 0x82e72668
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E72668; continue 'dispatch;
	}
	// 82E72674: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E72678: 9BA100C8  stb r29, 0xc8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[29].u8 ) };
	// 82E7267C: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 82E72680: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82E72684: 396B10BC  addi r11, r11, 0x10bc
	ctx.r[11].s64 = ctx.r[11].s64 + 4284;
	// 82E72688: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82E7268C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E72690: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82E72694: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E72698: 4B33C011  bl 0x821ae6a8
	ctx.lr = 0x82E7269C;
	sub_821AE6A8(ctx, base);
	// 82E7269C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E726A0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82E726A4: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E726A8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E726AC: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82E726B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E726B4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E726B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E726BC: 4E800421  bctrl
	ctx.lr = 0x82E726C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E726C0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E726C4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E726C8: 409A00F0  bne cr6, 0x82e727b8
	if !ctx.cr[6].eq {
	pc = 0x82E727B8; continue 'dispatch;
	}
	// 82E726CC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E726D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E726D4: 419A001C  beq cr6, 0x82e726f0
	if ctx.cr[6].eq {
	pc = 0x82E726F0; continue 'dispatch;
	}
	// 82E726D8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E726DC: 813F0064  lwz r9, 0x64(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E726E0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E726E4: 409A000C  bne cr6, 0x82e726f0
	if !ctx.cr[6].eq {
	pc = 0x82E726F0; continue 'dispatch;
	}
	// 82E726E8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82E726EC: 480000C4  b 0x82e727b0
	pc = 0x82E727B0; continue 'dispatch;
	// 82E726F0: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E726F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E726F8: 41820098  beq 0x82e72790
	if ctx.cr[0].eq {
	pc = 0x82E72790; continue 'dispatch;
	}
	// 82E726FC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82E72700: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E72704: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E72708: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E7270C: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E72710: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E72714: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E72718: 4E800421  bctrl
	ctx.lr = 0x82E7271C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E7271C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E72720: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E72724: 409A006C  bne cr6, 0x82e72790
	if !ctx.cr[6].eq {
	pc = 0x82E72790; continue 'dispatch;
	}
	// 82E72728: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E7272C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82E72730: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E72734: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82E72738: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E7273C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E72740: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E72744: 4E800421  bctrl
	ctx.lr = 0x82E72748;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E72748: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E7274C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E72750: 409A0040  bne cr6, 0x82e72790
	if !ctx.cr[6].eq {
	pc = 0x82E72790; continue 'dispatch;
	}
	// 82E72754: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E72758: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E7275C: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82E72760: 419A0030  beq cr6, 0x82e72790
	if ctx.cr[6].eq {
	pc = 0x82E72790; continue 'dispatch;
	}
	// 82E72764: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E72768: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E7276C: 40980024  bge cr6, 0x82e72790
	if !ctx.cr[6].lt {
	pc = 0x82E72790; continue 'dispatch;
	}
	// 82E72770: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E72774: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 * 20;
	// 82E72778: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E7277C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E72780: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E72784: 419A000C  beq cr6, 0x82e72790
	if ctx.cr[6].eq {
	pc = 0x82E72790; continue 'dispatch;
	}
	// 82E72788: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7278C: 40820070  bne 0x82e727fc
	if !ctx.cr[0].eq {
	pc = 0x82E727FC; continue 'dispatch;
	}
	// 82E72790: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E72794: 80DF001C  lwz r6, 0x1c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E72798: 80BF0068  lwz r5, 0x68(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82E7279C: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E727A0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E727A4: 386B0034  addi r3, r11, 0x34
	ctx.r[3].s64 = ctx.r[11].s64 + 52;
	// 82E727A8: 48001431  bl 0x82e73bd8
	ctx.lr = 0x82E727AC;
	sub_82E73BD8(ctx, base);
	// 82E727AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E727B0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E727B4: 409A0048  bne cr6, 0x82e727fc
	if !ctx.cr[6].eq {
	pc = 0x82E727FC; continue 'dispatch;
	}
	// 82E727B8: 809F0030  lwz r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E727BC: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E727C0: 4801ADF1  bl 0x82e8d5b0
	ctx.lr = 0x82E727C4;
	sub_82E8D5B0(ctx, base);
	// 82E727C4: 93BF0030  stw r29, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[29].u32 ) };
	// 82E727C8: 93BF0054  stw r29, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82E727CC: 4B3EE1ED  bl 0x822609b8
	ctx.lr = 0x82E727D0;
	sub_822609B8(ctx, base);
	// 82E727D0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E727D4: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E727D8: 83DF0074  lwz r30, 0x74(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E727DC: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E727E0: 83EB0014  lwz r31, 0x14(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E727E4: 4B3EE1D5  bl 0x822609b8
	ctx.lr = 0x82E727E8;
	sub_822609B8(ctx, base);
	// 82E727E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E727EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E727F0: 4800F281  bl 0x82e81a70
	ctx.lr = 0x82E727F4;
	sub_82E81A70(ctx, base);
	// 82E727F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E727F8: 4800012C  b 0x82e72924
	pc = 0x82E72924; continue 'dispatch;
	// 82E727FC: 809F0074  lwz r4, 0x74(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E72800: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E72804: 4B87290D  bl 0x826e5110
	ctx.lr = 0x82E72808;
	sub_826E5110(ctx, base);
	// 82E72808: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E7280C: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E72810: 480262F1  bl 0x82e98b00
	ctx.lr = 0x82E72814;
	sub_82E98B00(ctx, base);
	// 82E72814: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E72818: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E7281C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E72820: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E72824: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E72828: 4E800421  bctrl
	ctx.lr = 0x82E7282C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E7282C: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E72830: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E72834: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E72838: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E7283C: 914B0050  stw r10, 0x50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82E72840: 912B0048  stw r9, 0x48(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), ctx.r[9].u32 ) };
	// 82E72844: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E72848: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E7284C: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E72850: 914B004C  stw r10, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[10].u32 ) };
	// 82E72854: 912B0044  stw r9, 0x44(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[9].u32 ) };
	// 82E72858: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E7285C: 480020FD  bl 0x82e74958
	ctx.lr = 0x82E72860;
	sub_82E74958(ctx, base);
	// 82E72860: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E72864: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E72868: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E7286C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E72870: 4E800421  bctrl
	ctx.lr = 0x82E72874;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E72874: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E72878: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E7287C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E72880: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82E72884: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E72888: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7288C: 41820078  beq 0x82e72904
	if ctx.cr[0].eq {
	pc = 0x82E72904; continue 'dispatch;
	}
	// 82E72890: 48002389  bl 0x82e74c18
	ctx.lr = 0x82E72894;
	sub_82E74C18(ctx, base);
	// 82E72894: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E72898: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E7289C: 409A0084  bne cr6, 0x82e72920
	if !ctx.cr[6].eq {
	pc = 0x82E72920; continue 'dispatch;
	}
	// 82E728A0: 3BDF0054  addi r30, r31, 0x54
	ctx.r[30].s64 = ctx.r[31].s64 + 84;
	// 82E728A4: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E728A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E728AC: 480020B5  bl 0x82e74960
	ctx.lr = 0x82E728B0;
	sub_82E74960(ctx, base);
	// 82E728B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E728B4: 40820008  bne 0x82e728bc
	if !ctx.cr[0].eq {
	pc = 0x82E728BC; continue 'dispatch;
	}
	// 82E728B8: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82E728BC: 4B3EE0FD  bl 0x822609b8
	ctx.lr = 0x82E728C0;
	sub_822609B8(ctx, base);
	// 82E728C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E728C4: 809F0030  lwz r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E728C8: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E728CC: C00B004C  lfs f0, 0x4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E728D0: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E728D4: 4801ACDD  bl 0x82e8d5b0
	ctx.lr = 0x82E728D8;
	sub_82E8D5B0(ctx, base);
	// 82E728D8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E728DC: 839F0074  lwz r28, 0x74(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E728E0: 836B0014  lwz r27, 0x14(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E728E4: 4B3EE0D5  bl 0x822609b8
	ctx.lr = 0x82E728E8;
	sub_822609B8(ctx, base);
	// 82E728E8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E728EC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82E728F0: 4800F181  bl 0x82e81a70
	ctx.lr = 0x82E728F4;
	sub_82E81A70(ctx, base);
	// 82E728F4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E728F8: 93BF0030  stw r29, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[29].u32 ) };
	// 82E728FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E72900: 48000020  b 0x82e72920
	pc = 0x82E72920; continue 'dispatch;
	// 82E72904: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E72908: 83FF0074  lwz r31, 0x74(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E7290C: 83CB0014  lwz r30, 0x14(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E72910: 4B3EE0A9  bl 0x822609b8
	ctx.lr = 0x82E72914;
	sub_822609B8(ctx, base);
	// 82E72914: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E72918: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E7291C: 4800F31D  bl 0x82e81c38
	ctx.lr = 0x82E72920;
	sub_82E81C38(ctx, base);
	// 82E72920: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E72924: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82E72928: 4BE36B2C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E72930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E72930 size=240
    let mut pc: u32 = 0x82E72930;
    'dispatch: loop {
        match pc {
            0x82E72930 => {
    //   block [0x82E72930..0x82E72A20)
	// 82E72930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E72934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E72938: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E7293C: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E72940: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E72944: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E72948: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82E7294C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E72950: 41820064  beq 0x82e729b4
	if ctx.cr[0].eq {
	pc = 0x82E729B4; continue 'dispatch;
	}
	// 82E72954: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82E72958: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82E7295C: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82E72960: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82E72964: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72968: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E7296C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82E72970: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72974: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E72978: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7297C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82E72980: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E72984: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82E72988: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82E7298C: 4200FFF8  bdnz 0x82e72984
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E72984; continue 'dispatch;
	}
	// 82E72990: 38840058  addi r4, r4, 0x58
	ctx.r[4].s64 = ctx.r[4].s64 + 88;
	// 82E72994: 990100A8  stb r8, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[8].u8 ) };
	// 82E72998: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82E7299C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E729A0: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E729A4: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E729A8: 4B33BD01  bl 0x821ae6a8
	ctx.lr = 0x82E729AC;
	sub_821AE6A8(ctx, base);
	// 82E729AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E729B0: 48000050  b 0x82e72a00
	pc = 0x82E72A00; continue 'dispatch;
	// 82E729B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E729B8: 80E40008  lwz r7, 8(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E729BC: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 82E729C0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E729C4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82E729C8: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82E729CC: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E729D0: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E729D4: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82E729D8: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E729DC: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82E729E0: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E729E4: D00100BC  stfs f0, 0xbc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82E729E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E729EC: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82E729F0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82E729F4: 4200FFF8  bdnz 0x82e729ec
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E729EC; continue 'dispatch;
	}
	// 82E729F8: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82E729FC: 99010108  stb r8, 0x108(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[8].u8 ) };
	// 82E72A00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E72A04: 4B33A04D  bl 0x821aca50
	ctx.lr = 0x82E72A08;
	sub_821ACA50(ctx, base);
	// 82E72A08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E72A0C: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82E72A10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E72A14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E72A18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E72A1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E72A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E72A20 size=396
    let mut pc: u32 = 0x82E72A20;
    'dispatch: loop {
        match pc {
            0x82E72A20 => {
    //   block [0x82E72A20..0x82E72BAC)
	// 82E72A20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E72A24: 4BE369E9  bl 0x82ca940c
	ctx.lr = 0x82E72A28;
	sub_82CA93D0(ctx, base);
	// 82E72A28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E72A2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E72A30: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E72A34: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E72A38: 388B1048  addi r4, r11, 0x1048
	ctx.r[4].s64 = ctx.r[11].s64 + 4168;
	// 82E72A3C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E72A40: 4B3F4AD1  bl 0x82267510
	ctx.lr = 0x82E72A44;
	sub_82267510(ctx, base);
	// 82E72A44: 3FC08334  lis r30, -0x7ccc
	ctx.r[30].s64 = -2093744128;
	// 82E72A48: 907F001C  stw r3, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 82E72A4C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E72A50: 388B2E38  addi r4, r11, 0x2e38
	ctx.r[4].s64 = ctx.r[11].s64 + 11832;
	// 82E72A54: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E72A58: 4B3F51C9  bl 0x82267c20
	ctx.lr = 0x82E72A5C;
	sub_82267C20(ctx, base);
	// 82E72A5C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E72A60: 907F0024  stw r3, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 82E72A64: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E72A68: 388BE4AC  addi r4, r11, -0x1b54
	ctx.r[4].s64 = ctx.r[11].s64 + -6996;
	// 82E72A6C: 4B3F51B5  bl 0x82267c20
	ctx.lr = 0x82E72A70;
	sub_82267C20(ctx, base);
	// 82E72A70: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E72A74: 907F0028  stw r3, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[3].u32 ) };
	// 82E72A78: 388BDF68  addi r4, r11, -0x2098
	ctx.r[4].s64 = ctx.r[11].s64 + -8344;
	// 82E72A7C: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E72A80: 4B3F51A1  bl 0x82267c20
	ctx.lr = 0x82E72A84;
	sub_82267C20(ctx, base);
	// 82E72A84: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E72A88: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E72A8C: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 82E72A90: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E72A94: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82E72A98: 419A0108  beq cr6, 0x82e72ba0
	if ctx.cr[6].eq {
	pc = 0x82E72BA0; continue 'dispatch;
	}
	// 82E72A9C: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E72AA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E72AA4: 419A00FC  beq cr6, 0x82e72ba0
	if ctx.cr[6].eq {
	pc = 0x82E72BA0; continue 'dispatch;
	}
	// 82E72AA8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E72AAC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E72AB0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E72AB4: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82E72AB8: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E72ABC: 4B375BBD  bl 0x821e8678
	ctx.lr = 0x82E72AC0;
	sub_821E8678(ctx, base);
	// 82E72AC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E72AC4: 4182000C  beq 0x82e72ad0
	if ctx.cr[0].eq {
	pc = 0x82E72AD0; continue 'dispatch;
	}
	// 82E72AC8: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72ACC: 48000020  b 0x82e72aec
	pc = 0x82E72AEC; continue 'dispatch;
	// 82E72AD0: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E72AD4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E72AD8: 4182000C  beq 0x82e72ae4
	if ctx.cr[0].eq {
	pc = 0x82E72AE4; continue 'dispatch;
	}
	// 82E72ADC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72AE0: 4800000C  b 0x82e72aec
	pc = 0x82E72AEC; continue 'dispatch;
	// 82E72AE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E72AE8: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72AEC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E72AF0: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82E72AF4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E72AF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E72AFC: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82E72B00: 480167C9  bl 0x82e892c8
	ctx.lr = 0x82E72B04;
	sub_82E892C8(ctx, base);
	// 82E72B04: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E72B08: 41820098  beq 0x82e72ba0
	if ctx.cr[0].eq {
	pc = 0x82E72BA0; continue 'dispatch;
	}
	// 82E72B0C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E72B10: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E72B14: 409A0014  bne cr6, 0x82e72b28
	if !ctx.cr[6].eq {
	pc = 0x82E72B28; continue 'dispatch;
	}
	// 82E72B18: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E72B1C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82E72B20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E72B24: 4BFFFA15  bl 0x82e72538
	ctx.lr = 0x82E72B28;
	sub_82E72538(ctx, base);
	// 82E72B28: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E72B2C: 3BCB88D4  addi r30, r11, -0x772c
	ctx.r[30].s64 = ctx.r[11].s64 + -30508;
	// 82E72B30: 4B3EDE89  bl 0x822609b8
	ctx.lr = 0x82E72B34;
	sub_822609B8(ctx, base);
	// 82E72B34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E72B38: 4800E631  bl 0x82e81168
	ctx.lr = 0x82E72B3C;
	sub_82E81168(ctx, base);
	// 82E72B3C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E72B40: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82E72B44: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E72B48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E72B4C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E72B50: 915F0074  stw r10, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82E72B54: 913F0030  stw r9, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[9].u32 ) };
	// 82E72B58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E72B5C: 4E800421  bctrl
	ctx.lr = 0x82E72B60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E72B60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E72B64: 4182003C  beq 0x82e72ba0
	if ctx.cr[0].eq {
	pc = 0x82E72BA0; continue 'dispatch;
	}
	// 82E72B68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E72B6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E72B70: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E72B74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E72B78: 4E800421  bctrl
	ctx.lr = 0x82E72B7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E72B7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E72B80: 41820020  beq 0x82e72ba0
	if ctx.cr[0].eq {
	pc = 0x82E72BA0; continue 'dispatch;
	}
	// 82E72B84: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E72B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E72B8C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E72B90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E72B94: 4E800421  bctrl
	ctx.lr = 0x82E72B98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E72B98: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E72B9C: 48000008  b 0x82e72ba4
	pc = 0x82E72BA4; continue 'dispatch;
	// 82E72BA0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E72BA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E72BA8: 4BE368B4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E72BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E72BB0 size=528
    let mut pc: u32 = 0x82E72BB0;
    'dispatch: loop {
        match pc {
            0x82E72BB0 => {
    //   block [0x82E72BB0..0x82E72DC0)
	// 82E72BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E72BB4: 4BE36859  bl 0x82ca940c
	ctx.lr = 0x82E72BB8;
	sub_82CA93D0(ctx, base);
	// 82E72BB8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82E72BBC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E72BC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E72BC4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E72BC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E72BCC: 409A000C  bne cr6, 0x82e72bd8
	if !ctx.cr[6].eq {
	pc = 0x82E72BD8; continue 'dispatch;
	}
	// 82E72BD0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E72BD4: 480001E0  b 0x82e72db4
	pc = 0x82E72DB4; continue 'dispatch;
	// 82E72BD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E72BDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E72BE0: 3BCB88B4  addi r30, r11, -0x774c
	ctx.r[30].s64 = ctx.r[11].s64 + -30540;
	// 82E72BE4: 4834947D  bl 0x831bc060
	ctx.lr = 0x82E72BE8;
	sub_831BC060(ctx, base);
	// 82E72BE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E72BEC: 4BE39F65  bl 0x82cacb50
	ctx.lr = 0x82E72BF0;
	sub_82CACB50(ctx, base);
	// 82E72BF0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E72BF4: 40820044  bne 0x82e72c38
	if !ctx.cr[0].eq {
	pc = 0x82E72C38; continue 'dispatch;
	}
	// 82E72BF8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E72BFC: 388B2E38  addi r4, r11, 0x2e38
	ctx.r[4].s64 = ctx.r[11].s64 + 11832;
	// 82E72C00: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E72C04: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E72C08: 4B3F5019  bl 0x82267c20
	ctx.lr = 0x82E72C0C;
	sub_82267C20(ctx, base);
	// 82E72C0C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82E72C10: 4182FFC0  beq 0x82e72bd0
	if ctx.cr[0].eq {
	pc = 0x82E72BD0; continue 'dispatch;
	}
	// 82E72C14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E72C18: 4BA9B0F1  bl 0x8290dd08
	ctx.lr = 0x82E72C1C;
	sub_8290DD08(ctx, base);
	// 82E72C1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E72C20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E72C24: 4801A595  bl 0x82e8d1b8
	ctx.lr = 0x82E72C28;
	sub_82E8D1B8(ctx, base);
	// 82E72C28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E72C2C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E72C30: 917D0034  stw r11, 0x34(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82E72C34: 48000180  b 0x82e72db4
	pc = 0x82E72DB4; continue 'dispatch;
	// 82E72C38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E72C3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E72C40: 3BCB88AC  addi r30, r11, -0x7754
	ctx.r[30].s64 = ctx.r[11].s64 + -30548;
	// 82E72C44: 4834941D  bl 0x831bc060
	ctx.lr = 0x82E72C48;
	sub_831BC060(ctx, base);
	// 82E72C48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E72C4C: 4BE39F05  bl 0x82cacb50
	ctx.lr = 0x82E72C50;
	sub_82CACB50(ctx, base);
	// 82E72C50: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E72C54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E72C58: 40820064  bne 0x82e72cbc
	if !ctx.cr[0].eq {
	pc = 0x82E72CBC; continue 'dispatch;
	}
	// 82E72C5C: 4BA9B0AD  bl 0x8290dd08
	ctx.lr = 0x82E72C60;
	sub_8290DD08(ctx, base);
	// 82E72C60: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82E72C64: 41820144  beq 0x82e72da8
	if ctx.cr[0].eq {
	pc = 0x82E72DA8; continue 'dispatch;
	}
	// 82E72C68: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E72C6C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E72C70: 4182FF60  beq 0x82e72bd0
	if ctx.cr[0].eq {
	pc = 0x82E72BD0; continue 'dispatch;
	}
	// 82E72C74: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E72C78: 48009651  bl 0x82e7c2c8
	ctx.lr = 0x82E72C7C;
	sub_82E7C2C8(ctx, base);
	// 82E72C7C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82E72C80: 4182FF50  beq 0x82e72bd0
	if ctx.cr[0].eq {
	pc = 0x82E72BD0; continue 'dispatch;
	}
	// 82E72C84: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E72C88: 807D0024  lwz r3, 0x24(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E72C8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E72C90: 38AB5D84  addi r5, r11, 0x5d84
	ctx.r[5].s64 = ctx.r[11].s64 + 23940;
	// 82E72C94: 4801A3FD  bl 0x82e8d090
	ctx.lr = 0x82E72C98;
	sub_82E8D090(ctx, base);
	// 82E72C98: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E72C9C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82E72CA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E72CA4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E72CA8: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E72CAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E72CB0: 4E800421  bctrl
	ctx.lr = 0x82E72CB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E72CB4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E72CB8: 480000FC  b 0x82e72db4
	pc = 0x82E72DB4; continue 'dispatch;
	// 82E72CBC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E72CC0: 3BCB8898  addi r30, r11, -0x7768
	ctx.r[30].s64 = ctx.r[11].s64 + -30568;
	// 82E72CC4: 4834939D  bl 0x831bc060
	ctx.lr = 0x82E72CC8;
	sub_831BC060(ctx, base);
	// 82E72CC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E72CCC: 4BE39E85  bl 0x82cacb50
	ctx.lr = 0x82E72CD0;
	sub_82CACB50(ctx, base);
	// 82E72CD0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E72CD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E72CD8: 40820028  bne 0x82e72d00
	if !ctx.cr[0].eq {
	pc = 0x82E72D00; continue 'dispatch;
	}
	// 82E72CDC: 4BA9B02D  bl 0x8290dd08
	ctx.lr = 0x82E72CE0;
	sub_8290DD08(ctx, base);
	// 82E72CE0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E72CE4: 418200C4  beq 0x82e72da8
	if ctx.cr[0].eq {
	pc = 0x82E72DA8; continue 'dispatch;
	}
	// 82E72CE8: 4BE376D9  bl 0x82caa3c0
	ctx.lr = 0x82E72CEC;
	sub_82CAA3C0(ctx, base);
	// 82E72CEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E72CF0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E72CF4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E72CF8: 4BFFF769  bl 0x82e72460
	ctx.lr = 0x82E72CFC;
	sub_82E72460(ctx, base);
	// 82E72CFC: 4BFFFFB8  b 0x82e72cb4
	pc = 0x82E72CB4; continue 'dispatch;
	// 82E72D00: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E72D04: 3BCB8880  addi r30, r11, -0x7780
	ctx.r[30].s64 = ctx.r[11].s64 + -30592;
	// 82E72D08: 48349359  bl 0x831bc060
	ctx.lr = 0x82E72D0C;
	sub_831BC060(ctx, base);
	// 82E72D0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E72D10: 4BE39E41  bl 0x82cacb50
	ctx.lr = 0x82E72D14;
	sub_82CACB50(ctx, base);
	// 82E72D14: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E72D18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E72D1C: 40820028  bne 0x82e72d44
	if !ctx.cr[0].eq {
	pc = 0x82E72D44; continue 'dispatch;
	}
	// 82E72D20: 4BA9AFE9  bl 0x8290dd08
	ctx.lr = 0x82E72D24;
	sub_8290DD08(ctx, base);
	// 82E72D24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E72D28: 41820080  beq 0x82e72da8
	if ctx.cr[0].eq {
	pc = 0x82E72DA8; continue 'dispatch;
	}
	// 82E72D2C: 4BE37695  bl 0x82caa3c0
	ctx.lr = 0x82E72D30;
	sub_82CAA3C0(ctx, base);
	// 82E72D30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E72D34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E72D38: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E72D3C: 4BFFF7FD  bl 0x82e72538
	ctx.lr = 0x82E72D40;
	sub_82E72538(ctx, base);
	// 82E72D40: 4BFFFF74  b 0x82e72cb4
	pc = 0x82E72CB4; continue 'dispatch;
	// 82E72D44: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82E72D48: 3BCB293C  addi r30, r11, 0x293c
	ctx.r[30].s64 = ctx.r[11].s64 + 10556;
	// 82E72D4C: 48349315  bl 0x831bc060
	ctx.lr = 0x82E72D50;
	sub_831BC060(ctx, base);
	// 82E72D50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E72D54: 4BE39DFD  bl 0x82cacb50
	ctx.lr = 0x82E72D58;
	sub_82CACB50(ctx, base);
	// 82E72D58: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E72D5C: 4082004C  bne 0x82e72da8
	if !ctx.cr[0].eq {
	pc = 0x82E72DA8; continue 'dispatch;
	}
	// 82E72D60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E72D64: 4BA9AFA5  bl 0x8290dd08
	ctx.lr = 0x82E72D68;
	sub_8290DD08(ctx, base);
	// 82E72D68: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E72D6C: 4182003C  beq 0x82e72da8
	if ctx.cr[0].eq {
	pc = 0x82E72DA8; continue 'dispatch;
	}
	// 82E72D70: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E72D74: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E72D78: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E72D7C: 4182000C  beq 0x82e72d88
	if ctx.cr[0].eq {
	pc = 0x82E72D88; continue 'dispatch;
	}
	// 82E72D80: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E72D84: 4800000C  b 0x82e72d90
	pc = 0x82E72D90; continue 'dispatch;
	// 82E72D88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E72D8C: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E72D90: 4BE38E21  bl 0x82cabbb0
	ctx.lr = 0x82E72D94;
	sub_82CABBB0(ctx, base);
	// 82E72D94: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E72D98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E72D9C: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E72DA0: 4B375859  bl 0x821e85f8
	ctx.lr = 0x82E72DA4;
	sub_821E85F8(ctx, base);
	// 82E72DA4: 4BFFFF10  b 0x82e72cb4
	pc = 0x82E72CB4; continue 'dispatch;
	// 82E72DA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E72DAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E72DB0: 4BFFD0E9  bl 0x82e6fe98
	ctx.lr = 0x82E72DB4;
	sub_82E6FE98(ctx, base);
	// 82E72DB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E72DB8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82E72DBC: 4BE366A0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E72DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E72DC0 size=12
    let mut pc: u32 = 0x82E72DC0;
    'dispatch: loop {
        match pc {
            0x82E72DC0 => {
    //   block [0x82E72DC0..0x82E72DCC)
	// 82E72DC0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E72DC4: 386BBAFC  addi r3, r11, -0x4504
	ctx.r[3].s64 = ctx.r[11].s64 + -17668;
	// 82E72DC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E72DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E72DD0 size=308
    let mut pc: u32 = 0x82E72DD0;
    'dispatch: loop {
        match pc {
            0x82E72DD0 => {
    //   block [0x82E72DD0..0x82E72F04)
	// 82E72DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E72DD4: 4BE36639  bl 0x82ca940c
	ctx.lr = 0x82E72DD8;
	sub_82CA93D0(ctx, base);
	// 82E72DD8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82E72DDC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E72DE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E72DE4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E72DE8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E72DEC: 388B1048  addi r4, r11, 0x1048
	ctx.r[4].s64 = ctx.r[11].s64 + 4168;
	// 82E72DF0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E72DF4: 4B3F471D  bl 0x82267510
	ctx.lr = 0x82E72DF8;
	sub_82267510(ctx, base);
	// 82E72DF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E72DFC: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82E72E00: 4082000C  bne 0x82e72e0c
	if !ctx.cr[0].eq {
	pc = 0x82E72E0C; continue 'dispatch;
	}
	// 82E72E04: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E72E08: 480000F0  b 0x82e72ef8
	pc = 0x82E72EF8; continue 'dispatch;
	// 82E72E0C: 3FC08334  lis r30, -0x7ccc
	ctx.r[30].s64 = -2093744128;
	// 82E72E10: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E72E14: 388BE4AC  addi r4, r11, -0x1b54
	ctx.r[4].s64 = ctx.r[11].s64 + -6996;
	// 82E72E18: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E72E1C: 4B3F4E05  bl 0x82267c20
	ctx.lr = 0x82E72E20;
	sub_82267C20(ctx, base);
	// 82E72E20: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82E72E24: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82E72E28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E72E2C: 995F0090  stb r10, 0x90(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u8 ) };
	// 82E72E30: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E72E34: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82E72E38: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82E72E3C: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E72E40: C3EA0C14  lfs f31, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E72E44: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E72E48: 4182000C  beq 0x82e72e54
	if ctx.cr[0].eq {
	pc = 0x82E72E54; continue 'dispatch;
	}
	// 82E72E4C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E72E50: 48000008  b 0x82e72e58
	pc = 0x82E72E58; continue 'dispatch;
	// 82E72E54: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	// 82E72E58: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E72E5C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E72E60: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E72E64: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82E72E68: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E72E6C: C00B0B20  lfs f0, 0xb20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2848 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72E70: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E72E74: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82E72E78: D1BF008C  stfs f13, 0x8c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82E72E7C: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E72E80: 4B3757F9  bl 0x821e8678
	ctx.lr = 0x82E72E84;
	sub_821E8678(ctx, base);
	// 82E72E84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E72E88: 4182000C  beq 0x82e72e94
	if ctx.cr[0].eq {
	pc = 0x82E72E94; continue 'dispatch;
	}
	// 82E72E8C: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72E90: 4800001C  b 0x82e72eac
	pc = 0x82E72EAC; continue 'dispatch;
	// 82E72E94: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E72E98: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E72E9C: 4182000C  beq 0x82e72ea8
	if ctx.cr[0].eq {
	pc = 0x82E72EA8; continue 'dispatch;
	}
	// 82E72EA0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72EA4: 48000008  b 0x82e72eac
	pc = 0x82E72EAC; continue 'dispatch;
	// 82E72EA8: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82E72EAC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E72EB0: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82E72EB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E72EB8: 48016411  bl 0x82e892c8
	ctx.lr = 0x82E72EBC;
	sub_82E892C8(ctx, base);
	// 82E72EBC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E72EC0: 4182FF44  beq 0x82e72e04
	if ctx.cr[0].eq {
	pc = 0x82E72E04; continue 'dispatch;
	}
	// 82E72EC4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E72EC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E72ECC: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E72ED0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E72ED4: 4E800421  bctrl
	ctx.lr = 0x82E72ED8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E72ED8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E72EDC: 4182FF28  beq 0x82e72e04
	if ctx.cr[0].eq {
	pc = 0x82E72E04; continue 'dispatch;
	}
	// 82E72EE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E72EE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E72EE8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E72EEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E72EF0: 4E800421  bctrl
	ctx.lr = 0x82E72EF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E72EF4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E72EF8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E72EFC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82E72F00: 4BE3655C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E72F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E72F08 size=116
    let mut pc: u32 = 0x82E72F08;
    'dispatch: loop {
        match pc {
            0x82E72F08 => {
    //   block [0x82E72F08..0x82E72F7C)
	// 82E72F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E72F0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E72F10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E72F14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E72F18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E72F1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E72F20: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E72F24: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82E72F28: 389F0078  addi r4, r31, 0x78
	ctx.r[4].s64 = ctx.r[31].s64 + 120;
	// 82E72F2C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82E72F30: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E72F34: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E72F38: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72F3C: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E72F40: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72F44: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E72F48: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72F4C: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E72F50: 9BC30058  stb r30, 0x58(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82E72F54: 93C40004  stw r30, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82E72F58: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E72F5C: 4B33B74D  bl 0x821ae6a8
	ctx.lr = 0x82E72F60;
	sub_821AE6A8(ctx, base);
	// 82E72F60: 9BDF0084  stb r30, 0x84(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[30].u8 ) };
	// 82E72F64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E72F68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E72F6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E72F70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E72F74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E72F78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E72F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E72F80 size=32
    let mut pc: u32 = 0x82E72F80;
    'dispatch: loop {
        match pc {
            0x82E72F80 => {
    //   block [0x82E72F80..0x82E72FA0)
	// 82E72F80: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82E72F84: 90830014  stw r4, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[4].u32 ) };
	// 82E72F88: 90A30018  stw r5, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[5].u32 ) };
	// 82E72F8C: 419A0014  beq cr6, 0x82e72fa0
	if ctx.cr[6].eq {
		sub_82E72FA0(ctx, base);
		return;
	}
	// 82E72F90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E72F94: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E72F98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E72F9C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E72FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E72FA0 size=68
    let mut pc: u32 = 0x82E72FA0;
    'dispatch: loop {
        match pc {
            0x82E72FA0 => {
    //   block [0x82E72FA0..0x82E72FE4)
	// 82E72FA0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E72FA4: 3963001C  addi r11, r3, 0x1c
	ctx.r[11].s64 = ctx.r[3].s64 + 28;
	// 82E72FA8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E72FAC: 38830078  addi r4, r3, 0x78
	ctx.r[4].s64 = ctx.r[3].s64 + 120;
	// 82E72FB0: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 82E72FB4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E72FB8: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E72FBC: C00A0034  lfs f0, 0x34(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72FC0: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E72FC4: C00A0038  lfs f0, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72FC8: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E72FCC: C00A003C  lfs f0, 0x3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E72FD0: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E72FD4: 992B0058  stb r9, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 82E72FD8: 91240004  stw r9, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82E72FDC: 91040008  stw r8, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82E72FE0: 4B33B6C8  b 0x821ae6a8
	sub_821AE6A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E72FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E72FE8 size=160
    let mut pc: u32 = 0x82E72FE8;
    'dispatch: loop {
        match pc {
            0x82E72FE8 => {
    //   block [0x82E72FE8..0x82E73088)
	// 82E72FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E72FEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E72FF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E72FF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E72FF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E72FFC: 480161DD  bl 0x82e891d8
	ctx.lr = 0x82E73000;
	sub_82E891D8(ctx, base);
	// 82E73000: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E73004: 397F001C  addi r11, r31, 0x1c
	ctx.r[11].s64 = ctx.r[31].s64 + 28;
	// 82E73008: 392A2938  addi r9, r10, 0x2938
	ctx.r[9].s64 = ctx.r[10].s64 + 10552;
	// 82E7300C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E73010: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E73014: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82E73018: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7301C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82E73020: 390A9128  addi r8, r10, -0x6ed8
	ctx.r[8].s64 = ctx.r[10].s64 + -28376;
	// 82E73024: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E73028: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82E7302C: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82E73030: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82E73034: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E73038: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E7303C: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 82E73040: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E73044: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82E73048: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E7304C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82E73050: 4200FFF8  bdnz 0x82e73048
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E73048; continue 'dispatch;
	}
	// 82E73054: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E73058: 994B0058  stb r10, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[10].u8 ) };
	// 82E7305C: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 82E73060: 915F007C  stw r10, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 82E73064: 392910BC  addi r9, r9, 0x10bc
	ctx.r[9].s64 = ctx.r[9].s64 + 4284;
	// 82E73068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7306C: 911F0080  stw r8, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[8].u32 ) };
	// 82E73070: 913F0078  stw r9, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 82E73074: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E73078: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E7307C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E73080: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E73084: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E73088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E73088 size=116
    let mut pc: u32 = 0x82E73088;
    'dispatch: loop {
        match pc {
            0x82E73088 => {
    //   block [0x82E73088..0x82E730FC)
	// 82E73088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7308C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E73090: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E73094: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E73098: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7309C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E730A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E730A4: 394B2938  addi r10, r11, 0x2938
	ctx.r[10].s64 = ctx.r[11].s64 + 10552;
	// 82E730A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E730AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E730B0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E730B4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E730B8: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82E730BC: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82E730C0: 48016139  bl 0x82e891f8
	ctx.lr = 0x82E730C4;
	sub_82E891F8(ctx, base);
	// 82E730C4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E730C8: 41820018  beq 0x82e730e0
	if ctx.cr[0].eq {
	pc = 0x82E730E0; continue 'dispatch;
	}
	// 82E730CC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E730D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E730D4: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E730D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E730DC: 4E800421  bctrl
	ctx.lr = 0x82E730E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E730E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E730E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E730E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E730EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E730F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E730F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E730F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E73100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E73100 size=568
    let mut pc: u32 = 0x82E73100;
    'dispatch: loop {
        match pc {
            0x82E73100 => {
    //   block [0x82E73100..0x82E73338)
	// 82E73100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E73104: 4BE36305  bl 0x82ca9408
	ctx.lr = 0x82E73108;
	sub_82CA93D0(ctx, base);
	// 82E73108: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82E7310C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E73110: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E73114: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E73118: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E7311C: 409A000C  bne cr6, 0x82e73128
	if !ctx.cr[6].eq {
	pc = 0x82E73128; continue 'dispatch;
	}
	// 82E73120: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E73124: 48000208  b 0x82e7332c
	pc = 0x82E7332C; continue 'dispatch;
	// 82E73128: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E7312C: 48348F35  bl 0x831bc060
	ctx.lr = 0x82E73130;
	sub_831BC060(ctx, base);
	// 82E73130: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E73134: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E73138: 388B88AC  addi r4, r11, -0x7754
	ctx.r[4].s64 = ctx.r[11].s64 + -30548;
	// 82E7313C: 4BE39A15  bl 0x82cacb50
	ctx.lr = 0x82E73140;
	sub_82CACB50(ctx, base);
	// 82E73140: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E73144: 40820070  bne 0x82e731b4
	if !ctx.cr[0].eq {
	pc = 0x82E731B4; continue 'dispatch;
	}
	// 82E73148: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E7314C: 4BA9ABBD  bl 0x8290dd08
	ctx.lr = 0x82E73150;
	sub_8290DD08(ctx, base);
	// 82E73150: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82E73154: 418201CC  beq 0x82e73320
	if ctx.cr[0].eq {
	pc = 0x82E73320; continue 'dispatch;
	}
	// 82E73158: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7315C: 388B2E38  addi r4, r11, 0x2e38
	ctx.r[4].s64 = ctx.r[11].s64 + 11832;
	// 82E73160: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E73164: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E73168: 4B3F4AB9  bl 0x82267c20
	ctx.lr = 0x82E7316C;
	sub_82267C20(ctx, base);
	// 82E7316C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82E73170: 4182FFB0  beq 0x82e73120
	if ctx.cr[0].eq {
	pc = 0x82E73120; continue 'dispatch;
	}
	// 82E73174: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E73178: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7317C: 4800914D  bl 0x82e7c2c8
	ctx.lr = 0x82E73180;
	sub_82E7C2C8(ctx, base);
	// 82E73180: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82E73184: 4182FF9C  beq 0x82e73120
	if ctx.cr[0].eq {
	pc = 0x82E73120; continue 'dispatch;
	}
	// 82E73188: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7318C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E73190: 38AB5D84  addi r5, r11, 0x5d84
	ctx.r[5].s64 = ctx.r[11].s64 + 23940;
	// 82E73194: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E73198: 48019EF9  bl 0x82e8d090
	ctx.lr = 0x82E7319C;
	sub_82E8D090(ctx, base);
	// 82E7319C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82E731A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E731A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E731A8: 4BFFFDD9  bl 0x82e72f80
	ctx.lr = 0x82E731AC;
	sub_82E72F80(ctx, base);
	// 82E731AC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E731B0: 4800017C  b 0x82e7332c
	pc = 0x82E7332C; continue 'dispatch;
	// 82E731B4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82E731B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E731BC: 388B293C  addi r4, r11, 0x293c
	ctx.r[4].s64 = ctx.r[11].s64 + 10556;
	// 82E731C0: 4BE39991  bl 0x82cacb50
	ctx.lr = 0x82E731C4;
	sub_82CACB50(ctx, base);
	// 82E731C4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E731C8: 4082004C  bne 0x82e73214
	if !ctx.cr[0].eq {
	pc = 0x82E73214; continue 'dispatch;
	}
	// 82E731CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E731D0: 4BA9AB39  bl 0x8290dd08
	ctx.lr = 0x82E731D4;
	sub_8290DD08(ctx, base);
	// 82E731D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E731D8: 4182FFD4  beq 0x82e731ac
	if ctx.cr[0].eq {
	pc = 0x82E731AC; continue 'dispatch;
	}
	// 82E731DC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E731E0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E731E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E731E8: 4182000C  beq 0x82e731f4
	if ctx.cr[0].eq {
	pc = 0x82E731F4; continue 'dispatch;
	}
	// 82E731EC: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E731F0: 4800000C  b 0x82e731fc
	pc = 0x82E731FC; continue 'dispatch;
	// 82E731F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E731F8: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E731FC: 4BE389B5  bl 0x82cabbb0
	ctx.lr = 0x82E73200;
	sub_82CABBB0(ctx, base);
	// 82E73200: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E73204: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E73208: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E7320C: 4B37553D  bl 0x821e8748
	ctx.lr = 0x82E73210;
	sub_821E8748(ctx, base);
	// 82E73210: 4BFFFF9C  b 0x82e731ac
	pc = 0x82E731AC; continue 'dispatch;
	// 82E73214: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E73218: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7321C: 388B8928  addi r4, r11, -0x76d8
	ctx.r[4].s64 = ctx.r[11].s64 + -30424;
	// 82E73220: 4BE39931  bl 0x82cacb50
	ctx.lr = 0x82E73224;
	sub_82CACB50(ctx, base);
	// 82E73224: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E73228: 40820060  bne 0x82e73288
	if !ctx.cr[0].eq {
	pc = 0x82E73288; continue 'dispatch;
	}
	// 82E7322C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E73230: 4BA9AAD9  bl 0x8290dd08
	ctx.lr = 0x82E73234;
	sub_8290DD08(ctx, base);
	// 82E73234: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E73238: 4182FF74  beq 0x82e731ac
	if ctx.cr[0].eq {
	pc = 0x82E731AC; continue 'dispatch;
	}
	// 82E7323C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E73240: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E73244: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E73248: 4182000C  beq 0x82e73254
	if ctx.cr[0].eq {
	pc = 0x82E73254; continue 'dispatch;
	}
	// 82E7324C: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E73250: 4800000C  b 0x82e7325c
	pc = 0x82E7325C; continue 'dispatch;
	// 82E73254: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E73258: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E7325C: 4BE38955  bl 0x82cabbb0
	ctx.lr = 0x82E73260;
	sub_82CABBB0(ctx, base);
	// 82E73260: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E73264: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E73268: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E7326C: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E73270: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E73274: 4098000C  bge cr6, 0x82e73280
	if !ctx.cr[6].lt {
	pc = 0x82E73280; continue 'dispatch;
	}
	// 82E73278: D1BC008C  stfs f13, 0x8c(r28)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82E7327C: 4BFFFF30  b 0x82e731ac
	pc = 0x82E731AC; continue 'dispatch;
	// 82E73280: D01C008C  stfs f0, 0x8c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82E73284: 4BFFFF28  b 0x82e731ac
	pc = 0x82E731AC; continue 'dispatch;
	// 82E73288: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E7328C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E73290: 388B8914  addi r4, r11, -0x76ec
	ctx.r[4].s64 = ctx.r[11].s64 + -30444;
	// 82E73294: 4BE398BD  bl 0x82cacb50
	ctx.lr = 0x82E73298;
	sub_82CACB50(ctx, base);
	// 82E73298: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E7329C: 40820020  bne 0x82e732bc
	if !ctx.cr[0].eq {
	pc = 0x82E732BC; continue 'dispatch;
	}
	// 82E732A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E732A4: 4BA9AA65  bl 0x8290dd08
	ctx.lr = 0x82E732A8;
	sub_8290DD08(ctx, base);
	// 82E732A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E732AC: 4182FF00  beq 0x82e731ac
	if ctx.cr[0].eq {
	pc = 0x82E731AC; continue 'dispatch;
	}
	// 82E732B0: 4BE37111  bl 0x82caa3c0
	ctx.lr = 0x82E732B4;
	sub_82CAA3C0(ctx, base);
	// 82E732B4: 987C0090  stb r3, 0x90(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(144 as u32), ctx.r[3].u8 ) };
	// 82E732B8: 4BFFFEF4  b 0x82e731ac
	pc = 0x82E731AC; continue 'dispatch;
	// 82E732BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E732C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E732C4: 388B8904  addi r4, r11, -0x76fc
	ctx.r[4].s64 = ctx.r[11].s64 + -30460;
	// 82E732C8: 4BE39889  bl 0x82cacb50
	ctx.lr = 0x82E732CC;
	sub_82CACB50(ctx, base);
	// 82E732CC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E732D0: 40820050  bne 0x82e73320
	if !ctx.cr[0].eq {
	pc = 0x82E73320; continue 'dispatch;
	}
	// 82E732D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E732D8: 4BA9AA31  bl 0x8290dd08
	ctx.lr = 0x82E732DC;
	sub_8290DD08(ctx, base);
	// 82E732DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E732E0: 4182FECC  beq 0x82e731ac
	if ctx.cr[0].eq {
	pc = 0x82E731AC; continue 'dispatch;
	}
	// 82E732E4: 4BE388CD  bl 0x82cabbb0
	ctx.lr = 0x82E732E8;
	sub_82CABBB0(ctx, base);
	// 82E732E8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E732EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E732F0: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E732F4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E732F8: 4198FEB4  blt cr6, 0x82e731ac
	if ctx.cr[6].lt {
	pc = 0x82E731AC; continue 'dispatch;
	}
	// 82E732FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E73300: C1AB0A44  lfs f13, 0xa44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2628 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E73304: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E73308: 4199FEA4  bgt cr6, 0x82e731ac
	if ctx.cr[6].gt {
	pc = 0x82E731AC; continue 'dispatch;
	}
	// 82E7330C: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82E73310: C1AB0ED4  lfs f13, 0xed4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3796 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E73314: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E73318: D01C0094  stfs f0, 0x94(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82E7331C: 4BFFFE90  b 0x82e731ac
	pc = 0x82E731AC; continue 'dispatch;
	// 82E73320: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E73324: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E73328: 4BFFCB71  bl 0x82e6fe98
	ctx.lr = 0x82E7332C;
	sub_82E6FE98(ctx, base);
	// 82E7332C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E73330: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82E73334: 4BE36124  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E73338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E73338 size=216
    let mut pc: u32 = 0x82E73338;
    'dispatch: loop {
        match pc {
            0x82E73338 => {
    //   block [0x82E73338..0x82E73410)
	// 82E73338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7333C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E73340: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E73344: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82E73348: 4BE3A98D  bl 0x82cadcd4
	ctx.lr = 0x82E7334C;
	sub_82CADCA0(ctx, base);
	// 82E7334C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E73350: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E73354: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E73358: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E7335C: 4B40BF0D  bl 0x8227f268
	ctx.lr = 0x82E73360;
	sub_8227F268(ctx, base);
	// 82E73360: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E73364: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E73368: 4B40BF01  bl 0x8227f268
	ctx.lr = 0x82E7336C;
	sub_8227F268(ctx, base);
	// 82E7336C: C3E10060  lfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E73370: C3C10050  lfs f30, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E73374: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E73378: ED9F07B2  fmuls f12, f31, f30
	ctx.f[12].f64 = (((ctx.f[31].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E7337C: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73380: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E73384: C3A10058  lfs f29, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82E73388: C3810068  lfs f28, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82E7338C: EC00637A  fmadds f0, f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82E73390: EC3D073A  fmadds f1, f29, f28, f0
	ctx.f[1].f64 = (((ctx.f[29].f64 * ctx.f[28].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E73394: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73398: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E7339C: C36B0EE0  lfs f27, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82E733A0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82E733A4: 4099000C  ble cr6, 0x82e733b0
	if !ctx.cr[6].gt {
	pc = 0x82E733B0; continue 'dispatch;
	}
	// 82E733A8: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82E733AC: 48000010  b 0x82e733bc
	pc = 0x82E733BC; continue 'dispatch;
	// 82E733B0: FF01D800  fcmpu cr6, f1, f27
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[27].f64);
	// 82E733B4: 40980008  bge cr6, 0x82e733bc
	if !ctx.cr[6].lt {
	pc = 0x82E733BC; continue 'dispatch;
	}
	// 82E733B8: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 82E733BC: 4B3ED585  bl 0x82260940
	ctx.lr = 0x82E733C0;
	sub_82260940(ctx, base);
	// 82E733C0: EC1E0732  fmuls f0, f30, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[28].f64) as f32) as f64);
	// 82E733C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E733C8: FC200818  frsp f1, f1
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E733CC: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E733D0: EC1D07F8  fmsubs f0, f29, f31, f0
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E733D4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E733D8: 4098001C  bge cr6, 0x82e733f4
	if !ctx.cr[6].lt {
	pc = 0x82E733F4; continue 'dispatch;
	}
	// 82E733DC: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82E733E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E733E4: C00B0AC4  lfs f0, 0xac4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2756 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E733E8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E733EC: 40990008  ble cr6, 0x82e733f4
	if !ctx.cr[6].gt {
	pc = 0x82E733F4; continue 'dispatch;
	}
	// 82E733F0: EC2106F2  fmuls f1, f1, f27
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[27].f64) as f32) as f64);
	// 82E733F4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E733F8: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82E733FC: 4BE3A925  bl 0x82cadd20
	ctx.lr = 0x82E73400;
	sub_82CADCEC(ctx, base);
	// 82E73400: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E73404: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E73408: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E7340C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E73410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E73410 size=72
    let mut pc: u32 = 0x82E73410;
    'dispatch: loop {
        match pc {
            0x82E73410 => {
    //   block [0x82E73410..0x82E73458)
	// 82E73410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E73414: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E73418: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E7341C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E73420: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E73424: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82E73428: 4B7A3501  bl 0x82616928
	ctx.lr = 0x82E7342C;
	sub_82616928(ctx, base);
	// 82E7342C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E73430: 41820010  beq 0x82e73440
	if ctx.cr[0].eq {
	pc = 0x82E73440; continue 'dispatch;
	}
	// 82E73434: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E73438: 4BFFFBB1  bl 0x82e72fe8
	ctx.lr = 0x82E7343C;
	sub_82E72FE8(ctx, base);
	// 82E7343C: 48000008  b 0x82e73444
	pc = 0x82E73444; continue 'dispatch;
	// 82E73440: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E73444: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E73448: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E7344C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E73450: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E73454: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E73458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E73458 size=852
    let mut pc: u32 = 0x82E73458;
    'dispatch: loop {
        match pc {
            0x82E73458 => {
    //   block [0x82E73458..0x82E737AC)
	// 82E73458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7345C: 4BE35F91  bl 0x82ca93ec
	ctx.lr = 0x82E73460;
	sub_82CA93D0(ctx, base);
	// 82E73460: DBA1FF88  stfd f29, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[29].u64 ) };
	// 82E73464: DBC1FF90  stfd f30, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 82E73468: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 82E7346C: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E73470: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E73474: 3AA0FFFF  li r21, -1
	ctx.r[21].s64 = -1;
	// 82E73478: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82E7347C: 7EB7AB78  mr r23, r21
	ctx.r[23].u64 = ctx.r[21].u64;
	// 82E73480: 807D0018  lwz r3, 0x18(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E73484: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E73488: 41820254  beq 0x82e736dc
	if ctx.cr[0].eq {
	pc = 0x82E736DC; continue 'dispatch;
	}
	// 82E7348C: 897D0090  lbz r11, 0x90(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(144 as u32) ) } as u64;
	// 82E73490: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E73494: 41820248  beq 0x82e736dc
	if ctx.cr[0].eq {
	pc = 0x82E736DC; continue 'dispatch;
	}
	// 82E73498: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E7349C: 38C1005C  addi r6, r1, 0x5c
	ctx.r[6].s64 = ctx.r[1].s64 + 92;
	// 82E734A0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E734A4: C03D008C  lfs f1, 0x8c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E734A8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E734AC: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E734B0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E734B4: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E734B8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E734BC: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E734C0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E734C4: 480242AD  bl 0x82e97770
	ctx.lr = 0x82E734C8;
	sub_82E97770(ctx, base);
	// 82E734C8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82E734CC: 2B1A0001  cmplwi cr6, r26, 1
	ctx.cr[6].compare_u32(ctx.r[26].u32, 1 as u32, &mut ctx.xer);
	// 82E734D0: 4099020C  ble cr6, 0x82e736dc
	if !ctx.cr[6].gt {
	pc = 0x82E736DC; continue 'dispatch;
	}
	// 82E734D4: 895D0090  lbz r10, 0x90(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(144 as u32) ) } as u64;
	// 82E734D8: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E734DC: 41990008  bgt cr6, 0x82e734e4
	if ctx.cr[6].gt {
	pc = 0x82E734E4; continue 'dispatch;
	}
	// 82E734E0: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82E734E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E734E8: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E734EC: 7EDBB378  mr r27, r22
	ctx.r[27].u64 = ctx.r[22].u64;
	// 82E734F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E734F4: C3AB0A40  lfs f29, 0xa40(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2624 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82E734F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E734FC: C3CB0C18  lfs f30, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E73500: 81690014  lwz r11, 0x14(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E73504: D3C10074  stfs f30, 0x74(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82E73508: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E7350C: D3C10054  stfs f30, 0x54(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E73510: D3C10058  stfs f30, 0x58(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E73514: C00B004C  lfs f0, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73518: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82E7351C: C00B0054  lfs f0, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73520: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82E73524: 419A013C  beq cr6, 0x82e73660
	if ctx.cr[6].eq {
	pc = 0x82E73660; continue 'dispatch;
	}
	// 82E73528: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E7352C: 7D585378  mr r24, r10
	ctx.r[24].u64 = ctx.r[10].u64;
	// 82E73530: 3B2B9128  addi r25, r11, -0x6ed8
	ctx.r[25].s64 = ctx.r[11].s64 + -28376;
	// 82E73534: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E73538: 3B8B9128  addi r28, r11, -0x6ed8
	ctx.r[28].s64 = ctx.r[11].s64 + -28376;
	// 82E7353C: 4BE36C95  bl 0x82caa1d0
	ctx.lr = 0x82E73540;
	sub_82CAA1D0(ctx, base);
	// 82E73540: 7D43D396  divwu r10, r3, r26
	ctx.r[10].u32 = ctx.r[3].u32 / ctx.r[26].u32;
	// 82E73544: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E73548: 0CDA0000  twi 6, r26, 0
	// 82E7354C: 7D4AD1D6  mullw r10, r10, r26
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[26].s32 as i64);
	// 82E73550: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E73554: 7D4A1850  subf r10, r10, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[10].s64;
	// 82E73558: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E7355C: 7FCA482E  lwzx r30, r10, r9
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82E73560: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82E73564: 419A00F4  beq cr6, 0x82e73658
	if ctx.cr[6].eq {
	pc = 0x82E73658; continue 'dispatch;
	}
	// 82E73568: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E7356C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E73570: 409800E8  bge cr6, 0x82e73658
	if !ctx.cr[6].lt {
	pc = 0x82E73658; continue 'dispatch;
	}
	// 82E73574: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E73578: 1D5E0014  mulli r10, r30, 0x14
	ctx.r[10].s64 = ctx.r[30].s64 * 20;
	// 82E7357C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E73580: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E73584: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82E73588: 419A00D0  beq cr6, 0x82e73658
	if ctx.cr[6].eq {
	pc = 0x82E73658; continue 'dispatch;
	}
	// 82E7358C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E73590: 418200C8  beq 0x82e73658
	if ctx.cr[0].eq {
	pc = 0x82E73658; continue 'dispatch;
	}
	// 82E73594: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 82E73598: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E7359C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E735A0: D3C10054  stfs f30, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E735A4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E735A8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E735AC: C19F0000  lfs f12, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E735B0: C17F0008  lfs f11, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E735B4: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E735B8: C1AB003C  lfs f13, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E735BC: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E735C0: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E735C4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E735C8: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E735CC: 4BFFFD6D  bl 0x82e73338
	ctx.lr = 0x82E735D0;
	sub_82E73338(ctx, base);
	// 82E735D0: FFE00A10  fabs f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 82E735D4: C01D0094  lfs f0, 0x94(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E735D8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82E735DC: 40980008  bge cr6, 0x82e735e4
	if !ctx.cr[6].lt {
	pc = 0x82E735E4; continue 'dispatch;
	}
	// 82E735E0: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 82E735E4: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 82E735E8: 40980070  bge cr6, 0x82e73658
	if !ctx.cr[6].lt {
	pc = 0x82E73658; continue 'dispatch;
	}
	// 82E735EC: D3C10084  stfs f30, 0x84(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82E735F0: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 82E735F4: D3C10088  stfs f30, 0x88(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82E735F8: 93810080  stw r28, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 82E735FC: D3C1008C  stfs f30, 0x8c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82E73600: 7EC9B378  mr r9, r22
	ctx.r[9].u64 = ctx.r[22].u64;
	// 82E73604: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82E73608: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E7360C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E73610: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E73614: 4200FFF8  bdnz 0x82e7360c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E7360C; continue 'dispatch;
	}
	// 82E73618: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E7361C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82E73620: 9AC100D8  stb r22, 0xd8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[22].u8 ) };
	// 82E73624: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E73628: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E7362C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E73630: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E73634: 4E800421  bctrl
	ctx.lr = 0x82E73638;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E73638: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E7363C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E73640: 409A0014  bne cr6, 0x82e73654
	if !ctx.cr[6].eq {
	pc = 0x82E73654; continue 'dispatch;
	}
	// 82E73644: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 82E73648: FFA0F890  fmr f29, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[31].f64;
	// 82E7364C: 7FD7F378  mr r23, r30
	ctx.r[23].u64 = ctx.r[30].u64;
	// 82E73650: 617B0001  ori r27, r11, 1
	ctx.r[27].u64 = ctx.r[11].u64 | 1;
	// 82E73654: 93210080  stw r25, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[25].u32 ) };
	// 82E73658: 3718FFFF  addic. r24, r24, -1
	ctx.xer.ca = (ctx.r[24].u32 > (!(-1 as u32)));
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82E7365C: 4082FEE0  bne 0x82e7353c
	if !ctx.cr[0].eq {
	pc = 0x82E7353C; continue 'dispatch;
	}
	// 82E73660: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E73664: 41820078  beq 0x82e736dc
	if ctx.cr[0].eq {
	pc = 0x82E736DC; continue 'dispatch;
	}
	// 82E73668: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E7366C: 2F17FFFF  cmpwi cr6, r23, -1
	ctx.cr[6].compare_i32(ctx.r[23].s32, -1, &mut ctx.xer);
	// 82E73670: 419A0028  beq cr6, 0x82e73698
	if ctx.cr[6].eq {
	pc = 0x82E73698; continue 'dispatch;
	}
	// 82E73674: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E73678: 7F175040  cmplw cr6, r23, r10
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E7367C: 4098001C  bge cr6, 0x82e73698
	if !ctx.cr[6].lt {
	pc = 0x82E73698; continue 'dispatch;
	}
	// 82E73680: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E73684: 1D570014  mulli r10, r23, 0x14
	ctx.r[10].s64 = ctx.r[23].s64 * 20;
	// 82E73688: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E7368C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E73690: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82E73694: 409A0008  bne cr6, 0x82e7369c
	if !ctx.cr[6].eq {
	pc = 0x82E7369C; continue 'dispatch;
	}
	// 82E73698: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 82E7369C: 387D001C  addi r3, r29, 0x1c
	ctx.r[3].s64 = ctx.r[29].s64 + 28;
	// 82E736A0: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E736A4: 2F17FFFF  cmpwi cr6, r23, -1
	ctx.cr[6].compare_i32(ctx.r[23].s32, -1, &mut ctx.xer);
	// 82E736A8: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E736AC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E736B0: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E736B4: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E736B8: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E736BC: 9AC30058  stb r22, 0x58(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[22].u8 ) };
	// 82E736C0: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E736C4: 419A00C0  beq cr6, 0x82e73784
	if ctx.cr[6].eq {
	pc = 0x82E73784; continue 'dispatch;
	}
	// 82E736C8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E736CC: 7F175040  cmplw cr6, r23, r10
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E736D0: 409800B4  bge cr6, 0x82e73784
	if !ctx.cr[6].lt {
	pc = 0x82E73784; continue 'dispatch;
	}
	// 82E736D4: 1D570014  mulli r10, r23, 0x14
	ctx.r[10].s64 = ctx.r[23].s64 * 20;
	// 82E736D8: 48000098  b 0x82e73770
	pc = 0x82E73770; continue 'dispatch;
	// 82E736DC: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E736E0: 83EB0014  lwz r31, 0x14(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E736E4: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E736E8: 418200B0  beq 0x82e73798
	if ctx.cr[0].eq {
	pc = 0x82E73798; continue 'dispatch;
	}
	// 82E736EC: 4BE36AE5  bl 0x82caa1d0
	ctx.lr = 0x82E736F0;
	sub_82CAA1D0(ctx, base);
	// 82E736F0: 7D43FB96  divwu r10, r3, r31
	ctx.r[10].u32 = ctx.r[3].u32 / ctx.r[31].u32;
	// 82E736F4: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E736F8: 0CDF0000  twi 6, r31, 0
	// 82E736FC: 7D4AF9D6  mullw r10, r10, r31
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[31].s32 as i64);
	// 82E73700: 7D4A1850  subf r10, r10, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[10].s64;
	// 82E73704: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82E73708: 419A0028  beq cr6, 0x82e73730
	if ctx.cr[6].eq {
	pc = 0x82E73730; continue 'dispatch;
	}
	// 82E7370C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E73710: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E73714: 4098001C  bge cr6, 0x82e73730
	if !ctx.cr[6].lt {
	pc = 0x82E73730; continue 'dispatch;
	}
	// 82E73718: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E7371C: 1D2A0014  mulli r9, r10, 0x14
	ctx.r[9].s64 = ctx.r[10].s64 * 20;
	// 82E73720: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82E73724: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E73728: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 82E7372C: 409A0008  bne cr6, 0x82e73734
	if !ctx.cr[6].eq {
	pc = 0x82E73734; continue 'dispatch;
	}
	// 82E73730: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 82E73734: 387D001C  addi r3, r29, 0x1c
	ctx.r[3].s64 = ctx.r[29].s64 + 28;
	// 82E73738: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7373C: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82E73740: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E73744: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73748: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E7374C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73750: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E73754: 9AC30058  stb r22, 0x58(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[22].u8 ) };
	// 82E73758: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E7375C: 419A0028  beq cr6, 0x82e73784
	if ctx.cr[6].eq {
	pc = 0x82E73784; continue 'dispatch;
	}
	// 82E73760: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E73764: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E73768: 4098001C  bge cr6, 0x82e73784
	if !ctx.cr[6].lt {
	pc = 0x82E73784; continue 'dispatch;
	}
	// 82E7376C: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 * 20;
	// 82E73770: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E73774: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E73778: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E7377C: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82E73780: 409A0008  bne cr6, 0x82e73788
	if !ctx.cr[6].eq {
	pc = 0x82E73788; continue 'dispatch;
	}
	// 82E73784: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 82E73788: 389D0078  addi r4, r29, 0x78
	ctx.r[4].s64 = ctx.r[29].s64 + 120;
	// 82E7378C: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E73790: 92A40008  stw r21, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[21].u32 ) };
	// 82E73794: 4B33AF15  bl 0x821ae6a8
	ctx.lr = 0x82E73798;
	sub_821AE6A8(ctx, base);
	// 82E73798: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82E7379C: CBA1FF88  lfd f29, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 82E737A0: CBC1FF90  lfd f30, -0x70(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 82E737A4: CBE1FF98  lfd f31, -0x68(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 82E737A8: 4BE35C94  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E737B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E737B0 size=88
    let mut pc: u32 = 0x82E737B0;
    'dispatch: loop {
        match pc {
            0x82E737B0 => {
    //   block [0x82E737B0..0x82E73808)
	// 82E737B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E737B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E737B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E737BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E737C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E737C4: 48015A15  bl 0x82e891d8
	ctx.lr = 0x82E737C8;
	sub_82E891D8(ctx, base);
	// 82E737C8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E737CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E737D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E737D4: 396B2758  addi r11, r11, 0x2758
	ctx.r[11].s64 = ctx.r[11].s64 + 10072;
	// 82E737D8: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E737DC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E737E0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E737E4: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82E737E8: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E737EC: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E737F0: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82E737F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E737F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E737FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E73800: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E73804: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E73808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E73808 size=12
    let mut pc: u32 = 0x82E73808;
    'dispatch: loop {
        match pc {
            0x82E73808 => {
    //   block [0x82E73808..0x82E73814)
	// 82E73808: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7380C: 386BBC10  addi r3, r11, -0x43f0
	ctx.r[3].s64 = ctx.r[11].s64 + -17392;
	// 82E73810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E73818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E73818 size=228
    let mut pc: u32 = 0x82E73818;
    'dispatch: loop {
        match pc {
            0x82E73818 => {
    //   block [0x82E73818..0x82E738FC)
	// 82E73818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7381C: 4BE35BF1  bl 0x82ca940c
	ctx.lr = 0x82E73820;
	sub_82CA93D0(ctx, base);
	// 82E73820: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E73824: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E73828: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7382C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E73830: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82E73834: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E73838: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E7383C: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E73840: 4B374E39  bl 0x821e8678
	ctx.lr = 0x82E73844;
	sub_821E8678(ctx, base);
	// 82E73844: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E73848: 3FC08334  lis r30, -0x7ccc
	ctx.r[30].s64 = -2093744128;
	// 82E7384C: 4182000C  beq 0x82e73858
	if ctx.cr[0].eq {
	pc = 0x82E73858; continue 'dispatch;
	}
	// 82E73850: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73854: 48000020  b 0x82e73874
	pc = 0x82E73874; continue 'dispatch;
	// 82E73858: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E7385C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E73860: 4182000C  beq 0x82e7386c
	if ctx.cr[0].eq {
	pc = 0x82E7386C; continue 'dispatch;
	}
	// 82E73864: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73868: 4800000C  b 0x82e73874
	pc = 0x82E73874; continue 'dispatch;
	// 82E7386C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E73870: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73874: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E73878: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82E7387C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E73880: 48015A49  bl 0x82e892c8
	ctx.lr = 0x82E73884;
	sub_82E892C8(ctx, base);
	// 82E73884: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E73888: 4082000C  bne 0x82e73894
	if !ctx.cr[0].eq {
	pc = 0x82E73894; continue 'dispatch;
	}
	// 82E7388C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E73890: 48000064  b 0x82e738f4
	pc = 0x82E738F4; continue 'dispatch;
	// 82E73894: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E73898: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E7389C: 388B1048  addi r4, r11, 0x1048
	ctx.r[4].s64 = ctx.r[11].s64 + 4168;
	// 82E738A0: 4B3F3C71  bl 0x82267510
	ctx.lr = 0x82E738A4;
	sub_82267510(ctx, base);
	// 82E738A4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E738A8: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82E738AC: 388BE4AC  addi r4, r11, -0x1b54
	ctx.r[4].s64 = ctx.r[11].s64 + -6996;
	// 82E738B0: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E738B4: 4B3F436D  bl 0x82267c20
	ctx.lr = 0x82E738B8;
	sub_82267C20(ctx, base);
	// 82E738B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E738BC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82E738C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E738C4: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E738C8: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82E738CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E738D0: 4E800421  bctrl
	ctx.lr = 0x82E738D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E738D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E738D8: 4182FFB4  beq 0x82e7388c
	if ctx.cr[0].eq {
	pc = 0x82E7388C; continue 'dispatch;
	}
	// 82E738DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E738E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E738E4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E738E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E738EC: 4E800421  bctrl
	ctx.lr = 0x82E738F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E738F0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E738F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E738F8: 4BE35B64  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E73900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E73900 size=36
    let mut pc: u32 = 0x82E73900;
    'dispatch: loop {
        match pc {
            0x82E73900 => {
    //   block [0x82E73900..0x82E73924)
	// 82E73900: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E73904: 396B115C  addi r11, r11, 0x115c
	ctx.r[11].s64 = ctx.r[11].s64 + 4444;
	// 82E73908: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7390C: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E73910: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73914: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E73918: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7391C: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82E73920: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E73928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E73928 size=72
    let mut pc: u32 = 0x82E73928;
    'dispatch: loop {
        match pc {
            0x82E73928 => {
    //   block [0x82E73928..0x82E73970)
	// 82E73928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7392C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E73930: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E73934: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E73938: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E7393C: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 82E73940: 4B7A2FE9  bl 0x82616928
	ctx.lr = 0x82E73944;
	sub_82616928(ctx, base);
	// 82E73944: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E73948: 41820010  beq 0x82e73958
	if ctx.cr[0].eq {
	pc = 0x82E73958; continue 'dispatch;
	}
	// 82E7394C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E73950: 4BFFFE61  bl 0x82e737b0
	ctx.lr = 0x82E73954;
	sub_82E737B0(ctx, base);
	// 82E73954: 48000008  b 0x82e7395c
	pc = 0x82E7395C; continue 'dispatch;
	// 82E73958: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E7395C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E73960: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E73964: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E73968: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E7396C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E73970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E73970 size=100
    let mut pc: u32 = 0x82E73970;
    'dispatch: loop {
        match pc {
            0x82E73970 => {
    //   block [0x82E73970..0x82E739D4)
	// 82E73970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E73974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E73978: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E7397C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E73980: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E73984: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E73988: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E7398C: 396B2758  addi r11, r11, 0x2758
	ctx.r[11].s64 = ctx.r[11].s64 + 10072;
	// 82E73990: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E73994: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E73998: 48015861  bl 0x82e891f8
	ctx.lr = 0x82E7399C;
	sub_82E891F8(ctx, base);
	// 82E7399C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E739A0: 41820018  beq 0x82e739b8
	if ctx.cr[0].eq {
	pc = 0x82E739B8; continue 'dispatch;
	}
	// 82E739A4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E739A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E739AC: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E739B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E739B4: 4E800421  bctrl
	ctx.lr = 0x82E739B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E739B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E739BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E739C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E739C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E739C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E739CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E739D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E739D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E739D8 size=192
    let mut pc: u32 = 0x82E739D8;
    'dispatch: loop {
        match pc {
            0x82E739D8 => {
    //   block [0x82E739D8..0x82E73A98)
	// 82E739D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E739DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E739E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E739E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E739E8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82E739EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E739F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E739F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E739F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E739FC: 409A000C  bne cr6, 0x82e73a08
	if !ctx.cr[6].eq {
	pc = 0x82E73A08; continue 'dispatch;
	}
	// 82E73A00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E73A04: 48000078  b 0x82e73a7c
	pc = 0x82E73A7C; continue 'dispatch;
	// 82E73A08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E73A0C: 48348655  bl 0x831bc060
	ctx.lr = 0x82E73A10;
	sub_831BC060(ctx, base);
	// 82E73A10: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82E73A14: 388B293C  addi r4, r11, 0x293c
	ctx.r[4].s64 = ctx.r[11].s64 + 10556;
	// 82E73A18: 4BE39139  bl 0x82cacb50
	ctx.lr = 0x82E73A1C;
	sub_82CACB50(ctx, base);
	// 82E73A1C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E73A20: 40820050  bne 0x82e73a70
	if !ctx.cr[0].eq {
	pc = 0x82E73A70; continue 'dispatch;
	}
	// 82E73A24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E73A28: 4BA9A2E1  bl 0x8290dd08
	ctx.lr = 0x82E73A2C;
	sub_8290DD08(ctx, base);
	// 82E73A2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E73A30: 41820040  beq 0x82e73a70
	if ctx.cr[0].eq {
	pc = 0x82E73A70; continue 'dispatch;
	}
	// 82E73A34: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E73A38: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E73A3C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E73A40: 4182000C  beq 0x82e73a4c
	if ctx.cr[0].eq {
	pc = 0x82E73A4C; continue 'dispatch;
	}
	// 82E73A44: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E73A48: 4800000C  b 0x82e73a54
	pc = 0x82E73A54; continue 'dispatch;
	// 82E73A4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E73A50: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E73A54: 4BE3815D  bl 0x82cabbb0
	ctx.lr = 0x82E73A58;
	sub_82CABBB0(ctx, base);
	// 82E73A58: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E73A5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E73A60: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E73A64: 4B374B15  bl 0x821e8578
	ctx.lr = 0x82E73A68;
	sub_821E8578(ctx, base);
	// 82E73A68: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E73A6C: 48000010  b 0x82e73a7c
	pc = 0x82E73A7C; continue 'dispatch;
	// 82E73A70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E73A74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E73A78: 4BFFC421  bl 0x82e6fe98
	ctx.lr = 0x82E73A7C;
	sub_82E6FE98(ctx, base);
	// 82E73A7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E73A80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E73A84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E73A88: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82E73A8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E73A90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E73A94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E73A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E73A98 size=320
    let mut pc: u32 = 0x82E73A98;
    'dispatch: loop {
        match pc {
            0x82E73A98 => {
    //   block [0x82E73A98..0x82E73BD8)
	// 82E73A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E73A9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E73AA0: 3981FFF8  addi r12, r1, -8
	ctx.r[12].s64 = ctx.r[1].s64 + -8;
	// 82E73AA4: 4BE3A221  bl 0x82cadcc4
	ctx.lr = 0x82E73AA8;
	sub_82CADCA0(ctx, base);
	// 82E73AA8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E73AAC: FC001890  fmr f0, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[3].f64;
	// 82E73AB0: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82E73AB4: EDA2002A  fadds f13, f2, f0
	ctx.f[13].f64 = ((ctx.f[2].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E73AB8: FF1E6800  fcmpu cr6, f30, f13
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[13].f64);
	// 82E73ABC: 40990010  ble cr6, 0x82e73acc
	if !ctx.cr[6].gt {
	pc = 0x82E73ACC; continue 'dispatch;
	}
	// 82E73AC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E73AC4: C02B0C18  lfs f1, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E73AC8: 480000F8  b 0x82e73bc0
	pc = 0x82E73BC0; continue 'dispatch;
	// 82E73ACC: EDBE002A  fadds f13, f30, f0
	ctx.f[13].f64 = ((ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E73AD0: FF026800  fcmpu cr6, f2, f13
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[13].f64);
	// 82E73AD4: 40990018  ble cr6, 0x82e73aec
	if !ctx.cr[6].gt {
	pc = 0x82E73AEC; continue 'dispatch;
	}
	// 82E73AD8: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E73ADC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E73AE0: C00B8958  lfs f0, -0x76a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30376 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73AE4: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E73AE8: 480000D8  b 0x82e73bc0
	pc = 0x82E73BC0; continue 'dispatch;
	// 82E73AEC: EDBE102A  fadds f13, f30, f2
	ctx.f[13].f64 = ((ctx.f[30].f64 + ctx.f[2].f64) as f32) as f64;
	// 82E73AF0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E73AF4: 4099000C  ble cr6, 0x82e73b00
	if !ctx.cr[6].gt {
	pc = 0x82E73B00; continue 'dispatch;
	}
	// 82E73AF8: EDA200B2  fmuls f13, f2, f2
	ctx.f[13].f64 = (((ctx.f[2].f64 * ctx.f[2].f64) as f32) as f64);
	// 82E73AFC: 4BFFFFE0  b 0x82e73adc
	pc = 0x82E73ADC; continue 'dispatch;
	// 82E73B00: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82E73B04: 4099000C  ble cr6, 0x82e73b10
	if !ctx.cr[6].gt {
	pc = 0x82E73B10; continue 'dispatch;
	}
	// 82E73B08: FDA01090  fmr f13, f2
	ctx.f[13].f64 = ctx.f[2].f64;
	// 82E73B0C: 48000008  b 0x82e73b14
	pc = 0x82E73B14; continue 'dispatch;
	// 82E73B10: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82E73B14: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82E73B18: 40980008  bge cr6, 0x82e73b20
	if !ctx.cr[6].lt {
	pc = 0x82E73B20; continue 'dispatch;
	}
	// 82E73B1C: FC001090  fmr f0, f2
	ctx.f[0].f64 = ctx.f[2].f64;
	// 82E73B20: EF400032  fmuls f26, f0, f0
	ctx.f[26].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E73B24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E73B28: EFAD0372  fmuls f29, f13, f13
	ctx.f[29].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E73B2C: C38B0C4C  lfs f28, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82E73B30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E73B34: EC1E0732  fmuls f0, f30, f28
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[28].f64) as f32) as f64);
	// 82E73B38: EDBDD028  fsubs f13, f29, f26
	ctx.f[13].f64 = (((ctx.f[29].f64 - ctx.f[26].f64) as f32) as f64);
	// 82E73B3C: EDBE6FBA  fmadds f13, f30, f30, f13
	ctx.f[13].f64 = (((ctx.f[30].f64 * ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64);
	// 82E73B40: EFED0024  fdivs f31, f13, f0
	ctx.f[31].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82E73B44: EC1FEFFC  fnmsubs f0, f31, f31, f29
	ctx.f[0].f64 = -(((ctx.f[31].f64 * ctx.f[31].f64 - ctx.f[29].f64) as f32) as f64);
	// 82E73B48: EF60002C  fsqrts f27, f0
	ctx.f[27].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E73B4C: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73B50: EF20D824  fdivs f25, f0, f27
	ctx.f[25].f64 = ((ctx.f[0].f64 / ctx.f[27].f64) as f32) as f64;
	// 82E73B54: EC3907F2  fmuls f1, f25, f31
	ctx.f[1].f64 = (((ctx.f[25].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E73B58: 4B40B629  bl 0x8227f180
	ctx.lr = 0x82E73B5C;
	sub_8227F180(ctx, base);
	// 82E73B5C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E73B60: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82E73B64: EC1B07F2  fmuls f0, f27, f31
	ctx.f[0].f64 = (((ctx.f[27].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E73B68: EF1EF828  fsubs f24, f30, f31
	ctx.f[24].f64 = (((ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 82E73B6C: C2EB0E8C  lfs f23, 0xe8c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3724 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82E73B70: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82E73B74: EC390632  fmuls f1, f25, f24
	ctx.f[1].f64 = (((ctx.f[25].f64 * ctx.f[24].f64) as f32) as f64);
	// 82E73B78: EDAD0732  fmuls f13, f13, f28
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[28].f64) as f32) as f64);
	// 82E73B7C: EDAD0772  fmuls f13, f13, f29
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 82E73B80: EFAD05F8  fmsubs f29, f13, f23, f0
	ctx.f[29].f64 = (((ctx.f[13].f64 * ctx.f[23].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E73B84: 4B40B5FD  bl 0x8227f180
	ctx.lr = 0x82E73B88;
	sub_8227F180(ctx, base);
	// 82E73B88: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E73B8C: EC1806F2  fmuls f0, f24, f27
	ctx.f[0].f64 = (((ctx.f[24].f64 * ctx.f[27].f64) as f32) as f64);
	// 82E73B90: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 82E73B94: EDAD0732  fmuls f13, f13, f28
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[28].f64) as f32) as f64);
	// 82E73B98: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82E73B9C: EDAD06B2  fmuls f13, f13, f26
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[26].f64) as f32) as f64);
	// 82E73BA0: EC0D05F8  fmsubs f0, f13, f23, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[23].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E73BA4: 4198000C  blt cr6, 0x82e73bb0
	if ctx.cr[6].lt {
	pc = 0x82E73BB0; continue 'dispatch;
	}
	// 82E73BA8: EC20E82A  fadds f1, f0, f29
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82E73BAC: 48000014  b 0x82e73bc0
	pc = 0x82E73BC0; continue 'dispatch;
	// 82E73BB0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E73BB4: C1AB8958  lfs f13, -0x76a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E73BB8: EDBAEB7A  fmadds f13, f26, f13, f29
	ctx.f[13].f64 = (((ctx.f[26].f64 * ctx.f[13].f64 + ctx.f[29].f64) as f32) as f64);
	// 82E73BBC: EC2D0028  fsubs f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E73BC0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E73BC4: 3981FFF8  addi r12, r1, -8
	ctx.r[12].s64 = ctx.r[1].s64 + -8;
	// 82E73BC8: 4BE3A149  bl 0x82cadd10
	ctx.lr = 0x82E73BCC;
	sub_82CADCEC(ctx, base);
	// 82E73BCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E73BD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E73BD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E73BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E73BD8 size=340
    let mut pc: u32 = 0x82E73BD8;
    'dispatch: loop {
        match pc {
            0x82E73BD8 => {
    //   block [0x82E73BD8..0x82E73D2C)
	// 82E73BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E73BDC: 4BE35821  bl 0x82ca93fc
	ctx.lr = 0x82E73BE0;
	sub_82CA93D0(ctx, base);
	// 82E73BE0: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 82E73BE4: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82E73BE8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E73BEC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E73BF0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E73BF4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82E73BF8: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82E73BFC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82E73C00: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E73C04: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E73C08: 4182000C  beq 0x82e73c14
	if ctx.cr[0].eq {
	pc = 0x82E73C14; continue 'dispatch;
	}
	// 82E73C0C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E73C10: 4800000C  b 0x82e73c1c
	pc = 0x82E73C1C; continue 'dispatch;
	// 82E73C14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E73C18: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E73C1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E73C20: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E73C24: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E73C28: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82E73C2C: C00B0AEC  lfs f0, 0xaec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2796 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73C30: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E73C34: 480239BD  bl 0x82e975f0
	ctx.lr = 0x82E73C38;
	sub_82E975F0(ctx, base);
	// 82E73C38: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82E73C3C: 409A000C  bne cr6, 0x82e73c48
	if !ctx.cr[6].eq {
	pc = 0x82E73C48; continue 'dispatch;
	}
	// 82E73C40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E73C44: 480000D8  b 0x82e73d1c
	pc = 0x82E73D1C; continue 'dispatch;
	// 82E73C48: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E73C4C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82E73C50: C3CB0BEC  lfs f30, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E73C54: 409900C4  ble cr6, 0x82e73d18
	if !ctx.cr[6].gt {
	pc = 0x82E73D18; continue 'dispatch;
	}
	// 82E73C58: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E73C5C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E73C60: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E73C64: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E73C68: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E73C6C: 409A000C  bne cr6, 0x82e73c78
	if !ctx.cr[6].eq {
	pc = 0x82E73C78; continue 'dispatch;
	}
	// 82E73C70: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E73C74: 48000030  b 0x82e73ca4
	pc = 0x82E73CA4; continue 'dispatch;
	// 82E73C78: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E73C7C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E73C80: 4098FFF0  bge cr6, 0x82e73c70
	if !ctx.cr[6].lt {
	pc = 0x82E73C70; continue 'dispatch;
	}
	// 82E73C84: 815B0018  lwz r10, 0x18(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E73C88: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 * 20;
	// 82E73C8C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E73C90: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E73C94: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E73C98: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82E73C9C: 419A0008  beq cr6, 0x82e73ca4
	if ctx.cr[6].eq {
	pc = 0x82E73CA4; continue 'dispatch;
	}
	// 82E73CA0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82E73CA4: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82E73CA8: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73CAC: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E73CB0: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E73CB4: C1650000  lfs f11, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E73CB8: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E73CBC: C1450004  lfs f10, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E73CC0: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E73CC4: C1650008  lfs f11, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E73CC8: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E73CCC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E73CD0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E73CD4: EFEC033A  fmadds f31, f12, f12, f0
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E73CD8: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 82E73CDC: 40980030  bge cr6, 0x82e73d0c
	if !ctx.cr[6].lt {
	pc = 0x82E73D0C; continue 'dispatch;
	}
	// 82E73CE0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E73CE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E73CE8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82E73CEC: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E73CF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E73CF4: 4E800421  bctrl
	ctx.lr = 0x82E73CF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E73CF8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E73CFC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E73D00: 409A000C  bne cr6, 0x82e73d0c
	if !ctx.cr[6].eq {
	pc = 0x82E73D0C; continue 'dispatch;
	}
	// 82E73D04: FFC0F890  fmr f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[31].f64;
	// 82E73D08: 7FF9FB78  mr r25, r31
	ctx.r[25].u64 = ctx.r[31].u64;
	// 82E73D0C: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82E73D10: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82E73D14: 4082FF4C  bne 0x82e73c60
	if !ctx.cr[0].eq {
	pc = 0x82E73C60; continue 'dispatch;
	}
	// 82E73D18: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82E73D1C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E73D20: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82E73D24: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82E73D28: 4BE35724  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E73D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E73D30 size=168
    let mut pc: u32 = 0x82E73D30;
    'dispatch: loop {
        match pc {
            0x82E73D30 => {
    //   block [0x82E73D30..0x82E73DD8)
	// 82E73D30: DBE1FFF8  stfd f31, -8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.f[31].u64 ) };
	// 82E73D34: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73D38: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E73D3C: ED000032  fmuls f8, f0, f0
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E73D40: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E73D44: EC4D0032  fmuls f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E73D48: EC2C0372  fmuls f1, f12, f13
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E73D4C: C1650000  lfs f11, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E73D50: C0A60000  lfs f5, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82E73D54: EFEC0032  fmuls f31, f12, f0
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E73D58: C1450004  lfs f10, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E73D5C: ECEC0332  fmuls f7, f12, f12
	ctx.f[7].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82E73D60: C0860004  lfs f4, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82E73D64: ECCD0372  fmuls f6, f13, f13
	ctx.f[6].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E73D68: C1250008  lfs f9, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E73D6C: EC055828  fsubs f0, f5, f11
	ctx.f[0].f64 = (((ctx.f[5].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E73D70: C0660008  lfs f3, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82E73D74: EDA45028  fsubs f13, f4, f10
	ctx.f[13].f64 = (((ctx.f[4].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E73D78: ED834828  fsubs f12, f3, f9
	ctx.f[12].f64 = (((ctx.f[3].f64 - ctx.f[9].f64) as f32) as f64);
	// 82E73D7C: FCA01050  fneg f5, f2
	ctx.f[5].u64 = ctx.f[2].u64 ^ 0x8000_0000_0000_0000u64;
	// 82E73D80: FC800850  fneg f4, f1
	ctx.f[4].u64 = ctx.f[1].u64 ^ 0x8000_0000_0000_0000u64;
	// 82E73D84: FC60F850  fneg f3, f31
	ctx.f[3].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
	// 82E73D88: EC48382A  fadds f2, f8, f7
	ctx.f[2].f64 = ((ctx.f[8].f64 + ctx.f[7].f64) as f32) as f64;
	// 82E73D8C: ECE6382A  fadds f7, f6, f7
	ctx.f[7].f64 = ((ctx.f[6].f64 + ctx.f[7].f64) as f32) as f64;
	// 82E73D90: ED08302A  fadds f8, f8, f6
	ctx.f[8].f64 = ((ctx.f[8].f64 + ctx.f[6].f64) as f32) as f64;
	// 82E73D94: ECC50372  fmuls f6, f5, f13
	ctx.f[6].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E73D98: EC240332  fmuls f1, f4, f12
	ctx.f[1].f64 = (((ctx.f[4].f64 * ctx.f[12].f64) as f32) as f64);
	// 82E73D9C: EC840372  fmuls f4, f4, f13
	ctx.f[4].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E73DA0: ECE7303A  fmadds f7, f7, f0, f6
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64);
	// 82E73DA4: ECC20B7A  fmadds f6, f2, f13, f1
	ctx.f[6].f64 = (((ctx.f[2].f64 * ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64);
	// 82E73DA8: ED08233A  fmadds f8, f8, f12, f4
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[12].f64 + ctx.f[4].f64) as f32) as f64);
	// 82E73DAC: EDA33B3A  fmadds f13, f3, f12, f7
	ctx.f[13].f64 = (((ctx.f[3].f64 * ctx.f[12].f64 + ctx.f[7].f64) as f32) as f64);
	// 82E73DB0: ED85303A  fmadds f12, f5, f0, f6
	ctx.f[12].f64 = (((ctx.f[5].f64 * ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64);
	// 82E73DB4: EC03403A  fmadds f0, f3, f0, f8
	ctx.f[0].f64 = (((ctx.f[3].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 82E73DB8: EDAB682A  fadds f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E73DBC: D1A30000  stfs f13, 0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E73DC0: EDAA602A  fadds f13, f10, f12
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E73DC4: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E73DC8: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E73DCC: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E73DD0: CBE1FFF8  lfd f31, -8(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82E73DD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E73DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E73DD8 size=248
    let mut pc: u32 = 0x82E73DD8;
    'dispatch: loop {
        match pc {
            0x82E73DD8 => {
    //   block [0x82E73DD8..0x82E73ED0)
	// 82E73DD8: DBC1FFF0  stfd f30, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[30].u64 ) };
	// 82E73DDC: DBE1FFF8  stfd f31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.f[31].u64 ) };
	// 82E73DE0: C1460008  lfs f10, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E73DE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E73DE8: C1A50008  lfs f13, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E73DEC: C1030008  lfs f8, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82E73DF0: ECAA6828  fsubs f5, f10, f13
	ctx.f[5].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E73DF4: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73DF8: EFE86828  fsubs f31, f8, f13
	ctx.f[31].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E73DFC: C1860000  lfs f12, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E73E00: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E73E04: C1230000  lfs f9, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E73E08: EC8C0028  fsubs f4, f12, f0
	ctx.f[4].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E73E0C: EC490028  fsubs f2, f9, f0
	ctx.f[2].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E73E10: C0C60004  lfs f6, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82E73E14: ED4C0028  fsubs f10, f12, f0
	ctx.f[10].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E73E18: C1650004  lfs f11, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E73E1C: C0E30004  lfs f7, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82E73E20: EC665828  fsubs f3, f6, f11
	ctx.f[3].f64 = (((ctx.f[6].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E73E24: EFC75828  fsubs f30, f7, f11
	ctx.f[30].f64 = (((ctx.f[7].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E73E28: ED665828  fsubs f11, f6, f11
	ctx.f[11].f64 = (((ctx.f[6].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E73E2C: ECC20132  fmuls f6, f2, f4
	ctx.f[6].f64 = (((ctx.f[2].f64 * ctx.f[4].f64) as f32) as f64);
	// 82E73E30: ED4A02B2  fmuls f10, f10, f10
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[10].f64) as f32) as f64);
	// 82E73E34: ECC537FA  fmadds f6, f5, f31, f6
	ctx.f[6].f64 = (((ctx.f[5].f64 * ctx.f[31].f64 + ctx.f[6].f64) as f32) as f64);
	// 82E73E38: EDAD537A  fmadds f13, f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64);
	// 82E73E3C: ECC337BA  fmadds f6, f3, f30, f6
	ctx.f[6].f64 = (((ctx.f[3].f64 * ctx.f[30].f64 + ctx.f[6].f64) as f32) as f64);
	// 82E73E40: EDAB6AFA  fmadds f13, f11, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82E73E44: C16B0C18  lfs f11, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E73E48: EDA66824  fdivs f13, f6, f13
	ctx.f[13].f64 = ((ctx.f[6].f64 / ctx.f[13].f64) as f32) as f64;
	// 82E73E4C: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82E73E50: 41980070  blt cr6, 0x82e73ec0
	if ctx.cr[6].lt {
	pc = 0x82E73EC0; continue 'dispatch;
	}
	// 82E73E54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E73E58: C16B0C14  lfs f11, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E73E5C: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82E73E60: 41990060  bgt cr6, 0x82e73ec0
	if ctx.cr[6].gt {
	pc = 0x82E73EC0; continue 'dispatch;
	}
	// 82E73E64: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E73E68: C1650004  lfs f11, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E73E6C: C0C60004  lfs f6, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82E73E70: EC810072  fmuls f4, f1, f1
	ctx.f[4].f64 = (((ctx.f[1].f64 * ctx.f[1].f64) as f32) as f64);
	// 82E73E74: ECC65828  fsubs f6, f6, f11
	ctx.f[6].f64 = (((ctx.f[6].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E73E78: C1450008  lfs f10, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E73E7C: C0A60008  lfs f5, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82E73E80: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E73E84: ECA55028  fsubs f5, f5, f10
	ctx.f[5].f64 = (((ctx.f[5].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E73E88: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E73E8C: ECC60372  fmuls f6, f6, f13
	ctx.f[6].f64 = (((ctx.f[6].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E73E90: EDA50372  fmuls f13, f5, f13
	ctx.f[13].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E73E94: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E73E98: ED8B302A  fadds f12, f11, f6
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[6].f64) as f32) as f64;
	// 82E73E9C: ED6A682A  fadds f11, f10, f13
	ctx.f[11].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E73EA0: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E73EA4: EDA76028  fsubs f13, f7, f12
	ctx.f[13].f64 = (((ctx.f[7].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E73EA8: ED885828  fsubs f12, f8, f11
	ctx.f[12].f64 = (((ctx.f[8].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E73EAC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E73EB0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E73EB4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E73EB8: FF002000  fcmpu cr6, f0, f4
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[4].f64);
	// 82E73EBC: 41980008  blt cr6, 0x82e73ec4
	if ctx.cr[6].lt {
	pc = 0x82E73EC4; continue 'dispatch;
	}
	// 82E73EC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E73EC4: CBC1FFF0  lfd f30, -0x10(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E73EC8: CBE1FFF8  lfd f31, -8(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82E73ECC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E73ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E73ED0 size=100
    let mut pc: u32 = 0x82E73ED0;
    'dispatch: loop {
        match pc {
            0x82E73ED0 => {
    //   block [0x82E73ED0..0x82E73F34)
	// 82E73ED0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E73ED4: C1450000  lfs f10, 0(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E73ED8: C1840000  lfs f12, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E73EDC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E73EE0: C1640008  lfs f11, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E73EE4: C0E50008  lfs f7, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82E73EE8: C0C40004  lfs f6, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82E73EEC: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E73EF0: ED0A6828  fsubs f8, f10, f13
	ctx.f[8].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E73EF4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73EF8: ED8C6828  fsubs f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E73EFC: C12B0004  lfs f9, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E73F00: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E73F04: C0A50004  lfs f5, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82E73F08: EC070028  fsubs f0, f7, f0
	ctx.f[0].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E73F0C: ED464828  fsubs f10, f6, f9
	ctx.f[10].f64 = (((ctx.f[6].f64 - ctx.f[9].f64) as f32) as f64);
	// 82E73F10: ED254828  fsubs f9, f5, f9
	ctx.f[9].f64 = (((ctx.f[5].f64 - ctx.f[9].f64) as f32) as f64);
	// 82E73F14: ED080332  fmuls f8, f8, f12
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 82E73F18: EC0042FA  fmadds f0, f0, f11, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64 + ctx.f[8].f64) as f32) as f64);
	// 82E73F1C: EC0902BA  fmadds f0, f9, f10, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E73F20: C12A0C18  lfs f9, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E73F24: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 82E73F28: 4098000C  bge cr6, 0x82e73f34
	if !ctx.cr[6].lt {
		sub_82E73F34(ctx, base);
		return;
	}
	// 82E73F2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E73F30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E73F34(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E73F34 size=84
    let mut pc: u32 = 0x82E73F34;
    'dispatch: loop {
        match pc {
            0x82E73F34 => {
    //   block [0x82E73F34..0x82E73F88)
	// 82E73F34: ED0A02B2  fmuls f8, f10, f10
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[10].f64) as f32) as f64);
	// 82E73F38: ED0C433A  fmadds f8, f12, f12, f8
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[8].f64) as f32) as f64);
	// 82E73F3C: ED0B42FA  fmadds f8, f11, f11, f8
	ctx.f[8].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[8].f64) as f32) as f64);
	// 82E73F40: ED00402C  fsqrts f8, f8
	ctx.f[8].f64 = ((ctx.f[8].f64).sqrt() as f32) as f64;
	// 82E73F44: FF084800  fcmpu cr6, f8, f9
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[9].f64);
	// 82E73F48: 409A0040  bne cr6, 0x82e73f88
	if !ctx.cr[6].eq {
		sub_82E73F88(ctx, base);
		return;
	}
	// 82E73F4C: D1A70000  stfs f13, 0(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E73F50: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73F54: D0070004  stfs f0, 4(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E73F58: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73F5C: D0070008  stfs f0, 8(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E73F60: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E73F64: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E73F68: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E73F6C: C1850004  lfs f12, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E73F70: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E73F74: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E73F78: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E73F7C: C1850008  lfs f12, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E73F80: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E73F84: 48000058  b 0x82e73fdc
	sub_82E73F88(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E73F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E73F88 size=112
    let mut pc: u32 = 0x82E73F88;
    'dispatch: loop {
        match pc {
            0x82E73F88 => {
    //   block [0x82E73F88..0x82E73FF8)
	// 82E73F88: ED280232  fmuls f9, f8, f8
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[9].f64 = (((ctx.f[8].f64 * ctx.f[8].f64) as f32) as f64);
	// 82E73F8C: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 82E73F90: 4199FF9C  bgt cr6, 0x82e73f2c
	if ctx.cr[6].gt {
		sub_82E73ED0(ctx, base);
		return;
	}
	// 82E73F94: EC004824  fdivs f0, f0, f9
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[9].f64) as f32) as f64;
	// 82E73F98: C10B0008  lfs f8, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82E73F9C: C12B0004  lfs f9, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E73FA0: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E73FA4: ED6002F2  fmuls f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82E73FA8: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E73FAC: EC0D602A  fadds f0, f13, f12
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E73FB0: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E73FB4: ED88582A  fadds f12, f8, f11
	ctx.f[12].f64 = ((ctx.f[8].f64 + ctx.f[11].f64) as f32) as f64;
	// 82E73FB8: D1870008  stfs f12, 8(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E73FBC: EDAA482A  fadds f13, f10, f9
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[9].f64) as f32) as f64;
	// 82E73FC0: D1A70004  stfs f13, 4(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E73FC4: C1650000  lfs f11, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E73FC8: C1450004  lfs f10, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E73FCC: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E73FD0: C1650008  lfs f11, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E73FD4: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E73FD8: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E73FDC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E73FE0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E73FE4: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E73FE8: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E73FEC: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E73FF0: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E73FF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E73FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E73FF8 size=288
    let mut pc: u32 = 0x82E73FF8;
    'dispatch: loop {
        match pc {
            0x82E73FF8 => {
    //   block [0x82E73FF8..0x82E74118)
	// 82E73FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E73FFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E74000: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 82E74004: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E74008: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E7400C: C0070000  lfs f0, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74010: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82E74014: C1A70004  lfs f13, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E74018: C1870008  lfs f12, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E7401C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82E74020: C0A50000  lfs f5, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82E74024: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E74028: C0460000  lfs f2, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82E7402C: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E74030: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E74034: C14B0004  lfs f10, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E74038: D1610080  stfs f11, 0x80(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82E7403C: ED6A6828  fsubs f11, f10, f13
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E74040: C12B0008  lfs f9, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E74044: D1610084  stfs f11, 0x84(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82E74048: ED696028  fsubs f11, f9, f12
	ctx.f[11].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E7404C: C10A0000  lfs f8, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82E74050: D1610088  stfs f11, 0x88(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82E74054: ED680028  fsubs f11, f8, f0
	ctx.f[11].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E74058: C0EA0004  lfs f7, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82E7405C: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E74060: ED676828  fsubs f11, f7, f13
	ctx.f[11].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E74064: C0CA0008  lfs f6, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82E74068: D1610054  stfs f11, 0x54(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E7406C: ED666028  fsubs f11, f6, f12
	ctx.f[11].f64 = (((ctx.f[6].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E74070: D1610058  stfs f11, 0x58(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E74074: ED650028  fsubs f11, f5, f0
	ctx.f[11].f64 = (((ctx.f[5].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E74078: C0850004  lfs f4, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82E7407C: EC020028  fsubs f0, f2, f0
	ctx.f[0].f64 = (((ctx.f[2].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E74080: C0260004  lfs f1, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E74084: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E74088: ED646828  fsubs f11, f4, f13
	ctx.f[11].f64 = (((ctx.f[4].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E7408C: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82E74090: EC016828  fsubs f0, f1, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E74094: C0650008  lfs f3, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82E74098: C3E60008  lfs f31, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E7409C: D1610064  stfs f11, 0x64(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E740A0: ED636028  fsubs f11, f3, f12
	ctx.f[11].f64 = (((ctx.f[3].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E740A4: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82E740A8: EC1F6028  fsubs f0, f31, f12
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E740AC: D1610068  stfs f11, 0x68(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E740B0: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82E740B4: 4BFFF285  bl 0x82e73338
	ctx.lr = 0x82E740B8;
	sub_82E73338(ctx, base);
	// 82E740B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E740BC: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E740C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E740C4: 4BFFF275  bl 0x82e73338
	ctx.lr = 0x82E740C8;
	sub_82E73338(ctx, base);
	// 82E740C8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E740CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E740D0: EFE1F82A  fadds f31, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 82E740D4: 4BFFF265  bl 0x82e73338
	ctx.lr = 0x82E740D8;
	sub_82E73338(ctx, base);
	// 82E740D8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82E740DC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82E740E0: EFE1F82A  fadds f31, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 82E740E4: 4BFFF255  bl 0x82e73338
	ctx.lr = 0x82E740E8;
	sub_82E73338(ctx, base);
	// 82E740E8: EDA1F82A  fadds f13, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 82E740EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E740F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E740F4: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E740F8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E740FC: 419A0008  beq cr6, 0x82e74104
	if ctx.cr[6].eq {
	pc = 0x82E74104; continue 'dispatch;
	}
	// 82E74100: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E74104: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E74108: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E7410C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E74110: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E74114: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E74118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E74118 size=1984
    let mut pc: u32 = 0x82E74118;
    'dispatch: loop {
        match pc {
            0x82E74118 => {
    //   block [0x82E74118..0x82E748D8)
	// 82E74118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7411C: 4BE352ED  bl 0x82ca9408
	ctx.lr = 0x82E74120;
	sub_82CA93D0(ctx, base);
	// 82E74120: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82E74124: 4BE39B8D  bl 0x82cadcb0
	ctx.lr = 0x82E74128;
	sub_82CADCA0(ctx, base);
	// 82E74128: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7412C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E74130: FE400890  fmr f18, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[18].f64 = ctx.f[1].f64;
	// 82E74134: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E74138: FEA01090  fmr f21, f2
	ctx.f[21].f64 = ctx.f[2].f64;
	// 82E7413C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E74140: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82E74144: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E74148: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E7414C: 4B37452D  bl 0x821e8678
	ctx.lr = 0x82E74150;
	sub_821E8678(ctx, base);
	// 82E74150: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E74154: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E74158: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82E7415C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E74160: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E74164: 4B374515  bl 0x821e8678
	ctx.lr = 0x82E74168;
	sub_821E8678(ctx, base);
	// 82E74168: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E7416C: 409A0020  bne cr6, 0x82e7418c
	if !ctx.cr[6].eq {
	pc = 0x82E7418C; continue 'dispatch;
	}
	// 82E74170: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E74174: 409A0010  bne cr6, 0x82e74184
	if !ctx.cr[6].eq {
	pc = 0x82E74184; continue 'dispatch;
	}
	// 82E74178: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82E7417C: C3CB5CC4  lfs f30, 0x5cc4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(23748 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E74180: 48000030  b 0x82e741b0
	pc = 0x82E741B0; continue 'dispatch;
	// 82E74184: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E74188: 48000008  b 0x82e74190
	pc = 0x82E74190; continue 'dispatch;
	// 82E7418C: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E74190: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E74194: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E74198: 396B0BFC  addi r11, r11, 0xbfc
	ctx.r[11].s64 = ctx.r[11].s64 + 3068;
	// 82E7419C: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E741A0: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E741A4: 409A0020  bne cr6, 0x82e741c4
	if !ctx.cr[6].eq {
	pc = 0x82E741C4; continue 'dispatch;
	}
	// 82E741A8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E741AC: 409A0010  bne cr6, 0x82e741bc
	if !ctx.cr[6].eq {
	pc = 0x82E741BC; continue 'dispatch;
	}
	// 82E741B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E741B4: C3EB0A78  lfs f31, 0xa78(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2680 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E741B8: 48000014  b 0x82e741cc
	pc = 0x82E741CC; continue 'dispatch;
	// 82E741BC: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E741C0: 48000008  b 0x82e741c8
	pc = 0x82E741C8; continue 'dispatch;
	// 82E741C4: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E741C8: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E741CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E741D0: C01F0040  lfs f0, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E741D4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82E741D8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82E741DC: 3BDF004C  addi r30, r31, 0x4c
	ctx.r[30].s64 = ctx.r[31].s64 + 76;
	// 82E741E0: C3AB2594  lfs f29, 0x2594(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9620 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82E741E4: EC00E82A  fadds f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82E741E8: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82E741EC: C01F0044  lfs f0, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E741F0: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82E741F4: C01F0048  lfs f0, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E741F8: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82E741FC: 48011AA5  bl 0x82e85ca0
	ctx.lr = 0x82E74200;
	sub_82E85CA0(ctx, base);
	// 82E74200: C01F0044  lfs f0, 0x44(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74204: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82E74208: EC00E828  fsubs f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	// 82E7420C: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82E74210: C01F0040  lfs f0, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74214: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82E74218: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82E7421C: C01F0048  lfs f0, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74220: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82E74224: 48011A7D  bl 0x82e85ca0
	ctx.lr = 0x82E74228;
	sub_82E85CA0(ctx, base);
	// 82E74228: C0410080  lfs f2, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82E7422C: 3BFF0034  addi r31, r31, 0x34
	ctx.r[31].s64 = ctx.r[31].s64 + 52;
	// 82E74230: EC0207F2  fmuls f0, f2, f31
	ctx.f[0].f64 = (((ctx.f[2].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E74234: C0210084  lfs f1, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E74238: C3010090  lfs f24, 0x90(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82E7423C: EDA107F2  fmuls f13, f1, f31
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E74240: ED1807B2  fmuls f8, f24, f30
	ctx.f[8].f64 = (((ctx.f[24].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E74244: C17E0000  lfs f11, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E74248: C3210088  lfs f25, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82E7424C: ECAB07F2  fmuls f5, f11, f31
	ctx.f[5].f64 = (((ctx.f[11].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E74250: C39F0000  lfs f28, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82E74254: ED9907F2  fmuls f12, f25, f31
	ctx.f[12].f64 = (((ctx.f[25].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E74258: C2E10094  lfs f23, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82E7425C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E74260: C29F0004  lfs f20, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 82E74264: ECF707B2  fmuls f7, f23, f30
	ctx.f[7].f64 = (((ctx.f[23].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E74268: C15E0004  lfs f10, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E7426C: C2C10098  lfs f22, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 82E74270: EC8A07F2  fmuls f4, f10, f31
	ctx.f[4].f64 = (((ctx.f[10].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E74274: ECD607B2  fmuls f6, f22, f30
	ctx.f[6].f64 = (((ctx.f[22].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E74278: C13E0008  lfs f9, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E7427C: EC1C0028  fsubs f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E74280: C39F0008  lfs f28, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82E74284: EDB46828  fsubs f13, f20, f13
	ctx.f[13].f64 = (((ctx.f[20].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E74288: C3BC0000  lfs f29, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82E7428C: EC6907F2  fmuls f3, f9, f31
	ctx.f[3].f64 = (((ctx.f[9].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E74290: C37C0004  lfs f27, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82E74294: C35C0008  lfs f26, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82E74298: ED9C6028  fsubs f12, f28, f12
	ctx.f[12].f64 = (((ctx.f[28].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E7429C: C38B0C18  lfs f28, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82E742A0: EC004028  fsubs f0, f0, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[8].f64) as f32) as f64);
	// 82E742A4: EDAD3828  fsubs f13, f13, f7
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[7].f64) as f32) as f64);
	// 82E742A8: ED8C3028  fsubs f12, f12, f6
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[6].f64) as f32) as f64);
	// 82E742AC: ED002828  fsubs f8, f0, f5
	ctx.f[8].f64 = (((ctx.f[0].f64 - ctx.f[5].f64) as f32) as f64);
	// 82E742B0: ECED2028  fsubs f7, f13, f4
	ctx.f[7].f64 = (((ctx.f[13].f64 - ctx.f[4].f64) as f32) as f64);
	// 82E742B4: ECCC1828  fsubs f6, f12, f3
	ctx.f[6].f64 = (((ctx.f[12].f64 - ctx.f[3].f64) as f32) as f64);
	// 82E742B8: EC1D4028  fsubs f0, f29, f8
	ctx.f[0].f64 = (((ctx.f[29].f64 - ctx.f[8].f64) as f32) as f64);
	// 82E742BC: EDBB3828  fsubs f13, f27, f7
	ctx.f[13].f64 = (((ctx.f[27].f64 - ctx.f[7].f64) as f32) as f64);
	// 82E742C0: ED9A3028  fsubs f12, f26, f6
	ctx.f[12].f64 = (((ctx.f[26].f64 - ctx.f[6].f64) as f32) as f64);
	// 82E742C4: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E742C8: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E742CC: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E742D0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E742D4: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 82E742D8: 419A05EC  beq cr6, 0x82e748c4
	if ctx.cr[6].eq {
	pc = 0x82E748C4; continue 'dispatch;
	}
	// 82E742DC: EDBA3028  fsubs f13, f26, f6
	ctx.f[13].f64 = (((ctx.f[26].f64 - ctx.f[6].f64) as f32) as f64);
	// 82E742E0: ED9B3828  fsubs f12, f27, f7
	ctx.f[12].f64 = (((ctx.f[27].f64 - ctx.f[7].f64) as f32) as f64);
	// 82E742E4: EC1D4028  fsubs f0, f29, f8
	ctx.f[0].f64 = (((ctx.f[29].f64 - ctx.f[8].f64) as f32) as f64);
	// 82E742E8: ED190372  fmuls f8, f25, f13
	ctx.f[8].f64 = (((ctx.f[25].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E742EC: ED4C02B2  fmuls f10, f12, f10
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[10].f64) as f32) as f64);
	// 82E742F0: ECF60372  fmuls f7, f22, f13
	ctx.f[7].f64 = (((ctx.f[22].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E742F4: ED02403A  fmadds f8, f2, f0, f8
	ctx.f[8].f64 = (((ctx.f[2].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 82E742F8: ED4D527A  fmadds f10, f13, f9, f10
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[9].f64 + ctx.f[10].f64) as f32) as f64);
	// 82E742FC: ECF8383A  fmadds f7, f24, f0, f7
	ctx.f[7].f64 = (((ctx.f[24].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 82E74300: EDA1433A  fmadds f13, f1, f12, f8
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[12].f64 + ctx.f[8].f64) as f32) as f64);
	// 82E74304: EC0B503A  fmadds f0, f11, f0, f10
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 82E74308: ED973B3A  fmadds f12, f23, f12, f7
	ctx.f[12].f64 = (((ctx.f[23].f64 * ctx.f[12].f64 + ctx.f[7].f64) as f32) as f64);
	// 82E7430C: FF0DE000  fcmpu cr6, f13, f28
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[28].f64);
	// 82E74310: 4198003C  blt cr6, 0x82e7434c
	if ctx.cr[6].lt {
	pc = 0x82E7434C; continue 'dispatch;
	}
	// 82E74314: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E74318: C16B0C4C  lfs f11, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E7431C: ED5F02F2  fmuls f10, f31, f11
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[11].f64) as f32) as f64);
	// 82E74320: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82E74324: 41990028  bgt cr6, 0x82e7434c
	if ctx.cr[6].gt {
	pc = 0x82E7434C; continue 'dispatch;
	}
	// 82E74328: FF0CE000  fcmpu cr6, f12, f28
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[28].f64);
	// 82E7432C: 41980020  blt cr6, 0x82e7434c
	if ctx.cr[6].lt {
	pc = 0x82E7434C; continue 'dispatch;
	}
	// 82E74330: EDBE02F2  fmuls f13, f30, f11
	ctx.f[13].f64 = (((ctx.f[30].f64 * ctx.f[11].f64) as f32) as f64);
	// 82E74334: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82E74338: 41990014  bgt cr6, 0x82e7434c
	if ctx.cr[6].gt {
	pc = 0x82E7434C; continue 'dispatch;
	}
	// 82E7433C: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 82E74340: 4198000C  blt cr6, 0x82e7434c
	if ctx.cr[6].lt {
	pc = 0x82E7434C; continue 'dispatch;
	}
	// 82E74344: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82E74348: 4099057C  ble cr6, 0x82e748c4
	if !ctx.cr[6].gt {
	pc = 0x82E748C4; continue 'dispatch;
	}
	// 82E7434C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E74350: D38100CC  stfs f28, 0xcc(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82E74354: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E74358: D3810050  stfs f28, 0x50(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E7435C: D3810054  stfs f28, 0x54(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E74360: D3810058  stfs f28, 0x58(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E74364: 4B40AF05  bl 0x8227f268
	ctx.lr = 0x82E74368;
	sub_8227F268(ctx, base);
	// 82E74368: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7436C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82E74370: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E74374: EC000572  fmuls f0, f0, f21
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[21].f64) as f32) as f64);
	// 82E74378: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E7437C: EDAD0572  fmuls f13, f13, f21
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[21].f64) as f32) as f64);
	// 82E74380: ED8C0572  fmuls f12, f12, f21
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[21].f64) as f32) as f64);
	// 82E74384: 38C100CC  addi r6, r1, 0xcc
	ctx.r[6].s64 = ctx.r[1].s64 + 204;
	// 82E74388: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E7438C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E74390: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E74394: EC1D002A  fadds f0, f29, f0
	ctx.f[0].f64 = ((ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E74398: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E7439C: EC1B682A  fadds f0, f27, f13
	ctx.f[0].f64 = ((ctx.f[27].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E743A0: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E743A4: EC1A602A  fadds f0, f26, f12
	ctx.f[0].f64 = ((ctx.f[26].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E743A8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E743AC: 4BFFFB25  bl 0x82e73ed0
	ctx.lr = 0x82E743B0;
	sub_82E73ED0(ctx, base);
	// 82E743B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E743B4: 4082000C  bne 0x82e743c0
	if !ctx.cr[0].eq {
	pc = 0x82E743C0; continue 'dispatch;
	}
	// 82E743B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E743BC: 4800050C  b 0x82e748c8
	pc = 0x82E748C8; continue 'dispatch;
	// 82E743C0: FF1EF800  fcmpu cr6, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 82E743C4: 4099000C  ble cr6, 0x82e743d0
	if !ctx.cr[6].gt {
	pc = 0x82E743D0; continue 'dispatch;
	}
	// 82E743C8: FF20F090  fmr f25, f30
	ctx.f[25].f64 = ctx.f[30].f64;
	// 82E743CC: 48000008  b 0x82e743d4
	pc = 0x82E743D4; continue 'dispatch;
	// 82E743D0: FF20F890  fmr f25, f31
	ctx.f[25].f64 = ctx.f[31].f64;
	// 82E743D4: C2A10058  lfs f21, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 82E743D8: FC209090  fmr f1, f18
	ctx.f[1].f64 = ctx.f[18].f64;
	// 82E743DC: C2810050  lfs f20, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 82E743E0: EF5AA828  fsubs f26, f26, f21
	ctx.f[26].f64 = (((ctx.f[26].f64 - ctx.f[21].f64) as f32) as f64);
	// 82E743E4: C2610054  lfs f19, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 82E743E8: EFBDA028  fsubs f29, f29, f20
	ctx.f[29].f64 = (((ctx.f[29].f64 - ctx.f[20].f64) as f32) as f64);
	// 82E743EC: EF7B9828  fsubs f27, f27, f19
	ctx.f[27].f64 = (((ctx.f[27].f64 - ctx.f[19].f64) as f32) as f64);
	// 82E743F0: 48011881  bl 0x82e85c70
	ctx.lr = 0x82E743F4;
	sub_82E85C70(ctx, base);
	// 82E743F4: FF000890  fmr f24, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[24].f64 = ctx.f[1].f64;
	// 82E743F8: FC209090  fmr f1, f18
	ctx.f[1].f64 = ctx.f[18].f64;
	// 82E743FC: 48011845  bl 0x82e85c40
	ctx.lr = 0x82E74400;
	sub_82E85C40(ctx, base);
	// 82E74400: EC1D0772  fmuls f0, f29, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[29].f64) as f32) as f64);
	// 82E74404: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E74408: EDB80824  fdivs f13, f24, f1
	ctx.f[13].f64 = ((ctx.f[24].f64 / ctx.f[1].f64) as f32) as f64;
	// 82E7440C: ED8CA828  fsubs f12, f12, f21
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[21].f64) as f32) as f64);
	// 82E74410: EC1B06FA  fmadds f0, f27, f27, f0
	ctx.f[0].f64 = (((ctx.f[27].f64 * ctx.f[27].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E74414: EC1A06BA  fmadds f0, f26, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 * ctx.f[26].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E74418: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E7441C: EFAD0032  fmuls f29, f13, f0
	ctx.f[29].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E74420: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74424: EC00A028  fsubs f0, f0, f20
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[20].f64) as f32) as f64);
	// 82E74428: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E7442C: EDAD9828  fsubs f13, f13, f19
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[19].f64) as f32) as f64);
	// 82E74430: ED7DC82A  fadds f11, f29, f25
	ctx.f[11].f64 = ((ctx.f[29].f64 + ctx.f[25].f64) as f32) as f64;
	// 82E74434: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E74438: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E7443C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E74440: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E74444: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82E74448: 4199FF70  bgt cr6, 0x82e743b8
	if ctx.cr[6].gt {
	pc = 0x82E743B8; continue 'dispatch;
	}
	// 82E7444C: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 82E74450: 396100D8  addi r11, r1, 0xd8
	ctx.r[11].s64 = ctx.r[1].s64 + 216;
	// 82E74454: D38BFFF8  stfs f28, -8(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82E74458: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E7445C: D38BFFFC  stfs f28, -4(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82E74460: D38B0000  stfs f28, 0(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E74464: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82E74468: 4080FFEC  bge 0x82e74454
	if !ctx.cr[0].lt {
	pc = 0x82E74454; continue 'dispatch;
	}
	// 82E7446C: C0BF0000  lfs f5, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82E74470: C0010080  lfs f0, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74474: FC402890  fmr f2, f5
	ctx.f[2].f64 = ctx.f[5].f64;
	// 82E74478: C1810088  lfs f12, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E7447C: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E74480: ED8C07F2  fmuls f12, f12, f31
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E74484: C1A10084  lfs f13, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E74488: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E7448C: C09F0004  lfs f4, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82E74490: C1610090  lfs f11, 0x90(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E74494: FC202090  fmr f1, f4
	ctx.f[1].f64 = ctx.f[4].f64;
	// 82E74498: C1410094  lfs f10, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E7449C: ED6B07B2  fmuls f11, f11, f30
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E744A0: C1210098  lfs f9, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E744A4: ED4A07B2  fmuls f10, f10, f30
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E744A8: C07F0008  lfs f3, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82E744AC: ED2907B2  fmuls f9, f9, f30
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E744B0: FFC01890  fmr f30, f3
	ctx.f[30].f64 = ctx.f[3].f64;
	// 82E744B4: C11E0000  lfs f8, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82E744B8: FF802890  fmr f28, f5
	ctx.f[28].f64 = ctx.f[5].f64;
	// 82E744BC: C0DE0008  lfs f6, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82E744C0: FF401890  fmr f26, f3
	ctx.f[26].f64 = ctx.f[3].f64;
	// 82E744C4: C0FE0004  lfs f7, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82E744C8: EC40102A  fadds f2, f0, f2
	ctx.f[2].f64 = ((ctx.f[0].f64 + ctx.f[2].f64) as f32) as f64;
	// 82E744CC: C33F0008  lfs f25, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82E744D0: EC636028  fsubs f3, f3, f12
	ctx.f[3].f64 = (((ctx.f[3].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E744D4: C31F0000  lfs f24, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82E744D8: FF602090  fmr f27, f4
	ctx.f[27].f64 = ctx.f[4].f64;
	// 82E744DC: C2FF0004  lfs f23, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82E744E0: ECA50028  fsubs f5, f5, f0
	ctx.f[5].f64 = (((ctx.f[5].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E744E4: C2DF0008  lfs f22, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 82E744E8: EC846828  fsubs f4, f4, f13
	ctx.f[4].f64 = (((ctx.f[4].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E744EC: EC21682A  fadds f1, f1, f13
	ctx.f[1].f64 = ((ctx.f[1].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E744F0: ED0807F2  fmuls f8, f8, f31
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E744F4: EFDE602A  fadds f30, f30, f12
	ctx.f[30].f64 = ((ctx.f[30].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E744F8: EF9C002A  fadds f28, f28, f0
	ctx.f[28].f64 = ((ctx.f[28].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E744FC: ECC607F2  fmuls f6, f6, f31
	ctx.f[6].f64 = (((ctx.f[6].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E74500: EC425828  fsubs f2, f2, f11
	ctx.f[2].f64 = (((ctx.f[2].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E74504: EC634828  fsubs f3, f3, f9
	ctx.f[3].f64 = (((ctx.f[3].f64 - ctx.f[9].f64) as f32) as f64);
	// 82E74508: EF7B682A  fadds f27, f27, f13
	ctx.f[27].f64 = ((ctx.f[27].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E7450C: EF5A602A  fadds f26, f26, f12
	ctx.f[26].f64 = ((ctx.f[26].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E74510: ECE707F2  fmuls f7, f7, f31
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E74514: ECA55828  fsubs f5, f5, f11
	ctx.f[5].f64 = (((ctx.f[5].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E74518: EC845028  fsubs f4, f4, f10
	ctx.f[4].f64 = (((ctx.f[4].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E7451C: EC215028  fsubs f1, f1, f10
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E74520: EFDE4828  fsubs f30, f30, f9
	ctx.f[30].f64 = (((ctx.f[30].f64 - ctx.f[9].f64) as f32) as f64);
	// 82E74524: EF9C582A  fadds f28, f28, f11
	ctx.f[28].f64 = ((ctx.f[28].f64 + ctx.f[11].f64) as f32) as f64;
	// 82E74528: EC42402A  fadds f2, f2, f8
	ctx.f[2].f64 = ((ctx.f[2].f64 + ctx.f[8].f64) as f32) as f64;
	// 82E7452C: D04100DC  stfs f2, 0xdc(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82E74530: EC63302A  fadds f3, f3, f6
	ctx.f[3].f64 = ((ctx.f[3].f64 + ctx.f[6].f64) as f32) as f64;
	// 82E74534: D06100D8  stfs f3, 0xd8(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82E74538: EC7B502A  fadds f3, f27, f10
	ctx.f[3].f64 = ((ctx.f[27].f64 + ctx.f[10].f64) as f32) as f64;
	// 82E7453C: C37F0000  lfs f27, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82E74540: EC5A482A  fadds f2, f26, f9
	ctx.f[2].f64 = ((ctx.f[26].f64 + ctx.f[9].f64) as f32) as f64;
	// 82E74544: C35F0004  lfs f26, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82E74548: EF7B0028  fsubs f27, f27, f0
	ctx.f[27].f64 = (((ctx.f[27].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E7454C: ECA5402A  fadds f5, f5, f8
	ctx.f[5].f64 = ((ctx.f[5].f64 + ctx.f[8].f64) as f32) as f64;
	// 82E74550: D0A100D0  stfs f5, 0xd0(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82E74554: EC84382A  fadds f4, f4, f7
	ctx.f[4].f64 = ((ctx.f[4].f64 + ctx.f[7].f64) as f32) as f64;
	// 82E74558: D08100D4  stfs f4, 0xd4(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82E7455C: C0BE0004  lfs f5, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82E74560: EC21382A  fadds f1, f1, f7
	ctx.f[1].f64 = ((ctx.f[1].f64 + ctx.f[7].f64) as f32) as f64;
	// 82E74564: C09E0008  lfs f4, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82E74568: EFDE302A  fadds f30, f30, f6
	ctx.f[30].f64 = ((ctx.f[30].f64 + ctx.f[6].f64) as f32) as f64;
	// 82E7456C: D02100E0  stfs f1, 0xe0(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82E74570: ECA507F2  fmuls f5, f5, f31
	ctx.f[5].f64 = (((ctx.f[5].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E74574: D3C100E4  stfs f30, 0xe4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82E74578: EC3C402A  fadds f1, f28, f8
	ctx.f[1].f64 = ((ctx.f[28].f64 + ctx.f[8].f64) as f32) as f64;
	// 82E7457C: EC8407F2  fmuls f4, f4, f31
	ctx.f[4].f64 = (((ctx.f[4].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E74580: C3DF0004  lfs f30, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E74584: C3FF0000  lfs f31, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E74588: EFDE6828  fsubs f30, f30, f13
	ctx.f[30].f64 = (((ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E7458C: C39F0008  lfs f28, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82E74590: EFFF0028  fsubs f31, f31, f0
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E74594: EF9C6028  fsubs f28, f28, f12
	ctx.f[28].f64 = (((ctx.f[28].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E74598: EF5A6828  fsubs f26, f26, f13
	ctx.f[26].f64 = (((ctx.f[26].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E7459C: EF396028  fsubs f25, f25, f12
	ctx.f[25].f64 = (((ctx.f[25].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E745A0: EC63382A  fadds f3, f3, f7
	ctx.f[3].f64 = ((ctx.f[3].f64 + ctx.f[7].f64) as f32) as f64;
	// 82E745A4: EC42302A  fadds f2, f2, f6
	ctx.f[2].f64 = ((ctx.f[2].f64 + ctx.f[6].f64) as f32) as f64;
	// 82E745A8: EF00C02A  fadds f24, f0, f24
	ctx.f[24].f64 = ((ctx.f[0].f64 + ctx.f[24].f64) as f32) as f64;
	// 82E745AC: EEF7682A  fadds f23, f23, f13
	ctx.f[23].f64 = ((ctx.f[23].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E745B0: D02100E8  stfs f1, 0xe8(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82E745B4: EC3F582A  fadds f1, f31, f11
	ctx.f[1].f64 = ((ctx.f[31].f64 + ctx.f[11].f64) as f32) as f64;
	// 82E745B8: EFFE502A  fadds f31, f30, f10
	ctx.f[31].f64 = ((ctx.f[30].f64 + ctx.f[10].f64) as f32) as f64;
	// 82E745BC: D04100F0  stfs f2, 0xf0(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82E745C0: EFDC482A  fadds f30, f28, f9
	ctx.f[30].f64 = ((ctx.f[28].f64 + ctx.f[9].f64) as f32) as f64;
	// 82E745C4: D06100EC  stfs f3, 0xec(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82E745C8: EF9B5828  fsubs f28, f27, f11
	ctx.f[28].f64 = (((ctx.f[27].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E745CC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E745D0: EF7A5028  fsubs f27, f26, f10
	ctx.f[27].f64 = (((ctx.f[26].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E745D4: EF594828  fsubs f26, f25, f9
	ctx.f[26].f64 = (((ctx.f[25].f64 - ctx.f[9].f64) as f32) as f64);
	// 82E745D8: EC575028  fsubs f2, f23, f10
	ctx.f[2].f64 = (((ctx.f[23].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E745DC: EED6602A  fadds f22, f22, f12
	ctx.f[22].f64 = ((ctx.f[22].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E745E0: EC785828  fsubs f3, f24, f11
	ctx.f[3].f64 = (((ctx.f[24].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E745E4: EC21402A  fadds f1, f1, f8
	ctx.f[1].f64 = ((ctx.f[1].f64 + ctx.f[8].f64) as f32) as f64;
	// 82E745E8: D02100F4  stfs f1, 0xf4(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82E745EC: EFFF382A  fadds f31, f31, f7
	ctx.f[31].f64 = ((ctx.f[31].f64 + ctx.f[7].f64) as f32) as f64;
	// 82E745F0: D3E100F8  stfs f31, 0xf8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82E745F4: EFDE302A  fadds f30, f30, f6
	ctx.f[30].f64 = ((ctx.f[30].f64 + ctx.f[6].f64) as f32) as f64;
	// 82E745F8: C03F0004  lfs f1, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E745FC: EF9C4028  fsubs f28, f28, f8
	ctx.f[28].f64 = (((ctx.f[28].f64 - ctx.f[8].f64) as f32) as f64);
	// 82E74600: D3810100  stfs f28, 0x100(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82E74604: C39F0000  lfs f28, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82E74608: ECFB3828  fsubs f7, f27, f7
	ctx.f[7].f64 = (((ctx.f[27].f64 - ctx.f[7].f64) as f32) as f64);
	// 82E7460C: ECDA3028  fsubs f6, f26, f6
	ctx.f[6].f64 = (((ctx.f[26].f64 - ctx.f[6].f64) as f32) as f64);
	// 82E74610: D0C10108  stfs f6, 0x108(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82E74614: ECC22828  fsubs f6, f2, f5
	ctx.f[6].f64 = (((ctx.f[2].f64 - ctx.f[5].f64) as f32) as f64);
	// 82E74618: C05F0000  lfs f2, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82E7461C: EC42002A  fadds f2, f2, f0
	ctx.f[2].f64 = ((ctx.f[2].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E74620: C3FF0008  lfs f31, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E74624: EC1C0028  fsubs f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E74628: C37F0004  lfs f27, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82E7462C: C39F0008  lfs f28, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82E74630: EF364828  fsubs f25, f22, f9
	ctx.f[25].f64 = (((ctx.f[22].f64 - ctx.f[9].f64) as f32) as f64);
	// 82E74634: EC21682A  fadds f1, f1, f13
	ctx.f[1].f64 = ((ctx.f[1].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E74638: D0E10104  stfs f7, 0x104(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82E7463C: EFFF602A  fadds f31, f31, f12
	ctx.f[31].f64 = ((ctx.f[31].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E74640: D0C10110  stfs f6, 0x110(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82E74644: EDBB6828  fsubs f13, f27, f13
	ctx.f[13].f64 = (((ctx.f[27].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E74648: D3C100FC  stfs f30, 0xfc(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82E7464C: ED9C6028  fsubs f12, f28, f12
	ctx.f[12].f64 = (((ctx.f[28].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E74650: ECE34028  fsubs f7, f3, f8
	ctx.f[7].f64 = (((ctx.f[3].f64 - ctx.f[8].f64) as f32) as f64);
	// 82E74654: D0E1010C  stfs f7, 0x10c(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82E74658: EFDD0772  fmuls f30, f29, f29
	ctx.f[30].f64 = (((ctx.f[29].f64 * ctx.f[29].f64) as f32) as f64);
	// 82E7465C: ECE2582A  fadds f7, f2, f11
	ctx.f[7].f64 = ((ctx.f[2].f64 + ctx.f[11].f64) as f32) as f64;
	// 82E74660: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82E74664: EC792028  fsubs f3, f25, f4
	ctx.f[3].f64 = (((ctx.f[25].f64 - ctx.f[4].f64) as f32) as f64);
	// 82E74668: D0610114  stfs f3, 0x114(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82E7466C: ECC1502A  fadds f6, f1, f10
	ctx.f[6].f64 = ((ctx.f[1].f64 + ctx.f[10].f64) as f32) as f64;
	// 82E74670: EC7F482A  fadds f3, f31, f9
	ctx.f[3].f64 = ((ctx.f[31].f64 + ctx.f[9].f64) as f32) as f64;
	// 82E74674: EDAD502A  fadds f13, f13, f10
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 82E74678: ED8C482A  fadds f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64;
	// 82E7467C: ED674028  fsubs f11, f7, f8
	ctx.f[11].f64 = (((ctx.f[7].f64 - ctx.f[8].f64) as f32) as f64);
	// 82E74680: D1610118  stfs f11, 0x118(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82E74684: EC004028  fsubs f0, f0, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[8].f64) as f32) as f64);
	// 82E74688: D0010124  stfs f0, 0x124(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82E7468C: ED462828  fsubs f10, f6, f5
	ctx.f[10].f64 = (((ctx.f[6].f64 - ctx.f[5].f64) as f32) as f64);
	// 82E74690: D141011C  stfs f10, 0x11c(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82E74694: ED232028  fsubs f9, f3, f4
	ctx.f[9].f64 = (((ctx.f[3].f64 - ctx.f[4].f64) as f32) as f64);
	// 82E74698: D1210120  stfs f9, 0x120(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82E7469C: EDAD2828  fsubs f13, f13, f5
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[5].f64) as f32) as f64);
	// 82E746A0: D1A10128  stfs f13, 0x128(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82E746A4: ED8C2028  fsubs f12, f12, f4
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[4].f64) as f32) as f64);
	// 82E746A8: D181012C  stfs f12, 0x12c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82E746AC: 1D7E000C  mulli r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 * 12;
	// 82E746B0: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 82E746B4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E746B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E746BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E746C0: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E746C4: 4BFFF66D  bl 0x82e73d30
	ctx.lr = 0x82E746C8;
	sub_82E73D30(ctx, base);
	// 82E746C8: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E746CC: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82E746D0: EC140028  fsubs f0, f20, f0
	ctx.f[0].f64 = (((ctx.f[20].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E746D4: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E746D8: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82E746DC: EDB36828  fsubs f13, f19, f13
	ctx.f[13].f64 = (((ctx.f[19].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E746E0: C1830008  lfs f12, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E746E4: D1810078  stfs f12, 0x78(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82E746E8: ED956028  fsubs f12, f21, f12
	ctx.f[12].f64 = (((ctx.f[21].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E746EC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E746F0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E746F4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E746F8: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82E746FC: 419801C8  blt cr6, 0x82e748c4
	if ctx.cr[6].lt {
	pc = 0x82E748C4; continue 'dispatch;
	}
	// 82E74700: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 82E74704: 557E063E  clrlwi r30, r11, 0x18
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82E74708: 2B1E0008  cmplwi cr6, r30, 8
	ctx.cr[6].compare_u32(ctx.r[30].u32, 8 as u32, &mut ctx.xer);
	// 82E7470C: 4198FFA0  blt cr6, 0x82e746ac
	if ctx.cr[6].lt {
	pc = 0x82E746AC; continue 'dispatch;
	}
	// 82E74710: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E74714: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E74718: 3BCBD8B0  addi r30, r11, -0x2750
	ctx.r[30].s64 = ctx.r[11].s64 + -10064;
	// 82E7471C: 579F103A  slwi r31, r28, 2
	ctx.r[31].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82E74720: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 82E74724: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E74728: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E7472C: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82E74730: 7D7FF0AE  lbzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82E74734: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82E74738: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E7473C: 4BFFF5F5  bl 0x82e73d30
	ctx.lr = 0x82E74740;
	sub_82E73D30(ctx, base);
	// 82E74740: 395E0001  addi r10, r30, 1
	ctx.r[10].s64 = ctx.r[30].s64 + 1;
	// 82E74744: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E74748: 392100D0  addi r9, r1, 0xd0
	ctx.r[9].s64 = ctx.r[1].s64 + 208;
	// 82E7474C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E74750: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E74754: 7D5F50AE  lbzx r10, r31, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E74758: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 82E7475C: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74760: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 * 12;
	// 82E74764: D00100B0  stfs f0, 0xb0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82E74768: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7476C: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82E74770: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74774: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82E74778: 7CCA4A14  add r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E7477C: 4BFFF5B5  bl 0x82e73d30
	ctx.lr = 0x82E74780;
	sub_82E73D30(ctx, base);
	// 82E74780: 395E0002  addi r10, r30, 2
	ctx.r[10].s64 = ctx.r[30].s64 + 2;
	// 82E74784: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E74788: 392100D0  addi r9, r1, 0xd0
	ctx.r[9].s64 = ctx.r[1].s64 + 208;
	// 82E7478C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E74790: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E74794: 7D5F50AE  lbzx r10, r31, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E74798: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 82E7479C: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E747A0: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 * 12;
	// 82E747A4: D00100C0  stfs f0, 0xc0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82E747A8: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E747AC: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82E747B0: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E747B4: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82E747B8: 7CCA4A14  add r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E747BC: 4BFFF575  bl 0x82e73d30
	ctx.lr = 0x82E747C0;
	sub_82E73D30(ctx, base);
	// 82E747C0: 395E0003  addi r10, r30, 3
	ctx.r[10].s64 = ctx.r[30].s64 + 3;
	// 82E747C4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E747C8: 392100D0  addi r9, r1, 0xd0
	ctx.r[9].s64 = ctx.r[1].s64 + 208;
	// 82E747CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E747D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E747D4: 7D5F50AE  lbzx r10, r31, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E747D8: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 82E747DC: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E747E0: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 * 12;
	// 82E747E4: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82E747E8: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E747EC: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82E747F0: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E747F4: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82E747F8: 7CCA4A14  add r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E747FC: 4BFFF535  bl 0x82e73d30
	ctx.lr = 0x82E74800;
	sub_82E73D30(ctx, base);
	// 82E74800: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E74804: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82E74808: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82E7480C: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 82E74810: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82E74814: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74818: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82E7481C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E74820: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74824: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E74828: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7482C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E74830: 4BFFF7C9  bl 0x82e73ff8
	ctx.lr = 0x82E74834;
	sub_82E73FF8(ctx, base);
	// 82E74834: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E74838: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E7483C: 419A0088  beq cr6, 0x82e748c4
	if ctx.cr[6].eq {
	pc = 0x82E748C4; continue 'dispatch;
	}
	// 82E74840: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 82E74844: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82E74848: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 82E7484C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E74850: 4BFFF589  bl 0x82e73dd8
	ctx.lr = 0x82E74854;
	sub_82E73DD8(ctx, base);
	// 82E74854: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E74858: 4082006C  bne 0x82e748c4
	if !ctx.cr[0].eq {
	pc = 0x82E748C4; continue 'dispatch;
	}
	// 82E7485C: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 82E74860: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82E74864: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82E74868: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E7486C: 4BFFF56D  bl 0x82e73dd8
	ctx.lr = 0x82E74870;
	sub_82E73DD8(ctx, base);
	// 82E74870: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E74874: 40820050  bne 0x82e748c4
	if !ctx.cr[0].eq {
	pc = 0x82E748C4; continue 'dispatch;
	}
	// 82E74878: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82E7487C: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82E74880: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 82E74884: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E74888: 4BFFF551  bl 0x82e73dd8
	ctx.lr = 0x82E7488C;
	sub_82E73DD8(ctx, base);
	// 82E7488C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E74890: 40820034  bne 0x82e748c4
	if !ctx.cr[0].eq {
	pc = 0x82E748C4; continue 'dispatch;
	}
	// 82E74894: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 82E74898: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82E7489C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82E748A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E748A4: 4BFFF535  bl 0x82e73dd8
	ctx.lr = 0x82E748A8;
	sub_82E73DD8(ctx, base);
	// 82E748A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E748AC: 40820018  bne 0x82e748c4
	if !ctx.cr[0].eq {
	pc = 0x82E748C4; continue 'dispatch;
	}
	// 82E748B0: 397C0001  addi r11, r28, 1
	ctx.r[11].s64 = ctx.r[28].s64 + 1;
	// 82E748B4: 557C063E  clrlwi r28, r11, 0x18
	ctx.r[28].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82E748B8: 2B1C0006  cmplwi cr6, r28, 6
	ctx.cr[6].compare_u32(ctx.r[28].u32, 6 as u32, &mut ctx.xer);
	// 82E748BC: 4198FE60  blt cr6, 0x82e7471c
	if ctx.cr[6].lt {
	pc = 0x82E7471C; continue 'dispatch;
	}
	// 82E748C0: 4BFFFAF8  b 0x82e743b8
	pc = 0x82E743B8; continue 'dispatch;
	// 82E748C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E748C8: 38210210  addi r1, r1, 0x210
	ctx.r[1].s64 = ctx.r[1].s64 + 528;
	// 82E748CC: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82E748D0: 4BE3942D  bl 0x82cadcfc
	ctx.lr = 0x82E748D4;
	sub_82CADCEC(ctx, base);
	// 82E748D4: 4BE34B84  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E748D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E748D8 size=12
    let mut pc: u32 = 0x82E748D8;
    'dispatch: loop {
        match pc {
            0x82E748D8 => {
    //   block [0x82E748D8..0x82E748E4)
	// 82E748D8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E748DC: 386BBD28  addi r3, r11, -0x42d8
	ctx.r[3].s64 = ctx.r[11].s64 + -17112;
	// 82E748E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E748E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E748E8 size=112
    let mut pc: u32 = 0x82E748E8;
    'dispatch: loop {
        match pc {
            0x82E748E8 => {
    //   block [0x82E748E8..0x82E74958)
	// 82E748E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E748EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E748F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E748F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E748F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E748FC: 48017465  bl 0x82e8bd60
	ctx.lr = 0x82E74900;
	sub_82E8BD60(ctx, base);
	// 82E74900: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E74904: 4082000C  bne 0x82e74910
	if !ctx.cr[0].eq {
	pc = 0x82E74910; continue 'dispatch;
	}
	// 82E74908: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E7490C: 48000038  b 0x82e74944
	pc = 0x82E74944; continue 'dispatch;
	// 82E74910: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E74914: 388BE4AC  addi r4, r11, -0x1b54
	ctx.r[4].s64 = ctx.r[11].s64 + -6996;
	// 82E74918: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7491C: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E74920: 4B3F3301  bl 0x82267c20
	ctx.lr = 0x82E74924;
	sub_82267C20(ctx, base);
	// 82E74924: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E74928: 907F005C  stw r3, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82E7492C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E74930: 409A0010  bne cr6, 0x82e74940
	if !ctx.cr[6].eq {
	pc = 0x82E74940; continue 'dispatch;
	}
	// 82E74934: 38800064  li r4, 0x64
	ctx.r[4].s64 = 100;
	// 82E74938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7493C: 480240AD  bl 0x82e989e8
	ctx.lr = 0x82E74940;
	sub_82E989E8(ctx, base);
	// 82E74940: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E74944: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E74948: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E7494C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E74950: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E74954: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E74958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E74958 size=8
    let mut pc: u32 = 0x82E74958;
    'dispatch: loop {
        match pc {
            0x82E74958 => {
    //   block [0x82E74958..0x82E74960)
	// 82E74958: 90830040  stw r4, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[4].u32 ) };
	// 82E7495C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E74960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E74960 size=20
    let mut pc: u32 = 0x82E74960;
    'dispatch: loop {
        match pc {
            0x82E74960 => {
    //   block [0x82E74960..0x82E74974)
	// 82E74960: 8163003C  lwz r11, 0x3c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E74964: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E74968: 409A000C  bne cr6, 0x82e74974
	if !ctx.cr[6].eq {
		sub_82E74974(ctx, base);
		return;
	}
	// 82E7496C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E74970: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E74974(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E74974 size=64
    let mut pc: u32 = 0x82E74974;
    'dispatch: loop {
        match pc {
            0x82E74974 => {
    //   block [0x82E74974..0x82E749B4)
	// 82E74974: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E74978: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E7497C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E74980: 4098001C  bge cr6, 0x82e7499c
	if !ctx.cr[6].lt {
	pc = 0x82E7499C; continue 'dispatch;
	}
	// 82E74984: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E74988: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 * 20;
	// 82E7498C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E74990: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E74994: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82E74998: 409A0008  bne cr6, 0x82e749a0
	if !ctx.cr[6].eq {
	pc = 0x82E749A0; continue 'dispatch;
	}
	// 82E7499C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E749A0: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82E749A4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E749A8: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82E749AC: 69430001  xori r3, r10, 1
	ctx.r[3].u64 = ctx.r[10].u64 ^ 1;
	// 82E749B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E749B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E749B8 size=604
    let mut pc: u32 = 0x82E749B8;
    'dispatch: loop {
        match pc {
            0x82E749B8 => {
    //   block [0x82E749B8..0x82E74C14)
	// 82E749B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E749BC: 4BE34A45  bl 0x82ca9400
	ctx.lr = 0x82E749C0;
	sub_82CA93D0(ctx, base);
	// 82E749C0: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 82E749C4: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82E749C8: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82E749CC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E749D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E749D4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82E749D8: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E749DC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E749E0: 409A0214  bne cr6, 0x82e74bf4
	if !ctx.cr[6].eq {
	pc = 0x82E74BF4; continue 'dispatch;
	}
	// 82E749E4: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E749E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E749EC: 419A0110  beq cr6, 0x82e74afc
	if ctx.cr[6].eq {
	pc = 0x82E74AFC; continue 'dispatch;
	}
	// 82E749F0: 3F608334  lis r27, -0x7ccc
	ctx.r[27].s64 = -2093744128;
	// 82E749F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E749F8: 817B0718  lwz r11, 0x718(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E749FC: C3AA0C14  lfs f29, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82E74A00: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E74A04: 4182000C  beq 0x82e74a10
	if ctx.cr[0].eq {
	pc = 0x82E74A10; continue 'dispatch;
	}
	// 82E74A08: C3CB000C  lfs f30, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E74A0C: 48000008  b 0x82e74a14
	pc = 0x82E74A14; continue 'dispatch;
	// 82E74A10: FFC0E890  fmr f30, f29
	ctx.f[30].f64 = ctx.f[29].f64;
	// 82E74A14: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E74A18: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E74A1C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E74A20: 3B8BC5C8  addi r28, r11, -0x3a38
	ctx.r[28].s64 = ctx.r[11].s64 + -14904;
	// 82E74A24: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E74A28: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E74A2C: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E74A30: 4B373C49  bl 0x821e8678
	ctx.lr = 0x82E74A34;
	sub_821E8678(ctx, base);
	// 82E74A34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E74A38: 41820008  beq 0x82e74a40
	if ctx.cr[0].eq {
	pc = 0x82E74A40; continue 'dispatch;
	}
	// 82E74A3C: C3C30004  lfs f30, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E74A40: EDBE07B2  fmuls f13, f30, f30
	ctx.f[13].f64 = (((ctx.f[30].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E74A44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E74A48: 3BBA0004  addi r29, r26, 4
	ctx.r[29].s64 = ctx.r[26].s64 + 4;
	// 82E74A4C: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E74A50: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E74A54: C00B0A4C  lfs f0, 0xa4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2636 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74A58: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E74A5C: 480541E5  bl 0x82ec8c40
	ctx.lr = 0x82E74A60;
	sub_82EC8C40(ctx, base);
	// 82E74A60: 48000094  b 0x82e74af4
	pc = 0x82E74AF4; continue 'dispatch;
	// 82E74A64: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E74A68: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E74A6C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E74A70: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E74A74: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E74A78: 419A0074  beq cr6, 0x82e74aec
	if ctx.cr[6].eq {
	pc = 0x82E74AEC; continue 'dispatch;
	}
	// 82E74A7C: 817B0718  lwz r11, 0x718(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E74A80: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E74A84: 4182000C  beq 0x82e74a90
	if ctx.cr[0].eq {
	pc = 0x82E74A90; continue 'dispatch;
	}
	// 82E74A88: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E74A8C: 48000008  b 0x82e74a94
	pc = 0x82E74A94; continue 'dispatch;
	// 82E74A90: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	// 82E74A94: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E74A98: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E74A9C: 4B373BDD  bl 0x821e8678
	ctx.lr = 0x82E74AA0;
	sub_821E8678(ctx, base);
	// 82E74AA0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E74AA4: 41820008  beq 0x82e74aac
	if ctx.cr[0].eq {
	pc = 0x82E74AAC; continue 'dispatch;
	}
	// 82E74AA8: C3E30004  lfs f31, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E74AAC: EC1FF02A  fadds f0, f31, f30
	ctx.f[0].f64 = ((ctx.f[31].f64 + ctx.f[30].f64) as f32) as f64;
	// 82E74AB0: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E74AB4: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E74AB8: C15D0008  lfs f10, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E74ABC: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E74AC0: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74AC4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E74AC8: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E74ACC: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E74AD0: C19E000C  lfs f12, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E74AD4: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E74AD8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E74ADC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E74AE0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E74AE4: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82E74AE8: 41980124  blt cr6, 0x82e74c0c
	if ctx.cr[6].lt {
	pc = 0x82E74C0C; continue 'dispatch;
	}
	// 82E74AEC: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E74AF0: 48053B69  bl 0x82ec8658
	ctx.lr = 0x82E74AF4;
	sub_82EC8658(ctx, base);
	// 82E74AF4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82E74AF8: 4082FF6C  bne 0x82e74a64
	if !ctx.cr[0].eq {
	pc = 0x82E74A64; continue 'dispatch;
	}
	// 82E74AFC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E74B00: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E74B04: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E74B08: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82E74B0C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E74B10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E74B14: 40990054  ble cr6, 0x82e74b68
	if !ctx.cr[6].gt {
	pc = 0x82E74B68; continue 'dispatch;
	}
	// 82E74B18: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E74B1C: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E74B20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E74B24: 4BFFD485  bl 0x82e71fa8
	ctx.lr = 0x82E74B28;
	sub_82E71FA8(ctx, base);
	// 82E74B28: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E74B2C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E74B30: 409A0024  bne cr6, 0x82e74b54
	if !ctx.cr[6].eq {
	pc = 0x82E74B54; continue 'dispatch;
	}
	// 82E74B34: 80BF0050  lwz r5, 0x50(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E74B38: 389A0004  addi r4, r26, 4
	ctx.r[4].s64 = ctx.r[26].s64 + 4;
	// 82E74B3C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E74B40: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E74B44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E74B48: 4E800421  bctrl
	ctx.lr = 0x82E74B4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E74B4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E74B50: 408200BC  bne 0x82e74c0c
	if !ctx.cr[0].eq {
	pc = 0x82E74C0C; continue 'dispatch;
	}
	// 82E74B54: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E74B58: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E74B5C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E74B60: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E74B64: 4198FFB4  blt cr6, 0x82e74b18
	if ctx.cr[6].lt {
	pc = 0x82E74B18; continue 'dispatch;
	}
	// 82E74B68: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E74B6C: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E74B70: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E74B74: 396B115C  addi r11, r11, 0x115c
	ctx.r[11].s64 = ctx.r[11].s64 + 4444;
	// 82E74B78: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74B7C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E74B80: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74B84: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82E74B88: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74B8C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E74B90: 816A003C  lwz r11, 0x3c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E74B94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E74B98: 40990054  ble cr6, 0x82e74bec
	if !ctx.cr[6].gt {
	pc = 0x82E74BEC; continue 'dispatch;
	}
	// 82E74B9C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82E74BA0: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E74BA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E74BA8: 4BFFD361  bl 0x82e71f08
	ctx.lr = 0x82E74BAC;
	sub_82E71F08(ctx, base);
	// 82E74BAC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E74BB0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E74BB4: 409A0024  bne cr6, 0x82e74bd8
	if !ctx.cr[6].eq {
	pc = 0x82E74BD8; continue 'dispatch;
	}
	// 82E74BB8: 80BF004C  lwz r5, 0x4c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82E74BBC: 389A0004  addi r4, r26, 4
	ctx.r[4].s64 = ctx.r[26].s64 + 4;
	// 82E74BC0: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E74BC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E74BC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E74BCC: 4E800421  bctrl
	ctx.lr = 0x82E74BD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E74BD0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E74BD4: 40820038  bne 0x82e74c0c
	if !ctx.cr[0].eq {
	pc = 0x82E74C0C; continue 'dispatch;
	}
	// 82E74BD8: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E74BDC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E74BE0: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E74BE4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E74BE8: 4198FFB4  blt cr6, 0x82e74b9c
	if ctx.cr[6].lt {
	pc = 0x82E74B9C; continue 'dispatch;
	}
	// 82E74BEC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E74BF0: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82E74BF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E74BF8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82E74BFC: CBA1FFB0  lfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82E74C00: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82E74C04: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82E74C08: 4BE34848  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 82E74C0C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E74C10: 4BFFFFE8  b 0x82e74bf8
	pc = 0x82E74BF8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E74C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E74C18 size=92
    let mut pc: u32 = 0x82E74C18;
    'dispatch: loop {
        match pc {
            0x82E74C18 => {
    //   block [0x82E74C18..0x82E74C74)
	// 82E74C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E74C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E74C20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E74C24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E74C28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E74C2C: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E74C30: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E74C34: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E74C38: 814A002C  lwz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E74C3C: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E74C40: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E74C44: 4E800421  bctrl
	ctx.lr = 0x82E74C48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E74C48: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E74C4C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E74C50: 419A000C  beq cr6, 0x82e74c5c
	if ctx.cr[6].eq {
	pc = 0x82E74C5C; continue 'dispatch;
	}
	// 82E74C54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E74C58: 997F0010  stb r11, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 82E74C5C: 887F0010  lbz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E74C60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E74C64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E74C68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E74C6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E74C70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E74C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E74C78 size=52
    let mut pc: u32 = 0x82E74C78;
    'dispatch: loop {
        match pc {
            0x82E74C78 => {
    //   block [0x82E74C78..0x82E74CAC)
	// 82E74C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E74C7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E74C80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E74C84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E74C88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E74C8C: 48023E35  bl 0x82e98ac0
	ctx.lr = 0x82E74C90;
	sub_82E98AC0(ctx, base);
	// 82E74C90: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E74C94: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82E74C98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E74C9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E74CA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E74CA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E74CA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E74CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E74CB0 size=836
    let mut pc: u32 = 0x82E74CB0;
    'dispatch: loop {
        match pc {
            0x82E74CB0 => {
    //   block [0x82E74CB0..0x82E74FF4)
	// 82E74CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E74CB4: 4BE34751  bl 0x82ca9404
	ctx.lr = 0x82E74CB8;
	sub_82CA93D0(ctx, base);
	// 82E74CB8: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 82E74CBC: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82E74CC0: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82E74CC4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E74CC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E74CCC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82E74CD0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82E74CD4: 394A8704  addi r10, r10, -0x78fc
	ctx.r[10].s64 = ctx.r[10].s64 + -30972;
	// 82E74CD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E74CDC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E74CE0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E74CE4: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82E74CE8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82E74CEC: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E74CF0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E74CF4: 41820050  beq 0x82e74d44
	if ctx.cr[0].eq {
	pc = 0x82E74D44; continue 'dispatch;
	}
	// 82E74CF8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E74CFC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E74D00: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E74D04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E74D08: 4182003C  beq 0x82e74d44
	if ctx.cr[0].eq {
	pc = 0x82E74D44; continue 'dispatch;
	}
	// 82E74D0C: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E74D10: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82E74D14: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E74D18: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82E74D1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E74D20: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E74D24: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E74D28: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E74D2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E74D30: 4E800421  bctrl
	ctx.lr = 0x82E74D34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E74D34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E74D38: 4082000C  bne 0x82e74d44
	if !ctx.cr[0].eq {
	pc = 0x82E74D44; continue 'dispatch;
	}
	// 82E74D3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E74D40: 480002A0  b 0x82e74fe0
	pc = 0x82E74FE0; continue 'dispatch;
	// 82E74D44: 897E0054  lbz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E74D48: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E74D4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E74D50: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E74D54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E74D58: 4082000C  bne 0x82e74d64
	if !ctx.cr[0].eq {
	pc = 0x82E74D64; continue 'dispatch;
	}
	// 82E74D5C: 48023E15  bl 0x82e98b70
	ctx.lr = 0x82E74D60;
	sub_82E98B70(ctx, base);
	// 82E74D60: 48000280  b 0x82e74fe0
	pc = 0x82E74FE0; continue 'dispatch;
	// 82E74D64: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E74D68: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E74D6C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E74D70: 80EB003C  lwz r7, 0x3c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E74D74: 80CB0038  lwz r6, 0x38(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E74D78: 810B0018  lwz r8, 0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E74D7C: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82E74D80: 7D67502E  lwzx r11, r7, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E74D84: 7D46502E  lwzx r10, r6, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E74D88: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 * 20;
	// 82E74D8C: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 * 20;
	// 82E74D90: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82E74D94: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E74D98: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74D9C: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E74DA0: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E74DA4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74DA8: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E74DAC: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E74DB0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74DB4: C16A000C  lfs f11, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E74DB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E74DBC: ED6B002A  fadds f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E74DC0: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74DC4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E74DC8: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E74DCC: EDAC0032  fmuls f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E74DD0: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E74DD4: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E74DD8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E74DDC: 48023D95  bl 0x82e98b70
	ctx.lr = 0x82E74DE0;
	sub_82E98B70(ctx, base);
	// 82E74DE0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E74DE4: 4182FF58  beq 0x82e74d3c
	if ctx.cr[0].eq {
	pc = 0x82E74D3C; continue 'dispatch;
	}
	// 82E74DE8: 807E0040  lwz r3, 0x40(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E74DEC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E74DF0: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82E74DF4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E74DF8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82E74DFC: 3F808334  lis r28, -0x7ccc
	ctx.r[28].s64 = -2093744128;
	// 82E74E00: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E74E04: C3A90C18  lfs f29, 0xc18(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82E74E08: C3EA0A54  lfs f31, 0xa54(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2644 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E74E0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E74E10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E74E14: C3CB0C14  lfs f30, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E74E18: 409900CC  ble cr6, 0x82e74ee4
	if !ctx.cr[6].gt {
	pc = 0x82E74EE4; continue 'dispatch;
	}
	// 82E74E1C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E74E20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E74E24: 4BFFD185  bl 0x82e71fa8
	ctx.lr = 0x82E74E28;
	sub_82E71FA8(ctx, base);
	// 82E74E28: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E74E2C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E74E30: 409A00A0  bne cr6, 0x82e74ed0
	if !ctx.cr[6].eq {
	pc = 0x82E74ED0; continue 'dispatch;
	}
	// 82E74E34: 80BE0050  lwz r5, 0x50(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E74E38: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E74E3C: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E74E40: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E74E44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E74E48: 4E800421  bctrl
	ctx.lr = 0x82E74E4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E74E4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E74E50: 41820080  beq 0x82e74ed0
	if ctx.cr[0].eq {
	pc = 0x82E74ED0; continue 'dispatch;
	}
	// 82E74E54: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E74E58: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E74E5C: 4182000C  beq 0x82e74e68
	if ctx.cr[0].eq {
	pc = 0x82E74E68; continue 'dispatch;
	}
	// 82E74E60: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74E64: 48000008  b 0x82e74e6c
	pc = 0x82E74E6C; continue 'dispatch;
	// 82E74E68: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 82E74E6C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E74E70: ED6007F2  fmuls f11, f0, f31
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E74E74: C1810060  lfs f12, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E74E78: C1410068  lfs f10, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E74E7C: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74E80: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E74E84: C1810064  lfs f12, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E74E88: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E74E8C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E74E90: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E74E94: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E74E98: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E74E9C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E74EA0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E74EA4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E74EA8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82E74EAC: 4099000C  ble cr6, 0x82e74eb8
	if !ctx.cr[6].gt {
	pc = 0x82E74EB8; continue 'dispatch;
	}
	// 82E74EB0: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 82E74EB4: 48000010  b 0x82e74ec4
	pc = 0x82E74EC4; continue 'dispatch;
	// 82E74EB8: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E74EBC: C1BE0058  lfs f13, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E74EC0: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E74EC4: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E74EC8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E74ECC: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E74ED0: 807E0040  lwz r3, 0x40(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E74ED4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82E74ED8: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E74EDC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E74EE0: 4198FF3C  blt cr6, 0x82e74e1c
	if ctx.cr[6].lt {
	pc = 0x82E74E1C; continue 'dispatch;
	}
	// 82E74EE4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E74EE8: 807E0040  lwz r3, 0x40(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E74EEC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82E74EF0: 396B115C  addi r11, r11, 0x115c
	ctx.r[11].s64 = ctx.r[11].s64 + 4444;
	// 82E74EF4: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74EF8: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82E74EFC: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74F00: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82E74F04: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74F08: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82E74F0C: 8163003C  lwz r11, 0x3c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E74F10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E74F14: 409900C8  ble cr6, 0x82e74fdc
	if !ctx.cr[6].gt {
	pc = 0x82E74FDC; continue 'dispatch;
	}
	// 82E74F18: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82E74F1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E74F20: 4BFFCFE9  bl 0x82e71f08
	ctx.lr = 0x82E74F24;
	sub_82E71F08(ctx, base);
	// 82E74F24: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E74F28: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E74F2C: 409A009C  bne cr6, 0x82e74fc8
	if !ctx.cr[6].eq {
	pc = 0x82E74FC8; continue 'dispatch;
	}
	// 82E74F30: 80BE004C  lwz r5, 0x4c(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 82E74F34: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E74F38: 817E0044  lwz r11, 0x44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E74F3C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E74F40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E74F44: 4E800421  bctrl
	ctx.lr = 0x82E74F48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E74F48: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E74F4C: 4182007C  beq 0x82e74fc8
	if ctx.cr[0].eq {
	pc = 0x82E74FC8; continue 'dispatch;
	}
	// 82E74F50: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E74F54: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E74F58: 4182000C  beq 0x82e74f64
	if ctx.cr[0].eq {
	pc = 0x82E74F64; continue 'dispatch;
	}
	// 82E74F5C: C16B000C  lfs f11, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E74F60: 48000008  b 0x82e74f68
	pc = 0x82E74F68; continue 'dispatch;
	// 82E74F64: FD60F090  fmr f11, f30
	ctx.f[11].f64 = ctx.f[30].f64;
	// 82E74F68: C1A10074  lfs f13, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E74F6C: ED6B07F2  fmuls f11, f11, f31
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E74F70: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E74F74: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E74F78: C1810070  lfs f12, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E74F7C: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E74F80: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E74F84: C1410078  lfs f10, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E74F88: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E74F8C: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E74F90: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E74F94: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82E74F98: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E74F9C: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E74FA0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82E74FA4: 4099000C  ble cr6, 0x82e74fb0
	if !ctx.cr[6].gt {
	pc = 0x82E74FB0; continue 'dispatch;
	}
	// 82E74FA8: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 82E74FAC: 48000010  b 0x82e74fbc
	pc = 0x82E74FBC; continue 'dispatch;
	// 82E74FB0: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E74FB4: C1BE0058  lfs f13, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E74FB8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E74FBC: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E74FC0: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E74FC4: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E74FC8: 807E0040  lwz r3, 0x40(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E74FCC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82E74FD0: 8163003C  lwz r11, 0x3c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E74FD4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E74FD8: 4198FF40  blt cr6, 0x82e74f18
	if ctx.cr[6].lt {
	pc = 0x82E74F18; continue 'dispatch;
	}
	// 82E74FDC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E74FE0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82E74FE4: CBA1FFB8  lfd f29, -0x48(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82E74FE8: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82E74FEC: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82E74FF0: 4BE34464  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E74FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E74FF8 size=20
    let mut pc: u32 = 0x82E74FF8;
    'dispatch: loop {
        match pc {
            0x82E74FF8 => {
    //   block [0x82E74FF8..0x82E7500C)
	// 82E74FF8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E74FFC: 814BBD24  lwz r10, -0x42dc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17116 as u32) ) } as u64;
	// 82E75000: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E75004: 914BBD24  stw r10, -0x42dc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-17116 as u32), ctx.r[10].u32 ) };
	// 82E75008: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E75010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E75010 size=100
    let mut pc: u32 = 0x82E75010;
    'dispatch: loop {
        match pc {
            0x82E75010 => {
    //   block [0x82E75010..0x82E75074)
	// 82E75010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E75014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E75018: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E7501C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E75020: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E75024: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E75028: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E7502C: 396B8960  addi r11, r11, -0x76a0
	ctx.r[11].s64 = ctx.r[11].s64 + -30368;
	// 82E75030: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E75034: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E75038: 48023919  bl 0x82e98950
	ctx.lr = 0x82E7503C;
	sub_82E98950(ctx, base);
	// 82E7503C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E75040: 41820018  beq 0x82e75058
	if ctx.cr[0].eq {
	pc = 0x82E75058; continue 'dispatch;
	}
	// 82E75044: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E75048: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7504C: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E75050: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E75054: 4E800421  bctrl
	ctx.lr = 0x82E75058;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E75058: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7505C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E75060: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E75064: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E75068: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E7506C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E75070: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E75078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E75078 size=128
    let mut pc: u32 = 0x82E75078;
    'dispatch: loop {
        match pc {
            0x82E75078 => {
    //   block [0x82E75078..0x82E750F8)
	// 82E75078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7507C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E75080: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E75084: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E75088: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E7508C: 48023C45  bl 0x82e98cd0
	ctx.lr = 0x82E75090;
	sub_82E98CD0(ctx, base);
	// 82E75090: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E75094: 3D0082EA  lis r8, -0x7d16
	ctx.r[8].s64 = -2098593792;
	// 82E75098: 394B8960  addi r10, r11, -0x76a0
	ctx.r[10].s64 = ctx.r[11].s64 + -30368;
	// 82E7509C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E750A0: 3D2082EA  lis r9, -0x7d16
	ctx.r[9].s64 = -2098593792;
	// 82E750A4: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 82E750A8: 39089C78  addi r8, r8, -0x6388
	ctx.r[8].s64 = ctx.r[8].s64 + -25480;
	// 82E750AC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E750B0: 39299D98  addi r9, r9, -0x6268
	ctx.r[9].s64 = ctx.r[9].s64 + -25192;
	// 82E750B4: C00B0A54  lfs f0, 0xa54(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E750B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E750BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E750C0: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E750C4: 90FF003C  stw r7, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[7].u32 ) };
	// 82E750C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E750CC: 911F0044  stw r8, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[8].u32 ) };
	// 82E750D0: 913F0048  stw r9, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[9].u32 ) };
	// 82E750D4: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82E750D8: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82E750DC: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E750E0: 995F0054  stb r10, 0x54(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[10].u8 ) };
	// 82E750E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E750E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E750EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E750F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E750F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E750F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E750F8 size=56
    let mut pc: u32 = 0x82E750F8;
    'dispatch: loop {
        match pc {
            0x82E750F8 => {
    //   block [0x82E750F8..0x82E75130)
	// 82E750F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E750FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E75100: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E75104: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82E75108: 4B7A1821  bl 0x82616928
	ctx.lr = 0x82E7510C;
	sub_82616928(ctx, base);
	// 82E7510C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E75110: 4182000C  beq 0x82e7511c
	if ctx.cr[0].eq {
	pc = 0x82E7511C; continue 'dispatch;
	}
	// 82E75114: 4BFFFF65  bl 0x82e75078
	ctx.lr = 0x82E75118;
	sub_82E75078(ctx, base);
	// 82E75118: 48000008  b 0x82e75120
	pc = 0x82E75120; continue 'dispatch;
	// 82E7511C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E75120: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E75124: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E75128: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E7512C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E75130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E75130 size=260
    let mut pc: u32 = 0x82E75130;
    'dispatch: loop {
        match pc {
            0x82E75130 => {
    //   block [0x82E75130..0x82E75234)
	// 82E75130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E75134: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E75138: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E7513C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E75140: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E75144: 48014095  bl 0x82e891d8
	ctx.lr = 0x82E75148;
	sub_82E891D8(ctx, base);
	// 82E75148: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E7514C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75150: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E75154: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82E75158: 394B89D0  addi r10, r11, -0x7630
	ctx.r[10].s64 = ctx.r[11].s64 + -30256;
	// 82E7515C: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82E75160: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E75164: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82E75168: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82E7516C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E75170: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82E75174: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E75178: 394A115C  addi r10, r10, 0x115c
	ctx.r[10].s64 = ctx.r[10].s64 + 4444;
	// 82E7517C: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82E75180: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E75184: D1BF0034  stfs f13, 0x34(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82E75188: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E7518C: D1BF0038  stfs f13, 0x38(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82E75190: C1AA0008  lfs f13, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E75194: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82E75198: D1BF003C  stfs f13, 0x3c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82E7519C: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82E751A0: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82E751A4: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82E751A8: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E751AC: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E751B0: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E751B4: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E751B8: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82E751BC: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82E751C0: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82E751C4: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82E751C8: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82E751CC: 814A0718  lwz r10, 0x718(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E751D0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E751D4: 4182000C  beq 0x82e751e0
	if ctx.cr[0].eq {
	pc = 0x82E751E0; continue 'dispatch;
	}
	// 82E751D8: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E751DC: 4800000C  b 0x82e751e8
	pc = 0x82E751E8; continue 'dispatch;
	// 82E751E0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E751E4: C18A0C14  lfs f12, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E751E8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E751EC: D01F00BC  stfs f0, 0xbc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82E751F0: 917F00B4  stw r11, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 82E751F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E751F8: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82E751FC: C1AA0BFC  lfs f13, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E75200: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82E75204: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E75208: D1BF00AC  stfs f13, 0xac(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82E7520C: 995F00B0  stb r10, 0xb0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[10].u8 ) };
	// 82E75210: 995F00B8  stb r10, 0xb8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[10].u8 ) };
	// 82E75214: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82E75218: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82E7521C: D01F00D0  stfs f0, 0xd0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82E75220: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E75224: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E75228: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E7522C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E75230: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E75238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E75238 size=12
    let mut pc: u32 = 0x82E75238;
    'dispatch: loop {
        match pc {
            0x82E75238 => {
    //   block [0x82E75238..0x82E75244)
	// 82E75238: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7523C: 386BBE3C  addi r3, r11, -0x41c4
	ctx.r[3].s64 = ctx.r[11].s64 + -16836;
	// 82E75240: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E75248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E75248 size=124
    let mut pc: u32 = 0x82E75248;
    'dispatch: loop {
        match pc {
            0x82E75248 => {
    //   block [0x82E75248..0x82E752C4)
	// 82E75248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7524C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E75250: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E75254: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E75258: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E7525C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E75260: 396B89D0  addi r11, r11, -0x7630
	ctx.r[11].s64 = ctx.r[11].s64 + -30256;
	// 82E75264: 807F00C0  lwz r3, 0xc0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82E75268: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7526C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E75270: 41820018  beq 0x82e75288
	if ctx.cr[0].eq {
	pc = 0x82E75288; continue 'dispatch;
	}
	// 82E75274: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E75278: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E7527C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E75280: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E75284: 4E800421  bctrl
	ctx.lr = 0x82E75288;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E75288: 807F00B4  lwz r3, 0xb4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82E7528C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E75290: 41820018  beq 0x82e752a8
	if ctx.cr[0].eq {
	pc = 0x82E752A8; continue 'dispatch;
	}
	// 82E75294: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E75298: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E7529C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E752A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E752A4: 4E800421  bctrl
	ctx.lr = 0x82E752A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E752A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E752AC: 48013F4D  bl 0x82e891f8
	ctx.lr = 0x82E752B0;
	sub_82E891F8(ctx, base);
	// 82E752B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E752B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E752B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E752BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E752C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E752C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E752C8 size=44
    let mut pc: u32 = 0x82E752C8;
    'dispatch: loop {
        match pc {
            0x82E752C8 => {
    //   block [0x82E752C8..0x82E752F4)
	// 82E752C8: 8143005C  lwz r10, 0x5c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E752CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E752D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E752D4: 409A0008  bne cr6, 0x82e752dc
	if !ctx.cr[6].eq {
	pc = 0x82E752DC; continue 'dispatch;
	}
	// 82E752D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E752DC: 81430064  lwz r10, 0x64(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E752E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E752E4: 409A0008  bne cr6, 0x82e752ec
	if !ctx.cr[6].eq {
	pc = 0x82E752EC; continue 'dispatch;
	}
	// 82E752E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E752EC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E752F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E752F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E752F8 size=56
    let mut pc: u32 = 0x82E752F8;
    'dispatch: loop {
        match pc {
            0x82E752F8 => {
    //   block [0x82E752F8..0x82E75330)
	// 82E752F8: 81430074  lwz r10, 0x74(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E752FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E75300: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E75304: 409A0014  bne cr6, 0x82e75318
	if !ctx.cr[6].eq {
	pc = 0x82E75318; continue 'dispatch;
	}
	// 82E75308: 81430078  lwz r10, 0x78(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E7530C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E75310: 409A0008  bne cr6, 0x82e75318
	if !ctx.cr[6].eq {
	pc = 0x82E75318; continue 'dispatch;
	}
	// 82E75314: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E75318: 8143007C  lwz r10, 0x7c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E7531C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E75320: 409A0008  bne cr6, 0x82e75328
	if !ctx.cr[6].eq {
	pc = 0x82E75328; continue 'dispatch;
	}
	// 82E75324: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E75328: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E7532C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E75330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E75330 size=44
    let mut pc: u32 = 0x82E75330;
    'dispatch: loop {
        match pc {
            0x82E75330 => {
    //   block [0x82E75330..0x82E7535C)
	// 82E75330: 8143008C  lwz r10, 0x8c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 82E75334: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E75338: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82E7533C: 409A0008  bne cr6, 0x82e75344
	if !ctx.cr[6].eq {
	pc = 0x82E75344; continue 'dispatch;
	}
	// 82E75340: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E75344: 81430090  lwz r10, 0x90(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 82E75348: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82E7534C: 409A0008  bne cr6, 0x82e75354
	if !ctx.cr[6].eq {
	pc = 0x82E75354; continue 'dispatch;
	}
	// 82E75350: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E75354: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E75358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E75360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E75360 size=208
    let mut pc: u32 = 0x82E75360;
    'dispatch: loop {
        match pc {
            0x82E75360 => {
    //   block [0x82E75360..0x82E75430)
	// 82E75360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E75364: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E75368: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E7536C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E75370: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E75374: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E75378: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E7537C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E75380: C01F003C  lfs f0, 0x3c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75384: C1BF0038  lfs f13, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E75388: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E7538C: C16B0038  lfs f11, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E75390: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E75394: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E75398: C18B0034  lfs f12, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E7539C: C17F0034  lfs f11, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E753A0: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E753A4: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E753A8: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E753AC: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E753B0: 480109B9  bl 0x82e85d68
	ctx.lr = 0x82E753B4;
	sub_82E85D68(ctx, base);
	// 82E753B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E753B8: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E753BC: C1AB0A44  lfs f13, 0xa44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2628 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E753C0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E753C4: 40990014  ble cr6, 0x82e753d8
	if !ctx.cr[6].gt {
	pc = 0x82E753D8; continue 'dispatch;
	}
	// 82E753C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E753CC: C1AB89CC  lfs f13, -0x7634(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E753D0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E753D4: 48000020  b 0x82e753f4
	pc = 0x82E753F4; continue 'dispatch;
	// 82E753D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E753DC: C1AB89C8  lfs f13, -0x7638(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E753E0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E753E4: 40980010  bge cr6, 0x82e753f4
	if !ctx.cr[6].lt {
	pc = 0x82E753F4; continue 'dispatch;
	}
	// 82E753E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E753EC: C1AB89CC  lfs f13, -0x7634(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E753F0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E753F4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E753F8: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82E753FC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E75400: 480108A1  bl 0x82e85ca0
	ctx.lr = 0x82E75404;
	sub_82E85CA0(ctx, base);
	// 82E75404: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75408: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82E7540C: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75410: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82E75414: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75418: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82E7541C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E75420: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E75424: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E75428: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E7542C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E75430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E75430 size=120
    let mut pc: u32 = 0x82E75430;
    'dispatch: loop {
        match pc {
            0x82E75430 => {
    //   block [0x82E75430..0x82E754A8)
	// 82E75430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E75434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E75438: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E7543C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E75440: 81640020  lwz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E75444: C0050008  lfs f0, 8(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75448: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E7544C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E75450: C1850000  lfs f12, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E75454: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E75458: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E7545C: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E75460: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E75464: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E75468: C16B0034  lfs f11, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E7546C: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E75470: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E75474: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E75478: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E7547C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E75480: 480108E9  bl 0x82e85d68
	ctx.lr = 0x82E75484;
	sub_82E85D68(ctx, base);
	// 82E75484: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E75488: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7548C: 48010815  bl 0x82e85ca0
	ctx.lr = 0x82E75490;
	sub_82E85CA0(ctx, base);
	// 82E75490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E75494: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E75498: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E7549C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E754A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E754A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E754A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E754A8 size=68
    let mut pc: u32 = 0x82E754A8;
    'dispatch: loop {
        match pc {
            0x82E754A8 => {
    //   block [0x82E754A8..0x82E754EC)
	// 82E754A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E754AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E754B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E754B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E754B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E754BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E754C0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E754C4: 4B3EB4F5  bl 0x822609b8
	ctx.lr = 0x82E754C8;
	sub_822609B8(ctx, base);
	// 82E754C8: C1A3004C  lfs f13, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E754CC: C01F0098  lfs f0, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E754D0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E754D4: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82E754D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E754DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E754E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E754E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E754E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E754F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E754F0 size=344
    let mut pc: u32 = 0x82E754F0;
    'dispatch: loop {
        match pc {
            0x82E754F0 => {
    //   block [0x82E754F0..0x82E75648)
	// 82E754F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E754F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E754F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E754FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E75500: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82E75504: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82E75508: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7550C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E75510: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E75514: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E75518: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E7551C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E75520: 4E800421  bctrl
	ctx.lr = 0x82E75524;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E75524: 3BDF0040  addi r30, r31, 0x40
	ctx.r[30].s64 = ctx.r[31].s64 + 64;
	// 82E75528: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E7552C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E75530: 48010839  bl 0x82e85d68
	ctx.lr = 0x82E75534;
	sub_82E85D68(ctx, base);
	// 82E75534: 4BE34C9D  bl 0x82caa1d0
	ctx.lr = 0x82E75538;
	sub_82CAA1D0(ctx, base);
	// 82E75538: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E7553C: C01F002C  lfs f0, 0x2c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75540: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82E75544: C3EB0C20  lfs f31, 0xc20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3104 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E75548: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 82E7554C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82E75550: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E75554: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82E75558: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E7555C: C3CB0C4C  lfs f30, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E75560: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82E75564: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E75568: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E7556C: EC006FF8  fmsubs f0, f0, f31, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E75570: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E75574: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E75578: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E7557C: 4BE34C55  bl 0x82caa1d0
	ctx.lr = 0x82E75580;
	sub_82CAA1D0(ctx, base);
	// 82E75580: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 82E75584: C01F002C  lfs f0, 0x2c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75588: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E7558C: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82E75590: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E75594: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82E75598: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E7559C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82E755A0: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82E755A4: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E755A8: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E755AC: EC006FF8  fmsubs f0, f0, f31, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E755B0: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E755B4: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E755B8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E755BC: 480106E5  bl 0x82e85ca0
	ctx.lr = 0x82E755C0;
	sub_82E85CA0(ctx, base);
	// 82E755C0: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E755C4: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E755C8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82E755CC: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E755D0: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E755D4: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E755D8: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E755DC: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E755E0: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E755E4: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E755E8: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E755EC: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E755F0: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E755F4: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E755F8: 992B0004  stb r9, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u8 ) };
	// 82E755FC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E75600: 815F007C  lwz r10, 0x7c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E75604: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75608: D00A0014  stfs f0, 0x14(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E7560C: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75610: D00A0018  stfs f0, 0x18(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E75614: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75618: D00A001C  stfs f0, 0x1c(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82E7561C: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E75620: 992B0020  stb r9, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u8 ) };
	// 82E75624: 992B0004  stb r9, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u8 ) };
	// 82E75628: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E7562C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E75630: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E75634: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82E75638: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82E7563C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E75640: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E75644: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E75648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E75648 size=124
    let mut pc: u32 = 0x82E75648;
    'dispatch: loop {
        match pc {
            0x82E75648 => {
    //   block [0x82E75648..0x82E756C4)
	// 82E75648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7564C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E75650: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E75654: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82E75658: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7565C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E75660: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E75664: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E75668: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7566C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82E75670: 4099003C  ble cr6, 0x82e756ac
	if !ctx.cr[6].gt {
	pc = 0x82E756AC; continue 'dispatch;
	}
	// 82E75674: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E75678: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7567C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E75680: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82E75684: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E75688: 4B372FF1  bl 0x821e8678
	ctx.lr = 0x82E7568C;
	sub_821E8678(ctx, base);
	// 82E7568C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E75690: 41820018  beq 0x82e756a8
	if ctx.cr[0].eq {
	pc = 0x82E756A8; continue 'dispatch;
	}
	// 82E75694: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75698: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82E7569C: 4099000C  ble cr6, 0x82e756a8
	if !ctx.cr[6].gt {
	pc = 0x82E756A8; continue 'dispatch;
	}
	// 82E756A0: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E756A4: 48000008  b 0x82e756ac
	pc = 0x82E756AC; continue 'dispatch;
	// 82E756A8: D3FF0014  stfs f31, 0x14(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E756AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E756B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E756B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E756B8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E756BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E756C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E756C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E756C8 size=52
    let mut pc: u32 = 0x82E756C8;
    'dispatch: loop {
        match pc {
            0x82E756C8 => {
    //   block [0x82E756C8..0x82E756FC)
	// 82E756C8: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E756CC: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E756D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E756D4: 40820028  bne 0x82e756fc
	if !ctx.cr[0].eq {
		sub_82E756FC(ctx, base);
		return;
	}
	// 82E756D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E756DC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82E756E0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E756E4: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82E756E8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E756EC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E756F0: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E756F4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82E756F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E756FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E756FC size=96
    let mut pc: u32 = 0x82E756FC;
    'dispatch: loop {
        match pc {
            0x82E756FC => {
    //   block [0x82E756FC..0x82E7575C)
	// 82E756FC: 81240014  lwz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E75700: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82E75704: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E75708: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E7570C: 91240014  stw r9, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82E75710: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E75714: 91240010  stw r9, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82E75718: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E7571C: 990B0010  stb r8, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[8].u8 ) };
	// 82E75720: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82E75724: 409A0054  bne cr6, 0x82e75778
	if !ctx.cr[6].eq {
		sub_82E75778(ctx, base);
		return;
	}
	// 82E75728: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E7572C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E75730: 4082002C  bne 0x82e7575c
	if !ctx.cr[0].eq {
		sub_82E7575C(ctx, base);
		return;
	}
	// 82E75734: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E75738: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E7573C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82E75740: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E75744: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E75748: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E7574C: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E75750: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E75754: 9149000C  stw r10, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82E75758: 48000044  b 0x82e7579c
	sub_82E75798(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E7575C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E7575C size=28
    let mut pc: u32 = 0x82E7575C;
    'dispatch: loop {
        match pc {
            0x82E7575C => {
    //   block [0x82E7575C..0x82E75778)
	// 82E7575C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E75760: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E75764: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82E75768: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E7576C: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E75770: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E75774: 48000028  b 0x82e7579c
	sub_82E75798(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E75778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E75778 size=32
    let mut pc: u32 = 0x82E75778;
    'dispatch: loop {
        match pc {
            0x82E75778 => {
    //   block [0x82E75778..0x82E75798)
	// 82E75778: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E7577C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82E75780: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E75784: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E75788: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82E7578C: 4182000C  beq 0x82e75798
	if ctx.cr[0].eq {
		sub_82E75798(ctx, base);
		return;
	}
	// 82E75790: 9169000C  stw r11, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E75794: 48000008  b 0x82e7579c
	sub_82E75798(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E75798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E75798 size=36
    let mut pc: u32 = 0x82E75798;
    'dispatch: loop {
        match pc {
            0x82E75798 => {
    //   block [0x82E75798..0x82E757BC)
	// 82E75798: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E7579C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82E757A0: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E757A4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82E757A8: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82E757AC: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 82E757B0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E757B4: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E757B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E757C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E757C0 size=72
    let mut pc: u32 = 0x82E757C0;
    'dispatch: loop {
        match pc {
            0x82E757C0 => {
    //   block [0x82E757C0..0x82E75808)
	// 82E757C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E757C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E757C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E757CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E757D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E757D4: 386000D8  li r3, 0xd8
	ctx.r[3].s64 = 216;
	// 82E757D8: 4B7A1151  bl 0x82616928
	ctx.lr = 0x82E757DC;
	sub_82616928(ctx, base);
	// 82E757DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E757E0: 41820010  beq 0x82e757f0
	if ctx.cr[0].eq {
	pc = 0x82E757F0; continue 'dispatch;
	}
	// 82E757E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E757E8: 4BFFF949  bl 0x82e75130
	ctx.lr = 0x82E757EC;
	sub_82E75130(ctx, base);
	// 82E757EC: 48000008  b 0x82e757f4
	pc = 0x82E757F4; continue 'dispatch;
	// 82E757F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E757F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E757F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E757FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E75800: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E75804: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E75808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E75808 size=88
    let mut pc: u32 = 0x82E75808;
    'dispatch: loop {
        match pc {
            0x82E75808 => {
    //   block [0x82E75808..0x82E75860)
	// 82E75808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7580C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E75810: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E75814: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E75818: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7581C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E75820: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E75824: 4BFFFA25  bl 0x82e75248
	ctx.lr = 0x82E75828;
	sub_82E75248(ctx, base);
	// 82E75828: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E7582C: 41820018  beq 0x82e75844
	if ctx.cr[0].eq {
	pc = 0x82E75844; continue 'dispatch;
	}
	// 82E75830: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E75834: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E75838: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E7583C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E75840: 4E800421  bctrl
	ctx.lr = 0x82E75844;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E75844: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E75848: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E7584C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E75850: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E75854: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E75858: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E7585C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E75860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E75860 size=840
    let mut pc: u32 = 0x82E75860;
    'dispatch: loop {
        match pc {
            0x82E75860 => {
    //   block [0x82E75860..0x82E75BA8)
	// 82E75860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E75864: 4BE33BA9  bl 0x82ca940c
	ctx.lr = 0x82E75868;
	sub_82CA93D0(ctx, base);
	// 82E75868: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82E7586C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E75870: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E75874: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E75878: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E7587C: 409A000C  bne cr6, 0x82e75888
	if !ctx.cr[6].eq {
	pc = 0x82E75888; continue 'dispatch;
	}
	// 82E75880: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E75884: 48000318  b 0x82e75b9c
	pc = 0x82E75B9C; continue 'dispatch;
	// 82E75888: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E7588C: 483467D5  bl 0x831bc060
	ctx.lr = 0x82E75890;
	sub_831BC060(ctx, base);
	// 82E75890: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E75894: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E75898: 388B8AA8  addi r4, r11, -0x7558
	ctx.r[4].s64 = ctx.r[11].s64 + -30040;
	// 82E7589C: 4BE372B5  bl 0x82cacb50
	ctx.lr = 0x82E758A0;
	sub_82CACB50(ctx, base);
	// 82E758A0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E758A4: 40820028  bne 0x82e758cc
	if !ctx.cr[0].eq {
	pc = 0x82E758CC; continue 'dispatch;
	}
	// 82E758A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E758AC: 4BA9845D  bl 0x8290dd08
	ctx.lr = 0x82E758B0;
	sub_8290DD08(ctx, base);
	// 82E758B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E758B4: 418202DC  beq 0x82e75b90
	if ctx.cr[0].eq {
	pc = 0x82E75B90; continue 'dispatch;
	}
	// 82E758B8: 4BE362F9  bl 0x82cabbb0
	ctx.lr = 0x82E758BC;
	sub_82CABBB0(ctx, base);
	// 82E758BC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E758C0: D01D0028  stfs f0, 0x28(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82E758C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E758C8: 480002D4  b 0x82e75b9c
	pc = 0x82E75B9C; continue 'dispatch;
	// 82E758CC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82E758D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E758D4: 388B4F80  addi r4, r11, 0x4f80
	ctx.r[4].s64 = ctx.r[11].s64 + 20352;
	// 82E758D8: 4BE37279  bl 0x82cacb50
	ctx.lr = 0x82E758DC;
	sub_82CACB50(ctx, base);
	// 82E758DC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E758E0: 40820034  bne 0x82e75914
	if !ctx.cr[0].eq {
	pc = 0x82E75914; continue 'dispatch;
	}
	// 82E758E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E758E8: 4BA98421  bl 0x8290dd08
	ctx.lr = 0x82E758EC;
	sub_8290DD08(ctx, base);
	// 82E758EC: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82E758F0: 418202A0  beq 0x82e75b90
	if ctx.cr[0].eq {
	pc = 0x82E75B90; continue 'dispatch;
	}
	// 82E758F4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E758F8: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E758FC: 4800DF0D  bl 0x82e83808
	ctx.lr = 0x82E75900;
	sub_82E83808(ctx, base);
	// 82E75900: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82E75904: 907D0020  stw r3, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 82E75908: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82E7590C: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82E75910: 4800028C  b 0x82e75b9c
	pc = 0x82E75B9C; continue 'dispatch;
	// 82E75914: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E75918: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7591C: 388B8A9C  addi r4, r11, -0x7564
	ctx.r[4].s64 = ctx.r[11].s64 + -30052;
	// 82E75920: 4BE37231  bl 0x82cacb50
	ctx.lr = 0x82E75924;
	sub_82CACB50(ctx, base);
	// 82E75924: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E75928: 4082004C  bne 0x82e75974
	if !ctx.cr[0].eq {
	pc = 0x82E75974; continue 'dispatch;
	}
	// 82E7592C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E75930: 4BA983D9  bl 0x8290dd08
	ctx.lr = 0x82E75934;
	sub_8290DD08(ctx, base);
	// 82E75934: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E75938: 41820258  beq 0x82e75b90
	if ctx.cr[0].eq {
	pc = 0x82E75B90; continue 'dispatch;
	}
	// 82E7593C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E75940: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E75944: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E75948: 4182000C  beq 0x82e75954
	if ctx.cr[0].eq {
	pc = 0x82E75954; continue 'dispatch;
	}
	// 82E7594C: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E75950: 4800000C  b 0x82e7595c
	pc = 0x82E7595C; continue 'dispatch;
	// 82E75954: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E75958: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E7595C: 4BE36255  bl 0x82cabbb0
	ctx.lr = 0x82E75960;
	sub_82CABBB0(ctx, base);
	// 82E75960: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E75964: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E75968: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E7596C: D01D0024  stfs f0, 0x24(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82E75970: 4800022C  b 0x82e75b9c
	pc = 0x82E75B9C; continue 'dispatch;
	// 82E75974: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E75978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7597C: 388B8A8C  addi r4, r11, -0x7574
	ctx.r[4].s64 = ctx.r[11].s64 + -30068;
	// 82E75980: 4BE371D1  bl 0x82cacb50
	ctx.lr = 0x82E75984;
	sub_82CACB50(ctx, base);
	// 82E75984: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E75988: 40820028  bne 0x82e759b0
	if !ctx.cr[0].eq {
	pc = 0x82E759B0; continue 'dispatch;
	}
	// 82E7598C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E75990: 4BA98379  bl 0x8290dd08
	ctx.lr = 0x82E75994;
	sub_8290DD08(ctx, base);
	// 82E75994: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E75998: 418201F8  beq 0x82e75b90
	if ctx.cr[0].eq {
	pc = 0x82E75B90; continue 'dispatch;
	}
	// 82E7599C: 4BE36215  bl 0x82cabbb0
	ctx.lr = 0x82E759A0;
	sub_82CABBB0(ctx, base);
	// 82E759A0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E759A4: D01D002C  stfs f0, 0x2c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82E759A8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E759AC: 480001F0  b 0x82e75b9c
	pc = 0x82E75B9C; continue 'dispatch;
	// 82E759B0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E759B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E759B8: 388B8A74  addi r4, r11, -0x758c
	ctx.r[4].s64 = ctx.r[11].s64 + -30092;
	// 82E759BC: 4BE37195  bl 0x82cacb50
	ctx.lr = 0x82E759C0;
	sub_82CACB50(ctx, base);
	// 82E759C0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E759C4: 40820028  bne 0x82e759ec
	if !ctx.cr[0].eq {
	pc = 0x82E759EC; continue 'dispatch;
	}
	// 82E759C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E759CC: 4BA9833D  bl 0x8290dd08
	ctx.lr = 0x82E759D0;
	sub_8290DD08(ctx, base);
	// 82E759D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E759D4: 418201BC  beq 0x82e75b90
	if ctx.cr[0].eq {
	pc = 0x82E75B90; continue 'dispatch;
	}
	// 82E759D8: 4BE361D9  bl 0x82cabbb0
	ctx.lr = 0x82E759DC;
	sub_82CABBB0(ctx, base);
	// 82E759DC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E759E0: D01D0094  stfs f0, 0x94(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82E759E4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E759E8: 480001B4  b 0x82e75b9c
	pc = 0x82E75B9C; continue 'dispatch;
	// 82E759EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E759F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E759F4: 388B8A64  addi r4, r11, -0x759c
	ctx.r[4].s64 = ctx.r[11].s64 + -30108;
	// 82E759F8: 4BE37159  bl 0x82cacb50
	ctx.lr = 0x82E759FC;
	sub_82CACB50(ctx, base);
	// 82E759FC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E75A00: 4082004C  bne 0x82e75a4c
	if !ctx.cr[0].eq {
	pc = 0x82E75A4C; continue 'dispatch;
	}
	// 82E75A04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E75A08: 4BA98301  bl 0x8290dd08
	ctx.lr = 0x82E75A0C;
	sub_8290DD08(ctx, base);
	// 82E75A0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E75A10: 41820180  beq 0x82e75b90
	if ctx.cr[0].eq {
	pc = 0x82E75B90; continue 'dispatch;
	}
	// 82E75A14: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E75A18: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E75A1C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E75A20: 4182000C  beq 0x82e75a2c
	if ctx.cr[0].eq {
	pc = 0x82E75A2C; continue 'dispatch;
	}
	// 82E75A24: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E75A28: 4800000C  b 0x82e75a34
	pc = 0x82E75A34; continue 'dispatch;
	// 82E75A2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E75A30: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E75A34: 4BE3617D  bl 0x82cabbb0
	ctx.lr = 0x82E75A38;
	sub_82CABBB0(ctx, base);
	// 82E75A38: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E75A3C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E75A40: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E75A44: D01D00BC  stfs f0, 0xbc(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82E75A48: 48000154  b 0x82e75b9c
	pc = 0x82E75B9C; continue 'dispatch;
	// 82E75A4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E75A50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E75A54: 388B8A50  addi r4, r11, -0x75b0
	ctx.r[4].s64 = ctx.r[11].s64 + -30128;
	// 82E75A58: 4BE370F9  bl 0x82cacb50
	ctx.lr = 0x82E75A5C;
	sub_82CACB50(ctx, base);
	// 82E75A5C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E75A60: 40820028  bne 0x82e75a88
	if !ctx.cr[0].eq {
	pc = 0x82E75A88; continue 'dispatch;
	}
	// 82E75A64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E75A68: 4BA982A1  bl 0x8290dd08
	ctx.lr = 0x82E75A6C;
	sub_8290DD08(ctx, base);
	// 82E75A6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E75A70: 41820120  beq 0x82e75b90
	if ctx.cr[0].eq {
	pc = 0x82E75B90; continue 'dispatch;
	}
	// 82E75A74: 4BE3494D  bl 0x82caa3c0
	ctx.lr = 0x82E75A78;
	sub_82CAA3C0(ctx, base);
	// 82E75A78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E75A7C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E75A80: 997D00B8  stb r11, 0xb8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(184 as u32), ctx.r[11].u8 ) };
	// 82E75A84: 48000118  b 0x82e75b9c
	pc = 0x82E75B9C; continue 'dispatch;
	// 82E75A88: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E75A8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E75A90: 388B8A3C  addi r4, r11, -0x75c4
	ctx.r[4].s64 = ctx.r[11].s64 + -30148;
	// 82E75A94: 4BE370BD  bl 0x82cacb50
	ctx.lr = 0x82E75A98;
	sub_82CACB50(ctx, base);
	// 82E75A98: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E75A9C: 40820028  bne 0x82e75ac4
	if !ctx.cr[0].eq {
	pc = 0x82E75AC4; continue 'dispatch;
	}
	// 82E75AA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E75AA4: 4BA98265  bl 0x8290dd08
	ctx.lr = 0x82E75AA8;
	sub_8290DD08(ctx, base);
	// 82E75AA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E75AAC: 418200E4  beq 0x82e75b90
	if ctx.cr[0].eq {
	pc = 0x82E75B90; continue 'dispatch;
	}
	// 82E75AB0: 4BE34911  bl 0x82caa3c0
	ctx.lr = 0x82E75AB4;
	sub_82CAA3C0(ctx, base);
	// 82E75AB4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E75AB8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E75ABC: 997D00B0  stb r11, 0xb0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(176 as u32), ctx.r[11].u8 ) };
	// 82E75AC0: 480000DC  b 0x82e75b9c
	pc = 0x82E75B9C; continue 'dispatch;
	// 82E75AC4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82E75AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E75ACC: 388B293C  addi r4, r11, 0x293c
	ctx.r[4].s64 = ctx.r[11].s64 + 10556;
	// 82E75AD0: 4BE37081  bl 0x82cacb50
	ctx.lr = 0x82E75AD4;
	sub_82CACB50(ctx, base);
	// 82E75AD4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E75AD8: 40820050  bne 0x82e75b28
	if !ctx.cr[0].eq {
	pc = 0x82E75B28; continue 'dispatch;
	}
	// 82E75ADC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E75AE0: 4BA98229  bl 0x8290dd08
	ctx.lr = 0x82E75AE4;
	sub_8290DD08(ctx, base);
	// 82E75AE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E75AE8: 41820038  beq 0x82e75b20
	if ctx.cr[0].eq {
	pc = 0x82E75B20; continue 'dispatch;
	}
	// 82E75AEC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E75AF0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E75AF4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E75AF8: 4182000C  beq 0x82e75b04
	if ctx.cr[0].eq {
	pc = 0x82E75B04; continue 'dispatch;
	}
	// 82E75AFC: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E75B00: 4800000C  b 0x82e75b0c
	pc = 0x82E75B0C; continue 'dispatch;
	// 82E75B04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E75B08: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E75B0C: 4BE360A5  bl 0x82cabbb0
	ctx.lr = 0x82E75B10;
	sub_82CABBB0(ctx, base);
	// 82E75B10: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E75B14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E75B18: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E75B1C: 4BFFFB2D  bl 0x82e75648
	ctx.lr = 0x82E75B20;
	sub_82E75648(ctx, base);
	// 82E75B20: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E75B24: 48000078  b 0x82e75b9c
	pc = 0x82E75B9C; continue 'dispatch;
	// 82E75B28: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E75B2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E75B30: 388B8A1C  addi r4, r11, -0x75e4
	ctx.r[4].s64 = ctx.r[11].s64 + -30180;
	// 82E75B34: 4BE3701D  bl 0x82cacb50
	ctx.lr = 0x82E75B38;
	sub_82CACB50(ctx, base);
	// 82E75B38: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E75B3C: 40820054  bne 0x82e75b90
	if !ctx.cr[0].eq {
	pc = 0x82E75B90; continue 'dispatch;
	}
	// 82E75B40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E75B44: 4BA981C5  bl 0x8290dd08
	ctx.lr = 0x82E75B48;
	sub_8290DD08(ctx, base);
	// 82E75B48: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E75B4C: 4182FFD4  beq 0x82e75b20
	if ctx.cr[0].eq {
	pc = 0x82E75B20; continue 'dispatch;
	}
	// 82E75B50: 4BE36061  bl 0x82cabbb0
	ctx.lr = 0x82E75B54;
	sub_82CABBB0(ctx, base);
	// 82E75B54: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E75B58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E75B5C: C1BD0018  lfs f13, 0x18(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E75B60: FC000818  frsp f0, f1
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E75B64: C16A0C18  lfs f11, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E75B68: C18B0C14  lfs f12, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E75B6C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82E75B70: 41980010  blt cr6, 0x82e75b80
	if ctx.cr[6].lt {
	pc = 0x82E75B80; continue 'dispatch;
	}
	// 82E75B74: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82E75B78: 41990008  bgt cr6, 0x82e75b80
	if ctx.cr[6].gt {
	pc = 0x82E75B80; continue 'dispatch;
	}
	// 82E75B7C: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82E75B80: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82E75B84: 409AFFE8  bne cr6, 0x82e75b6c
	if !ctx.cr[6].eq {
	pc = 0x82E75B6C; continue 'dispatch;
	}
	// 82E75B88: D1BD0018  stfs f13, 0x18(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E75B8C: 4BFFFF94  b 0x82e75b20
	pc = 0x82E75B20; continue 'dispatch;
	// 82E75B90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E75B94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E75B98: 4BFFA301  bl 0x82e6fe98
	ctx.lr = 0x82E75B9C;
	sub_82E6FE98(ctx, base);
	// 82E75B9C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E75BA0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82E75BA4: 4BE338B8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E75BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E75BA8 size=140
    let mut pc: u32 = 0x82E75BA8;
    'dispatch: loop {
        match pc {
            0x82E75BA8 => {
    //   block [0x82E75BA8..0x82E75C34)
	// 82E75BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E75BAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E75BB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E75BB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E75BB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E75BBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E75BC0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E75BC4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82E75BC8: 4B3EADF1  bl 0x822609b8
	ctx.lr = 0x82E75BCC;
	sub_822609B8(ctx, base);
	// 82E75BCC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E75BD0: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E75BD4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E75BD8: C1BF0098  lfs f13, 0x98(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E75BDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E75BE0: C18B004C  lfs f12, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E75BE4: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82E75BE8: C00A0C18  lfs f0, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75BEC: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E75BF0: 81490034  lwz r10, 0x34(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E75BF4: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82E75BF8: D1BF00A4  stfs f13, 0xa4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82E75BFC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E75C00: 4E800421  bctrl
	ctx.lr = 0x82E75C04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E75C04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E75C08: 9BDF00C4  stb r30, 0xc4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[30].u8 ) };
	// 82E75C0C: C00B0EE0  lfs f0, 0xee0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75C10: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82E75C14: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82E75C18: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82E75C1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E75C20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E75C24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E75C28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E75C2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E75C30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E75C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E75C38 size=12
    let mut pc: u32 = 0x82E75C38;
    'dispatch: loop {
        match pc {
            0x82E75C38 => {
    //   block [0x82E75C38..0x82E75C44)
	// 82E75C38: 816300B4  lwz r11, 0xb4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(180 as u32) ) } as u64;
	// 82E75C3C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E75C40: 48000028  b 0x82e75c68
	sub_82E75C44(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E75C44(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E75C44 size=64
    let mut pc: u32 = 0x82E75C44;
    'dispatch: loop {
        match pc {
            0x82E75C44 => {
    //   block [0x82E75C44..0x82E75C84)
	// 82E75C44: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E75C48: 99490010  stb r10, 0x10(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[10].u8 ) };
	// 82E75C4C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E75C50: 80EB0010  lwz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E75C54: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E75C58: 90E9000C  stw r7, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82E75C5C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E75C60: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82E75C64: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82E75C68: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E75C6C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E75C70: 409AFFD4  bne cr6, 0x82e75c44
	if !ctx.cr[6].eq {
	pc = 0x82E75C44; continue 'dispatch;
	}
	// 82E75C74: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82E75C78: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82E75C7C: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82E75C80: 48000028  b 0x82e75ca8
	sub_82E75C84(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E75C84(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E75C84 size=64
    let mut pc: u32 = 0x82E75C84;
    'dispatch: loop {
        match pc {
            0x82E75C84 => {
    //   block [0x82E75C84..0x82E75CC4)
	// 82E75C84: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E75C88: 99490018  stb r10, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 82E75C8C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E75C90: 80EB0010  lwz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E75C94: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E75C98: 90E90014  stw r7, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 82E75C9C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E75CA0: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82E75CA4: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82E75CA8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E75CAC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E75CB0: 409AFFD4  bne cr6, 0x82e75c84
	if !ctx.cr[6].eq {
	pc = 0x82E75C84; continue 'dispatch;
	}
	// 82E75CB4: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82E75CB8: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82E75CBC: 994300C4  stb r10, 0xc4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), ctx.r[10].u8 ) };
	// 82E75CC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E75CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E75CC8 size=548
    let mut pc: u32 = 0x82E75CC8;
    'dispatch: loop {
        match pc {
            0x82E75CC8 => {
    //   block [0x82E75CC8..0x82E75EEC)
	// 82E75CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E75CCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E75CD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E75CD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E75CD8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82E75CDC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E75CE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E75CE4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E75CE8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82E75CEC: 419A0068  beq cr6, 0x82e75d54
	if ctx.cr[6].eq {
	pc = 0x82E75D54; continue 'dispatch;
	}
	// 82E75CF0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82E75CF4: 419A0060  beq cr6, 0x82e75d54
	if ctx.cr[6].eq {
	pc = 0x82E75D54; continue 'dispatch;
	}
	// 82E75CF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E75CFC: 409A01D4  bne cr6, 0x82e75ed0
	if !ctx.cr[6].eq {
	pc = 0x82E75ED0; continue 'dispatch;
	}
	// 82E75D00: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E75D04: C01F0040  lfs f0, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75D08: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82E75D0C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E75D10: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E75D14: C01F0044  lfs f0, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75D18: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E75D1C: C01F0048  lfs f0, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75D20: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E75D24: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82E75D28: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E75D2C: 815F007C  lwz r10, 0x7c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E75D30: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75D34: D00A0014  stfs f0, 0x14(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E75D38: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75D3C: D00A0018  stfs f0, 0x18(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E75D40: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75D44: D00A001C  stfs f0, 0x1c(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82E75D48: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E75D4C: 992B0020  stb r9, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u8 ) };
	// 82E75D50: 480000C8  b 0x82e75e18
	pc = 0x82E75E18; continue 'dispatch;
	// 82E75D54: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E75D58: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82E75D5C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E75D60: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E75D64: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75D68: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E75D6C: C16B0034  lfs f11, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E75D70: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E75D74: C1AA003C  lfs f13, 0x3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E75D78: 396B115C  addi r11, r11, 0x115c
	ctx.r[11].s64 = ctx.r[11].s64 + 4444;
	// 82E75D7C: C14A0038  lfs f10, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E75D80: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E75D84: EC0C5028  fsubs f0, f12, f10
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E75D88: C18A0034  lfs f12, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E75D8C: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E75D90: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E75D94: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E75D98: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E75D9C: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E75DA0: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 82E75DA4: 409A0020  bne cr6, 0x82e75dc4
	if !ctx.cr[6].eq {
	pc = 0x82E75DC4; continue 'dispatch;
	}
	// 82E75DA8: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E75DAC: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82E75DB0: 409A0014  bne cr6, 0x82e75dc4
	if !ctx.cr[6].eq {
	pc = 0x82E75DC4; continue 'dispatch;
	}
	// 82E75DB4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75DB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E75DBC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E75DC0: 419A0008  beq cr6, 0x82e75dc8
	if ctx.cr[6].eq {
	pc = 0x82E75DC8; continue 'dispatch;
	}
	// 82E75DC4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82E75DC8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E75DCC: 41820104  beq 0x82e75ed0
	if ctx.cr[0].eq {
	pc = 0x82E75ED0; continue 'dispatch;
	}
	// 82E75DD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E75DD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E75DD8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E75DDC: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E75DE0: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E75DE4: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E75DE8: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E75DEC: 4B4092BD  bl 0x8227f0a8
	ctx.lr = 0x82E75DF0;
	sub_8227F0A8(ctx, base);
	// 82E75DF0: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82E75DF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E75DF8: 419A0028  beq cr6, 0x82e75e20
	if ctx.cr[6].eq {
	pc = 0x82E75E20; continue 'dispatch;
	}
	// 82E75DFC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E75E00: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75E04: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E75E08: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82E75E0C: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82E75E10: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75E14: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E75E18: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82E75E1C: 480000B4  b 0x82e75ed0
	pc = 0x82E75ED0; continue 'dispatch;
	// 82E75E20: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E75E24: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E75E28: 40820010  bne 0x82e75e38
	if !ctx.cr[0].eq {
	pc = 0x82E75E38; continue 'dispatch;
	}
	// 82E75E2C: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E75E30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E75E34: 419A009C  beq cr6, 0x82e75ed0
	if ctx.cr[6].eq {
	pc = 0x82E75ED0; continue 'dispatch;
	}
	// 82E75E38: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E75E3C: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82E75E40: 409A0090  bne cr6, 0x82e75ed0
	if !ctx.cr[6].eq {
	pc = 0x82E75ED0; continue 'dispatch;
	}
	// 82E75E44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E75E48: 419A001C  beq cr6, 0x82e75e64
	if ctx.cr[6].eq {
	pc = 0x82E75E64; continue 'dispatch;
	}
	// 82E75E4C: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82E75E50: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75E54: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E75E58: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82E75E5C: 388AC7F0  addi r4, r10, -0x3810
	ctx.r[4].s64 = ctx.r[10].s64 + -14352;
	// 82E75E60: 4800005C  b 0x82e75ebc
	pc = 0x82E75EBC; continue 'dispatch;
	// 82E75E64: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82E75E68: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E75E6C: C00B15E4  lfs f0, 0x15e4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5604 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75E70: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E75E74: 40980018  bge cr6, 0x82e75e8c
	if !ctx.cr[6].lt {
	pc = 0x82E75E8C; continue 'dispatch;
	}
	// 82E75E78: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E75E7C: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E75E80: C00A0EE0  lfs f0, 0xee0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75E84: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E75E88: 48000028  b 0x82e75eb0
	pc = 0x82E75EB0; continue 'dispatch;
	// 82E75E8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E75E90: C00BBDF4  lfs f0, -0x420c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75E94: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E75E98: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E75E9C: 40990010  ble cr6, 0x82e75eac
	if !ctx.cr[6].gt {
	pc = 0x82E75EAC; continue 'dispatch;
	}
	// 82E75EA0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E75EA4: C00A0C14  lfs f0, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75EA8: 4BFFFFDC  b 0x82e75e84
	pc = 0x82E75E84; continue 'dispatch;
	// 82E75EAC: D3EB0008  stfs f31, 8(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E75EB0: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82E75EB4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E75EB8: 388BC7F0  addi r4, r11, -0x3810
	ctx.r[4].s64 = ctx.r[11].s64 + -14352;
	// 82E75EBC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E75EC0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E75EC4: 480077FD  bl 0x82e7d6c0
	ctx.lr = 0x82E75EC8;
	sub_82E7D6C0(ctx, base);
	// 82E75EC8: 9BC30004  stb r30, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82E75ECC: D3E30008  stfs f31, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E75ED0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E75ED4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E75ED8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E75EDC: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82E75EE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E75EE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E75EE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E75EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E75EF0 size=336
    let mut pc: u32 = 0x82E75EF0;
    'dispatch: loop {
        match pc {
            0x82E75EF0 => {
    //   block [0x82E75EF0..0x82E76040)
	// 82E75EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E75EF4: 4BE33519  bl 0x82ca940c
	ctx.lr = 0x82E75EF8;
	sub_82CA93D0(ctx, base);
	// 82E75EF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E75EFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E75F00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E75F04: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E75F08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E75F0C: 396BA2F0  addi r11, r11, -0x5d10
	ctx.r[11].s64 = ctx.r[11].s64 + -23824;
	// 82E75F10: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E75F14: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82E75F18: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82E75F1C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E75F20: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82E75F24: 93BF0010  stw r29, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82E75F28: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82E75F2C: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82E75F30: 419A0104  beq cr6, 0x82e76034
	if ctx.cr[6].eq {
	pc = 0x82E76034; continue 'dispatch;
	}
	// 82E75F34: 3D600924  lis r11, 0x924
	ctx.r[11].s64 = 153354240;
	// 82E75F38: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82E75F3C: 616B9249  ori r11, r11, 0x9249
	ctx.r[11].u64 = ctx.r[11].u64 | 37449;
	// 82E75F40: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E75F44: 1D7E001C  mulli r11, r30, 0x1c
	ctx.r[11].s64 = ctx.r[30].s64 * 28;
	// 82E75F48: 40990008  ble cr6, 0x82e75f50
	if !ctx.cr[6].gt {
	pc = 0x82E75F50; continue 'dispatch;
	}
	// 82E75F4C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E75F50: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82E75F54: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E75F58: 41990008  bgt cr6, 0x82e75f60
	if ctx.cr[6].gt {
	pc = 0x82E75F60; continue 'dispatch;
	}
	// 82E75F5C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82E75F60: 4B7A09C9  bl 0x82616928
	ctx.lr = 0x82E75F64;
	sub_82616928(ctx, base);
	// 82E75F64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E75F68: 41820060  beq 0x82e75fc8
	if ctx.cr[0].eq {
	pc = 0x82E75FC8; continue 'dispatch;
	}
	// 82E75F6C: 38C30004  addi r6, r3, 4
	ctx.r[6].s64 = ctx.r[3].s64 + 4;
	// 82E75F70: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82E75F74: 355EFFFF  addic. r10, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E75F78: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 82E75F7C: 41800044  blt 0x82e75fc0
	if ctx.cr[0].lt {
	pc = 0x82E75FC0; continue 'dispatch;
	}
	// 82E75F80: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82E75F84: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82E75F88: 3969000C  addi r11, r9, 0xc
	ctx.r[11].s64 = ctx.r[9].s64 + 12;
	// 82E75F8C: 39088A18  addi r8, r8, -0x75e8
	ctx.r[8].s64 = ctx.r[8].s64 + -30184;
	// 82E75F90: C0070C18  lfs f0, 0xc18(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E75F94: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82E75F98: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82E75F9C: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82E75FA0: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E75FA4: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E75FA8: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82E75FAC: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82E75FB0: 3929001C  addi r9, r9, 0x1c
	ctx.r[9].s64 = ctx.r[9].s64 + 28;
	// 82E75FB4: 9BAB000C  stb r29, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82E75FB8: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 82E75FBC: 4080FFD8  bge 0x82e75f94
	if !ctx.cr[0].lt {
	pc = 0x82E75F94; continue 'dispatch;
	}
	// 82E75FC0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82E75FC4: 48000008  b 0x82e75fcc
	pc = 0x82E75FCC; continue 'dispatch;
	// 82E75FC8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82E75FCC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E75FD0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E75FD4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E75FD8: 93AB0010  stw r29, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82E75FDC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E75FE0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E75FE4: 4099003C  ble cr6, 0x82e76020
	if !ctx.cr[6].gt {
	pc = 0x82E76020; continue 'dispatch;
	}
	// 82E75FE8: 3960001C  li r11, 0x1c
	ctx.r[11].s64 = 28;
	// 82E75FEC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E75FF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E75FF4: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82E75FF8: 3909FFE4  addi r8, r9, -0x1c
	ctx.r[8].s64 = ctx.r[9].s64 + -28;
	// 82E75FFC: 91090010  stw r8, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82E76000: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E76004: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82E76008: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 82E7600C: 81090010  lwz r8, 0x10(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E76010: 91280014  stw r9, 0x14(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82E76014: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E76018: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E7601C: 4198FFD0  blt cr6, 0x82e75fec
	if ctx.cr[6].lt {
	pc = 0x82E75FEC; continue 'dispatch;
	}
	// 82E76020: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E76024: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E76028: 1D6B001C  mulli r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 * 28;
	// 82E7602C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E76030: 93ABFFF8  stw r29, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[29].u32 ) };
	// 82E76034: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E76038: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E7603C: 4BE33420  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E76040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E76040 size=52
    let mut pc: u32 = 0x82E76040;
    'dispatch: loop {
        match pc {
            0x82E76040 => {
    //   block [0x82E76040..0x82E76074)
	// 82E76040: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E76044: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E76048: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7604C: 40820028  bne 0x82e76074
	if !ctx.cr[0].eq {
		sub_82E76074(ctx, base);
		return;
	}
	// 82E76050: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E76054: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82E76058: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82E7605C: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82E76060: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E76064: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E76068: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E7606C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82E76070: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E76074(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E76074 size=112
    let mut pc: u32 = 0x82E76074;
    'dispatch: loop {
        match pc {
            0x82E76074 => {
    //   block [0x82E76074..0x82E760E4)
	// 82E76074: 81240014  lwz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76078: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82E7607C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E76080: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E76084: 91240014  stw r9, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82E76088: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E7608C: 91240010  stw r9, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82E76090: C0050000  lfs f0, 0(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76094: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E76098: C0050004  lfs f0, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7609C: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E760A0: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E760A4: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E760A8: 990B0018  stb r8, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[8].u8 ) };
	// 82E760AC: 409A0054  bne cr6, 0x82e76100
	if !ctx.cr[6].eq {
		sub_82E76100(ctx, base);
		return;
	}
	// 82E760B0: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E760B4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E760B8: 4082002C  bne 0x82e760e4
	if !ctx.cr[0].eq {
		sub_82E760E4(ctx, base);
		return;
	}
	// 82E760BC: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E760C0: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E760C4: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82E760C8: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E760CC: 91490010  stw r10, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82E760D0: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E760D4: 91490010  stw r10, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82E760D8: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E760DC: 91490014  stw r10, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82E760E0: 48000044  b 0x82e76124
	sub_82E76120(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E760E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E760E4 size=28
    let mut pc: u32 = 0x82E760E4;
    'dispatch: loop {
        match pc {
            0x82E760E4 => {
    //   block [0x82E760E4..0x82E76100)
	// 82E760E4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E760E8: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82E760EC: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82E760F0: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E760F4: 916A0014  stw r11, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82E760F8: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E760FC: 48000028  b 0x82e76124
	sub_82E76120(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E76100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E76100 size=32
    let mut pc: u32 = 0x82E76100;
    'dispatch: loop {
        match pc {
            0x82E76100 => {
    //   block [0x82E76100..0x82E76120)
	// 82E76100: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E76104: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82E76108: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E7610C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E76110: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82E76114: 4182000C  beq 0x82e76120
	if ctx.cr[0].eq {
		sub_82E76120(ctx, base);
		return;
	}
	// 82E76118: 91690014  stw r11, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82E7611C: 48000008  b 0x82e76124
	sub_82E76120(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E76120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E76120 size=36
    let mut pc: u32 = 0x82E76120;
    'dispatch: loop {
        match pc {
            0x82E76120 => {
    //   block [0x82E76120..0x82E76144)
	// 82E76120: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E76124: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82E76128: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E7612C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82E76130: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82E76134: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 82E76138: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E7613C: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E76140: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E76148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E76148 size=1052
    let mut pc: u32 = 0x82E76148;
    'dispatch: loop {
        match pc {
            0x82E76148 => {
    //   block [0x82E76148..0x82E76564)
	// 82E76148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7614C: 4BE332B9  bl 0x82ca9404
	ctx.lr = 0x82E76150;
	sub_82CA93D0(ctx, base);
	// 82E76150: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 82E76154: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82E76158: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82E7615C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E76160: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E76164: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E76168: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82E7616C: 388B1048  addi r4, r11, 0x1048
	ctx.r[4].s64 = ctx.r[11].s64 + 4168;
	// 82E76170: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76174: 4B3F139D  bl 0x82267510
	ctx.lr = 0x82E76178;
	sub_82267510(ctx, base);
	// 82E76178: 3F808334  lis r28, -0x7ccc
	ctx.r[28].s64 = -2093744128;
	// 82E7617C: 907F005C  stw r3, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82E76180: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E76184: 388BE4AC  addi r4, r11, -0x1b54
	ctx.r[4].s64 = ctx.r[11].s64 + -6996;
	// 82E76188: 807C0718  lwz r3, 0x718(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E7618C: 4B3F1A95  bl 0x82267c20
	ctx.lr = 0x82E76190;
	sub_82267C20(ctx, base);
	// 82E76190: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E76194: 907F0060  stw r3, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82E76198: 807C0718  lwz r3, 0x718(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E7619C: 388B1BA0  addi r4, r11, 0x1ba0
	ctx.r[4].s64 = ctx.r[11].s64 + 7072;
	// 82E761A0: 4B3F1A81  bl 0x82267c20
	ctx.lr = 0x82E761A4;
	sub_82267C20(ctx, base);
	// 82E761A4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E761A8: 907F0064  stw r3, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82E761AC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E761B0: 806B0064  lwz r3, 0x64(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E761B4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E761B8: 4182004C  beq 0x82e76204
	if ctx.cr[0].eq {
	pc = 0x82E76204; continue 'dispatch;
	}
	// 82E761BC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E761C0: 388BE284  addi r4, r11, -0x1d7c
	ctx.r[4].s64 = ctx.r[11].s64 + -7548;
	// 82E761C4: 4801150D  bl 0x82e876d0
	ctx.lr = 0x82E761C8;
	sub_82E876D0(ctx, base);
	// 82E761C8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E761CC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E761D0: 907F0068  stw r3, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82E761D4: 388BE6D4  addi r4, r11, -0x192c
	ctx.r[4].s64 = ctx.r[11].s64 + -6444;
	// 82E761D8: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E761DC: 806B0064  lwz r3, 0x64(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E761E0: 480114F1  bl 0x82e876d0
	ctx.lr = 0x82E761E4;
	sub_82E876D0(ctx, base);
	// 82E761E4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E761E8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E761EC: 907F006C  stw r3, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[3].u32 ) };
	// 82E761F0: 388BE5C0  addi r4, r11, -0x1a40
	ctx.r[4].s64 = ctx.r[11].s64 + -6720;
	// 82E761F4: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E761F8: 806B0064  lwz r3, 0x64(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E761FC: 480114D5  bl 0x82e876d0
	ctx.lr = 0x82E76200;
	sub_82E876D0(ctx, base);
	// 82E76200: 907F0070  stw r3, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 82E76204: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76208: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7620C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E76210: 388BC3A0  addi r4, r11, -0x3c60
	ctx.r[4].s64 = ctx.r[11].s64 + -15456;
	// 82E76214: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76218: 4B372461  bl 0x821e8678
	ctx.lr = 0x82E7621C;
	sub_821E8678(ctx, base);
	// 82E7621C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76220: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E76224: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E76228: 907F0084  stw r3, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82E7622C: 388BCC40  addi r4, r11, -0x33c0
	ctx.r[4].s64 = ctx.r[11].s64 + -13248;
	// 82E76230: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76234: 4B372445  bl 0x821e8678
	ctx.lr = 0x82E76238;
	sub_821E8678(ctx, base);
	// 82E76238: 907F0088  stw r3, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[3].u32 ) };
	// 82E7623C: 4B3EA77D  bl 0x822609b8
	ctx.lr = 0x82E76240;
	sub_822609B8(ctx, base);
	// 82E76240: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E76244: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E76248: 388B8ADC  addi r4, r11, -0x7524
	ctx.r[4].s64 = ctx.r[11].s64 + -29988;
	// 82E7624C: 4800AF1D  bl 0x82e81168
	ctx.lr = 0x82E76250;
	sub_82E81168(ctx, base);
	// 82E76250: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82E76254: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E76258: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E7625C: 388B8ABC  addi r4, r11, -0x7544
	ctx.r[4].s64 = ctx.r[11].s64 + -30020;
	// 82E76260: 915F008C  stw r10, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 82E76264: 4800AF05  bl 0x82e81168
	ctx.lr = 0x82E76268;
	sub_82E81168(ctx, base);
	// 82E76268: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E7626C: 907F0090  stw r3, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[3].u32 ) };
	// 82E76270: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82E76274: C3EB0C18  lfs f31, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E76278: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E7627C: 396BDBE4  addi r11, r11, -0x241c
	ctx.r[11].s64 = ctx.r[11].s64 + -9244;
	// 82E76280: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76284: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82E76288: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7628C: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82E76290: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76294: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E76298: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82E7629C: 396B115C  addi r11, r11, 0x115c
	ctx.r[11].s64 = ctx.r[11].s64 + 4444;
	// 82E762A0: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E762A4: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E762A8: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E762AC: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E762B0: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E762B4: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E762B8: D3FF004C  stfs f31, 0x4c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82E762BC: 419A0290  beq cr6, 0x82e7654c
	if ctx.cr[6].eq {
	pc = 0x82E7654C; continue 'dispatch;
	}
	// 82E762C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E762C4: D3FF0028  stfs f31, 0x28(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82E762C8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E762CC: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82E762D0: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E762D4: C3AA0C14  lfs f29, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82E762D8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E762DC: 4182000C  beq 0x82e762e8
	if ctx.cr[0].eq {
	pc = 0x82E762E8; continue 'dispatch;
	}
	// 82E762E0: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E762E4: 48000008  b 0x82e762ec
	pc = 0x82E762EC; continue 'dispatch;
	// 82E762E8: FDA0E890  fmr f13, f29
	ctx.f[13].f64 = ctx.f[29].f64;
	// 82E762EC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E762F0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E762F4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E762F8: D3FF002C  stfs f31, 0x2c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82E762FC: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82E76300: D3BF0098  stfs f29, 0x98(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82E76304: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E76308: C00B0AB8  lfs f0, 0xab8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2744 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7630C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E76310: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E76314: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82E76318: C00B0A94  lfs f0, 0xa94(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7631C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E76320: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82E76324: C3CB0BFC  lfs f30, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E76328: D3DF009C  stfs f30, 0x9c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82E7632C: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76330: 4B372349  bl 0x821e8678
	ctx.lr = 0x82E76334;
	sub_821E8678(ctx, base);
	// 82E76334: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76338: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7633C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E76340: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82E76344: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E76348: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E7634C: 4B37232D  bl 0x821e8678
	ctx.lr = 0x82E76350;
	sub_821E8678(ctx, base);
	// 82E76350: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76354: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E76358: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E7635C: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82E76360: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E76364: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76368: 4B372311  bl 0x821e8678
	ctx.lr = 0x82E7636C;
	sub_821E8678(ctx, base);
	// 82E7636C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E76370: 4182000C  beq 0x82e7637c
	if ctx.cr[0].eq {
	pc = 0x82E7637C; continue 'dispatch;
	}
	// 82E76374: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76378: 4800001C  b 0x82e76394
	pc = 0x82E76394; continue 'dispatch;
	// 82E7637C: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E76380: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E76384: 4182000C  beq 0x82e76390
	if ctx.cr[0].eq {
	pc = 0x82E76390; continue 'dispatch;
	}
	// 82E76388: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7638C: 48000008  b 0x82e76394
	pc = 0x82E76394; continue 'dispatch;
	// 82E76390: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 82E76394: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E76398: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E7639C: D3FF00AC  stfs f31, 0xac(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82E763A0: 409A0030  bne cr6, 0x82e763d0
	if !ctx.cr[6].eq {
	pc = 0x82E763D0; continue 'dispatch;
	}
	// 82E763A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E763A8: 409A0020  bne cr6, 0x82e763c8
	if !ctx.cr[6].eq {
	pc = 0x82E763C8; continue 'dispatch;
	}
	// 82E763AC: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E763B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E763B4: 4182000C  beq 0x82e763c0
	if ctx.cr[0].eq {
	pc = 0x82E763C0; continue 'dispatch;
	}
	// 82E763B8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E763BC: 48000018  b 0x82e763d4
	pc = 0x82E763D4; continue 'dispatch;
	// 82E763C0: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 82E763C4: 48000010  b 0x82e763d4
	pc = 0x82E763D4; continue 'dispatch;
	// 82E763C8: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E763CC: 48000008  b 0x82e763d4
	pc = 0x82E763D4; continue 'dispatch;
	// 82E763D0: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E763D4: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E763D8: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82E763DC: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E763E0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E763E4: 41820008  beq 0x82e763ec
	if ctx.cr[0].eq {
	pc = 0x82E763EC; continue 'dispatch;
	}
	// 82E763E8: C3AB000C  lfs f29, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82E763EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E763F0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E763F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E763F8: C00B0A98  lfs f0, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E763FC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82E76400: EDBD0032  fmuls f13, f29, f0
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E76404: D1BF00BC  stfs f13, 0xbc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82E76408: C00B8714  lfs f0, -0x78ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30956 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7640C: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E76410: 48012EB9  bl 0x82e892c8
	ctx.lr = 0x82E76414;
	sub_82E892C8(ctx, base);
	// 82E76414: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E76418: 41820134  beq 0x82e7654c
	if ctx.cr[0].eq {
	pc = 0x82E7654C; continue 'dispatch;
	}
	// 82E7641C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E76420: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E76424: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E76428: 388BC6DC  addi r4, r11, -0x3924
	ctx.r[4].s64 = ctx.r[11].s64 + -14628;
	// 82E7642C: 48007295  bl 0x82e7d6c0
	ctx.lr = 0x82E76430;
	sub_82E7D6C0(ctx, base);
	// 82E76430: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82E76434: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E76438: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E7643C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E76440: 388BCB2C  addi r4, r11, -0x34d4
	ctx.r[4].s64 = ctx.r[11].s64 + -13524;
	// 82E76444: 915F0074  stw r10, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82E76448: 48007279  bl 0x82e7d6c0
	ctx.lr = 0x82E7644C;
	sub_82E7D6C0(ctx, base);
	// 82E7644C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82E76450: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E76454: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E76458: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E7645C: 388BCA18  addi r4, r11, -0x35e8
	ctx.r[4].s64 = ctx.r[11].s64 + -13800;
	// 82E76460: 915F0078  stw r10, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82E76464: 4800725D  bl 0x82e7d6c0
	ctx.lr = 0x82E76468;
	sub_82E7D6C0(ctx, base);
	// 82E76468: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82E7646C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E76470: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E76474: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E76478: 388BC904  addi r4, r11, -0x36fc
	ctx.r[4].s64 = ctx.r[11].s64 + -14076;
	// 82E7647C: 915F007C  stw r10, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 82E76480: 48007241  bl 0x82e7d6c0
	ctx.lr = 0x82E76484;
	sub_82E7D6C0(ctx, base);
	// 82E76484: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E76488: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82E7648C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E76490: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E76494: 915F0080  stw r10, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 82E76498: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E7649C: 4E800421  bctrl
	ctx.lr = 0x82E764A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E764A0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E764A4: 418200A8  beq 0x82e7654c
	if ctx.cr[0].eq {
	pc = 0x82E7654C; continue 'dispatch;
	}
	// 82E764A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E764AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E764B0: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E764B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E764B8: 4E800421  bctrl
	ctx.lr = 0x82E764BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E764BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E764C0: 4182008C  beq 0x82e7654c
	if ctx.cr[0].eq {
	pc = 0x82E7654C; continue 'dispatch;
	}
	// 82E764C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E764C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E764CC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E764D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E764D4: 4E800421  bctrl
	ctx.lr = 0x82E764D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E764D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E764DC: 41820070  beq 0x82e7654c
	if ctx.cr[0].eq {
	pc = 0x82E7654C; continue 'dispatch;
	}
	// 82E764E0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82E764E4: 4B7A0445  bl 0x82616928
	ctx.lr = 0x82E764E8;
	sub_82616928(ctx, base);
	// 82E764E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E764EC: 41820014  beq 0x82e76500
	if ctx.cr[0].eq {
	pc = 0x82E76500; continue 'dispatch;
	}
	// 82E764F0: 889F00B8  lbz r4, 0xb8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82E764F4: 4BFFF9FD  bl 0x82e75ef0
	ctx.lr = 0x82E764F8;
	sub_82E75EF0(ctx, base);
	// 82E764F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E764FC: 48000008  b 0x82e76504
	pc = 0x82E76504; continue 'dispatch;
	// 82E76500: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E76504: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82E76508: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82E7650C: 4B7A041D  bl 0x82616928
	ctx.lr = 0x82E76510;
	sub_82616928(ctx, base);
	// 82E76510: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E76514: 41820014  beq 0x82e76528
	if ctx.cr[0].eq {
	pc = 0x82E76528; continue 'dispatch;
	}
	// 82E76518: 889F00B0  lbz r4, 0xb0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 82E7651C: 48016D15  bl 0x82e8d230
	ctx.lr = 0x82E76520;
	sub_82E8D230(ctx, base);
	// 82E76520: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E76524: 48000008  b 0x82e7652c
	pc = 0x82E7652C; continue 'dispatch;
	// 82E76528: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E7652C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E76530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E76534: 917F00B4  stw r11, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 82E76538: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E7653C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E76540: 4E800421  bctrl
	ctx.lr = 0x82E76544;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E76544: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E76548: 48000008  b 0x82e76550
	pc = 0x82E76550; continue 'dispatch;
	// 82E7654C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E76550: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E76554: CBA1FFB8  lfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82E76558: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82E7655C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82E76560: 4BE32EF4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E76568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E76568 size=760
    let mut pc: u32 = 0x82E76568;
    'dispatch: loop {
        match pc {
            0x82E76568 => {
    //   block [0x82E76568..0x82E76860)
	// 82E76568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7656C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E76570: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E76574: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E76578: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 82E7657C: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82E76580: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82E76584: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E76588: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E7658C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E76590: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E76594: 419802A0  blt cr6, 0x82e76834
	if ctx.cr[6].lt {
	pc = 0x82E76834; continue 'dispatch;
	}
	// 82E76598: 419A0230  beq cr6, 0x82e767c8
	if ctx.cr[6].eq {
	pc = 0x82E767C8; continue 'dispatch;
	}
	// 82E7659C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82E765A0: 41980194  blt cr6, 0x82e76734
	if ctx.cr[6].lt {
	pc = 0x82E76734; continue 'dispatch;
	}
	// 82E765A4: 419A0088  beq cr6, 0x82e7662c
	if ctx.cr[6].eq {
	pc = 0x82E7662C; continue 'dispatch;
	}
	// 82E765A8: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82E765AC: 40980290  bge cr6, 0x82e7683c
	if !ctx.cr[6].lt {
	pc = 0x82E7683C; continue 'dispatch;
	}
	// 82E765B0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E765B4: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 82E765B8: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E765BC: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E765C0: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E765C4: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E765C8: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E765CC: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E765D0: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E765D4: C03F0014  lfs f1, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E765D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E765DC: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E765E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E765E4: 4E800421  bctrl
	ctx.lr = 0x82E765E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E765E8: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E765EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E765F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E765F4: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E765F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E765FC: 4E800421  bctrl
	ctx.lr = 0x82E76600;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E76600: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E76604: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E76608: 409A0234  bne cr6, 0x82e7683c
	if !ctx.cr[6].eq {
	pc = 0x82E7683C; continue 'dispatch;
	}
	// 82E7660C: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E76610: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E76614: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76618: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E7661C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E76620: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E76624: 4E800421  bctrl
	ctx.lr = 0x82E76628;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E76628: 48000214  b 0x82e7683c
	pc = 0x82E7683C; continue 'dispatch;
	// 82E7662C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E76630: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E76634: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E76638: C3AB0C18  lfs f29, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82E7663C: 41820018  beq 0x82e76654
	if ctx.cr[0].eq {
	pc = 0x82E76654; continue 'dispatch;
	}
	// 82E76640: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76644: 38BF00C8  addi r5, r31, 0xc8
	ctx.r[5].s64 = ctx.r[31].s64 + 200;
	// 82E76648: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82E7664C: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76650: 4B432BC9  bl 0x822a9218
	ctx.lr = 0x82E76654;
	sub_822A9218(ctx, base);
	// 82E76654: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E76658: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E7665C: C01F00AC  lfs f0, 0xac(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76660: C1AB0A4C  lfs f13, 0xa4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2636 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E76664: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E76668: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E7666C: EC400372  fmuls f2, f0, f13
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E76670: C3E30014  lfs f31, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E76674: C3C30018  lfs f30, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E76678: C1AB0C4C  lfs f13, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E7667C: 816A0030  lwz r11, 0x30(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E76680: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E76684: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E76688: 4E800421  bctrl
	ctx.lr = 0x82E7668C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E7668C: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E76690: C03F0014  lfs f1, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E76694: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E76698: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E7669C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E766A0: 4E800421  bctrl
	ctx.lr = 0x82E766A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E766A4: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E766A8: 389F00C8  addi r4, r31, 0xc8
	ctx.r[4].s64 = ctx.r[31].s64 + 200;
	// 82E766AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E766B0: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E766B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E766B8: 4E800421  bctrl
	ctx.lr = 0x82E766BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E766BC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E766C0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E766C4: 409A0028  bne cr6, 0x82e766ec
	if !ctx.cr[6].eq {
	pc = 0x82E766EC; continue 'dispatch;
	}
	// 82E766C8: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E766CC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E766D0: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E766D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E766D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E766DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E766E0: 4E800421  bctrl
	ctx.lr = 0x82E766E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E766E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E766E8: 4BFFF5E1  bl 0x82e75cc8
	ctx.lr = 0x82E766EC;
	sub_82E75CC8(ctx, base);
	// 82E766EC: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E766F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E766F4: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E766F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E766FC: 4E800421  bctrl
	ctx.lr = 0x82E76700;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E76700: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E76704: 41820010  beq 0x82e76714
	if ctx.cr[0].eq {
	pc = 0x82E76714; continue 'dispatch;
	}
	// 82E76708: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E7670C: D3BF00A0  stfs f29, 0xa0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82E76710: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E76714: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E76718: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82E7671C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E76720: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E76724: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E76728: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E7672C: 4E800421  bctrl
	ctx.lr = 0x82E76730;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E76730: 4800010C  b 0x82e7683c
	pc = 0x82E7683C; continue 'dispatch;
	// 82E76734: 897F00C4  lbz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82E76738: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7673C: 40820054  bne 0x82e76790
	if !ctx.cr[0].eq {
	pc = 0x82E76790; continue 'dispatch;
	}
	// 82E76740: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E76744: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E76748: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E7674C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E76750: 4E800421  bctrl
	ctx.lr = 0x82E76754;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E76754: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E76758: 41820020  beq 0x82e76778
	if ctx.cr[0].eq {
	pc = 0x82E76778; continue 'dispatch;
	}
	// 82E7675C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E76760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E76764: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E76768: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E7676C: 4E800421  bctrl
	ctx.lr = 0x82E76770;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E76770: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E76774: 4082001C  bne 0x82e76790
	if !ctx.cr[0].eq {
	pc = 0x82E76790; continue 'dispatch;
	}
	// 82E76778: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E7677C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E76780: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E76784: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E76788: 4E800421  bctrl
	ctx.lr = 0x82E7678C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E7678C: 480000B0  b 0x82e7683c
	pc = 0x82E7683C; continue 'dispatch;
	// 82E76790: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E76794: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E76798: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E7679C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E767A0: 4E800421  bctrl
	ctx.lr = 0x82E767A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E767A4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E767A8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E767AC: 409A0090  bne cr6, 0x82e7683c
	if !ctx.cr[6].eq {
	pc = 0x82E7683C; continue 'dispatch;
	}
	// 82E767B0: 897F00C5  lbz r11, 0xc5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(197 as u32) ) } as u64;
	// 82E767B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E767B8: 4182FFC0  beq 0x82e76778
	if ctx.cr[0].eq {
	pc = 0x82E76778; continue 'dispatch;
	}
	// 82E767BC: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82E767C0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E767C4: 48000078  b 0x82e7683c
	pc = 0x82E7683C; continue 'dispatch;
	// 82E767C8: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E767CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E767D0: 41820030  beq 0x82e76800
	if ctx.cr[0].eq {
	pc = 0x82E76800; continue 'dispatch;
	}
	// 82E767D4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E767D8: 38BF00C8  addi r5, r31, 0xc8
	ctx.r[5].s64 = ctx.r[31].s64 + 200;
	// 82E767DC: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E767E0: 48051C21  bl 0x82ec8400
	ctx.lr = 0x82E767E4;
	sub_82EC8400(ctx, base);
	// 82E767E4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E767E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E767EC: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E767F0: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E767F4: C02B0C18  lfs f1, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E767F8: 38A40034  addi r5, r4, 0x34
	ctx.r[5].s64 = ctx.r[4].s64 + 52;
	// 82E767FC: 4B432A1D  bl 0x822a9218
	ctx.lr = 0x82E76800;
	sub_822A9218(ctx, base);
	// 82E76800: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E76808: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E7680C: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76810: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E76814: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76818: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E7681C: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76820: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E76824: 4BFFF4A5  bl 0x82e75cc8
	ctx.lr = 0x82E76828;
	sub_82E75CC8(ctx, base);
	// 82E76828: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7682C: 4BFFECC5  bl 0x82e754f0
	ctx.lr = 0x82E76830;
	sub_82E754F0(ctx, base);
	// 82E76830: 4800000C  b 0x82e7683c
	pc = 0x82E7683C; continue 'dispatch;
	// 82E76834: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E76838: 4BFFF491  bl 0x82e75cc8
	ctx.lr = 0x82E7683C;
	sub_82E75CC8(ctx, base);
	// 82E7683C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E76840: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E76844: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E76848: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82E7684C: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82E76850: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82E76854: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E76858: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E7685C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E76860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E76860 size=556
    let mut pc: u32 = 0x82E76860;
    'dispatch: loop {
        match pc {
            0x82E76860 => {
    //   block [0x82E76860..0x82E76A8C)
	// 82E76860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E76864: 4BE32BA5  bl 0x82ca9408
	ctx.lr = 0x82E76868;
	sub_82CA93D0(ctx, base);
	// 82E76868: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82E7686C: 4BE3746D  bl 0x82cadcd8
	ctx.lr = 0x82E76870;
	sub_82CADCA0(ctx, base);
	// 82E76870: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E76874: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E76878: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E7687C: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82E76880: 48000028  b 0x82e768a8
	pc = 0x82E768A8; continue 'dispatch;
	// 82E76884: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76888: 9BCA0018  stb r30, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82E7688C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76890: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E76894: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76898: 910A0014  stw r8, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82E7689C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E768A0: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82E768A4: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82E768A8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E768AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E768B0: 409AFFD4  bne cr6, 0x82e76884
	if !ctx.cr[6].eq {
	pc = 0x82E76884; continue 'dispatch;
	}
	// 82E768B4: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82E768B8: 93CB0014  stw r30, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82E768BC: 4B3EA0FD  bl 0x822609b8
	ctx.lr = 0x82E768C0;
	sub_822609B8(ctx, base);
	// 82E768C0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E768C4: C1A3004C  lfs f13, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E768C8: C01F009C  lfs f0, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E768CC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E768D0: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E768D4: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82E768D8: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E768DC: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E768E0: C1AA0034  lfs f13, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E768E4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E768E8: 409A0028  bne cr6, 0x82e76910
	if !ctx.cr[6].eq {
	pc = 0x82E76910; continue 'dispatch;
	}
	// 82E768EC: C00A0038  lfs f0, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E768F0: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E768F4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E768F8: 409A0018  bne cr6, 0x82e76910
	if !ctx.cr[6].eq {
	pc = 0x82E76910; continue 'dispatch;
	}
	// 82E768FC: C00A003C  lfs f0, 0x3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76900: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82E76904: C1AB003C  lfs f13, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E76908: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E7690C: 419A0008  beq cr6, 0x82e76914
	if ctx.cr[6].eq {
	pc = 0x82E76914; continue 'dispatch;
	}
	// 82E76910: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82E76914: 5529063F  clrlwi. r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82E76918: 4182000C  beq 0x82e76924
	if ctx.cr[0].eq {
	pc = 0x82E76924; continue 'dispatch;
	}
	// 82E7691C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E76920: 4800015C  b 0x82e76a7c
	pc = 0x82E76A7C; continue 'dispatch;
	// 82E76924: C14A0034  lfs f10, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E76928: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82E7692C: C16B0034  lfs f11, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E76930: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82E76934: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E76938: C12A0038  lfs f9, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E7693C: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E76940: 3929DBFC  addi r9, r9, -0x2404
	ctx.r[9].s64 = ctx.r[9].s64 + -9220;
	// 82E76944: ED495028  fsubs f10, f9, f10
	ctx.f[10].f64 = (((ctx.f[9].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E76948: C10A003C  lfs f8, 0x3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82E7694C: C12B003C  lfs f9, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E76950: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E76954: ED284828  fsubs f9, f8, f9
	ctx.f[9].f64 = (((ctx.f[8].f64 - ctx.f[9].f64) as f32) as f64);
	// 82E76958: C1890004  lfs f12, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E7695C: C0090008  lfs f0, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76960: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E76964: ED0B0032  fmuls f8, f11, f0
	ctx.f[8].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E76968: ECEA0372  fmuls f7, f10, f13
	ctx.f[7].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E7696C: ECC90332  fmuls f6, f9, f12
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82E76970: ED8B3B38  fmsubs f12, f11, f12, f7
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 - ctx.f[7].f64) as f32) as f64);
	// 82E76974: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82E76978: EC0A3038  fmsubs f0, f10, f0, f6
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 - ctx.f[6].f64) as f32) as f64);
	// 82E7697C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E76980: EC094378  fmsubs f0, f9, f13, f8
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[13].f64 - ctx.f[8].f64) as f32) as f64);
	// 82E76984: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82E76988: 4B4088E1  bl 0x8227f268
	ctx.lr = 0x82E7698C;
	sub_8227F268(ctx, base);
	// 82E7698C: 895F00B8  lbz r10, 0xb8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82E76990: C3FF00BC  lfs f31, 0xbc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E76994: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E76998: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7699C: 418200D0  beq 0x82e76a6c
	if ctx.cr[0].eq {
	pc = 0x82E76A6C; continue 'dispatch;
	}
	// 82E769A0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82E769A4: C3C10060  lfs f30, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E769A8: C3A1005C  lfs f29, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82E769AC: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82E769B0: C3810058  lfs f28, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82E769B4: 3BAAAFB4  addi r29, r10, -0x504c
	ctx.r[29].s64 = ctx.r[10].s64 + -20556;
	// 82E769B8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E769BC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E769C0: 809F00C0  lwz r4, 0xc0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82E769C4: EC1C07F2  fmuls f0, f28, f31
	ctx.f[0].f64 = (((ctx.f[28].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E769C8: EDBD07F2  fmuls f13, f29, f31
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E769CC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82E769D0: ED9E07F2  fmuls f12, f30, f31
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E769D4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E769D8: C16B0034  lfs f11, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E769DC: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E769E0: 4182003C  beq 0x82e76a1c
	if ctx.cr[0].eq {
	pc = 0x82E76A1C; continue 'dispatch;
	}
	// 82E769E4: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E769E8: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82E769EC: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E769F0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E769F4: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 82E769F8: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E769FC: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E76A00: D1A1007C  stfs f13, 0x7c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82E76A04: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82E76A08: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82E76A0C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82E76A10: 4BFFF631  bl 0x82e76040
	ctx.lr = 0x82E76A14;
	sub_82E76040(ctx, base);
	// 82E76A14: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82E76A18: 48000040  b 0x82e76a58
	pc = 0x82E76A58; continue 'dispatch;
	// 82E76A1C: EC0B0028  fsubs f0, f11, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E76A20: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82E76A24: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76A28: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82E76A2C: 38A10088  addi r5, r1, 0x88
	ctx.r[5].s64 = ctx.r[1].s64 + 136;
	// 82E76A30: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E76A34: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E76A38: D1A1008C  stfs f13, 0x8c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82E76A3C: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82E76A40: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82E76A44: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82E76A48: 4BFFF5F9  bl 0x82e76040
	ctx.lr = 0x82E76A4C;
	sub_82E76040(ctx, base);
	// 82E76A4C: C01F00BC  lfs f0, 0xbc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76A50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E76A54: EFFF002A  fadds f31, f31, f0
	ctx.f[31].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E76A58: 395C0001  addi r10, r28, 1
	ctx.r[10].s64 = ctx.r[28].s64 + 1;
	// 82E76A5C: 893F00B8  lbz r9, 0xb8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82E76A60: 555C063E  clrlwi r28, r10, 0x18
	ctx.r[28].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82E76A64: 7F1C4840  cmplw cr6, r28, r9
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E76A68: 4198FF50  blt cr6, 0x82e769b8
	if ctx.cr[6].lt {
	pc = 0x82E769B8; continue 'dispatch;
	}
	// 82E76A6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E76A70: 9BDF00D4  stb r30, 0xd4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[30].u8 ) };
	// 82E76A74: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E76A78: 997F00C4  stb r11, 0xc4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u8 ) };
	// 82E76A7C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82E76A80: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82E76A84: 4BE372A1  bl 0x82cadd24
	ctx.lr = 0x82E76A88;
	sub_82CADCEC(ctx, base);
	// 82E76A88: 4BE329D0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E76A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E76A90 size=868
    let mut pc: u32 = 0x82E76A90;
    'dispatch: loop {
        match pc {
            0x82E76A90 => {
    //   block [0x82E76A90..0x82E76DF4)
	// 82E76A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E76A94: 4BE32971  bl 0x82ca9404
	ctx.lr = 0x82E76A98;
	sub_82CA93D0(ctx, base);
	// 82E76A98: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 82E76A9C: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82E76AA0: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82E76AA4: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E76AA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E76AAC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E76AB0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76AB4: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76AB8: 9B9F00C5  stb r28, 0xc5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(197 as u32), ctx.r[28].u8 ) };
	// 82E76ABC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76AC0: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E76AC4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E76AC8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E76ACC: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82E76AD0: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E76AD4: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E76AD8: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E76ADC: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E76AE0: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E76AE4: EFAD0032  fmuls f29, f13, f0
	ctx.f[29].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E76AE8: 4B3E9ED1  bl 0x822609b8
	ctx.lr = 0x82E76AEC;
	sub_822609B8(ctx, base);
	// 82E76AEC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76AF0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82E76AF4: 809F0090  lwz r4, 0x90(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82E76AF8: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76AFC: 4BFF95D5  bl 0x82e700d0
	ctx.lr = 0x82E76B00;
	sub_82E700D0(ctx, base);
	// 82E76B00: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E76B04: 418202D8  beq 0x82e76ddc
	if ctx.cr[0].eq {
	pc = 0x82E76DDC; continue 'dispatch;
	}
	// 82E76B08: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82E76B0C: 891F00D4  lbz r8, 0xd4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82E76B10: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E76B14: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76B18: 41820020  beq 0x82e76b38
	if ctx.cr[0].eq {
	pc = 0x82E76B38; continue 'dispatch;
	}
	// 82E76B1C: 5509063E  clrlwi r9, r8, 0x18
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82E76B20: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82E76B24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E76B28: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76B2C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82E76B30: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E76B34: 4198FFF0  blt cr6, 0x82e76b24
	if ctx.cr[6].lt {
	pc = 0x82E76B24; continue 'dispatch;
	}
	// 82E76B38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E76B3C: 409A0020  bne cr6, 0x82e76b5c
	if !ctx.cr[6].eq {
	pc = 0x82E76B5C; continue 'dispatch;
	}
	// 82E76B40: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76B44: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76B48: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E76B4C: 809F0090  lwz r4, 0x90(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82E76B50: 4800B199  bl 0x82e81ce8
	ctx.lr = 0x82E76B54;
	sub_82E81CE8(ctx, base);
	// 82E76B54: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E76B58: 48000288  b 0x82e76de0
	pc = 0x82E76DE0; continue 'dispatch;
	// 82E76B5C: 39480001  addi r10, r8, 1
	ctx.r[10].s64 = ctx.r[8].s64 + 1;
	// 82E76B60: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76B64: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E76B68: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E76B6C: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E76B70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E76B74: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E76B78: EC00E82A  fadds f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82E76B7C: EDADF02A  fadds f13, f13, f30
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[30].f64) as f32) as f64;
	// 82E76B80: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E76B84: ED9F602A  fadds f12, f31, f12
	ctx.f[12].f64 = ((ctx.f[31].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E76B88: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E76B8C: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E76B90: 995F00D4  stb r10, 0xd4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[10].u8 ) };
	// 82E76B94: 4BFFE89D  bl 0x82e75430
	ctx.lr = 0x82E76B98;
	sub_82E75430(ctx, base);
	// 82E76B98: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82E76B9C: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76BA0: 48000028  b 0x82e76bc8
	pc = 0x82E76BC8; continue 'dispatch;
	// 82E76BA4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82E76BA8: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E76BAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E76BB0: C05F0024  lfs f2, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82E76BB4: C03F0028  lfs f1, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E76BB8: 4BFFD561  bl 0x82e74118
	ctx.lr = 0x82E76BBC;
	sub_82E74118(ctx, base);
	// 82E76BBC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E76BC0: 408200F8  bne 0x82e76cb8
	if !ctx.cr[0].eq {
	pc = 0x82E76CB8; continue 'dispatch;
	}
	// 82E76BC4: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E76BC8: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E76BCC: 4082FFD8  bne 0x82e76ba4
	if !ctx.cr[0].eq {
	pc = 0x82E76BA4; continue 'dispatch;
	}
	// 82E76BD0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E76BD4: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76BD8: D00100E4  stfs f0, 0xe4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82E76BDC: 394100F0  addi r10, r1, 0xf0
	ctx.r[10].s64 = ctx.r[1].s64 + 240;
	// 82E76BE0: 3BAB9128  addi r29, r11, -0x6ed8
	ctx.r[29].s64 = ctx.r[11].s64 + -28376;
	// 82E76BE4: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76BE8: D00100E8  stfs f0, 0xe8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82E76BEC: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82E76BF0: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76BF4: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82E76BF8: D00100EC  stfs f0, 0xec(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82E76BFC: 93A100E0  stw r29, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[29].u32 ) };
	// 82E76C00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E76C04: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E76C08: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82E76C0C: 4200FFF8  bdnz 0x82e76c04
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E76C04; continue 'dispatch;
	}
	// 82E76C10: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76C14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E76C18: 9B810138  stb r28, 0x138(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), ctx.r[28].u8 ) };
	// 82E76C1C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82E76C20: 3BCB1890  addi r30, r11, 0x1890
	ctx.r[30].s64 = ctx.r[11].s64 + 6288;
	// 82E76C24: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82E76C28: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76C2C: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82E76C30: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82E76C34: 4B337A75  bl 0x821ae6a8
	ctx.lr = 0x82E76C38;
	sub_821AE6A8(ctx, base);
	// 82E76C38: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E76C3C: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 82E76C40: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 82E76C44: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82E76C48: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82E76C4C: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76C50: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82E76C54: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76C58: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82E76C5C: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76C60: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82E76C64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E76C68: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82E76C6C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82E76C70: 4200FFF8  bdnz 0x82e76c68
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E76C68; continue 'dispatch;
	}
	// 82E76C74: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E76C78: 9B8100D8  stb r28, 0xd8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[28].u8 ) };
	// 82E76C7C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82E76C80: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82E76C84: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82E76C88: 4B337A21  bl 0x821ae6a8
	ctx.lr = 0x82E76C8C;
	sub_821AE6A8(ctx, base);
	// 82E76C8C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E76C90: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76C94: 396BDAC0  addi r11, r11, -0x2540
	ctx.r[11].s64 = ctx.r[11].s64 + -9536;
	// 82E76C98: 80E90014  lwz r7, 0x14(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76C9C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E76CA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E76CA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E76CA8: C3EA0C18  lfs f31, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E76CAC: 409A003C  bne cr6, 0x82e76ce8
	if !ctx.cr[6].eq {
	pc = 0x82E76CE8; continue 'dispatch;
	}
	// 82E76CB0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E76CB4: 48000050  b 0x82e76d04
	pc = 0x82E76D04; continue 'dispatch;
	// 82E76CB8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76CBC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E76CC0: 9B9F00C5  stb r28, 0xc5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(197 as u32), ctx.r[28].u8 ) };
	// 82E76CC4: 809F0090  lwz r4, 0x90(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82E76CC8: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76CCC: 4800B01D  bl 0x82e81ce8
	ctx.lr = 0x82E76CD0;
	sub_82E81CE8(ctx, base);
	// 82E76CD0: 897F00B8  lbz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82E76CD4: 895F00D4  lbz r10, 0xd4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82E76CD8: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82E76CDC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82E76CE0: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82E76CE4: 480000FC  b 0x82e76de0
	pc = 0x82E76DE0; continue 'dispatch;
	// 82E76CE8: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E76CEC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E76CF0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E76CF4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82E76CF8: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82E76CFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E76D00: 4E800421  bctrl
	ctx.lr = 0x82E76D04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E76D04: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E76D08: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76D0C: 4082FFB0  bne 0x82e76cbc
	if !ctx.cr[0].eq {
	pc = 0x82E76CBC; continue 'dispatch;
	}
	// 82E76D10: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E76D14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E76D18: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76D1C: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82E76D20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E76D24: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E76D28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E76D2C: 4E800421  bctrl
	ctx.lr = 0x82E76D30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E76D30: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E76D34: 4182FF84  beq 0x82e76cb8
	if ctx.cr[0].eq {
	pc = 0x82E76CB8; continue 'dispatch;
	}
	// 82E76D38: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76D3C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E76D40: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E76D44: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76D48: 38AB0034  addi r5, r11, 0x34
	ctx.r[5].s64 = ctx.r[11].s64 + 52;
	// 82E76D4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E76D50: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E76D54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E76D58: 4E800421  bctrl
	ctx.lr = 0x82E76D5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E76D5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E76D60: 4182FF58  beq 0x82e76cb8
	if ctx.cr[0].eq {
	pc = 0x82E76CB8; continue 'dispatch;
	}
	// 82E76D64: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E76D68: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E76D6C: 41820030  beq 0x82e76d9c
	if ctx.cr[0].eq {
	pc = 0x82E76D9C; continue 'dispatch;
	}
	// 82E76D70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E76D74: C03F00AC  lfs f1, 0xac(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E76D78: 48051EC9  bl 0x82ec8c40
	ctx.lr = 0x82E76D7C;
	sub_82EC8C40(ctx, base);
	// 82E76D7C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76D80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E76D84: 4082FF38  bne 0x82e76cbc
	if !ctx.cr[0].eq {
	pc = 0x82E76CBC; continue 'dispatch;
	}
	// 82E76D88: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E76D8C: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E76D90: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76D94: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E76D98: 4B432481  bl 0x822a9218
	ctx.lr = 0x82E76D9C;
	sub_822A9218(ctx, base);
	// 82E76D9C: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76DA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E76DA4: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E76DA8: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E76DAC: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82E76DB0: D1BF00CC  stfs f13, 0xcc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82E76DB4: D19F00D0  stfs f12, 0xd0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82E76DB8: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E76DBC: C01F00CC  lfs f0, 0xcc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76DC0: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E76DC4: C01F00D0  lfs f0, 0xd0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76DC8: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E76DCC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76DD0: 997F00C5  stb r11, 0xc5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(197 as u32), ctx.r[11].u8 ) };
	// 82E76DD4: 80AA0014  lwz r5, 0x14(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76DD8: 4BFFFD70  b 0x82e76b48
	pc = 0x82E76B48; continue 'dispatch;
	// 82E76DDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E76DE0: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82E76DE4: CBA1FFB8  lfd f29, -0x48(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82E76DE8: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82E76DEC: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82E76DF0: 4BE32664  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E76DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E76DF8 size=200
    let mut pc: u32 = 0x82E76DF8;
    'dispatch: loop {
        match pc {
            0x82E76DF8 => {
    //   block [0x82E76DF8..0x82E76EC0)
	// 82E76DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E76DFC: 4BE3260D  bl 0x82ca9408
	ctx.lr = 0x82E76E00;
	sub_82CA93D0(ctx, base);
	// 82E76E00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E76E04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E76E08: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E76E0C: 807F0070  lwz r3, 0x70(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82E76E10: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E76E14: 41820038  beq 0x82e76e4c
	if ctx.cr[0].eq {
	pc = 0x82E76E4C; continue 'dispatch;
	}
	// 82E76E18: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E76E1C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76E20: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 82E76E24: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82E76E28: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E76E2C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82E76E30: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82E76E34: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76E38: 4B45A579  bl 0x822d13b0
	ctx.lr = 0x82E76E3C;
	sub_822D13B0(ctx, base);
	// 82E76E3C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E76E40: 4182000C  beq 0x82e76e4c
	if ctx.cr[0].eq {
	pc = 0x82E76E4C; continue 'dispatch;
	}
	// 82E76E44: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E76E48: 48000070  b 0x82e76eb8
	pc = 0x82E76EB8; continue 'dispatch;
	// 82E76E4C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E76E50: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76E54: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E76E58: 3BEBC3A0  addi r31, r11, -0x3c60
	ctx.r[31].s64 = ctx.r[11].s64 + -15456;
	// 82E76E5C: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 82E76E60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E76E64: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76E68: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 82E76E6C: 4B37180D  bl 0x821e8678
	ctx.lr = 0x82E76E70;
	sub_821E8678(ctx, base);
	// 82E76E70: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E76E74: 41820008  beq 0x82e76e7c
	if ctx.cr[0].eq {
	pc = 0x82E76E7C; continue 'dispatch;
	}
	// 82E76E78: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E76E7C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E76E80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E76E84: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E76E88: 4B3717F1  bl 0x821e8678
	ctx.lr = 0x82E76E8C;
	sub_821E8678(ctx, base);
	// 82E76E8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E76E90: 41820008  beq 0x82e76e98
	if ctx.cr[0].eq {
	pc = 0x82E76E98; continue 'dispatch;
	}
	// 82E76E94: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E76E98: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82E76E9C: 419A0018  beq cr6, 0x82e76eb4
	if ctx.cr[6].eq {
	pc = 0x82E76EB4; continue 'dispatch;
	}
	// 82E76EA0: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82E76EA4: 419A0010  beq cr6, 0x82e76eb4
	if ctx.cr[6].eq {
	pc = 0x82E76EB4; continue 'dispatch;
	}
	// 82E76EA8: 7F1DF000  cmpw cr6, r29, r30
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82E76EAC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E76EB0: 409A0008  bne cr6, 0x82e76eb8
	if !ctx.cr[6].eq {
	pc = 0x82E76EB8; continue 'dispatch;
	}
	// 82E76EB4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E76EB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E76EBC: 4BE3259C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E76EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E76EC0 size=180
    let mut pc: u32 = 0x82E76EC0;
    'dispatch: loop {
        match pc {
            0x82E76EC0 => {
    //   block [0x82E76EC0..0x82E76F74)
	// 82E76EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E76EC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E76EC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E76ECC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E76ED0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E76ED4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E76ED8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E76EDC: 807E006C  lwz r3, 0x6c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E76EE0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E76EE4: 4182003C  beq 0x82e76f20
	if ctx.cr[0].eq {
	pc = 0x82E76F20; continue 'dispatch;
	}
	// 82E76EE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E76EEC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76EF0: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 82E76EF4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82E76EF8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E76EFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E76F00: C00B0BEC  lfs f0, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76F04: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E76F08: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76F0C: 4BFFAC35  bl 0x82e71b40
	ctx.lr = 0x82E76F10;
	sub_82E71B40(ctx, base);
	// 82E76F10: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E76F14: 4082000C  bne 0x82e76f20
	if !ctx.cr[0].eq {
	pc = 0x82E76F20; continue 'dispatch;
	}
	// 82E76F18: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E76F1C: 48000040  b 0x82e76f5c
	pc = 0x82E76F5C; continue 'dispatch;
	// 82E76F20: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76F24: C01F0034  lfs f0, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76F28: C1BF0038  lfs f13, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E76F2C: C19F003C  lfs f12, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E76F30: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E76F34: C16B0034  lfs f11, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E76F38: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E76F3C: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E76F40: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E76F44: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E76F48: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E76F4C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E76F50: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E76F54: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E76F58: EC20002C  fsqrts f1, f0
	ctx.f[1].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E76F5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E76F60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E76F64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E76F68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E76F6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E76F70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E76F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E76F78 size=80
    let mut pc: u32 = 0x82E76F78;
    'dispatch: loop {
        match pc {
            0x82E76F78 => {
    //   block [0x82E76F78..0x82E76FC8)
	// 82E76F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E76F7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E76F80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E76F84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E76F88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E76F8C: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E76F90: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E76F94: 4182001C  beq 0x82e76fb0
	if ctx.cr[0].eq {
	pc = 0x82E76FB0; continue 'dispatch;
	}
	// 82E76F98: 4BFFFF29  bl 0x82e76ec0
	ctx.lr = 0x82E76F9C;
	sub_82E76EC0(ctx, base);
	// 82E76F9C: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E76FA0: D03F0030  stfs f1, 0x30(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82E76FA4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82E76FA8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E76FAC: 41980008  blt cr6, 0x82e76fb4
	if ctx.cr[6].lt {
	pc = 0x82E76FB4; continue 'dispatch;
	}
	// 82E76FB0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E76FB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E76FB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E76FBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E76FC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E76FC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E76FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E76FC8 size=360
    let mut pc: u32 = 0x82E76FC8;
    'dispatch: loop {
        match pc {
            0x82E76FC8 => {
    //   block [0x82E76FC8..0x82E77130)
	// 82E76FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E76FCC: 4BE3243D  bl 0x82ca9408
	ctx.lr = 0x82E76FD0;
	sub_82CA93D0(ctx, base);
	// 82E76FD0: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E76FD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E76FD8: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82E76FDC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E76FE0: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82E76FE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E76FE8: 41820030  beq 0x82e77018
	if ctx.cr[0].eq {
	pc = 0x82E77018; continue 'dispatch;
	}
	// 82E76FEC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E76FF0: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 82E76FF4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82E76FF8: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 82E76FFC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E77000: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E77004: 4B45A3AD  bl 0x822d13b0
	ctx.lr = 0x82E77008;
	sub_822D13B0(ctx, base);
	// 82E77008: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E7700C: 4182000C  beq 0x82e77018
	if ctx.cr[0].eq {
	pc = 0x82E77018; continue 'dispatch;
	}
	// 82E77010: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E77014: 48000114  b 0x82e77128
	pc = 0x82E77128; continue 'dispatch;
	// 82E77018: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E7701C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E77020: 390100E0  addi r8, r1, 0xe0
	ctx.r[8].s64 = ctx.r[1].s64 + 224;
	// 82E77024: 3BAB9128  addi r29, r11, -0x6ed8
	ctx.r[29].s64 = ctx.r[11].s64 + -28376;
	// 82E77028: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82E7702C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82E77030: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E77034: 93A100D0  stw r29, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[29].u32 ) };
	// 82E77038: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7703C: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82E77040: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77044: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82E77048: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7704C: D00100DC  stfs f0, 0xdc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82E77050: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82E77054: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82E77058: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82E7705C: 4200FFF8  bdnz 0x82e77054
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E77054; continue 'dispatch;
	}
	// 82E77060: 9B810128  stb r28, 0x128(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), ctx.r[28].u8 ) };
	// 82E77064: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E77068: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E7706C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E77070: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82E77074: 3BCA1890  addi r30, r10, 0x1890
	ctx.r[30].s64 = ctx.r[10].s64 + 6288;
	// 82E77078: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82E7707C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82E77080: 4B337629  bl 0x821ae6a8
	ctx.lr = 0x82E77084;
	sub_821AE6A8(ctx, base);
	// 82E77084: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E77088: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82E7708C: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82E77090: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82E77094: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82E77098: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7709C: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82E770A0: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E770A4: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82E770A8: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E770AC: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82E770B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E770B4: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82E770B8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82E770BC: 4200FFF8  bdnz 0x82e770b4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E770B4; continue 'dispatch;
	}
	// 82E770C0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82E770C4: 9B8100C8  stb r28, 0xc8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[28].u8 ) };
	// 82E770C8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E770CC: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82E770D0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E770D4: 4B3375D5  bl 0x821ae6a8
	ctx.lr = 0x82E770D8;
	sub_821AE6A8(ctx, base);
	// 82E770D8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E770DC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E770E0: 396BDAC0  addi r11, r11, -0x2540
	ctx.r[11].s64 = ctx.r[11].s64 + -9536;
	// 82E770E4: 80E90014  lwz r7, 0x14(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E770E8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E770EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E770F0: 409A000C  bne cr6, 0x82e770fc
	if !ctx.cr[6].eq {
	pc = 0x82E770FC; continue 'dispatch;
	}
	// 82E770F4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E770F8: 48000024  b 0x82e7711c
	pc = 0x82E7711C; continue 'dispatch;
	// 82E770FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E77100: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E77104: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E77108: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82E7710C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82E77110: C02A0C18  lfs f1, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E77114: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E77118: 4E800421  bctrl
	ctx.lr = 0x82E7711C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E7711C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E77120: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82E77124: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82E77128: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82E7712C: 4BE3232C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E77130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E77130 size=180
    let mut pc: u32 = 0x82E77130;
    'dispatch: loop {
        match pc {
            0x82E77130 => {
    //   block [0x82E77130..0x82E771E4)
	// 82E77130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E77134: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E77138: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E7713C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E77140: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E77144: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E77148: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7714C: 4082000C  bne 0x82e77158
	if !ctx.cr[0].eq {
	pc = 0x82E77158; continue 'dispatch;
	}
	// 82E77150: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E77154: 4800007C  b 0x82e771d0
	pc = 0x82E771D0; continue 'dispatch;
	// 82E77158: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7715C: 4BFFFD65  bl 0x82e76ec0
	ctx.lr = 0x82E77160;
	sub_82E76EC0(ctx, base);
	// 82E77160: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E77164: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E77168: D03F0030  stfs f1, 0x30(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82E7716C: 4BFFFE5D  bl 0x82e76fc8
	ctx.lr = 0x82E77170;
	sub_82E76FC8(ctx, base);
	// 82E77170: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E77174: C1BF0024  lfs f13, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E77178: 987F0011  stb r3, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[3].u8 ) };
	// 82E7717C: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77180: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E77184: 4099FFCC  ble cr6, 0x82e77150
	if !ctx.cr[6].gt {
	pc = 0x82E77150; continue 'dispatch;
	}
	// 82E77188: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E7718C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E77190: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77194: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82E77198: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7719C: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82E771A0: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E771A4: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82E771A8: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82E771AC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E771B0: 4182001C  beq 0x82e771cc
	if ctx.cr[0].eq {
	pc = 0x82E771CC; continue 'dispatch;
	}
	// 82E771B4: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E771B8: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82E771BC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E771C0: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82E771C4: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E771C8: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82E771CC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E771D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E771D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E771D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E771DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E771E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E771E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E771E8 size=964
    let mut pc: u32 = 0x82E771E8;
    'dispatch: loop {
        match pc {
            0x82E771E8 => {
    //   block [0x82E771E8..0x82E775AC)
	// 82E771E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E771EC: 4BE32209  bl 0x82ca93f4
	ctx.lr = 0x82E771F0;
	sub_82CA93D0(ctx, base);
	// 82E771F0: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 82E771F4: 4BE36AC9  bl 0x82cadcbc
	ctx.lr = 0x82E771F8;
	sub_82CADCA0(ctx, base);
	// 82E771F8: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E771FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E77200: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E77204: 3B9F0034  addi r28, r31, 0x34
	ctx.r[28].s64 = ctx.r[31].s64 + 52;
	// 82E77208: 394B9128  addi r10, r11, -0x6ed8
	ctx.r[10].s64 = ctx.r[11].s64 + -28376;
	// 82E7720C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E77210: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E77214: 39210100  addi r9, r1, 0x100
	ctx.r[9].s64 = ctx.r[1].s64 + 256;
	// 82E77218: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7721C: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82E77220: D00100F4  stfs f0, 0xf4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82E77224: 914100F0  stw r10, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 82E77228: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7722C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82E77230: D00100F8  stfs f0, 0xf8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82E77234: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77238: D00100FC  stfs f0, 0xfc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82E7723C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E77240: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82E77244: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82E77248: 4200FFF8  bdnz 0x82e77240
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E77240; continue 'dispatch;
	}
	// 82E7724C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E77250: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 82E77254: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 82E77258: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82E7725C: 9BC10148  stb r30, 0x148(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), ctx.r[30].u8 ) };
	// 82E77260: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82E77264: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77268: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82E7726C: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77270: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82E77274: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77278: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82E7727C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E77280: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82E77284: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82E77288: 4200FFF8  bdnz 0x82e77280
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E77280; continue 'dispatch;
	}
	// 82E7728C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E77290: 9BC100E8  stb r30, 0xe8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[30].u8 ) };
	// 82E77294: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82E77298: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82E7729C: 394A1890  addi r10, r10, 0x1890
	ctx.r[10].s64 = ctx.r[10].s64 + 6288;
	// 82E772A0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82E772A4: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82E772A8: 4B337401  bl 0x821ae6a8
	ctx.lr = 0x82E772AC;
	sub_821AE6A8(ctx, base);
	// 82E772AC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E772B0: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E772B4: 396BDAC0  addi r11, r11, -0x2540
	ctx.r[11].s64 = ctx.r[11].s64 + -9536;
	// 82E772B8: 80E90014  lwz r7, 0x14(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E772BC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E772C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E772C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E772C8: C32A0C18  lfs f25, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82E772CC: 409A000C  bne cr6, 0x82e772d8
	if !ctx.cr[6].eq {
	pc = 0x82E772D8; continue 'dispatch;
	}
	// 82E772D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E772D4: 48000020  b 0x82e772f4
	pc = 0x82E772F4; continue 'dispatch;
	// 82E772D8: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E772DC: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 82E772E0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E772E4: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82E772E8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82E772EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E772F0: 4E800421  bctrl
	ctx.lr = 0x82E772F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E772F4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E772F8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E772FC: 419A029C  beq cr6, 0x82e77598
	if ctx.cr[6].eq {
	pc = 0x82E77598; continue 'dispatch;
	}
	// 82E77300: 897F0011  lbz r11, 0x11(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E77304: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E77308: 41820290  beq 0x82e77598
	if ctx.cr[0].eq {
	pc = 0x82E77598; continue 'dispatch;
	}
	// 82E7730C: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E77310: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E77314: 409A000C  bne cr6, 0x82e77320
	if !ctx.cr[6].eq {
	pc = 0x82E77320; continue 'dispatch;
	}
	// 82E77318: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E7731C: 48000280  b 0x82e7759c
	pc = 0x82E7759C; continue 'dispatch;
	// 82E77320: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E77324: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82E77328: 4B407F41  bl 0x8227f268
	ctx.lr = 0x82E7732C;
	sub_8227F268(ctx, base);
	// 82E7732C: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82E77330: FF60C890  fmr f27, f25
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[25].f64;
	// 82E77334: 82EB0008  lwz r23, 8(r11)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E77338: 28170000  cmplwi r23, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7733C: 4182024C  beq 0x82e77588
	if ctx.cr[0].eq {
	pc = 0x82E77588; continue 'dispatch;
	}
	// 82E77340: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E77344: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82E77348: 3B6B115C  addi r27, r11, 0x115c
	ctx.r[27].s64 = ctx.r[11].s64 + 4444;
	// 82E7734C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E77350: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82E77354: 3D208203  lis r9, -0x7dfd
	ctx.r[9].s64 = -2113732608;
	// 82E77358: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82E7735C: C3470B40  lfs f26, 0xb40(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2880 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82E77360: 3B4BC5C8  addi r26, r11, -0x3a38
	ctx.r[26].s64 = ctx.r[11].s64 + -14904;
	// 82E77364: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E77368: C2C80BFC  lfs f22, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 82E7736C: 3F008204  lis r24, -0x7dfc
	ctx.r[24].s64 = -2113667072;
	// 82E77370: C2E95CC4  lfs f23, 0x5cc4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(23748 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82E77374: 3B2BC178  addi r25, r11, -0x3e88
	ctx.r[25].s64 = ctx.r[11].s64 + -16008;
	// 82E77378: C30A8714  lfs f24, -0x78ec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30956 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82E7737C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E77380: 83D70004  lwz r30, 4(r23)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E77384: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E77388: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E7738C: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E77390: 419A01E0  beq cr6, 0x82e77570
	if ctx.cr[6].eq {
	pc = 0x82E77570; continue 'dispatch;
	}
	// 82E77394: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E77398: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E7739C: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E773A0: 419A01D0  beq cr6, 0x82e77570
	if ctx.cr[6].eq {
	pc = 0x82E77570; continue 'dispatch;
	}
	// 82E773A4: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E773A8: 81589660  lwz r10, -0x69a0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-27040 as u32) ) } as u64;
	// 82E773AC: 7D6B5039  and. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E773B0: 418201C0  beq 0x82e77570
	if ctx.cr[0].eq {
	pc = 0x82E77570; continue 'dispatch;
	}
	// 82E773B4: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82E773B8: C05F0024  lfs f2, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82E773BC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E773C0: C03F0028  lfs f1, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E773C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E773C8: 4BFFCD51  bl 0x82e74118
	ctx.lr = 0x82E773CC;
	sub_82E74118(ctx, base);
	// 82E773CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E773D0: 418201A0  beq 0x82e77570
	if ctx.cr[0].eq {
	pc = 0x82E77570; continue 'dispatch;
	}
	// 82E773D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E773D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E773DC: 4BFFFA1D  bl 0x82e76df8
	ctx.lr = 0x82E773E0;
	sub_82E76DF8(ctx, base);
	// 82E773E0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E773E4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E773E8: 419A0188  beq cr6, 0x82e77570
	if ctx.cr[6].eq {
	pc = 0x82E77570; continue 'dispatch;
	}
	// 82E773EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E773F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E773F4: 4BFFFBD5  bl 0x82e76fc8
	ctx.lr = 0x82E773F8;
	sub_82E76FC8(ctx, base);
	// 82E773F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E773FC: 41820174  beq 0x82e77570
	if ctx.cr[0].eq {
	pc = 0x82E77570; continue 'dispatch;
	}
	// 82E77400: C01F0028  lfs f0, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77404: FF00C800  fcmpu cr6, f0, f25
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[25].f64);
	// 82E77408: 419A0178  beq cr6, 0x82e77580
	if ctx.cr[6].eq {
	pc = 0x82E77580; continue 'dispatch;
	}
	// 82E7740C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E77410: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82E77414: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E77418: 4B371261  bl 0x821e8678
	ctx.lr = 0x82E7741C;
	sub_821E8678(ctx, base);
	// 82E7741C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E77420: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E77424: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E77428: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E7742C: 4B37124D  bl 0x821e8678
	ctx.lr = 0x82E77430;
	sub_821E8678(ctx, base);
	// 82E77430: FC00C090  fmr f0, f24
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[24].f64;
	// 82E77434: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E77438: FDA0B890  fmr f13, f23
	ctx.f[13].f64 = ctx.f[23].f64;
	// 82E7743C: 419A000C  beq cr6, 0x82e77448
	if ctx.cr[6].eq {
	pc = 0x82E77448; continue 'dispatch;
	}
	// 82E77440: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E77444: EDAD05B2  fmuls f13, f13, f22
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[22].f64) as f32) as f64);
	// 82E77448: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E7744C: 419A000C  beq cr6, 0x82e77458
	if ctx.cr[6].eq {
	pc = 0x82E77458; continue 'dispatch;
	}
	// 82E77450: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77454: EC0005B2  fmuls f0, f0, f22
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[22].f64) as f32) as f64);
	// 82E77458: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E7745C: 4099000C  ble cr6, 0x82e77468
	if !ctx.cr[6].gt {
	pc = 0x82E77468; continue 'dispatch;
	}
	// 82E77460: FF800090  fmr f28, f0
	ctx.f[28].f64 = ctx.f[0].f64;
	// 82E77464: 48000008  b 0x82e7746c
	pc = 0x82E7746C; continue 'dispatch;
	// 82E77468: FF806890  fmr f28, f13
	ctx.f[28].f64 = ctx.f[13].f64;
	// 82E7746C: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E77470: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82E77474: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E77478: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E7747C: C1BB0004  lfs f13, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E77480: 38BE0034  addi r5, r30, 0x34
	ctx.r[5].s64 = ctx.r[30].s64 + 52;
	// 82E77484: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82E77488: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82E7748C: C1BB0008  lfs f13, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E77490: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E77494: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E77498: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7749C: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E774A0: C181006C  lfs f12, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E774A4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E774A8: C1210070  lfs f9, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E774AC: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E774B0: EC090032  fmuls f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E774B4: C17C0000  lfs f11, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E774B8: C15C0004  lfs f10, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E774BC: C13C0008  lfs f9, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E774C0: D3210050  stfs f25, 0x50(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E774C4: EDAB682A  fadds f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E774C8: D1A10080  stfs f13, 0x80(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82E774CC: EDAA602A  fadds f13, f10, f12
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E774D0: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82E774D4: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E774D8: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82E774DC: 4BFFC9F5  bl 0x82e73ed0
	ctx.lr = 0x82E774E0;
	sub_82E73ED0(ctx, base);
	// 82E774E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E774E4: 4182009C  beq 0x82e77580
	if ctx.cr[0].eq {
	pc = 0x82E77580; continue 'dispatch;
	}
	// 82E774E8: C01C0008  lfs f0, 8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E774EC: C1810060  lfs f12, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E774F0: EFE06028  fsubs f31, f0, f12
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E774F4: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E774F8: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E774FC: EFCD6028  fsubs f30, f13, f12
	ctx.f[30].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E77500: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77504: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E77508: C03F0028  lfs f1, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E7750C: EFA06828  fsubs f29, f0, f13
	ctx.f[29].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E77510: 4800E761  bl 0x82e85c70
	ctx.lr = 0x82E77514;
	sub_82E85C70(ctx, base);
	// 82E77514: FEA00890  fmr f21, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[21].f64 = ctx.f[1].f64;
	// 82E77518: C03F0028  lfs f1, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E7751C: 4800E725  bl 0x82e85c40
	ctx.lr = 0x82E77520;
	sub_82E85C40(ctx, base);
	// 82E77520: EC1E07B2  fmuls f0, f30, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E77524: FDA00890  fmr f13, f1
	ctx.f[13].f64 = ctx.f[1].f64;
	// 82E77528: C0210050  lfs f1, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E7752C: FC60E090  fmr f3, f28
	ctx.f[3].f64 = ctx.f[28].f64;
	// 82E77530: EC1D077A  fmadds f0, f29, f29, f0
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E77534: EDB56824  fdivs f13, f21, f13
	ctx.f[13].f64 = ((ctx.f[21].f64 / ctx.f[13].f64) as f32) as f64;
	// 82E77538: EC1F07FA  fmadds f0, f31, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E7753C: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E77540: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E77544: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82E77548: 4BFFC551  bl 0x82e73a98
	ctx.lr = 0x82E7754C;
	sub_82E73A98(ctx, base);
	// 82E7754C: EC1F07F2  fmuls f0, f31, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E77550: EC0006B2  fmuls f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 82E77554: EC010024  fdivs f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 / ctx.f[0].f64) as f32) as f64;
	// 82E77558: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82E7755C: 40990014  ble cr6, 0x82e77570
	if !ctx.cr[6].gt {
	pc = 0x82E77570; continue 'dispatch;
	}
	// 82E77560: C1BF0018  lfs f13, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E77564: FF600090  fmr f27, f0
	ctx.f[27].f64 = ctx.f[0].f64;
	// 82E77568: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E7756C: 4098001C  bge cr6, 0x82e77588
	if !ctx.cr[6].lt {
	pc = 0x82E77588; continue 'dispatch;
	}
	// 82E77570: 82F7000C  lwz r23, 0xc(r23)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E77574: 28170000  cmplwi r23, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E77578: 4082FE04  bne 0x82e7737c
	if !ctx.cr[0].eq {
	pc = 0x82E7737C; continue 'dispatch;
	}
	// 82E7757C: 4800000C  b 0x82e77588
	pc = 0x82E77588; continue 'dispatch;
	// 82E77580: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E77584: C36B0C14  lfs f27, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82E77588: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7758C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E77590: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82E77594: 41980008  blt cr6, 0x82e7759c
	if ctx.cr[6].lt {
	pc = 0x82E7759C; continue 'dispatch;
	}
	// 82E77598: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E7759C: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 82E775A0: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 82E775A4: 4BE36765  bl 0x82cadd08
	ctx.lr = 0x82E775A8;
	sub_82CADCEC(ctx, base);
	// 82E775A8: 4BE31E9C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E775B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E775B0 size=764
    let mut pc: u32 = 0x82E775B0;
    'dispatch: loop {
        match pc {
            0x82E775B0 => {
    //   block [0x82E775B0..0x82E778AC)
	// 82E775B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E775B4: 4BE31E51  bl 0x82ca9404
	ctx.lr = 0x82E775B8;
	sub_82CA93D0(ctx, base);
	// 82E775B8: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 82E775BC: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82E775C0: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82E775C4: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E775C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E775CC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82E775D0: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82E775D4: 48000028  b 0x82e775fc
	pc = 0x82E775FC; continue 'dispatch;
	// 82E775D8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E775DC: 9B6A0010  stb r27, 0x10(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[27].u8 ) };
	// 82E775E0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E775E4: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E775E8: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E775EC: 910A000C  stw r8, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82E775F0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E775F4: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82E775F8: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82E775FC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E77600: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E77604: 409AFFD4  bne cr6, 0x82e775d8
	if !ctx.cr[6].eq {
	pc = 0x82E775D8; continue 'dispatch;
	}
	// 82E77608: 936B000C  stw r27, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 82E7760C: 936B0014  stw r27, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[27].u32 ) };
	// 82E77610: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E77614: 9B7F001C  stb r27, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 82E77618: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7761C: 4182000C  beq 0x82e77628
	if ctx.cr[0].eq {
	pc = 0x82E77628; continue 'dispatch;
	}
	// 82E77620: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E77624: 48000008  b 0x82e7762c
	pc = 0x82E7762C; continue 'dispatch;
	// 82E77628: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E7762C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E77630: 419A0264  beq cr6, 0x82e77894
	if ctx.cr[6].eq {
	pc = 0x82E77894; continue 'dispatch;
	}
	// 82E77634: 897F00B8  lbz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82E77638: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82E7763C: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82E77640: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82E77644: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E77648: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82E7764C: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77650: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E77654: 4B41E3B5  bl 0x82295a08
	ctx.lr = 0x82E77658;
	sub_82295A08(ctx, base);
	// 82E77658: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82E7765C: C1BF00BC  lfs f13, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E77660: C3DF0024  lfs f30, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E77664: C03F0028  lfs f1, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E77668: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82E7766C: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E77670: 4800E601  bl 0x82e85c70
	ctx.lr = 0x82E77674;
	sub_82E85C70(ctx, base);
	// 82E77674: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82E77678: C03F0028  lfs f1, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E7767C: 4800E5C5  bl 0x82e85c40
	ctx.lr = 0x82E77680;
	sub_82E85C40(ctx, base);
	// 82E77680: EC1D0824  fdivs f0, f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[29].f64 / ctx.f[1].f64) as f32) as f64;
	// 82E77684: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E77688: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82E7768C: 4099001C  ble cr6, 0x82e776a8
	if !ctx.cr[6].gt {
	pc = 0x82E776A8; continue 'dispatch;
	}
	// 82E77690: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 82E77694: 4099000C  ble cr6, 0x82e776a0
	if !ctx.cr[6].gt {
	pc = 0x82E776A0; continue 'dispatch;
	}
	// 82E77698: FFA0F090  fmr f29, f30
	ctx.f[29].f64 = ctx.f[30].f64;
	// 82E7769C: 48000010  b 0x82e776ac
	pc = 0x82E776AC; continue 'dispatch;
	// 82E776A0: FFA0F890  fmr f29, f31
	ctx.f[29].f64 = ctx.f[31].f64;
	// 82E776A4: 48000008  b 0x82e776ac
	pc = 0x82E776AC; continue 'dispatch;
	// 82E776A8: FFA00090  fmr f29, f0
	ctx.f[29].f64 = ctx.f[0].f64;
	// 82E776AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E776B0: C1BF00AC  lfs f13, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E776B4: C19F0044  lfs f12, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E776B8: C17F0048  lfs f11, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E776BC: C15F0038  lfs f10, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E776C0: C13F003C  lfs f9, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E776C4: C00B0A4C  lfs f0, 0xa4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2636 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E776C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E776CC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E776D0: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E776D4: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E776D8: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 82E776DC: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E776E0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E776E4: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E776E8: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E776EC: C17F0034  lfs f11, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E776F0: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E776F4: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82E776F8: EDAA6028  fsubs f13, f10, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E776FC: D1A1008C  stfs f13, 0x8c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82E77700: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E77704: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82E77708: 409A0040  bne cr6, 0x82e77748
	if !ctx.cr[6].eq {
	pc = 0x82E77748; continue 'dispatch;
	}
	// 82E7770C: FC005890  fmr f0, f11
	ctx.f[0].f64 = ctx.f[11].f64;
	// 82E77710: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E77714: FD604890  fmr f11, f9
	ctx.f[11].f64 = ctx.f[9].f64;
	// 82E77718: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E7771C: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E77720: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E77724: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	// 82E77728: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E7772C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E77730: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E77734: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E77738: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E7773C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E77740: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E77744: 48000008  b 0x82e7774c
	pc = 0x82E7774C; continue 'dispatch;
	// 82E77748: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 82E7774C: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E77750: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E77754: C19F0044  lfs f12, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E77758: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E7775C: C17F0048  lfs f11, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E77760: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E77764: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E77768: C17F0034  lfs f11, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E7776C: C15F0038  lfs f10, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E77770: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E77774: C13F003C  lfs f9, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E77778: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82E7777C: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E77780: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82E77784: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82E77788: EDAB682A  fadds f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E7778C: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82E77790: EDAA602A  fadds f13, f10, f12
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E77794: D1A1007C  stfs f13, 0x7c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82E77798: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E7779C: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82E777A0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E777A4: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82E777A8: 48010501  bl 0x82e87ca8
	ctx.lr = 0x82E777AC;
	sub_82E87CA8(ctx, base);
	// 82E777AC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82E777B0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82E777B4: 418200E0  beq 0x82e77894
	if ctx.cr[0].eq {
	pc = 0x82E77894; continue 'dispatch;
	}
	// 82E777B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E777BC: 3BAB9128  addi r29, r11, -0x6ed8
	ctx.r[29].s64 = ctx.r[11].s64 + -28376;
	// 82E777C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E777C4: 3B8B9128  addi r28, r11, -0x6ed8
	ctx.r[28].s64 = ctx.r[11].s64 + -28376;
	// 82E777C8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E777CC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E777D0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E777D4: 419A00A0  beq cr6, 0x82e77874
	if ctx.cr[6].eq {
	pc = 0x82E77874; continue 'dispatch;
	}
	// 82E777D8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E777DC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E777E0: 419A0094  beq cr6, 0x82e77874
	if ctx.cr[6].eq {
	pc = 0x82E77874; continue 'dispatch;
	}
	// 82E777E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E777E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E777EC: 4BFFF60D  bl 0x82e76df8
	ctx.lr = 0x82E777F0;
	sub_82E76DF8(ctx, base);
	// 82E777F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E777F4: 40820080  bne 0x82e77874
	if !ctx.cr[0].eq {
	pc = 0x82E77874; continue 'dispatch;
	}
	// 82E777F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E777FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E77800: 4BFFF7C9  bl 0x82e76fc8
	ctx.lr = 0x82E77804;
	sub_82E76FC8(ctx, base);
	// 82E77804: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E77808: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E7780C: 409A0068  bne cr6, 0x82e77874
	if !ctx.cr[6].eq {
	pc = 0x82E77874; continue 'dispatch;
	}
	// 82E77810: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 82E77814: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E77818: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E7781C: 38BE0034  addi r5, r30, 0x34
	ctx.r[5].s64 = ctx.r[30].s64 + 52;
	// 82E77820: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82E77824: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82E77828: 4BFFC6A9  bl 0x82e73ed0
	ctx.lr = 0x82E7782C;
	sub_82E73ED0(ctx, base);
	// 82E7782C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E77830: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E77834: 409A0040  bne cr6, 0x82e77874
	if !ctx.cr[6].eq {
	pc = 0x82E77874; continue 'dispatch;
	}
	// 82E77838: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7783C: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82E77840: 40980034  bge cr6, 0x82e77874
	if !ctx.cr[6].lt {
	pc = 0x82E77874; continue 'dispatch;
	}
	// 82E77844: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82E77848: 809F00B4  lwz r4, 0xb4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82E7784C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E77850: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82E77854: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E77858: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82E7785C: 4BFFDE6D  bl 0x82e756c8
	ctx.lr = 0x82E77860;
	sub_82E756C8(ctx, base);
	// 82E77860: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E77864: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82E77868: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82E7786C: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E77870: 4082001C  bne 0x82e7788c
	if !ctx.cr[0].eq {
	pc = 0x82E7788C; continue 'dispatch;
	}
	// 82E77874: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E77878: 4800FEF9  bl 0x82e87770
	ctx.lr = 0x82E7787C;
	sub_82E87770(ctx, base);
	// 82E7787C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82E77880: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82E77884: 4082FF44  bne 0x82e777c8
	if !ctx.cr[0].eq {
	pc = 0x82E777C8; continue 'dispatch;
	}
	// 82E77888: 4800000C  b 0x82e77894
	pc = 0x82E77894; continue 'dispatch;
	// 82E7788C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E77890: 997F001C  stb r11, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82E77894: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E77898: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82E7789C: CBA1FFB8  lfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82E778A0: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82E778A4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82E778A8: 4BE31BAC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E778B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E778B0 size=520
    let mut pc: u32 = 0x82E778B0;
    'dispatch: loop {
        match pc {
            0x82E778B0 => {
    //   block [0x82E778B0..0x82E77AB8)
	// 82E778B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E778B4: 4BE31B51  bl 0x82ca9404
	ctx.lr = 0x82E778B8;
	sub_82CA93D0(ctx, base);
	// 82E778B8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82E778BC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E778C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E778C4: 4BFFF6B5  bl 0x82e76f78
	ctx.lr = 0x82E778C8;
	sub_82E76F78(ctx, base);
	// 82E778C8: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 82E778CC: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82E778D0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E778D4: 40820034  bne 0x82e77908
	if !ctx.cr[0].eq {
	pc = 0x82E77908; continue 'dispatch;
	}
	// 82E778D8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E778DC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82E778E0: 419A00F8  beq cr6, 0x82e779d8
	if ctx.cr[6].eq {
	pc = 0x82E779D8; continue 'dispatch;
	}
	// 82E778E4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E778E8: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E778EC: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E778F0: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E778F4: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E778F8: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E778FC: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E77900: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82E77904: 480000D4  b 0x82e779d8
	pc = 0x82E779D8; continue 'dispatch;
	// 82E77908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7790C: 4BFFDA55  bl 0x82e75360
	ctx.lr = 0x82E77910;
	sub_82E75360(ctx, base);
	// 82E77910: 4B3E90A9  bl 0x822609b8
	ctx.lr = 0x82E77914;
	sub_822609B8(ctx, base);
	// 82E77914: C01F00A0  lfs f0, 0xa0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77918: C3E3004C  lfs f31, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E7791C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82E77920: 409800B8  bge cr6, 0x82e779d8
	if !ctx.cr[6].lt {
	pc = 0x82E779D8; continue 'dispatch;
	}
	// 82E77924: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E77928: ED9F0028  fsubs f12, f31, f0
	ctx.f[12].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E7792C: C1BF0094  lfs f13, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E77930: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E77934: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77938: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E7793C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82E77940: 40990008  ble cr6, 0x82e77948
	if !ctx.cr[6].gt {
	pc = 0x82E77948; continue 'dispatch;
	}
	// 82E77944: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82E77948: 4B3E9071  bl 0x822609b8
	ctx.lr = 0x82E7794C;
	sub_822609B8(ctx, base);
	// 82E7794C: 57DD063E  clrlwi r29, r30, 0x18
	ctx.r[29].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82E77950: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E77954: 2B1D0001  cmplwi cr6, r29, 1
	ctx.cr[6].compare_u32(ctx.r[29].u32, 1 as u32, &mut ctx.xer);
	// 82E77958: 419A001C  beq cr6, 0x82e77974
	if ctx.cr[6].eq {
	pc = 0x82E77974; continue 'dispatch;
	}
	// 82E7795C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E77960: 809F008C  lwz r4, 0x8c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82E77964: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E77968: 4BFF8769  bl 0x82e700d0
	ctx.lr = 0x82E7796C;
	sub_82E700D0(ctx, base);
	// 82E7796C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E77970: 41820068  beq 0x82e779d8
	if ctx.cr[0].eq {
	pc = 0x82E779D8; continue 'dispatch;
	}
	// 82E77974: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E77978: C01F0094  lfs f0, 0x94(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7797C: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82E77980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E77984: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82E77988: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E7798C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E77990: 4E800421  bctrl
	ctx.lr = 0x82E77994;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E77994: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E77998: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E7799C: 409A0018  bne cr6, 0x82e779b4
	if !ctx.cr[6].eq {
	pc = 0x82E779B4; continue 'dispatch;
	}
	// 82E779A0: 389F0040  addi r4, r31, 0x40
	ctx.r[4].s64 = ctx.r[31].s64 + 64;
	// 82E779A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E779A8: 4BFFF841  bl 0x82e771e8
	ctx.lr = 0x82E779AC;
	sub_82E771E8(ctx, base);
	// 82E779AC: 987F0010  stb r3, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u8 ) };
	// 82E779B0: 4800000C  b 0x82e779bc
	pc = 0x82E779BC; continue 'dispatch;
	// 82E779B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E779B8: 997F0010  stb r11, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 82E779BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E779C0: 409A0018  bne cr6, 0x82e779d8
	if !ctx.cr[6].eq {
	pc = 0x82E779D8; continue 'dispatch;
	}
	// 82E779C4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E779C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E779CC: 809F008C  lwz r4, 0x8c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82E779D0: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E779D4: 4800A315  bl 0x82e81ce8
	ctx.lr = 0x82E779D8;
	sub_82E81CE8(ctx, base);
	// 82E779D8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E779DC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E779E0: 4198009C  blt cr6, 0x82e77a7c
	if ctx.cr[6].lt {
	pc = 0x82E77A7C; continue 'dispatch;
	}
	// 82E779E4: 419A007C  beq cr6, 0x82e77a60
	if ctx.cr[6].eq {
	pc = 0x82E77A60; continue 'dispatch;
	}
	// 82E779E8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82E779EC: 41980060  blt cr6, 0x82e77a4c
	if ctx.cr[6].lt {
	pc = 0x82E77A4C; continue 'dispatch;
	}
	// 82E779F0: 419A0048  beq cr6, 0x82e77a38
	if ctx.cr[6].eq {
	pc = 0x82E77A38; continue 'dispatch;
	}
	// 82E779F4: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82E779F8: 409800B4  bge cr6, 0x82e77aac
	if !ctx.cr[6].lt {
	pc = 0x82E77AAC; continue 'dispatch;
	}
	// 82E779FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E77A00: C1BF0024  lfs f13, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E77A04: C00B0C84  lfs f0, 0xc84(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77A08: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E77A0C: C1BF0030  lfs f13, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E77A10: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E77A14: 40980098  bge cr6, 0x82e77aac
	if !ctx.cr[6].lt {
	pc = 0x82E77AAC; continue 'dispatch;
	}
	// 82E77A18: 897F0011  lbz r11, 0x11(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E77A1C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E77A20: 40820070  bne 0x82e77a90
	if !ctx.cr[0].eq {
	pc = 0x82E77A90; continue 'dispatch;
	}
	// 82E77A24: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E77A28: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E77A2C: 41820080  beq 0x82e77aac
	if ctx.cr[0].eq {
	pc = 0x82E77AAC; continue 'dispatch;
	}
	// 82E77A30: 937F000C  stw r27, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 82E77A34: 48000078  b 0x82e77aac
	pc = 0x82E77AAC; continue 'dispatch;
	// 82E77A38: 4B3E8F81  bl 0x822609b8
	ctx.lr = 0x82E77A3C;
	sub_822609B8(ctx, base);
	// 82E77A3C: C01F00A8  lfs f0, 0xa8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77A40: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E77A44: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E77A48: 41990064  bgt cr6, 0x82e77aac
	if ctx.cr[6].gt {
	pc = 0x82E77AAC; continue 'dispatch;
	}
	// 82E77A4C: 897F0011  lbz r11, 0x11(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E77A50: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E77A54: 4082FFD0  bne 0x82e77a24
	if !ctx.cr[0].eq {
	pc = 0x82E77A24; continue 'dispatch;
	}
	// 82E77A58: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82E77A5C: 48000050  b 0x82e77aac
	pc = 0x82E77AAC; continue 'dispatch;
	// 82E77A60: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E77A64: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E77A68: 40820044  bne 0x82e77aac
	if !ctx.cr[0].eq {
	pc = 0x82E77AAC; continue 'dispatch;
	}
	// 82E77A6C: 897F0011  lbz r11, 0x11(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E77A70: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E77A74: 4082001C  bne 0x82e77a90
	if !ctx.cr[0].eq {
	pc = 0x82E77A90; continue 'dispatch;
	}
	// 82E77A78: 4BFFFFE0  b 0x82e77a58
	pc = 0x82E77A58; continue 'dispatch;
	// 82E77A7C: 4B3E8F3D  bl 0x822609b8
	ctx.lr = 0x82E77A80;
	sub_822609B8(ctx, base);
	// 82E77A80: C01F00A4  lfs f0, 0xa4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77A84: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E77A88: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E77A8C: 40980020  bge cr6, 0x82e77aac
	if !ctx.cr[6].lt {
	pc = 0x82E77AAC; continue 'dispatch;
	}
	// 82E77A90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E77A94: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82E77A98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E77A9C: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E77AA0: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82E77AA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E77AA8: 4E800421  bctrl
	ctx.lr = 0x82E77AAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E77AAC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E77AB0: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82E77AB4: 4BE319A0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E77AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E77AB8 size=64
    let mut pc: u32 = 0x82E77AB8;
    'dispatch: loop {
        match pc {
            0x82E77AB8 => {
    //   block [0x82E77AB8..0x82E77AF8)
	// 82E77AB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E77ABC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E77AC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E77AC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E77AC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E77ACC: 4B3F1A95  bl 0x82269560
	ctx.lr = 0x82E77AD0;
	sub_82269560(ctx, base);
	// 82E77AD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E77AD4: 4BFFFDDD  bl 0x82e778b0
	ctx.lr = 0x82E77AD8;
	sub_82E778B0(ctx, base);
	// 82E77AD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E77ADC: 4BFFEA8D  bl 0x82e76568
	ctx.lr = 0x82E77AE0;
	sub_82E76568(ctx, base);
	// 82E77AE0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E77AE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E77AE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E77AEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E77AF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E77AF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E77AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E77AF8 size=172
    let mut pc: u32 = 0x82E77AF8;
    'dispatch: loop {
        match pc {
            0x82E77AF8 => {
    //   block [0x82E77AF8..0x82E77BA4)
	// 82E77AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E77AFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E77B00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E77B04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E77B08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E77B0C: 480116CD  bl 0x82e891d8
	ctx.lr = 0x82E77B10;
	sub_82E891D8(ctx, base);
	// 82E77B10: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E77B14: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E77B18: 394B8B08  addi r10, r11, -0x74f8
	ctx.r[10].s64 = ctx.r[11].s64 + -29944;
	// 82E77B1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E77B20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E77B24: C0090C18  lfs f0, 0xc18(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77B28: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E77B2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E77B30: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82E77B34: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E77B38: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82E77B3C: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E77B40: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E77B44: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82E77B48: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E77B4C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82E77B50: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E77B54: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82E77B58: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82E77B5C: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82E77B60: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82E77B64: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82E77B68: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82E77B6C: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82E77B70: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82E77B74: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82E77B78: 995F004C  stb r10, 0x4c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[10].u8 ) };
	// 82E77B7C: 995F004D  stb r10, 0x4d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(77 as u32), ctx.r[10].u8 ) };
	// 82E77B80: 997F004E  stb r11, 0x4e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(78 as u32), ctx.r[11].u8 ) };
	// 82E77B84: 997F004F  stb r11, 0x4f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(79 as u32), ctx.r[11].u8 ) };
	// 82E77B88: 997F0054  stb r11, 0x54(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u8 ) };
	// 82E77B8C: 997F005C  stb r11, 0x5c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u8 ) };
	// 82E77B90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E77B94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E77B98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E77B9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E77BA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E77BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E77BA8 size=12
    let mut pc: u32 = 0x82E77BA8;
    'dispatch: loop {
        match pc {
            0x82E77BA8 => {
    //   block [0x82E77BA8..0x82E77BB4)
	// 82E77BA8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E77BAC: 386BBF50  addi r3, r11, -0x40b0
	ctx.r[3].s64 = ctx.r[11].s64 + -16560;
	// 82E77BB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E77BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E77BB8 size=20
    let mut pc: u32 = 0x82E77BB8;
    'dispatch: loop {
        match pc {
            0x82E77BB8 => {
    //   block [0x82E77BB8..0x82E77BCC)
	// 82E77BB8: 81630044  lwz r11, 0x44(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E77BBC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E77BC0: 4082000C  bne 0x82e77bcc
	if !ctx.cr[0].eq {
		sub_82E77BCC(ctx, base);
		return;
	}
	// 82E77BC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E77BC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E77BCC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E77BCC size=20
    let mut pc: u32 = 0x82E77BCC;
    'dispatch: loop {
        match pc {
            0x82E77BCC => {
    //   block [0x82E77BCC..0x82E77BE0)
	// 82E77BCC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E77BD0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82E77BD4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82E77BD8: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82E77BDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E77BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E77BE0 size=892
    let mut pc: u32 = 0x82E77BE0;
    'dispatch: loop {
        match pc {
            0x82E77BE0 => {
    //   block [0x82E77BE0..0x82E77F5C)
	// 82E77BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E77BE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E77BE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E77BEC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E77BF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E77BF4: 4B3F196D  bl 0x82269560
	ctx.lr = 0x82E77BF8;
	sub_82269560(ctx, base);
	// 82E77BF8: 897F004D  lbz r11, 0x4d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(77 as u32) ) } as u64;
	// 82E77BFC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E77C00: 40820344  bne 0x82e77f44
	if !ctx.cr[0].eq {
	pc = 0x82E77F44; continue 'dispatch;
	}
	// 82E77C04: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E77C08: 809F0048  lwz r4, 0x48(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E77C0C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E77C10: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E77C14: 4099000C  ble cr6, 0x82e77c20
	if !ctx.cr[6].gt {
	pc = 0x82E77C20; continue 'dispatch;
	}
	// 82E77C18: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E77C1C: 4800032C  b 0x82e77f48
	pc = 0x82E77F48; continue 'dispatch;
	// 82E77C20: 895F004C  lbz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82E77C24: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E77C28: 418200B8  beq 0x82e77ce0
	if ctx.cr[0].eq {
	pc = 0x82E77CE0; continue 'dispatch;
	}
	// 82E77C2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E77C30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E77C34: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E77C38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E77C3C: 4E800421  bctrl
	ctx.lr = 0x82E77C40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E77C40: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E77C44: 41820300  beq 0x82e77f44
	if ctx.cr[0].eq {
	pc = 0x82E77F44; continue 'dispatch;
	}
	// 82E77C48: 897F004E  lbz r11, 0x4e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(78 as u32) ) } as u64;
	// 82E77C4C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E77C50: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E77C54: 4182004C  beq 0x82e77ca0
	if ctx.cr[0].eq {
	pc = 0x82E77CA0; continue 'dispatch;
	}
	// 82E77C58: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E77C5C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E77C60: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E77C64: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82E77C68: 995F004C  stb r10, 0x4c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[10].u8 ) };
	// 82E77C6C: 409A02D8  bne cr6, 0x82e77f44
	if !ctx.cr[6].eq {
	pc = 0x82E77F44; continue 'dispatch;
	}
	// 82E77C70: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E77C74: 894B000C  lbz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E77C78: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E77C7C: 41820010  beq 0x82e77c8c
	if ctx.cr[0].eq {
	pc = 0x82E77C8C; continue 'dispatch;
	}
	// 82E77C80: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E77C84: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E77C88: 48000010  b 0x82e77c98
	pc = 0x82E77C98; continue 'dispatch;
	// 82E77C8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E77C90: 995F004D  stb r10, 0x4d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(77 as u32), ctx.r[10].u8 ) };
	// 82E77C94: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E77C98: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82E77C9C: 480002A8  b 0x82e77f44
	pc = 0x82E77F44; continue 'dispatch;
	// 82E77CA0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E77CA4: 815F0044  lwz r10, 0x44(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E77CA8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E77CAC: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82E77CB0: 993F004C  stb r9, 0x4c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[9].u8 ) };
	// 82E77CB4: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E77CB8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82E77CBC: 41980288  blt cr6, 0x82e77f44
	if ctx.cr[6].lt {
	pc = 0x82E77F44; continue 'dispatch;
	}
	// 82E77CC0: 896A000C  lbz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E77CC4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E77CC8: 4182000C  beq 0x82e77cd4
	if ctx.cr[0].eq {
	pc = 0x82E77CD4; continue 'dispatch;
	}
	// 82E77CCC: 913F0048  stw r9, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[9].u32 ) };
	// 82E77CD0: 48000274  b 0x82e77f44
	pc = 0x82E77F44; continue 'dispatch;
	// 82E77CD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E77CD8: 997F004D  stb r11, 0x4d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(77 as u32), ctx.r[11].u8 ) };
	// 82E77CDC: 48000268  b 0x82e77f44
	pc = 0x82E77F44; continue 'dispatch;
	// 82E77CE0: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E77CE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E77CE8: 4182FF30  beq 0x82e77c18
	if ctx.cr[0].eq {
	pc = 0x82E77C18; continue 'dispatch;
	}
	// 82E77CEC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E77CF0: 1D640090  mulli r11, r4, 0x90
	ctx.r[11].s64 = ctx.r[4].s64 * 144;
	// 82E77CF4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E77CF8: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82E77CFC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82E77D00: 394A8B50  addi r10, r10, -0x74b0
	ctx.r[10].s64 = ctx.r[10].s64 + -29872;
	// 82E77D04: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E77D08: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E77D0C: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E77D10: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82E77D14: 41820014  beq 0x82e77d28
	if ctx.cr[0].eq {
	pc = 0x82E77D28; continue 'dispatch;
	}
	// 82E77D18: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E77D1C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E77D20: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E77D24: 419AFFE0  beq cr6, 0x82e77d04
	if ctx.cr[6].eq {
	pc = 0x82E77D04; continue 'dispatch;
	}
	// 82E77D28: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E77D2C: 40820018  bne 0x82e77d44
	if !ctx.cr[0].eq {
	pc = 0x82E77D44; continue 'dispatch;
	}
	// 82E77D30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E77D34: C03F003C  lfs f1, 0x3c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E77D38: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E77D3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E77D40: 4E800421  bctrl
	ctx.lr = 0x82E77D44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E77D44: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E77D48: 813F0044  lwz r9, 0x44(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E77D4C: 394B8B4C  addi r10, r11, -0x74b4
	ctx.r[10].s64 = ctx.r[11].s64 + -29876;
	// 82E77D50: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E77D54: 1D6B0090  mulli r11, r11, 0x90
	ctx.r[11].s64 = ctx.r[11].s64 * 144;
	// 82E77D58: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E77D5C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82E77D60: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82E77D64: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E77D68: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E77D6C: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E77D70: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82E77D74: 41820014  beq 0x82e77d88
	if ctx.cr[0].eq {
	pc = 0x82E77D88; continue 'dispatch;
	}
	// 82E77D78: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E77D7C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E77D80: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E77D84: 419AFFE0  beq cr6, 0x82e77d64
	if ctx.cr[6].eq {
	pc = 0x82E77D64; continue 'dispatch;
	}
	// 82E77D88: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E77D8C: 4082001C  bne 0x82e77da8
	if !ctx.cr[0].eq {
	pc = 0x82E77DA8; continue 'dispatch;
	}
	// 82E77D90: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E77D94: C03F0040  lfs f1, 0x40(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E77D98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E77D9C: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E77DA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E77DA4: 4E800421  bctrl
	ctx.lr = 0x82E77DA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E77DA8: 815F0044  lwz r10, 0x44(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E77DAC: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E77DB0: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E77DB4: 1D6B0090  mulli r11, r11, 0x90
	ctx.r[11].s64 = ctx.r[11].s64 * 144;
	// 82E77DB8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E77DBC: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E77DC0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E77DC4: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77DC8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E77DCC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77DD0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E77DD4: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E77DD8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E77DDC: 4182001C  beq 0x82e77df8
	if ctx.cr[0].eq {
	pc = 0x82E77DF8; continue 'dispatch;
	}
	// 82E77DE0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E77DE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E77DE8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E77DEC: C02B0C18  lfs f1, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E77DF0: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E77DF4: 4B431425  bl 0x822a9218
	ctx.lr = 0x82E77DF8;
	sub_822A9218(ctx, base);
	// 82E77DF8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E77DFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E77E00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E77E04: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E77E08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E77E0C: 4E800421  bctrl
	ctx.lr = 0x82E77E10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E77E10: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E77E14: 41820110  beq 0x82e77f24
	if ctx.cr[0].eq {
	pc = 0x82E77F24; continue 'dispatch;
	}
	// 82E77E18: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E77E1C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E77E20: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E77E24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E77E28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E77E2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E77E30: 4E800421  bctrl
	ctx.lr = 0x82E77E34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E77E34: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E77E38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E77E3C: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E77E40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E77E44: 4E800421  bctrl
	ctx.lr = 0x82E77E48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E77E48: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E77E4C: 41820010  beq 0x82e77e5c
	if ctx.cr[0].eq {
	pc = 0x82E77E5C; continue 'dispatch;
	}
	// 82E77E50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E77E54: 997F004C  stb r11, 0x4c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u8 ) };
	// 82E77E58: 480000EC  b 0x82e77f44
	pc = 0x82E77F44; continue 'dispatch;
	// 82E77E5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E77E60: 813F0044  lwz r9, 0x44(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E77E64: 394B8B44  addi r10, r11, -0x74bc
	ctx.r[10].s64 = ctx.r[11].s64 + -29884;
	// 82E77E68: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E77E6C: 1D6B0090  mulli r11, r11, 0x90
	ctx.r[11].s64 = ctx.r[11].s64 * 144;
	// 82E77E70: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E77E74: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82E77E78: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82E77E7C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E77E80: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E77E84: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E77E88: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82E77E8C: 41820014  beq 0x82e77ea0
	if ctx.cr[0].eq {
	pc = 0x82E77EA0; continue 'dispatch;
	}
	// 82E77E90: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E77E94: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E77E98: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E77E9C: 419AFFE0  beq cr6, 0x82e77e7c
	if ctx.cr[6].eq {
	pc = 0x82E77E7C; continue 'dispatch;
	}
	// 82E77EA0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82E77EA4: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E77EA8: 40820018  bne 0x82e77ec0
	if !ctx.cr[0].eq {
	pc = 0x82E77EC0; continue 'dispatch;
	}
	// 82E77EAC: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E77EB0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E77EB4: 4182000C  beq 0x82e77ec0
	if ctx.cr[0].eq {
	pc = 0x82E77EC0; continue 'dispatch;
	}
	// 82E77EB8: 98EB0008  stb r7, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u8 ) };
	// 82E77EBC: 98EB0004  stb r7, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u8 ) };
	// 82E77EC0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E77EC4: 813F0044  lwz r9, 0x44(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E77EC8: 394B8B3C  addi r10, r11, -0x74c4
	ctx.r[10].s64 = ctx.r[11].s64 + -29892;
	// 82E77ECC: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E77ED0: 1D6B0090  mulli r11, r11, 0x90
	ctx.r[11].s64 = ctx.r[11].s64 * 144;
	// 82E77ED4: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E77ED8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82E77EDC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82E77EE0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E77EE4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E77EE8: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E77EEC: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82E77EF0: 41820014  beq 0x82e77f04
	if ctx.cr[0].eq {
	pc = 0x82E77F04; continue 'dispatch;
	}
	// 82E77EF4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E77EF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E77EFC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E77F00: 419AFFE0  beq cr6, 0x82e77ee0
	if ctx.cr[6].eq {
	pc = 0x82E77EE0; continue 'dispatch;
	}
	// 82E77F04: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E77F08: 4082003C  bne 0x82e77f44
	if !ctx.cr[0].eq {
	pc = 0x82E77F44; continue 'dispatch;
	}
	// 82E77F0C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E77F10: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E77F14: 41820030  beq 0x82e77f44
	if ctx.cr[0].eq {
	pc = 0x82E77F44; continue 'dispatch;
	}
	// 82E77F18: 98EB0008  stb r7, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u8 ) };
	// 82E77F1C: 98EB0004  stb r7, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u8 ) };
	// 82E77F20: 48000024  b 0x82e77f44
	pc = 0x82E77F44; continue 'dispatch;
	// 82E77F24: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E77F28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E77F2C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E77F30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E77F34: 4E800421  bctrl
	ctx.lr = 0x82E77F38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E77F38: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82E77F3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E77F40: 419A0008  beq cr6, 0x82e77f48
	if ctx.cr[6].eq {
	pc = 0x82E77F48; continue 'dispatch;
	}
	// 82E77F44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E77F48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E77F4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E77F50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E77F54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E77F58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E77F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E77F60 size=44
    let mut pc: u32 = 0x82E77F60;
    'dispatch: loop {
        match pc {
            0x82E77F60 => {
    //   block [0x82E77F60..0x82E77F8C)
	// 82E77F60: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E77F64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E77F68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E77F6C: 409A0008  bne cr6, 0x82e77f74
	if !ctx.cr[6].eq {
	pc = 0x82E77F74; continue 'dispatch;
	}
	// 82E77F70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E77F74: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E77F78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E77F7C: 409A0008  bne cr6, 0x82e77f84
	if !ctx.cr[6].eq {
	pc = 0x82E77F84; continue 'dispatch;
	}
	// 82E77F80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E77F84: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E77F88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E77F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E77F90 size=96
    let mut pc: u32 = 0x82E77F90;
    'dispatch: loop {
        match pc {
            0x82E77F90 => {
    //   block [0x82E77F90..0x82E77FF0)
	// 82E77F90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E77F94: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E77F98: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E77F9C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E77FA0: 40820014  bne 0x82e77fb4
	if !ctx.cr[0].eq {
	pc = 0x82E77FB4; continue 'dispatch;
	}
	// 82E77FA4: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E77FA8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E77FAC: 409A0008  bne cr6, 0x82e77fb4
	if !ctx.cr[6].eq {
	pc = 0x82E77FB4; continue 'dispatch;
	}
	// 82E77FB0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E77FB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E77FB8: 419A0014  beq cr6, 0x82e77fcc
	if ctx.cr[6].eq {
	pc = 0x82E77FCC; continue 'dispatch;
	}
	// 82E77FBC: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E77FC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E77FC4: 419A0008  beq cr6, 0x82e77fcc
	if ctx.cr[6].eq {
	pc = 0x82E77FCC; continue 'dispatch;
	}
	// 82E77FC8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E77FCC: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E77FD0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E77FD4: 40820014  bne 0x82e77fe8
	if !ctx.cr[0].eq {
	pc = 0x82E77FE8; continue 'dispatch;
	}
	// 82E77FD8: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E77FDC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E77FE0: 409A0008  bne cr6, 0x82e77fe8
	if !ctx.cr[6].eq {
	pc = 0x82E77FE8; continue 'dispatch;
	}
	// 82E77FE4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E77FE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E77FEC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E77FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E77FF0 size=12
    let mut pc: u32 = 0x82E77FF0;
    'dispatch: loop {
        match pc {
            0x82E77FF0 => {
    //   block [0x82E77FF0..0x82E77FFC)
	// 82E77FF0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E77FF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E77FF8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E77FFC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E77FFC size=8
    let mut pc: u32 = 0x82E77FFC;
    'dispatch: loop {
        match pc {
            0x82E77FFC => {
    //   block [0x82E77FFC..0x82E78004)
	// 82E77FFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E78000: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E78008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E78008 size=1440
    let mut pc: u32 = 0x82E78008;
    'dispatch: loop {
        match pc {
            0x82E78008 => {
    //   block [0x82E78008..0x82E785A8)
	// 82E78008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7800C: 4BE313FD  bl 0x82ca9408
	ctx.lr = 0x82E78010;
	sub_82CA93D0(ctx, base);
	// 82E78010: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82E78014: 4BE35CC1  bl 0x82cadcd4
	ctx.lr = 0x82E78018;
	sub_82CADCA0(ctx, base);
	// 82E78018: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7801C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E78020: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E78024: 1D440090  mulli r10, r4, 0x90
	ctx.r[10].s64 = ctx.r[4].s64 * 144;
	// 82E78028: 813F0044  lwz r9, 0x44(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E7802C: 388B8B68  addi r4, r11, -0x7498
	ctx.r[4].s64 = ctx.r[11].s64 + -29848;
	// 82E78030: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78034: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82E78038: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E7803C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E78040: 386B0050  addi r3, r11, 0x50
	ctx.r[3].s64 = ctx.r[11].s64 + 80;
	// 82E78044: 4BE35B95  bl 0x82cadbd8
	ctx.lr = 0x82E78048;
	sub_82CADBD8(ctx, base);
	// 82E78048: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82E7804C: 4098000C  bge cr6, 0x82e78058
	if !ctx.cr[6].lt {
	pc = 0x82E78058; continue 'dispatch;
	}
	// 82E78050: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E78054: 48000544  b 0x82e78598
	pc = 0x82E78598; continue 'dispatch;
	// 82E78058: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E7805C: 4BE33B55  bl 0x82cabbb0
	ctx.lr = 0x82E78060;
	sub_82CABBB0(ctx, base);
	// 82E78060: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82E78064: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82E78068: FFE00818  frsp f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E7806C: 392BE1F0  addi r9, r11, -0x1e10
	ctx.r[9].s64 = ctx.r[11].s64 + -7696;
	// 82E78070: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E78074: 89690000  lbz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E78078: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E7807C: 7D6B4050  subf r11, r11, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82E78080: 41820014  beq 0x82e78094
	if ctx.cr[0].eq {
	pc = 0x82E78094; continue 'dispatch;
	}
	// 82E78084: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E78088: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E7808C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E78090: 419AFFE0  beq cr6, 0x82e78070
	if ctx.cr[6].eq {
	pc = 0x82E78070; continue 'dispatch;
	}
	// 82E78094: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E78098: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82E7809C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E780A0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E780A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E780A8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E780AC: C3C80AB4  lfs f30, 0xab4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2740 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E780B0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82E780B4: C3A90C14  lfs f29, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82E780B8: 3FA08334  lis r29, -0x7ccc
	ctx.r[29].s64 = -2093744128;
	// 82E780BC: C38A0C18  lfs f28, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82E780C0: C36B0EE0  lfs f27, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82E780C4: 408200D8  bne 0x82e7819c
	if !ctx.cr[0].eq {
	pc = 0x82E7819C; continue 'dispatch;
	}
	// 82E780C8: 897F004F  lbz r11, 0x4f(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(79 as u32) ) } as u64;
	// 82E780CC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E780D0: 40820018  bne 0x82e780e8
	if !ctx.cr[0].eq {
	pc = 0x82E780E8; continue 'dispatch;
	}
	// 82E780D4: 4B3E88E5  bl 0x822609b8
	ctx.lr = 0x82E780D8;
	sub_822609B8(ctx, base);
	// 82E780D8: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E780DC: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82E780E0: 9BDF004F  stb r30, 0x4f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(79 as u32), ctx.r[30].u8 ) };
	// 82E780E4: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E780E8: 897F004F  lbz r11, 0x4f(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(79 as u32) ) } as u64;
	// 82E780EC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E780F0: 418200AC  beq 0x82e7819c
	if ctx.cr[0].eq {
	pc = 0x82E7819C; continue 'dispatch;
	}
	// 82E780F4: 4B3E88C5  bl 0x822609b8
	ctx.lr = 0x82E780F8;
	sub_822609B8(ctx, base);
	// 82E780F8: C01F0050  lfs f0, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E780FC: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E78100: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E78104: 40990094  ble cr6, 0x82e78198
	if !ctx.cr[6].gt {
	pc = 0x82E78198; continue 'dispatch;
	}
	// 82E78108: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E7810C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78110: 4182000C  beq 0x82e7811c
	if ctx.cr[0].eq {
	pc = 0x82E7811C; continue 'dispatch;
	}
	// 82E78114: D38B0008  stfs f28, 8(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E78118: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82E7811C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E78120: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78124: 41820078  beq 0x82e7819c
	if ctx.cr[0].eq {
	pc = 0x82E7819C; continue 'dispatch;
	}
	// 82E78128: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E7812C: 815D0718  lwz r10, 0x718(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E78130: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78134: 81290014  lwz r9, 0x14(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E78138: C1A90058  lfs f13, 0x58(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E7813C: 4182000C  beq 0x82e78148
	if ctx.cr[0].eq {
	pc = 0x82E78148; continue 'dispatch;
	}
	// 82E78140: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78144: 48000008  b 0x82e7814c
	pc = 0x82E7814C; continue 'dispatch;
	// 82E78148: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 82E7814C: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E78150: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E78154: 40990010  ble cr6, 0x82e78164
	if !ctx.cr[6].gt {
	pc = 0x82E78164; continue 'dispatch;
	}
	// 82E78158: D36B0008  stfs f27, 8(r11)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E7815C: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82E78160: 4800003C  b 0x82e7819c
	pc = 0x82E7819C; continue 'dispatch;
	// 82E78164: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78168: 4182000C  beq 0x82e78174
	if ctx.cr[0].eq {
	pc = 0x82E78174; continue 'dispatch;
	}
	// 82E7816C: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78170: 48000008  b 0x82e78178
	pc = 0x82E78178; continue 'dispatch;
	// 82E78174: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 82E78178: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E7817C: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82E78180: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E78184: 4098000C  bge cr6, 0x82e78190
	if !ctx.cr[6].lt {
	pc = 0x82E78190; continue 'dispatch;
	}
	// 82E78188: D3AB0008  stfs f29, 8(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E7818C: 48000010  b 0x82e7819c
	pc = 0x82E7819C; continue 'dispatch;
	// 82E78190: D38B0008  stfs f28, 8(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E78194: 48000008  b 0x82e7819c
	pc = 0x82E7819C; continue 'dispatch;
	// 82E78198: 9B9F004F  stb r28, 0x4f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(79 as u32), ctx.r[28].u8 ) };
	// 82E7819C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E781A0: 394B8B60  addi r10, r11, -0x74a0
	ctx.r[10].s64 = ctx.r[11].s64 + -29856;
	// 82E781A4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E781A8: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E781AC: 892A0000  lbz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E781B0: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E781B4: 7D294050  subf r9, r9, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82E781B8: 41820014  beq 0x82e781cc
	if ctx.cr[0].eq {
	pc = 0x82E781CC; continue 'dispatch;
	}
	// 82E781BC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E781C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E781C4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82E781C8: 419AFFE0  beq cr6, 0x82e781a8
	if ctx.cr[6].eq {
	pc = 0x82E781A8; continue 'dispatch;
	}
	// 82E781CC: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E781D0: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82E781D4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82E781D8: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82E781DC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82E781E0: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82E781E4: C18789CC  lfs f12, -0x7634(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E781E8: C1480A44  lfs f10, 0xa44(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2628 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E781EC: C16989C8  lfs f11, -0x7638(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-30264 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E781F0: C12A8B04  lfs f9, -0x74fc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-29948 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E781F4: C10B15E4  lfs f8, 0x15e4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5604 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82E781F8: 408201A4  bne 0x82e7839c
	if !ctx.cr[0].eq {
	pc = 0x82E7839C; continue 'dispatch;
	}
	// 82E781FC: 897F0054  lbz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E78200: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78204: 4082004C  bne 0x82e78250
	if !ctx.cr[0].eq {
	pc = 0x82E78250; continue 'dispatch;
	}
	// 82E78208: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E7820C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E78210: C00B0044  lfs f0, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78214: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82E78218: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E7821C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82E78220: 4198000C  blt cr6, 0x82e7822c
	if ctx.cr[6].lt {
	pc = 0x82E7822C; continue 'dispatch;
	}
	// 82E78224: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82E78228: 40990024  ble cr6, 0x82e7824c
	if !ctx.cr[6].gt {
	pc = 0x82E7824C; continue 'dispatch;
	}
	// 82E7822C: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82E78230: 4099000C  ble cr6, 0x82e7823c
	if !ctx.cr[6].gt {
	pc = 0x82E7823C; continue 'dispatch;
	}
	// 82E78234: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E78238: 4BFFFFE0  b 0x82e78218
	pc = 0x82E78218; continue 'dispatch;
	// 82E7823C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82E78240: 4098FFD8  bge cr6, 0x82e78218
	if !ctx.cr[6].lt {
	pc = 0x82E78218; continue 'dispatch;
	}
	// 82E78244: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E78248: 4BFFFFD0  b 0x82e78218
	pc = 0x82E78218; continue 'dispatch;
	// 82E7824C: 9BDF0054  stb r30, 0x54(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u8 ) };
	// 82E78250: 897F0054  lbz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E78254: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78258: 41820144  beq 0x82e7839c
	if ctx.cr[0].eq {
	pc = 0x82E7839C; continue 'dispatch;
	}
	// 82E7825C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E78260: C01F0058  lfs f0, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78264: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E78268: C1AB0044  lfs f13, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E7826C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E78270: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82E78274: 4198000C  blt cr6, 0x82e78280
	if ctx.cr[6].lt {
	pc = 0x82E78280; continue 'dispatch;
	}
	// 82E78278: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82E7827C: 40990024  ble cr6, 0x82e782a0
	if !ctx.cr[6].gt {
	pc = 0x82E782A0; continue 'dispatch;
	}
	// 82E78280: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82E78284: 4099000C  ble cr6, 0x82e78290
	if !ctx.cr[6].gt {
	pc = 0x82E78290; continue 'dispatch;
	}
	// 82E78288: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E7828C: 4BFFFFE4  b 0x82e78270
	pc = 0x82E78270; continue 'dispatch;
	// 82E78290: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82E78294: 4098FFDC  bge cr6, 0x82e78270
	if !ctx.cr[6].lt {
	pc = 0x82E78270; continue 'dispatch;
	}
	// 82E78298: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E7829C: 4BFFFFD4  b 0x82e78270
	pc = 0x82E78270; continue 'dispatch;
	// 82E782A0: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82E782A4: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 82E782A8: 409900F0  ble cr6, 0x82e78398
	if !ctx.cr[6].gt {
	pc = 0x82E78398; continue 'dispatch;
	}
	// 82E782AC: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E782B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E782B4: 4182000C  beq 0x82e782c0
	if ctx.cr[0].eq {
	pc = 0x82E782C0; continue 'dispatch;
	}
	// 82E782B8: D38B0008  stfs f28, 8(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E782BC: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82E782C0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E782C4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E782C8: 4182006C  beq 0x82e78334
	if ctx.cr[0].eq {
	pc = 0x82E78334; continue 'dispatch;
	}
	// 82E782CC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E782D0: 815D0718  lwz r10, 0x718(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E782D4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E782D8: 81290014  lwz r9, 0x14(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E782DC: C1A90058  lfs f13, 0x58(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E782E0: 4182000C  beq 0x82e782ec
	if ctx.cr[0].eq {
	pc = 0x82E782EC; continue 'dispatch;
	}
	// 82E782E4: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E782E8: 48000008  b 0x82e782f0
	pc = 0x82E782F0; continue 'dispatch;
	// 82E782EC: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 82E782F0: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E782F4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E782F8: 4099000C  ble cr6, 0x82e78304
	if !ctx.cr[6].gt {
	pc = 0x82E78304; continue 'dispatch;
	}
	// 82E782FC: D36B0008  stfs f27, 8(r11)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E78300: 48000030  b 0x82e78330
	pc = 0x82E78330; continue 'dispatch;
	// 82E78304: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78308: 4182000C  beq 0x82e78314
	if ctx.cr[0].eq {
	pc = 0x82E78314; continue 'dispatch;
	}
	// 82E7830C: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78310: 48000008  b 0x82e78318
	pc = 0x82E78318; continue 'dispatch;
	// 82E78314: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 82E78318: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E7831C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E78320: 4098000C  bge cr6, 0x82e7832c
	if !ctx.cr[6].lt {
	pc = 0x82E7832C; continue 'dispatch;
	}
	// 82E78324: D3AB0008  stfs f29, 8(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E78328: 48000008  b 0x82e78330
	pc = 0x82E78330; continue 'dispatch;
	// 82E7832C: D38B0008  stfs f28, 8(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E78330: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82E78334: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E78338: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7833C: 41820010  beq 0x82e7834c
	if ctx.cr[0].eq {
	pc = 0x82E7834C; continue 'dispatch;
	}
	// 82E78340: C01F0058  lfs f0, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78344: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82E78348: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E7834C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E78350: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78354: 41820048  beq 0x82e7839c
	if ctx.cr[0].eq {
	pc = 0x82E7839C; continue 'dispatch;
	}
	// 82E78358: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E7835C: C01F0058  lfs f0, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78360: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E78364: C1AA0044  lfs f13, 0x44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E78368: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82E7836C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E78370: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 82E78374: 4099000C  ble cr6, 0x82e78380
	if !ctx.cr[6].gt {
	pc = 0x82E78380; continue 'dispatch;
	}
	// 82E78378: D3AB0008  stfs f29, 8(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E7837C: 48000020  b 0x82e7839c
	pc = 0x82E7839C; continue 'dispatch;
	// 82E78380: FF004000  fcmpu cr6, f0, f8
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[8].f64);
	// 82E78384: 4098000C  bge cr6, 0x82e78390
	if !ctx.cr[6].lt {
	pc = 0x82E78390; continue 'dispatch;
	}
	// 82E78388: D36B0008  stfs f27, 8(r11)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E7838C: 48000010  b 0x82e7839c
	pc = 0x82E7839C; continue 'dispatch;
	// 82E78390: D38B0008  stfs f28, 8(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E78394: 48000008  b 0x82e7839c
	pc = 0x82E7839C; continue 'dispatch;
	// 82E78398: 9B9F0054  stb r28, 0x54(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[28].u8 ) };
	// 82E7839C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E783A0: 394B8B58  addi r10, r11, -0x74a8
	ctx.r[10].s64 = ctx.r[11].s64 + -29864;
	// 82E783A4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E783A8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E783AC: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E783B0: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E783B4: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82E783B8: 41820014  beq 0x82e783cc
	if ctx.cr[0].eq {
	pc = 0x82E783CC; continue 'dispatch;
	}
	// 82E783BC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E783C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E783C4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E783C8: 419AFFE0  beq cr6, 0x82e783a8
	if ctx.cr[6].eq {
	pc = 0x82E783A8; continue 'dispatch;
	}
	// 82E783CC: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E783D0: 4082019C  bne 0x82e7856c
	if !ctx.cr[0].eq {
	pc = 0x82E7856C; continue 'dispatch;
	}
	// 82E783D4: 897F005C  lbz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E783D8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E783DC: 40820044  bne 0x82e78420
	if !ctx.cr[0].eq {
	pc = 0x82E78420; continue 'dispatch;
	}
	// 82E783E0: D3FF0060  stfs f31, 0x60(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E783E4: C01F0060  lfs f0, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E783E8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82E783EC: 4198000C  blt cr6, 0x82e783f8
	if ctx.cr[6].lt {
	pc = 0x82E783F8; continue 'dispatch;
	}
	// 82E783F0: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82E783F4: 40990028  ble cr6, 0x82e7841c
	if !ctx.cr[6].gt {
	pc = 0x82E7841C; continue 'dispatch;
	}
	// 82E783F8: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82E783FC: 4099000C  ble cr6, 0x82e78408
	if !ctx.cr[6].gt {
	pc = 0x82E78408; continue 'dispatch;
	}
	// 82E78400: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E78404: 48000010  b 0x82e78414
	pc = 0x82E78414; continue 'dispatch;
	// 82E78408: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82E7840C: 40980008  bge cr6, 0x82e78414
	if !ctx.cr[6].lt {
	pc = 0x82E78414; continue 'dispatch;
	}
	// 82E78410: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E78414: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E78418: 4BFFFFCC  b 0x82e783e4
	pc = 0x82E783E4; continue 'dispatch;
	// 82E7841C: 9BDF005C  stb r30, 0x5c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u8 ) };
	// 82E78420: 897F005C  lbz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E78424: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78428: 41820144  beq 0x82e7856c
	if ctx.cr[0].eq {
	pc = 0x82E7856C; continue 'dispatch;
	}
	// 82E7842C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E78430: C01F0060  lfs f0, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78434: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E78438: C1AB0044  lfs f13, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E7843C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E78440: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82E78444: 4198000C  blt cr6, 0x82e78450
	if ctx.cr[6].lt {
	pc = 0x82E78450; continue 'dispatch;
	}
	// 82E78448: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82E7844C: 40990024  ble cr6, 0x82e78470
	if !ctx.cr[6].gt {
	pc = 0x82E78470; continue 'dispatch;
	}
	// 82E78450: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82E78454: 4099000C  ble cr6, 0x82e78460
	if !ctx.cr[6].gt {
	pc = 0x82E78460; continue 'dispatch;
	}
	// 82E78458: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E7845C: 4BFFFFE4  b 0x82e78440
	pc = 0x82E78440; continue 'dispatch;
	// 82E78460: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82E78464: 4098FFDC  bge cr6, 0x82e78440
	if !ctx.cr[6].lt {
	pc = 0x82E78440; continue 'dispatch;
	}
	// 82E78468: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E7846C: 4BFFFFD4  b 0x82e78440
	pc = 0x82E78440; continue 'dispatch;
	// 82E78470: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82E78474: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 82E78478: 409900F0  ble cr6, 0x82e78568
	if !ctx.cr[6].gt {
	pc = 0x82E78568; continue 'dispatch;
	}
	// 82E7847C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E78480: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78484: 4182000C  beq 0x82e78490
	if ctx.cr[0].eq {
	pc = 0x82E78490; continue 'dispatch;
	}
	// 82E78488: D38B0008  stfs f28, 8(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E7848C: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82E78490: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E78494: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78498: 4182006C  beq 0x82e78504
	if ctx.cr[0].eq {
	pc = 0x82E78504; continue 'dispatch;
	}
	// 82E7849C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E784A0: 815D0718  lwz r10, 0x718(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E784A4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E784A8: 81290014  lwz r9, 0x14(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E784AC: C1A90058  lfs f13, 0x58(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E784B0: 4182000C  beq 0x82e784bc
	if ctx.cr[0].eq {
	pc = 0x82E784BC; continue 'dispatch;
	}
	// 82E784B4: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E784B8: 48000008  b 0x82e784c0
	pc = 0x82E784C0; continue 'dispatch;
	// 82E784BC: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 82E784C0: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E784C4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E784C8: 4099000C  ble cr6, 0x82e784d4
	if !ctx.cr[6].gt {
	pc = 0x82E784D4; continue 'dispatch;
	}
	// 82E784CC: D36B0008  stfs f27, 8(r11)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E784D0: 48000030  b 0x82e78500
	pc = 0x82E78500; continue 'dispatch;
	// 82E784D4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E784D8: 4182000C  beq 0x82e784e4
	if ctx.cr[0].eq {
	pc = 0x82E784E4; continue 'dispatch;
	}
	// 82E784DC: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E784E0: 48000008  b 0x82e784e8
	pc = 0x82E784E8; continue 'dispatch;
	// 82E784E4: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 82E784E8: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E784EC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E784F0: 4098000C  bge cr6, 0x82e784fc
	if !ctx.cr[6].lt {
	pc = 0x82E784FC; continue 'dispatch;
	}
	// 82E784F4: D3AB0008  stfs f29, 8(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E784F8: 48000008  b 0x82e78500
	pc = 0x82E78500; continue 'dispatch;
	// 82E784FC: D38B0008  stfs f28, 8(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E78500: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82E78504: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E78508: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7850C: 41820010  beq 0x82e7851c
	if ctx.cr[0].eq {
	pc = 0x82E7851C; continue 'dispatch;
	}
	// 82E78510: C01F0060  lfs f0, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78514: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82E78518: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E7851C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E78520: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78524: 41820048  beq 0x82e7856c
	if ctx.cr[0].eq {
	pc = 0x82E7856C; continue 'dispatch;
	}
	// 82E78528: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E7852C: C01F0060  lfs f0, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78530: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E78534: C1AA0044  lfs f13, 0x44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E78538: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82E7853C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E78540: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 82E78544: 4099000C  ble cr6, 0x82e78550
	if !ctx.cr[6].gt {
	pc = 0x82E78550; continue 'dispatch;
	}
	// 82E78548: D3AB0008  stfs f29, 8(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E7854C: 48000020  b 0x82e7856c
	pc = 0x82E7856C; continue 'dispatch;
	// 82E78550: FF004000  fcmpu cr6, f0, f8
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[8].f64);
	// 82E78554: 4098000C  bge cr6, 0x82e78560
	if !ctx.cr[6].lt {
	pc = 0x82E78560; continue 'dispatch;
	}
	// 82E78558: D36B0008  stfs f27, 8(r11)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E7855C: 48000010  b 0x82e7856c
	pc = 0x82E7856C; continue 'dispatch;
	// 82E78560: D38B0008  stfs f28, 8(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E78564: 48000008  b 0x82e7856c
	pc = 0x82E7856C; continue 'dispatch;
	// 82E78568: 9B9F005C  stb r28, 0x5c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[28].u8 ) };
	// 82E7856C: 897F004F  lbz r11, 0x4f(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(79 as u32) ) } as u64;
	// 82E78570: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78574: 40820020  bne 0x82e78594
	if !ctx.cr[0].eq {
	pc = 0x82E78594; continue 'dispatch;
	}
	// 82E78578: 897F0054  lbz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E7857C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78580: 40820014  bne 0x82e78594
	if !ctx.cr[0].eq {
	pc = 0x82E78594; continue 'dispatch;
	}
	// 82E78584: 897F005C  lbz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E78588: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E7858C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78590: 41820008  beq 0x82e78598
	if ctx.cr[0].eq {
	pc = 0x82E78598; continue 'dispatch;
	}
	// 82E78594: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E78598: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82E7859C: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82E785A0: 4BE35781  bl 0x82cadd20
	ctx.lr = 0x82E785A4;
	sub_82CADCEC(ctx, base);
	// 82E785A4: 4BE30EB4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E785A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E785A8 size=64
    let mut pc: u32 = 0x82E785A8;
    'dispatch: loop {
        match pc {
            0x82E785A8 => {
    //   block [0x82E785A8..0x82E785E8)
	// 82E785A8: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E785AC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E785B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E785B4: 41820014  beq 0x82e785c8
	if ctx.cr[0].eq {
	pc = 0x82E785C8; continue 'dispatch;
	}
	// 82E785B8: 81230044  lwz r9, 0x44(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E785BC: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E785C0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E785C4: 41980028  blt cr6, 0x82e785ec
	if ctx.cr[6].lt {
		sub_82E785E8(ctx, base);
		return;
	}
	// 82E785C8: 8963004E  lbz r11, 0x4e(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(78 as u32) ) } as u64;
	// 82E785CC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E785D0: 41820018  beq 0x82e785e8
	if ctx.cr[0].eq {
		sub_82E785E8(ctx, base);
		return;
	}
	// 82E785D4: 81630044  lwz r11, 0x44(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E785D8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E785DC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E785E0: 91630048  stw r11, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82E785E4: 48000008  b 0x82e785ec
	sub_82E785E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E785E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E785E8 size=28
    let mut pc: u32 = 0x82E785E8;
    'dispatch: loop {
        match pc {
            0x82E785E8 => {
    //   block [0x82E785E8..0x82E78604)
	// 82E785E8: 91430048  stw r10, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 82E785EC: 9943004C  stb r10, 0x4c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[10].u8 ) };
	// 82E785F0: 9943004D  stb r10, 0x4d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(77 as u32), ctx.r[10].u8 ) };
	// 82E785F4: 9943004F  stb r10, 0x4f(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(79 as u32), ctx.r[10].u8 ) };
	// 82E785F8: 99430054  stb r10, 0x54(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[10].u8 ) };
	// 82E785FC: 9943005C  stb r10, 0x5c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[10].u8 ) };
	// 82E78600: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E78608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E78608 size=124
    let mut pc: u32 = 0x82E78608;
    'dispatch: loop {
        match pc {
            0x82E78608 => {
    //   block [0x82E78608..0x82E78684)
	// 82E78608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7860C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E78610: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E78614: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82E78618: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7861C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E78620: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E78624: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E78628: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7862C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82E78630: 4099003C  ble cr6, 0x82e7866c
	if !ctx.cr[6].gt {
	pc = 0x82E7866C; continue 'dispatch;
	}
	// 82E78634: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E78638: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7863C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E78640: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82E78644: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E78648: 4B370031  bl 0x821e8678
	ctx.lr = 0x82E7864C;
	sub_821E8678(ctx, base);
	// 82E7864C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78650: 41820018  beq 0x82e78668
	if ctx.cr[0].eq {
	pc = 0x82E78668; continue 'dispatch;
	}
	// 82E78654: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78658: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82E7865C: 4099000C  ble cr6, 0x82e78668
	if !ctx.cr[6].gt {
	pc = 0x82E78668; continue 'dispatch;
	}
	// 82E78660: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82E78664: 48000008  b 0x82e7866c
	pc = 0x82E7866C; continue 'dispatch;
	// 82E78668: D3FF0040  stfs f31, 0x40(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82E7866C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E78670: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E78674: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E78678: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E7867C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E78680: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E78688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E78688 size=124
    let mut pc: u32 = 0x82E78688;
    'dispatch: loop {
        match pc {
            0x82E78688 => {
    //   block [0x82E78688..0x82E78704)
	// 82E78688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7868C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E78690: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E78694: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82E78698: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7869C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E786A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E786A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E786A8: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E786AC: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82E786B0: 4099003C  ble cr6, 0x82e786ec
	if !ctx.cr[6].gt {
	pc = 0x82E786EC; continue 'dispatch;
	}
	// 82E786B4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E786B8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E786BC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E786C0: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82E786C4: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E786C8: 4B36FFB1  bl 0x821e8678
	ctx.lr = 0x82E786CC;
	sub_821E8678(ctx, base);
	// 82E786CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E786D0: 41820018  beq 0x82e786e8
	if ctx.cr[0].eq {
	pc = 0x82E786E8; continue 'dispatch;
	}
	// 82E786D4: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E786D8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82E786DC: 4099000C  ble cr6, 0x82e786e8
	if !ctx.cr[6].gt {
	pc = 0x82E786E8; continue 'dispatch;
	}
	// 82E786E0: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82E786E4: 48000008  b 0x82e786ec
	pc = 0x82E786EC; continue 'dispatch;
	// 82E786E8: D3FF003C  stfs f31, 0x3c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82E786EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E786F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E786F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E786F8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E786FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E78700: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E78708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E78708 size=72
    let mut pc: u32 = 0x82E78708;
    'dispatch: loop {
        match pc {
            0x82E78708 => {
    //   block [0x82E78708..0x82E78750)
	// 82E78708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7870C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E78710: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E78714: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E78718: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E7871C: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 82E78720: 4B79E209  bl 0x82616928
	ctx.lr = 0x82E78724;
	sub_82616928(ctx, base);
	// 82E78724: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78728: 41820010  beq 0x82e78738
	if ctx.cr[0].eq {
	pc = 0x82E78738; continue 'dispatch;
	}
	// 82E7872C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E78730: 4BFFF3C9  bl 0x82e77af8
	ctx.lr = 0x82E78734;
	sub_82E77AF8(ctx, base);
	// 82E78734: 48000008  b 0x82e7873c
	pc = 0x82E7873C; continue 'dispatch;
	// 82E78738: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E7873C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E78740: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E78744: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E78748: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E7874C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E78750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E78750 size=100
    let mut pc: u32 = 0x82E78750;
    'dispatch: loop {
        match pc {
            0x82E78750 => {
    //   block [0x82E78750..0x82E787B4)
	// 82E78750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E78754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E78758: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E7875C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E78760: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E78764: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E78768: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E7876C: 396B8B08  addi r11, r11, -0x74f8
	ctx.r[11].s64 = ctx.r[11].s64 + -29944;
	// 82E78770: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E78774: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E78778: 48010A81  bl 0x82e891f8
	ctx.lr = 0x82E7877C;
	sub_82E891F8(ctx, base);
	// 82E7877C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E78780: 41820018  beq 0x82e78798
	if ctx.cr[0].eq {
	pc = 0x82E78798; continue 'dispatch;
	}
	// 82E78784: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E78788: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7878C: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E78790: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E78794: 4E800421  bctrl
	ctx.lr = 0x82E78798;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E78798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7879C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E787A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E787A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E787A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E787AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E787B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E787B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E787B8 size=544
    let mut pc: u32 = 0x82E787B8;
    'dispatch: loop {
        match pc {
            0x82E787B8 => {
    //   block [0x82E787B8..0x82E789D8)
	// 82E787B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E787BC: 4BE30C51  bl 0x82ca940c
	ctx.lr = 0x82E787C0;
	sub_82CA93D0(ctx, base);
	// 82E787C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E787C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E787C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E787CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E787D0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E787D4: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E787D8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E787DC: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E787E0: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E787E4: 997F004F  stb r11, 0x4f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(79 as u32), ctx.r[11].u8 ) };
	// 82E787E8: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E787EC: 997F0054  stb r11, 0x54(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u8 ) };
	// 82E787F0: 997F005C  stb r11, 0x5c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u8 ) };
	// 82E787F4: 997F004E  stb r11, 0x4e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(78 as u32), ctx.r[11].u8 ) };
	// 82E787F8: 409A000C  bne cr6, 0x82e78804
	if !ctx.cr[6].eq {
	pc = 0x82E78804; continue 'dispatch;
	}
	// 82E787FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E78800: 480001D0  b 0x82e789d0
	pc = 0x82E789D0; continue 'dispatch;
	// 82E78804: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78808: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E7880C: 388B1048  addi r4, r11, 0x1048
	ctx.r[4].s64 = ctx.r[11].s64 + 4168;
	// 82E78810: 4B3EED01  bl 0x82267510
	ctx.lr = 0x82E78814;
	sub_82267510(ctx, base);
	// 82E78814: 3FC08334  lis r30, -0x7ccc
	ctx.r[30].s64 = -2093744128;
	// 82E78818: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7881C: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82E78820: 388BE07C  addi r4, r11, -0x1f84
	ctx.r[4].s64 = ctx.r[11].s64 + -8068;
	// 82E78824: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E78828: 4B3EF3F9  bl 0x82267c20
	ctx.lr = 0x82E7882C;
	sub_82267C20(ctx, base);
	// 82E7882C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E78830: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82E78834: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E78838: 388BE4AC  addi r4, r11, -0x1b54
	ctx.r[4].s64 = ctx.r[11].s64 + -6996;
	// 82E7883C: 4B3EF3E5  bl 0x82267c20
	ctx.lr = 0x82E78840;
	sub_82267C20(ctx, base);
	// 82E78840: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E78844: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82E78848: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7884C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E78850: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82E78854: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E78858: 4E800421  bctrl
	ctx.lr = 0x82E7885C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E7885C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E78860: 4182FF9C  beq 0x82e787fc
	if ctx.cr[0].eq {
	pc = 0x82E787FC; continue 'dispatch;
	}
	// 82E78864: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E78868: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7886C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E78870: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82E78874: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E78878: 4B36FE01  bl 0x821e8678
	ctx.lr = 0x82E7887C;
	sub_821E8678(ctx, base);
	// 82E7887C: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E78880: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82E78884: 41820010  beq 0x82e78894
	if ctx.cr[0].eq {
	pc = 0x82E78894; continue 'dispatch;
	}
	// 82E78888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7888C: C02B0004  lfs f1, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E78890: 4BFFFD79  bl 0x82e78608
	ctx.lr = 0x82E78894;
	sub_82E78608(ctx, base);
	// 82E78894: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E78898: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7889C: 41820010  beq 0x82e788ac
	if ctx.cr[0].eq {
	pc = 0x82E788AC; continue 'dispatch;
	}
	// 82E788A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E788A4: C02B0004  lfs f1, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E788A8: 4BFFFDE1  bl 0x82e78688
	ctx.lr = 0x82E788AC;
	sub_82E78688(ctx, base);
	// 82E788AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E788B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E788B4: 48010A15  bl 0x82e892c8
	ctx.lr = 0x82E788B8;
	sub_82E892C8(ctx, base);
	// 82E788B8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E788BC: 4182FF40  beq 0x82e787fc
	if ctx.cr[0].eq {
	pc = 0x82E787FC; continue 'dispatch;
	}
	// 82E788C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E788C4: 4BFFFCE5  bl 0x82e785a8
	ctx.lr = 0x82E788C8;
	sub_82E785A8(ctx, base);
	// 82E788C8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E788CC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E788D0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E788D4: 3BCBC7F0  addi r30, r11, -0x3810
	ctx.r[30].s64 = ctx.r[11].s64 + -14352;
	// 82E788D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E788DC: 806A0008  lwz r3, 8(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E788E0: 48004DE1  bl 0x82e7d6c0
	ctx.lr = 0x82E788E4;
	sub_82E7D6C0(ctx, base);
	// 82E788E4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E788E8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E788EC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E788F0: 907F0034  stw r3, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[3].u32 ) };
	// 82E788F4: 3BABCF7C  addi r29, r11, -0x3084
	ctx.r[29].s64 = ctx.r[11].s64 + -12420;
	// 82E788F8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E788FC: 806A0008  lwz r3, 8(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E78900: 48004DC1  bl 0x82e7d6c0
	ctx.lr = 0x82E78904;
	sub_82E7D6C0(ctx, base);
	// 82E78904: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E78908: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E7890C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78910: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E78914: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82E78918: 48004DA9  bl 0x82e7d6c0
	ctx.lr = 0x82E7891C;
	sub_82E7D6C0(ctx, base);
	// 82E7891C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E78920: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78924: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E78928: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E7892C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82E78930: 48004D91  bl 0x82e7d6c0
	ctx.lr = 0x82E78934;
	sub_82E7D6C0(ctx, base);
	// 82E78934: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82E78938: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E7893C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78940: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E78944: 388BC6DC  addi r4, r11, -0x3924
	ctx.r[4].s64 = ctx.r[11].s64 + -14628;
	// 82E78948: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82E7894C: 48004D75  bl 0x82e7d6c0
	ctx.lr = 0x82E78950;
	sub_82E7D6C0(ctx, base);
	// 82E78950: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82E78954: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78958: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7895C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E78960: 388BCB2C  addi r4, r11, -0x34d4
	ctx.r[4].s64 = ctx.r[11].s64 + -13524;
	// 82E78964: 915F002C  stw r10, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 82E78968: 48004D59  bl 0x82e7d6c0
	ctx.lr = 0x82E7896C;
	sub_82E7D6C0(ctx, base);
	// 82E7896C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82E78970: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78974: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78978: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E7897C: 388BCE68  addi r4, r11, -0x3198
	ctx.r[4].s64 = ctx.r[11].s64 + -12696;
	// 82E78980: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 82E78984: 48004D3D  bl 0x82e7d6c0
	ctx.lr = 0x82E78988;
	sub_82E7D6C0(ctx, base);
	// 82E78988: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82E7898C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78990: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78994: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E78998: 388BCD54  addi r4, r11, -0x32ac
	ctx.r[4].s64 = ctx.r[11].s64 + -12972;
	// 82E7899C: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82E789A0: 48004D21  bl 0x82e7d6c0
	ctx.lr = 0x82E789A4;
	sub_82E7D6C0(ctx, base);
	// 82E789A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E789A8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82E789AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E789B0: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E789B4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82E789B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E789BC: 4E800421  bctrl
	ctx.lr = 0x82E789C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E789C0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E789C4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82E789C8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82E789CC: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82E789D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E789D4: 4BE30A88  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E789D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E789D8 size=404
    let mut pc: u32 = 0x82E789D8;
    'dispatch: loop {
        match pc {
            0x82E789D8 => {
    //   block [0x82E789D8..0x82E78B6C)
	// 82E789D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E789DC: 4BE30A31  bl 0x82ca940c
	ctx.lr = 0x82E789E0;
	sub_82CA93D0(ctx, base);
	// 82E789E0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82E789E4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E789E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E789EC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E789F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E789F4: 409A000C  bne cr6, 0x82e78a00
	if !ctx.cr[6].eq {
	pc = 0x82E78A00; continue 'dispatch;
	}
	// 82E789F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E789FC: 48000164  b 0x82e78b60
	pc = 0x82E78B60; continue 'dispatch;
	// 82E78A00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E78A04: 4834365D  bl 0x831bc060
	ctx.lr = 0x82E78A08;
	sub_831BC060(ctx, base);
	// 82E78A08: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E78A0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E78A10: 388B8B84  addi r4, r11, -0x747c
	ctx.r[4].s64 = ctx.r[11].s64 + -29820;
	// 82E78A14: 4BE3413D  bl 0x82cacb50
	ctx.lr = 0x82E78A18;
	sub_82CACB50(ctx, base);
	// 82E78A18: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E78A1C: 4082003C  bne 0x82e78a58
	if !ctx.cr[0].eq {
	pc = 0x82E78A58; continue 'dispatch;
	}
	// 82E78A20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E78A24: 4BA952E5  bl 0x8290dd08
	ctx.lr = 0x82E78A28;
	sub_8290DD08(ctx, base);
	// 82E78A28: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82E78A2C: 4182FFCC  beq 0x82e789f8
	if ctx.cr[0].eq {
	pc = 0x82E789F8; continue 'dispatch;
	}
	// 82E78A30: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E78A34: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78A38: 4182FFC0  beq 0x82e789f8
	if ctx.cr[0].eq {
	pc = 0x82E789F8; continue 'dispatch;
	}
	// 82E78A3C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E78A40: 48003889  bl 0x82e7c2c8
	ctx.lr = 0x82E78A44;
	sub_82E7C2C8(ctx, base);
	// 82E78A44: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82E78A48: 907D0044  stw r3, 0x44(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(68 as u32), ctx.r[3].u32 ) };
	// 82E78A4C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82E78A50: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82E78A54: 4800010C  b 0x82e78b60
	pc = 0x82E78B60; continue 'dispatch;
	// 82E78A58: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E78A5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E78A60: 388B8B70  addi r4, r11, -0x7490
	ctx.r[4].s64 = ctx.r[11].s64 + -29840;
	// 82E78A64: 4BE340ED  bl 0x82cacb50
	ctx.lr = 0x82E78A68;
	sub_82CACB50(ctx, base);
	// 82E78A68: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E78A6C: 40820024  bne 0x82e78a90
	if !ctx.cr[0].eq {
	pc = 0x82E78A90; continue 'dispatch;
	}
	// 82E78A70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E78A74: 4BA95295  bl 0x8290dd08
	ctx.lr = 0x82E78A78;
	sub_8290DD08(ctx, base);
	// 82E78A78: 4BE31949  bl 0x82caa3c0
	ctx.lr = 0x82E78A7C;
	sub_82CAA3C0(ctx, base);
	// 82E78A7C: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E78A80: 418000D4  blt 0x82e78b54
	if ctx.cr[0].lt {
	pc = 0x82E78B54; continue 'dispatch;
	}
	// 82E78A84: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E78A88: 917D0048  stw r11, 0x48(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82E78A8C: 480000D4  b 0x82e78b60
	pc = 0x82E78B60; continue 'dispatch;
	// 82E78A90: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E78A94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E78A98: 388BA888  addi r4, r11, -0x5778
	ctx.r[4].s64 = ctx.r[11].s64 + -22392;
	// 82E78A9C: 4BE340B5  bl 0x82cacb50
	ctx.lr = 0x82E78AA0;
	sub_82CACB50(ctx, base);
	// 82E78AA0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E78AA4: 40820050  bne 0x82e78af4
	if !ctx.cr[0].eq {
	pc = 0x82E78AF4; continue 'dispatch;
	}
	// 82E78AA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E78AAC: 4BA9525D  bl 0x8290dd08
	ctx.lr = 0x82E78AB0;
	sub_8290DD08(ctx, base);
	// 82E78AB0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78AB4: 41820038  beq 0x82e78aec
	if ctx.cr[0].eq {
	pc = 0x82E78AEC; continue 'dispatch;
	}
	// 82E78AB8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78ABC: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E78AC0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78AC4: 4182000C  beq 0x82e78ad0
	if ctx.cr[0].eq {
	pc = 0x82E78AD0; continue 'dispatch;
	}
	// 82E78AC8: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E78ACC: 4800000C  b 0x82e78ad8
	pc = 0x82E78AD8; continue 'dispatch;
	// 82E78AD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E78AD4: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E78AD8: 4BE330D9  bl 0x82cabbb0
	ctx.lr = 0x82E78ADC;
	sub_82CABBB0(ctx, base);
	// 82E78ADC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E78AE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E78AE4: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E78AE8: 4BFFFBA1  bl 0x82e78688
	ctx.lr = 0x82E78AEC;
	sub_82E78688(ctx, base);
	// 82E78AEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E78AF0: 48000070  b 0x82e78b60
	pc = 0x82E78B60; continue 'dispatch;
	// 82E78AF4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E78AF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E78AFC: 388BA87C  addi r4, r11, -0x5784
	ctx.r[4].s64 = ctx.r[11].s64 + -22404;
	// 82E78B00: 4BE34051  bl 0x82cacb50
	ctx.lr = 0x82E78B04;
	sub_82CACB50(ctx, base);
	// 82E78B04: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E78B08: 4082004C  bne 0x82e78b54
	if !ctx.cr[0].eq {
	pc = 0x82E78B54; continue 'dispatch;
	}
	// 82E78B0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E78B10: 4BA951F9  bl 0x8290dd08
	ctx.lr = 0x82E78B14;
	sub_8290DD08(ctx, base);
	// 82E78B14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78B18: 4182FFD4  beq 0x82e78aec
	if ctx.cr[0].eq {
	pc = 0x82E78AEC; continue 'dispatch;
	}
	// 82E78B1C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78B20: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E78B24: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78B28: 4182000C  beq 0x82e78b34
	if ctx.cr[0].eq {
	pc = 0x82E78B34; continue 'dispatch;
	}
	// 82E78B2C: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E78B30: 4800000C  b 0x82e78b3c
	pc = 0x82E78B3C; continue 'dispatch;
	// 82E78B34: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E78B38: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E78B3C: 4BE33075  bl 0x82cabbb0
	ctx.lr = 0x82E78B40;
	sub_82CABBB0(ctx, base);
	// 82E78B40: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E78B44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E78B48: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E78B4C: 4BFFFABD  bl 0x82e78608
	ctx.lr = 0x82E78B50;
	sub_82E78608(ctx, base);
	// 82E78B50: 4BFFFF9C  b 0x82e78aec
	pc = 0x82E78AEC; continue 'dispatch;
	// 82E78B54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E78B58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E78B5C: 4BFF733D  bl 0x82e6fe98
	ctx.lr = 0x82E78B60;
	sub_82E6FE98(ctx, base);
	// 82E78B60: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E78B64: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82E78B68: 4BE308F4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E78B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E78B70 size=4
    let mut pc: u32 = 0x82E78B70;
    'dispatch: loop {
        match pc {
            0x82E78B70 => {
    //   block [0x82E78B70..0x82E78B74)
	// 82E78B70: 4BFFFA38  b 0x82e785a8
	sub_82E785A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E78B78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E78B78 size=484
    let mut pc: u32 = 0x82E78B78;
    'dispatch: loop {
        match pc {
            0x82E78B78 => {
    //   block [0x82E78B78..0x82E78D5C)
	// 82E78B78: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78B7C: 396BCF7C  addi r11, r11, -0x3084
	ctx.r[11].s64 = ctx.r[11].s64 + -12420;
	// 82E78B80: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78B84: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78B88: 419A01D4  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78B8C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78B90: 396BD938  addi r11, r11, -0x26c8
	ctx.r[11].s64 = ctx.r[11].s64 + -9928;
	// 82E78B94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78B98: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78B9C: 419A01C0  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78BA0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78BA4: 396BCE68  addi r11, r11, -0x3198
	ctx.r[11].s64 = ctx.r[11].s64 + -12696;
	// 82E78BA8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78BAC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78BB0: 419A01AC  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78BB4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78BB8: 396BD824  addi r11, r11, -0x27dc
	ctx.r[11].s64 = ctx.r[11].s64 + -10204;
	// 82E78BBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78BC0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78BC4: 419A0198  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78BC8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78BCC: 396BC904  addi r11, r11, -0x36fc
	ctx.r[11].s64 = ctx.r[11].s64 + -14076;
	// 82E78BD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78BD4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78BD8: 419A0184  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78BDC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78BE0: 396BCD54  addi r11, r11, -0x32ac
	ctx.r[11].s64 = ctx.r[11].s64 + -12972;
	// 82E78BE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78BE8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78BEC: 419A0170  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78BF0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78BF4: 396BC6DC  addi r11, r11, -0x3924
	ctx.r[11].s64 = ctx.r[11].s64 + -14628;
	// 82E78BF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78BFC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78C00: 419A015C  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78C04: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78C08: 396BCA18  addi r11, r11, -0x35e8
	ctx.r[11].s64 = ctx.r[11].s64 + -13800;
	// 82E78C0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78C10: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78C14: 419A0148  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78C18: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78C1C: 396BC7F0  addi r11, r11, -0x3810
	ctx.r[11].s64 = ctx.r[11].s64 + -14352;
	// 82E78C20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78C24: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78C28: 419A0134  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78C2C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78C30: 396BCB2C  addi r11, r11, -0x34d4
	ctx.r[11].s64 = ctx.r[11].s64 + -13524;
	// 82E78C34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78C38: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78C3C: 419A0120  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78C40: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78C44: 396BD710  addi r11, r11, -0x28f0
	ctx.r[11].s64 = ctx.r[11].s64 + -10480;
	// 82E78C48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78C4C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78C50: 419A010C  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78C54: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78C58: 396BC064  addi r11, r11, -0x3f9c
	ctx.r[11].s64 = ctx.r[11].s64 + -16284;
	// 82E78C5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78C60: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78C64: 419A00F8  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78C68: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78C6C: 396BD5FC  addi r11, r11, -0x2a04
	ctx.r[11].s64 = ctx.r[11].s64 + -10756;
	// 82E78C70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78C74: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78C78: 419A00E4  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78C7C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78C80: 396BCC40  addi r11, r11, -0x33c0
	ctx.r[11].s64 = ctx.r[11].s64 + -13248;
	// 82E78C84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78C88: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78C8C: 419A00D0  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78C90: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78C94: 396BD4E8  addi r11, r11, -0x2b18
	ctx.r[11].s64 = ctx.r[11].s64 + -11032;
	// 82E78C98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78C9C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78CA0: 419A00BC  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78CA4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78CA8: 396BC178  addi r11, r11, -0x3e88
	ctx.r[11].s64 = ctx.r[11].s64 + -16008;
	// 82E78CAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78CB0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78CB4: 419A00A8  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78CB8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78CBC: 396BD3D4  addi r11, r11, -0x2c2c
	ctx.r[11].s64 = ctx.r[11].s64 + -11308;
	// 82E78CC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78CC4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78CC8: 419A0094  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78CCC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78CD0: 396BC28C  addi r11, r11, -0x3d74
	ctx.r[11].s64 = ctx.r[11].s64 + -15732;
	// 82E78CD4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78CD8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78CDC: 419A0080  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78CE0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78CE4: 396BC3A0  addi r11, r11, -0x3c60
	ctx.r[11].s64 = ctx.r[11].s64 + -15456;
	// 82E78CE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78CEC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78CF0: 419A006C  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78CF4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78CF8: 396BC4B4  addi r11, r11, -0x3b4c
	ctx.r[11].s64 = ctx.r[11].s64 + -15180;
	// 82E78CFC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78D00: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78D04: 419A0058  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78D08: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78D0C: 396BD2C0  addi r11, r11, -0x2d40
	ctx.r[11].s64 = ctx.r[11].s64 + -11584;
	// 82E78D10: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78D14: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78D18: 419A0044  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78D1C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78D20: 396BC5C8  addi r11, r11, -0x3a38
	ctx.r[11].s64 = ctx.r[11].s64 + -14904;
	// 82E78D24: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78D28: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78D2C: 419A0030  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78D30: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78D34: 396BD1AC  addi r11, r11, -0x2e54
	ctx.r[11].s64 = ctx.r[11].s64 + -11860;
	// 82E78D38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78D3C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78D40: 419A001C  beq cr6, 0x82e78d5c
	if ctx.cr[6].eq {
		sub_82E78D5C(ctx, base);
		return;
	}
	// 82E78D44: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78D48: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E78D4C: 396BD098  addi r11, r11, -0x2f68
	ctx.r[11].s64 = ctx.r[11].s64 + -12136;
	// 82E78D50: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E78D54: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E78D58: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E78D5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E78D5C size=8
    let mut pc: u32 = 0x82E78D5C;
    'dispatch: loop {
        match pc {
            0x82E78D5C => {
    //   block [0x82E78D5C..0x82E78D64)
	// 82E78D5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E78D60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E78D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E78D68 size=296
    let mut pc: u32 = 0x82E78D68;
    'dispatch: loop {
        match pc {
            0x82E78D68 => {
    //   block [0x82E78D68..0x82E78E90)
	// 82E78D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E78D6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E78D70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E78D74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E78D78: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82E78D7C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E78D80: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E78D84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E78D88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E78D8C: 409A000C  bne cr6, 0x82e78d98
	if !ctx.cr[6].eq {
	pc = 0x82E78D98; continue 'dispatch;
	}
	// 82E78D90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E78D94: 480000E0  b 0x82e78e74
	pc = 0x82E78E74; continue 'dispatch;
	// 82E78D98: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78D9C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E78DA0: 388BC4B4  addi r4, r11, -0x3b4c
	ctx.r[4].s64 = ctx.r[11].s64 + -15180;
	// 82E78DA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E78DA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E78DAC: C3EB0A44  lfs f31, 0xa44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2628 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E78DB0: 4B36F8C9  bl 0x821e8678
	ctx.lr = 0x82E78DB4;
	sub_821E8678(ctx, base);
	// 82E78DB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78DB8: 41820008  beq 0x82e78dc0
	if ctx.cr[0].eq {
	pc = 0x82E78DC0; continue 'dispatch;
	}
	// 82E78DBC: C3E30008  lfs f31, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E78DC0: C01F0034  lfs f0, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78DC4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78DC8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E78DCC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E78DD0: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78DD4: 388BC064  addi r4, r11, -0x3f9c
	ctx.r[4].s64 = ctx.r[11].s64 + -16284;
	// 82E78DD8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E78DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E78DE0: C01F003C  lfs f0, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78DE4: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E78DE8: C01F004C  lfs f0, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78DEC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E78DF0: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78DF4: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E78DF8: C01F0054  lfs f0, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78DFC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E78E00: 4B36F879  bl 0x821e8678
	ctx.lr = 0x82E78E04;
	sub_821E8678(ctx, base);
	// 82E78E04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78E08: 4182001C  beq 0x82e78e24
	if ctx.cr[0].eq {
	pc = 0x82E78E24; continue 'dispatch;
	}
	// 82E78E0C: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78E10: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E78E14: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78E18: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E78E1C: C003000C  lfs f0, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78E20: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E78E24: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78E28: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E78E2C: 388BD5FC  addi r4, r11, -0x2a04
	ctx.r[4].s64 = ctx.r[11].s64 + -10756;
	// 82E78E30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E78E34: 4B36F845  bl 0x821e8678
	ctx.lr = 0x82E78E38;
	sub_821E8678(ctx, base);
	// 82E78E38: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78E3C: 4182001C  beq 0x82e78e58
	if ctx.cr[0].eq {
	pc = 0x82E78E58; continue 'dispatch;
	}
	// 82E78E40: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78E44: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E78E48: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78E4C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E78E50: C003000C  lfs f0, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78E54: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E78E58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E78E5C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E78E60: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E78E64: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E78E68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E78E6C: C04B0EE0  lfs f2, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82E78E70: 48010CB1  bl 0x82e89b20
	ctx.lr = 0x82E78E74;
	sub_82E89B20(ctx, base);
	// 82E78E74: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E78E78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E78E7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E78E80: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82E78E84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E78E88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E78E8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E78E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E78E90 size=12
    let mut pc: u32 = 0x82E78E90;
    'dispatch: loop {
        match pc {
            0x82E78E90 => {
    //   block [0x82E78E90..0x82E78E9C)
	// 82E78E90: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78E94: 386BC064  addi r3, r11, -0x3f9c
	ctx.r[3].s64 = ctx.r[11].s64 + -16284;
	// 82E78E98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E78EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E78EA0 size=84
    let mut pc: u32 = 0x82E78EA0;
    'dispatch: loop {
        match pc {
            0x82E78EA0 => {
    //   block [0x82E78EA0..0x82E78EF4)
	// 82E78EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E78EA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E78EA8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E78EAC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E78EB0: 4B79DA79  bl 0x82616928
	ctx.lr = 0x82E78EB4;
	sub_82616928(ctx, base);
	// 82E78EB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78EB8: 41820028  beq 0x82e78ee0
	if ctx.cr[0].eq {
	pc = 0x82E78EE0; continue 'dispatch;
	}
	// 82E78EBC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E78EC0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E78EC4: 396B8BA8  addi r11, r11, -0x7458
	ctx.r[11].s64 = ctx.r[11].s64 + -29784;
	// 82E78EC8: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78ECC: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E78ED0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E78ED4: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E78ED8: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E78EDC: 48000008  b 0x82e78ee4
	pc = 0x82E78EE4; continue 'dispatch;
	// 82E78EE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E78EE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E78EE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E78EEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E78EF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E78EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E78EF8 size=12
    let mut pc: u32 = 0x82E78EF8;
    'dispatch: loop {
        match pc {
            0x82E78EF8 => {
    //   block [0x82E78EF8..0x82E78F04)
	// 82E78EF8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78EFC: 386BC178  addi r3, r11, -0x3e88
	ctx.r[3].s64 = ctx.r[11].s64 + -16008;
	// 82E78F00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E78F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E78F08 size=112
    let mut pc: u32 = 0x82E78F08;
    'dispatch: loop {
        match pc {
            0x82E78F08 => {
    //   block [0x82E78F08..0x82E78F78)
	// 82E78F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E78F0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E78F10: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E78F14: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82E78F18: 4B79DA11  bl 0x82616928
	ctx.lr = 0x82E78F1C;
	sub_82616928(ctx, base);
	// 82E78F1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78F20: 41820044  beq 0x82e78f64
	if ctx.cr[0].eq {
	pc = 0x82E78F64; continue 'dispatch;
	}
	// 82E78F24: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E78F28: 396B8BD0  addi r11, r11, -0x7430
	ctx.r[11].s64 = ctx.r[11].s64 + -29744;
	// 82E78F2C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E78F30: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78F34: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E78F38: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E78F3C: 4182000C  beq 0x82e78f48
	if ctx.cr[0].eq {
	pc = 0x82E78F48; continue 'dispatch;
	}
	// 82E78F40: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E78F44: 4800000C  b 0x82e78f50
	pc = 0x82E78F50; continue 'dispatch;
	// 82E78F48: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E78F4C: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E78F50: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82E78F54: C00B0EEC  lfs f0, 0xeec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3820 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78F58: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E78F5C: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E78F60: 48000008  b 0x82e78f68
	pc = 0x82E78F68; continue 'dispatch;
	// 82E78F64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E78F68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E78F6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E78F70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E78F74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E78F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E78F78 size=92
    let mut pc: u32 = 0x82E78F78;
    'dispatch: loop {
        match pc {
            0x82E78F78 => {
    //   block [0x82E78F78..0x82E78FD4)
	// 82E78F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E78F7C: 4BE30491  bl 0x82ca940c
	ctx.lr = 0x82E78F80;
	sub_82CA93D0(ctx, base);
	// 82E78F80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E78F84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E78F88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E78F8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E78F90: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E78F94: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E78F98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E78F9C: 4E800421  bctrl
	ctx.lr = 0x82E78FA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E78FA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E78FA4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E78FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E78FAC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E78FB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E78FB4: 4E800421  bctrl
	ctx.lr = 0x82E78FB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E78FB8: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82E78FBC: 409A000C  bne cr6, 0x82e78fc8
	if !ctx.cr[6].eq {
	pc = 0x82E78FC8; continue 'dispatch;
	}
	// 82E78FC0: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E78FC4: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E78FC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E78FCC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E78FD0: 4BE3048C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E78FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E78FD8 size=12
    let mut pc: u32 = 0x82E78FD8;
    'dispatch: loop {
        match pc {
            0x82E78FD8 => {
    //   block [0x82E78FD8..0x82E78FE4)
	// 82E78FD8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E78FDC: 386BC28C  addi r3, r11, -0x3d74
	ctx.r[3].s64 = ctx.r[11].s64 + -15732;
	// 82E78FE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E78FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E78FE8 size=112
    let mut pc: u32 = 0x82E78FE8;
    'dispatch: loop {
        match pc {
            0x82E78FE8 => {
    //   block [0x82E78FE8..0x82E79058)
	// 82E78FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E78FEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E78FF0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E78FF4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82E78FF8: 4B79D931  bl 0x82616928
	ctx.lr = 0x82E78FFC;
	sub_82616928(ctx, base);
	// 82E78FFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79000: 41820044  beq 0x82e79044
	if ctx.cr[0].eq {
	pc = 0x82E79044; continue 'dispatch;
	}
	// 82E79004: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E79008: 396B8BF4  addi r11, r11, -0x740c
	ctx.r[11].s64 = ctx.r[11].s64 + -29708;
	// 82E7900C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E79010: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E79014: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E79018: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7901C: 4182000C  beq 0x82e79028
	if ctx.cr[0].eq {
	pc = 0x82E79028; continue 'dispatch;
	}
	// 82E79020: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E79024: 4800000C  b 0x82e79030
	pc = 0x82E79030; continue 'dispatch;
	// 82E79028: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E7902C: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E79030: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E79034: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79038: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E7903C: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E79040: 48000008  b 0x82e79048
	pc = 0x82E79048; continue 'dispatch;
	// 82E79044: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E79048: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E7904C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E79050: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E79054: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E79058 size=12
    let mut pc: u32 = 0x82E79058;
    'dispatch: loop {
        match pc {
            0x82E79058 => {
    //   block [0x82E79058..0x82E79064)
	// 82E79058: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7905C: 386BC3A0  addi r3, r11, -0x3c60
	ctx.r[3].s64 = ctx.r[11].s64 + -15456;
	// 82E79060: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E79068 size=72
    let mut pc: u32 = 0x82E79068;
    'dispatch: loop {
        match pc {
            0x82E79068 => {
    //   block [0x82E79068..0x82E790B0)
	// 82E79068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7906C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E79070: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E79074: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82E79078: 4B79D8B1  bl 0x82616928
	ctx.lr = 0x82E7907C;
	sub_82616928(ctx, base);
	// 82E7907C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79080: 4182001C  beq 0x82e7909c
	if ctx.cr[0].eq {
	pc = 0x82E7909C; continue 'dispatch;
	}
	// 82E79084: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E79088: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82E7908C: 396B8C18  addi r11, r11, -0x73e8
	ctx.r[11].s64 = ctx.r[11].s64 + -29672;
	// 82E79090: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E79094: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E79098: 48000008  b 0x82e790a0
	pc = 0x82E790A0; continue 'dispatch;
	// 82E7909C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E790A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E790A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E790A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E790AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E790B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E790B0 size=92
    let mut pc: u32 = 0x82E790B0;
    'dispatch: loop {
        match pc {
            0x82E790B0 => {
    //   block [0x82E790B0..0x82E7910C)
	// 82E790B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E790B4: 4BE30359  bl 0x82ca940c
	ctx.lr = 0x82E790B8;
	sub_82CA93D0(ctx, base);
	// 82E790B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E790BC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E790C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E790C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E790C8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E790CC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E790D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E790D4: 4E800421  bctrl
	ctx.lr = 0x82E790D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E790D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E790DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E790E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E790E4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E790E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E790EC: 4E800421  bctrl
	ctx.lr = 0x82E790F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E790F0: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82E790F4: 409A000C  bne cr6, 0x82e79100
	if !ctx.cr[6].eq {
	pc = 0x82E79100; continue 'dispatch;
	}
	// 82E790F8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E790FC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E79100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E79104: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E79108: 4BE30354  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E79110 size=36
    let mut pc: u32 = 0x82E79110;
    'dispatch: loop {
        match pc {
            0x82E79110 => {
    //   block [0x82E79110..0x82E79134)
	// 82E79110: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E79114: 396B8C3C  addi r11, r11, -0x73c4
	ctx.r[11].s64 = ctx.r[11].s64 + -29636;
	// 82E79118: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E7911C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E79120: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E79124: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79128: 4182000C  beq 0x82e79134
	if ctx.cr[0].eq {
		sub_82E79134(ctx, base);
		return;
	}
	// 82E7912C: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E79130: 4800000C  b 0x82e7913c
	sub_82E79134(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79134(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E79134 size=40
    let mut pc: u32 = 0x82E79134;
    'dispatch: loop {
        match pc {
            0x82E79134 => {
    //   block [0x82E79134..0x82E7915C)
	// 82E79134: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E79138: C1AB0C14  lfs f13, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E7913C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E79140: C00B0AA4  lfs f0, 0xaa4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2724 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79144: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E79148: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E7914C: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E79150: C00B0BD8  lfs f0, 0xbd8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3032 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79154: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E79158: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E79160 size=12
    let mut pc: u32 = 0x82E79160;
    'dispatch: loop {
        match pc {
            0x82E79160 => {
    //   block [0x82E79160..0x82E7916C)
	// 82E79160: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E79164: 386BC4B4  addi r3, r11, -0x3b4c
	ctx.r[3].s64 = ctx.r[11].s64 + -15180;
	// 82E79168: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E79170 size=56
    let mut pc: u32 = 0x82E79170;
    'dispatch: loop {
        match pc {
            0x82E79170 => {
    //   block [0x82E79170..0x82E791A8)
	// 82E79170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E79174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E79178: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7917C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82E79180: 4B79D7A9  bl 0x82616928
	ctx.lr = 0x82E79184;
	sub_82616928(ctx, base);
	// 82E79184: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79188: 4182000C  beq 0x82e79194
	if ctx.cr[0].eq {
	pc = 0x82E79194; continue 'dispatch;
	}
	// 82E7918C: 4BFFFF85  bl 0x82e79110
	ctx.lr = 0x82E79190;
	sub_82E79110(ctx, base);
	// 82E79190: 48000008  b 0x82e79198
	pc = 0x82E79198; continue 'dispatch;
	// 82E79194: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E79198: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E7919C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E791A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E791A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E791A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E791A8 size=164
    let mut pc: u32 = 0x82E791A8;
    'dispatch: loop {
        match pc {
            0x82E791A8 => {
    //   block [0x82E791A8..0x82E7924C)
	// 82E791A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E791AC: 4BE30261  bl 0x82ca940c
	ctx.lr = 0x82E791B0;
	sub_82CA93D0(ctx, base);
	// 82E791B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E791B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E791B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E791BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E791C0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E791C4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E791C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E791CC: 4E800421  bctrl
	ctx.lr = 0x82E791D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E791D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E791D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E791D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E791DC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E791E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E791E4: 4E800421  bctrl
	ctx.lr = 0x82E791E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E791E8: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82E791EC: 409A0054  bne cr6, 0x82e79240
	if !ctx.cr[6].eq {
	pc = 0x82E79240; continue 'dispatch;
	}
	// 82E791F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E791F4: C19E0004  lfs f12, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E791F8: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E791FC: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E79200: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82E79204: 41980008  blt cr6, 0x82e7920c
	if ctx.cr[6].lt {
	pc = 0x82E7920C; continue 'dispatch;
	}
	// 82E79208: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 82E7920C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82E79210: 409AFFF0  bne cr6, 0x82e79200
	if !ctx.cr[6].eq {
	pc = 0x82E79200; continue 'dispatch;
	}
	// 82E79214: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E79218: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7921C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E79220: 41980014  blt cr6, 0x82e79234
	if ctx.cr[6].lt {
	pc = 0x82E79234; continue 'dispatch;
	}
	// 82E79224: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E79228: C1AB0A44  lfs f13, 0xa44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2628 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E7922C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E79230: 4099000C  ble cr6, 0x82e7923c
	if !ctx.cr[6].gt {
	pc = 0x82E7923C; continue 'dispatch;
	}
	// 82E79234: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E79238: 48000008  b 0x82e79240
	pc = 0x82E79240; continue 'dispatch;
	// 82E7923C: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E79240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E79244: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E79248: 4BE30214  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E79250 size=12
    let mut pc: u32 = 0x82E79250;
    'dispatch: loop {
        match pc {
            0x82E79250 => {
    //   block [0x82E79250..0x82E7925C)
	// 82E79250: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E79254: 386BC5C8  addi r3, r11, -0x3a38
	ctx.r[3].s64 = ctx.r[11].s64 + -14904;
	// 82E79258: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E79260 size=112
    let mut pc: u32 = 0x82E79260;
    'dispatch: loop {
        match pc {
            0x82E79260 => {
    //   block [0x82E79260..0x82E792D0)
	// 82E79260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E79264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E79268: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7926C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82E79270: 4B79D6B9  bl 0x82616928
	ctx.lr = 0x82E79274;
	sub_82616928(ctx, base);
	// 82E79274: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79278: 41820044  beq 0x82e792bc
	if ctx.cr[0].eq {
	pc = 0x82E792BC; continue 'dispatch;
	}
	// 82E7927C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E79280: 396B8C68  addi r11, r11, -0x7398
	ctx.r[11].s64 = ctx.r[11].s64 + -29592;
	// 82E79284: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E79288: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7928C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E79290: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79294: 4182000C  beq 0x82e792a0
	if ctx.cr[0].eq {
	pc = 0x82E792A0; continue 'dispatch;
	}
	// 82E79298: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E7929C: 4800000C  b 0x82e792a8
	pc = 0x82E792A8; continue 'dispatch;
	// 82E792A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E792A4: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E792A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E792AC: C00B0B64  lfs f0, 0xb64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2916 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E792B0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E792B4: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E792B8: 48000008  b 0x82e792c0
	pc = 0x82E792C0; continue 'dispatch;
	// 82E792BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E792C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E792C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E792C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E792CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E792D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E792D0 size=12
    let mut pc: u32 = 0x82E792D0;
    'dispatch: loop {
        match pc {
            0x82E792D0 => {
    //   block [0x82E792D0..0x82E792DC)
	// 82E792D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E792D4: 99630004  stb r11, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82E792D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E792E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E792E0 size=72
    let mut pc: u32 = 0x82E792E0;
    'dispatch: loop {
        match pc {
            0x82E792E0 => {
    //   block [0x82E792E0..0x82E79328)
	// 82E792E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E792E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E792E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E792EC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82E792F0: 4B79D639  bl 0x82616928
	ctx.lr = 0x82E792F4;
	sub_82616928(ctx, base);
	// 82E792F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E792F8: 4182001C  beq 0x82e79314
	if ctx.cr[0].eq {
	pc = 0x82E79314; continue 'dispatch;
	}
	// 82E792FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E79300: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E79304: 396B1B48  addi r11, r11, 0x1b48
	ctx.r[11].s64 = ctx.r[11].s64 + 6984;
	// 82E79308: 99430004  stb r10, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 82E7930C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E79310: 48000008  b 0x82e79318
	pc = 0x82E79318; continue 'dispatch;
	// 82E79314: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E79318: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E7931C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E79320: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E79324: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E79328 size=72
    let mut pc: u32 = 0x82E79328;
    'dispatch: loop {
        match pc {
            0x82E79328 => {
    //   block [0x82E79328..0x82E79370)
	// 82E79328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7932C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E79330: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E79334: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82E79338: 4B79D5F1  bl 0x82616928
	ctx.lr = 0x82E7933C;
	sub_82616928(ctx, base);
	// 82E7933C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79340: 4182001C  beq 0x82e7935c
	if ctx.cr[0].eq {
	pc = 0x82E7935C; continue 'dispatch;
	}
	// 82E79344: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E79348: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E7934C: 396B18AC  addi r11, r11, 0x18ac
	ctx.r[11].s64 = ctx.r[11].s64 + 6316;
	// 82E79350: 99430004  stb r10, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 82E79354: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E79358: 48000008  b 0x82e79360
	pc = 0x82E79360; continue 'dispatch;
	// 82E7935C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E79360: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E79364: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E79368: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E7936C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E79370 size=12
    let mut pc: u32 = 0x82E79370;
    'dispatch: loop {
        match pc {
            0x82E79370 => {
    //   block [0x82E79370..0x82E7937C)
	// 82E79370: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E79374: 386BC904  addi r3, r11, -0x36fc
	ctx.r[3].s64 = ctx.r[11].s64 + -14076;
	// 82E79378: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E79380 size=80
    let mut pc: u32 = 0x82E79380;
    'dispatch: loop {
        match pc {
            0x82E79380 => {
    //   block [0x82E79380..0x82E793D0)
	// 82E79380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E79384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E79388: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E7938C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E79390: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E79394: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E79398: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E7939C: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E793A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E793A4: 41820014  beq 0x82e793b8
	if ctx.cr[0].eq {
	pc = 0x82E793B8; continue 'dispatch;
	}
	// 82E793A8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E793AC: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E793B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E793B4: 4E800421  bctrl
	ctx.lr = 0x82E793B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E793B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E793BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E793C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E793C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E793C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E793CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E793D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E793D0 size=72
    let mut pc: u32 = 0x82E793D0;
    'dispatch: loop {
        match pc {
            0x82E793D0 => {
    //   block [0x82E793D0..0x82E79418)
	// 82E793D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E793D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E793D8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E793DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E793E0: 4B79D549  bl 0x82616928
	ctx.lr = 0x82E793E4;
	sub_82616928(ctx, base);
	// 82E793E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E793E8: 4182001C  beq 0x82e79404
	if ctx.cr[0].eq {
	pc = 0x82E79404; continue 'dispatch;
	}
	// 82E793EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E793F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E793F4: 396B8CB4  addi r11, r11, -0x734c
	ctx.r[11].s64 = ctx.r[11].s64 + -29516;
	// 82E793F8: 99430004  stb r10, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 82E793FC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E79400: 48000008  b 0x82e79408
	pc = 0x82E79408; continue 'dispatch;
	// 82E79404: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E79408: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E7940C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E79410: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E79414: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E79418 size=12
    let mut pc: u32 = 0x82E79418;
    'dispatch: loop {
        match pc {
            0x82E79418 => {
    //   block [0x82E79418..0x82E79424)
	// 82E79418: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7941C: 386BCA18  addi r3, r11, -0x35e8
	ctx.r[3].s64 = ctx.r[11].s64 + -13800;
	// 82E79420: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E79428 size=104
    let mut pc: u32 = 0x82E79428;
    'dispatch: loop {
        match pc {
            0x82E79428 => {
    //   block [0x82E79428..0x82E79490)
	// 82E79428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7942C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E79430: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E79434: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 82E79438: 4B79D4F1  bl 0x82616928
	ctx.lr = 0x82E7943C;
	sub_82616928(ctx, base);
	// 82E7943C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79440: 4182003C  beq 0x82e7947c
	if ctx.cr[0].eq {
	pc = 0x82E7947C; continue 'dispatch;
	}
	// 82E79444: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E79448: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E7944C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79450: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E79454: 99430004  stb r10, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 82E79458: 396B8CE0  addi r11, r11, -0x7320
	ctx.r[11].s64 = ctx.r[11].s64 + -29472;
	// 82E7945C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E79460: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E79464: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E79468: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E7946C: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E79470: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E79474: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82E79478: 48000008  b 0x82e79480
	pc = 0x82E79480; continue 'dispatch;
	// 82E7947C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E79480: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E79484: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E79488: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E7948C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E79490 size=152
    let mut pc: u32 = 0x82E79490;
    'dispatch: loop {
        match pc {
            0x82E79490 => {
    //   block [0x82E79490..0x82E79528)
	// 82E79490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E79494: 4BE2FF79  bl 0x82ca940c
	ctx.lr = 0x82E79498;
	sub_82CA93D0(ctx, base);
	// 82E79498: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7949C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E794A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E794A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E794A8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E794AC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E794B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E794B4: 4E800421  bctrl
	ctx.lr = 0x82E794B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E794B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E794BC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E794C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E794C4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E794C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E794CC: 4E800421  bctrl
	ctx.lr = 0x82E794D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E794D0: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82E794D4: 409A0048  bne cr6, 0x82e7951c
	if !ctx.cr[6].eq {
	pc = 0x82E7951C; continue 'dispatch;
	}
	// 82E794D8: C01E0008  lfs f0, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E794DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E794E0: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E794E4: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E794E8: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E794EC: C01E0010  lfs f0, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E794F0: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E794F4: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82E794F8: 895E0020  lbz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E794FC: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82E79500: 995F0020  stb r10, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 82E79504: C01E0014  lfs f0, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79508: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E7950C: C01E0018  lfs f0, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79510: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E79514: C01E001C  lfs f0, 0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79518: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82E7951C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E79520: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E79524: 4BE2FF38  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E79528 size=12
    let mut pc: u32 = 0x82E79528;
    'dispatch: loop {
        match pc {
            0x82E79528 => {
    //   block [0x82E79528..0x82E79534)
	// 82E79528: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7952C: 386BCB2C  addi r3, r11, -0x34d4
	ctx.r[3].s64 = ctx.r[11].s64 + -13524;
	// 82E79530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E79538 size=72
    let mut pc: u32 = 0x82E79538;
    'dispatch: loop {
        match pc {
            0x82E79538 => {
    //   block [0x82E79538..0x82E79580)
	// 82E79538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7953C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E79540: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E79544: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82E79548: 4B79D3E1  bl 0x82616928
	ctx.lr = 0x82E7954C;
	sub_82616928(ctx, base);
	// 82E7954C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79550: 4182001C  beq 0x82e7956c
	if ctx.cr[0].eq {
	pc = 0x82E7956C; continue 'dispatch;
	}
	// 82E79554: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E79558: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E7955C: 396B8D08  addi r11, r11, -0x72f8
	ctx.r[11].s64 = ctx.r[11].s64 + -29432;
	// 82E79560: 99430004  stb r10, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 82E79564: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E79568: 48000008  b 0x82e79570
	pc = 0x82E79570; continue 'dispatch;
	// 82E7956C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E79570: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E79574: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E79578: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E7957C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E79580 size=148
    let mut pc: u32 = 0x82E79580;
    'dispatch: loop {
        match pc {
            0x82E79580 => {
    //   block [0x82E79580..0x82E79614)
	// 82E79580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E79584: 4BE2FE89  bl 0x82ca940c
	ctx.lr = 0x82E79588;
	sub_82CA93D0(ctx, base);
	// 82E79588: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7958C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E79590: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E79594: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E79598: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E7959C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E795A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E795A4: 4E800421  bctrl
	ctx.lr = 0x82E795A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E795A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E795AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E795B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E795B4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E795B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E795BC: 4E800421  bctrl
	ctx.lr = 0x82E795C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E795C0: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82E795C4: 409A0044  bne cr6, 0x82e79608
	if !ctx.cr[6].eq {
	pc = 0x82E79608; continue 'dispatch;
	}
	// 82E795C8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E795CC: C01E0008  lfs f0, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E795D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E795D4: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E795D8: C16A0C14  lfs f11, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E795DC: C18B0EE0  lfs f12, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E795E0: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82E795E4: 41980010  blt cr6, 0x82e795f4
	if ctx.cr[6].lt {
	pc = 0x82E795F4; continue 'dispatch;
	}
	// 82E795E8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82E795EC: 41990008  bgt cr6, 0x82e795f4
	if ctx.cr[6].gt {
	pc = 0x82E795F4; continue 'dispatch;
	}
	// 82E795F0: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82E795F4: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82E795F8: 409AFFE8  bne cr6, 0x82e795e0
	if !ctx.cr[6].eq {
	pc = 0x82E795E0; continue 'dispatch;
	}
	// 82E795FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E79600: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E79604: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82E79608: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7960C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E79610: 4BE2FE4C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E79618 size=12
    let mut pc: u32 = 0x82E79618;
    'dispatch: loop {
        match pc {
            0x82E79618 => {
    //   block [0x82E79618..0x82E79624)
	// 82E79618: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7961C: 386BCC40  addi r3, r11, -0x33c0
	ctx.r[3].s64 = ctx.r[11].s64 + -13248;
	// 82E79620: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E79628 size=84
    let mut pc: u32 = 0x82E79628;
    'dispatch: loop {
        match pc {
            0x82E79628 => {
    //   block [0x82E79628..0x82E7967C)
	// 82E79628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7962C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E79630: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E79634: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E79638: 4B79D2F1  bl 0x82616928
	ctx.lr = 0x82E7963C;
	sub_82616928(ctx, base);
	// 82E7963C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79640: 41820028  beq 0x82e79668
	if ctx.cr[0].eq {
	pc = 0x82E79668; continue 'dispatch;
	}
	// 82E79644: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E79648: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E7964C: 396B8D30  addi r11, r11, -0x72d0
	ctx.r[11].s64 = ctx.r[11].s64 + -29392;
	// 82E79650: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79654: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E79658: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E7965C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E79660: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E79664: 48000008  b 0x82e7966c
	pc = 0x82E7966C; continue 'dispatch;
	// 82E79668: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E7966C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E79670: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E79674: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E79678: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E79680 size=12
    let mut pc: u32 = 0x82E79680;
    'dispatch: loop {
        match pc {
            0x82E79680 => {
    //   block [0x82E79680..0x82E7968C)
	// 82E79680: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E79684: 386BCD54  addi r3, r11, -0x32ac
	ctx.r[3].s64 = ctx.r[11].s64 + -12972;
	// 82E79688: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E79690 size=72
    let mut pc: u32 = 0x82E79690;
    'dispatch: loop {
        match pc {
            0x82E79690 => {
    //   block [0x82E79690..0x82E796D8)
	// 82E79690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E79694: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E79698: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7969C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82E796A0: 4B79D289  bl 0x82616928
	ctx.lr = 0x82E796A4;
	sub_82616928(ctx, base);
	// 82E796A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E796A8: 4182001C  beq 0x82e796c4
	if ctx.cr[0].eq {
	pc = 0x82E796C4; continue 'dispatch;
	}
	// 82E796AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E796B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E796B4: 396B8D58  addi r11, r11, -0x72a8
	ctx.r[11].s64 = ctx.r[11].s64 + -29352;
	// 82E796B8: 99430004  stb r10, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 82E796BC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E796C0: 48000008  b 0x82e796c8
	pc = 0x82E796C8; continue 'dispatch;
	// 82E796C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E796C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E796CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E796D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E796D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E796D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E796D8 size=100
    let mut pc: u32 = 0x82E796D8;
    'dispatch: loop {
        match pc {
            0x82E796D8 => {
    //   block [0x82E796D8..0x82E7973C)
	// 82E796D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E796DC: 4BE2FD31  bl 0x82ca940c
	ctx.lr = 0x82E796E0;
	sub_82CA93D0(ctx, base);
	// 82E796E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E796E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E796E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E796EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E796F0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E796F4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E796F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E796FC: 4E800421  bctrl
	ctx.lr = 0x82E79700;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E79700: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E79704: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E79708: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7970C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E79710: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E79714: 4E800421  bctrl
	ctx.lr = 0x82E79718;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E79718: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82E7971C: 409A0014  bne cr6, 0x82e79730
	if !ctx.cr[6].eq {
	pc = 0x82E79730; continue 'dispatch;
	}
	// 82E79720: 897E0008  lbz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E79724: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E79728: 997F0008  stb r11, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 82E7972C: 995F0004  stb r10, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 82E79730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E79734: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E79738: 4BE2FD24  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E79740 size=12
    let mut pc: u32 = 0x82E79740;
    'dispatch: loop {
        match pc {
            0x82E79740 => {
    //   block [0x82E79740..0x82E7974C)
	// 82E79740: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E79744: 386BCE68  addi r3, r11, -0x3198
	ctx.r[3].s64 = ctx.r[11].s64 + -12696;
	// 82E79748: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E79750 size=72
    let mut pc: u32 = 0x82E79750;
    'dispatch: loop {
        match pc {
            0x82E79750 => {
    //   block [0x82E79750..0x82E79798)
	// 82E79750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E79754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E79758: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7975C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82E79760: 4B79D1C9  bl 0x82616928
	ctx.lr = 0x82E79764;
	sub_82616928(ctx, base);
	// 82E79764: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79768: 4182001C  beq 0x82e79784
	if ctx.cr[0].eq {
	pc = 0x82E79784; continue 'dispatch;
	}
	// 82E7976C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E79770: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E79774: 396B8D7C  addi r11, r11, -0x7284
	ctx.r[11].s64 = ctx.r[11].s64 + -29316;
	// 82E79778: 99430004  stb r10, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 82E7977C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E79780: 48000008  b 0x82e79788
	pc = 0x82E79788; continue 'dispatch;
	// 82E79784: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E79788: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E7978C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E79790: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E79794: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E79798 size=12
    let mut pc: u32 = 0x82E79798;
    'dispatch: loop {
        match pc {
            0x82E79798 => {
    //   block [0x82E79798..0x82E797A4)
	// 82E79798: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7979C: 386BCF7C  addi r3, r11, -0x3084
	ctx.r[3].s64 = ctx.r[11].s64 + -12420;
	// 82E797A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E797A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E797A8 size=72
    let mut pc: u32 = 0x82E797A8;
    'dispatch: loop {
        match pc {
            0x82E797A8 => {
    //   block [0x82E797A8..0x82E797F0)
	// 82E797A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E797AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E797B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E797B4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82E797B8: 4B79D171  bl 0x82616928
	ctx.lr = 0x82E797BC;
	sub_82616928(ctx, base);
	// 82E797BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E797C0: 4182001C  beq 0x82e797dc
	if ctx.cr[0].eq {
	pc = 0x82E797DC; continue 'dispatch;
	}
	// 82E797C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E797C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E797CC: 396B8DA4  addi r11, r11, -0x725c
	ctx.r[11].s64 = ctx.r[11].s64 + -29276;
	// 82E797D0: 99430004  stb r10, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 82E797D4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E797D8: 48000008  b 0x82e797e0
	pc = 0x82E797E0; continue 'dispatch;
	// 82E797DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E797E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E797E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E797E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E797EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E797F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E797F0 size=12
    let mut pc: u32 = 0x82E797F0;
    'dispatch: loop {
        match pc {
            0x82E797F0 => {
    //   block [0x82E797F0..0x82E797FC)
	// 82E797F0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E797F4: 386BD098  addi r3, r11, -0x2f68
	ctx.r[3].s64 = ctx.r[11].s64 + -12136;
	// 82E797F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E79800 size=124
    let mut pc: u32 = 0x82E79800;
    'dispatch: loop {
        match pc {
            0x82E79800 => {
    //   block [0x82E79800..0x82E7987C)
	// 82E79800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E79804: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E79808: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E7980C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E79810: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E79814: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E79818: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E7981C: 3FC08330  lis r30, -0x7cd0
	ctx.r[30].s64 = -2094006272;
	// 82E79820: 396B8DD0  addi r11, r11, -0x7230
	ctx.r[11].s64 = ctx.r[11].s64 + -29232;
	// 82E79824: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E79828: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7982C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E79830: 41820010  beq 0x82e79840
	if ctx.cr[0].eq {
	pc = 0x82E79840; continue 'dispatch;
	}
	// 82E79834: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E79838: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E7983C: 4E800421  bctrl
	ctx.lr = 0x82E79840;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E79840: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E79844: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79848: 41820010  beq 0x82e79858
	if ctx.cr[0].eq {
	pc = 0x82E79858; continue 'dispatch;
	}
	// 82E7984C: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E79850: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E79854: 4E800421  bctrl
	ctx.lr = 0x82E79858;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E79858: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E7985C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E79860: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E79864: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E79868: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E7986C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E79870: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E79874: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E79878: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E79880 size=484
    let mut pc: u32 = 0x82E79880;
    'dispatch: loop {
        match pc {
            0x82E79880 => {
    //   block [0x82E79880..0x82E79A64)
	// 82E79880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E79884: 4BE2FB81  bl 0x82ca9404
	ctx.lr = 0x82E79888;
	sub_82CA93D0(ctx, base);
	// 82E79888: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7988C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E79890: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E79894: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E79898: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E7989C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E798A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E798A4: 4E800421  bctrl
	ctx.lr = 0x82E798A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E798A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E798AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E798B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E798B4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E798B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E798BC: 4E800421  bctrl
	ctx.lr = 0x82E798C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E798C0: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82E798C4: 409A0194  bne cr6, 0x82e79a58
	if !ctx.cr[6].eq {
	pc = 0x82E79A58; continue 'dispatch;
	}
	// 82E798C8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E798CC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82E798D0: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E798D4: 3F808330  lis r28, -0x7cd0
	ctx.r[28].s64 = -2094006272;
	// 82E798D8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E798DC: 419A0094  beq cr6, 0x82e79970
	if ctx.cr[6].eq {
	pc = 0x82E79970; continue 'dispatch;
	}
	// 82E798E0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E798E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E798E8: 41820010  beq 0x82e798f8
	if ctx.cr[0].eq {
	pc = 0x82E798F8; continue 'dispatch;
	}
	// 82E798EC: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E798F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E798F4: 4E800421  bctrl
	ctx.lr = 0x82E798F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E798F8: 83DD0008  lwz r30, 8(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E798FC: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79900: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82E79904: 41820068  beq 0x82e7996c
	if ctx.cr[0].eq {
	pc = 0x82E7996C; continue 'dispatch;
	}
	// 82E79908: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 82E7990C: 1C7E000C  mulli r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 * 12;
	// 82E79910: 616B5555  ori r11, r11, 0x5555
	ctx.r[11].u64 = ctx.r[11].u64 | 21845;
	// 82E79914: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E79918: 40990008  ble cr6, 0x82e79920
	if !ctx.cr[6].gt {
	pc = 0x82E79920; continue 'dispatch;
	}
	// 82E7991C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82E79920: 4B79D009  bl 0x82616928
	ctx.lr = 0x82E79924;
	sub_82616928(ctx, base);
	// 82E79924: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79928: 41820038  beq 0x82e79960
	if ctx.cr[0].eq {
	pc = 0x82E79960; continue 'dispatch;
	}
	// 82E7992C: 355EFFFF  addic. r10, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E79930: 41800028  blt 0x82e79958
	if ctx.cr[0].lt {
	pc = 0x82E79958; continue 'dispatch;
	}
	// 82E79934: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E79938: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 82E7993C: C0090C18  lfs f0, 0xc18(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79940: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82E79944: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E79948: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82E7994C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E79950: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82E79954: 4080FFEC  bge 0x82e79940
	if !ctx.cr[0].lt {
	pc = 0x82E79940; continue 'dispatch;
	}
	// 82E79958: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E7995C: 48000008  b 0x82e79964
	pc = 0x82E79964; continue 'dispatch;
	// 82E79960: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82E79964: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E79968: 48000008  b 0x82e79970
	pc = 0x82E79970; continue 'dispatch;
	// 82E7996C: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82E79970: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E79974: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E79978: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E7997C: 419A0040  beq cr6, 0x82e799bc
	if ctx.cr[6].eq {
	pc = 0x82E799BC; continue 'dispatch;
	}
	// 82E79980: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E79984: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79988: 41820010  beq 0x82e79998
	if ctx.cr[0].eq {
	pc = 0x82E79998; continue 'dispatch;
	}
	// 82E7998C: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E79990: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E79994: 4E800421  bctrl
	ctx.lr = 0x82E79998;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E79998: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E7999C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E799A0: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E799A4: 41820014  beq 0x82e799b8
	if ctx.cr[0].eq {
	pc = 0x82E799B8; continue 'dispatch;
	}
	// 82E799A8: 55631838  slwi r3, r11, 3
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82E799AC: 4B79CF7D  bl 0x82616928
	ctx.lr = 0x82E799B0;
	sub_82616928(ctx, base);
	// 82E799B0: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82E799B4: 48000008  b 0x82e799bc
	pc = 0x82E799BC; continue 'dispatch;
	// 82E799B8: 937F000C  stw r27, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 82E799BC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E799C0: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 82E799C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E799C8: 40990044  ble cr6, 0x82e79a0c
	if !ctx.cr[6].gt {
	pc = 0x82E79A0C; continue 'dispatch;
	}
	// 82E799CC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82E799D0: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E799D4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82E799D8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E799DC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E799E0: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82E799E4: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82E799E8: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E799EC: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E799F0: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E799F4: D0090004  stfs f0, 4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E799F8: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E799FC: D0090008  stfs f0, 8(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E79A00: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E79A04: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E79A08: 4198FFC8  blt cr6, 0x82e799d0
	if ctx.cr[6].lt {
	pc = 0x82E799D0; continue 'dispatch;
	}
	// 82E79A0C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E79A10: 809D000C  lwz r4, 0xc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E79A14: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82E79A18: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E79A1C: 4BE2FA65  bl 0x82ca9480
	ctx.lr = 0x82E79A20;
	sub_82CA9480(ctx, base);
	// 82E79A20: C01D0014  lfs f0, 0x14(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79A24: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E79A28: C01D0018  lfs f0, 0x18(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79A2C: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E79A30: C01D001C  lfs f0, 0x1c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79A34: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82E79A38: C01D0020  lfs f0, 0x20(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79A3C: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82E79A40: C01D0024  lfs f0, 0x24(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79A44: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82E79A48: C01D0028  lfs f0, 0x28(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79A4C: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82E79A50: 897D002C  lbz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E79A54: 997F002C  stb r11, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u8 ) };
	// 82E79A58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E79A5C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E79A60: 4BE2F9F4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E79A68 size=668
    let mut pc: u32 = 0x82E79A68;
    'dispatch: loop {
        match pc {
            0x82E79A68 => {
    //   block [0x82E79A68..0x82E79D04)
	// 82E79A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E79A6C: 4BE2F99D  bl 0x82ca9408
	ctx.lr = 0x82E79A70;
	sub_82CA93D0(ctx, base);
	// 82E79A70: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 82E79A74: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82E79A78: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82E79A7C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E79A80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E79A84: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E79A88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E79A8C: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 82E79A90: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E79A94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E79A98: 4B36EBE1  bl 0x821e8678
	ctx.lr = 0x82E79A9C;
	sub_821E8678(ctx, base);
	// 82E79A9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79AA0: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82E79AA4: 40820008  bne 0x82e79aac
	if !ctx.cr[0].eq {
	pc = 0x82E79AAC; continue 'dispatch;
	}
	// 82E79AA8: 397E004C  addi r11, r30, 0x4c
	ctx.r[11].s64 = ctx.r[30].s64 + 76;
	// 82E79AAC: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82E79AB0: C3EB0000  lfs f31, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E79AB4: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E79AB8: 3F808334  lis r28, -0x7ccc
	ctx.r[28].s64 = -2093744128;
	// 82E79ABC: C3CB0008  lfs f30, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E79AC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E79AC4: 8149D094  lwz r10, -0x2f6c(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 82E79AC8: C3AB0C14  lfs f29, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82E79ACC: 554807FF  clrlwi. r8, r10, 0x1f
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E79AD0: 3D008334  lis r8, -0x7ccc
	ctx.r[8].s64 = -2093744128;
	// 82E79AD4: 40820038  bne 0x82e79b0c
	if !ctx.cr[0].eq {
	pc = 0x82E79B0C; continue 'dispatch;
	}
	// 82E79AD8: 614A0001  ori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 1;
	// 82E79ADC: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E79AE0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79AE4: 9149D094  stw r10, -0x2f6c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-12140 as u32), ctx.r[10].u32 ) };
	// 82E79AE8: 4182000C  beq 0x82e79af4
	if ctx.cr[0].eq {
	pc = 0x82E79AF4; continue 'dispatch;
	}
	// 82E79AEC: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E79AF0: 48000008  b 0x82e79af8
	pc = 0x82E79AF8; continue 'dispatch;
	// 82E79AF4: FDA0E890  fmr f13, f29
	ctx.f[13].f64 = ctx.f[29].f64;
	// 82E79AF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E79AFC: C00B0BF8  lfs f0, 0xbf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3064 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79B00: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E79B04: D008D090  stfs f0, -0x2f70(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(-12144 as u32), tmp.u32 ) };
	// 82E79B08: 48000008  b 0x82e79b10
	pc = 0x82E79B10; continue 'dispatch;
	// 82E79B0C: C008D090  lfs f0, -0x2f70(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79B10: C1BE0038  lfs f13, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E79B14: C19F0024  lfs f12, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E79B18: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E79B1C: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82E79B20: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E79B24: 40980060  bge cr6, 0x82e79b84
	if !ctx.cr[6].lt {
	pc = 0x82E79B84; continue 'dispatch;
	}
	// 82E79B28: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E79B2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E79B30: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E79B34: C19F001C  lfs f12, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E79B38: ED8C6FBA  fmadds f12, f12, f30, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64);
	// 82E79B3C: C1AB0BDC  lfs f13, 0xbdc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3036 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E79B40: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82E79B44: 40990040  ble cr6, 0x82e79b84
	if !ctx.cr[6].gt {
	pc = 0x82E79B84; continue 'dispatch;
	}
	// 82E79B48: ED400032  fmuls f10, f0, f0
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E79B4C: C1BE0034  lfs f13, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E79B50: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79B54: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E79B58: C19F0024  lfs f12, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E79B5C: C1BE0038  lfs f13, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E79B60: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E79B64: C13E003C  lfs f9, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E79B68: C19F0028  lfs f12, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E79B6C: ED8C4828  fsubs f12, f12, f9
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82E79B70: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E79B74: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E79B78: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E79B7C: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82E79B80: 41980170  blt cr6, 0x82e79cf0
	if ctx.cr[6].lt {
	pc = 0x82E79CF0; continue 'dispatch;
	}
	// 82E79B84: C01E0034  lfs f0, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79B88: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E79B8C: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82E79B90: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E79B94: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79B98: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E79B9C: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82E79BA0: 388BDA4C  addi r4, r11, -0x25b4
	ctx.r[4].s64 = ctx.r[11].s64 + -9652;
	// 82E79BA4: C01E003C  lfs f0, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79BA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E79BAC: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82E79BB0: D3FF0014  stfs f31, 0x14(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E79BB4: D17F0018  stfs f11, 0x18(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E79BB8: D3DF001C  stfs f30, 0x1c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82E79BBC: 995F002C  stb r10, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u8 ) };
	// 82E79BC0: 4B36EAB9  bl 0x821e8678
	ctx.lr = 0x82E79BC4;
	sub_821E8678(ctx, base);
	// 82E79BC4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E79BC8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E79BCC: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82E79BD0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E79BD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E79BD8: 4B36EAA1  bl 0x821e8678
	ctx.lr = 0x82E79BDC;
	sub_821E8678(ctx, base);
	// 82E79BDC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E79BE0: 419A000C  beq cr6, 0x82e79bec
	if ctx.cr[6].eq {
	pc = 0x82E79BEC; continue 'dispatch;
	}
	// 82E79BE4: C1BD0004  lfs f13, 4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E79BE8: 4800001C  b 0x82e79c04
	pc = 0x82E79C04; continue 'dispatch;
	// 82E79BEC: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E79BF0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79BF4: 4182000C  beq 0x82e79c00
	if ctx.cr[0].eq {
	pc = 0x82E79C00; continue 'dispatch;
	}
	// 82E79BF8: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E79BFC: 48000008  b 0x82e79c04
	pc = 0x82E79C04; continue 'dispatch;
	// 82E79C00: FDA0E890  fmr f13, f29
	ctx.f[13].f64 = ctx.f[29].f64;
	// 82E79C04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E79C08: 419A000C  beq cr6, 0x82e79c14
	if ctx.cr[6].eq {
	pc = 0x82E79C14; continue 'dispatch;
	}
	// 82E79C0C: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E79C10: 48000008  b 0x82e79c18
	pc = 0x82E79C18; continue 'dispatch;
	// 82E79C14: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	// 82E79C18: ED7E0332  fmuls f11, f30, f12
	ctx.f[11].f64 = (((ctx.f[30].f64 * ctx.f[12].f64) as f32) as f64);
	// 82E79C1C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E79C20: EC1F0372  fmuls f0, f31, f13
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E79C24: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E79C28: ED9F0332  fmuls f12, f31, f12
	ctx.f[12].f64 = (((ctx.f[31].f64 * ctx.f[12].f64) as f32) as f64);
	// 82E79C2C: C0FE0034  lfs f7, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82E79C30: EDBE0372  fmuls f13, f30, f13
	ctx.f[13].f64 = (((ctx.f[30].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E79C34: C0DE003C  lfs f6, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82E79C38: C15E0038  lfs f10, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E79C3C: D14B0004  stfs f10, 4(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E79C40: C14A0BFC  lfs f10, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E79C44: FD605850  fneg f11, f11
	ctx.f[11].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 82E79C48: ED2D602A  fadds f9, f13, f12
	ctx.f[9].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E79C4C: ED00582A  fadds f8, f0, f11
	ctx.f[8].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82E79C50: ED2902B2  fmuls f9, f9, f10
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82E79C54: ED4802B2  fmuls f10, f8, f10
	ctx.f[10].f64 = (((ctx.f[8].f64 * ctx.f[10].f64) as f32) as f64);
	// 82E79C58: ED26482A  fadds f9, f6, f9
	ctx.f[9].f64 = ((ctx.f[6].f64 + ctx.f[9].f64) as f32) as f64;
	// 82E79C5C: D12B0008  stfs f9, 8(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E79C60: ED4A382A  fadds f10, f10, f7
	ctx.f[10].f64 = ((ctx.f[10].f64 + ctx.f[7].f64) as f32) as f64;
	// 82E79C64: D14B0000  stfs f10, 0(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E79C68: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E79C6C: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E79C70: C10B0008  lfs f8, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82E79C74: ED4A0028  fsubs f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E79C78: C12B0004  lfs f9, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E79C7C: ED086828  fsubs f8, f8, f13
	ctx.f[8].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E79C80: D14B000C  stfs f10, 0xc(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E79C84: D12B0010  stfs f9, 0x10(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E79C88: D10B0014  stfs f8, 0x14(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E79C8C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E79C90: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E79C94: C12B0014  lfs f9, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E79C98: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E79C9C: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E79CA0: ED896028  fsubs f12, f9, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E79CA4: D16B0018  stfs f11, 0x18(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E79CA8: D14B001C  stfs f10, 0x1c(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82E79CAC: D18B0020  stfs f12, 0x20(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82E79CB0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E79CB4: C18B0018  lfs f12, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E79CB8: C16B0020  lfs f11, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E79CBC: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E79CC0: C18B001C  lfs f12, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E79CC4: EDAB682A  fadds f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E79CC8: D00B0024  stfs f0, 0x24(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82E79CCC: D18B0028  stfs f12, 0x28(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82E79CD0: D1AB002C  stfs f13, 0x2c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82E79CD4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E79CD8: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79CDC: D00B0030  stfs f0, 0x30(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82E79CE0: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79CE4: D00B0034  stfs f0, 0x34(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82E79CE8: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79CEC: D00B0038  stfs f0, 0x38(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82E79CF0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E79CF4: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82E79CF8: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82E79CFC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82E79D00: 4BE2F758  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E79D08 size=136
    let mut pc: u32 = 0x82E79D08;
    'dispatch: loop {
        match pc {
            0x82E79D08 => {
    //   block [0x82E79D08..0x82E79D90)
	// 82E79D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E79D0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E79D10: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E79D14: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82E79D18: 4B79CC11  bl 0x82616928
	ctx.lr = 0x82E79D1C;
	sub_82616928(ctx, base);
	// 82E79D1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79D20: 4182005C  beq 0x82e79d7c
	if ctx.cr[0].eq {
	pc = 0x82E79D7C; continue 'dispatch;
	}
	// 82E79D24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E79D28: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E79D2C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79D30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E79D34: C1A90BEC  lfs f13, 0xbec(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3052 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E79D38: 394B8DD0  addi r10, r11, -0x7230
	ctx.r[10].s64 = ctx.r[11].s64 + -29232;
	// 82E79D3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E79D40: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E79D44: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E79D48: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E79D4C: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E79D50: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E79D54: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E79D58: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E79D5C: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82E79D60: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82E79D64: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82E79D68: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82E79D6C: 9963002C  stb r11, 0x2c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u8 ) };
	// 82E79D70: D1A30014  stfs f13, 0x14(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E79D74: D1A30020  stfs f13, 0x20(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82E79D78: 48000008  b 0x82e79d80
	pc = 0x82E79D80; continue 'dispatch;
	// 82E79D7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E79D80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E79D84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E79D88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E79D8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E79D90 size=88
    let mut pc: u32 = 0x82E79D90;
    'dispatch: loop {
        match pc {
            0x82E79D90 => {
    //   block [0x82E79D90..0x82E79DE8)
	// 82E79D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E79D94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E79D98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E79D9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E79DA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E79DA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E79DA8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E79DAC: 4BFFFA55  bl 0x82e79800
	ctx.lr = 0x82E79DB0;
	sub_82E79800(ctx, base);
	// 82E79DB0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E79DB4: 41820018  beq 0x82e79dcc
	if ctx.cr[0].eq {
	pc = 0x82E79DCC; continue 'dispatch;
	}
	// 82E79DB8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E79DBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E79DC0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E79DC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E79DC8: 4E800421  bctrl
	ctx.lr = 0x82E79DCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E79DCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E79DD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E79DD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E79DD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E79DDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E79DE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E79DE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E79DE8 size=216
    let mut pc: u32 = 0x82E79DE8;
    'dispatch: loop {
        match pc {
            0x82E79DE8 => {
    //   block [0x82E79DE8..0x82E79EC0)
	// 82E79DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E79DEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E79DF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E79DF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E79DF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E79DFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E79E00: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E79E04: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E79E08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E79E0C: 4E800421  bctrl
	ctx.lr = 0x82E79E10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E79E10: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82E79E14: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82E79E18: 41820064  beq 0x82e79e7c
	if ctx.cr[0].eq {
	pc = 0x82E79E7C; continue 'dispatch;
	}
	// 82E79E1C: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 82E79E20: 1C7F000C  mulli r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 * 12;
	// 82E79E24: 616B5555  ori r11, r11, 0x5555
	ctx.r[11].u64 = ctx.r[11].u64 | 21845;
	// 82E79E28: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E79E2C: 40990008  ble cr6, 0x82e79e34
	if !ctx.cr[6].gt {
	pc = 0x82E79E34; continue 'dispatch;
	}
	// 82E79E30: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82E79E34: 4B79CAF5  bl 0x82616928
	ctx.lr = 0x82E79E38;
	sub_82616928(ctx, base);
	// 82E79E38: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79E3C: 41820038  beq 0x82e79e74
	if ctx.cr[0].eq {
	pc = 0x82E79E74; continue 'dispatch;
	}
	// 82E79E40: 355FFFFF  addic. r10, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E79E44: 41800028  blt 0x82e79e6c
	if ctx.cr[0].lt {
	pc = 0x82E79E6C; continue 'dispatch;
	}
	// 82E79E48: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E79E4C: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 82E79E50: C0090C18  lfs f0, 0xc18(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79E54: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82E79E58: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E79E5C: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82E79E60: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E79E64: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82E79E68: 4080FFEC  bge 0x82e79e54
	if !ctx.cr[0].lt {
	pc = 0x82E79E54; continue 'dispatch;
	}
	// 82E79E6C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E79E70: 48000008  b 0x82e79e78
	pc = 0x82E79E78; continue 'dispatch;
	// 82E79E74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E79E78: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E79E7C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E79E80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E79E84: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E79E88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E79E8C: 4E800421  bctrl
	ctx.lr = 0x82E79E90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E79E90: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79E94: 907E0010  stw r3, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82E79E98: 41820010  beq 0x82e79ea8
	if ctx.cr[0].eq {
	pc = 0x82E79EA8; continue 'dispatch;
	}
	// 82E79E9C: 54631838  slwi r3, r3, 3
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82E79EA0: 4B79CA89  bl 0x82616928
	ctx.lr = 0x82E79EA4;
	sub_82616928(ctx, base);
	// 82E79EA4: 907E000C  stw r3, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82E79EA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E79EAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E79EB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E79EB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E79EB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E79EBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E79EC0 size=12
    let mut pc: u32 = 0x82E79EC0;
    'dispatch: loop {
        match pc {
            0x82E79EC0 => {
    //   block [0x82E79EC0..0x82E79ECC)
	// 82E79EC0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E79EC4: 386BD1AC  addi r3, r11, -0x2e54
	ctx.r[3].s64 = ctx.r[11].s64 + -11860;
	// 82E79EC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E79ED0 size=72
    let mut pc: u32 = 0x82E79ED0;
    'dispatch: loop {
        match pc {
            0x82E79ED0 => {
    //   block [0x82E79ED0..0x82E79F18)
	// 82E79ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E79ED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E79ED8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E79EDC: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82E79EE0: 4B79CA49  bl 0x82616928
	ctx.lr = 0x82E79EE4;
	sub_82616928(ctx, base);
	// 82E79EE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79EE8: 4182001C  beq 0x82e79f04
	if ctx.cr[0].eq {
	pc = 0x82E79F04; continue 'dispatch;
	}
	// 82E79EEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E79EF0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E79EF4: 396B8E00  addi r11, r11, -0x7200
	ctx.r[11].s64 = ctx.r[11].s64 + -29184;
	// 82E79EF8: 99430004  stb r10, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 82E79EFC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E79F00: 48000008  b 0x82e79f08
	pc = 0x82E79F08; continue 'dispatch;
	// 82E79F04: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E79F08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E79F0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E79F10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E79F14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E79F18 size=92
    let mut pc: u32 = 0x82E79F18;
    'dispatch: loop {
        match pc {
            0x82E79F18 => {
    //   block [0x82E79F18..0x82E79F74)
	// 82E79F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E79F1C: 4BE2F4F1  bl 0x82ca940c
	ctx.lr = 0x82E79F20;
	sub_82CA93D0(ctx, base);
	// 82E79F20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E79F24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E79F28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E79F2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E79F30: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E79F34: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E79F38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E79F3C: 4E800421  bctrl
	ctx.lr = 0x82E79F40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E79F40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E79F44: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E79F48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E79F4C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E79F50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E79F54: 4E800421  bctrl
	ctx.lr = 0x82E79F58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E79F58: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82E79F5C: 409A000C  bne cr6, 0x82e79f68
	if !ctx.cr[6].eq {
	pc = 0x82E79F68; continue 'dispatch;
	}
	// 82E79F60: 897E0004  lbz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E79F64: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82E79F68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E79F6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E79F70: 4BE2F4EC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E79F78 size=12
    let mut pc: u32 = 0x82E79F78;
    'dispatch: loop {
        match pc {
            0x82E79F78 => {
    //   block [0x82E79F78..0x82E79F84)
	// 82E79F78: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E79F7C: 386BD2C0  addi r3, r11, -0x2d40
	ctx.r[3].s64 = ctx.r[11].s64 + -11584;
	// 82E79F80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E79F88 size=84
    let mut pc: u32 = 0x82E79F88;
    'dispatch: loop {
        match pc {
            0x82E79F88 => {
    //   block [0x82E79F88..0x82E79FDC)
	// 82E79F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E79F8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E79F90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E79F94: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E79F98: 4B79C991  bl 0x82616928
	ctx.lr = 0x82E79F9C;
	sub_82616928(ctx, base);
	// 82E79F9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E79FA0: 41820028  beq 0x82e79fc8
	if ctx.cr[0].eq {
	pc = 0x82E79FC8; continue 'dispatch;
	}
	// 82E79FA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E79FA8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E79FAC: 396B8E24  addi r11, r11, -0x71dc
	ctx.r[11].s64 = ctx.r[11].s64 + -29148;
	// 82E79FB0: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E79FB4: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E79FB8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E79FBC: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E79FC0: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E79FC4: 48000008  b 0x82e79fcc
	pc = 0x82E79FCC; continue 'dispatch;
	// 82E79FC8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E79FCC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E79FD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E79FD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E79FD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E79FE0 size=12
    let mut pc: u32 = 0x82E79FE0;
    'dispatch: loop {
        match pc {
            0x82E79FE0 => {
    //   block [0x82E79FE0..0x82E79FEC)
	// 82E79FE0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E79FE4: 386BD3D4  addi r3, r11, -0x2c2c
	ctx.r[3].s64 = ctx.r[11].s64 + -11308;
	// 82E79FE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E79FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E79FF0 size=84
    let mut pc: u32 = 0x82E79FF0;
    'dispatch: loop {
        match pc {
            0x82E79FF0 => {
    //   block [0x82E79FF0..0x82E7A044)
	// 82E79FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E79FF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E79FF8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E79FFC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E7A000: 4B79C929  bl 0x82616928
	ctx.lr = 0x82E7A004;
	sub_82616928(ctx, base);
	// 82E7A004: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7A008: 41820028  beq 0x82e7a030
	if ctx.cr[0].eq {
	pc = 0x82E7A030; continue 'dispatch;
	}
	// 82E7A00C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E7A010: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E7A014: 396B8E50  addi r11, r11, -0x71b0
	ctx.r[11].s64 = ctx.r[11].s64 + -29104;
	// 82E7A018: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7A01C: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E7A020: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E7A024: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E7A028: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E7A02C: 48000008  b 0x82e7a034
	pc = 0x82E7A034; continue 'dispatch;
	// 82E7A030: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E7A034: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E7A038: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E7A03C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E7A040: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E7A048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E7A048 size=12
    let mut pc: u32 = 0x82E7A048;
    'dispatch: loop {
        match pc {
            0x82E7A048 => {
    //   block [0x82E7A048..0x82E7A054)
	// 82E7A048: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7A04C: 386BD4E8  addi r3, r11, -0x2b18
	ctx.r[3].s64 = ctx.r[11].s64 + -11032;
	// 82E7A050: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E7A058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E7A058 size=64
    let mut pc: u32 = 0x82E7A058;
    'dispatch: loop {
        match pc {
            0x82E7A058 => {
    //   block [0x82E7A058..0x82E7A098)
	// 82E7A058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7A05C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E7A060: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7A064: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82E7A068: 4B79C8C1  bl 0x82616928
	ctx.lr = 0x82E7A06C;
	sub_82616928(ctx, base);
	// 82E7A06C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7A070: 41820014  beq 0x82e7a084
	if ctx.cr[0].eq {
	pc = 0x82E7A084; continue 'dispatch;
	}
	// 82E7A074: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E7A078: 396B8E78  addi r11, r11, -0x7188
	ctx.r[11].s64 = ctx.r[11].s64 + -29064;
	// 82E7A07C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E7A080: 48000008  b 0x82e7a088
	pc = 0x82E7A088; continue 'dispatch;
	// 82E7A084: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E7A088: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E7A08C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E7A090: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E7A094: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E7A098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E7A098 size=124
    let mut pc: u32 = 0x82E7A098;
    'dispatch: loop {
        match pc {
            0x82E7A098 => {
    //   block [0x82E7A098..0x82E7A114)
	// 82E7A098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7A09C: 4BE2F371  bl 0x82ca940c
	ctx.lr = 0x82E7A0A0;
	sub_82CA93D0(ctx, base);
	// 82E7A0A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7A0A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E7A0A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E7A0AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E7A0B0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E7A0B4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E7A0B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E7A0BC: 4E800421  bctrl
	ctx.lr = 0x82E7A0C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E7A0C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E7A0C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E7A0C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7A0CC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E7A0D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E7A0D4: 4E800421  bctrl
	ctx.lr = 0x82E7A0D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E7A0D8: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82E7A0DC: 409A002C  bne cr6, 0x82e7a108
	if !ctx.cr[6].eq {
	pc = 0x82E7A108; continue 'dispatch;
	}
	// 82E7A0E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E7A0E4: C1BE0004  lfs f13, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E7A0E8: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7A0EC: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E7A0F0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82E7A0F4: 41980008  blt cr6, 0x82e7a0fc
	if ctx.cr[6].lt {
	pc = 0x82E7A0FC; continue 'dispatch;
	}
	// 82E7A0F8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82E7A0FC: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82E7A100: 409AFFF0  bne cr6, 0x82e7a0f0
	if !ctx.cr[6].eq {
	pc = 0x82E7A0F0; continue 'dispatch;
	}
	// 82E7A104: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E7A108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7A10C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E7A110: 4BE2F34C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E7A118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E7A118 size=12
    let mut pc: u32 = 0x82E7A118;
    'dispatch: loop {
        match pc {
            0x82E7A118 => {
    //   block [0x82E7A118..0x82E7A124)
	// 82E7A118: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7A11C: 386BD5FC  addi r3, r11, -0x2a04
	ctx.r[3].s64 = ctx.r[11].s64 + -10756;
	// 82E7A120: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E7A128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E7A128 size=84
    let mut pc: u32 = 0x82E7A128;
    'dispatch: loop {
        match pc {
            0x82E7A128 => {
    //   block [0x82E7A128..0x82E7A17C)
	// 82E7A128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7A12C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E7A130: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7A134: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E7A138: 4B79C7F1  bl 0x82616928
	ctx.lr = 0x82E7A13C;
	sub_82616928(ctx, base);
	// 82E7A13C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7A140: 41820028  beq 0x82e7a168
	if ctx.cr[0].eq {
	pc = 0x82E7A168; continue 'dispatch;
	}
	// 82E7A144: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E7A148: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E7A14C: 396B8EA4  addi r11, r11, -0x715c
	ctx.r[11].s64 = ctx.r[11].s64 + -29020;
	// 82E7A150: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7A154: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E7A158: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E7A15C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E7A160: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E7A164: 48000008  b 0x82e7a16c
	pc = 0x82E7A16C; continue 'dispatch;
	// 82E7A168: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E7A16C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E7A170: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E7A174: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E7A178: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E7A180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E7A180 size=108
    let mut pc: u32 = 0x82E7A180;
    'dispatch: loop {
        match pc {
            0x82E7A180 => {
    //   block [0x82E7A180..0x82E7A1EC)
	// 82E7A180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7A184: 4BE2F289  bl 0x82ca940c
	ctx.lr = 0x82E7A188;
	sub_82CA93D0(ctx, base);
	// 82E7A188: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7A18C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E7A190: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E7A194: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E7A198: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E7A19C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E7A1A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E7A1A4: 4E800421  bctrl
	ctx.lr = 0x82E7A1A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E7A1A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E7A1AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E7A1B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7A1B4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E7A1B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E7A1BC: 4E800421  bctrl
	ctx.lr = 0x82E7A1C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E7A1C0: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82E7A1C4: 409A001C  bne cr6, 0x82e7a1e0
	if !ctx.cr[6].eq {
	pc = 0x82E7A1E0; continue 'dispatch;
	}
	// 82E7A1C8: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7A1CC: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E7A1D0: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7A1D4: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E7A1D8: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7A1DC: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E7A1E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7A1E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E7A1E8: 4BE2F274  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E7A1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E7A1F0 size=12
    let mut pc: u32 = 0x82E7A1F0;
    'dispatch: loop {
        match pc {
            0x82E7A1F0 => {
    //   block [0x82E7A1F0..0x82E7A1FC)
	// 82E7A1F0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7A1F4: 386BD710  addi r3, r11, -0x28f0
	ctx.r[3].s64 = ctx.r[11].s64 + -10480;
	// 82E7A1F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E7A200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E7A200 size=72
    let mut pc: u32 = 0x82E7A200;
    'dispatch: loop {
        match pc {
            0x82E7A200 => {
    //   block [0x82E7A200..0x82E7A248)
	// 82E7A200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7A204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E7A208: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7A20C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82E7A210: 4B79C719  bl 0x82616928
	ctx.lr = 0x82E7A214;
	sub_82616928(ctx, base);
	// 82E7A214: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7A218: 4182001C  beq 0x82e7a234
	if ctx.cr[0].eq {
	pc = 0x82E7A234; continue 'dispatch;
	}
	// 82E7A21C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E7A220: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E7A224: 396B8ECC  addi r11, r11, -0x7134
	ctx.r[11].s64 = ctx.r[11].s64 + -28980;
	// 82E7A228: 99430004  stb r10, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 82E7A22C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E7A230: 48000008  b 0x82e7a238
	pc = 0x82E7A238; continue 'dispatch;
	// 82E7A234: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E7A238: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E7A23C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E7A240: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E7A244: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E7A248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E7A248 size=12
    let mut pc: u32 = 0x82E7A248;
    'dispatch: loop {
        match pc {
            0x82E7A248 => {
    //   block [0x82E7A248..0x82E7A254)
	// 82E7A248: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E7A24C: 386BD824  addi r3, r11, -0x27dc
	ctx.r[3].s64 = ctx.r[11].s64 + -10204;
	// 82E7A250: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E7A258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E7A258 size=72
    let mut pc: u32 = 0x82E7A258;
    'dispatch: loop {
        match pc {
            0x82E7A258 => {
    //   block [0x82E7A258..0x82E7A2A0)
	// 82E7A258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7A25C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E7A260: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7A264: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E7A268: 4B79C6C1  bl 0x82616928
	ctx.lr = 0x82E7A26C;
	sub_82616928(ctx, base);
	// 82E7A26C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E7A270: 4182001C  beq 0x82e7a28c
	if ctx.cr[0].eq {
	pc = 0x82E7A28C; continue 'dispatch;
	}
	// 82E7A274: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E7A278: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E7A27C: 396B8EFC  addi r11, r11, -0x7104
	ctx.r[11].s64 = ctx.r[11].s64 + -28932;
	// 82E7A280: 99430004  stb r10, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 82E7A284: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E7A288: 48000008  b 0x82e7a290
	pc = 0x82E7A290; continue 'dispatch;
	// 82E7A28C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E7A290: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E7A294: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E7A298: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E7A29C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E7A2A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E7A2A0 size=112
    let mut pc: u32 = 0x82E7A2A0;
    'dispatch: loop {
        match pc {
            0x82E7A2A0 => {
    //   block [0x82E7A2A0..0x82E7A310)
	// 82E7A2A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E7A2A4: 4BE2F169  bl 0x82ca940c
	ctx.lr = 0x82E7A2A8;
	sub_82CA93D0(ctx, base);
	// 82E7A2A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E7A2AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E7A2B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E7A2B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E7A2B8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E7A2BC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E7A2C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E7A2C4: 4E800421  bctrl
	ctx.lr = 0x82E7A2C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E7A2C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E7A2CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E7A2D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7A2D4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E7A2D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E7A2DC: 4E800421  bctrl
	ctx.lr = 0x82E7A2E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E7A2E0: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82E7A2E4: 409A0020  bne cr6, 0x82e7a304
	if !ctx.cr[6].eq {
	pc = 0x82E7A304; continue 'dispatch;
	}
	// 82E7A2E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E7A2EC: C01E0008  lfs f0, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7A2F0: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E7A2F4: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82E7A2F8: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E7A2FC: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E7A300: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82E7A304: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E7A308: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E7A30C: 4BE2F150  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


