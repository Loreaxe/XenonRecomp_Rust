pub fn sub_828CCC68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CCC68 size=120
    let mut pc: u32 = 0x828CCC68;
    'dispatch: loop {
        match pc {
            0x828CCC68 => {
    //   block [0x828CCC68..0x828CCCE0)
	// 828CCC68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CCC6C: 483DC799  bl 0x82ca9404
	ctx.lr = 0x828CCC70;
	sub_82CA93D0(ctx, base);
	// 828CCC70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CCC74: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828CCC78: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828CCC7C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 828CCC80: 897D0029  lbz r11, 0x29(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CCC84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CCC88: 409A0050  bne cr6, 0x828cccd8
	if !ctx.cr[6].eq {
	pc = 0x828CCCD8; continue 'dispatch;
	}
	// 828CCC8C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828CCC90: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828CCC94: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CCC98: 4BFFFFD1  bl 0x828ccc68
	ctx.lr = 0x828CCC9C;
	sub_828CCC68(ctx, base);
	// 828CCC9C: 807D001C  lwz r3, 0x1c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 828CCCA0: 3BDD0018  addi r30, r29, 0x18
	ctx.r[30].s64 = ctx.r[29].s64 + 24;
	// 828CCCA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CCCA8: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCCAC: 419A0008  beq cr6, 0x828cccb4
	if ctx.cr[6].eq {
	pc = 0x828CCCB4; continue 'dispatch;
	}
	// 828CCCB0: 4B94F089  bl 0x8221bd38
	ctx.lr = 0x828CCCB4;
	sub_8221BD38(ctx, base);
	// 828CCCB4: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828CCCB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CCCBC: 939E0008  stw r28, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 828CCCC0: 939E000C  stw r28, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 828CCCC4: 4B94F075  bl 0x8221bd38
	ctx.lr = 0x828CCCC8;
	sub_8221BD38(ctx, base);
	// 828CCCC8: 897F0029  lbz r11, 0x29(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CCCCC: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 828CCCD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CCCD4: 419AFFBC  beq cr6, 0x828ccc90
	if ctx.cr[6].eq {
	pc = 0x828CCC90; continue 'dispatch;
	}
	// 828CCCD8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CCCDC: 483DC778  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CCCE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CCCE0 size=104
    let mut pc: u32 = 0x828CCCE0;
    'dispatch: loop {
        match pc {
            0x828CCCE0 => {
    //   block [0x828CCCE0..0x828CCD48)
	// 828CCCE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CCCE4: 483DC725  bl 0x82ca9408
	ctx.lr = 0x828CCCE8;
	sub_82CA93D0(ctx, base);
	// 828CCCE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CCCEC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828CCCF0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828CCCF4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 828CCCF8: 897E0021  lbz r11, 0x21(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(33 as u32) ) } as u64;
	// 828CCCFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CCD00: 409A0040  bne cr6, 0x828ccd40
	if !ctx.cr[6].eq {
	pc = 0x828CCD40; continue 'dispatch;
	}
	// 828CCD04: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CCD08: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CCD0C: 4BFFFFD5  bl 0x828ccce0
	ctx.lr = 0x828CCD10;
	sub_828CCCE0(ctx, base);
	// 828CCD10: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 828CCD14: 387D0008  addi r3, r29, 8
	ctx.r[3].s64 = ctx.r[29].s64 + 8;
	// 828CCD18: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCD1C: 4B8EADFD  bl 0x821b7b18
	ctx.lr = 0x828CCD20;
	sub_821B7B18(ctx, base);
	// 828CCD20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CCD24: 4B8EADF5  bl 0x821b7b18
	ctx.lr = 0x828CCD28;
	sub_821B7B18(ctx, base);
	// 828CCD28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CCD2C: 4B94F00D  bl 0x8221bd38
	ctx.lr = 0x828CCD30;
	sub_8221BD38(ctx, base);
	// 828CCD30: 897F0021  lbz r11, 0x21(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(33 as u32) ) } as u64;
	// 828CCD34: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 828CCD38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CCD3C: 419AFFC8  beq cr6, 0x828ccd04
	if ctx.cr[6].eq {
	pc = 0x828CCD04; continue 'dispatch;
	}
	// 828CCD40: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CCD44: 483DC714  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CCD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CCD48 size=592
    let mut pc: u32 = 0x828CCD48;
    'dispatch: loop {
        match pc {
            0x828CCD48 => {
    //   block [0x828CCD48..0x828CCF98)
	// 828CCD48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CCD4C: 483DC6B5  bl 0x82ca9400
	ctx.lr = 0x828CCD50;
	sub_82CA93D0(ctx, base);
	// 828CCD50: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CCD54: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828CCD58: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828CCD5C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828CCD60: 3B4B2850  addi r26, r11, 0x2850
	ctx.r[26].s64 = ctx.r[11].s64 + 10320;
	// 828CCD64: 83BC0010  lwz r29, 0x10(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 828CCD68: 815C0014  lwz r10, 0x14(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CCD6C: 935C0000  stw r26, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 828CCD70: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CCD74: 419A01E8  beq cr6, 0x828ccf5c
	if ctx.cr[6].eq {
	pc = 0x828CCF5C; continue 'dispatch;
	}
	// 828CCD78: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828CCD7C: 3B6B8C64  addi r27, r11, -0x739c
	ctx.r[27].s64 = ctx.r[11].s64 + -29596;
	// 828CCD80: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CCD84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CCD88: 419A0030  beq cr6, 0x828ccdb8
	if ctx.cr[6].eq {
	pc = 0x828CCDB8; continue 'dispatch;
	}
	// 828CCD8C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCD90: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CCD94: 419A0058  beq cr6, 0x828ccdec
	if ctx.cr[6].eq {
	pc = 0x828CCDEC; continue 'dispatch;
	}
	// 828CCD98: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828CCD9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CCDA0: 419A0018  beq cr6, 0x828ccdb8
	if ctx.cr[6].eq {
	pc = 0x828CCDB8; continue 'dispatch;
	}
	// 828CCDA4: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828CCDA8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828CCDAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CCDB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CCDB4: 409A0008  bne cr6, 0x828ccdbc
	if !ctx.cr[6].eq {
	pc = 0x828CCDBC; continue 'dispatch;
	}
	// 828CCDB8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828CCDBC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CCDC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CCDC4: 419A0188  beq cr6, 0x828ccf4c
	if ctx.cr[6].eq {
	pc = 0x828CCF4C; continue 'dispatch;
	}
	// 828CCDC8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CCDCC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 828CCDD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CCDD4: 419A002C  beq cr6, 0x828cce00
	if ctx.cr[6].eq {
	pc = 0x828CCE00; continue 'dispatch;
	}
	// 828CCDD8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCDDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CCDE0: 419A0018  beq cr6, 0x828ccdf8
	if ctx.cr[6].eq {
	pc = 0x828CCDF8; continue 'dispatch;
	}
	// 828CCDE4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828CCDE8: 4800001C  b 0x828cce04
	pc = 0x828CCE04; continue 'dispatch;
	// 828CCDEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CCDF0: 4B8C7049  bl 0x82193e38
	ctx.lr = 0x828CCDF4;
	sub_82193E38(ctx, base);
	// 828CCDF4: 4BFFFFC4  b 0x828ccdb8
	pc = 0x828CCDB8; continue 'dispatch;
	// 828CCDF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CCDFC: 4B8C703D  bl 0x82193e38
	ctx.lr = 0x828CCE00;
	sub_82193E38(ctx, base);
	// 828CCE00: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828CCE04: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CCE08: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 828CCE0C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CCE10: 419A00F4  beq cr6, 0x828ccf04
	if ctx.cr[6].eq {
	pc = 0x828CCF04; continue 'dispatch;
	}
	// 828CCE14: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CCE18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CCE1C: 419A0024  beq cr6, 0x828cce40
	if ctx.cr[6].eq {
	pc = 0x828CCE40; continue 'dispatch;
	}
	// 828CCE20: 892A003B  lbz r9, 0x3b(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(59 as u32) ) } as u64;
	// 828CCE24: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CCE28: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828CCE2C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828CCE30: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CCE34: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828CCE38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CCE3C: 480000CC  b 0x828ccf08
	pc = 0x828CCF08; continue 'dispatch;
	// 828CCE40: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CCE44: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CCE48: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828CCE4C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828CCE50: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CCE54: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CCE58: 40810054  ble 0x828cceac
	if !ctx.cr[0].gt {
	pc = 0x828CCEAC; continue 'dispatch;
	}
	// 828CCE5C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828CCE60: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828CCE64: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828CCE68: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCE6C: 2F07003B  cmpwi cr6, r7, 0x3b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 59, &mut ctx.xer);
	// 828CCE70: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CCE74: 41980008  blt cr6, 0x828cce7c
	if ctx.cr[6].lt {
	pc = 0x828CCE7C; continue 'dispatch;
	}
	// 828CCE78: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828CCE7C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828CCE80: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828CCE84: 419A0014  beq cr6, 0x828cce98
	if ctx.cr[6].eq {
	pc = 0x828CCE98; continue 'dispatch;
	}
	// 828CCE88: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CCE8C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CCE90: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CCE94: 4800000C  b 0x828ccea0
	pc = 0x828CCEA0; continue 'dispatch;
	// 828CCE98: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828CCE9C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828CCEA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CCEA4: 4199FFB8  bgt cr6, 0x828cce5c
	if ctx.cr[6].gt {
	pc = 0x828CCE5C; continue 'dispatch;
	}
	// 828CCEA8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CCEAC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828CCEB0: 419A0040  beq cr6, 0x828ccef0
	if ctx.cr[6].eq {
	pc = 0x828CCEF0; continue 'dispatch;
	}
	// 828CCEB4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCEB8: 2F0B003B  cmpwi cr6, r11, 0x3b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 59, &mut ctx.xer);
	// 828CCEBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CCEC0: 41990008  bgt cr6, 0x828ccec8
	if ctx.cr[6].gt {
	pc = 0x828CCEC8; continue 'dispatch;
	}
	// 828CCEC4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828CCEC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CCECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CCED0: 409A0020  bne cr6, 0x828ccef0
	if !ctx.cr[6].eq {
	pc = 0x828CCEF0; continue 'dispatch;
	}
	// 828CCED4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CCED8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828CCEDC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828CCEE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CCEE4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828CCEE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CCEEC: 4800001C  b 0x828ccf08
	pc = 0x828CCF08; continue 'dispatch;
	// 828CCEF0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828CCEF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CCEF8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828CCEFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CCF00: 48000008  b 0x828ccf08
	pc = 0x828CCF08; continue 'dispatch;
	// 828CCF04: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828CCF08: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CCF0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CCF10: 419A003C  beq cr6, 0x828ccf4c
	if ctx.cr[6].eq {
	pc = 0x828CCF4C; continue 'dispatch;
	}
	// 828CCF14: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CCF18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CCF1C: 419A0030  beq cr6, 0x828ccf4c
	if ctx.cr[6].eq {
	pc = 0x828CCF4C; continue 'dispatch;
	}
	// 828CCF20: 806B0018  lwz r3, 0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828CCF24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CCF28: 419A0024  beq cr6, 0x828ccf4c
	if ctx.cr[6].eq {
	pc = 0x828CCF4C; continue 'dispatch;
	}
	// 828CCF2C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828CCF30: 4B99A5E1  bl 0x82267510
	ctx.lr = 0x828CCF34;
	sub_82267510(ctx, base);
	// 828CCF34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CCF38: 419A0014  beq cr6, 0x828ccf4c
	if ctx.cr[6].eq {
	pc = 0x828CCF4C; continue 'dispatch;
	}
	// 828CCF3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCF40: 814B0068  lwz r10, 0x68(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 828CCF44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828CCF48: 4E800421  bctrl
	ctx.lr = 0x828CCF4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CCF4C: 817C0014  lwz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CCF50: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CCF54: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CCF58: 409AFE28  bne cr6, 0x828ccd80
	if !ctx.cr[6].eq {
	pc = 0x828CCD80; continue 'dispatch;
	}
	// 828CCF5C: 809C0010  lwz r4, 0x10(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 828CCF60: 3BFC000C  addi r31, r28, 0xc
	ctx.r[31].s64 = ctx.r[28].s64 + 12;
	// 828CCF64: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828CCF68: 419A0018  beq cr6, 0x828ccf80
	if ctx.cr[6].eq {
	pc = 0x828CCF80; continue 'dispatch;
	}
	// 828CCF6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CCF70: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CCF74: 481C4F8D  bl 0x82a91f00
	ctx.lr = 0x828CCF78;
	sub_82A91F00(ctx, base);
	// 828CCF78: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CCF7C: 4B94EDBD  bl 0x8221bd38
	ctx.lr = 0x828CCF80;
	sub_8221BD38(ctx, base);
	// 828CCF80: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828CCF84: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 828CCF88: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 828CCF8C: 935C0000  stw r26, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 828CCF90: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828CCF94: 483DC4BC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CCF98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CCF98 size=132
    let mut pc: u32 = 0x828CCF98;
    'dispatch: loop {
        match pc {
            0x828CCF98 => {
    //   block [0x828CCF98..0x828CD01C)
	// 828CCF98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CCF9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CCFA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CCFA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CCFA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CCFAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CCFB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828CCFB4: 4800017D  bl 0x828cd130
	ctx.lr = 0x828CCFB8;
	sub_828CD130(ctx, base);
	// 828CCFB8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828CCFBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CCFC0: 409A0044  bne cr6, 0x828cd004
	if !ctx.cr[6].eq {
	pc = 0x828CD004; continue 'dispatch;
	}
	// 828CCFC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CCFC8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CCFCC: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 828CCFD0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CCFD4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CCFD8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828CCFDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CCFE0: 4B9478B9  bl 0x82214898
	ctx.lr = 0x828CCFE4;
	sub_82214898(ctx, base);
	// 828CCFE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CCFE8: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828CCFEC: 4B93C1FD  bl 0x822091e8
	ctx.lr = 0x828CCFF0;
	sub_822091E8(ctx, base);
	// 828CCFF0: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828CCFF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CCFF8: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 828CCFFC: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 828CD000: 4B8C6E39  bl 0x82193e38
	ctx.lr = 0x828CD004;
	sub_82193E38(ctx, base);
	// 828CD004: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CD008: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CD00C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CD010: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CD014: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CD018: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CD020 size=272
    let mut pc: u32 = 0x828CD020;
    'dispatch: loop {
        match pc {
            0x828CD020 => {
    //   block [0x828CD020..0x828CD130)
	// 828CD020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CD024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CD028: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CD02C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CD030: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CD034: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CD038: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CD03C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828CD040: 83DF0010  lwz r30, 0x10(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828CD044: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CD048: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CD04C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828CD050: 419A00AC  beq cr6, 0x828cd0fc
	if ctx.cr[6].eq {
	pc = 0x828CD0FC; continue 'dispatch;
	}
	// 828CD054: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD058: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD05C: 419A0030  beq cr6, 0x828cd08c
	if ctx.cr[6].eq {
	pc = 0x828CD08C; continue 'dispatch;
	}
	// 828CD060: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CD064: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CD068: 419A0074  beq cr6, 0x828cd0dc
	if ctx.cr[6].eq {
	pc = 0x828CD0DC; continue 'dispatch;
	}
	// 828CD06C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828CD070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD074: 419A0018  beq cr6, 0x828cd08c
	if ctx.cr[6].eq {
	pc = 0x828CD08C; continue 'dispatch;
	}
	// 828CD078: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828CD07C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828CD080: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CD084: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CD088: 409A0008  bne cr6, 0x828cd090
	if !ctx.cr[6].eq {
	pc = 0x828CD090; continue 'dispatch;
	}
	// 828CD08C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CD090: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CD094: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD098: 409A0050  bne cr6, 0x828cd0e8
	if !ctx.cr[6].eq {
	pc = 0x828CD0E8; continue 'dispatch;
	}
	// 828CD09C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828CD0A0: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CD0A4: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 828CD0A8: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 828CD0AC: 481369ED  bl 0x82a03a98
	ctx.lr = 0x828CD0B0;
	sub_82A03A98(ctx, base);
	// 828CD0B0: 80BF0014  lwz r5, 0x14(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CD0B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CD0B8: 3885FFF8  addi r4, r5, -8
	ctx.r[4].s64 = ctx.r[5].s64 + -8;
	// 828CD0BC: 481C4E45  bl 0x82a91f00
	ctx.lr = 0x828CD0C0;
	sub_82A91F00(ctx, base);
	// 828CD0C0: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CD0C4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CD0C8: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828CD0CC: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 828CD0D0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CD0D4: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 828CD0D8: 48000018  b 0x828cd0f0
	pc = 0x828CD0F0; continue 'dispatch;
	// 828CD0DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CD0E0: 4B8C6D59  bl 0x82193e38
	ctx.lr = 0x828CD0E4;
	sub_82193E38(ctx, base);
	// 828CD0E4: 4BFFFFA8  b 0x828cd08c
	pc = 0x828CD08C; continue 'dispatch;
	// 828CD0E8: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 828CD0EC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828CD0F0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CD0F4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CD0F8: 409AFF5C  bne cr6, 0x828cd054
	if !ctx.cr[6].eq {
	pc = 0x828CD054; continue 'dispatch;
	}
	// 828CD0FC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CD100: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828CD104: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828CD108: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 828CD10C: 7D070034  cntlzw r7, r8
	ctx.r[7].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 828CD110: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 828CD114: 68C30001  xori r3, r6, 1
	ctx.r[3].u64 = ctx.r[6].u64 ^ 1;
	// 828CD118: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CD11C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CD120: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CD124: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CD128: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CD12C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CD130 size=108
    let mut pc: u32 = 0x828CD130;
    'dispatch: loop {
        match pc {
            0x828CD130 => {
    //   block [0x828CD130..0x828CD19C)
	// 828CD130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CD134: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CD138: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CD13C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CD140: 83E30014  lwz r31, 0x14(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CD144: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CD148: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828CD14C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828CD150: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828CD154: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828CD158: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CD15C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828CD160: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828CD164: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828CD168: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828CD16C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828CD170: 4BEF8991  bl 0x827c5b00
	ctx.lr = 0x828CD174;
	sub_827C5B00(ctx, base);
	// 828CD174: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD178: 7D09F850  subf r8, r9, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[9].s64;
	// 828CD17C: 7D070034  cntlzw r7, r8
	ctx.r[7].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 828CD180: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 828CD184: 68C30001  xori r3, r6, 1
	ctx.r[3].u64 = ctx.r[6].u64 ^ 1;
	// 828CD188: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CD18C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CD190: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CD194: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CD198: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CD1A0 size=192
    let mut pc: u32 = 0x828CD1A0;
    'dispatch: loop {
        match pc {
            0x828CD1A0 => {
    //   block [0x828CD1A0..0x828CD260)
	// 828CD1A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CD1A4: 483DC269  bl 0x82ca940c
	ctx.lr = 0x828CD1A8;
	sub_82CA93D0(ctx, base);
	// 828CD1A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CD1AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CD1B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CD1B4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828CD1B8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828CD1BC: 83DF0010  lwz r30, 0x10(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828CD1C0: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CD1C4: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CD1C8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828CD1CC: 419A008C  beq cr6, 0x828cd258
	if ctx.cr[6].eq {
	pc = 0x828CD258; continue 'dispatch;
	}
	// 828CD1D0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD1D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD1D8: 419A0020  beq cr6, 0x828cd1f8
	if ctx.cr[6].eq {
	pc = 0x828CD1F8; continue 'dispatch;
	}
	// 828CD1DC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CD1E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CD1E4: 419A000C  beq cr6, 0x828cd1f0
	if ctx.cr[6].eq {
	pc = 0x828CD1F0; continue 'dispatch;
	}
	// 828CD1E8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828CD1EC: 48000010  b 0x828cd1fc
	pc = 0x828CD1FC; continue 'dispatch;
	// 828CD1F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CD1F4: 4B8C6C45  bl 0x82193e38
	ctx.lr = 0x828CD1F8;
	sub_82193E38(ctx, base);
	// 828CD1F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CD1FC: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828CD200: 409A0044  bne cr6, 0x828cd244
	if !ctx.cr[6].eq {
	pc = 0x828CD244; continue 'dispatch;
	}
	// 828CD204: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828CD208: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CD20C: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 828CD210: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 828CD214: 48136885  bl 0x82a03a98
	ctx.lr = 0x828CD218;
	sub_82A03A98(ctx, base);
	// 828CD218: 80BF0014  lwz r5, 0x14(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CD21C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CD220: 3885FFF8  addi r4, r5, -8
	ctx.r[4].s64 = ctx.r[5].s64 + -8;
	// 828CD224: 481C4CDD  bl 0x82a91f00
	ctx.lr = 0x828CD228;
	sub_82A91F00(ctx, base);
	// 828CD228: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CD22C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CD230: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828CD234: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 828CD238: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CD23C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 828CD240: 4800000C  b 0x828cd24c
	pc = 0x828CD24C; continue 'dispatch;
	// 828CD244: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 828CD248: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828CD24C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CD250: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CD254: 409AFF7C  bne cr6, 0x828cd1d0
	if !ctx.cr[6].eq {
	pc = 0x828CD1D0; continue 'dispatch;
	}
	// 828CD258: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CD25C: 483DC200  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CD260 size=60
    let mut pc: u32 = 0x828CD260;
    'dispatch: loop {
        match pc {
            0x828CD260 => {
    //   block [0x828CD260..0x828CD29C)
	// 828CD260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CD264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CD268: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CD26C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CD270: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828CD274: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CD278: 388B9808  addi r4, r11, -0x67f8
	ctx.r[4].s64 = ctx.r[11].s64 + -26616;
	// 828CD27C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CD280: 4B95FC51  bl 0x8222ced0
	ctx.lr = 0x828CD284;
	sub_8222CED0(ctx, base);
	// 828CD284: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD288: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CD28C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CD290: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CD294: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CD298: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD2A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828CD2A0 size=8
    let mut pc: u32 = 0x828CD2A0;
    'dispatch: loop {
        match pc {
            0x828CD2A0 => {
    //   block [0x828CD2A0..0x828CD2A8)
	// 828CD2A0: C0230030  lfs f1, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CD2A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD2A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CD2A8 size=8
    let mut pc: u32 = 0x828CD2A8;
    'dispatch: loop {
        match pc {
            0x828CD2A8 => {
    //   block [0x828CD2A8..0x828CD2B0)
	// 828CD2A8: 386000D6  li r3, 0xd6
	ctx.r[3].s64 = 214;
	// 828CD2AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CD2B0 size=60
    let mut pc: u32 = 0x828CD2B0;
    'dispatch: loop {
        match pc {
            0x828CD2B0 => {
    //   block [0x828CD2B0..0x828CD2EC)
	// 828CD2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CD2B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CD2B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CD2BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CD2C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828CD2C4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CD2C8: 388B981C  addi r4, r11, -0x67e4
	ctx.r[4].s64 = ctx.r[11].s64 + -26596;
	// 828CD2CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CD2D0: 4B95FC01  bl 0x8222ced0
	ctx.lr = 0x828CD2D4;
	sub_8222CED0(ctx, base);
	// 828CD2D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD2D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CD2DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CD2E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CD2E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CD2E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CD2F0 size=652
    let mut pc: u32 = 0x828CD2F0;
    'dispatch: loop {
        match pc {
            0x828CD2F0 => {
    //   block [0x828CD2F0..0x828CD57C)
	// 828CD2F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CD2F4: 483DC111  bl 0x82ca9404
	ctx.lr = 0x828CD2F8;
	sub_82CA93D0(ctx, base);
	// 828CD2F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CD2FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CD300: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828CD304: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CD308: 3B7F0008  addi r27, r31, 8
	ctx.r[27].s64 = ctx.r[31].s64 + 8;
	// 828CD30C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828CD310: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828CD314: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CD318: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828CD31C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 828CD320: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828CD324: 4B95FBAD  bl 0x8222ced0
	ctx.lr = 0x828CD328;
	sub_8222CED0(ctx, base);
	// 828CD328: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828CD32C: 9BDF000C  stb r30, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u8 ) };
	// 828CD330: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828CD334: 9BDF000D  stb r30, 0xd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(13 as u32), ctx.r[30].u8 ) };
	// 828CD338: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 828CD33C: 9BDF000E  stb r30, 0xe(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(14 as u32), ctx.r[30].u8 ) };
	// 828CD340: 9BDF000F  stb r30, 0xf(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(15 as u32), ctx.r[30].u8 ) };
	// 828CD344: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CD348: 9BDF0012  stb r30, 0x12(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[30].u8 ) };
	// 828CD34C: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 828CD350: 9BDF0013  stb r30, 0x13(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(19 as u32), ctx.r[30].u8 ) };
	// 828CD354: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 828CD358: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 828CD35C: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 828CD360: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 828CD364: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 828CD368: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 828CD36C: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 828CD370: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 828CD374: 811D0014  lwz r8, 0x14(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CD378: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828CD37C: 80FD0018  lwz r7, 0x18(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 828CD380: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 828CD384: 81696AB8  lwz r11, 0x6ab8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828CD388: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CD38C: 80A60058  lwz r5, 0x58(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(88 as u32) ) } as u64;
	// 828CD390: 80850004  lwz r4, 4(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD394: 80640008  lwz r3, 8(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CD398: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD39C: 812A0024  lwz r9, 0x24(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 828CD3A0: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD3A4: 80E800B4  lwz r7, 0xb4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(180 as u32) ) } as u64;
	// 828CD3A8: 90FF0014  stw r7, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 828CD3AC: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CD3B0: 80A60058  lwz r5, 0x58(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(88 as u32) ) } as u64;
	// 828CD3B4: 80850004  lwz r4, 4(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD3B8: 80640014  lwz r3, 0x14(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CD3BC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CD3C0: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 828CD3C4: 815D002C  lwz r10, 0x2c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 828CD3C8: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828CD3CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CD3D0: 419A00D4  beq cr6, 0x828cd4a4
	if ctx.cr[6].eq {
	pc = 0x828CD4A4; continue 'dispatch;
	}
	// 828CD3D4: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CD3D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD3DC: 419A001C  beq cr6, 0x828cd3f8
	if ctx.cr[6].eq {
	pc = 0x828CD3F8; continue 'dispatch;
	}
	// 828CD3E0: 894B0043  lbz r10, 0x43(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(67 as u32) ) } as u64;
	// 828CD3E4: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CD3E8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828CD3EC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828CD3F0: 83890004  lwz r28, 4(r9)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD3F4: 480000AC  b 0x828cd4a0
	pc = 0x828CD4A0; continue 'dispatch;
	// 828CD3F8: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CD3FC: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CD400: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828CD404: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828CD408: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CD40C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CD410: 40810054  ble 0x828cd464
	if !ctx.cr[0].gt {
	pc = 0x828CD464; continue 'dispatch;
	}
	// 828CD414: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828CD418: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828CD41C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828CD420: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CD424: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 828CD428: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CD42C: 41980008  blt cr6, 0x828cd434
	if ctx.cr[6].lt {
	pc = 0x828CD434; continue 'dispatch;
	}
	// 828CD430: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828CD434: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828CD438: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828CD43C: 419A0014  beq cr6, 0x828cd450
	if ctx.cr[6].eq {
	pc = 0x828CD450; continue 'dispatch;
	}
	// 828CD440: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CD444: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CD448: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CD44C: 4800000C  b 0x828cd458
	pc = 0x828CD458; continue 'dispatch;
	// 828CD450: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828CD454: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828CD458: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CD45C: 4199FFB8  bgt cr6, 0x828cd414
	if ctx.cr[6].gt {
	pc = 0x828CD414; continue 'dispatch;
	}
	// 828CD460: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CD464: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828CD468: 419A0030  beq cr6, 0x828cd498
	if ctx.cr[6].eq {
	pc = 0x828CD498; continue 'dispatch;
	}
	// 828CD46C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CD470: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 828CD474: 40990008  ble cr6, 0x828cd47c
	if !ctx.cr[6].gt {
	pc = 0x828CD47C; continue 'dispatch;
	}
	// 828CD478: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828CD47C: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 828CD480: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD484: 409A0014  bne cr6, 0x828cd498
	if !ctx.cr[6].eq {
	pc = 0x828CD498; continue 'dispatch;
	}
	// 828CD488: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CD48C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828CD490: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CD494: 48000008  b 0x828cd49c
	pc = 0x828CD49C; continue 'dispatch;
	// 828CD498: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828CD49C: 838B0004  lwz r28, 4(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD4A0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828CD4A4: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 828CD4A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD4AC: 419A00C4  beq cr6, 0x828cd570
	if ctx.cr[6].eq {
	pc = 0x828CD570; continue 'dispatch;
	}
	// 828CD4B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828CD4B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD4B8: 4BF5D9A1  bl 0x8282ae58
	ctx.lr = 0x828CD4BC;
	sub_8282AE58(ctx, base);
	// 828CD4BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CD4C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828CD4C4: 4B997CDD  bl 0x822651a0
	ctx.lr = 0x828CD4C8;
	sub_822651A0(ctx, base);
	// 828CD4C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD4CC: 4B94790D  bl 0x82214dd8
	ctx.lr = 0x828CD4D0;
	sub_82214DD8(ctx, base);
	// 828CD4D0: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 828CD4D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CD4D8: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828CD4DC: 995F000F  stb r10, 0xf(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(15 as u32), ctx.r[10].u8 ) };
	// 828CD4E0: 813C001C  lwz r9, 0x1c(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 828CD4E4: 5528F7FE  rlwinm r8, r9, 0x1e, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 828CD4E8: 991F0010  stb r8, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[8].u8 ) };
	// 828CD4EC: 80FC001C  lwz r7, 0x1c(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 828CD4F0: 54E6AFFE  rlwinm r6, r7, 0x15, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x000007FFu64;
	// 828CD4F4: 98DF0011  stb r6, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[6].u8 ) };
	// 828CD4F8: 4BF5D9B9  bl 0x8282aeb0
	ctx.lr = 0x828CD4FC;
	sub_8282AEB0(ctx, base);
	// 828CD4FC: 907F002C  stw r3, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[3].u32 ) };
	// 828CD500: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828CD504: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD508: 4B90CEA9  bl 0x821da3b0
	ctx.lr = 0x828CD50C;
	sub_821DA3B0(ctx, base);
	// 828CD50C: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CD510: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828CD514: 419A005C  beq cr6, 0x828cd570
	if ctx.cr[6].eq {
	pc = 0x828CD570; continue 'dispatch;
	}
	// 828CD518: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD51C: 4B8E4FDD  bl 0x821b24f8
	ctx.lr = 0x828CD520;
	sub_821B24F8(ctx, base);
	// 828CD520: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CD524: 419A004C  beq cr6, 0x828cd570
	if ctx.cr[6].eq {
	pc = 0x828CD570; continue 'dispatch;
	}
	// 828CD528: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CD52C: 388B332C  addi r4, r11, 0x332c
	ctx.r[4].s64 = ctx.r[11].s64 + 13100;
	// 828CD530: 4BA42D61  bl 0x82310290
	ctx.lr = 0x828CD534;
	sub_82310290(ctx, base);
	// 828CD534: 987F000E  stb r3, 0xe(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(14 as u32), ctx.r[3].u8 ) };
	// 828CD538: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828CD53C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD540: 38EA3338  addi r7, r10, 0x3338
	ctx.r[7].s64 = ctx.r[10].s64 + 13112;
	// 828CD544: 4B8E4FB5  bl 0x821b24f8
	ctx.lr = 0x828CD548;
	sub_821B24F8(ctx, base);
	// 828CD548: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 828CD54C: 4BAF22D5  bl 0x823bf820
	ctx.lr = 0x828CD550;
	sub_823BF820(ctx, base);
	// 828CD550: 907F0034  stw r3, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[3].u32 ) };
	// 828CD554: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828CD558: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD55C: 38A63344  addi r5, r6, 0x3344
	ctx.r[5].s64 = ctx.r[6].s64 + 13124;
	// 828CD560: 4B8E4F99  bl 0x821b24f8
	ctx.lr = 0x828CD564;
	sub_821B24F8(ctx, base);
	// 828CD564: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828CD568: 4BAF22B9  bl 0x823bf820
	ctx.lr = 0x828CD56C;
	sub_823BF820(ctx, base);
	// 828CD56C: 907F0038  stw r3, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[3].u32 ) };
	// 828CD570: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD574: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828CD578: 483DBEDC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CD580 size=360
    let mut pc: u32 = 0x828CD580;
    'dispatch: loop {
        match pc {
            0x828CD580 => {
    //   block [0x828CD580..0x828CD6E8)
	// 828CD580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CD584: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CD588: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CD58C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CD590: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828CD594: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CD598: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828CD59C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828CD5A0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CD5A4: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828CD5A8: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD5AC: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CD5B0: 4B996ED9  bl 0x82264488
	ctx.lr = 0x828CD5B4;
	sub_82264488(ctx, base);
	// 828CD5B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CD5B8: 419A011C  beq cr6, 0x828cd6d4
	if ctx.cr[6].eq {
	pc = 0x828CD6D4; continue 'dispatch;
	}
	// 828CD5BC: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 828CD5C0: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828CD5C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CD5C8: 419A00F4  beq cr6, 0x828cd6bc
	if ctx.cr[6].eq {
	pc = 0x828CD6BC; continue 'dispatch;
	}
	// 828CD5CC: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CD5D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD5D4: 419A0024  beq cr6, 0x828cd5f8
	if ctx.cr[6].eq {
	pc = 0x828CD5F8; continue 'dispatch;
	}
	// 828CD5D8: 894B0043  lbz r10, 0x43(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(67 as u32) ) } as u64;
	// 828CD5DC: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CD5E0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828CD5E4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828CD5E8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD5EC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828CD5F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CD5F4: 480000CC  b 0x828cd6c0
	pc = 0x828CD6C0; continue 'dispatch;
	// 828CD5F8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CD5FC: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CD600: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828CD604: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828CD608: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CD60C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CD610: 40810054  ble 0x828cd664
	if !ctx.cr[0].gt {
	pc = 0x828CD664; continue 'dispatch;
	}
	// 828CD614: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828CD618: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828CD61C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828CD620: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CD624: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 828CD628: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CD62C: 41980008  blt cr6, 0x828cd634
	if ctx.cr[6].lt {
	pc = 0x828CD634; continue 'dispatch;
	}
	// 828CD630: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828CD634: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828CD638: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828CD63C: 419A0014  beq cr6, 0x828cd650
	if ctx.cr[6].eq {
	pc = 0x828CD650; continue 'dispatch;
	}
	// 828CD640: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CD644: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CD648: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CD64C: 4800000C  b 0x828cd658
	pc = 0x828CD658; continue 'dispatch;
	// 828CD650: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828CD654: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828CD658: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CD65C: 4199FFB8  bgt cr6, 0x828cd614
	if ctx.cr[6].gt {
	pc = 0x828CD614; continue 'dispatch;
	}
	// 828CD660: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CD664: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828CD668: 419A0040  beq cr6, 0x828cd6a8
	if ctx.cr[6].eq {
	pc = 0x828CD6A8; continue 'dispatch;
	}
	// 828CD66C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CD670: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 828CD674: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CD678: 41990008  bgt cr6, 0x828cd680
	if ctx.cr[6].gt {
	pc = 0x828CD680; continue 'dispatch;
	}
	// 828CD67C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828CD680: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CD684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD688: 409A0020  bne cr6, 0x828cd6a8
	if !ctx.cr[6].eq {
	pc = 0x828CD6A8; continue 'dispatch;
	}
	// 828CD68C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CD690: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828CD694: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CD698: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD69C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828CD6A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CD6A4: 4800001C  b 0x828cd6c0
	pc = 0x828CD6C0; continue 'dispatch;
	// 828CD6A8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828CD6AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD6B0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828CD6B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CD6B8: 48000008  b 0x828cd6c0
	pc = 0x828CD6C0; continue 'dispatch;
	// 828CD6BC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828CD6C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CD6C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD6C8: 419A000C  beq cr6, 0x828cd6d4
	if ctx.cr[6].eq {
	pc = 0x828CD6D4; continue 'dispatch;
	}
	// 828CD6CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD6D0: 4BF5E651  bl 0x8282bd20
	ctx.lr = 0x828CD6D4;
	sub_8282BD20(ctx, base);
	// 828CD6D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CD6D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CD6DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CD6E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CD6E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CD6E8 size=460
    let mut pc: u32 = 0x828CD6E8;
    'dispatch: loop {
        match pc {
            0x828CD6E8 => {
    //   block [0x828CD6E8..0x828CD8B4)
	// 828CD6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CD6EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CD6F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CD6F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CD6F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CD6FC: 897F000E  lbz r11, 0xe(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(14 as u32) ) } as u64;
	// 828CD700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD704: 419A001C  beq cr6, 0x828cd720
	if ctx.cr[6].eq {
	pc = 0x828CD720; continue 'dispatch;
	}
	// 828CD708: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828CD70C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CD710: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CD714: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CD718: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CD71C: 4E800020  blr
	return;
	// 828CD720: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828CD724: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CD728: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828CD72C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CD730: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828CD734: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD738: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CD73C: 4B996D4D  bl 0x82264488
	ctx.lr = 0x828CD740;
	sub_82264488(ctx, base);
	// 828CD740: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CD744: 419A0018  beq cr6, 0x828cd75c
	if ctx.cr[6].eq {
	pc = 0x828CD75C; continue 'dispatch;
	}
	// 828CD748: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828CD74C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828CD750: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CD754: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CD758: 409A0008  bne cr6, 0x828cd760
	if !ctx.cr[6].eq {
	pc = 0x828CD760; continue 'dispatch;
	}
	// 828CD75C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CD760: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CD764: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD768: 419A0134  beq cr6, 0x828cd89c
	if ctx.cr[6].eq {
	pc = 0x828CD89C; continue 'dispatch;
	}
	// 828CD76C: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 828CD770: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CD774: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828CD778: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CD77C: 419A00EC  beq cr6, 0x828cd868
	if ctx.cr[6].eq {
	pc = 0x828CD868; continue 'dispatch;
	}
	// 828CD780: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CD784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD788: 419A0020  beq cr6, 0x828cd7a8
	if ctx.cr[6].eq {
	pc = 0x828CD7A8; continue 'dispatch;
	}
	// 828CD78C: 894B0043  lbz r10, 0x43(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(67 as u32) ) } as u64;
	// 828CD790: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CD794: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828CD798: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828CD79C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CD7A0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD7A4: 480000C8  b 0x828cd86c
	pc = 0x828CD86C; continue 'dispatch;
	// 828CD7A8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CD7AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CD7B0: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CD7B4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828CD7B8: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828CD7BC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CD7C0: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CD7C4: 40810054  ble 0x828cd818
	if !ctx.cr[0].gt {
	pc = 0x828CD818; continue 'dispatch;
	}
	// 828CD7C8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828CD7CC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828CD7D0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828CD7D4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CD7D8: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 828CD7DC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CD7E0: 41980008  blt cr6, 0x828cd7e8
	if ctx.cr[6].lt {
	pc = 0x828CD7E8; continue 'dispatch;
	}
	// 828CD7E4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828CD7E8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828CD7EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828CD7F0: 419A0014  beq cr6, 0x828cd804
	if ctx.cr[6].eq {
	pc = 0x828CD804; continue 'dispatch;
	}
	// 828CD7F4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CD7F8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CD7FC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CD800: 4800000C  b 0x828cd80c
	pc = 0x828CD80C; continue 'dispatch;
	// 828CD804: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828CD808: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828CD80C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CD810: 4199FFB8  bgt cr6, 0x828cd7c8
	if ctx.cr[6].gt {
	pc = 0x828CD7C8; continue 'dispatch;
	}
	// 828CD814: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CD818: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828CD81C: 419A003C  beq cr6, 0x828cd858
	if ctx.cr[6].eq {
	pc = 0x828CD858; continue 'dispatch;
	}
	// 828CD820: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CD824: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 828CD828: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CD82C: 41990008  bgt cr6, 0x828cd834
	if ctx.cr[6].gt {
	pc = 0x828CD834; continue 'dispatch;
	}
	// 828CD830: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CD834: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CD838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD83C: 409A001C  bne cr6, 0x828cd858
	if !ctx.cr[6].eq {
	pc = 0x828CD858; continue 'dispatch;
	}
	// 828CD840: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CD844: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CD848: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828CD84C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CD850: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD854: 48000018  b 0x828cd86c
	pc = 0x828CD86C; continue 'dispatch;
	// 828CD858: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828CD85C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CD860: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD864: 48000008  b 0x828cd86c
	pc = 0x828CD86C; continue 'dispatch;
	// 828CD868: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CD86C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828CD870: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CD874: 419A0028  beq cr6, 0x828cd89c
	if ctx.cr[6].eq {
	pc = 0x828CD89C; continue 'dispatch;
	}
	// 828CD878: 895F000D  lbz r10, 0xd(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(13 as u32) ) } as u64;
	// 828CD87C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CD880: 419A001C  beq cr6, 0x828cd89c
	if ctx.cr[6].eq {
	pc = 0x828CD89C; continue 'dispatch;
	}
	// 828CD884: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828CD888: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CD88C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CD890: 41990008  bgt cr6, 0x828cd898
	if ctx.cr[6].gt {
	pc = 0x828CD898; continue 'dispatch;
	}
	// 828CD894: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CD898: 997F0012  stb r11, 0x12(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[11].u8 ) };
	// 828CD89C: 887F0012  lbz r3, 0x12(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 828CD8A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CD8A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CD8A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CD8AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CD8B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD8B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CD8B8 size=496
    let mut pc: u32 = 0x828CD8B8;
    'dispatch: loop {
        match pc {
            0x828CD8B8 => {
    //   block [0x828CD8B8..0x828CDAA8)
	// 828CD8B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CD8BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CD8C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CD8C4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CD8C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CD8CC: 897F000E  lbz r11, 0xe(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(14 as u32) ) } as u64;
	// 828CD8D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD8D4: 409A01BC  bne cr6, 0x828cda90
	if !ctx.cr[6].eq {
	pc = 0x828CDA90; continue 'dispatch;
	}
	// 828CD8D8: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828CD8DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD8E0: 409A01B0  bne cr6, 0x828cda90
	if !ctx.cr[6].eq {
	pc = 0x828CDA90; continue 'dispatch;
	}
	// 828CD8E4: 897F0011  lbz r11, 0x11(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 828CD8E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD8EC: 419A001C  beq cr6, 0x828cd908
	if ctx.cr[6].eq {
	pc = 0x828CD908; continue 'dispatch;
	}
	// 828CD8F0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828CD8F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CD8F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CD8FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CD900: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CD904: 4E800020  blr
	return;
	// 828CD908: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828CD90C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CD910: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828CD914: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CD918: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828CD91C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD920: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CD924: 4B996B65  bl 0x82264488
	ctx.lr = 0x828CD928;
	sub_82264488(ctx, base);
	// 828CD928: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CD92C: 419A0018  beq cr6, 0x828cd944
	if ctx.cr[6].eq {
	pc = 0x828CD944; continue 'dispatch;
	}
	// 828CD930: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828CD934: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828CD938: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CD93C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CD940: 409A0008  bne cr6, 0x828cd948
	if !ctx.cr[6].eq {
	pc = 0x828CD948; continue 'dispatch;
	}
	// 828CD944: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CD948: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CD94C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD950: 419A0128  beq cr6, 0x828cda78
	if ctx.cr[6].eq {
	pc = 0x828CDA78; continue 'dispatch;
	}
	// 828CD954: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CD958: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CD95C: 5549BFFE  rlwinm r9, r10, 0x17, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000001FFu64;
	// 828CD960: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CD964: 419A00EC  beq cr6, 0x828cda50
	if ctx.cr[6].eq {
	pc = 0x828CDA50; continue 'dispatch;
	}
	// 828CD968: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CD96C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD970: 419A0020  beq cr6, 0x828cd990
	if ctx.cr[6].eq {
	pc = 0x828CD990; continue 'dispatch;
	}
	// 828CD974: 894B0029  lbz r10, 0x29(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CD978: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CD97C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828CD980: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828CD984: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CD988: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD98C: 480000C8  b 0x828cda54
	pc = 0x828CDA54; continue 'dispatch;
	// 828CD990: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CD994: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CD998: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CD99C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828CD9A0: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828CD9A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CD9A8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CD9AC: 40810054  ble 0x828cda00
	if !ctx.cr[0].gt {
	pc = 0x828CDA00; continue 'dispatch;
	}
	// 828CD9B0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828CD9B4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828CD9B8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828CD9BC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CD9C0: 2F070029  cmpwi cr6, r7, 0x29
	ctx.cr[6].compare_i32(ctx.r[7].s32, 41, &mut ctx.xer);
	// 828CD9C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CD9C8: 41980008  blt cr6, 0x828cd9d0
	if ctx.cr[6].lt {
	pc = 0x828CD9D0; continue 'dispatch;
	}
	// 828CD9CC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828CD9D0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828CD9D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828CD9D8: 419A0014  beq cr6, 0x828cd9ec
	if ctx.cr[6].eq {
	pc = 0x828CD9EC; continue 'dispatch;
	}
	// 828CD9DC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CD9E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CD9E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CD9E8: 4800000C  b 0x828cd9f4
	pc = 0x828CD9F4; continue 'dispatch;
	// 828CD9EC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828CD9F0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828CD9F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CD9F8: 4199FFB8  bgt cr6, 0x828cd9b0
	if ctx.cr[6].gt {
	pc = 0x828CD9B0; continue 'dispatch;
	}
	// 828CD9FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CDA00: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828CDA04: 419A003C  beq cr6, 0x828cda40
	if ctx.cr[6].eq {
	pc = 0x828CDA40; continue 'dispatch;
	}
	// 828CDA08: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CDA0C: 2F0B0029  cmpwi cr6, r11, 0x29
	ctx.cr[6].compare_i32(ctx.r[11].s32, 41, &mut ctx.xer);
	// 828CDA10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CDA14: 41990008  bgt cr6, 0x828cda1c
	if ctx.cr[6].gt {
	pc = 0x828CDA1C; continue 'dispatch;
	}
	// 828CDA18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CDA1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CDA20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDA24: 409A001C  bne cr6, 0x828cda40
	if !ctx.cr[6].eq {
	pc = 0x828CDA40; continue 'dispatch;
	}
	// 828CDA28: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CDA2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CDA30: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828CDA34: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CDA38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CDA3C: 48000018  b 0x828cda54
	pc = 0x828CDA54; continue 'dispatch;
	// 828CDA40: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828CDA44: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CDA48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CDA4C: 48000008  b 0x828cda54
	pc = 0x828CDA54; continue 'dispatch;
	// 828CDA50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CDA54: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828CDA58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CDA5C: 419A001C  beq cr6, 0x828cda78
	if ctx.cr[6].eq {
	pc = 0x828CDA78; continue 'dispatch;
	}
	// 828CDA60: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CDA64: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CDA68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CDA6C: 41990008  bgt cr6, 0x828cda74
	if ctx.cr[6].gt {
	pc = 0x828CDA74; continue 'dispatch;
	}
	// 828CDA70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CDA74: 997F0013  stb r11, 0x13(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(19 as u32), ctx.r[11].u8 ) };
	// 828CDA78: 887F0013  lbz r3, 0x13(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(19 as u32) ) } as u64;
	// 828CDA7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CDA80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CDA84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CDA88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CDA8C: 4E800020  blr
	return;
	// 828CDA90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828CDA94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CDA98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CDA9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CDAA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CDAA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDAA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CDAA8 size=100
    let mut pc: u32 = 0x828CDAA8;
    'dispatch: loop {
        match pc {
            0x828CDAA8 => {
    //   block [0x828CDAA8..0x828CDB0C)
	// 828CDAA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CDAAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CDAB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CDAB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CDAB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CDABC: 4BFFFDFD  bl 0x828cd8b8
	ctx.lr = 0x828CDAC0;
	sub_828CD8B8(ctx, base);
	// 828CDAC0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828CDAC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDAC8: 409A0028  bne cr6, 0x828cdaf0
	if !ctx.cr[6].eq {
	pc = 0x828CDAF0; continue 'dispatch;
	}
	// 828CDACC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CDAD0: 4BFFFC19  bl 0x828cd6e8
	ctx.lr = 0x828CDAD4;
	sub_828CD6E8(ctx, base);
	// 828CDAD4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828CDAD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDADC: 409A0014  bne cr6, 0x828cdaf0
	if !ctx.cr[6].eq {
	pc = 0x828CDAF0; continue 'dispatch;
	}
	// 828CDAE0: 897F000E  lbz r11, 0xe(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(14 as u32) ) } as u64;
	// 828CDAE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDAE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CDAEC: 419A0008  beq cr6, 0x828cdaf4
	if ctx.cr[6].eq {
	pc = 0x828CDAF4; continue 'dispatch;
	}
	// 828CDAF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CDAF4: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CDAF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CDAFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CDB00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CDB04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CDB08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDB10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CDB10 size=92
    let mut pc: u32 = 0x828CDB10;
    'dispatch: loop {
        match pc {
            0x828CDB10 => {
    //   block [0x828CDB10..0x828CDB6C)
	// 828CDB10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CDB14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CDB18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CDB1C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CDB20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CDB24: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CDB28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDB2C: 409A0024  bne cr6, 0x828cdb50
	if !ctx.cr[6].eq {
	pc = 0x828CDB50; continue 'dispatch;
	}
	// 828CDB30: 4BFFFBB9  bl 0x828cd6e8
	ctx.lr = 0x828CDB34;
	sub_828CD6E8(ctx, base);
	// 828CDB34: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828CDB38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDB3C: 409A0014  bne cr6, 0x828cdb50
	if !ctx.cr[6].eq {
	pc = 0x828CDB50; continue 'dispatch;
	}
	// 828CDB40: 897F000E  lbz r11, 0xe(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(14 as u32) ) } as u64;
	// 828CDB44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDB48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CDB4C: 419A0008  beq cr6, 0x828cdb54
	if ctx.cr[6].eq {
	pc = 0x828CDB54; continue 'dispatch;
	}
	// 828CDB50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CDB54: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CDB58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CDB5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CDB60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CDB64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CDB68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CDB70 size=532
    let mut pc: u32 = 0x828CDB70;
    'dispatch: loop {
        match pc {
            0x828CDB70 => {
    //   block [0x828CDB70..0x828CDD84)
	// 828CDB70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CDB74: 483DB891  bl 0x82ca9404
	ctx.lr = 0x828CDB78;
	sub_82CA93D0(ctx, base);
	// 828CDB78: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CDB7C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828CDB80: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828CDB84: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828CDB88: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 828CDB8C: 817C0028  lwz r11, 0x28(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CDB90: 7FABD850  subf r29, r11, r27
	ctx.r[29].s64 = ctx.r[27].s64 - ctx.r[11].s64;
	// 828CDB94: 4BFFFF15  bl 0x828cdaa8
	ctx.lr = 0x828CDB98;
	sub_828CDAA8(ctx, base);
	// 828CDB98: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828CDB9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CDBA0: 419A01DC  beq cr6, 0x828cdd7c
	if ctx.cr[6].eq {
	pc = 0x828CDD7C; continue 'dispatch;
	}
	// 828CDBA4: 7F1DF000  cmpw cr6, r29, r30
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[30].s32, &mut ctx.xer);
	// 828CDBA8: 419801D4  blt cr6, 0x828cdd7c
	if ctx.cr[6].lt {
	pc = 0x828CDD7C; continue 'dispatch;
	}
	// 828CDBAC: 815C0020  lwz r10, 0x20(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CDBB0: 7F0AF800  cmpw cr6, r10, r31
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[31].s32, &mut ctx.xer);
	// 828CDBB4: 409801C8  bge cr6, 0x828cdd7c
	if !ctx.cr[6].lt {
	pc = 0x828CDD7C; continue 'dispatch;
	}
	// 828CDBB8: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828CDBBC: 7D0AF850  subf r8, r10, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 828CDBC0: 7D7DF3D6  divw r11, r29, r30
	ctx.r[11].s32 = ctx.r[29].s32 / ctx.r[30].s32;
	// 828CDBC4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828CDBC8: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 828CDBCC: 81496AB8  lwz r10, 0x6ab8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828CDBD0: 7CE6FE70  srawi r6, r7, 0x1f
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[7].s32 >> 31) as i64;
	// 828CDBD4: 7CC93838  and r9, r6, r7
	ctx.r[9].u64 = ctx.r[6].u64 & ctx.r[7].u64;
	// 828CDBD8: 80AA000C  lwz r5, 0xc(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CDBDC: 7FC95A14  add r30, r9, r11
	ctx.r[30].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 828CDBE0: 80650058  lwz r3, 0x58(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(88 as u32) ) } as u64;
	// 828CDBE4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CDBE8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CDBEC: 4B99689D  bl 0x82264488
	ctx.lr = 0x828CDBF0;
	sub_82264488(ctx, base);
	// 828CDBF0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828CDBF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CDBF8: 419A0018  beq cr6, 0x828cdc10
	if ctx.cr[6].eq {
	pc = 0x828CDC10; continue 'dispatch;
	}
	// 828CDBFC: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828CDC00: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828CDC04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CDC08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CDC0C: 409A0008  bne cr6, 0x828cdc14
	if !ctx.cr[6].eq {
	pc = 0x828CDC14; continue 'dispatch;
	}
	// 828CDC10: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828CDC14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CDC18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDC1C: 419A0128  beq cr6, 0x828cdd44
	if ctx.cr[6].eq {
	pc = 0x828CDD44; continue 'dispatch;
	}
	// 828CDC20: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 828CDC24: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828CDC28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CDC2C: 419A00F4  beq cr6, 0x828cdd20
	if ctx.cr[6].eq {
	pc = 0x828CDD20; continue 'dispatch;
	}
	// 828CDC30: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CDC34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDC38: 419A0024  beq cr6, 0x828cdc5c
	if ctx.cr[6].eq {
	pc = 0x828CDC5C; continue 'dispatch;
	}
	// 828CDC3C: 894B0043  lbz r10, 0x43(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(67 as u32) ) } as u64;
	// 828CDC40: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CDC44: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828CDC48: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828CDC4C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CDC50: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828CDC54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CDC58: 480000CC  b 0x828cdd24
	pc = 0x828CDD24; continue 'dispatch;
	// 828CDC5C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CDC60: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CDC64: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828CDC68: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828CDC6C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CDC70: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CDC74: 40810054  ble 0x828cdcc8
	if !ctx.cr[0].gt {
	pc = 0x828CDCC8; continue 'dispatch;
	}
	// 828CDC78: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828CDC7C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828CDC80: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828CDC84: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CDC88: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 828CDC8C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CDC90: 41980008  blt cr6, 0x828cdc98
	if ctx.cr[6].lt {
	pc = 0x828CDC98; continue 'dispatch;
	}
	// 828CDC94: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828CDC98: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828CDC9C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828CDCA0: 419A0014  beq cr6, 0x828cdcb4
	if ctx.cr[6].eq {
	pc = 0x828CDCB4; continue 'dispatch;
	}
	// 828CDCA4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CDCA8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CDCAC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CDCB0: 4800000C  b 0x828cdcbc
	pc = 0x828CDCBC; continue 'dispatch;
	// 828CDCB4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828CDCB8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828CDCBC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CDCC0: 4199FFB8  bgt cr6, 0x828cdc78
	if ctx.cr[6].gt {
	pc = 0x828CDC78; continue 'dispatch;
	}
	// 828CDCC4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CDCC8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828CDCCC: 419A0040  beq cr6, 0x828cdd0c
	if ctx.cr[6].eq {
	pc = 0x828CDD0C; continue 'dispatch;
	}
	// 828CDCD0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CDCD4: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 828CDCD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CDCDC: 41990008  bgt cr6, 0x828cdce4
	if ctx.cr[6].gt {
	pc = 0x828CDCE4; continue 'dispatch;
	}
	// 828CDCE0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828CDCE4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CDCE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDCEC: 409A0020  bne cr6, 0x828cdd0c
	if !ctx.cr[6].eq {
	pc = 0x828CDD0C; continue 'dispatch;
	}
	// 828CDCF0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CDCF4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828CDCF8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CDCFC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CDD00: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828CDD04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CDD08: 4800001C  b 0x828cdd24
	pc = 0x828CDD24; continue 'dispatch;
	// 828CDD0C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828CDD10: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CDD14: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828CDD18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CDD1C: 48000008  b 0x828cdd24
	pc = 0x828CDD24; continue 'dispatch;
	// 828CDD20: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828CDD24: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CDD28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDD2C: 419A0018  beq cr6, 0x828cdd44
	if ctx.cr[6].eq {
	pc = 0x828CDD44; continue 'dispatch;
	}
	// 828CDD30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CDD34: 4BF5E3DD  bl 0x8282c110
	ctx.lr = 0x828CDD38;
	sub_8282C110(ctx, base);
	// 828CDD38: 907C001C  stw r3, 0x1c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 828CDD3C: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 828CDD40: 917C003C  stw r11, 0x3c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 828CDD44: 897C000E  lbz r11, 0xe(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(14 as u32) ) } as u64;
	// 828CDD48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDD4C: 419A000C  beq cr6, 0x828cdd58
	if ctx.cr[6].eq {
	pc = 0x828CDD58; continue 'dispatch;
	}
	// 828CDD50: 817C0034  lwz r11, 0x34(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) } as u64;
	// 828CDD54: 917C001C  stw r11, 0x1c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 828CDD58: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 828CDD5C: 813C0020  lwz r9, 0x20(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CDD60: 815C0024  lwz r10, 0x24(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 828CDD64: 7D6BF1D6  mullw r11, r11, r30
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[30].s32 as i64);
	// 828CDD68: 937C0028  stw r27, 0x28(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(40 as u32), ctx.r[27].u32 ) };
	// 828CDD6C: 7D29F214  add r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 828CDD70: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828CDD74: 913C0020  stw r9, 0x20(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 828CDD78: 911C0024  stw r8, 0x24(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(36 as u32), ctx.r[8].u32 ) };
	// 828CDD7C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828CDD80: 483DB6D4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDD88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CDD88 size=472
    let mut pc: u32 = 0x828CDD88;
    'dispatch: loop {
        match pc {
            0x828CDD88 => {
    //   block [0x828CDD88..0x828CDF60)
	// 828CDD88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CDD8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CDD90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CDD94: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CDD98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CDD9C: 4BFFFD0D  bl 0x828cdaa8
	ctx.lr = 0x828CDDA0;
	sub_828CDAA8(ctx, base);
	// 828CDDA0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828CDDA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDDA8: 419A01A0  beq cr6, 0x828cdf48
	if ctx.cr[6].eq {
	pc = 0x828CDF48; continue 'dispatch;
	}
	// 828CDDAC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828CDDB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CDDB4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828CDDB8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CDDBC: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828CDDC0: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CDDC4: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CDDC8: 4B9966C1  bl 0x82264488
	ctx.lr = 0x828CDDCC;
	sub_82264488(ctx, base);
	// 828CDDCC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CDDD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDDD4: 419A0018  beq cr6, 0x828cddec
	if ctx.cr[6].eq {
	pc = 0x828CDDEC; continue 'dispatch;
	}
	// 828CDDD8: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828CDDDC: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828CDDE0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CDDE4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CDDE8: 409A0008  bne cr6, 0x828cddf0
	if !ctx.cr[6].eq {
	pc = 0x828CDDF0; continue 'dispatch;
	}
	// 828CDDEC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CDDF0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828CDDF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CDDF8: 419A0124  beq cr6, 0x828cdf1c
	if ctx.cr[6].eq {
	pc = 0x828CDF1C; continue 'dispatch;
	}
	// 828CDDFC: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828CDE00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828CDE04: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828CDE08: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CDE0C: 419A00F8  beq cr6, 0x828cdf04
	if ctx.cr[6].eq {
	pc = 0x828CDF04; continue 'dispatch;
	}
	// 828CDE10: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CDE14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CDE18: 419A0024  beq cr6, 0x828cde3c
	if ctx.cr[6].eq {
	pc = 0x828CDE3C; continue 'dispatch;
	}
	// 828CDE1C: 894A0043  lbz r10, 0x43(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(67 as u32) ) } as u64;
	// 828CDE20: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CDE24: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828CDE28: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828CDE2C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CDE30: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CDE34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CDE38: 480000D0  b 0x828cdf08
	pc = 0x828CDF08; continue 'dispatch;
	// 828CDE3C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CDE40: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828CDE44: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CDE48: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828CDE4C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828CDE50: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CDE54: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CDE58: 40810054  ble 0x828cdeac
	if !ctx.cr[0].gt {
	pc = 0x828CDEAC; continue 'dispatch;
	}
	// 828CDE5C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828CDE60: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828CDE64: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828CDE68: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CDE6C: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 828CDE70: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CDE74: 41980008  blt cr6, 0x828cde7c
	if ctx.cr[6].lt {
	pc = 0x828CDE7C; continue 'dispatch;
	}
	// 828CDE78: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828CDE7C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828CDE80: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828CDE84: 419A0014  beq cr6, 0x828cde98
	if ctx.cr[6].eq {
	pc = 0x828CDE98; continue 'dispatch;
	}
	// 828CDE88: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CDE8C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CDE90: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CDE94: 4800000C  b 0x828cdea0
	pc = 0x828CDEA0; continue 'dispatch;
	// 828CDE98: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828CDE9C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828CDEA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CDEA4: 4199FFB8  bgt cr6, 0x828cde5c
	if ctx.cr[6].gt {
	pc = 0x828CDE5C; continue 'dispatch;
	}
	// 828CDEA8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CDEAC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828CDEB0: 419A0040  beq cr6, 0x828cdef0
	if ctx.cr[6].eq {
	pc = 0x828CDEF0; continue 'dispatch;
	}
	// 828CDEB4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CDEB8: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 828CDEBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CDEC0: 41990008  bgt cr6, 0x828cdec8
	if ctx.cr[6].gt {
	pc = 0x828CDEC8; continue 'dispatch;
	}
	// 828CDEC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CDEC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CDECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDED0: 409A0020  bne cr6, 0x828cdef0
	if !ctx.cr[6].eq {
	pc = 0x828CDEF0; continue 'dispatch;
	}
	// 828CDED4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CDED8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828CDEDC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CDEE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CDEE4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CDEE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CDEEC: 4800001C  b 0x828cdf08
	pc = 0x828CDF08; continue 'dispatch;
	// 828CDEF0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828CDEF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CDEF8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CDEFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CDF00: 48000008  b 0x828cdf08
	pc = 0x828CDF08; continue 'dispatch;
	// 828CDF04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CDF08: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CDF0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDF10: 419A000C  beq cr6, 0x828cdf1c
	if ctx.cr[6].eq {
	pc = 0x828CDF1C; continue 'dispatch;
	}
	// 828CDF14: 4BF5E1FD  bl 0x8282c110
	ctx.lr = 0x828CDF18;
	sub_8282C110(ctx, base);
	// 828CDF18: 907F001C  stw r3, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 828CDF1C: 897F000E  lbz r11, 0xe(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(14 as u32) ) } as u64;
	// 828CDF20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDF24: 419A000C  beq cr6, 0x828cdf30
	if ctx.cr[6].eq {
	pc = 0x828CDF30; continue 'dispatch;
	}
	// 828CDF28: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 828CDF2C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 828CDF30: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828CDF34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CDF38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CDF3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CDF40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CDF44: 4E800020  blr
	return;
	// 828CDF48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828CDF4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CDF50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CDF54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CDF58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CDF5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDF60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CDF60 size=436
    let mut pc: u32 = 0x828CDF60;
    'dispatch: loop {
        match pc {
            0x828CDF60 => {
    //   block [0x828CDF60..0x828CE114)
	// 828CDF60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CDF64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CDF68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CDF6C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CDF70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CDF74: 4BFFFB35  bl 0x828cdaa8
	ctx.lr = 0x828CDF78;
	sub_828CDAA8(ctx, base);
	// 828CDF78: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828CDF7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDF80: 419A017C  beq cr6, 0x828ce0fc
	if ctx.cr[6].eq {
	pc = 0x828CE0FC; continue 'dispatch;
	}
	// 828CDF84: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828CDF88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CDF8C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828CDF90: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CDF94: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828CDF98: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CDF9C: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CDFA0: 4B9964E9  bl 0x82264488
	ctx.lr = 0x828CDFA4;
	sub_82264488(ctx, base);
	// 828CDFA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CDFA8: 419A0018  beq cr6, 0x828cdfc0
	if ctx.cr[6].eq {
	pc = 0x828CDFC0; continue 'dispatch;
	}
	// 828CDFAC: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828CDFB0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828CDFB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CDFB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CDFBC: 409A0008  bne cr6, 0x828cdfc4
	if !ctx.cr[6].eq {
	pc = 0x828CDFC4; continue 'dispatch;
	}
	// 828CDFC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CDFC4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CDFC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDFCC: 419A0118  beq cr6, 0x828ce0e4
	if ctx.cr[6].eq {
	pc = 0x828CE0E4; continue 'dispatch;
	}
	// 828CDFD0: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 828CDFD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CDFD8: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828CDFDC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CDFE0: 419A00EC  beq cr6, 0x828ce0cc
	if ctx.cr[6].eq {
	pc = 0x828CE0CC; continue 'dispatch;
	}
	// 828CDFE4: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CDFE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDFEC: 419A0020  beq cr6, 0x828ce00c
	if ctx.cr[6].eq {
	pc = 0x828CE00C; continue 'dispatch;
	}
	// 828CDFF0: 894B0043  lbz r10, 0x43(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(67 as u32) ) } as u64;
	// 828CDFF4: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CDFF8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828CDFFC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828CE000: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CE004: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CE008: 480000C8  b 0x828ce0d0
	pc = 0x828CE0D0; continue 'dispatch;
	// 828CE00C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CE010: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CE014: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CE018: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828CE01C: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828CE020: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CE024: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CE028: 40810054  ble 0x828ce07c
	if !ctx.cr[0].gt {
	pc = 0x828CE07C; continue 'dispatch;
	}
	// 828CE02C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828CE030: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828CE034: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828CE038: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE03C: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 828CE040: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CE044: 41980008  blt cr6, 0x828ce04c
	if ctx.cr[6].lt {
	pc = 0x828CE04C; continue 'dispatch;
	}
	// 828CE048: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828CE04C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828CE050: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828CE054: 419A0014  beq cr6, 0x828ce068
	if ctx.cr[6].eq {
	pc = 0x828CE068; continue 'dispatch;
	}
	// 828CE058: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CE05C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CE060: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CE064: 4800000C  b 0x828ce070
	pc = 0x828CE070; continue 'dispatch;
	// 828CE068: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828CE06C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828CE070: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CE074: 4199FFB8  bgt cr6, 0x828ce02c
	if ctx.cr[6].gt {
	pc = 0x828CE02C; continue 'dispatch;
	}
	// 828CE078: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CE07C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828CE080: 419A003C  beq cr6, 0x828ce0bc
	if ctx.cr[6].eq {
	pc = 0x828CE0BC; continue 'dispatch;
	}
	// 828CE084: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE088: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 828CE08C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CE090: 41990008  bgt cr6, 0x828ce098
	if ctx.cr[6].gt {
	pc = 0x828CE098; continue 'dispatch;
	}
	// 828CE094: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CE098: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CE09C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE0A0: 409A001C  bne cr6, 0x828ce0bc
	if !ctx.cr[6].eq {
	pc = 0x828CE0BC; continue 'dispatch;
	}
	// 828CE0A4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CE0A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CE0AC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828CE0B0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CE0B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CE0B8: 48000018  b 0x828ce0d0
	pc = 0x828CE0D0; continue 'dispatch;
	// 828CE0BC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828CE0C0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CE0C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CE0C8: 48000008  b 0x828ce0d0
	pc = 0x828CE0D0; continue 'dispatch;
	// 828CE0CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CE0D0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828CE0D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CE0D8: 419A000C  beq cr6, 0x828ce0e4
	if ctx.cr[6].eq {
	pc = 0x828CE0E4; continue 'dispatch;
	}
	// 828CE0DC: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828CE0E0: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 828CE0E4: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CE0E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE0EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE0F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE0F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CE0F8: 4E800020  blr
	return;
	// 828CE0FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828CE100: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE104: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE108: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE10C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CE110: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CE118 size=1196
    let mut pc: u32 = 0x828CE118;
    'dispatch: loop {
        match pc {
            0x828CE118 => {
    //   block [0x828CE118..0x828CE5C4)
	// 828CE118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE11C: 483DB2F1  bl 0x82ca940c
	ctx.lr = 0x828CE120;
	sub_82CA93D0(ctx, base);
	// 828CE120: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE124: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CE128: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CE12C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828CE130: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE134: 388B335C  addi r4, r11, 0x335c
	ctx.r[4].s64 = ctx.r[11].s64 + 13148;
	// 828CE138: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE13C: 4B95ED95  bl 0x8222ced0
	ctx.lr = 0x828CE140;
	sub_8222CED0(ctx, base);
	// 828CE140: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828CE144: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CE148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE14C: 4BBE466D  bl 0x824b27b8
	ctx.lr = 0x828CE150;
	sub_824B27B8(ctx, base);
	// 828CE150: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE154: 4B946C85  bl 0x82214dd8
	ctx.lr = 0x828CE158;
	sub_82214DD8(ctx, base);
	// 828CE158: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828CE15C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE160: 388A3368  addi r4, r10, 0x3368
	ctx.r[4].s64 = ctx.r[10].s64 + 13160;
	// 828CE164: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE168: 4B95ED69  bl 0x8222ced0
	ctx.lr = 0x828CE16C;
	sub_8222CED0(ctx, base);
	// 828CE16C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CE170: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 828CE174: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE178: 4814ECD1  bl 0x82a1ce48
	ctx.lr = 0x828CE17C;
	sub_82A1CE48(ctx, base);
	// 828CE17C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE180: 4B946C59  bl 0x82214dd8
	ctx.lr = 0x828CE184;
	sub_82214DD8(ctx, base);
	// 828CE184: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828CE188: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE18C: 3889D5E0  addi r4, r9, -0x2a20
	ctx.r[4].s64 = ctx.r[9].s64 + -10784;
	// 828CE190: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE194: 4B95ED3D  bl 0x8222ced0
	ctx.lr = 0x828CE198;
	sub_8222CED0(ctx, base);
	// 828CE198: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CE19C: 38BF000F  addi r5, r31, 0xf
	ctx.r[5].s64 = ctx.r[31].s64 + 15;
	// 828CE1A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE1A4: 4814ECA5  bl 0x82a1ce48
	ctx.lr = 0x828CE1A8;
	sub_82A1CE48(ctx, base);
	// 828CE1A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE1AC: 4B946C2D  bl 0x82214dd8
	ctx.lr = 0x828CE1B0;
	sub_82214DD8(ctx, base);
	// 828CE1B0: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828CE1B4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE1B8: 38883378  addi r4, r8, 0x3378
	ctx.r[4].s64 = ctx.r[8].s64 + 13176;
	// 828CE1BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE1C0: 4B95ED11  bl 0x8222ced0
	ctx.lr = 0x828CE1C4;
	sub_8222CED0(ctx, base);
	// 828CE1C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CE1C8: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 828CE1CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE1D0: 4814EC79  bl 0x82a1ce48
	ctx.lr = 0x828CE1D4;
	sub_82A1CE48(ctx, base);
	// 828CE1D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE1D8: 4B946C01  bl 0x82214dd8
	ctx.lr = 0x828CE1DC;
	sub_82214DD8(ctx, base);
	// 828CE1DC: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 828CE1E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE1E4: 38873380  addi r4, r7, 0x3380
	ctx.r[4].s64 = ctx.r[7].s64 + 13184;
	// 828CE1E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE1EC: 4B95ECE5  bl 0x8222ced0
	ctx.lr = 0x828CE1F0;
	sub_8222CED0(ctx, base);
	// 828CE1F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CE1F4: 38BF0011  addi r5, r31, 0x11
	ctx.r[5].s64 = ctx.r[31].s64 + 17;
	// 828CE1F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE1FC: 4814EC4D  bl 0x82a1ce48
	ctx.lr = 0x828CE200;
	sub_82A1CE48(ctx, base);
	// 828CE200: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE204: 4B946BD5  bl 0x82214dd8
	ctx.lr = 0x828CE208;
	sub_82214DD8(ctx, base);
	// 828CE208: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828CE20C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE210: 3886338C  addi r4, r6, 0x338c
	ctx.r[4].s64 = ctx.r[6].s64 + 13196;
	// 828CE214: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE218: 4B95ECB9  bl 0x8222ced0
	ctx.lr = 0x828CE21C;
	sub_8222CED0(ctx, base);
	// 828CE21C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CE220: 38BF000D  addi r5, r31, 0xd
	ctx.r[5].s64 = ctx.r[31].s64 + 13;
	// 828CE224: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE228: 4814EC21  bl 0x82a1ce48
	ctx.lr = 0x828CE22C;
	sub_82A1CE48(ctx, base);
	// 828CE22C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE230: 4B946BA9  bl 0x82214dd8
	ctx.lr = 0x828CE234;
	sub_82214DD8(ctx, base);
	// 828CE234: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 828CE238: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE23C: 388433A0  addi r4, r4, 0x33a0
	ctx.r[4].s64 = ctx.r[4].s64 + 13216;
	// 828CE240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE244: 4B95EC8D  bl 0x8222ced0
	ctx.lr = 0x828CE248;
	sub_8222CED0(ctx, base);
	// 828CE248: 38BF0012  addi r5, r31, 0x12
	ctx.r[5].s64 = ctx.r[31].s64 + 18;
	// 828CE24C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CE250: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE254: 4814EBF5  bl 0x82a1ce48
	ctx.lr = 0x828CE258;
	sub_82A1CE48(ctx, base);
	// 828CE258: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE25C: 4B946B7D  bl 0x82214dd8
	ctx.lr = 0x828CE260;
	sub_82214DD8(ctx, base);
	// 828CE260: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 828CE264: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE268: 388333AC  addi r4, r3, 0x33ac
	ctx.r[4].s64 = ctx.r[3].s64 + 13228;
	// 828CE26C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE270: 4B95EC61  bl 0x8222ced0
	ctx.lr = 0x828CE274;
	sub_8222CED0(ctx, base);
	// 828CE274: 38BF0013  addi r5, r31, 0x13
	ctx.r[5].s64 = ctx.r[31].s64 + 19;
	// 828CE278: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CE27C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE280: 4814EBC9  bl 0x82a1ce48
	ctx.lr = 0x828CE284;
	sub_82A1CE48(ctx, base);
	// 828CE284: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE288: 4B946B51  bl 0x82214dd8
	ctx.lr = 0x828CE28C;
	sub_82214DD8(ctx, base);
	// 828CE28C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828CE290: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE294: 388B4AF8  addi r4, r11, 0x4af8
	ctx.r[4].s64 = ctx.r[11].s64 + 19192;
	// 828CE298: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE29C: 4B95EC35  bl 0x8222ced0
	ctx.lr = 0x828CE2A0;
	sub_8222CED0(ctx, base);
	// 828CE2A0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CE2A4: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 828CE2A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CE2AC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CE2B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE2B4: 419A0008  beq cr6, 0x828ce2bc
	if ctx.cr[6].eq {
	pc = 0x828CE2BC; continue 'dispatch;
	}
	// 828CE2B8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE2BC: 38BF0014  addi r5, r31, 0x14
	ctx.r[5].s64 = ctx.r[31].s64 + 20;
	// 828CE2C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE2C4: 4BAC1DC5  bl 0x82390088
	ctx.lr = 0x828CE2C8;
	sub_82390088(ctx, base);
	// 828CE2C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE2CC: 4B946B0D  bl 0x82214dd8
	ctx.lr = 0x828CE2D0;
	sub_82214DD8(ctx, base);
	// 828CE2D0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CE2D4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE2D8: 388B33B8  addi r4, r11, 0x33b8
	ctx.r[4].s64 = ctx.r[11].s64 + 13240;
	// 828CE2DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE2E0: 4B95EBF1  bl 0x8222ced0
	ctx.lr = 0x828CE2E4;
	sub_8222CED0(ctx, base);
	// 828CE2E4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CE2E8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CE2EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE2F0: 419A0008  beq cr6, 0x828ce2f8
	if ctx.cr[6].eq {
	pc = 0x828CE2F8; continue 'dispatch;
	}
	// 828CE2F4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE2F8: 38BF001C  addi r5, r31, 0x1c
	ctx.r[5].s64 = ctx.r[31].s64 + 28;
	// 828CE2FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE300: 4BBB24C9  bl 0x824807c8
	ctx.lr = 0x828CE304;
	sub_824807C8(ctx, base);
	// 828CE304: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE308: 4B946AD1  bl 0x82214dd8
	ctx.lr = 0x828CE30C;
	sub_82214DD8(ctx, base);
	// 828CE30C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CE310: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE314: 388B33C0  addi r4, r11, 0x33c0
	ctx.r[4].s64 = ctx.r[11].s64 + 13248;
	// 828CE318: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE31C: 4B95EBB5  bl 0x8222ced0
	ctx.lr = 0x828CE320;
	sub_8222CED0(ctx, base);
	// 828CE320: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CE324: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CE328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE32C: 419A0008  beq cr6, 0x828ce334
	if ctx.cr[6].eq {
	pc = 0x828CE334; continue 'dispatch;
	}
	// 828CE330: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE334: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 828CE338: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE33C: 4BBB248D  bl 0x824807c8
	ctx.lr = 0x828CE340;
	sub_824807C8(ctx, base);
	// 828CE340: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE344: 4B946A95  bl 0x82214dd8
	ctx.lr = 0x828CE348;
	sub_82214DD8(ctx, base);
	// 828CE348: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CE34C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE350: 388B33CC  addi r4, r11, 0x33cc
	ctx.r[4].s64 = ctx.r[11].s64 + 13260;
	// 828CE354: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE358: 4B95EB79  bl 0x8222ced0
	ctx.lr = 0x828CE35C;
	sub_8222CED0(ctx, base);
	// 828CE35C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CE360: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CE364: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE368: 419A0008  beq cr6, 0x828ce370
	if ctx.cr[6].eq {
	pc = 0x828CE370; continue 'dispatch;
	}
	// 828CE36C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE370: 38BF0024  addi r5, r31, 0x24
	ctx.r[5].s64 = ctx.r[31].s64 + 36;
	// 828CE374: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE378: 4BBB2451  bl 0x824807c8
	ctx.lr = 0x828CE37C;
	sub_824807C8(ctx, base);
	// 828CE37C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE380: 4B946A59  bl 0x82214dd8
	ctx.lr = 0x828CE384;
	sub_82214DD8(ctx, base);
	// 828CE384: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CE388: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE38C: 388B33D8  addi r4, r11, 0x33d8
	ctx.r[4].s64 = ctx.r[11].s64 + 13272;
	// 828CE390: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE394: 4B95EB3D  bl 0x8222ced0
	ctx.lr = 0x828CE398;
	sub_8222CED0(ctx, base);
	// 828CE398: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CE39C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CE3A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE3A4: 419A0008  beq cr6, 0x828ce3ac
	if ctx.cr[6].eq {
	pc = 0x828CE3AC; continue 'dispatch;
	}
	// 828CE3A8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE3AC: 38BF0028  addi r5, r31, 0x28
	ctx.r[5].s64 = ctx.r[31].s64 + 40;
	// 828CE3B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE3B4: 4BBB2415  bl 0x824807c8
	ctx.lr = 0x828CE3B8;
	sub_824807C8(ctx, base);
	// 828CE3B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE3BC: 4B946A1D  bl 0x82214dd8
	ctx.lr = 0x828CE3C0;
	sub_82214DD8(ctx, base);
	// 828CE3C0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CE3C4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE3C8: 388BD3F8  addi r4, r11, -0x2c08
	ctx.r[4].s64 = ctx.r[11].s64 + -11272;
	// 828CE3CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE3D0: 4B95EB01  bl 0x8222ced0
	ctx.lr = 0x828CE3D4;
	sub_8222CED0(ctx, base);
	// 828CE3D4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CE3D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CE3DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE3E0: 419A0008  beq cr6, 0x828ce3e8
	if ctx.cr[6].eq {
	pc = 0x828CE3E8; continue 'dispatch;
	}
	// 828CE3E4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE3E8: 38BF003C  addi r5, r31, 0x3c
	ctx.r[5].s64 = ctx.r[31].s64 + 60;
	// 828CE3EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE3F0: 4BBB23D9  bl 0x824807c8
	ctx.lr = 0x828CE3F4;
	sub_824807C8(ctx, base);
	// 828CE3F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE3F8: 4B9469E1  bl 0x82214dd8
	ctx.lr = 0x828CE3FC;
	sub_82214DD8(ctx, base);
	// 828CE3FC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CE400: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE404: 388B33EC  addi r4, r11, 0x33ec
	ctx.r[4].s64 = ctx.r[11].s64 + 13292;
	// 828CE408: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE40C: 4B95EAC5  bl 0x8222ced0
	ctx.lr = 0x828CE410;
	sub_8222CED0(ctx, base);
	// 828CE410: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CE414: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CE418: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE41C: 419A0008  beq cr6, 0x828ce424
	if ctx.cr[6].eq {
	pc = 0x828CE424; continue 'dispatch;
	}
	// 828CE420: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE424: 38BF0040  addi r5, r31, 0x40
	ctx.r[5].s64 = ctx.r[31].s64 + 64;
	// 828CE428: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE42C: 4BBB2425  bl 0x82480850
	ctx.lr = 0x828CE430;
	sub_82480850(ctx, base);
	// 828CE430: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE434: 4B9469A5  bl 0x82214dd8
	ctx.lr = 0x828CE438;
	sub_82214DD8(ctx, base);
	// 828CE438: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CE43C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE440: 388B3400  addi r4, r11, 0x3400
	ctx.r[4].s64 = ctx.r[11].s64 + 13312;
	// 828CE444: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE448: 4B95EA89  bl 0x8222ced0
	ctx.lr = 0x828CE44C;
	sub_8222CED0(ctx, base);
	// 828CE44C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CE450: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CE454: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE458: 419A0008  beq cr6, 0x828ce460
	if ctx.cr[6].eq {
	pc = 0x828CE460; continue 'dispatch;
	}
	// 828CE45C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE460: 38BF002C  addi r5, r31, 0x2c
	ctx.r[5].s64 = ctx.r[31].s64 + 44;
	// 828CE464: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE468: 4BBB2361  bl 0x824807c8
	ctx.lr = 0x828CE46C;
	sub_824807C8(ctx, base);
	// 828CE46C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE470: 4B946969  bl 0x82214dd8
	ctx.lr = 0x828CE474;
	sub_82214DD8(ctx, base);
	// 828CE474: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CE478: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE47C: 388B3410  addi r4, r11, 0x3410
	ctx.r[4].s64 = ctx.r[11].s64 + 13328;
	// 828CE480: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE484: 4B95EA4D  bl 0x8222ced0
	ctx.lr = 0x828CE488;
	sub_8222CED0(ctx, base);
	// 828CE488: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CE48C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CE490: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE494: 419A0008  beq cr6, 0x828ce49c
	if ctx.cr[6].eq {
	pc = 0x828CE49C; continue 'dispatch;
	}
	// 828CE498: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE49C: 38BF0030  addi r5, r31, 0x30
	ctx.r[5].s64 = ctx.r[31].s64 + 48;
	// 828CE4A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE4A4: 4BBB2325  bl 0x824807c8
	ctx.lr = 0x828CE4A8;
	sub_824807C8(ctx, base);
	// 828CE4A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE4AC: 4B94692D  bl 0x82214dd8
	ctx.lr = 0x828CE4B0;
	sub_82214DD8(ctx, base);
	// 828CE4B0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CE4B4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE4B8: 388B341C  addi r4, r11, 0x341c
	ctx.r[4].s64 = ctx.r[11].s64 + 13340;
	// 828CE4BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE4C0: 4B95EA11  bl 0x8222ced0
	ctx.lr = 0x828CE4C4;
	sub_8222CED0(ctx, base);
	// 828CE4C4: 38BF000E  addi r5, r31, 0xe
	ctx.r[5].s64 = ctx.r[31].s64 + 14;
	// 828CE4C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CE4CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE4D0: 4814E979  bl 0x82a1ce48
	ctx.lr = 0x828CE4D4;
	sub_82A1CE48(ctx, base);
	// 828CE4D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE4D8: 4B946901  bl 0x82214dd8
	ctx.lr = 0x828CE4DC;
	sub_82214DD8(ctx, base);
	// 828CE4DC: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828CE4E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE4E4: 388A3338  addi r4, r10, 0x3338
	ctx.r[4].s64 = ctx.r[10].s64 + 13112;
	// 828CE4E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE4EC: 4B95E9E5  bl 0x8222ced0
	ctx.lr = 0x828CE4F0;
	sub_8222CED0(ctx, base);
	// 828CE4F0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CE4F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CE4F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE4FC: 419A0008  beq cr6, 0x828ce504
	if ctx.cr[6].eq {
	pc = 0x828CE504; continue 'dispatch;
	}
	// 828CE500: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE504: 38BF0034  addi r5, r31, 0x34
	ctx.r[5].s64 = ctx.r[31].s64 + 52;
	// 828CE508: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE50C: 4BBB22BD  bl 0x824807c8
	ctx.lr = 0x828CE510;
	sub_824807C8(ctx, base);
	// 828CE510: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE514: 4B9468C5  bl 0x82214dd8
	ctx.lr = 0x828CE518;
	sub_82214DD8(ctx, base);
	// 828CE518: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CE51C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE520: 388B3424  addi r4, r11, 0x3424
	ctx.r[4].s64 = ctx.r[11].s64 + 13348;
	// 828CE524: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE528: 4B95E9A9  bl 0x8222ced0
	ctx.lr = 0x828CE52C;
	sub_8222CED0(ctx, base);
	// 828CE52C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CE530: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CE534: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE538: 419A0008  beq cr6, 0x828ce540
	if ctx.cr[6].eq {
	pc = 0x828CE540; continue 'dispatch;
	}
	// 828CE53C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE540: 38BF0038  addi r5, r31, 0x38
	ctx.r[5].s64 = ctx.r[31].s64 + 56;
	// 828CE544: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE548: 4BBB2281  bl 0x824807c8
	ctx.lr = 0x828CE54C;
	sub_824807C8(ctx, base);
	// 828CE54C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE550: 4B946889  bl 0x82214dd8
	ctx.lr = 0x828CE554;
	sub_82214DD8(ctx, base);
	// 828CE554: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828CE558: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE55C: 388B2DF8  addi r4, r11, 0x2df8
	ctx.r[4].s64 = ctx.r[11].s64 + 11768;
	// 828CE560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE564: 4B95E96D  bl 0x8222ced0
	ctx.lr = 0x828CE568;
	sub_8222CED0(ctx, base);
	// 828CE568: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 828CE56C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CE570: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE574: 4814E975  bl 0x82a1cee8
	ctx.lr = 0x828CE578;
	sub_82A1CEE8(ctx, base);
	// 828CE578: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE57C: 4B94685D  bl 0x82214dd8
	ctx.lr = 0x828CE580;
	sub_82214DD8(ctx, base);
	// 828CE580: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828CE584: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE588: 388A3434  addi r4, r10, 0x3434
	ctx.r[4].s64 = ctx.r[10].s64 + 13364;
	// 828CE58C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE590: 4B95E941  bl 0x8222ced0
	ctx.lr = 0x828CE594;
	sub_8222CED0(ctx, base);
	// 828CE594: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CE598: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CE59C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE5A0: 419A0008  beq cr6, 0x828ce5a8
	if ctx.cr[6].eq {
	pc = 0x828CE5A8; continue 'dispatch;
	}
	// 828CE5A4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE5A8: 38BF0018  addi r5, r31, 0x18
	ctx.r[5].s64 = ctx.r[31].s64 + 24;
	// 828CE5AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE5B0: 4BAC1AD9  bl 0x82390088
	ctx.lr = 0x828CE5B4;
	sub_82390088(ctx, base);
	// 828CE5B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE5B8: 4B946821  bl 0x82214dd8
	ctx.lr = 0x828CE5BC;
	sub_82214DD8(ctx, base);
	// 828CE5BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CE5C0: 483DAE9C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE5C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CE5C8 size=408
    let mut pc: u32 = 0x828CE5C8;
    'dispatch: loop {
        match pc {
            0x828CE5C8 => {
    //   block [0x828CE5C8..0x828CE760)
	// 828CE5C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE5CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CE5D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CE5D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE5D8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828CE5DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CE5E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CE5E4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828CE5E8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CE5EC: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828CE5F0: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CE5F4: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE5F8: 4B995E91  bl 0x82264488
	ctx.lr = 0x828CE5FC;
	sub_82264488(ctx, base);
	// 828CE5FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CE600: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE604: 419A0018  beq cr6, 0x828ce61c
	if ctx.cr[6].eq {
	pc = 0x828CE61C; continue 'dispatch;
	}
	// 828CE608: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828CE60C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828CE610: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CE614: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CE618: 409A0008  bne cr6, 0x828ce620
	if !ctx.cr[6].eq {
	pc = 0x828CE620; continue 'dispatch;
	}
	// 828CE61C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CE620: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828CE624: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CE628: 419A0124  beq cr6, 0x828ce74c
	if ctx.cr[6].eq {
	pc = 0x828CE74C; continue 'dispatch;
	}
	// 828CE62C: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828CE630: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828CE634: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828CE638: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CE63C: 419A00F8  beq cr6, 0x828ce734
	if ctx.cr[6].eq {
	pc = 0x828CE734; continue 'dispatch;
	}
	// 828CE640: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CE644: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CE648: 419A0024  beq cr6, 0x828ce66c
	if ctx.cr[6].eq {
	pc = 0x828CE66C; continue 'dispatch;
	}
	// 828CE64C: 894A0043  lbz r10, 0x43(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(67 as u32) ) } as u64;
	// 828CE650: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CE654: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828CE658: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828CE65C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CE660: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CE664: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CE668: 480000D0  b 0x828ce738
	pc = 0x828CE738; continue 'dispatch;
	// 828CE66C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CE670: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828CE674: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CE678: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828CE67C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828CE680: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CE684: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CE688: 40810054  ble 0x828ce6dc
	if !ctx.cr[0].gt {
	pc = 0x828CE6DC; continue 'dispatch;
	}
	// 828CE68C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828CE690: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828CE694: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828CE698: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE69C: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 828CE6A0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CE6A4: 41980008  blt cr6, 0x828ce6ac
	if ctx.cr[6].lt {
	pc = 0x828CE6AC; continue 'dispatch;
	}
	// 828CE6A8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828CE6AC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828CE6B0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828CE6B4: 419A0014  beq cr6, 0x828ce6c8
	if ctx.cr[6].eq {
	pc = 0x828CE6C8; continue 'dispatch;
	}
	// 828CE6B8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CE6BC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CE6C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CE6C4: 4800000C  b 0x828ce6d0
	pc = 0x828CE6D0; continue 'dispatch;
	// 828CE6C8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828CE6CC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828CE6D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CE6D4: 4199FFB8  bgt cr6, 0x828ce68c
	if ctx.cr[6].gt {
	pc = 0x828CE68C; continue 'dispatch;
	}
	// 828CE6D8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CE6DC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828CE6E0: 419A0040  beq cr6, 0x828ce720
	if ctx.cr[6].eq {
	pc = 0x828CE720; continue 'dispatch;
	}
	// 828CE6E4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE6E8: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 828CE6EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CE6F0: 41990008  bgt cr6, 0x828ce6f8
	if ctx.cr[6].gt {
	pc = 0x828CE6F8; continue 'dispatch;
	}
	// 828CE6F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CE6F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CE6FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE700: 409A0020  bne cr6, 0x828ce720
	if !ctx.cr[6].eq {
	pc = 0x828CE720; continue 'dispatch;
	}
	// 828CE704: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CE708: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828CE70C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CE710: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CE714: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CE718: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CE71C: 4800001C  b 0x828ce738
	pc = 0x828CE738; continue 'dispatch;
	// 828CE720: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828CE724: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CE728: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CE72C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CE730: 48000008  b 0x828ce738
	pc = 0x828CE738; continue 'dispatch;
	// 828CE734: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CE738: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CE73C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE740: 419A000C  beq cr6, 0x828ce74c
	if ctx.cr[6].eq {
	pc = 0x828CE74C; continue 'dispatch;
	}
	// 828CE744: 4BF5C76D  bl 0x8282aeb0
	ctx.lr = 0x828CE748;
	sub_8282AEB0(ctx, base);
	// 828CE748: 907F002C  stw r3, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[3].u32 ) };
	// 828CE74C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE750: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE754: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE758: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CE75C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CE760 size=268
    let mut pc: u32 = 0x828CE760;
    'dispatch: loop {
        match pc {
            0x828CE760 => {
    //   block [0x828CE760..0x828CE86C)
	// 828CE760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CE768: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CE76C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CE770: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828CE774: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE778: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CE77C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CE780: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828CE784: 394B31A8  addi r10, r11, 0x31a8
	ctx.r[10].s64 = ctx.r[11].s64 + 12712;
	// 828CE788: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828CE78C: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 828CE790: 9BDF0008  stb r30, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u8 ) };
	// 828CE794: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828CE798: 4BA53811  bl 0x82321fa8
	ctx.lr = 0x828CE79C;
	sub_82321FA8(ctx, base);
	// 828CE79C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828CE7A0: 4B950AB9  bl 0x8221f258
	ctx.lr = 0x828CE7A4;
	sub_8221F258(ctx, base);
	// 828CE7A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CE7A8: 419A0008  beq cr6, 0x828ce7b0
	if ctx.cr[6].eq {
	pc = 0x828CE7B0; continue 'dispatch;
	}
	// 828CE7AC: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828CE7B0: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CE7B4: 41820008  beq 0x828ce7bc
	if ctx.cr[0].eq {
	pc = 0x828CE7BC; continue 'dispatch;
	}
	// 828CE7B8: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828CE7BC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828CE7C0: 907F001C  stw r3, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 828CE7C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CE7C8: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 828CE7CC: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 828CE7D0: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828CE7D4: 913F0024  stw r9, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 828CE7D8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CE7DC: C3EB9484  lfs f31, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828CE7E0: 38880CA0  addi r4, r8, 0xca0
	ctx.r[4].s64 = ctx.r[8].s64 + 3232;
	// 828CE7E4: C00A0AC0  lfs f0, 0xac0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2752 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CE7E8: 387F005C  addi r3, r31, 0x5c
	ctx.r[3].s64 = ctx.r[31].s64 + 92;
	// 828CE7EC: D3FF0030  stfs f31, 0x30(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 828CE7F0: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 828CE7F4: D3FF0038  stfs f31, 0x38(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 828CE7F8: D3FF003C  stfs f31, 0x3c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 828CE7FC: D3FF0040  stfs f31, 0x40(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 828CE800: D3FF0044  stfs f31, 0x44(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 828CE804: D3FF0048  stfs f31, 0x48(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 828CE808: D3FF004C  stfs f31, 0x4c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 828CE80C: D3FF0050  stfs f31, 0x50(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828CE810: D3FF0054  stfs f31, 0x54(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828CE814: D3FF0058  stfs f31, 0x58(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828CE818: 4B95E6B9  bl 0x8222ced0
	ctx.lr = 0x828CE81C;
	sub_8222CED0(ctx, base);
	// 828CE81C: D3FF008C  stfs f31, 0x8c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 828CE820: 9BDF0060  stb r30, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[30].u8 ) };
	// 828CE824: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CE828: FBDF0068  std r30, 0x68(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u64 ) };
	// 828CE82C: 93DF0070  stw r30, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828CE830: 93DF0074  stw r30, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 828CE834: FBDF0078  std r30, 0x78(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[30].u64 ) };
	// 828CE838: 93DF0080  stw r30, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 828CE83C: 93DF0084  stw r30, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828CE840: 93DF0088  stw r30, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 828CE844: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CE848: 4BABEC71  bl 0x8238d4b8
	ctx.lr = 0x828CE84C;
	sub_8238D4B8(ctx, base);
	// 828CE84C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE850: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE854: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE858: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE85C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828CE860: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CE864: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CE868: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CE870 size=128
    let mut pc: u32 = 0x828CE870;
    'dispatch: loop {
        match pc {
            0x828CE870 => {
    //   block [0x828CE870..0x828CE8F0)
	// 828CE870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE874: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CE878: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CE87C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CE880: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE884: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CE888: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828CE88C: 387F005C  addi r3, r31, 0x5c
	ctx.r[3].s64 = ctx.r[31].s64 + 92;
	// 828CE890: 4B946549  bl 0x82214dd8
	ctx.lr = 0x828CE894;
	sub_82214DD8(ctx, base);
	// 828CE894: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 828CE898: 4BED2581  bl 0x827a0e18
	ctx.lr = 0x828CE89C;
	sub_827A0E18(ctx, base);
	// 828CE89C: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828CE8A0: 4B94D499  bl 0x8221bd38
	ctx.lr = 0x828CE8A4;
	sub_8221BD38(ctx, base);
	// 828CE8A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CE8A8: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828CE8AC: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 828CE8B0: 4BA52E31  bl 0x823216e0
	ctx.lr = 0x828CE8B4;
	sub_823216E0(ctx, base);
	// 828CE8B4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 828CE8B8: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828CE8BC: 390A2850  addi r8, r10, 0x2850
	ctx.r[8].s64 = ctx.r[10].s64 + 10320;
	// 828CE8C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CE8C4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828CE8C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE8CC: 419A000C  beq cr6, 0x828ce8d8
	if ctx.cr[6].eq {
	pc = 0x828CE8D8; continue 'dispatch;
	}
	// 828CE8D0: 4B94D469  bl 0x8221bd38
	ctx.lr = 0x828CE8D4;
	sub_8221BD38(ctx, base);
	// 828CE8D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE8D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE8DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE8E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE8E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CE8E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CE8EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CE8F0 size=36
    let mut pc: u32 = 0x828CE8F0;
    'dispatch: loop {
        match pc {
            0x828CE8F0 => {
    //   block [0x828CE8F0..0x828CE914)
	// 828CE8F0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828CE8F4: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828CE8F8: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 828CE8FC: C9AA9610  lfd f13, -0x69f0(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27120 as u32) ) };
	// 828CE900: FC000372  fmul f0, f0, f13
	ctx.f[0].f64 = ctx.f[0].f64 * ctx.f[13].f64;
	// 828CE904: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 828CE908: D9A1FFF0  stfd f13, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[13].u64 ) };
	// 828CE90C: 8061FFF4  lwz r3, -0xc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 828CE910: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CE918 size=436
    let mut pc: u32 = 0x828CE918;
    'dispatch: loop {
        match pc {
            0x828CE918 => {
    //   block [0x828CE918..0x828CEACC)
	// 828CE918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE91C: 483DAAED  bl 0x82ca9408
	ctx.lr = 0x828CE920;
	sub_82CA93D0(ctx, base);
	// 828CE920: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE924: 3D60811C  lis r11, -0x7ee4
	ctx.r[11].s64 = -2128871424;
	// 828CE928: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828CE92C: 617C9DC5  ori r28, r11, 0x9dc5
	ctx.r[28].u64 = ctx.r[11].u64 | 40389;
	// 828CE930: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CE934: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828CE938: 386AD294  addi r3, r10, -0x2d6c
	ctx.r[3].s64 = ctx.r[10].s64 + -11628;
	// 828CE93C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828CE940: 4B925419  bl 0x821f3d58
	ctx.lr = 0x828CE944;
	sub_821F3D58(ctx, base);
	// 828CE944: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828CE948: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CE94C: 80696DA0  lwz r3, 0x6da0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828CE950: 48131509  bl 0x829ffe58
	ctx.lr = 0x828CE954;
	sub_829FFE58(ctx, base);
	// 828CE954: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828CE958: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CE95C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CE960: 38883444  addi r4, r8, 0x3444
	ctx.r[4].s64 = ctx.r[8].s64 + 13380;
	// 828CE964: 4BAF0EBD  bl 0x823bf820
	ctx.lr = 0x828CE968;
	sub_823BF820(ctx, base);
	// 828CE968: 7C6707B4  extsw r7, r3
	ctx.r[7].s64 = ctx.r[3].s32 as i64;
	// 828CE96C: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828CE970: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 828CE974: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CE978: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828CE97C: 3866345C  addi r3, r6, 0x345c
	ctx.r[3].s64 = ctx.r[6].s64 + 13404;
	// 828CE980: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828CE984: D19F0034  stfs f12, 0x34(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 828CE988: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828CE98C: 4B9253CD  bl 0x821f3d58
	ctx.lr = 0x828CE990;
	sub_821F3D58(ctx, base);
	// 828CE990: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CE994: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CE998: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828CE99C: 48131D2D  bl 0x82a006c8
	ctx.lr = 0x828CE9A0;
	sub_82A006C8(ctx, base);
	// 828CE9A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CE9A4: 419A000C  beq cr6, 0x828ce9b0
	if ctx.cr[6].eq {
	pc = 0x828CE9B0; continue 'dispatch;
	}
	// 828CE9A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE9AC: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 828CE9B0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CE9B4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828CE9B8: 386B3470  addi r3, r11, 0x3470
	ctx.r[3].s64 = ctx.r[11].s64 + 13424;
	// 828CE9BC: 4B92539D  bl 0x821f3d58
	ctx.lr = 0x828CE9C0;
	sub_821F3D58(ctx, base);
	// 828CE9C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CE9C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CE9C8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828CE9CC: 48131CFD  bl 0x82a006c8
	ctx.lr = 0x828CE9D0;
	sub_82A006C8(ctx, base);
	// 828CE9D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CE9D4: 419A000C  beq cr6, 0x828ce9e0
	if ctx.cr[6].eq {
	pc = 0x828CE9E0; continue 'dispatch;
	}
	// 828CE9D8: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CE9DC: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 828CE9E0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828CE9E4: 419A00E0  beq cr6, 0x828ceac4
	if ctx.cr[6].eq {
	pc = 0x828CEAC4; continue 'dispatch;
	}
	// 828CE9E8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CE9EC: 38BF0028  addi r5, r31, 0x28
	ctx.r[5].s64 = ctx.r[31].s64 + 40;
	// 828CE9F0: 388B3484  addi r4, r11, 0x3484
	ctx.r[4].s64 = ctx.r[11].s64 + 13444;
	// 828CE9F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE9F8: 4BADEA71  bl 0x823ad468
	ctx.lr = 0x828CE9FC;
	sub_823AD468(ctx, base);
	// 828CE9FC: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828CEA00: 38BF002C  addi r5, r31, 0x2c
	ctx.r[5].s64 = ctx.r[31].s64 + 44;
	// 828CEA04: 388A349C  addi r4, r10, 0x349c
	ctx.r[4].s64 = ctx.r[10].s64 + 13468;
	// 828CEA08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CEA0C: 4BADEA5D  bl 0x823ad468
	ctx.lr = 0x828CEA10;
	sub_823AD468(ctx, base);
	// 828CEA10: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828CEA14: 38BF0038  addi r5, r31, 0x38
	ctx.r[5].s64 = ctx.r[31].s64 + 56;
	// 828CEA18: 388934AC  addi r4, r9, 0x34ac
	ctx.r[4].s64 = ctx.r[9].s64 + 13484;
	// 828CEA1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CEA20: 4BADE9D1  bl 0x823ad3f0
	ctx.lr = 0x828CEA24;
	sub_823AD3F0(ctx, base);
	// 828CEA24: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828CEA28: 38BF003C  addi r5, r31, 0x3c
	ctx.r[5].s64 = ctx.r[31].s64 + 60;
	// 828CEA2C: 388834C8  addi r4, r8, 0x34c8
	ctx.r[4].s64 = ctx.r[8].s64 + 13512;
	// 828CEA30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CEA34: 4BADE9BD  bl 0x823ad3f0
	ctx.lr = 0x828CEA38;
	sub_823AD3F0(ctx, base);
	// 828CEA38: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 828CEA3C: 38BF0040  addi r5, r31, 0x40
	ctx.r[5].s64 = ctx.r[31].s64 + 64;
	// 828CEA40: 388734E4  addi r4, r7, 0x34e4
	ctx.r[4].s64 = ctx.r[7].s64 + 13540;
	// 828CEA44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CEA48: 4BADE9A9  bl 0x823ad3f0
	ctx.lr = 0x828CEA4C;
	sub_823AD3F0(ctx, base);
	// 828CEA4C: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828CEA50: 38BF0044  addi r5, r31, 0x44
	ctx.r[5].s64 = ctx.r[31].s64 + 68;
	// 828CEA54: 38863500  addi r4, r6, 0x3500
	ctx.r[4].s64 = ctx.r[6].s64 + 13568;
	// 828CEA58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CEA5C: 4BADE995  bl 0x823ad3f0
	ctx.lr = 0x828CEA60;
	sub_823AD3F0(ctx, base);
	// 828CEA60: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 828CEA64: 38BF0048  addi r5, r31, 0x48
	ctx.r[5].s64 = ctx.r[31].s64 + 72;
	// 828CEA68: 3884351C  addi r4, r4, 0x351c
	ctx.r[4].s64 = ctx.r[4].s64 + 13596;
	// 828CEA6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CEA70: 4BADE981  bl 0x823ad3f0
	ctx.lr = 0x828CEA74;
	sub_823AD3F0(ctx, base);
	// 828CEA74: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 828CEA78: 38BF004C  addi r5, r31, 0x4c
	ctx.r[5].s64 = ctx.r[31].s64 + 76;
	// 828CEA7C: 38833538  addi r4, r3, 0x3538
	ctx.r[4].s64 = ctx.r[3].s64 + 13624;
	// 828CEA80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CEA84: 4BADE96D  bl 0x823ad3f0
	ctx.lr = 0x828CEA88;
	sub_823AD3F0(ctx, base);
	// 828CEA88: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CEA8C: 38BF0050  addi r5, r31, 0x50
	ctx.r[5].s64 = ctx.r[31].s64 + 80;
	// 828CEA90: 388B3554  addi r4, r11, 0x3554
	ctx.r[4].s64 = ctx.r[11].s64 + 13652;
	// 828CEA94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CEA98: 4BADE959  bl 0x823ad3f0
	ctx.lr = 0x828CEA9C;
	sub_823AD3F0(ctx, base);
	// 828CEA9C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828CEAA0: 38BF0054  addi r5, r31, 0x54
	ctx.r[5].s64 = ctx.r[31].s64 + 84;
	// 828CEAA4: 388A3570  addi r4, r10, 0x3570
	ctx.r[4].s64 = ctx.r[10].s64 + 13680;
	// 828CEAA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CEAAC: 4BADE945  bl 0x823ad3f0
	ctx.lr = 0x828CEAB0;
	sub_823AD3F0(ctx, base);
	// 828CEAB0: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828CEAB4: 38BF0058  addi r5, r31, 0x58
	ctx.r[5].s64 = ctx.r[31].s64 + 88;
	// 828CEAB8: 3889358C  addi r4, r9, 0x358c
	ctx.r[4].s64 = ctx.r[9].s64 + 13708;
	// 828CEABC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CEAC0: 4BADE931  bl 0x823ad3f0
	ctx.lr = 0x828CEAC4;
	sub_823AD3F0(ctx, base);
	// 828CEAC4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CEAC8: 483DA990  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CEAD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CEAD0 size=2352
    let mut pc: u32 = 0x828CEAD0;
    'dispatch: loop {
        match pc {
            0x828CEAD0 => {
    //   block [0x828CEAD0..0x828CF400)
	// 828CEAD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CEAD4: 483DA919  bl 0x82ca93ec
	ctx.lr = 0x828CEAD8;
	sub_82CA93D0(ctx, base);
	// 828CEAD8: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 828CEADC: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CEAE0: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 828CEAE4: 3EA08349  lis r21, -0x7cb7
	ctx.r[21].s64 = -2092367872;
	// 828CEAE8: E9760068  ld r11, 0x68(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[22].u32.wrapping_add(104 as u32) ) };
	// 828CEAEC: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 828CEAF0: 419A0140  beq cr6, 0x828cec30
	if ctx.cr[6].eq {
	pc = 0x828CEC30; continue 'dispatch;
	}
	// 828CEAF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CEAF8: 483F8189  bl 0x82cc6c80
	ctx.lr = 0x828CEAFC;
	sub_82CC6C80(ctx, base);
	// 828CEAFC: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 828CEB00: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CEB04: 483F886D  bl 0x82cc7370
	ctx.lr = 0x828CEB08;
	sub_82CC7370(ctx, base);
	// 828CEB08: 8101007C  lwz r8, 0x7c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828CEB0C: 81210078  lwz r9, 0x78(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828CEB10: E9760068  ld r11, 0x68(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[22].u32.wrapping_add(104 as u32) ) };
	// 828CEB14: 7928000E  rldimi r8, r9, 0x20, 0
	ctx.r[8].u64 = ((ctx.r[9].u64).rotate_left(32) & 0xFFFFFFFF00000000) | (ctx.r[8].u64 & 0x00000000FFFFFFFF);
	// 828CEB18: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 828CEB1C: 7F285840  cmpld cr6, r8, r11
	ctx.cr[6].compare_u64(ctx.r[8].u64, ctx.r[11].u64, &mut ctx.xer);
	// 828CEB20: 409900AC  ble cr6, 0x828cebcc
	if !ctx.cr[6].gt {
	pc = 0x828CEBCC; continue 'dispatch;
	}
	// 828CEB24: 3D200098  lis r9, 0x98
	ctx.r[9].s64 = 9961472;
	// 828CEB28: C016008C  lfs f0, 0x8c(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CEB2C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CEB30: 80F60088  lwz r7, 0x88(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(136 as u32) ) } as u64;
	// 828CEB34: 61269680  ori r6, r9, 0x9680
	ctx.r[6].u64 = ctx.r[9].u64 | 38528;
	// 828CEB38: 38A0003C  li r5, 0x3c
	ctx.r[5].s64 = 60;
	// 828CEB3C: 7C883392  divdu r4, r8, r6
	ctx.r[4].u64 = ctx.r[8].u64 / ctx.r[6].u64;
	// 828CEB40: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 828CEB44: 7D642B92  divdu r11, r4, r5
	ctx.r[11].u64 = ctx.r[4].u64 / ctx.r[5].u64;
	// 828CEB48: 7D4B1B92  divdu r10, r11, r3
	ctx.r[10].u64 = ctx.r[11].u64 / ctx.r[3].u64;
	// 828CEB4C: 7D4807B4  extsw r8, r10
	ctx.r[8].s64 = ctx.r[10].s32 as i64;
	// 828CEB50: F9010070  std r8, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u64 ) };
	// 828CEB54: C9A10070  lfd f13, 0x70(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828CEB58: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 828CEB5C: ED60602C  fsqrts f11, f12
	ctx.f[11].f64 = ((ctx.f[12].f64).sqrt() as f32) as f64;
	// 828CEB60: ED4B0032  fmuls f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 828CEB64: FD20501E  fctiwz f9, f10
	ctx.f[9].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 828CEB68: D9210070  stfd f9, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[9].u64 ) };
	// 828CEB6C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828CEB70: 7CEB3850  subf r7, r11, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 828CEB74: 7CE6FE70  srawi r6, r7, 0x1f
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[7].s32 >> 31) as i64;
	// 828CEB78: 7CCA3838  and r10, r6, r7
	ctx.r[10].u64 = ctx.r[6].u64 & ctx.r[7].u64;
	// 828CEB7C: 7C8A5A15  add. r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 828CEB80: 4081004C  ble 0x828cebcc
	if !ctx.cr[0].gt {
	pc = 0x828CEBCC; continue 'dispatch;
	}
	// 828CEB84: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828CEB88: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 828CEB8C: 48000AF5  bl 0x828cf680
	ctx.lr = 0x828CEB90;
	sub_828CF680(ctx, base);
	// 828CEB90: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828CEB94: 90760080  stw r3, 0x80(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 828CEB98: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828CEB9C: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 828CEBA0: 39000084  li r8, 0x84
	ctx.r[8].s64 = 132;
	// 828CEBA4: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 828CEBA8: 7D6707B4  extsw r7, r11
	ctx.r[7].s64 = ctx.r[11].s32 as i64;
	// 828CEBAC: F8E10078  std r7, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[7].u64 ) };
	// 828CEBB0: C8010078  lfd f0, 0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 828CEBB4: FD80069C  fcfid f12, f0
	ctx.f[12].f64 = (ctx.f[0].s64 as f64);
	// 828CEBB8: C80A9660  lfd f0, -0x69a0(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 828CEBBC: C9A91718  lfd f13, 0x1718(r9)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(5912 as u32) ) };
	// 828CEBC0: FD60637A  fmadd f11, f0, f13, f12
	ctx.f[11].f64 = ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64;
	// 828CEBC4: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 828CEBC8: 7D5647AE  stfiwx f10, r22, r8
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 828CEBCC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828CEBD0: FBB60068  std r29, 0x68(r22)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[22].u32.wrapping_add(104 as u32), ctx.r[29].u64 ) };
	// 828CEBD4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 828CEBD8: 48005641  bl 0x828d4218
	ctx.lr = 0x828CEBDC;
	sub_828D4218(ctx, base);
	// 828CEBDC: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CEBE0: C0160030  lfs f0, 0x30(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CEBE4: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 828CEBE8: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 828CEBEC: D9A10078  stfd f13, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.f[13].u64 ) };
	// 828CEBF0: 8361007C  lwz r27, 0x7c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828CEBF4: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828CEBF8: 55287FFE  rlwinm r8, r9, 0xf, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0001FFFFu64;
	// 828CEBFC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828CEC00: 419A0644  beq cr6, 0x828cf244
	if ctx.cr[6].eq {
	pc = 0x828CF244; continue 'dispatch;
	}
	// 828CEC04: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CEC08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CEC0C: 419A0574  beq cr6, 0x828cf180
	if ctx.cr[6].eq {
	pc = 0x828CF180; continue 'dispatch;
	}
	// 828CEC10: 894A0051  lbz r10, 0x51(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(81 as u32) ) } as u64;
	// 828CEC14: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CEC18: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828CEC1C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828CEC20: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CEC24: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828CEC28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CEC2C: 4800061C  b 0x828cf248
	pc = 0x828CF248; continue 'dispatch;
	// 828CEC30: 81756AB8  lwz r11, 0x6ab8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828CEC34: 3B360018  addi r25, r22, 0x18
	ctx.r[25].s64 = ctx.r[22].s64 + 24;
	// 828CEC38: 8136001C  lwz r9, 0x1c(r22)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28 as u32) ) } as u64;
	// 828CEC3C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828CEC40: 93210078  stw r25, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[25].u32 ) };
	// 828CEC44: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828CEC48: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CEC4C: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CEC50: 830A6DA0  lwz r24, 0x6da0(r10)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828CEC54: 80C80058  lwz r6, 0x58(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 828CEC58: 90E1007C  stw r7, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 828CEC5C: E8A10078  ld r5, 0x78(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 828CEC60: F8A10078  std r5, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[5].u64 ) };
	// 828CEC64: 80860004  lwz r4, 4(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CEC68: 83410078  lwz r26, 0x78(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828CEC6C: 8361007C  lwz r27, 0x7c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828CEC70: 80640008  lwz r3, 8(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CEC74: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CEC78: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828CEC7C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828CEC80: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CEC84: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828CEC88: 82E900B4  lwz r23, 0xb4(r9)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(180 as u32) ) } as u64;
	// 828CEC8C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CEC90: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828CEC94: 419A000C  beq cr6, 0x828ceca0
	if ctx.cr[6].eq {
	pc = 0x828CECA0; continue 'dispatch;
	}
	// 828CEC98: 7F1AC840  cmplw cr6, r26, r25
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[25].u32, &mut ctx.xer);
	// 828CEC9C: 419A0008  beq cr6, 0x828ceca4
	if ctx.cr[6].eq {
	pc = 0x828CECA4; continue 'dispatch;
	}
	// 828CECA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CECA4: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CECA8: 419AFF2C  beq cr6, 0x828cebd4
	if ctx.cr[6].eq {
	pc = 0x828CEBD4; continue 'dispatch;
	}
	// 828CECAC: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828CECB0: 409A0008  bne cr6, 0x828cecb8
	if !ctx.cr[6].eq {
	pc = 0x828CECB8; continue 'dispatch;
	}
	// 828CECB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CECB8: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CECBC: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CECC0: 409A0008  bne cr6, 0x828cecc8
	if !ctx.cr[6].eq {
	pc = 0x828CECC8; continue 'dispatch;
	}
	// 828CECC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CECC8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CECCC: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CECD0: 7F09B840  cmplw cr6, r9, r23
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[23].u32, &mut ctx.xer);
	// 828CECD4: 409A0494  bne cr6, 0x828cf168
	if !ctx.cr[6].eq {
	pc = 0x828CF168; continue 'dispatch;
	}
	// 828CECD8: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CECDC: 409A0008  bne cr6, 0x828cece4
	if !ctx.cr[6].eq {
	pc = 0x828CECE4; continue 'dispatch;
	}
	// 828CECE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CECE4: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828CECE8: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828CECEC: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828CECF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CECF4: 409A0014  bne cr6, 0x828ced08
	if !ctx.cr[6].eq {
	pc = 0x828CED08; continue 'dispatch;
	}
	// 828CECF8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828CECFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CED00: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828CED04: 419A0008  beq cr6, 0x828ced0c
	if ctx.cr[6].eq {
	pc = 0x828CED0C; continue 'dispatch;
	}
	// 828CED08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CED0C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CED10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CED14: 419A0454  beq cr6, 0x828cf168
	if ctx.cr[6].eq {
	pc = 0x828CF168; continue 'dispatch;
	}
	// 828CED18: 81756AB8  lwz r11, 0x6ab8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828CED1C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828CED20: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CED24: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828CED28: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CED2C: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CED30: 4B995759  bl 0x82264488
	ctx.lr = 0x828CED34;
	sub_82264488(ctx, base);
	// 828CED34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CED38: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828CED3C: 419A0018  beq cr6, 0x828ced54
	if ctx.cr[6].eq {
	pc = 0x828CED54; continue 'dispatch;
	}
	// 828CED40: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 828CED44: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828CED48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CED4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CED50: 409A0008  bne cr6, 0x828ced58
	if !ctx.cr[6].eq {
	pc = 0x828CED58; continue 'dispatch;
	}
	// 828CED54: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828CED58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CED5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CED60: 419A0408  beq cr6, 0x828cf168
	if ctx.cr[6].eq {
	pc = 0x828CF168; continue 'dispatch;
	}
	// 828CED64: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 828CED68: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 828CED6C: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828CED70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CED74: 419A00F4  beq cr6, 0x828cee68
	if ctx.cr[6].eq {
	pc = 0x828CEE68; continue 'dispatch;
	}
	// 828CED78: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CED7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CED80: 419A0024  beq cr6, 0x828ceda4
	if ctx.cr[6].eq {
	pc = 0x828CEDA4; continue 'dispatch;
	}
	// 828CED84: 894B0043  lbz r10, 0x43(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(67 as u32) ) } as u64;
	// 828CED88: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CED8C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828CED90: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828CED94: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CED98: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828CED9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CEDA0: 480000CC  b 0x828cee6c
	pc = 0x828CEE6C; continue 'dispatch;
	// 828CEDA4: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CEDA8: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CEDAC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828CEDB0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828CEDB4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CEDB8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CEDBC: 40810054  ble 0x828cee10
	if !ctx.cr[0].gt {
	pc = 0x828CEE10; continue 'dispatch;
	}
	// 828CEDC0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828CEDC4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828CEDC8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828CEDCC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CEDD0: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 828CEDD4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CEDD8: 41980008  blt cr6, 0x828cede0
	if ctx.cr[6].lt {
	pc = 0x828CEDE0; continue 'dispatch;
	}
	// 828CEDDC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828CEDE0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828CEDE4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828CEDE8: 419A0014  beq cr6, 0x828cedfc
	if ctx.cr[6].eq {
	pc = 0x828CEDFC; continue 'dispatch;
	}
	// 828CEDEC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CEDF0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CEDF4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CEDF8: 4800000C  b 0x828cee04
	pc = 0x828CEE04; continue 'dispatch;
	// 828CEDFC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828CEE00: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828CEE04: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CEE08: 4199FFB8  bgt cr6, 0x828cedc0
	if ctx.cr[6].gt {
	pc = 0x828CEDC0; continue 'dispatch;
	}
	// 828CEE0C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CEE10: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828CEE14: 419A0040  beq cr6, 0x828cee54
	if ctx.cr[6].eq {
	pc = 0x828CEE54; continue 'dispatch;
	}
	// 828CEE18: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CEE1C: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 828CEE20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CEE24: 41990008  bgt cr6, 0x828cee2c
	if ctx.cr[6].gt {
	pc = 0x828CEE2C; continue 'dispatch;
	}
	// 828CEE28: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828CEE2C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CEE30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CEE34: 409A0020  bne cr6, 0x828cee54
	if !ctx.cr[6].eq {
	pc = 0x828CEE54; continue 'dispatch;
	}
	// 828CEE38: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CEE3C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828CEE40: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828CEE44: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CEE48: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828CEE4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CEE50: 4800001C  b 0x828cee6c
	pc = 0x828CEE6C; continue 'dispatch;
	// 828CEE54: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828CEE58: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CEE5C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828CEE60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CEE64: 48000008  b 0x828cee6c
	pc = 0x828CEE6C; continue 'dispatch;
	// 828CEE68: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828CEE6C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CEE70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CEE74: 419A02F4  beq cr6, 0x828cf168
	if ctx.cr[6].eq {
	pc = 0x828CF168; continue 'dispatch;
	}
	// 828CEE78: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CEE7C: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CEE80: 409A0008  bne cr6, 0x828cee88
	if !ctx.cr[6].eq {
	pc = 0x828CEE88; continue 'dispatch;
	}
	// 828CEE84: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CEE88: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CEE8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CEE90: C02B0040  lfs f1, 0x40(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CEE94: 4BF5E1C5  bl 0x8282d058
	ctx.lr = 0x828CEE98;
	sub_8282D058(ctx, base);
	// 828CEE98: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CEE9C: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CEEA0: 409A0008  bne cr6, 0x828ceea8
	if !ctx.cr[6].eq {
	pc = 0x828CEEA8; continue 'dispatch;
	}
	// 828CEEA4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CEEA8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CEEAC: D3EB0040  stfs f31, 0x40(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 828CEEB0: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CEEB4: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CEEB8: 409A0008  bne cr6, 0x828ceec0
	if !ctx.cr[6].eq {
	pc = 0x828CEEC0; continue 'dispatch;
	}
	// 828CEEBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CEEC0: 838B0018  lwz r28, 0x18(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828CEEC4: 93AB0018  stw r29, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 828CEEC8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828CEECC: 419A029C  beq cr6, 0x828cf168
	if ctx.cr[6].eq {
	pc = 0x828CF168; continue 'dispatch;
	}
	// 828CEED0: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828CEED4: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828CEED8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CEEDC: 419A0018  beq cr6, 0x828ceef4
	if ctx.cr[6].eq {
	pc = 0x828CEEF4; continue 'dispatch;
	}
	// 828CEEE0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828CEEE4: 80960004  lwz r4, 4(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CEEE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CEEEC: 4BF5ED6D  bl 0x8282dc58
	ctx.lr = 0x828CEEF0;
	sub_8282DC58(ctx, base);
	// 828CEEF0: 48000278  b 0x828cf168
	pc = 0x828CF168; continue 'dispatch;
	// 828CEEF4: 815E002C  lwz r10, 0x2c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 828CEEF8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828CEEFC: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 828CEF00: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CEF04: 419A00E8  beq cr6, 0x828cefec
	if ctx.cr[6].eq {
	pc = 0x828CEFEC; continue 'dispatch;
	}
	// 828CEF08: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CEF0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CEF10: 419A0020  beq cr6, 0x828cef30
	if ctx.cr[6].eq {
	pc = 0x828CEF30; continue 'dispatch;
	}
	// 828CEF14: 894B0042  lbz r10, 0x42(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(66 as u32) ) } as u64;
	// 828CEF18: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CEF1C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828CEF20: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828CEF24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CEF28: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CEF2C: 480000C4  b 0x828ceff0
	pc = 0x828CEFF0; continue 'dispatch;
	// 828CEF30: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CEF34: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CEF38: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828CEF3C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828CEF40: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 828CEF44: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CEF48: 40810054  ble 0x828cef9c
	if !ctx.cr[0].gt {
	pc = 0x828CEF9C; continue 'dispatch;
	}
	// 828CEF4C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828CEF50: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828CEF54: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828CEF58: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CEF5C: 2F070042  cmpwi cr6, r7, 0x42
	ctx.cr[6].compare_i32(ctx.r[7].s32, 66, &mut ctx.xer);
	// 828CEF60: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CEF64: 41980008  blt cr6, 0x828cef6c
	if ctx.cr[6].lt {
	pc = 0x828CEF6C; continue 'dispatch;
	}
	// 828CEF68: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828CEF6C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828CEF70: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828CEF74: 419A0014  beq cr6, 0x828cef88
	if ctx.cr[6].eq {
	pc = 0x828CEF88; continue 'dispatch;
	}
	// 828CEF78: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CEF7C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CEF80: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CEF84: 4800000C  b 0x828cef90
	pc = 0x828CEF90; continue 'dispatch;
	// 828CEF88: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828CEF8C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828CEF90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CEF94: 4199FFB8  bgt cr6, 0x828cef4c
	if ctx.cr[6].gt {
	pc = 0x828CEF4C; continue 'dispatch;
	}
	// 828CEF98: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 828CEF9C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828CEFA0: 419A003C  beq cr6, 0x828cefdc
	if ctx.cr[6].eq {
	pc = 0x828CEFDC; continue 'dispatch;
	}
	// 828CEFA4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CEFA8: 2F0B0042  cmpwi cr6, r11, 0x42
	ctx.cr[6].compare_i32(ctx.r[11].s32, 66, &mut ctx.xer);
	// 828CEFAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CEFB0: 41990008  bgt cr6, 0x828cefb8
	if ctx.cr[6].gt {
	pc = 0x828CEFB8; continue 'dispatch;
	}
	// 828CEFB4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828CEFB8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CEFBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CEFC0: 409A001C  bne cr6, 0x828cefdc
	if !ctx.cr[6].eq {
	pc = 0x828CEFDC; continue 'dispatch;
	}
	// 828CEFC4: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828CEFC8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CEFCC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828CEFD0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828CEFD4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CEFD8: 48000018  b 0x828ceff0
	pc = 0x828CEFF0; continue 'dispatch;
	// 828CEFDC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828CEFE0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CEFE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CEFE8: 48000008  b 0x828ceff0
	pc = 0x828CEFF0; continue 'dispatch;
	// 828CEFEC: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 828CEFF0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828CEFF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CEFF8: 419A0170  beq cr6, 0x828cf168
	if ctx.cr[6].eq {
	pc = 0x828CF168; continue 'dispatch;
	}
	// 828CEFFC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CF000: 4B9CFE79  bl 0x8229ee78
	ctx.lr = 0x828CF004;
	sub_8229EE78(ctx, base);
	// 828CF004: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CF008: 419A0018  beq cr6, 0x828cf020
	if ctx.cr[6].eq {
	pc = 0x828CF020; continue 'dispatch;
	}
	// 828CF00C: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828CF010: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828CF014: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CF018: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CF01C: 409A0008  bne cr6, 0x828cf024
	if !ctx.cr[6].eq {
	pc = 0x828CF024; continue 'dispatch;
	}
	// 828CF020: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828CF024: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CF028: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF02C: 419A013C  beq cr6, 0x828cf168
	if ctx.cr[6].eq {
	pc = 0x828CF168; continue 'dispatch;
	}
	// 828CF030: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 828CF034: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828CF038: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828CF03C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CF040: 419A00F4  beq cr6, 0x828cf134
	if ctx.cr[6].eq {
	pc = 0x828CF134; continue 'dispatch;
	}
	// 828CF044: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CF048: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF04C: 419A0024  beq cr6, 0x828cf070
	if ctx.cr[6].eq {
	pc = 0x828CF070; continue 'dispatch;
	}
	// 828CF050: 894B0041  lbz r10, 0x41(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 828CF054: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CF058: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828CF05C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828CF060: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF064: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 828CF068: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CF06C: 480000CC  b 0x828cf138
	pc = 0x828CF138; continue 'dispatch;
	// 828CF070: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CF074: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CF078: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 828CF07C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828CF080: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 828CF084: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CF088: 40810054  ble 0x828cf0dc
	if !ctx.cr[0].gt {
	pc = 0x828CF0DC; continue 'dispatch;
	}
	// 828CF08C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828CF090: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828CF094: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828CF098: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CF09C: 2F070041  cmpwi cr6, r7, 0x41
	ctx.cr[6].compare_i32(ctx.r[7].s32, 65, &mut ctx.xer);
	// 828CF0A0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CF0A4: 41980008  blt cr6, 0x828cf0ac
	if ctx.cr[6].lt {
	pc = 0x828CF0AC; continue 'dispatch;
	}
	// 828CF0A8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828CF0AC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828CF0B0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828CF0B4: 419A0014  beq cr6, 0x828cf0c8
	if ctx.cr[6].eq {
	pc = 0x828CF0C8; continue 'dispatch;
	}
	// 828CF0B8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CF0BC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CF0C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CF0C4: 4800000C  b 0x828cf0d0
	pc = 0x828CF0D0; continue 'dispatch;
	// 828CF0C8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828CF0CC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828CF0D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CF0D4: 4199FFB8  bgt cr6, 0x828cf08c
	if ctx.cr[6].gt {
	pc = 0x828CF08C; continue 'dispatch;
	}
	// 828CF0D8: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 828CF0DC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828CF0E0: 419A0040  beq cr6, 0x828cf120
	if ctx.cr[6].eq {
	pc = 0x828CF120; continue 'dispatch;
	}
	// 828CF0E4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CF0E8: 2F0B0041  cmpwi cr6, r11, 0x41
	ctx.cr[6].compare_i32(ctx.r[11].s32, 65, &mut ctx.xer);
	// 828CF0EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CF0F0: 41990008  bgt cr6, 0x828cf0f8
	if ctx.cr[6].gt {
	pc = 0x828CF0F8; continue 'dispatch;
	}
	// 828CF0F4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828CF0F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CF0FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF100: 409A0020  bne cr6, 0x828cf120
	if !ctx.cr[6].eq {
	pc = 0x828CF120; continue 'dispatch;
	}
	// 828CF104: E9610078  ld r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 828CF108: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828CF10C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828CF110: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF114: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 828CF118: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CF11C: 4800001C  b 0x828cf138
	pc = 0x828CF138; continue 'dispatch;
	// 828CF120: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828CF124: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF128: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 828CF12C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CF130: 48000008  b 0x828cf138
	pc = 0x828CF138; continue 'dispatch;
	// 828CF134: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828CF138: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CF13C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF140: 419A0028  beq cr6, 0x828cf168
	if ctx.cr[6].eq {
	pc = 0x828CF168; continue 'dispatch;
	}
	// 828CF144: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828CF148: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828CF14C: 4B915105  bl 0x821e4250
	ctx.lr = 0x828CF150;
	sub_821E4250(ctx, base);
	// 828CF150: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CF154: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828CF158: 419A0010  beq cr6, 0x828cf168
	if ctx.cr[6].eq {
	pc = 0x828CF168; continue 'dispatch;
	}
	// 828CF15C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828CF160: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 828CF164: 4BBCA26D  bl 0x824993d0
	ctx.lr = 0x828CF168;
	sub_824993D0(ctx, base);
	// 828CF168: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF16C: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CF170: 409A0008  bne cr6, 0x828cf178
	if !ctx.cr[6].eq {
	pc = 0x828CF178; continue 'dispatch;
	}
	// 828CF174: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CF178: 837B0000  lwz r27, 0(r27)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CF17C: 4BFFFB10  b 0x828cec8c
	pc = 0x828CEC8C; continue 'dispatch;
	// 828CF180: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CF184: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CF188: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 828CF18C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828CF190: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 828CF194: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CF198: 40810054  ble 0x828cf1ec
	if !ctx.cr[0].gt {
	pc = 0x828CF1EC; continue 'dispatch;
	}
	// 828CF19C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828CF1A0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828CF1A4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828CF1A8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CF1AC: 2F070051  cmpwi cr6, r7, 0x51
	ctx.cr[6].compare_i32(ctx.r[7].s32, 81, &mut ctx.xer);
	// 828CF1B0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CF1B4: 41980008  blt cr6, 0x828cf1bc
	if ctx.cr[6].lt {
	pc = 0x828CF1BC; continue 'dispatch;
	}
	// 828CF1B8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828CF1BC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828CF1C0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828CF1C4: 419A0014  beq cr6, 0x828cf1d8
	if ctx.cr[6].eq {
	pc = 0x828CF1D8; continue 'dispatch;
	}
	// 828CF1C8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CF1CC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CF1D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CF1D4: 4800000C  b 0x828cf1e0
	pc = 0x828CF1E0; continue 'dispatch;
	// 828CF1D8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828CF1DC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828CF1E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CF1E4: 4199FFB8  bgt cr6, 0x828cf19c
	if ctx.cr[6].gt {
	pc = 0x828CF19C; continue 'dispatch;
	}
	// 828CF1E8: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 828CF1EC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828CF1F0: 419A0040  beq cr6, 0x828cf230
	if ctx.cr[6].eq {
	pc = 0x828CF230; continue 'dispatch;
	}
	// 828CF1F4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CF1F8: 2F0B0051  cmpwi cr6, r11, 0x51
	ctx.cr[6].compare_i32(ctx.r[11].s32, 81, &mut ctx.xer);
	// 828CF1FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CF200: 41990008  bgt cr6, 0x828cf208
	if ctx.cr[6].gt {
	pc = 0x828CF208; continue 'dispatch;
	}
	// 828CF204: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828CF208: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CF20C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF210: 409A0020  bne cr6, 0x828cf230
	if !ctx.cr[6].eq {
	pc = 0x828CF230; continue 'dispatch;
	}
	// 828CF214: E9610078  ld r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 828CF218: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 828CF21C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828CF220: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF224: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828CF228: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CF22C: 4800001C  b 0x828cf248
	pc = 0x828CF248; continue 'dispatch;
	// 828CF230: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828CF234: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF238: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828CF23C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CF240: 48000008  b 0x828cf248
	pc = 0x828CF248; continue 'dispatch;
	// 828CF244: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828CF248: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CF24C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF250: 419A000C  beq cr6, 0x828cf25c
	if ctx.cr[6].eq {
	pc = 0x828CF25C; continue 'dispatch;
	}
	// 828CF254: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CF258: 7F6BDA14  add r27, r11, r27
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828CF25C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828CF260: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828CF264: 4B90B14D  bl 0x821da3b0
	ctx.lr = 0x828CF268;
	sub_821DA3B0(ctx, base);
	// 828CF268: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CF26C: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828CF270: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CF274: 386B35AC  addi r3, r11, 0x35ac
	ctx.r[3].s64 = ctx.r[11].s64 + 13740;
	// 828CF278: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828CF27C: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 828CF280: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828CF284: 4B924AD5  bl 0x821f3d58
	ctx.lr = 0x828CF288;
	sub_821F3D58(ctx, base);
	// 828CF288: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828CF28C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CF290: 4B8E3269  bl 0x821b24f8
	ctx.lr = 0x828CF294;
	sub_821B24F8(ctx, base);
	// 828CF294: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 828CF298: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828CF29C: 4B91676D  bl 0x821e5a08
	ctx.lr = 0x828CF2A0;
	sub_821E5A08(ctx, base);
	// 828CF2A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CF2A4: 419A0008  beq cr6, 0x828cf2ac
	if ctx.cr[6].eq {
	pc = 0x828CF2AC; continue 'dispatch;
	}
	// 828CF2A8: 83830000  lwz r28, 0(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CF2AC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828CF2B0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828CF2B4: 4B90B0FD  bl 0x821da3b0
	ctx.lr = 0x828CF2B8;
	sub_821DA3B0(ctx, base);
	// 828CF2B8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CF2BC: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828CF2C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CF2C4: 386B35C8  addi r3, r11, 0x35c8
	ctx.r[3].s64 = ctx.r[11].s64 + 13768;
	// 828CF2C8: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828CF2CC: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828CF2D0: 4B924A89  bl 0x821f3d58
	ctx.lr = 0x828CF2D4;
	sub_821F3D58(ctx, base);
	// 828CF2D4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828CF2D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CF2DC: 4B8E321D  bl 0x821b24f8
	ctx.lr = 0x828CF2E0;
	sub_821B24F8(ctx, base);
	// 828CF2E0: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 828CF2E4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828CF2E8: 4B916721  bl 0x821e5a08
	ctx.lr = 0x828CF2EC;
	sub_821E5A08(ctx, base);
	// 828CF2EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CF2F0: 419A0008  beq cr6, 0x828cf2f8
	if ctx.cr[6].eq {
	pc = 0x828CF2F8; continue 'dispatch;
	}
	// 828CF2F4: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CF2F8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828CF2FC: 3BF6005C  addi r31, r22, 0x5c
	ctx.r[31].s64 = ctx.r[22].s64 + 92;
	// 828CF300: 3BCB92D8  addi r30, r11, -0x6d28
	ctx.r[30].s64 = ctx.r[11].s64 + -27944;
	// 828CF304: 8176005C  lwz r11, 0x5c(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(92 as u32) ) } as u64;
	// 828CF308: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF30C: 419A0054  beq cr6, 0x828cf360
	if ctx.cr[6].eq {
	pc = 0x828CF360; continue 'dispatch;
	}
	// 828CF310: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF314: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CF318: 419A0048  beq cr6, 0x828cf360
	if ctx.cr[6].eq {
	pc = 0x828CF360; continue 'dispatch;
	}
	// 828CF31C: 81756AB8  lwz r11, 0x6ab8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828CF320: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CF324: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CF328: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CF32C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828CF330: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF334: 83490028  lwz r26, 0x28(r9)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CF338: 4B920F09  bl 0x821f0240
	ctx.lr = 0x828CF33C;
	sub_821F0240(ctx, base);
	// 828CF33C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828CF340: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CF344: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CF348: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CF34C: 4B95DB85  bl 0x8222ced0
	ctx.lr = 0x828CF350;
	sub_8222CED0(ctx, base);
	// 828CF350: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CF354: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828CF358: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 828CF35C: 4BBAB815  bl 0x8247ab70
	ctx.lr = 0x828CF360;
	sub_8247AB70(ctx, base);
	// 828CF360: 7F1BE000  cmpw cr6, r27, r28
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[28].s32, &mut ctx.xer);
	// 828CF364: 40980010  bge cr6, 0x828cf374
	if !ctx.cr[6].lt {
	pc = 0x828CF374; continue 'dispatch;
	}
	// 828CF368: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CF36C: 388B35E4  addi r4, r11, 0x35e4
	ctx.r[4].s64 = ctx.r[11].s64 + 13796;
	// 828CF370: 48000020  b 0x828cf390
	pc = 0x828CF390; continue 'dispatch;
	// 828CF374: 7F1BE800  cmpw cr6, r27, r29
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[29].s32, &mut ctx.xer);
	// 828CF378: 40980010  bge cr6, 0x828cf388
	if !ctx.cr[6].lt {
	pc = 0x828CF388; continue 'dispatch;
	}
	// 828CF37C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CF380: 388B35F4  addi r4, r11, 0x35f4
	ctx.r[4].s64 = ctx.r[11].s64 + 13812;
	// 828CF384: 4800000C  b 0x828cf390
	pc = 0x828CF390; continue 'dispatch;
	// 828CF388: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CF38C: 388B3608  addi r4, r11, 0x3608
	ctx.r[4].s64 = ctx.r[11].s64 + 13832;
	// 828CF390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CF394: 4B9A60A5  bl 0x82275438
	ctx.lr = 0x828CF398;
	sub_82275438(ctx, base);
	// 828CF398: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CF39C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF3A0: 419A0054  beq cr6, 0x828cf3f4
	if ctx.cr[6].eq {
	pc = 0x828CF3F4; continue 'dispatch;
	}
	// 828CF3A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF3A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CF3AC: 419A0048  beq cr6, 0x828cf3f4
	if ctx.cr[6].eq {
	pc = 0x828CF3F4; continue 'dispatch;
	}
	// 828CF3B0: 81756AB8  lwz r11, 0x6ab8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828CF3B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CF3B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CF3BC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CF3C0: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828CF3C4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF3C8: 83E90028  lwz r31, 0x28(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CF3CC: 4B920E75  bl 0x821f0240
	ctx.lr = 0x828CF3D0;
	sub_821F0240(ctx, base);
	// 828CF3D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CF3D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CF3D8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CF3DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CF3E0: 4B95DAF1  bl 0x8222ced0
	ctx.lr = 0x828CF3E4;
	sub_8222CED0(ctx, base);
	// 828CF3E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CF3E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CF3EC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828CF3F0: 4BBAB681  bl 0x8247aa70
	ctx.lr = 0x828CF3F4;
	sub_8247AA70(ctx, base);
	// 828CF3F4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 828CF3F8: CBE1FF98  lfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 828CF3FC: 483DA040  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CF400 size=636
    let mut pc: u32 = 0x828CF400;
    'dispatch: loop {
        match pc {
            0x828CF400 => {
    //   block [0x828CF400..0x828CF67C)
	// 828CF400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CF404: 483DA005  bl 0x82ca9408
	ctx.lr = 0x828CF408;
	sub_82CA93D0(ctx, base);
	// 828CF408: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CF40C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CF410: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828CF414: 809D0080  lwz r4, 0x80(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 828CF418: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 828CF41C: 40990144  ble cr6, 0x828cf560
	if !ctx.cr[6].gt {
	pc = 0x828CF560; continue 'dispatch;
	}
	// 828CF420: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828CF424: 815D0084  lwz r10, 0x84(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 828CF428: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 828CF42C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 828CF430: 41980130  blt cr6, 0x828cf560
	if ctx.cr[6].lt {
	pc = 0x828CF560; continue 'dispatch;
	}
	// 828CF434: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF438: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CF43C: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828CF440: 55497FFE  rlwinm r9, r10, 0xf, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0001FFFFu64;
	// 828CF444: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CF448: 419A00F4  beq cr6, 0x828cf53c
	if ctx.cr[6].eq {
	pc = 0x828CF53C; continue 'dispatch;
	}
	// 828CF44C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CF450: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CF454: 419A0024  beq cr6, 0x828cf478
	if ctx.cr[6].eq {
	pc = 0x828CF478; continue 'dispatch;
	}
	// 828CF458: 894A0051  lbz r10, 0x51(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(81 as u32) ) } as u64;
	// 828CF45C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CF460: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828CF464: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828CF468: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF46C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CF470: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CF474: 480000CC  b 0x828cf540
	pc = 0x828CF540; continue 'dispatch;
	// 828CF478: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CF47C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CF480: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828CF484: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828CF488: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CF48C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CF490: 40810054  ble 0x828cf4e4
	if !ctx.cr[0].gt {
	pc = 0x828CF4E4; continue 'dispatch;
	}
	// 828CF494: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828CF498: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828CF49C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828CF4A0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CF4A4: 2F070051  cmpwi cr6, r7, 0x51
	ctx.cr[6].compare_i32(ctx.r[7].s32, 81, &mut ctx.xer);
	// 828CF4A8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CF4AC: 41980008  blt cr6, 0x828cf4b4
	if ctx.cr[6].lt {
	pc = 0x828CF4B4; continue 'dispatch;
	}
	// 828CF4B0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828CF4B4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828CF4B8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828CF4BC: 419A0014  beq cr6, 0x828cf4d0
	if ctx.cr[6].eq {
	pc = 0x828CF4D0; continue 'dispatch;
	}
	// 828CF4C0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CF4C4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CF4C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CF4CC: 4800000C  b 0x828cf4d8
	pc = 0x828CF4D8; continue 'dispatch;
	// 828CF4D0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828CF4D4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828CF4D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CF4DC: 4199FFB8  bgt cr6, 0x828cf494
	if ctx.cr[6].gt {
	pc = 0x828CF494; continue 'dispatch;
	}
	// 828CF4E0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CF4E4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828CF4E8: 419A0040  beq cr6, 0x828cf528
	if ctx.cr[6].eq {
	pc = 0x828CF528; continue 'dispatch;
	}
	// 828CF4EC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CF4F0: 2F0B0051  cmpwi cr6, r11, 0x51
	ctx.cr[6].compare_i32(ctx.r[11].s32, 81, &mut ctx.xer);
	// 828CF4F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CF4F8: 41990008  bgt cr6, 0x828cf500
	if ctx.cr[6].gt {
	pc = 0x828CF500; continue 'dispatch;
	}
	// 828CF4FC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828CF500: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CF504: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF508: 409A0020  bne cr6, 0x828cf528
	if !ctx.cr[6].eq {
	pc = 0x828CF528; continue 'dispatch;
	}
	// 828CF50C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CF510: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828CF514: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CF518: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF51C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CF520: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CF524: 4800001C  b 0x828cf540
	pc = 0x828CF540; continue 'dispatch;
	// 828CF528: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828CF52C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF530: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CF534: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CF538: 48000008  b 0x828cf540
	pc = 0x828CF540; continue 'dispatch;
	// 828CF53C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828CF540: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CF544: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF548: 419A0014  beq cr6, 0x828cf55c
	if ctx.cr[6].eq {
	pc = 0x828CF55C; continue 'dispatch;
	}
	// 828CF54C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CF550: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828CF554: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828CF558: 4BB5F021  bl 0x8242e578
	ctx.lr = 0x828CF55C;
	sub_8242E578(ctx, base);
	// 828CF55C: 939D0080  stw r28, 0x80(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 828CF560: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CF564: 483F771D  bl 0x82cc6c80
	ctx.lr = 0x828CF568;
	sub_82CC6C80(ctx, base);
	// 828CF568: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CF56C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CF570: 483F7E01  bl 0x82cc7370
	ctx.lr = 0x828CF574;
	sub_82CC7370(ctx, base);
	// 828CF574: E97D0078  ld r11, 0x78(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(120 as u32) ) };
	// 828CF578: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CF57C: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 828CF580: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CF584: 793F000E  rldimi r31, r9, 0x20, 0
	ctx.r[31].u64 = ((ctx.r[9].u64).rotate_left(32) & 0xFFFFFFFF00000000) | (ctx.r[31].u64 & 0x00000000FFFFFFFF);
	// 828CF588: 409A0054  bne cr6, 0x828cf5dc
	if !ctx.cr[6].eq {
	pc = 0x828CF5DC; continue 'dispatch;
	}
	// 828CF58C: 3D406666  lis r10, 0x6666
	ctx.r[10].s64 = 1717960704;
	// 828CF590: A121006A  lhz r9, 0x6a(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(106 as u32) ) } as u64;
	// 828CF594: 61486667  ori r8, r10, 0x6667
	ctx.r[8].u64 = ctx.r[10].u64 | 26215;
	// 828CF598: 7CE94096  mulhw r7, r9, r8
	ctx.r[7].s64 = ((ctx.r[9].s32 as i64 * ctx.r[8].s32 as i64) >> 32);
	// 828CF59C: 7CEB0E70  srawi r11, r7, 1
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 1) as i64;
	// 828CF5A0: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828CF5A4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828CF5A8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828CF5AC: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828CF5B0: 7CA64851  subf. r5, r6, r9
	ctx.r[5].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828CF5B4: 40820094  bne 0x828cf648
	if !ctx.cr[0].eq {
	pc = 0x828CF648; continue 'dispatch;
	}
	// 828CF5B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828CF5BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CF5C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CF5C4: 480000BD  bl 0x828cf680
	ctx.lr = 0x828CF5C8;
	sub_828CF680(ctx, base);
	// 828CF5C8: 39605E00  li r11, 0x5e00
	ctx.r[11].s64 = 24064;
	// 828CF5CC: 656AB2D0  oris r10, r11, 0xb2d0
	ctx.r[10].u64 = ctx.r[11].u64 | 2999975936;
	// 828CF5D0: 7D3F5214  add r9, r31, r10
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 828CF5D4: F93D0078  std r9, 0x78(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(120 as u32), ctx.r[9].u64 ) };
	// 828CF5D8: 48000070  b 0x828cf648
	pc = 0x828CF648; continue 'dispatch;
	// 828CF5DC: 7F3F5840  cmpld cr6, r31, r11
	ctx.cr[6].compare_u64(ctx.r[31].u64, ctx.r[11].u64, &mut ctx.xer);
	// 828CF5E0: 41980068  blt cr6, 0x828cf648
	if ctx.cr[6].lt {
	pc = 0x828CF648; continue 'dispatch;
	}
	// 828CF5E4: 39405E00  li r10, 0x5e00
	ctx.r[10].s64 = 24064;
	// 828CF5E8: 7D2BF850  subf r9, r11, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 828CF5EC: 655EB2D0  oris r30, r10, 0xb2d0
	ctx.r[30].u64 = ctx.r[10].u64 | 2999975936;
	// 828CF5F0: 7D09F392  divdu r8, r9, r30
	ctx.r[8].u64 = ctx.r[9].u64 / ctx.r[30].u64;
	// 828CF5F4: 550B003E  slwi r11, r8, 0
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828CF5F8: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 828CF5FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CF600: 2F1F0001  cmpwi cr6, r31, 1
	ctx.cr[6].compare_i32(ctx.r[31].s32, 1, &mut ctx.xer);
	// 828CF604: 40990024  ble cr6, 0x828cf628
	if !ctx.cr[6].gt {
	pc = 0x828CF628; continue 'dispatch;
	}
	// 828CF608: 7FEB07B4  extsw r11, r31
	ctx.r[11].s64 = ctx.r[31].s32 as i64;
	// 828CF60C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828CF610: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828CF614: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828CF618: ED80682C  fsqrts f12, f13
	ctx.f[12].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 828CF61C: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 828CF620: D9610058  stfd f11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[11].u64 ) };
	// 828CF624: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828CF628: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828CF62C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CF630: 48000051  bl 0x828cf680
	ctx.lr = 0x828CF634;
	sub_828CF680(ctx, base);
	// 828CF634: 7FEB07B4  extsw r11, r31
	ctx.r[11].s64 = ctx.r[31].s32 as i64;
	// 828CF638: E95D0078  ld r10, 0x78(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(120 as u32) ) };
	// 828CF63C: 7D6BF1D2  mulld r11, r11, r30
	ctx.r[11].s64 = ctx.r[11].s64 * ctx.r[30].s64;
	// 828CF640: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828CF644: F95D0078  std r10, 0x78(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(120 as u32), ctx.r[10].u64 ) };
	// 828CF648: 897D0060  lbz r11, 0x60(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 828CF64C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF650: 419A0024  beq cr6, 0x828cf674
	if ctx.cr[6].eq {
	pc = 0x828CF674; continue 'dispatch;
	}
	// 828CF654: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828CF658: 3880001B  li r4, 0x1b
	ctx.r[4].s64 = 27;
	// 828CF65C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828CF660: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CF664: 812A00A8  lwz r9, 0xa8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(168 as u32) ) } as u64;
	// 828CF668: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF66C: 4B8E5BF5  bl 0x821b5260
	ctx.lr = 0x828CF670;
	sub_821B5260(ctx, base);
	// 828CF670: 9B9D0060  stb r28, 0x60(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), ctx.r[28].u8 ) };
	// 828CF674: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828CF678: 483D9DE0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CF680 size=1928
    let mut pc: u32 = 0x828CF680;
    'dispatch: loop {
        match pc {
            0x828CF680 => {
    //   block [0x828CF680..0x828CFE08)
	// 828CF680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CF684: 483D9D55  bl 0x82ca93d8
	ctx.lr = 0x828CF688;
	sub_82CA93D0(ctx, base);
	// 828CF688: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 828CF68C: 483DE64D  bl 0x82cadcd8
	ctx.lr = 0x828CF690;
	sub_82CADCA0(ctx, base);
	// 828CF690: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CF694: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 828CF698: 7CB22B78  mr r18, r5
	ctx.r[18].u64 = ctx.r[5].u64;
	// 828CF69C: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 828CF6A0: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 828CF6A4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828CF6A8: 815B6AB8  lwz r10, 0x6ab8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828CF6AC: 3B330018  addi r25, r19, 0x18
	ctx.r[25].s64 = ctx.r[19].s64 + 24;
	// 828CF6B0: 396BCB94  addi r11, r11, -0x346c
	ctx.r[11].s64 = ctx.r[11].s64 + -13420;
	// 828CF6B4: 93210068  stw r25, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 828CF6B8: 3A200000  li r17, 0
	ctx.r[17].s64 = 0;
	// 828CF6BC: 8133001C  lwz r9, 0x1c(r19)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(28 as u32) ) } as u64;
	// 828CF6C0: 3EA0820A  lis r21, -0x7df6
	ctx.r[21].s64 = -2113273856;
	// 828CF6C4: 7E308B78  mr r16, r17
	ctx.r[16].u64 = ctx.r[17].u64;
	// 828CF6C8: 80EA000C  lwz r7, 0xc(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CF6CC: C3ABC8F0  lfs f29, -0x3710(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14096 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828CF6D0: C38B0000  lfs f28, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 828CF6D4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CF6D8: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CF6DC: FFC0E890  fmr f30, f29
	ctx.f[30].f64 = ctx.f[29].f64;
	// 828CF6E0: 3ACB3618  addi r22, r11, 0x3618
	ctx.r[22].s64 = ctx.r[11].s64 + 13848;
	// 828CF6E4: 80A70058  lwz r5, 0x58(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(88 as u32) ) } as u64;
	// 828CF6E8: 9101006C  stw r8, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[8].u32 ) };
	// 828CF6EC: E8C10068  ld r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828CF6F0: 80850004  lwz r4, 4(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF6F4: F8C10068  std r6, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[6].u64 ) };
	// 828CF6F8: 80640008  lwz r3, 8(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CF6FC: 83810068  lwz r28, 0x68(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828CF700: 83A1006C  lwz r29, 0x6c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828CF704: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF708: 812A0024  lwz r9, 0x24(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 828CF70C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828CF710: 3AEA3630  addi r23, r10, 0x3630
	ctx.r[23].s64 = ctx.r[10].s64 + 13872;
	// 828CF714: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF718: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 828CF71C: 3B49E950  addi r26, r9, -0x16b0
	ctx.r[26].s64 = ctx.r[9].s64 + -5808;
	// 828CF720: 828800B4  lwz r20, 0xb4(r8)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(180 as u32) ) } as u64;
	// 828CF724: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF728: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828CF72C: 419A000C  beq cr6, 0x828cf738
	if ctx.cr[6].eq {
	pc = 0x828CF738; continue 'dispatch;
	}
	// 828CF730: 7F1CC840  cmplw cr6, r28, r25
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[25].u32, &mut ctx.xer);
	// 828CF734: 419A0008  beq cr6, 0x828cf73c
	if ctx.cr[6].eq {
	pc = 0x828CF73C; continue 'dispatch;
	}
	// 828CF738: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CF73C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CF740: 419A0414  beq cr6, 0x828cfb54
	if ctx.cr[6].eq {
	pc = 0x828CFB54; continue 'dispatch;
	}
	// 828CF744: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828CF748: 409A0008  bne cr6, 0x828cf750
	if !ctx.cr[6].eq {
	pc = 0x828CF750; continue 'dispatch;
	}
	// 828CF74C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CF750: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF754: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CF758: 409A0008  bne cr6, 0x828cf760
	if !ctx.cr[6].eq {
	pc = 0x828CF760; continue 'dispatch;
	}
	// 828CF75C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CF760: 83DD0008  lwz r30, 8(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CF764: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CF768: 4BFFE151  bl 0x828cd8b8
	ctx.lr = 0x828CF76C;
	sub_828CD8B8(ctx, base);
	// 828CF76C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828CF770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF774: 409A0028  bne cr6, 0x828cf79c
	if !ctx.cr[6].eq {
	pc = 0x828CF79C; continue 'dispatch;
	}
	// 828CF778: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CF77C: 4BFFDF6D  bl 0x828cd6e8
	ctx.lr = 0x828CF780;
	sub_828CD6E8(ctx, base);
	// 828CF780: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828CF784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF788: 409A0014  bne cr6, 0x828cf79c
	if !ctx.cr[6].eq {
	pc = 0x828CF79C; continue 'dispatch;
	}
	// 828CF78C: 897E000E  lbz r11, 0xe(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(14 as u32) ) } as u64;
	// 828CF790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF794: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 828CF798: 419A0008  beq cr6, 0x828cf7a0
	if ctx.cr[6].eq {
	pc = 0x828CF7A0; continue 'dispatch;
	}
	// 828CF79C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CF7A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CF7A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF7A8: 419A0394  beq cr6, 0x828cfb3c
	if ctx.cr[6].eq {
	pc = 0x828CFB3C; continue 'dispatch;
	}
	// 828CF7AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CF7B0: 4BFFE5D9  bl 0x828cdd88
	ctx.lr = 0x828CF7B4;
	sub_828CDD88(ctx, base);
	// 828CF7B4: 7D63C1D6  mullw r11, r3, r24
	ctx.r[11].s64 = (ctx.r[3].s32 as i64) * (ctx.r[24].s32 as i64);
	// 828CF7B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CF7BC: 7E0B8214  add r16, r11, r16
	ctx.r[16].u64 = ctx.r[11].u64 + ctx.r[16].u64;
	// 828CF7C0: 4BFFE7A1  bl 0x828cdf60
	ctx.lr = 0x828CF7C4;
	sub_828CDF60(ctx, base);
	// 828CF7C4: 7C6907B4  extsw r9, r3
	ctx.r[9].s64 = ctx.r[3].s32 as i64;
	// 828CF7C8: 7F0B07B4  extsw r11, r24
	ctx.r[11].s64 = ctx.r[24].s32 as i64;
	// 828CF7CC: 895E000F  lbz r10, 0xf(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(15 as u32) ) } as u64;
	// 828CF7D0: F9210078  std r9, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[9].u64 ) };
	// 828CF7D4: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 828CF7D8: C8010070  lfd f0, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828CF7DC: FD80069C  fcfid f12, f0
	ctx.f[12].f64 = (ctx.f[0].s64 as f64);
	// 828CF7E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CF7E4: C9A10078  lfd f13, 0x78(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 828CF7E8: FD406018  frsp f10, f12
	ctx.f[10].f64 = (ctx.f[12].f64 as f32) as f64;
	// 828CF7EC: FD606E9C  fcfid f11, f13
	ctx.f[11].f64 = (ctx.f[13].s64 as f64);
	// 828CF7F0: FD205818  frsp f9, f11
	ctx.f[9].f64 = (ctx.f[11].f64 as f32) as f64;
	// 828CF7F4: ED090732  fmuls f8, f9, f28
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[28].f64) as f32) as f64);
	// 828CF7F8: EFE802B2  fmuls f31, f8, f10
	ctx.f[31].f64 = (((ctx.f[8].f64 * ctx.f[10].f64) as f32) as f64);
	// 828CF7FC: 419A0050  beq cr6, 0x828cf84c
	if ctx.cr[6].eq {
	pc = 0x828CF84C; continue 'dispatch;
	}
	// 828CF800: 7C6BFE70  srawi r11, r3, 0x1f
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[3].s32 >> 31) as i64;
	// 828CF804: 7C6A5A78  xor r10, r3, r11
	ctx.r[10].u64 = ctx.r[3].u64 ^ ctx.r[11].u64;
	// 828CF808: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CF80C: 2F0B0019  cmpwi cr6, r11, 0x19
	ctx.cr[6].compare_i32(ctx.r[11].s32, 25, &mut ctx.xer);
	// 828CF810: 409A000C  bne cr6, 0x828cf81c
	if !ctx.cr[6].eq {
	pc = 0x828CF81C; continue 'dispatch;
	}
	// 828CF814: C0130038  lfs f0, 0x38(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CF818: 480000B8  b 0x828cf8d0
	pc = 0x828CF8D0; continue 'dispatch;
	// 828CF81C: 2F0B0032  cmpwi cr6, r11, 0x32
	ctx.cr[6].compare_i32(ctx.r[11].s32, 50, &mut ctx.xer);
	// 828CF820: 409A000C  bne cr6, 0x828cf82c
	if !ctx.cr[6].eq {
	pc = 0x828CF82C; continue 'dispatch;
	}
	// 828CF824: C013003C  lfs f0, 0x3c(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CF828: 480000A8  b 0x828cf8d0
	pc = 0x828CF8D0; continue 'dispatch;
	// 828CF82C: 2F0B004B  cmpwi cr6, r11, 0x4b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 75, &mut ctx.xer);
	// 828CF830: 409A000C  bne cr6, 0x828cf83c
	if !ctx.cr[6].eq {
	pc = 0x828CF83C; continue 'dispatch;
	}
	// 828CF834: C0130040  lfs f0, 0x40(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CF838: 48000098  b 0x828cf8d0
	pc = 0x828CF8D0; continue 'dispatch;
	// 828CF83C: 2F0B0064  cmpwi cr6, r11, 0x64
	ctx.cr[6].compare_i32(ctx.r[11].s32, 100, &mut ctx.xer);
	// 828CF840: 409A008C  bne cr6, 0x828cf8cc
	if !ctx.cr[6].eq {
	pc = 0x828CF8CC; continue 'dispatch;
	}
	// 828CF844: C0130044  lfs f0, 0x44(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CF848: 48000088  b 0x828cf8d0
	pc = 0x828CF8D0; continue 'dispatch;
	// 828CF84C: 2F030014  cmpwi cr6, r3, 0x14
	ctx.cr[6].compare_i32(ctx.r[3].s32, 20, &mut ctx.xer);
	// 828CF850: 409A000C  bne cr6, 0x828cf85c
	if !ctx.cr[6].eq {
	pc = 0x828CF85C; continue 'dispatch;
	}
	// 828CF854: C0130048  lfs f0, 0x48(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CF858: 48000078  b 0x828cf8d0
	pc = 0x828CF8D0; continue 'dispatch;
	// 828CF85C: 2F030028  cmpwi cr6, r3, 0x28
	ctx.cr[6].compare_i32(ctx.r[3].s32, 40, &mut ctx.xer);
	// 828CF860: 409A000C  bne cr6, 0x828cf86c
	if !ctx.cr[6].eq {
	pc = 0x828CF86C; continue 'dispatch;
	}
	// 828CF864: C013004C  lfs f0, 0x4c(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CF868: 48000068  b 0x828cf8d0
	pc = 0x828CF8D0; continue 'dispatch;
	// 828CF86C: 2F03003C  cmpwi cr6, r3, 0x3c
	ctx.cr[6].compare_i32(ctx.r[3].s32, 60, &mut ctx.xer);
	// 828CF870: 409A000C  bne cr6, 0x828cf87c
	if !ctx.cr[6].eq {
	pc = 0x828CF87C; continue 'dispatch;
	}
	// 828CF874: C0130050  lfs f0, 0x50(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CF878: 48000058  b 0x828cf8d0
	pc = 0x828CF8D0; continue 'dispatch;
	// 828CF87C: 2F030050  cmpwi cr6, r3, 0x50
	ctx.cr[6].compare_i32(ctx.r[3].s32, 80, &mut ctx.xer);
	// 828CF880: 409A000C  bne cr6, 0x828cf88c
	if !ctx.cr[6].eq {
	pc = 0x828CF88C; continue 'dispatch;
	}
	// 828CF884: C0130054  lfs f0, 0x54(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CF888: 48000048  b 0x828cf8d0
	pc = 0x828CF8D0; continue 'dispatch;
	// 828CF88C: 2F030064  cmpwi cr6, r3, 0x64
	ctx.cr[6].compare_i32(ctx.r[3].s32, 100, &mut ctx.xer);
	// 828CF890: 409A000C  bne cr6, 0x828cf89c
	if !ctx.cr[6].eq {
	pc = 0x828CF89C; continue 'dispatch;
	}
	// 828CF894: C0130058  lfs f0, 0x58(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CF898: 48000038  b 0x828cf8d0
	pc = 0x828CF8D0; continue 'dispatch;
	// 828CF89C: 2F03FFEC  cmpwi cr6, r3, -0x14
	ctx.cr[6].compare_i32(ctx.r[3].s32, -20, &mut ctx.xer);
	// 828CF8A0: 409A000C  bne cr6, 0x828cf8ac
	if !ctx.cr[6].eq {
	pc = 0x828CF8AC; continue 'dispatch;
	}
	// 828CF8A4: C0130050  lfs f0, 0x50(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CF8A8: 48000028  b 0x828cf8d0
	pc = 0x828CF8D0; continue 'dispatch;
	// 828CF8AC: 2F03FFD8  cmpwi cr6, r3, -0x28
	ctx.cr[6].compare_i32(ctx.r[3].s32, -40, &mut ctx.xer);
	// 828CF8B0: 409A000C  bne cr6, 0x828cf8bc
	if !ctx.cr[6].eq {
	pc = 0x828CF8BC; continue 'dispatch;
	}
	// 828CF8B4: C0130054  lfs f0, 0x54(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CF8B8: 48000018  b 0x828cf8d0
	pc = 0x828CF8D0; continue 'dispatch;
	// 828CF8BC: 2F03FFC4  cmpwi cr6, r3, -0x3c
	ctx.cr[6].compare_i32(ctx.r[3].s32, -60, &mut ctx.xer);
	// 828CF8C0: 409A000C  bne cr6, 0x828cf8cc
	if !ctx.cr[6].eq {
	pc = 0x828CF8CC; continue 'dispatch;
	}
	// 828CF8C4: C0130058  lfs f0, 0x58(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CF8C8: 48000008  b 0x828cf8d0
	pc = 0x828CF8D0; continue 'dispatch;
	// 828CF8CC: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 828CF8D0: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828CF8D4: EFC0F7FA  fmadds f30, f0, f31, f30
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[30].f64) as f32) as f64);
	// 828CF8D8: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828CF8DC: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828CF8E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CF8E4: 409A0014  bne cr6, 0x828cf8f8
	if !ctx.cr[6].eq {
	pc = 0x828CF8F8; continue 'dispatch;
	}
	// 828CF8E8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828CF8EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF8F0: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 828CF8F4: 419A0008  beq cr6, 0x828cf8fc
	if ctx.cr[6].eq {
	pc = 0x828CF8FC; continue 'dispatch;
	}
	// 828CF8F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CF8FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CF900: 83FB6AB8  lwz r31, 0x6ab8(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828CF904: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF908: 419A017C  beq cr6, 0x828cfa84
	if ctx.cr[6].eq {
	pc = 0x828CFA84; continue 'dispatch;
	}
	// 828CF90C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CF910: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828CF914: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828CF918: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF91C: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CF920: 4B994B69  bl 0x82264488
	ctx.lr = 0x828CF924;
	sub_82264488(ctx, base);
	// 828CF924: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CF928: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF92C: 419A0018  beq cr6, 0x828cf944
	if ctx.cr[6].eq {
	pc = 0x828CF944; continue 'dispatch;
	}
	// 828CF930: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828CF934: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828CF938: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CF93C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CF940: 409A0008  bne cr6, 0x828cf948
	if !ctx.cr[6].eq {
	pc = 0x828CF948; continue 'dispatch;
	}
	// 828CF944: 7E2A8B78  mr r10, r17
	ctx.r[10].u64 = ctx.r[17].u64;
	// 828CF948: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828CF94C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CF950: 419A0128  beq cr6, 0x828cfa78
	if ctx.cr[6].eq {
	pc = 0x828CFA78; continue 'dispatch;
	}
	// 828CF954: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828CF958: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828CF95C: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828CF960: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CF964: 419A00F4  beq cr6, 0x828cfa58
	if ctx.cr[6].eq {
	pc = 0x828CFA58; continue 'dispatch;
	}
	// 828CF968: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CF96C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CF970: 419A0024  beq cr6, 0x828cf994
	if ctx.cr[6].eq {
	pc = 0x828CF994; continue 'dispatch;
	}
	// 828CF974: 892A0043  lbz r9, 0x43(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(67 as u32) ) } as u64;
	// 828CF978: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CF97C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828CF980: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828CF984: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CF988: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CF98C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CF990: 480000CC  b 0x828cfa5c
	pc = 0x828CFA5C; continue 'dispatch;
	// 828CF994: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CF998: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CF99C: 92210068  stw r17, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[17].u32 ) };
	// 828CF9A0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828CF9A4: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828CF9A8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CF9AC: 40810054  ble 0x828cfa00
	if !ctx.cr[0].gt {
	pc = 0x828CFA00; continue 'dispatch;
	}
	// 828CF9B0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828CF9B4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828CF9B8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828CF9BC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CF9C0: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 828CF9C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CF9C8: 41980008  blt cr6, 0x828cf9d0
	if ctx.cr[6].lt {
	pc = 0x828CF9D0; continue 'dispatch;
	}
	// 828CF9CC: 7E278B78  mr r7, r17
	ctx.r[7].u64 = ctx.r[17].u64;
	// 828CF9D0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828CF9D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828CF9D8: 419A0014  beq cr6, 0x828cf9ec
	if ctx.cr[6].eq {
	pc = 0x828CF9EC; continue 'dispatch;
	}
	// 828CF9DC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CF9E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CF9E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CF9E8: 4800000C  b 0x828cf9f4
	pc = 0x828CF9F4; continue 'dispatch;
	// 828CF9EC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828CF9F0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828CF9F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CF9F8: 4199FFB8  bgt cr6, 0x828cf9b0
	if ctx.cr[6].gt {
	pc = 0x828CF9B0; continue 'dispatch;
	}
	// 828CF9FC: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828CFA00: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828CFA04: 419A0040  beq cr6, 0x828cfa44
	if ctx.cr[6].eq {
	pc = 0x828CFA44; continue 'dispatch;
	}
	// 828CFA08: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CFA0C: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 828CFA10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CFA14: 41990008  bgt cr6, 0x828cfa1c
	if ctx.cr[6].gt {
	pc = 0x828CFA1C; continue 'dispatch;
	}
	// 828CFA18: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 828CFA1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CFA20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CFA24: 409A0020  bne cr6, 0x828cfa44
	if !ctx.cr[6].eq {
	pc = 0x828CFA44; continue 'dispatch;
	}
	// 828CFA28: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828CFA2C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828CFA30: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828CFA34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFA38: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CFA3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CFA40: 4800001C  b 0x828cfa5c
	pc = 0x828CFA5C; continue 'dispatch;
	// 828CFA44: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828CFA48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFA4C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CFA50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CFA54: 48000008  b 0x828cfa5c
	pc = 0x828CFA5C; continue 'dispatch;
	// 828CFA58: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 828CFA5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CFA60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CFA64: 419A0020  beq cr6, 0x828cfa84
	if ctx.cr[6].eq {
	pc = 0x828CFA84; continue 'dispatch;
	}
	// 828CFA68: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828CFA6C: 4BF5D5ED  bl 0x8282d058
	ctx.lr = 0x828CFA70;
	sub_8282D058(ctx, base);
	// 828CFA70: 83FB6AB8  lwz r31, 0x6ab8(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828CFA74: 48000010  b 0x828cfa84
	pc = 0x828CFA84; continue 'dispatch;
	// 828CFA78: C01E0040  lfs f0, 0x40(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CFA7C: EDA0F82A  fadds f13, f0, f31
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 828CFA80: D1BE0040  stfs f13, 0x40(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 828CFA84: FDA0FA10  fabs f13, f31
	ctx.f[13].u64 = ctx.f[31].u64 & !0x8000_0000_0000_0000u64;
	// 828CFA88: C0159054  lfs f0, -0x6fac(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-28588 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CFA8C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828CFA90: 41980018  blt cr6, 0x828cfaa8
	if ctx.cr[6].lt {
	pc = 0x828CFAA8; continue 'dispatch;
	}
	// 828CFA94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CFA98: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828CFA9C: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 828CFAA0: 48003A91  bl 0x828d3530
	ctx.lr = 0x828CFAA4;
	sub_828D3530(ctx, base);
	// 828CFAA4: 48000098  b 0x828cfb3c
	pc = 0x828CFB3C; continue 'dispatch;
	// 828CFAA8: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFAAC: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CFAB0: 409A0008  bne cr6, 0x828cfab8
	if !ctx.cr[6].eq {
	pc = 0x828CFAB8; continue 'dispatch;
	}
	// 828CFAB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CFAB8: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CFABC: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CFAC0: 7F09A040  cmplw cr6, r9, r20
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[20].u32, &mut ctx.xer);
	// 828CFAC4: 409A0078  bne cr6, 0x828cfb3c
	if !ctx.cr[6].eq {
	pc = 0x828CFB3C; continue 'dispatch;
	}
	// 828CFAC8: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CFACC: 409A0008  bne cr6, 0x828cfad4
	if !ctx.cr[6].eq {
	pc = 0x828CFAD4; continue 'dispatch;
	}
	// 828CFAD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CFAD4: 896B000F  lbz r11, 0xf(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(15 as u32) ) } as u64;
	// 828CFAD8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CFADC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CFAE0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CFAE4: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828CFAE8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFAEC: 83E90028  lwz r31, 0x28(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CFAF0: 419A001C  beq cr6, 0x828cfb0c
	if ctx.cr[6].eq {
	pc = 0x828CFB0C; continue 'dispatch;
	}
	// 828CFAF4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828CFAF8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CFAFC: 4B95D3D5  bl 0x8222ced0
	ctx.lr = 0x828CFB00;
	sub_8222CED0(ctx, base);
	// 828CFB00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CFB04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CFB08: 48000018  b 0x828cfb20
	pc = 0x828CFB20; continue 'dispatch;
	// 828CFB0C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 828CFB10: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CFB14: 4B95D3BD  bl 0x8222ced0
	ctx.lr = 0x828CFB18;
	sub_8222CED0(ctx, base);
	// 828CFB18: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CFB1C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828CFB20: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CFB24: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828CFB28: 4B95D3A9  bl 0x8222ced0
	ctx.lr = 0x828CFB2C;
	sub_8222CED0(ctx, base);
	// 828CFB2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CFB30: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828CFB34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CFB38: 4BBAAF39  bl 0x8247aa70
	ctx.lr = 0x828CFB3C;
	sub_8247AA70(ctx, base);
	// 828CFB3C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFB40: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CFB44: 409A0008  bne cr6, 0x828cfb4c
	if !ctx.cr[6].eq {
	pc = 0x828CFB4C; continue 'dispatch;
	}
	// 828CFB48: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CFB4C: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CFB50: 4BFFFBD4  b 0x828cf724
	pc = 0x828CF724; continue 'dispatch;
	// 828CFB54: 2F100000  cmpwi cr6, r16, 0
	ctx.cr[6].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 828CFB58: 4099017C  ble cr6, 0x828cfcd4
	if !ctx.cr[6].gt {
	pc = 0x828CFCD4; continue 'dispatch;
	}
	// 828CFB5C: 564B063E  clrlwi r11, r18, 0x18
	ctx.r[11].u64 = ctx.r[18].u32 as u64 & 0x000000FFu64;
	// 828CFB60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CFB64: 409A0170  bne cr6, 0x828cfcd4
	if !ctx.cr[6].eq {
	pc = 0x828CFCD4; continue 'dispatch;
	}
	// 828CFB68: 81730004  lwz r11, 4(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFB6C: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828CFB70: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828CFB74: 55497FFE  rlwinm r9, r10, 0xf, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0001FFFFu64;
	// 828CFB78: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CFB7C: 419A00F4  beq cr6, 0x828cfc70
	if ctx.cr[6].eq {
	pc = 0x828CFC70; continue 'dispatch;
	}
	// 828CFB80: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CFB84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CFB88: 419A0024  beq cr6, 0x828cfbac
	if ctx.cr[6].eq {
	pc = 0x828CFBAC; continue 'dispatch;
	}
	// 828CFB8C: 892A0051  lbz r9, 0x51(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(81 as u32) ) } as u64;
	// 828CFB90: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CFB94: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828CFB98: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828CFB9C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFBA0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CFBA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CFBA8: 480000CC  b 0x828cfc74
	pc = 0x828CFC74; continue 'dispatch;
	// 828CFBAC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CFBB0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CFBB4: 92210068  stw r17, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[17].u32 ) };
	// 828CFBB8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828CFBBC: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828CFBC0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CFBC4: 40810054  ble 0x828cfc18
	if !ctx.cr[0].gt {
	pc = 0x828CFC18; continue 'dispatch;
	}
	// 828CFBC8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828CFBCC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828CFBD0: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828CFBD4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CFBD8: 2F070051  cmpwi cr6, r7, 0x51
	ctx.cr[6].compare_i32(ctx.r[7].s32, 81, &mut ctx.xer);
	// 828CFBDC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CFBE0: 41980008  blt cr6, 0x828cfbe8
	if ctx.cr[6].lt {
	pc = 0x828CFBE8; continue 'dispatch;
	}
	// 828CFBE4: 7E278B78  mr r7, r17
	ctx.r[7].u64 = ctx.r[17].u64;
	// 828CFBE8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828CFBEC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828CFBF0: 419A0014  beq cr6, 0x828cfc04
	if ctx.cr[6].eq {
	pc = 0x828CFC04; continue 'dispatch;
	}
	// 828CFBF4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CFBF8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CFBFC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CFC00: 4800000C  b 0x828cfc0c
	pc = 0x828CFC0C; continue 'dispatch;
	// 828CFC04: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828CFC08: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828CFC0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CFC10: 4199FFB8  bgt cr6, 0x828cfbc8
	if ctx.cr[6].gt {
	pc = 0x828CFBC8; continue 'dispatch;
	}
	// 828CFC14: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828CFC18: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828CFC1C: 419A0040  beq cr6, 0x828cfc5c
	if ctx.cr[6].eq {
	pc = 0x828CFC5C; continue 'dispatch;
	}
	// 828CFC20: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CFC24: 2F0B0051  cmpwi cr6, r11, 0x51
	ctx.cr[6].compare_i32(ctx.r[11].s32, 81, &mut ctx.xer);
	// 828CFC28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CFC2C: 41990008  bgt cr6, 0x828cfc34
	if ctx.cr[6].gt {
	pc = 0x828CFC34; continue 'dispatch;
	}
	// 828CFC30: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 828CFC34: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CFC38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CFC3C: 409A0020  bne cr6, 0x828cfc5c
	if !ctx.cr[6].eq {
	pc = 0x828CFC5C; continue 'dispatch;
	}
	// 828CFC40: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828CFC44: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 828CFC48: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828CFC4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFC50: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CFC54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CFC58: 4800001C  b 0x828cfc74
	pc = 0x828CFC74; continue 'dispatch;
	// 828CFC5C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828CFC60: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFC64: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CFC68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CFC6C: 48000008  b 0x828cfc74
	pc = 0x828CFC74; continue 'dispatch;
	// 828CFC70: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 828CFC74: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CFC78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CFC7C: 419A0018  beq cr6, 0x828cfc94
	if ctx.cr[6].eq {
	pc = 0x828CFC94; continue 'dispatch;
	}
	// 828CFC80: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CFC84: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828CFC88: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828CFC8C: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 828CFC90: 4BB5E8E9  bl 0x8242e578
	ctx.lr = 0x828CFC94;
	sub_8242E578(ctx, base);
	// 828CFC94: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828CFC98: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828CFC9C: 388B3648  addi r4, r11, 0x3648
	ctx.r[4].s64 = ctx.r[11].s64 + 13896;
	// 828CFCA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CFCA4: 4B95D22D  bl 0x8222ced0
	ctx.lr = 0x828CFCA8;
	sub_8222CED0(ctx, base);
	// 828CFCA8: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 828CFCAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CFCB0: 4BA7F011  bl 0x8234ecc0
	ctx.lr = 0x828CFCB4;
	sub_8234ECC0(ctx, base);
	// 828CFCB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CFCB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CFCBC: 4B91CB3D  bl 0x821ec7f8
	ctx.lr = 0x828CFCC0;
	sub_821EC7F8(ctx, base);
	// 828CFCC0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CFCC4: 4B945115  bl 0x82214dd8
	ctx.lr = 0x828CFCC8;
	sub_82214DD8(ctx, base);
	// 828CFCC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CFCCC: 7E308B78  mr r16, r17
	ctx.r[16].u64 = ctx.r[17].u64;
	// 828CFCD0: 4B945109  bl 0x82214dd8
	ctx.lr = 0x828CFCD4;
	sub_82214DD8(ctx, base);
	// 828CFCD4: 81730004  lwz r11, 4(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFCD8: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828CFCDC: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CFCE0: 55493FFE  rlwinm r9, r10, 7, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x01FFFFFFu64;
	// 828CFCE4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CFCE8: 419A00F4  beq cr6, 0x828cfddc
	if ctx.cr[6].eq {
	pc = 0x828CFDDC; continue 'dispatch;
	}
	// 828CFCEC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CFCF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CFCF4: 419A0024  beq cr6, 0x828cfd18
	if ctx.cr[6].eq {
	pc = 0x828CFD18; continue 'dispatch;
	}
	// 828CFCF8: 892A0039  lbz r9, 0x39(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(57 as u32) ) } as u64;
	// 828CFCFC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CFD00: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828CFD04: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828CFD08: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFD0C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CFD10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CFD14: 480000CC  b 0x828cfde0
	pc = 0x828CFDE0; continue 'dispatch;
	// 828CFD18: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CFD1C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CFD20: 92210068  stw r17, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[17].u32 ) };
	// 828CFD24: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828CFD28: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828CFD2C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CFD30: 40810054  ble 0x828cfd84
	if !ctx.cr[0].gt {
	pc = 0x828CFD84; continue 'dispatch;
	}
	// 828CFD34: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828CFD38: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828CFD3C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828CFD40: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CFD44: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 828CFD48: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CFD4C: 41980008  blt cr6, 0x828cfd54
	if ctx.cr[6].lt {
	pc = 0x828CFD54; continue 'dispatch;
	}
	// 828CFD50: 7E278B78  mr r7, r17
	ctx.r[7].u64 = ctx.r[17].u64;
	// 828CFD54: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828CFD58: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828CFD5C: 419A0014  beq cr6, 0x828cfd70
	if ctx.cr[6].eq {
	pc = 0x828CFD70; continue 'dispatch;
	}
	// 828CFD60: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CFD64: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CFD68: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CFD6C: 4800000C  b 0x828cfd78
	pc = 0x828CFD78; continue 'dispatch;
	// 828CFD70: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828CFD74: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828CFD78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CFD7C: 4199FFB8  bgt cr6, 0x828cfd34
	if ctx.cr[6].gt {
	pc = 0x828CFD34; continue 'dispatch;
	}
	// 828CFD80: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828CFD84: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828CFD88: 419A0040  beq cr6, 0x828cfdc8
	if ctx.cr[6].eq {
	pc = 0x828CFDC8; continue 'dispatch;
	}
	// 828CFD8C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CFD90: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 828CFD94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CFD98: 41990008  bgt cr6, 0x828cfda0
	if ctx.cr[6].gt {
	pc = 0x828CFDA0; continue 'dispatch;
	}
	// 828CFD9C: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 828CFDA0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CFDA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CFDA8: 409A0020  bne cr6, 0x828cfdc8
	if !ctx.cr[6].eq {
	pc = 0x828CFDC8; continue 'dispatch;
	}
	// 828CFDAC: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828CFDB0: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 828CFDB4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828CFDB8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFDBC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CFDC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CFDC4: 4800001C  b 0x828cfde0
	pc = 0x828CFDE0; continue 'dispatch;
	// 828CFDC8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828CFDCC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFDD0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CFDD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CFDD8: 48000008  b 0x828cfde0
	pc = 0x828CFDE0; continue 'dispatch;
	// 828CFDDC: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 828CFDE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CFDE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CFDE8: 419A000C  beq cr6, 0x828cfdf4
	if ctx.cr[6].eq {
	pc = 0x828CFDF4; continue 'dispatch;
	}
	// 828CFDEC: FC20F050  fneg f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = ctx.f[30].u64 ^ 0x8000_0000_0000_0000u64;
	// 828CFDF0: 4BC06DF1  bl 0x824d6be0
	ctx.lr = 0x828CFDF4;
	sub_824D6BE0(ctx, base);
	// 828CFDF4: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 828CFDF8: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 828CFDFC: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 828CFE00: 483DDF25  bl 0x82cadd24
	ctx.lr = 0x828CFE04;
	sub_82CADCEC(ctx, base);
	// 828CFE04: 483D9624  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CFE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CFE08 size=628
    let mut pc: u32 = 0x828CFE08;
    'dispatch: loop {
        match pc {
            0x828CFE08 => {
    //   block [0x828CFE08..0x828D007C)
	// 828CFE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CFE0C: 483D95F9  bl 0x82ca9404
	ctx.lr = 0x828CFE10;
	sub_82CA93D0(ctx, base);
	// 828CFE10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CFE14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CFE18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CFE1C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828CFE20: 3B7E0018  addi r27, r30, 0x18
	ctx.r[27].s64 = ctx.r[30].s64 + 24;
	// 828CFE24: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 828CFE28: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CFE2C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFE30: 7F1BD840  cmplw cr6, r27, r27
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828CFE34: 419A0008  beq cr6, 0x828cfe3c
	if ctx.cr[6].eq {
	pc = 0x828CFE3C; continue 'dispatch;
	}
	// 828CFE38: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CFE3C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CFE40: 419A0234  beq cr6, 0x828d0074
	if ctx.cr[6].eq {
	pc = 0x828D0074; continue 'dispatch;
	}
	// 828CFE44: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFE48: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CFE4C: 409A0008  bne cr6, 0x828cfe54
	if !ctx.cr[6].eq {
	pc = 0x828CFE54; continue 'dispatch;
	}
	// 828CFE50: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CFE54: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CFE58: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CFE5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CFE60: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828CFE64: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828CFE68: 419A0020  beq cr6, 0x828cfe88
	if ctx.cr[6].eq {
	pc = 0x828CFE88; continue 'dispatch;
	}
	// 828CFE6C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828CFE70: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CFE74: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828CFE78: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828CFE7C: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CFE80: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CFE84: 4082FFE8  bne 0x828cfe6c
	if !ctx.cr[0].eq {
	pc = 0x828CFE6C; continue 'dispatch;
	}
	// 828CFE88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CFE8C: 419A0038  beq cr6, 0x828cfec4
	if ctx.cr[6].eq {
	pc = 0x828CFEC4; continue 'dispatch;
	}
	// 828CFE90: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CFE94: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CFE98: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828CFE9C: 409A0018  bne cr6, 0x828cfeb4
	if !ctx.cr[6].eq {
	pc = 0x828CFEB4; continue 'dispatch;
	}
	// 828CFEA0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFEA4: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828CFEA8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828CFEAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CFEB0: 419A0008  beq cr6, 0x828cfeb8
	if ctx.cr[6].eq {
	pc = 0x828CFEB8; continue 'dispatch;
	}
	// 828CFEB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CFEB8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CFEBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CFEC0: 409A0024  bne cr6, 0x828cfee4
	if !ctx.cr[6].eq {
	pc = 0x828CFEE4; continue 'dispatch;
	}
	// 828CFEC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CFEC8: 4B8E7C51  bl 0x821b7b18
	ctx.lr = 0x828CFECC;
	sub_821B7B18(ctx, base);
	// 828CFECC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFED0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CFED4: 409A0008  bne cr6, 0x828cfedc
	if !ctx.cr[6].eq {
	pc = 0x828CFEDC; continue 'dispatch;
	}
	// 828CFED8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CFEDC: 839C0000  lwz r28, 0(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CFEE0: 4BFFFF4C  b 0x828cfe2c
	pc = 0x828CFE2C; continue 'dispatch;
	// 828CFEE4: 7FAB0E70  srawi r11, r29, 1
	ctx.xer.ca = (ctx.r[29].s32 < 0) && ((ctx.r[29].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[29].s32 >> 1) as i64;
	// 828CFEE8: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 828CFEEC: 7D2B0194  addze r9, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[9].s64 = tmp.s64;
	// 828CFEF0: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 828CFEF4: 41990128  bgt cr6, 0x828d001c
	if ctx.cr[6].gt {
	pc = 0x828D001C; continue 'dispatch;
	}
	// 828CFEF8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFEFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828CFF00: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CFF04: 55493FFE  rlwinm r9, r10, 7, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x01FFFFFFu64;
	// 828CFF08: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CFF0C: 419A00F8  beq cr6, 0x828d0004
	if ctx.cr[6].eq {
	pc = 0x828D0004; continue 'dispatch;
	}
	// 828CFF10: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CFF14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CFF18: 419A0024  beq cr6, 0x828cff3c
	if ctx.cr[6].eq {
	pc = 0x828CFF3C; continue 'dispatch;
	}
	// 828CFF1C: 892A0039  lbz r9, 0x39(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(57 as u32) ) } as u64;
	// 828CFF20: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CFF24: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828CFF28: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828CFF2C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFF30: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CFF34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CFF38: 480000D0  b 0x828d0008
	pc = 0x828D0008; continue 'dispatch;
	// 828CFF3C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CFF40: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828CFF44: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CFF48: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828CFF4C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828CFF50: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CFF54: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CFF58: 40810054  ble 0x828cffac
	if !ctx.cr[0].gt {
	pc = 0x828CFFAC; continue 'dispatch;
	}
	// 828CFF5C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828CFF60: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828CFF64: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828CFF68: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CFF6C: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 828CFF70: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828CFF74: 41980008  blt cr6, 0x828cff7c
	if ctx.cr[6].lt {
	pc = 0x828CFF7C; continue 'dispatch;
	}
	// 828CFF78: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828CFF7C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828CFF80: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828CFF84: 419A0014  beq cr6, 0x828cff98
	if ctx.cr[6].eq {
	pc = 0x828CFF98; continue 'dispatch;
	}
	// 828CFF88: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CFF8C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CFF90: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CFF94: 4800000C  b 0x828cffa0
	pc = 0x828CFFA0; continue 'dispatch;
	// 828CFF98: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828CFF9C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828CFFA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CFFA4: 4199FFB8  bgt cr6, 0x828cff5c
	if ctx.cr[6].gt {
	pc = 0x828CFF5C; continue 'dispatch;
	}
	// 828CFFA8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CFFAC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828CFFB0: 419A0040  beq cr6, 0x828cfff0
	if ctx.cr[6].eq {
	pc = 0x828CFFF0; continue 'dispatch;
	}
	// 828CFFB4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CFFB8: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 828CFFBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CFFC0: 41990008  bgt cr6, 0x828cffc8
	if ctx.cr[6].gt {
	pc = 0x828CFFC8; continue 'dispatch;
	}
	// 828CFFC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CFFC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CFFCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CFFD0: 409A0020  bne cr6, 0x828cfff0
	if !ctx.cr[6].eq {
	pc = 0x828CFFF0; continue 'dispatch;
	}
	// 828CFFD4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CFFD8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828CFFDC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CFFE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFFE4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CFFE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CFFEC: 4800001C  b 0x828d0008
	pc = 0x828D0008; continue 'dispatch;
	// 828CFFF0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828CFFF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFFF8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CFFFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0000: 48000008  b 0x828d0008
	pc = 0x828D0008; continue 'dispatch;
	// 828D0004: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D0008: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D000C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0010: 419A000C  beq cr6, 0x828d001c
	if ctx.cr[6].eq {
	pc = 0x828D001C; continue 'dispatch;
	}
	// 828D0014: 38800026  li r4, 0x26
	ctx.r[4].s64 = 38;
	// 828D0018: 4BC08F71  bl 0x824d8f88
	ctx.lr = 0x828D001C;
	sub_824D8F88(ctx, base);
	// 828D001C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0020: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D0024: 409A0008  bne cr6, 0x828d002c
	if !ctx.cr[6].eq {
	pc = 0x828D002C; continue 'dispatch;
	}
	// 828D0028: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D002C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0030: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D0034: 419A0038  beq cr6, 0x828d006c
	if ctx.cr[6].eq {
	pc = 0x828D006C; continue 'dispatch;
	}
	// 828D0038: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D003C: 387C0008  addi r3, r28, 8
	ctx.r[3].s64 = ctx.r[28].s64 + 8;
	// 828D0040: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0044: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D0048: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D004C: 811C0004  lwz r8, 4(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0050: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 828D0054: 4B8E7AC5  bl 0x821b7b18
	ctx.lr = 0x828D0058;
	sub_821B7B18(ctx, base);
	// 828D0058: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D005C: 4B94BCDD  bl 0x8221bd38
	ctx.lr = 0x828D0060;
	sub_8221BD38(ctx, base);
	// 828D0060: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D0064: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 828D0068: 90FB0008  stw r7, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 828D006C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D0070: 4B8E7AA9  bl 0x821b7b18
	ctx.lr = 0x828D0074;
	sub_821B7B18(ctx, base);
	// 828D0074: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828D0078: 483D93DC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D0080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D0080 size=1200
    let mut pc: u32 = 0x828D0080;
    'dispatch: loop {
        match pc {
            0x828D0080 => {
    //   block [0x828D0080..0x828D0530)
	// 828D0080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D0084: 483D937D  bl 0x82ca9400
	ctx.lr = 0x828D0088;
	sub_82CA93D0(ctx, base);
	// 828D0088: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D008C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D0090: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828D0094: 48001455  bl 0x828d14e8
	ctx.lr = 0x828D0098;
	sub_828D14E8(ctx, base);
	// 828D0098: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828D009C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D00A0: 409A0488  bne cr6, 0x828d0528
	if !ctx.cr[6].eq {
	pc = 0x828D0528; continue 'dispatch;
	}
	// 828D00A4: 38600044  li r3, 0x44
	ctx.r[3].s64 = 68;
	// 828D00A8: 4B94F1B1  bl 0x8221f258
	ctx.lr = 0x828D00AC;
	sub_8221F258(ctx, base);
	// 828D00AC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D00B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D00B4: 419A0014  beq cr6, 0x828d00c8
	if ctx.cr[6].eq {
	pc = 0x828D00C8; continue 'dispatch;
	}
	// 828D00B8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828D00BC: 4BFFD235  bl 0x828cd2f0
	ctx.lr = 0x828D00C0;
	sub_828CD2F0(ctx, base);
	// 828D00C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D00C4: 48000008  b 0x828d00cc
	pc = 0x828D00CC; continue 'dispatch;
	// 828D00C8: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 828D00CC: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 828D00D0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D00D4: 419A0014  beq cr6, 0x828d00e8
	if ctx.cr[6].eq {
	pc = 0x828D00E8; continue 'dispatch;
	}
	// 828D00D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D00DC: 4BB6C055  bl 0x8243c130
	ctx.lr = 0x828D00E0;
	sub_8243C130(ctx, base);
	// 828D00E0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D00E4: 4800000C  b 0x828d00f0
	pc = 0x828D00F0; continue 'dispatch;
	// 828D00E8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828D00EC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 828D00F0: 815C001C  lwz r10, 0x1c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D00F4: 397C0018  addi r11, r28, 0x18
	ctx.r[11].s64 = ctx.r[28].s64 + 24;
	// 828D00F8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D00FC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828D0100: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D0104: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D0108: 4BD4D9E1  bl 0x8261dae8
	ctx.lr = 0x828D010C;
	sub_8261DAE8(ctx, base);
	// 828D010C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D0110: 4B8E7A09  bl 0x821b7b18
	ctx.lr = 0x828D0114;
	sub_821B7B18(ctx, base);
	// 828D0114: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 828D0118: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D011C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D0120: 387C000C  addi r3, r28, 0xc
	ctx.r[3].s64 = ctx.r[28].s64 + 12;
	// 828D0124: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D0128: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828D012C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D0130: 80E90058  lwz r7, 0x58(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D0134: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0138: 80A60008  lwz r5, 8(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D013C: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0140: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828D0144: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0148: 3B6B00AC  addi r27, r11, 0xac
	ctx.r[27].s64 = ctx.r[11].s64 + 172;
	// 828D014C: 4BA50FAD  bl 0x823210f8
	ctx.lr = 0x828D0150;
	sub_823210F8(ctx, base);
	// 828D0150: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D0154: 4B99504D  bl 0x822651a0
	ctx.lr = 0x828D0158;
	sub_822651A0(ctx, base);
	// 828D0158: 893E000E  lbz r9, 0xe(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(14 as u32) ) } as u64;
	// 828D015C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D0160: 419A002C  beq cr6, 0x828d018c
	if ctx.cr[6].eq {
	pc = 0x828D018C; continue 'dispatch;
	}
	// 828D0164: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D0168: 3880001B  li r4, 0x1b
	ctx.r[4].s64 = 27;
	// 828D016C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D0170: 806B00A8  lwz r3, 0xa8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 828D0174: 4BB806FD  bl 0x82450870
	ctx.lr = 0x828D0178;
	sub_82450870(ctx, base);
	// 828D0178: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828D017C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D0180: 409A000C  bne cr6, 0x828d018c
	if !ctx.cr[6].eq {
	pc = 0x828D018C; continue 'dispatch;
	}
	// 828D0184: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0188: 997C0060  stb r11, 0x60(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 828D018C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0190: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 828D0194: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 828D0198: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D019C: 55497FFE  rlwinm r9, r10, 0xf, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0001FFFFu64;
	// 828D01A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D01A4: 419A00F4  beq cr6, 0x828d0298
	if ctx.cr[6].eq {
	pc = 0x828D0298; continue 'dispatch;
	}
	// 828D01A8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D01AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D01B0: 419A0024  beq cr6, 0x828d01d4
	if ctx.cr[6].eq {
	pc = 0x828D01D4; continue 'dispatch;
	}
	// 828D01B4: 894A0051  lbz r10, 0x51(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(81 as u32) ) } as u64;
	// 828D01B8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D01BC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D01C0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D01C4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D01C8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D01CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D01D0: 480000CC  b 0x828d029c
	pc = 0x828D029C; continue 'dispatch;
	// 828D01D4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D01D8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D01DC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828D01E0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D01E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D01E8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D01EC: 40810054  ble 0x828d0240
	if !ctx.cr[0].gt {
	pc = 0x828D0240; continue 'dispatch;
	}
	// 828D01F0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D01F4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D01F8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D01FC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0200: 2F070051  cmpwi cr6, r7, 0x51
	ctx.cr[6].compare_i32(ctx.r[7].s32, 81, &mut ctx.xer);
	// 828D0204: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D0208: 41980008  blt cr6, 0x828d0210
	if ctx.cr[6].lt {
	pc = 0x828D0210; continue 'dispatch;
	}
	// 828D020C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828D0210: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D0214: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D0218: 419A0014  beq cr6, 0x828d022c
	if ctx.cr[6].eq {
	pc = 0x828D022C; continue 'dispatch;
	}
	// 828D021C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D0220: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D0224: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D0228: 4800000C  b 0x828d0234
	pc = 0x828D0234; continue 'dispatch;
	// 828D022C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D0230: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D0234: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0238: 4199FFB8  bgt cr6, 0x828d01f0
	if ctx.cr[6].gt {
	pc = 0x828D01F0; continue 'dispatch;
	}
	// 828D023C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D0240: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D0244: 419A0040  beq cr6, 0x828d0284
	if ctx.cr[6].eq {
	pc = 0x828D0284; continue 'dispatch;
	}
	// 828D0248: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D024C: 2F0B0051  cmpwi cr6, r11, 0x51
	ctx.cr[6].compare_i32(ctx.r[11].s32, 81, &mut ctx.xer);
	// 828D0250: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0254: 41990008  bgt cr6, 0x828d025c
	if ctx.cr[6].gt {
	pc = 0x828D025C; continue 'dispatch;
	}
	// 828D0258: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828D025C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D0260: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0264: 409A0020  bne cr6, 0x828d0284
	if !ctx.cr[6].eq {
	pc = 0x828D0284; continue 'dispatch;
	}
	// 828D0268: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D026C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D0270: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D0274: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0278: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D027C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0280: 4800001C  b 0x828d029c
	pc = 0x828D029C; continue 'dispatch;
	// 828D0284: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D0288: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D028C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D0290: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0294: 48000008  b 0x828d029c
	pc = 0x828D029C; continue 'dispatch;
	// 828D0298: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828D029C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D02A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D02A4: 419A0130  beq cr6, 0x828d03d4
	if ctx.cr[6].eq {
	pc = 0x828D03D4; continue 'dispatch;
	}
	// 828D02A8: 815A002C  lwz r10, 0x2c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D02AC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828D02B0: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828D02B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D02B8: 419A00E4  beq cr6, 0x828d039c
	if ctx.cr[6].eq {
	pc = 0x828D039C; continue 'dispatch;
	}
	// 828D02BC: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D02C0: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D02C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D02C8: 419A001C  beq cr6, 0x828d02e4
	if ctx.cr[6].eq {
	pc = 0x828D02E4; continue 'dispatch;
	}
	// 828D02CC: 896B0043  lbz r11, 0x43(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(67 as u32) ) } as u64;
	// 828D02D0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828D02D4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828D02D8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D02DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D02E0: 480000C0  b 0x828d03a0
	pc = 0x828D03A0; continue 'dispatch;
	// 828D02E4: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D02E8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828D02EC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D02F0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D02F4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D02F8: 40810054  ble 0x828d034c
	if !ctx.cr[0].gt {
	pc = 0x828D034C; continue 'dispatch;
	}
	// 828D02FC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D0300: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D0304: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D0308: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D030C: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 828D0310: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D0314: 41980008  blt cr6, 0x828d031c
	if ctx.cr[6].lt {
	pc = 0x828D031C; continue 'dispatch;
	}
	// 828D0318: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828D031C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D0320: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D0324: 419A0014  beq cr6, 0x828d0338
	if ctx.cr[6].eq {
	pc = 0x828D0338; continue 'dispatch;
	}
	// 828D0328: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D032C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D0330: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D0334: 4800000C  b 0x828d0340
	pc = 0x828D0340; continue 'dispatch;
	// 828D0338: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D033C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D0340: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0344: 4199FFB8  bgt cr6, 0x828d02fc
	if ctx.cr[6].gt {
	pc = 0x828D02FC; continue 'dispatch;
	}
	// 828D0348: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D034C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D0350: 419A003C  beq cr6, 0x828d038c
	if ctx.cr[6].eq {
	pc = 0x828D038C; continue 'dispatch;
	}
	// 828D0354: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0358: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 828D035C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0360: 41990008  bgt cr6, 0x828d0368
	if ctx.cr[6].gt {
	pc = 0x828D0368; continue 'dispatch;
	}
	// 828D0364: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828D0368: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D036C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0370: 409A001C  bne cr6, 0x828d038c
	if !ctx.cr[6].eq {
	pc = 0x828D038C; continue 'dispatch;
	}
	// 828D0374: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D0378: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D037C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D0380: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D0384: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0388: 48000018  b 0x828d03a0
	pc = 0x828D03A0; continue 'dispatch;
	// 828D038C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D0390: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D0394: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0398: 48000008  b 0x828d03a0
	pc = 0x828D03A0; continue 'dispatch;
	// 828D039C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 828D03A0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D03A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D03A8: 419A002C  beq cr6, 0x828d03d4
	if ctx.cr[6].eq {
	pc = 0x828D03D4; continue 'dispatch;
	}
	// 828D03AC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D03B0: 4BF5B699  bl 0x8282ba48
	ctx.lr = 0x828D03B4;
	sub_8282BA48(ctx, base);
	// 828D03B4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D03B8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828D03BC: 937E0030  stw r27, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[27].u32 ) };
	// 828D03C0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828D03C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828D03C8: 7C9B00D0  neg r4, r27
	ctx.r[4].s64 = -ctx.r[27].s64;
	// 828D03CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D03D0: 4BB5E1A9  bl 0x8242e578
	ctx.lr = 0x828D03D4;
	sub_8242E578(ctx, base);
	// 828D03D4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D03D8: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 828D03DC: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828D03E0: 55493FFE  rlwinm r9, r10, 7, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x01FFFFFFu64;
	// 828D03E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D03E8: 419A00F4  beq cr6, 0x828d04dc
	if ctx.cr[6].eq {
	pc = 0x828D04DC; continue 'dispatch;
	}
	// 828D03EC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D03F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D03F4: 419A0024  beq cr6, 0x828d0418
	if ctx.cr[6].eq {
	pc = 0x828D0418; continue 'dispatch;
	}
	// 828D03F8: 892A0039  lbz r9, 0x39(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(57 as u32) ) } as u64;
	// 828D03FC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D0400: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828D0404: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828D0408: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D040C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D0410: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0414: 480000CC  b 0x828d04e0
	pc = 0x828D04E0; continue 'dispatch;
	// 828D0418: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D041C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D0420: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828D0424: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D0428: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D042C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0430: 40810054  ble 0x828d0484
	if !ctx.cr[0].gt {
	pc = 0x828D0484; continue 'dispatch;
	}
	// 828D0434: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D0438: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D043C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D0440: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0444: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 828D0448: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D044C: 41980008  blt cr6, 0x828d0454
	if ctx.cr[6].lt {
	pc = 0x828D0454; continue 'dispatch;
	}
	// 828D0450: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828D0454: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D0458: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D045C: 419A0014  beq cr6, 0x828d0470
	if ctx.cr[6].eq {
	pc = 0x828D0470; continue 'dispatch;
	}
	// 828D0460: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D0464: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D0468: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D046C: 4800000C  b 0x828d0478
	pc = 0x828D0478; continue 'dispatch;
	// 828D0470: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D0474: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D0478: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D047C: 4199FFB8  bgt cr6, 0x828d0434
	if ctx.cr[6].gt {
	pc = 0x828D0434; continue 'dispatch;
	}
	// 828D0480: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D0484: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D0488: 419A0040  beq cr6, 0x828d04c8
	if ctx.cr[6].eq {
	pc = 0x828D04C8; continue 'dispatch;
	}
	// 828D048C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0490: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 828D0494: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0498: 41990008  bgt cr6, 0x828d04a0
	if ctx.cr[6].gt {
	pc = 0x828D04A0; continue 'dispatch;
	}
	// 828D049C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828D04A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D04A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D04A8: 409A0020  bne cr6, 0x828d04c8
	if !ctx.cr[6].eq {
	pc = 0x828D04C8; continue 'dispatch;
	}
	// 828D04AC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D04B0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D04B4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D04B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D04BC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D04C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D04C4: 4800001C  b 0x828d04e0
	pc = 0x828D04E0; continue 'dispatch;
	// 828D04C8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D04CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D04D0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D04D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D04D8: 48000008  b 0x828d04e0
	pc = 0x828D04E0; continue 'dispatch;
	// 828D04DC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828D04E0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D04E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D04E8: 419A0024  beq cr6, 0x828d050c
	if ctx.cr[6].eq {
	pc = 0x828D050C; continue 'dispatch;
	}
	// 828D04EC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D04F0: 38800069  li r4, 0x69
	ctx.r[4].s64 = 105;
	// 828D04F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D04F8: 4BA08911  bl 0x822d8e08
	ctx.lr = 0x828D04FC;
	sub_822D8E08(ctx, base);
	// 828D04FC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828D0500: 38800013  li r4, 0x13
	ctx.r[4].s64 = 19;
	// 828D0504: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D0508: 4BA08901  bl 0x822d8e08
	ctx.lr = 0x828D050C;
	sub_822D8E08(ctx, base);
	// 828D050C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828D0510: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D0514: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828D0518: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D051C: 48000375  bl 0x828d0890
	ctx.lr = 0x828D0520;
	sub_828D0890(ctx, base);
	// 828D0520: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D0524: 48003CF5  bl 0x828d4218
	ctx.lr = 0x828D0528;
	sub_828D4218(ctx, base);
	// 828D0528: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828D052C: 483D8F24  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D0530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D0530 size=44
    let mut pc: u32 = 0x828D0530;
    'dispatch: loop {
        match pc {
            0x828D0530 => {
    //   block [0x828D0530..0x828D055C)
	// 828D0530: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828D0534: 419A0018  beq cr6, 0x828d054c
	if ctx.cr[6].eq {
	pc = 0x828D054C; continue 'dispatch;
	}
	// 828D0538: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D053C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D0540: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0544: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D0548: 409A0008  bne cr6, 0x828d0550
	if !ctx.cr[6].eq {
	pc = 0x828D0550; continue 'dispatch;
	}
	// 828D054C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D0550: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D0554: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0558: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D055C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D055C size=8
    let mut pc: u32 = 0x828D055C;
    'dispatch: loop {
        match pc {
            0x828D055C => {
    //   block [0x828D055C..0x828D0564)
	// 828D055C: 4BFFFB24  b 0x828d0080
	sub_828D0080(ctx, base);
	return;
	// 828D0560: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D0568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D0568 size=808
    let mut pc: u32 = 0x828D0568;
    'dispatch: loop {
        match pc {
            0x828D0568 => {
    //   block [0x828D0568..0x828D0890)
	// 828D0568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D056C: 483D8E99  bl 0x82ca9404
	ctx.lr = 0x828D0570;
	sub_82CA93D0(ctx, base);
	// 828D0570: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D0574: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D0578: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828D057C: 48000F6D  bl 0x828d14e8
	ctx.lr = 0x828D0580;
	sub_828D14E8(ctx, base);
	// 828D0580: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828D0584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0588: 409A0300  bne cr6, 0x828d0888
	if !ctx.cr[6].eq {
	pc = 0x828D0888; continue 'dispatch;
	}
	// 828D058C: 38600044  li r3, 0x44
	ctx.r[3].s64 = 68;
	// 828D0590: 4B94ECC9  bl 0x8221f258
	ctx.lr = 0x828D0594;
	sub_8221F258(ctx, base);
	// 828D0594: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828D0598: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D059C: 419A0014  beq cr6, 0x828d05b0
	if ctx.cr[6].eq {
	pc = 0x828D05B0; continue 'dispatch;
	}
	// 828D05A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D05A4: 4BFFCD4D  bl 0x828cd2f0
	ctx.lr = 0x828D05A8;
	sub_828CD2F0(ctx, base);
	// 828D05A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D05AC: 48000008  b 0x828d05b4
	pc = 0x828D05B4; continue 'dispatch;
	// 828D05B0: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 828D05B4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828D05B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D05BC: 419A0014  beq cr6, 0x828d05d0
	if ctx.cr[6].eq {
	pc = 0x828D05D0; continue 'dispatch;
	}
	// 828D05C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D05C4: 4BB6BB6D  bl 0x8243c130
	ctx.lr = 0x828D05C8;
	sub_8243C130(ctx, base);
	// 828D05C8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D05CC: 4800000C  b 0x828d05d8
	pc = 0x828D05D8; continue 'dispatch;
	// 828D05D0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828D05D4: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 828D05D8: 815C001C  lwz r10, 0x1c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D05DC: 397C0018  addi r11, r28, 0x18
	ctx.r[11].s64 = ctx.r[28].s64 + 24;
	// 828D05E0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D05E4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828D05E8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D05EC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D05F0: 4BD4D4F9  bl 0x8261dae8
	ctx.lr = 0x828D05F4;
	sub_8261DAE8(ctx, base);
	// 828D05F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D05F8: 4B8E7521  bl 0x821b7b18
	ctx.lr = 0x828D05FC;
	sub_821B7B18(ctx, base);
	// 828D05FC: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828D0600: 80FF0014  lwz r7, 0x14(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D0604: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D0608: 387C000C  addi r3, r28, 0xc
	ctx.r[3].s64 = ctx.r[28].s64 + 12;
	// 828D060C: 81696AB8  lwz r11, 0x6ab8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D0610: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 828D0614: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D0618: 80C80058  lwz r6, 0x58(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D061C: 80A60004  lwz r5, 4(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0620: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D0624: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0628: 812A0024  lwz r9, 0x24(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 828D062C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0630: 3B6B00AC  addi r27, r11, 0xac
	ctx.r[27].s64 = ctx.r[11].s64 + 172;
	// 828D0634: 4BA50AC5  bl 0x823210f8
	ctx.lr = 0x828D0638;
	sub_823210F8(ctx, base);
	// 828D0638: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D063C: 4B994B65  bl 0x822651a0
	ctx.lr = 0x828D0640;
	sub_822651A0(ctx, base);
	// 828D0640: 811D002C  lwz r8, 0x2c(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D0644: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D0648: 5507EFFE  rlwinm r7, r8, 0x1d, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x00000007u64;
	// 828D064C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D0650: 419A00E8  beq cr6, 0x828d0738
	if ctx.cr[6].eq {
	pc = 0x828D0738; continue 'dispatch;
	}
	// 828D0654: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D0658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D065C: 419A0020  beq cr6, 0x828d067c
	if ctx.cr[6].eq {
	pc = 0x828D067C; continue 'dispatch;
	}
	// 828D0660: 894B0043  lbz r10, 0x43(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(67 as u32) ) } as u64;
	// 828D0664: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D0668: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D066C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D0670: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0674: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0678: 480000C4  b 0x828d073c
	pc = 0x828D073C; continue 'dispatch;
	// 828D067C: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D0680: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D0684: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828D0688: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D068C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D0690: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0694: 40810054  ble 0x828d06e8
	if !ctx.cr[0].gt {
	pc = 0x828D06E8; continue 'dispatch;
	}
	// 828D0698: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D069C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D06A0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D06A4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D06A8: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 828D06AC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D06B0: 41980008  blt cr6, 0x828d06b8
	if ctx.cr[6].lt {
	pc = 0x828D06B8; continue 'dispatch;
	}
	// 828D06B4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828D06B8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D06BC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D06C0: 419A0014  beq cr6, 0x828d06d4
	if ctx.cr[6].eq {
	pc = 0x828D06D4; continue 'dispatch;
	}
	// 828D06C4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D06C8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D06CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D06D0: 4800000C  b 0x828d06dc
	pc = 0x828D06DC; continue 'dispatch;
	// 828D06D4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D06D8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D06DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D06E0: 4199FFB8  bgt cr6, 0x828d0698
	if ctx.cr[6].gt {
	pc = 0x828D0698; continue 'dispatch;
	}
	// 828D06E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D06E8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D06EC: 419A003C  beq cr6, 0x828d0728
	if ctx.cr[6].eq {
	pc = 0x828D0728; continue 'dispatch;
	}
	// 828D06F0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D06F4: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 828D06F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D06FC: 41990008  bgt cr6, 0x828d0704
	if ctx.cr[6].gt {
	pc = 0x828D0704; continue 'dispatch;
	}
	// 828D0700: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828D0704: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D0708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D070C: 409A001C  bne cr6, 0x828d0728
	if !ctx.cr[6].eq {
	pc = 0x828D0728; continue 'dispatch;
	}
	// 828D0710: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D0714: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D0718: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D071C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0720: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0724: 48000018  b 0x828d073c
	pc = 0x828D073C; continue 'dispatch;
	// 828D0728: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D072C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0730: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0734: 48000008  b 0x828d073c
	pc = 0x828D073C; continue 'dispatch;
	// 828D0738: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828D073C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D0740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0744: 419A000C  beq cr6, 0x828d0750
	if ctx.cr[6].eq {
	pc = 0x828D0750; continue 'dispatch;
	}
	// 828D0748: 4BF5B301  bl 0x8282ba48
	ctx.lr = 0x828D074C;
	sub_8282BA48(ctx, base);
	// 828D074C: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 828D0750: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0754: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D0758: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828D075C: 55493FFE  rlwinm r9, r10, 7, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x01FFFFFFu64;
	// 828D0760: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D0764: 419A00F4  beq cr6, 0x828d0858
	if ctx.cr[6].eq {
	pc = 0x828D0858; continue 'dispatch;
	}
	// 828D0768: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D076C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D0770: 419A0024  beq cr6, 0x828d0794
	if ctx.cr[6].eq {
	pc = 0x828D0794; continue 'dispatch;
	}
	// 828D0774: 892A0039  lbz r9, 0x39(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(57 as u32) ) } as u64;
	// 828D0778: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D077C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828D0780: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828D0784: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0788: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D078C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0790: 480000CC  b 0x828d085c
	pc = 0x828D085C; continue 'dispatch;
	// 828D0794: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D0798: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D079C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828D07A0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D07A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D07A8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D07AC: 40810054  ble 0x828d0800
	if !ctx.cr[0].gt {
	pc = 0x828D0800; continue 'dispatch;
	}
	// 828D07B0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D07B4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D07B8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D07BC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D07C0: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 828D07C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D07C8: 41980008  blt cr6, 0x828d07d0
	if ctx.cr[6].lt {
	pc = 0x828D07D0; continue 'dispatch;
	}
	// 828D07CC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828D07D0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D07D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D07D8: 419A0014  beq cr6, 0x828d07ec
	if ctx.cr[6].eq {
	pc = 0x828D07EC; continue 'dispatch;
	}
	// 828D07DC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D07E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D07E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D07E8: 4800000C  b 0x828d07f4
	pc = 0x828D07F4; continue 'dispatch;
	// 828D07EC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D07F0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D07F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D07F8: 4199FFB8  bgt cr6, 0x828d07b0
	if ctx.cr[6].gt {
	pc = 0x828D07B0; continue 'dispatch;
	}
	// 828D07FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D0800: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D0804: 419A0040  beq cr6, 0x828d0844
	if ctx.cr[6].eq {
	pc = 0x828D0844; continue 'dispatch;
	}
	// 828D0808: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D080C: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 828D0810: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0814: 41990008  bgt cr6, 0x828d081c
	if ctx.cr[6].gt {
	pc = 0x828D081C; continue 'dispatch;
	}
	// 828D0818: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828D081C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D0820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0824: 409A0020  bne cr6, 0x828d0844
	if !ctx.cr[6].eq {
	pc = 0x828D0844; continue 'dispatch;
	}
	// 828D0828: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D082C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D0830: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D0834: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0838: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D083C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0840: 4800001C  b 0x828d085c
	pc = 0x828D085C; continue 'dispatch;
	// 828D0844: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D0848: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D084C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D0850: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0854: 48000008  b 0x828d085c
	pc = 0x828D085C; continue 'dispatch;
	// 828D0858: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828D085C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D0860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0864: 419A0010  beq cr6, 0x828d0874
	if ctx.cr[6].eq {
	pc = 0x828D0874; continue 'dispatch;
	}
	// 828D0868: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D086C: 38800069  li r4, 0x69
	ctx.r[4].s64 = 105;
	// 828D0870: 4BA08599  bl 0x822d8e08
	ctx.lr = 0x828D0874;
	sub_822D8E08(ctx, base);
	// 828D0874: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828D0878: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D087C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D0880: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D0884: 4800000D  bl 0x828d0890
	ctx.lr = 0x828D0888;
	sub_828D0890(ctx, base);
	// 828D0888: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828D088C: 483D8BC8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D0890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D0890 size=744
    let mut pc: u32 = 0x828D0890;
    'dispatch: loop {
        match pc {
            0x828D0890 => {
    //   block [0x828D0890..0x828D0B78)
	// 828D0890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D0894: 483D8B69  bl 0x82ca93fc
	ctx.lr = 0x828D0898;
	sub_82CA93D0(ctx, base);
	// 828D0898: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D089C: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 828D08A0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828D08A4: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 828D08A8: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828D08AC: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 828D08B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D08B4: 419A00F4  beq cr6, 0x828d09a8
	if ctx.cr[6].eq {
	pc = 0x828D09A8; continue 'dispatch;
	}
	// 828D08B8: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D08BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D08C0: 419A0024  beq cr6, 0x828d08e4
	if ctx.cr[6].eq {
	pc = 0x828D08E4; continue 'dispatch;
	}
	// 828D08C4: 894B003F  lbz r10, 0x3f(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(63 as u32) ) } as u64;
	// 828D08C8: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D08CC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D08D0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D08D4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D08D8: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 828D08DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D08E0: 480000CC  b 0x828d09ac
	pc = 0x828D09AC; continue 'dispatch;
	// 828D08E4: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D08E8: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D08EC: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 828D08F0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D08F4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D08F8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D08FC: 40810054  ble 0x828d0950
	if !ctx.cr[0].gt {
	pc = 0x828D0950; continue 'dispatch;
	}
	// 828D0900: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D0904: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D0908: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D090C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0910: 2F07003F  cmpwi cr6, r7, 0x3f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 63, &mut ctx.xer);
	// 828D0914: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D0918: 41980008  blt cr6, 0x828d0920
	if ctx.cr[6].lt {
	pc = 0x828D0920; continue 'dispatch;
	}
	// 828D091C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828D0920: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D0924: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D0928: 419A0014  beq cr6, 0x828d093c
	if ctx.cr[6].eq {
	pc = 0x828D093C; continue 'dispatch;
	}
	// 828D092C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D0930: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D0934: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D0938: 4800000C  b 0x828d0944
	pc = 0x828D0944; continue 'dispatch;
	// 828D093C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D0940: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D0944: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0948: 4199FFB8  bgt cr6, 0x828d0900
	if ctx.cr[6].gt {
	pc = 0x828D0900; continue 'dispatch;
	}
	// 828D094C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D0950: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D0954: 419A0040  beq cr6, 0x828d0994
	if ctx.cr[6].eq {
	pc = 0x828D0994; continue 'dispatch;
	}
	// 828D0958: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D095C: 2F0B003F  cmpwi cr6, r11, 0x3f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 63, &mut ctx.xer);
	// 828D0960: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0964: 41990008  bgt cr6, 0x828d096c
	if ctx.cr[6].gt {
	pc = 0x828D096C; continue 'dispatch;
	}
	// 828D0968: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828D096C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D0970: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0974: 409A0020  bne cr6, 0x828d0994
	if !ctx.cr[6].eq {
	pc = 0x828D0994; continue 'dispatch;
	}
	// 828D0978: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D097C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D0980: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D0984: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0988: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 828D098C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0990: 4800001C  b 0x828d09ac
	pc = 0x828D09AC; continue 'dispatch;
	// 828D0994: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D0998: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D099C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 828D09A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D09A4: 48000008  b 0x828d09ac
	pc = 0x828D09AC; continue 'dispatch;
	// 828D09A8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828D09AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D09B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D09B4: 419A01BC  beq cr6, 0x828d0b70
	if ctx.cr[6].eq {
	pc = 0x828D0B70; continue 'dispatch;
	}
	// 828D09B8: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828D09BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D09C0: 4B9706B1  bl 0x82241070
	ctx.lr = 0x828D09C4;
	sub_82241070(ctx, base);
	// 828D09C4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D09C8: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 828D09CC: 409901A4  ble cr6, 0x828d0b70
	if !ctx.cr[6].gt {
	pc = 0x828D0B70; continue 'dispatch;
	}
	// 828D09D0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828D09D4: 2F1B0001  cmpwi cr6, r27, 1
	ctx.cr[6].compare_i32(ctx.r[27].s32, 1, &mut ctx.xer);
	// 828D09D8: 41980198  blt cr6, 0x828d0b70
	if ctx.cr[6].lt {
	pc = 0x828D0B70; continue 'dispatch;
	}
	// 828D09DC: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 828D09E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D09E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D09E8: 4B970869  bl 0x82241250
	ctx.lr = 0x828D09EC;
	sub_82241250(ctx, base);
	// 828D09EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D09F0: 419A0018  beq cr6, 0x828d0a08
	if ctx.cr[6].eq {
	pc = 0x828D0A08; continue 'dispatch;
	}
	// 828D09F4: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D09F8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D09FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0A00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D0A04: 409A0008  bne cr6, 0x828d0a0c
	if !ctx.cr[6].eq {
	pc = 0x828D0A0C; continue 'dispatch;
	}
	// 828D0A08: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828D0A0C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D0A10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0A14: 419A0150  beq cr6, 0x828d0b64
	if ctx.cr[6].eq {
	pc = 0x828D0B64; continue 'dispatch;
	}
	// 828D0A18: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D0A1C: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 828D0A20: 556AA7FE  rlwinm r10, r11, 0x14, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 828D0A24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D0A28: 419A00F0  beq cr6, 0x828d0b18
	if ctx.cr[6].eq {
	pc = 0x828D0B18; continue 'dispatch;
	}
	// 828D0A2C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D0A30: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D0A34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0A38: 419A0020  beq cr6, 0x828d0a58
	if ctx.cr[6].eq {
	pc = 0x828D0A58; continue 'dispatch;
	}
	// 828D0A3C: 896B004C  lbz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D0A40: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828D0A44: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828D0A48: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0A4C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828D0A50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0A54: 480000C8  b 0x828d0b1c
	pc = 0x828D0B1C; continue 'dispatch;
	// 828D0A58: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D0A5C: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 828D0A60: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D0A64: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D0A68: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0A6C: 40810054  ble 0x828d0ac0
	if !ctx.cr[0].gt {
	pc = 0x828D0AC0; continue 'dispatch;
	}
	// 828D0A70: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D0A74: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D0A78: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D0A7C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0A80: 2F07004C  cmpwi cr6, r7, 0x4c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 76, &mut ctx.xer);
	// 828D0A84: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D0A88: 41980008  blt cr6, 0x828d0a90
	if ctx.cr[6].lt {
	pc = 0x828D0A90; continue 'dispatch;
	}
	// 828D0A8C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828D0A90: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D0A94: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D0A98: 419A0014  beq cr6, 0x828d0aac
	if ctx.cr[6].eq {
	pc = 0x828D0AAC; continue 'dispatch;
	}
	// 828D0A9C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D0AA0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D0AA4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D0AA8: 4800000C  b 0x828d0ab4
	pc = 0x828D0AB4; continue 'dispatch;
	// 828D0AAC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D0AB0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D0AB4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0AB8: 4199FFB8  bgt cr6, 0x828d0a70
	if ctx.cr[6].gt {
	pc = 0x828D0A70; continue 'dispatch;
	}
	// 828D0ABC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D0AC0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D0AC4: 419A0040  beq cr6, 0x828d0b04
	if ctx.cr[6].eq {
	pc = 0x828D0B04; continue 'dispatch;
	}
	// 828D0AC8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0ACC: 2F0B004C  cmpwi cr6, r11, 0x4c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 76, &mut ctx.xer);
	// 828D0AD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0AD4: 41990008  bgt cr6, 0x828d0adc
	if ctx.cr[6].gt {
	pc = 0x828D0ADC; continue 'dispatch;
	}
	// 828D0AD8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828D0ADC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D0AE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0AE4: 409A0020  bne cr6, 0x828d0b04
	if !ctx.cr[6].eq {
	pc = 0x828D0B04; continue 'dispatch;
	}
	// 828D0AE8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D0AEC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828D0AF0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D0AF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0AF8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828D0AFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0B00: 4800001C  b 0x828d0b1c
	pc = 0x828D0B1C; continue 'dispatch;
	// 828D0B04: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D0B08: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0B0C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828D0B10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0B14: 48000008  b 0x828d0b1c
	pc = 0x828D0B1C; continue 'dispatch;
	// 828D0B18: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828D0B1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D0B20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0B24: 419A0040  beq cr6, 0x828d0b64
	if ctx.cr[6].eq {
	pc = 0x828D0B64; continue 'dispatch;
	}
	// 828D0B28: 573F063E  clrlwi r31, r25, 0x18
	ctx.r[31].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 828D0B2C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D0B30: 419A0014  beq cr6, 0x828d0b44
	if ctx.cr[6].eq {
	pc = 0x828D0B44; continue 'dispatch;
	}
	// 828D0B34: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D0B38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D0B3C: 4B9FF685  bl 0x822d01c0
	ctx.lr = 0x828D0B40;
	sub_822D01C0(ctx, base);
	// 828D0B40: 9B5E0022  stb r26, 0x22(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(34 as u32), ctx.r[26].u8 ) };
	// 828D0B44: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 828D0B48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D0B4C: 409A0008  bne cr6, 0x828d0b54
	if !ctx.cr[6].eq {
	pc = 0x828D0B54; continue 'dispatch;
	}
	// 828D0B50: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828D0B54: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D0B58: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828D0B5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D0B60: 4B8CD099  bl 0x8219dbf8
	ctx.lr = 0x828D0B64;
	sub_8219DBF8(ctx, base);
	// 828D0B64: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828D0B68: 7F1DD800  cmpw cr6, r29, r27
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[27].s32, &mut ctx.xer);
	// 828D0B6C: 4099FE70  ble cr6, 0x828d09dc
	if !ctx.cr[6].gt {
	pc = 0x828D09DC; continue 'dispatch;
	}
	// 828D0B70: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828D0B74: 483D88D8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D0B78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D0B78 size=2416
    let mut pc: u32 = 0x828D0B78;
    'dispatch: loop {
        match pc {
            0x828D0B78 => {
    //   block [0x828D0B78..0x828D14E8)
	// 828D0B78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D0B7C: 483D8881  bl 0x82ca93fc
	ctx.lr = 0x828D0B80;
	sub_82CA93D0(ctx, base);
	// 828D0B80: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D0B84: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828D0B88: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828D0B8C: 4800095D  bl 0x828d14e8
	ctx.lr = 0x828D0B90;
	sub_828D14E8(ctx, base);
	// 828D0B90: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828D0B94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0B98: 419A0948  beq cr6, 0x828d14e0
	if ctx.cr[6].eq {
	pc = 0x828D14E0; continue 'dispatch;
	}
	// 828D0B9C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0BA0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828D0BA4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D0BA8: 7F79DB78  mr r25, r27
	ctx.r[25].u64 = ctx.r[27].u64;
	// 828D0BAC: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D0BB0: 55497FFE  rlwinm r9, r10, 0xf, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0001FFFFu64;
	// 828D0BB4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D0BB8: 419A00F4  beq cr6, 0x828d0cac
	if ctx.cr[6].eq {
	pc = 0x828D0CAC; continue 'dispatch;
	}
	// 828D0BBC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D0BC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D0BC4: 419A0024  beq cr6, 0x828d0be8
	if ctx.cr[6].eq {
	pc = 0x828D0BE8; continue 'dispatch;
	}
	// 828D0BC8: 894A0051  lbz r10, 0x51(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(81 as u32) ) } as u64;
	// 828D0BCC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D0BD0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D0BD4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D0BD8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0BDC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D0BE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0BE4: 480000CC  b 0x828d0cb0
	pc = 0x828D0CB0; continue 'dispatch;
	// 828D0BE8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D0BEC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D0BF0: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828D0BF4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D0BF8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D0BFC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0C00: 40810054  ble 0x828d0c54
	if !ctx.cr[0].gt {
	pc = 0x828D0C54; continue 'dispatch;
	}
	// 828D0C04: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D0C08: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D0C0C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D0C10: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0C14: 2F070051  cmpwi cr6, r7, 0x51
	ctx.cr[6].compare_i32(ctx.r[7].s32, 81, &mut ctx.xer);
	// 828D0C18: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D0C1C: 41980008  blt cr6, 0x828d0c24
	if ctx.cr[6].lt {
	pc = 0x828D0C24; continue 'dispatch;
	}
	// 828D0C20: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828D0C24: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D0C28: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D0C2C: 419A0014  beq cr6, 0x828d0c40
	if ctx.cr[6].eq {
	pc = 0x828D0C40; continue 'dispatch;
	}
	// 828D0C30: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D0C34: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D0C38: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D0C3C: 4800000C  b 0x828d0c48
	pc = 0x828D0C48; continue 'dispatch;
	// 828D0C40: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D0C44: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D0C48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0C4C: 4199FFB8  bgt cr6, 0x828d0c04
	if ctx.cr[6].gt {
	pc = 0x828D0C04; continue 'dispatch;
	}
	// 828D0C50: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D0C54: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D0C58: 419A0040  beq cr6, 0x828d0c98
	if ctx.cr[6].eq {
	pc = 0x828D0C98; continue 'dispatch;
	}
	// 828D0C5C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0C60: 2F0B0051  cmpwi cr6, r11, 0x51
	ctx.cr[6].compare_i32(ctx.r[11].s32, 81, &mut ctx.xer);
	// 828D0C64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0C68: 41990008  bgt cr6, 0x828d0c70
	if ctx.cr[6].gt {
	pc = 0x828D0C70; continue 'dispatch;
	}
	// 828D0C6C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828D0C70: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D0C74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0C78: 409A0020  bne cr6, 0x828d0c98
	if !ctx.cr[6].eq {
	pc = 0x828D0C98; continue 'dispatch;
	}
	// 828D0C7C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D0C80: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D0C84: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D0C88: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0C8C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D0C90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0C94: 4800001C  b 0x828d0cb0
	pc = 0x828D0CB0; continue 'dispatch;
	// 828D0C98: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D0C9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0CA0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D0CA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0CA8: 48000008  b 0x828d0cb0
	pc = 0x828D0CB0; continue 'dispatch;
	// 828D0CAC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828D0CB0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D0CB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0CB8: 419A0130  beq cr6, 0x828d0de8
	if ctx.cr[6].eq {
	pc = 0x828D0DE8; continue 'dispatch;
	}
	// 828D0CBC: 815C002C  lwz r10, 0x2c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D0CC0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828D0CC4: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828D0CC8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D0CCC: 419A00E8  beq cr6, 0x828d0db4
	if ctx.cr[6].eq {
	pc = 0x828D0DB4; continue 'dispatch;
	}
	// 828D0CD0: 817C008C  lwz r11, 0x8c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D0CD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0CD8: 419A0020  beq cr6, 0x828d0cf8
	if ctx.cr[6].eq {
	pc = 0x828D0CF8; continue 'dispatch;
	}
	// 828D0CDC: 894B0043  lbz r10, 0x43(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(67 as u32) ) } as u64;
	// 828D0CE0: 817C0048  lwz r11, 0x48(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D0CE4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D0CE8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D0CEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D0CF0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0CF4: 480000C4  b 0x828d0db8
	pc = 0x828D0DB8; continue 'dispatch;
	// 828D0CF8: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D0CFC: 80DC004C  lwz r6, 0x4c(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D0D00: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828D0D04: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D0D08: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D0D0C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0D10: 40810054  ble 0x828d0d64
	if !ctx.cr[0].gt {
	pc = 0x828D0D64; continue 'dispatch;
	}
	// 828D0D14: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D0D18: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D0D1C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D0D20: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0D24: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 828D0D28: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D0D2C: 41980008  blt cr6, 0x828d0d34
	if ctx.cr[6].lt {
	pc = 0x828D0D34; continue 'dispatch;
	}
	// 828D0D30: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828D0D34: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D0D38: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D0D3C: 419A0014  beq cr6, 0x828d0d50
	if ctx.cr[6].eq {
	pc = 0x828D0D50; continue 'dispatch;
	}
	// 828D0D40: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D0D44: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D0D48: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D0D4C: 4800000C  b 0x828d0d58
	pc = 0x828D0D58; continue 'dispatch;
	// 828D0D50: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D0D54: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D0D58: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0D5C: 4199FFB8  bgt cr6, 0x828d0d14
	if ctx.cr[6].gt {
	pc = 0x828D0D14; continue 'dispatch;
	}
	// 828D0D60: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D0D64: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D0D68: 419A003C  beq cr6, 0x828d0da4
	if ctx.cr[6].eq {
	pc = 0x828D0DA4; continue 'dispatch;
	}
	// 828D0D6C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0D70: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 828D0D74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0D78: 41990008  bgt cr6, 0x828d0d80
	if ctx.cr[6].gt {
	pc = 0x828D0D80; continue 'dispatch;
	}
	// 828D0D7C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828D0D80: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D0D84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0D88: 409A001C  bne cr6, 0x828d0da4
	if !ctx.cr[6].eq {
	pc = 0x828D0DA4; continue 'dispatch;
	}
	// 828D0D8C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D0D90: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D0D94: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D0D98: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D0D9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0DA0: 48000018  b 0x828d0db8
	pc = 0x828D0DB8; continue 'dispatch;
	// 828D0DA4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D0DA8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D0DAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0DB0: 48000008  b 0x828d0db8
	pc = 0x828D0DB8; continue 'dispatch;
	// 828D0DB4: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 828D0DB8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D0DBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D0DC0: 419A0028  beq cr6, 0x828d0de8
	if ctx.cr[6].eq {
	pc = 0x828D0DE8; continue 'dispatch;
	}
	// 828D0DC4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D0DC8: 4BF5AED9  bl 0x8282bca0
	ctx.lr = 0x828D0DCC;
	sub_8282BCA0(ctx, base);
	// 828D0DCC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828D0DD0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828D0DD4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828D0DD8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828D0DDC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828D0DE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D0DE4: 4BB5D795  bl 0x8242e578
	ctx.lr = 0x828D0DE8;
	sub_8242E578(ctx, base);
	// 828D0DE8: 817C002C  lwz r11, 0x2c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D0DEC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D0DF0: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828D0DF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D0DF8: 419A00F4  beq cr6, 0x828d0eec
	if ctx.cr[6].eq {
	pc = 0x828D0EEC; continue 'dispatch;
	}
	// 828D0DFC: 817C008C  lwz r11, 0x8c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D0E00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0E04: 419A0024  beq cr6, 0x828d0e28
	if ctx.cr[6].eq {
	pc = 0x828D0E28; continue 'dispatch;
	}
	// 828D0E08: 894B0043  lbz r10, 0x43(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(67 as u32) ) } as u64;
	// 828D0E0C: 817C0048  lwz r11, 0x48(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D0E10: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D0E14: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D0E18: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0E1C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D0E20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0E24: 480000CC  b 0x828d0ef0
	pc = 0x828D0EF0; continue 'dispatch;
	// 828D0E28: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D0E2C: 80DC004C  lwz r6, 0x4c(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D0E30: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828D0E34: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D0E38: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D0E3C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0E40: 40810054  ble 0x828d0e94
	if !ctx.cr[0].gt {
	pc = 0x828D0E94; continue 'dispatch;
	}
	// 828D0E44: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D0E48: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D0E4C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D0E50: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0E54: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 828D0E58: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D0E5C: 41980008  blt cr6, 0x828d0e64
	if ctx.cr[6].lt {
	pc = 0x828D0E64; continue 'dispatch;
	}
	// 828D0E60: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828D0E64: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D0E68: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D0E6C: 419A0014  beq cr6, 0x828d0e80
	if ctx.cr[6].eq {
	pc = 0x828D0E80; continue 'dispatch;
	}
	// 828D0E70: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D0E74: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D0E78: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D0E7C: 4800000C  b 0x828d0e88
	pc = 0x828D0E88; continue 'dispatch;
	// 828D0E80: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D0E84: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D0E88: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0E8C: 4199FFB8  bgt cr6, 0x828d0e44
	if ctx.cr[6].gt {
	pc = 0x828D0E44; continue 'dispatch;
	}
	// 828D0E90: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D0E94: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D0E98: 419A0040  beq cr6, 0x828d0ed8
	if ctx.cr[6].eq {
	pc = 0x828D0ED8; continue 'dispatch;
	}
	// 828D0E9C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0EA0: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 828D0EA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0EA8: 41990008  bgt cr6, 0x828d0eb0
	if ctx.cr[6].gt {
	pc = 0x828D0EB0; continue 'dispatch;
	}
	// 828D0EAC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828D0EB0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D0EB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0EB8: 409A0020  bne cr6, 0x828d0ed8
	if !ctx.cr[6].eq {
	pc = 0x828D0ED8; continue 'dispatch;
	}
	// 828D0EBC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D0EC0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D0EC4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D0EC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0ECC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D0ED0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0ED4: 4800001C  b 0x828d0ef0
	pc = 0x828D0EF0; continue 'dispatch;
	// 828D0ED8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D0EDC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0EE0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D0EE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0EE8: 48000008  b 0x828d0ef0
	pc = 0x828D0EF0; continue 'dispatch;
	// 828D0EEC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828D0EF0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D0EF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0EF8: 419A0318  beq cr6, 0x828d1210
	if ctx.cr[6].eq {
	pc = 0x828D1210; continue 'dispatch;
	}
	// 828D0EFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0F00: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 828D0F04: 997F0056  stb r11, 0x56(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(86 as u32), ctx.r[11].u8 ) };
	// 828D0F08: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0F0C: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828D0F10: 5549C7FE  rlwinm r9, r10, 0x18, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D0F14: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D0F18: 419A00F4  beq cr6, 0x828d100c
	if ctx.cr[6].eq {
	pc = 0x828D100C; continue 'dispatch;
	}
	// 828D0F1C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D0F20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D0F24: 419A0024  beq cr6, 0x828d0f48
	if ctx.cr[6].eq {
	pc = 0x828D0F48; continue 'dispatch;
	}
	// 828D0F28: 892A0088  lbz r9, 0x88(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(136 as u32) ) } as u64;
	// 828D0F2C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D0F30: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828D0F34: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828D0F38: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0F3C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828D0F40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0F44: 480000CC  b 0x828d1010
	pc = 0x828D1010; continue 'dispatch;
	// 828D0F48: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D0F4C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D0F50: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828D0F54: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D0F58: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D0F5C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0F60: 40810054  ble 0x828d0fb4
	if !ctx.cr[0].gt {
	pc = 0x828D0FB4; continue 'dispatch;
	}
	// 828D0F64: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D0F68: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D0F6C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D0F70: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0F74: 2F070088  cmpwi cr6, r7, 0x88
	ctx.cr[6].compare_i32(ctx.r[7].s32, 136, &mut ctx.xer);
	// 828D0F78: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D0F7C: 41980008  blt cr6, 0x828d0f84
	if ctx.cr[6].lt {
	pc = 0x828D0F84; continue 'dispatch;
	}
	// 828D0F80: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828D0F84: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D0F88: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D0F8C: 419A0014  beq cr6, 0x828d0fa0
	if ctx.cr[6].eq {
	pc = 0x828D0FA0; continue 'dispatch;
	}
	// 828D0F90: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D0F94: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D0F98: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D0F9C: 4800000C  b 0x828d0fa8
	pc = 0x828D0FA8; continue 'dispatch;
	// 828D0FA0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D0FA4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D0FA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0FAC: 4199FFB8  bgt cr6, 0x828d0f64
	if ctx.cr[6].gt {
	pc = 0x828D0F64; continue 'dispatch;
	}
	// 828D0FB0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D0FB4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D0FB8: 419A0040  beq cr6, 0x828d0ff8
	if ctx.cr[6].eq {
	pc = 0x828D0FF8; continue 'dispatch;
	}
	// 828D0FBC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0FC0: 2F0B0088  cmpwi cr6, r11, 0x88
	ctx.cr[6].compare_i32(ctx.r[11].s32, 136, &mut ctx.xer);
	// 828D0FC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0FC8: 41990008  bgt cr6, 0x828d0fd0
	if ctx.cr[6].gt {
	pc = 0x828D0FD0; continue 'dispatch;
	}
	// 828D0FCC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828D0FD0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D0FD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0FD8: 409A0020  bne cr6, 0x828d0ff8
	if !ctx.cr[6].eq {
	pc = 0x828D0FF8; continue 'dispatch;
	}
	// 828D0FDC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D0FE0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D0FE4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D0FE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0FEC: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828D0FF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D0FF4: 4800001C  b 0x828d1010
	pc = 0x828D1010; continue 'dispatch;
	// 828D0FF8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D0FFC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1000: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828D1004: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D1008: 48000008  b 0x828d1010
	pc = 0x828D1010; continue 'dispatch;
	// 828D100C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828D1010: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D1014: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D1018: 419A01F8  beq cr6, 0x828d1210
	if ctx.cr[6].eq {
	pc = 0x828D1210; continue 'dispatch;
	}
	// 828D101C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D1020: 4BF76F91  bl 0x82847fb0
	ctx.lr = 0x828D1024;
	sub_82847FB0(ctx, base);
	// 828D1024: 397F0078  addi r11, r31, 0x78
	ctx.r[11].s64 = ctx.r[31].s64 + 120;
	// 828D1028: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828D102C: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 828D1030: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828D1034: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1038: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D103C: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D1040: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 828D1044: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D1048: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D104C: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828D1050: 419A0028  beq cr6, 0x828d1078
	if ctx.cr[6].eq {
	pc = 0x828D1078; continue 'dispatch;
	}
	// 828D1054: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828D1058: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D105C: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 828D1060: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D1064: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D1068: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D106C: 4BB850AD  bl 0x82456118
	ctx.lr = 0x828D1070;
	sub_82456118(ctx, base);
	// 828D1070: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1074: 4BFFFFD4  b 0x828d1048
	pc = 0x828D1048; continue 'dispatch;
	// 828D1078: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D107C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D1080: 419A017C  beq cr6, 0x828d11fc
	if ctx.cr[6].eq {
	pc = 0x828D11FC; continue 'dispatch;
	}
	// 828D1084: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 828D1088: 4B8A2DB1  bl 0x82173e38
	ctx.lr = 0x828D108C;
	sub_82173E38(ctx, base);
	// 828D108C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D1090: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D1094: 419A0018  beq cr6, 0x828d10ac
	if ctx.cr[6].eq {
	pc = 0x828D10AC; continue 'dispatch;
	}
	// 828D1098: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D109C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D10A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D10A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D10A8: 409A0008  bne cr6, 0x828d10b0
	if !ctx.cr[6].eq {
	pc = 0x828D10B0; continue 'dispatch;
	}
	// 828D10AC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828D10B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D10B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D10B8: 419A012C  beq cr6, 0x828d11e4
	if ctx.cr[6].eq {
	pc = 0x828D11E4; continue 'dispatch;
	}
	// 828D10BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D10C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D10C4: 4BEDEBCD  bl 0x827afc90
	ctx.lr = 0x828D10C8;
	sub_827AFC90(ctx, base);
	// 828D10C8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828D10CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D10D0: 419A0114  beq cr6, 0x828d11e4
	if ctx.cr[6].eq {
	pc = 0x828D11E4; continue 'dispatch;
	}
	// 828D10D4: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 828D10D8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828D10DC: 554937FE  rlwinm r9, r10, 6, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x03FFFFFFu64;
	// 828D10E0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D10E4: 419A00E4  beq cr6, 0x828d11c8
	if ctx.cr[6].eq {
	pc = 0x828D11C8; continue 'dispatch;
	}
	// 828D10E8: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D10EC: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D10F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D10F4: 419A001C  beq cr6, 0x828d1110
	if ctx.cr[6].eq {
	pc = 0x828D1110; continue 'dispatch;
	}
	// 828D10F8: 896B001A  lbz r11, 0x1a(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(26 as u32) ) } as u64;
	// 828D10FC: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828D1100: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828D1104: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1108: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D110C: 480000C0  b 0x828d11cc
	pc = 0x828D11CC; continue 'dispatch;
	// 828D1110: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D1114: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828D1118: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D111C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D1120: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D1124: 40810054  ble 0x828d1178
	if !ctx.cr[0].gt {
	pc = 0x828D1178; continue 'dispatch;
	}
	// 828D1128: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D112C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D1130: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D1134: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1138: 2F07001A  cmpwi cr6, r7, 0x1a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 26, &mut ctx.xer);
	// 828D113C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D1140: 41980008  blt cr6, 0x828d1148
	if ctx.cr[6].lt {
	pc = 0x828D1148; continue 'dispatch;
	}
	// 828D1144: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828D1148: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D114C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D1150: 419A0014  beq cr6, 0x828d1164
	if ctx.cr[6].eq {
	pc = 0x828D1164; continue 'dispatch;
	}
	// 828D1154: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D1158: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D115C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D1160: 4800000C  b 0x828d116c
	pc = 0x828D116C; continue 'dispatch;
	// 828D1164: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D1168: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D116C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D1170: 4199FFB8  bgt cr6, 0x828d1128
	if ctx.cr[6].gt {
	pc = 0x828D1128; continue 'dispatch;
	}
	// 828D1174: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D1178: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D117C: 419A003C  beq cr6, 0x828d11b8
	if ctx.cr[6].eq {
	pc = 0x828D11B8; continue 'dispatch;
	}
	// 828D1180: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1184: 2F0B001A  cmpwi cr6, r11, 0x1a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 26, &mut ctx.xer);
	// 828D1188: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D118C: 41990008  bgt cr6, 0x828d1194
	if ctx.cr[6].gt {
	pc = 0x828D1194; continue 'dispatch;
	}
	// 828D1190: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828D1194: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D1198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D119C: 409A001C  bne cr6, 0x828d11b8
	if !ctx.cr[6].eq {
	pc = 0x828D11B8; continue 'dispatch;
	}
	// 828D11A0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D11A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D11A8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828D11AC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D11B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D11B4: 48000018  b 0x828d11cc
	pc = 0x828D11CC; continue 'dispatch;
	// 828D11B8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D11BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D11C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D11C4: 48000008  b 0x828d11cc
	pc = 0x828D11CC; continue 'dispatch;
	// 828D11C8: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 828D11CC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D11D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D11D4: 419A0010  beq cr6, 0x828d11e4
	if ctx.cr[6].eq {
	pc = 0x828D11E4; continue 'dispatch;
	}
	// 828D11D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D11DC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D11E0: 4BF085A9  bl 0x827d9788
	ctx.lr = 0x828D11E4;
	sub_827D9788(ctx, base);
	// 828D11E4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D11E8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D11EC: 409A0008  bne cr6, 0x828d11f4
	if !ctx.cr[6].eq {
	pc = 0x828D11F4; continue 'dispatch;
	}
	// 828D11F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D11F4: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D11F8: 4BFFFE84  b 0x828d107c
	pc = 0x828D107C; continue 'dispatch;
	// 828D11FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D1200: 4BE5C139  bl 0x8272d338
	ctx.lr = 0x828D1204;
	sub_8272D338(ctx, base);
	// 828D1204: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D1208: 4B94AB31  bl 0x8221bd38
	ctx.lr = 0x828D120C;
	sub_8221BD38(ctx, base);
	// 828D120C: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 828D1210: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 828D1214: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828D1218: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D121C: 4BFFEBED  bl 0x828cfe08
	ctx.lr = 0x828D1220;
	sub_828CFE08(ctx, base);
	// 828D1220: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828D1224: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828D1228: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828D122C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D1230: 4BFFF661  bl 0x828d0890
	ctx.lr = 0x828D1234;
	sub_828D0890(ctx, base);
	// 828D1234: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1238: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D123C: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828D1240: 55493FFE  rlwinm r9, r10, 7, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x01FFFFFFu64;
	// 828D1244: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D1248: 419A00E8  beq cr6, 0x828d1330
	if ctx.cr[6].eq {
	pc = 0x828D1330; continue 'dispatch;
	}
	// 828D124C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D1250: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D1254: 419A0020  beq cr6, 0x828d1274
	if ctx.cr[6].eq {
	pc = 0x828D1274; continue 'dispatch;
	}
	// 828D1258: 892A0039  lbz r9, 0x39(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(57 as u32) ) } as u64;
	// 828D125C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D1260: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828D1264: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828D1268: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D126C: 83E80004  lwz r31, 4(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1270: 480000C4  b 0x828d1334
	pc = 0x828D1334; continue 'dispatch;
	// 828D1274: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D1278: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D127C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828D1280: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D1284: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D1288: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D128C: 40810054  ble 0x828d12e0
	if !ctx.cr[0].gt {
	pc = 0x828D12E0; continue 'dispatch;
	}
	// 828D1290: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D1294: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D1298: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828D129C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D12A0: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 828D12A4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D12A8: 41980008  blt cr6, 0x828d12b0
	if ctx.cr[6].lt {
	pc = 0x828D12B0; continue 'dispatch;
	}
	// 828D12AC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828D12B0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D12B4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D12B8: 419A0014  beq cr6, 0x828d12cc
	if ctx.cr[6].eq {
	pc = 0x828D12CC; continue 'dispatch;
	}
	// 828D12BC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D12C0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D12C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D12C8: 4800000C  b 0x828d12d4
	pc = 0x828D12D4; continue 'dispatch;
	// 828D12CC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D12D0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D12D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D12D8: 4199FFB8  bgt cr6, 0x828d1290
	if ctx.cr[6].gt {
	pc = 0x828D1290; continue 'dispatch;
	}
	// 828D12DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D12E0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D12E4: 419A003C  beq cr6, 0x828d1320
	if ctx.cr[6].eq {
	pc = 0x828D1320; continue 'dispatch;
	}
	// 828D12E8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D12EC: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 828D12F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D12F4: 41990008  bgt cr6, 0x828d12fc
	if ctx.cr[6].gt {
	pc = 0x828D12FC; continue 'dispatch;
	}
	// 828D12F8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828D12FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D1300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D1304: 409A001C  bne cr6, 0x828d1320
	if !ctx.cr[6].eq {
	pc = 0x828D1320; continue 'dispatch;
	}
	// 828D1308: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D130C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828D1310: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D1314: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1318: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D131C: 48000018  b 0x828d1334
	pc = 0x828D1334; continue 'dispatch;
	// 828D1320: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D1324: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1328: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D132C: 48000008  b 0x828d1334
	pc = 0x828D1334; continue 'dispatch;
	// 828D1330: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828D1334: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D1338: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D133C: 419A0024  beq cr6, 0x828d1360
	if ctx.cr[6].eq {
	pc = 0x828D1360; continue 'dispatch;
	}
	// 828D1340: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D1344: 38800069  li r4, 0x69
	ctx.r[4].s64 = 105;
	// 828D1348: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D134C: 4BA07ABD  bl 0x822d8e08
	ctx.lr = 0x828D1350;
	sub_822D8E08(ctx, base);
	// 828D1350: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 828D1354: 3880001D  li r4, 0x1d
	ctx.r[4].s64 = 29;
	// 828D1358: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D135C: 4BA07AAD  bl 0x822d8e08
	ctx.lr = 0x828D1360;
	sub_822D8E08(ctx, base);
	// 828D1360: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D1364: 48002EB5  bl 0x828d4218
	ctx.lr = 0x828D1368;
	sub_828D4218(ctx, base);
	// 828D1368: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828D136C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D1370: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D1374: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D1378: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D137C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1380: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1384: 4BA929B5  bl 0x82363d38
	ctx.lr = 0x828D1388;
	sub_82363D38(ctx, base);
	// 828D1388: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D138C: 419A0018  beq cr6, 0x828d13a4
	if ctx.cr[6].eq {
	pc = 0x828D13A4; continue 'dispatch;
	}
	// 828D1390: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D1394: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D1398: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D139C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D13A0: 409A0008  bne cr6, 0x828d13a8
	if !ctx.cr[6].eq {
	pc = 0x828D13A8; continue 'dispatch;
	}
	// 828D13A4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828D13A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D13AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D13B0: 419A0130  beq cr6, 0x828d14e0
	if ctx.cr[6].eq {
	pc = 0x828D14E0; continue 'dispatch;
	}
	// 828D13B4: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 828D13B8: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828D13BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D13C0: 419A00F0  beq cr6, 0x828d14b0
	if ctx.cr[6].eq {
	pc = 0x828D14B0; continue 'dispatch;
	}
	// 828D13C4: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D13C8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D13CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D13D0: 419A0020  beq cr6, 0x828d13f0
	if ctx.cr[6].eq {
	pc = 0x828D13F0; continue 'dispatch;
	}
	// 828D13D4: 896B0061  lbz r11, 0x61(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(97 as u32) ) } as u64;
	// 828D13D8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828D13DC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828D13E0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D13E4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D13E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D13EC: 480000C8  b 0x828d14b4
	pc = 0x828D14B4; continue 'dispatch;
	// 828D13F0: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D13F4: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828D13F8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D13FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D1400: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D1404: 40810054  ble 0x828d1458
	if !ctx.cr[0].gt {
	pc = 0x828D1458; continue 'dispatch;
	}
	// 828D1408: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D140C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D1410: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828D1414: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1418: 2F070061  cmpwi cr6, r7, 0x61
	ctx.cr[6].compare_i32(ctx.r[7].s32, 97, &mut ctx.xer);
	// 828D141C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D1420: 41980008  blt cr6, 0x828d1428
	if ctx.cr[6].lt {
	pc = 0x828D1428; continue 'dispatch;
	}
	// 828D1424: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828D1428: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D142C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D1430: 419A0014  beq cr6, 0x828d1444
	if ctx.cr[6].eq {
	pc = 0x828D1444; continue 'dispatch;
	}
	// 828D1434: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D1438: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D143C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D1440: 4800000C  b 0x828d144c
	pc = 0x828D144C; continue 'dispatch;
	// 828D1444: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D1448: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D144C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D1450: 4199FFB8  bgt cr6, 0x828d1408
	if ctx.cr[6].gt {
	pc = 0x828D1408; continue 'dispatch;
	}
	// 828D1454: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D1458: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D145C: 419A0040  beq cr6, 0x828d149c
	if ctx.cr[6].eq {
	pc = 0x828D149C; continue 'dispatch;
	}
	// 828D1460: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1464: 2F0B0061  cmpwi cr6, r11, 0x61
	ctx.cr[6].compare_i32(ctx.r[11].s32, 97, &mut ctx.xer);
	// 828D1468: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D146C: 41990008  bgt cr6, 0x828d1474
	if ctx.cr[6].gt {
	pc = 0x828D1474; continue 'dispatch;
	}
	// 828D1470: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828D1474: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D1478: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D147C: 409A0020  bne cr6, 0x828d149c
	if !ctx.cr[6].eq {
	pc = 0x828D149C; continue 'dispatch;
	}
	// 828D1480: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D1484: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828D1488: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D148C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1490: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D1494: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D1498: 4800001C  b 0x828d14b4
	pc = 0x828D14B4; continue 'dispatch;
	// 828D149C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D14A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D14A4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D14A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D14AC: 48000008  b 0x828d14b4
	pc = 0x828D14B4; continue 'dispatch;
	// 828D14B0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828D14B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D14B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D14BC: 419A0024  beq cr6, 0x828d14e0
	if ctx.cr[6].eq {
	pc = 0x828D14E0; continue 'dispatch;
	}
	// 828D14C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D14C4: 4BF419C5  bl 0x82812e88
	ctx.lr = 0x828D14C8;
	sub_82812E88(ctx, base);
	// 828D14C8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828D14CC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828D14D0: 409A0010  bne cr6, 0x828d14e0
	if !ctx.cr[6].eq {
	pc = 0x828D14E0; continue 'dispatch;
	}
	// 828D14D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D14D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D14DC: 4BF39FCD  bl 0x8280b4a8
	ctx.lr = 0x828D14E0;
	sub_8280B4A8(ctx, base);
	// 828D14E0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828D14E4: 483D7F68  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D14E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D14E8 size=244
    let mut pc: u32 = 0x828D14E8;
    'dispatch: loop {
        match pc {
            0x828D14E8 => {
    //   block [0x828D14E8..0x828D15DC)
	// 828D14E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D14EC: 483D7F21  bl 0x82ca940c
	ctx.lr = 0x828D14F0;
	sub_82CA93D0(ctx, base);
	// 828D14F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D14F4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D14F8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828D14FC: 3BC30018  addi r30, r3, 0x18
	ctx.r[30].s64 = ctx.r[3].s64 + 24;
	// 828D1500: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1504: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1508: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828D150C: 419A0008  beq cr6, 0x828d1514
	if ctx.cr[6].eq {
	pc = 0x828D1514; continue 'dispatch;
	}
	// 828D1510: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D1514: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D1518: 419A00B8  beq cr6, 0x828d15d0
	if ctx.cr[6].eq {
	pc = 0x828D15D0; continue 'dispatch;
	}
	// 828D151C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1520: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D1524: 409A0008  bne cr6, 0x828d152c
	if !ctx.cr[6].eq {
	pc = 0x828D152C; continue 'dispatch;
	}
	// 828D1528: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D152C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D1530: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D1534: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D1538: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D153C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D1540: 419A0020  beq cr6, 0x828d1560
	if ctx.cr[6].eq {
	pc = 0x828D1560; continue 'dispatch;
	}
	// 828D1544: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828D1548: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D154C: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828D1550: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828D1554: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D1558: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D155C: 4082FFE8  bne 0x828d1544
	if !ctx.cr[0].eq {
	pc = 0x828D1544; continue 'dispatch;
	}
	// 828D1560: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D1564: 419A0038  beq cr6, 0x828d159c
	if ctx.cr[6].eq {
	pc = 0x828D159C; continue 'dispatch;
	}
	// 828D1568: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D156C: 813D0014  lwz r9, 0x14(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D1570: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D1574: 409A0018  bne cr6, 0x828d158c
	if !ctx.cr[6].eq {
	pc = 0x828D158C; continue 'dispatch;
	}
	// 828D1578: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D157C: 815D0018  lwz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 828D1580: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828D1584: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D1588: 419A0008  beq cr6, 0x828d1590
	if ctx.cr[6].eq {
	pc = 0x828D1590; continue 'dispatch;
	}
	// 828D158C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D1590: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D1594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D1598: 409A0024  bne cr6, 0x828d15bc
	if !ctx.cr[6].eq {
	pc = 0x828D15BC; continue 'dispatch;
	}
	// 828D159C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D15A0: 4B8E6579  bl 0x821b7b18
	ctx.lr = 0x828D15A4;
	sub_821B7B18(ctx, base);
	// 828D15A4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D15A8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D15AC: 409A0008  bne cr6, 0x828d15b4
	if !ctx.cr[6].eq {
	pc = 0x828D15B4; continue 'dispatch;
	}
	// 828D15B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D15B4: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D15B8: 4BFFFF4C  b 0x828d1504
	pc = 0x828D1504; continue 'dispatch;
	// 828D15BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D15C0: 4B8E6559  bl 0x821b7b18
	ctx.lr = 0x828D15C4;
	sub_821B7B18(ctx, base);
	// 828D15C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828D15C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D15CC: 483D7E90  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828D15D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828D15D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D15D8: 483D7E84  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D15E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D15E0 size=260
    let mut pc: u32 = 0x828D15E0;
    'dispatch: loop {
        match pc {
            0x828D15E0 => {
    //   block [0x828D15E0..0x828D16E4)
	// 828D15E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D15E4: 483D7E25  bl 0x82ca9408
	ctx.lr = 0x828D15E8;
	sub_82CA93D0(ctx, base);
	// 828D15E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D15EC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828D15F0: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D15F4: 3BA30018  addi r29, r3, 0x18
	ctx.r[29].s64 = ctx.r[3].s64 + 24;
	// 828D15F8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D15FC: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1600: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D1604: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D1608: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D160C: 80C70008  lwz r6, 8(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D1610: 80A60004  lwz r5, 4(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1614: 80850024  lwz r4, 0x24(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 828D1618: 80640004  lwz r3, 4(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D161C: 838300B4  lwz r28, 0xb4(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(180 as u32) ) } as u64;
	// 828D1620: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1624: 7F1DE840  cmplw cr6, r29, r29
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828D1628: 419A0008  beq cr6, 0x828d1630
	if ctx.cr[6].eq {
	pc = 0x828D1630; continue 'dispatch;
	}
	// 828D162C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D1630: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D1634: 419A00A4  beq cr6, 0x828d16d8
	if ctx.cr[6].eq {
	pc = 0x828D16D8; continue 'dispatch;
	}
	// 828D1638: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D163C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D1640: 409A0008  bne cr6, 0x828d1648
	if !ctx.cr[6].eq {
	pc = 0x828D1648; continue 'dispatch;
	}
	// 828D1644: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D1648: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D164C: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D1650: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D1654: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D1658: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828D165C: 419A0020  beq cr6, 0x828d167c
	if ctx.cr[6].eq {
	pc = 0x828D167C; continue 'dispatch;
	}
	// 828D1660: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D1664: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D1668: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D166C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D1670: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D1674: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D1678: 4082FFE8  bne 0x828d1660
	if !ctx.cr[0].eq {
	pc = 0x828D1660; continue 'dispatch;
	}
	// 828D167C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D1680: 419A0024  beq cr6, 0x828d16a4
	if ctx.cr[6].eq {
	pc = 0x828D16A4; continue 'dispatch;
	}
	// 828D1684: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1688: 4BFFC489  bl 0x828cdb10
	ctx.lr = 0x828D168C;
	sub_828CDB10(ctx, base);
	// 828D168C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828D1690: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D1694: 419A0010  beq cr6, 0x828d16a4
	if ctx.cr[6].eq {
	pc = 0x828D16A4; continue 'dispatch;
	}
	// 828D1698: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D169C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828D16A0: 419A0024  beq cr6, 0x828d16c4
	if ctx.cr[6].eq {
	pc = 0x828D16C4; continue 'dispatch;
	}
	// 828D16A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D16A8: 4B8E6471  bl 0x821b7b18
	ctx.lr = 0x828D16AC;
	sub_821B7B18(ctx, base);
	// 828D16AC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D16B0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D16B4: 409A0008  bne cr6, 0x828d16bc
	if !ctx.cr[6].eq {
	pc = 0x828D16BC; continue 'dispatch;
	}
	// 828D16B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D16BC: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D16C0: 4BFFFF60  b 0x828d1620
	pc = 0x828D1620; continue 'dispatch;
	// 828D16C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D16C8: 4B8E6451  bl 0x821b7b18
	ctx.lr = 0x828D16CC;
	sub_821B7B18(ctx, base);
	// 828D16CC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828D16D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D16D4: 483D7D84  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 828D16D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828D16DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D16E0: 483D7D78  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D16E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D16E8 size=232
    let mut pc: u32 = 0x828D16E8;
    'dispatch: loop {
        match pc {
            0x828D16E8 => {
    //   block [0x828D16E8..0x828D17D0)
	// 828D16E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D16EC: 483D7D21  bl 0x82ca940c
	ctx.lr = 0x828D16F0;
	sub_82CA93D0(ctx, base);
	// 828D16F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D16F4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D16F8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828D16FC: 3BC30018  addi r30, r3, 0x18
	ctx.r[30].s64 = ctx.r[3].s64 + 24;
	// 828D1700: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1704: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1708: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828D170C: 419A0008  beq cr6, 0x828d1714
	if ctx.cr[6].eq {
	pc = 0x828D1714; continue 'dispatch;
	}
	// 828D1710: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D1714: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D1718: 419A00B0  beq cr6, 0x828d17c8
	if ctx.cr[6].eq {
	pc = 0x828D17C8; continue 'dispatch;
	}
	// 828D171C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1720: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D1724: 409A0008  bne cr6, 0x828d172c
	if !ctx.cr[6].eq {
	pc = 0x828D172C; continue 'dispatch;
	}
	// 828D1728: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D172C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D1730: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D1734: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D1738: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D173C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828D1740: 419A0020  beq cr6, 0x828d1760
	if ctx.cr[6].eq {
	pc = 0x828D1760; continue 'dispatch;
	}
	// 828D1744: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D1748: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D174C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D1750: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D1754: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D1758: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D175C: 4082FFE8  bne 0x828d1744
	if !ctx.cr[0].eq {
	pc = 0x828D1744; continue 'dispatch;
	}
	// 828D1760: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D1764: 419A0038  beq cr6, 0x828d179c
	if ctx.cr[6].eq {
	pc = 0x828D179C; continue 'dispatch;
	}
	// 828D1768: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D176C: 815D0014  lwz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D1770: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828D1774: 409A0018  bne cr6, 0x828d178c
	if !ctx.cr[6].eq {
	pc = 0x828D178C; continue 'dispatch;
	}
	// 828D1778: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D177C: 815D0018  lwz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 828D1780: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828D1784: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D1788: 419A0008  beq cr6, 0x828d1790
	if ctx.cr[6].eq {
	pc = 0x828D1790; continue 'dispatch;
	}
	// 828D178C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D1790: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D1794: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D1798: 409A0024  bne cr6, 0x828d17bc
	if !ctx.cr[6].eq {
	pc = 0x828D17BC; continue 'dispatch;
	}
	// 828D179C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D17A0: 4B8E6379  bl 0x821b7b18
	ctx.lr = 0x828D17A4;
	sub_821B7B18(ctx, base);
	// 828D17A4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D17A8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D17AC: 409A0008  bne cr6, 0x828d17b4
	if !ctx.cr[6].eq {
	pc = 0x828D17B4; continue 'dispatch;
	}
	// 828D17B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D17B4: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D17B8: 4BFFFF4C  b 0x828d1704
	pc = 0x828D1704; continue 'dispatch;
	// 828D17BC: 4BFFBDC5  bl 0x828cd580
	ctx.lr = 0x828D17C0;
	sub_828CD580(ctx, base);
	// 828D17C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D17C4: 4B8E6355  bl 0x821b7b18
	ctx.lr = 0x828D17C8;
	sub_821B7B18(ctx, base);
	// 828D17C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D17CC: 483D7C90  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D17D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D17D0 size=556
    let mut pc: u32 = 0x828D17D0;
    'dispatch: loop {
        match pc {
            0x828D17D0 => {
    //   block [0x828D17D0..0x828D19FC)
	// 828D17D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D17D4: 483D7C25  bl 0x82ca93f8
	ctx.lr = 0x828D17D8;
	sub_82CA93D0(ctx, base);
	// 828D17D8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D17DC: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 828D17E0: 8144001C  lwz r10, 0x1c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D17E4: 3B840018  addi r28, r4, 0x18
	ctx.r[28].s64 = ctx.r[4].s64 + 24;
	// 828D17E8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828D17EC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828D17F0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828D17F4: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D17F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D17FC: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D1800: F921006C  std r9, 0x6c(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u64 ) };
	// 828D1804: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D1808: 83C1006C  lwz r30, 0x6c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828D180C: 83A10070  lwz r29, 0x70(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828D1810: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 828D1814: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 828D1818: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D181C: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1820: 80A60008  lwz r5, 8(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D1824: 80850004  lwz r4, 4(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1828: 80640024  lwz r3, 0x24(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 828D182C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1830: 830B00B4  lwz r24, 0xb4(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) } as u64;
	// 828D1834: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1838: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D183C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1840: 419A000C  beq cr6, 0x828d184c
	if ctx.cr[6].eq {
	pc = 0x828D184C; continue 'dispatch;
	}
	// 828D1844: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828D1848: 419A0008  beq cr6, 0x828d1850
	if ctx.cr[6].eq {
	pc = 0x828D1850; continue 'dispatch;
	}
	// 828D184C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D1850: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D1854: 419A0194  beq cr6, 0x828d19e8
	if ctx.cr[6].eq {
	pc = 0x828D19E8; continue 'dispatch;
	}
	// 828D1858: E961006C  ld r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	// 828D185C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D1860: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828D1864: 409A0008  bne cr6, 0x828d186c
	if !ctx.cr[6].eq {
	pc = 0x828D186C; continue 'dispatch;
	}
	// 828D1868: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D186C: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828D1870: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1874: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1878: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828D187C: 409A000C  bne cr6, 0x828d1888
	if !ctx.cr[6].eq {
	pc = 0x828D1888; continue 'dispatch;
	}
	// 828D1880: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D1884: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D1888: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D188C: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D1890: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D1894: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D1898: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828D189C: 419A0020  beq cr6, 0x828d18bc
	if ctx.cr[6].eq {
	pc = 0x828D18BC; continue 'dispatch;
	}
	// 828D18A0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D18A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D18A8: 7D605028  lwarx r11, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D18AC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828D18B0: 7D60512D  stwcx. r11, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D18B4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D18B8: 4082FFE8  bne 0x828d18a0
	if !ctx.cr[0].eq {
	pc = 0x828D18A0; continue 'dispatch;
	}
	// 828D18BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D18C0: 419A00D4  beq cr6, 0x828d1994
	if ctx.cr[6].eq {
	pc = 0x828D1994; continue 'dispatch;
	}
	// 828D18C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D18C8: 4BFFC249  bl 0x828cdb10
	ctx.lr = 0x828D18CC;
	sub_828CDB10(ctx, base);
	// 828D18CC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828D18D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D18D4: 419A00C0  beq cr6, 0x828d1994
	if ctx.cr[6].eq {
	pc = 0x828D1994; continue 'dispatch;
	}
	// 828D18D8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D18DC: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D18E0: 409A00B4  bne cr6, 0x828d1994
	if !ctx.cr[6].eq {
	pc = 0x828D1994; continue 'dispatch;
	}
	// 828D18E4: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D18E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D18EC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D18F0: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D18F4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D18F8: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D18FC: 4B992B8D  bl 0x82264488
	ctx.lr = 0x828D1900;
	sub_82264488(ctx, base);
	// 828D1900: 8103002C  lwz r8, 0x2c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D1904: 5507EFFE  rlwinm r7, r8, 0x1d, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x00000007u64;
	// 828D1908: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D190C: 419A0078  beq cr6, 0x828d1984
	if ctx.cr[6].eq {
	pc = 0x828D1984; continue 'dispatch;
	}
	// 828D1910: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D1914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D1918: 409A0064  bne cr6, 0x828d197c
	if !ctx.cr[6].eq {
	pc = 0x828D197C; continue 'dispatch;
	}
	// 828D191C: 8163004C  lwz r11, 0x4c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D1920: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D1924: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828D1928: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D192C: 40810050  ble 0x828d197c
	if !ctx.cr[0].gt {
	pc = 0x828D197C; continue 'dispatch;
	}
	// 828D1930: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D1934: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D1938: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D193C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1940: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 828D1944: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D1948: 41980008  blt cr6, 0x828d1950
	if ctx.cr[6].lt {
	pc = 0x828D1950; continue 'dispatch;
	}
	// 828D194C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828D1950: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D1954: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D1958: 419A0014  beq cr6, 0x828d196c
	if ctx.cr[6].eq {
	pc = 0x828D196C; continue 'dispatch;
	}
	// 828D195C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D1960: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D1964: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D1968: 4800000C  b 0x828d1974
	pc = 0x828D1974; continue 'dispatch;
	// 828D196C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D1970: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D1974: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D1978: 4199FFB8  bgt cr6, 0x828d1930
	if ctx.cr[6].gt {
	pc = 0x828D1930; continue 'dispatch;
	}
	// 828D197C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D1980: 48000008  b 0x828d1988
	pc = 0x828D1988; continue 'dispatch;
	// 828D1984: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828D1988: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D198C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D1990: 409A0034  bne cr6, 0x828d19c4
	if !ctx.cr[6].eq {
	pc = 0x828D19C4; continue 'dispatch;
	}
	// 828D1994: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1998: 4B8E6181  bl 0x821b7b18
	ctx.lr = 0x828D199C;
	sub_821B7B18(ctx, base);
	// 828D199C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D19A0: 409A0008  bne cr6, 0x828d19a8
	if !ctx.cr[6].eq {
	pc = 0x828D19A8; continue 'dispatch;
	}
	// 828D19A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D19A8: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D19AC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D19B0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D19B4: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828D19B8: 409AFE7C  bne cr6, 0x828d1834
	if !ctx.cr[6].eq {
	pc = 0x828D1834; continue 'dispatch;
	}
	// 828D19BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D19C0: 4BFFFE74  b 0x828d1834
	pc = 0x828D1834; continue 'dispatch;
	// 828D19C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D19C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D19CC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D19D0: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D19D4: 91590004  stw r10, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D19D8: 4B8E6141  bl 0x821b7b18
	ctx.lr = 0x828D19DC;
	sub_821B7B18(ctx, base);
	// 828D19DC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828D19E0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828D19E4: 483D7A64  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 828D19E8: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828D19EC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828D19F0: F9790000  std r11, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828D19F4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828D19F8: 483D7A50  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D1A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D1A00 size=2096
    let mut pc: u32 = 0x828D1A00;
    'dispatch: loop {
        match pc {
            0x828D1A00 => {
    //   block [0x828D1A00..0x828D2230)
	// 828D1A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D1A04: 483D79E5  bl 0x82ca93e8
	ctx.lr = 0x828D1A08;
	sub_82CA93D0(ctx, base);
	// 828D1A08: DBE1FF90  stfd f31, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 828D1A0C: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D1A10: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 828D1A14: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828D1A18: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 828D1A1C: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828D1A20: 409A0804  bne cr6, 0x828d2224
	if !ctx.cr[6].eq {
	pc = 0x828D2224; continue 'dispatch;
	}
	// 828D1A24: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D1A28: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D1A2C: 388B3650  addi r4, r11, 0x3650
	ctx.r[4].s64 = ctx.r[11].s64 + 13904;
	// 828D1A30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1A34: 4B95B49D  bl 0x8222ced0
	ctx.lr = 0x828D1A38;
	sub_8222CED0(ctx, base);
	// 828D1A38: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D1A3C: 3A8BFFDF  addi r20, r11, -0x21
	ctx.r[20].s64 = ctx.r[11].s64 + -33;
	// 828D1A40: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828D1A44: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D1A48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D1A4C: 419A0008  beq cr6, 0x828d1a54
	if ctx.cr[6].eq {
	pc = 0x828D1A54; continue 'dispatch;
	}
	// 828D1A50: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1A54: 38B50024  addi r5, r21, 0x24
	ctx.r[5].s64 = ctx.r[21].s64 + 36;
	// 828D1A58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D1A5C: 4BBAED6D  bl 0x824807c8
	ctx.lr = 0x828D1A60;
	sub_824807C8(ctx, base);
	// 828D1A60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1A64: 4B943375  bl 0x82214dd8
	ctx.lr = 0x828D1A68;
	sub_82214DD8(ctx, base);
	// 828D1A68: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D1A6C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D1A70: 388B3668  addi r4, r11, 0x3668
	ctx.r[4].s64 = ctx.r[11].s64 + 13928;
	// 828D1A74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1A78: 4B95B459  bl 0x8222ced0
	ctx.lr = 0x828D1A7C;
	sub_8222CED0(ctx, base);
	// 828D1A7C: 38B5005C  addi r5, r21, 0x5c
	ctx.r[5].s64 = ctx.r[21].s64 + 92;
	// 828D1A80: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D1A84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1A88: 4814B461  bl 0x82a1cee8
	ctx.lr = 0x828D1A8C;
	sub_82A1CEE8(ctx, base);
	// 828D1A8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1A90: 4B943349  bl 0x82214dd8
	ctx.lr = 0x828D1A94;
	sub_82214DD8(ctx, base);
	// 828D1A94: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828D1A98: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D1A9C: 388A3678  addi r4, r10, 0x3678
	ctx.r[4].s64 = ctx.r[10].s64 + 13944;
	// 828D1AA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1AA4: 4B95B42D  bl 0x8222ced0
	ctx.lr = 0x828D1AA8;
	sub_8222CED0(ctx, base);
	// 828D1AA8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D1AAC: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828D1AB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D1AB4: 419A0008  beq cr6, 0x828d1abc
	if ctx.cr[6].eq {
	pc = 0x828D1ABC; continue 'dispatch;
	}
	// 828D1AB8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1ABC: 38B50030  addi r5, r21, 0x30
	ctx.r[5].s64 = ctx.r[21].s64 + 48;
	// 828D1AC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D1AC4: 4BBAED8D  bl 0x82480850
	ctx.lr = 0x828D1AC8;
	sub_82480850(ctx, base);
	// 828D1AC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1ACC: 4B94330D  bl 0x82214dd8
	ctx.lr = 0x828D1AD0;
	sub_82214DD8(ctx, base);
	// 828D1AD0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D1AD4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D1AD8: 388B3690  addi r4, r11, 0x3690
	ctx.r[4].s64 = ctx.r[11].s64 + 13968;
	// 828D1ADC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1AE0: 4B95B3F1  bl 0x8222ced0
	ctx.lr = 0x828D1AE4;
	sub_8222CED0(ctx, base);
	// 828D1AE4: 38B50060  addi r5, r21, 0x60
	ctx.r[5].s64 = ctx.r[21].s64 + 96;
	// 828D1AE8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D1AEC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1AF0: 4814B359  bl 0x82a1ce48
	ctx.lr = 0x828D1AF4;
	sub_82A1CE48(ctx, base);
	// 828D1AF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1AF8: 4B9432E1  bl 0x82214dd8
	ctx.lr = 0x828D1AFC;
	sub_82214DD8(ctx, base);
	// 828D1AFC: 56CA063E  clrlwi r10, r22, 0x18
	ctx.r[10].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	// 828D1B00: 3B950018  addi r28, r21, 0x18
	ctx.r[28].s64 = ctx.r[21].s64 + 24;
	// 828D1B04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D1B08: 419A0358  beq cr6, 0x828d1e60
	if ctx.cr[6].eq {
	pc = 0x828D1E60; continue 'dispatch;
	}
	// 828D1B0C: 8175001C  lwz r11, 0x1c(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D1B10: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 828D1B14: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1B18: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D1B1C: 3B6B36A4  addi r27, r11, 0x36a4
	ctx.r[27].s64 = ctx.r[11].s64 + 13988;
	// 828D1B20: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828D1B24: E9210068  ld r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828D1B28: F9210068  std r9, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 828D1B2C: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828D1B30: 83C1006C  lwz r30, 0x6c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828D1B34: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1B38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D1B3C: 419A000C  beq cr6, 0x828d1b48
	if ctx.cr[6].eq {
	pc = 0x828D1B48; continue 'dispatch;
	}
	// 828D1B40: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828D1B44: 419A0008  beq cr6, 0x828d1b4c
	if ctx.cr[6].eq {
	pc = 0x828D1B4C; continue 'dispatch;
	}
	// 828D1B48: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D1B4C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D1B50: 419A0074  beq cr6, 0x828d1bc4
	if ctx.cr[6].eq {
	pc = 0x828D1BC4; continue 'dispatch;
	}
	// 828D1B54: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1B58: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D1B5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D1B60: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1B64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828D1B68: 4E800421  bctrl
	ctx.lr = 0x828D1B6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D1B6C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D1B70: 409A0008  bne cr6, 0x828d1b78
	if !ctx.cr[6].eq {
	pc = 0x828D1B78; continue 'dispatch;
	}
	// 828D1B74: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D1B78: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1B7C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D1B80: 409A0008  bne cr6, 0x828d1b88
	if !ctx.cr[6].eq {
	pc = 0x828D1B88; continue 'dispatch;
	}
	// 828D1B84: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D1B88: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 828D1B8C: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D1B90: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D1B94: 4BFFC585  bl 0x828ce118
	ctx.lr = 0x828D1B98;
	sub_828CE118(ctx, base);
	// 828D1B98: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1B9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D1BA0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D1BA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828D1BA8: 4E800421  bctrl
	ctx.lr = 0x828D1BAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D1BAC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1BB0: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D1BB4: 409A0008  bne cr6, 0x828d1bbc
	if !ctx.cr[6].eq {
	pc = 0x828D1BBC; continue 'dispatch;
	}
	// 828D1BB8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D1BBC: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1BC0: 4BFFFF74  b 0x828d1b34
	pc = 0x828D1B34; continue 'dispatch;
	// 828D1BC4: 81750010  lwz r11, 0x10(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D1BC8: 3B35000C  addi r25, r21, 0xc
	ctx.r[25].s64 = ctx.r[21].s64 + 12;
	// 828D1BCC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828D1BD0: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 828D1BD4: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828D1BD8: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828D1BDC: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 828D1BE0: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1BE4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828D1BE8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828D1BEC: 3B8B7088  addi r28, r11, 0x7088
	ctx.r[28].s64 = ctx.r[11].s64 + 28808;
	// 828D1BF0: 3B4A4A80  addi r26, r10, 0x4a80
	ctx.r[26].s64 = ctx.r[10].s64 + 19072;
	// 828D1BF4: 3B0936C8  addi r24, r9, 0x36c8
	ctx.r[24].s64 = ctx.r[9].s64 + 14024;
	// 828D1BF8: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 828D1BFC: 3AE836B8  addi r23, r8, 0x36b8
	ctx.r[23].s64 = ctx.r[8].s64 + 14008;
	// 828D1C00: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1C04: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D1C08: 419A000C  beq cr6, 0x828d1c14
	if ctx.cr[6].eq {
	pc = 0x828D1C14; continue 'dispatch;
	}
	// 828D1C0C: 7F1FC840  cmplw cr6, r31, r25
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[25].u32, &mut ctx.xer);
	// 828D1C10: 419A0008  beq cr6, 0x828d1c18
	if ctx.cr[6].eq {
	pc = 0x828D1C18; continue 'dispatch;
	}
	// 828D1C14: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D1C18: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D1C1C: 419A0158  beq cr6, 0x828d1d74
	if ctx.cr[6].eq {
	pc = 0x828D1D74; continue 'dispatch;
	}
	// 828D1C20: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1C24: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 828D1C28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D1C2C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1C30: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828D1C34: 4E800421  bctrl
	ctx.lr = 0x828D1C38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D1C38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D1C3C: 409A0008  bne cr6, 0x828d1c44
	if !ctx.cr[6].eq {
	pc = 0x828D1C44; continue 'dispatch;
	}
	// 828D1C40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D1C44: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1C48: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D1C4C: 409A0008  bne cr6, 0x828d1c54
	if !ctx.cr[6].eq {
	pc = 0x828D1C54; continue 'dispatch;
	}
	// 828D1C50: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D1C54: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D1C58: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828D1C5C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1C60: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828D1C64: 409A0008  bne cr6, 0x828d1c6c
	if !ctx.cr[6].eq {
	pc = 0x828D1C6C; continue 'dispatch;
	}
	// 828D1C68: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D1C6C: 389B0010  addi r4, r27, 0x10
	ctx.r[4].s64 = ctx.r[27].s64 + 16;
	// 828D1C70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1C74: 4B91E5CD  bl 0x821f0240
	ctx.lr = 0x828D1C78;
	sub_821F0240(ctx, base);
	// 828D1C78: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828D1C7C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D1C80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1C84: 4B95B24D  bl 0x8222ced0
	ctx.lr = 0x828D1C88;
	sub_8222CED0(ctx, base);
	// 828D1C88: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D1C8C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828D1C90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D1C94: 419A0008  beq cr6, 0x828d1c9c
	if ctx.cr[6].eq {
	pc = 0x828D1C9C; continue 'dispatch;
	}
	// 828D1C98: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1C9C: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 828D1CA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D1CA4: 4BABE3E5  bl 0x82390088
	ctx.lr = 0x828D1CA8;
	sub_82390088(ctx, base);
	// 828D1CA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1CAC: 4B8F4ABD  bl 0x821c6768
	ctx.lr = 0x828D1CB0;
	sub_821C6768(ctx, base);
	// 828D1CB0: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 828D1CB4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D1CB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D1CBC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D1CC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D1CC4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D1CC8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D1CCC: 4082FFE8  bne 0x828d1cb4
	if !ctx.cr[0].eq {
	pc = 0x828D1CB4; continue 'dispatch;
	}
	// 828D1CD0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828D1CD4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828D1CD8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D1CDC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D1CE0: 4B95B1F1  bl 0x8222ced0
	ctx.lr = 0x828D1CE4;
	sub_8222CED0(ctx, base);
	// 828D1CE4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828D1CE8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D1CEC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D1CF0: 4814B1F9  bl 0x82a1cee8
	ctx.lr = 0x828D1CF4;
	sub_82A1CEE8(ctx, base);
	// 828D1CF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D1CF8: 4B8F4A71  bl 0x821c6768
	ctx.lr = 0x828D1CFC;
	sub_821C6768(ctx, base);
	// 828D1CFC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828D1D00: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 828D1D04: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D1D08: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 828D1D0C: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 828D1D10: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D1D14: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D1D18: 4082FFE8  bne 0x828d1d00
	if !ctx.cr[0].eq {
	pc = 0x828D1D00; continue 'dispatch;
	}
	// 828D1D1C: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1D20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D1D24: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828D1D28: 8085000C  lwz r4, 0xc(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D1D2C: 7C8903A6  mtctr r4
	ctx.ctr.u64 = ctx.r[4].u64;
	// 828D1D30: 4E800421  bctrl
	ctx.lr = 0x828D1D34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D1D34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1D38: 4B8F4A31  bl 0x821c6768
	ctx.lr = 0x828D1D3C;
	sub_821C6768(ctx, base);
	// 828D1D3C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 828D1D40: 7D6000A6  mfmsr r11
	ctx.r[11].u64 = ctx.msr;
	// 828D1D44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D1D48: 7C605028  lwarx r3, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[3].u64 = ctx.reserved.u32 as u64;
	// 828D1D4C: 3863FFFF  addi r3, r3, -1
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	// 828D1D50: 7C60512D  stwcx. r3, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[3].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D1D54: 7D610164  mtmsrd r11, 1
	ctx.msr = (ctx.r[11].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D1D58: 4082FFE8  bne 0x828d1d40
	if !ctx.cr[0].eq {
	pc = 0x828D1D40; continue 'dispatch;
	}
	// 828D1D5C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828D1D60: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 828D1D64: 4BC84AF5  bl 0x82556858
	ctx.lr = 0x828D1D68;
	sub_82556858(ctx, base);
	// 828D1D68: 8361006C  lwz r27, 0x6c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828D1D6C: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828D1D70: 4BFFFE90  b 0x828d1c00
	pc = 0x828D1C00; continue 'dispatch;
	// 828D1D74: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828D1D78: 483F4F09  bl 0x82cc6c80
	ctx.lr = 0x828D1D7C;
	sub_82CC6C80(ctx, base);
	// 828D1D7C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828D1D80: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828D1D84: 483F55ED  bl 0x82cc7370
	ctx.lr = 0x828D1D88;
	sub_82CC7370(ctx, base);
	// 828D1D88: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828D1D8C: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828D1D90: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D1D94: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D1D98: 388B36D0  addi r4, r11, 0x36d0
	ctx.r[4].s64 = ctx.r[11].s64 + 14032;
	// 828D1D9C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1DA0: 91550074  stw r10, 0x74(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 828D1DA4: 3BF50074  addi r31, r21, 0x74
	ctx.r[31].s64 = ctx.r[21].s64 + 116;
	// 828D1DA8: 91350070  stw r9, 0x70(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 828D1DAC: 3BD50070  addi r30, r21, 0x70
	ctx.r[30].s64 = ctx.r[21].s64 + 112;
	// 828D1DB0: 4B95B121  bl 0x8222ced0
	ctx.lr = 0x828D1DB4;
	sub_8222CED0(ctx, base);
	// 828D1DB4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D1DB8: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828D1DBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D1DC0: 419A0008  beq cr6, 0x828d1dc8
	if ctx.cr[6].eq {
	pc = 0x828D1DC8; continue 'dispatch;
	}
	// 828D1DC4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1DC8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D1DCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D1DD0: 4BABE2B9  bl 0x82390088
	ctx.lr = 0x828D1DD4;
	sub_82390088(ctx, base);
	// 828D1DD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1DD8: 4B8F4991  bl 0x821c6768
	ctx.lr = 0x828D1DDC;
	sub_821C6768(ctx, base);
	// 828D1DDC: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 828D1DE0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D1DE4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D1DE8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D1DEC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D1DF0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D1DF4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D1DF8: 4082FFE8  bne 0x828d1de0
	if !ctx.cr[0].eq {
	pc = 0x828D1DE0; continue 'dispatch;
	}
	// 828D1DFC: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828D1E00: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D1E04: 388836E4  addi r4, r8, 0x36e4
	ctx.r[4].s64 = ctx.r[8].s64 + 14052;
	// 828D1E08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1E0C: 4B95B0C5  bl 0x8222ced0
	ctx.lr = 0x828D1E10;
	sub_8222CED0(ctx, base);
	// 828D1E10: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D1E14: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828D1E18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D1E1C: 419A0008  beq cr6, 0x828d1e24
	if ctx.cr[6].eq {
	pc = 0x828D1E24; continue 'dispatch;
	}
	// 828D1E20: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1E24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D1E28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D1E2C: 4BABE25D  bl 0x82390088
	ctx.lr = 0x828D1E30;
	sub_82390088(ctx, base);
	// 828D1E30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1E34: 4B8F4935  bl 0x821c6768
	ctx.lr = 0x828D1E38;
	sub_821C6768(ctx, base);
	// 828D1E38: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D1E3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D1E40: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D1E44: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D1E48: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D1E4C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D1E50: 4082FFE8  bne 0x828d1e38
	if !ctx.cr[0].eq {
	pc = 0x828D1E38; continue 'dispatch;
	}
	// 828D1E54: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 828D1E58: CBE1FF90  lfd f31, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 828D1E5C: 483D75DC  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
	// 828D1E60: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D1E64: 4BECEFB5  bl 0x827a0e18
	ctx.lr = 0x828D1E68;
	sub_827A0E18(ctx, base);
	// 828D1E68: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D1E6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D1E70: 3B6B36A4  addi r27, r11, 0x36a4
	ctx.r[27].s64 = ctx.r[11].s64 + 13988;
	// 828D1E74: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D1E78: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1E7C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D1E80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828D1E84: 4E800421  bctrl
	ctx.lr = 0x828D1E88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D1E88: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828D1E8C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D1E90: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828D1E94: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D1E98: 3AEB0CA0  addi r23, r11, 0xca0
	ctx.r[23].s64 = ctx.r[11].s64 + 3232;
	// 828D1E9C: 419A0170  beq cr6, 0x828d200c
	if ctx.cr[6].eq {
	pc = 0x828D200C; continue 'dispatch;
	}
	// 828D1EA0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828D1EA4: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 828D1EA8: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 828D1EAC: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 828D1EB0: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 828D1EB4: C3EB9484  lfs f31, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D1EB8: 38600044  li r3, 0x44
	ctx.r[3].s64 = 68;
	// 828D1EBC: 4B94D405  bl 0x8221f2c0
	ctx.lr = 0x828D1EC0;
	sub_8221F2C0(ctx, base);
	// 828D1EC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D1EC4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D1EC8: 409A0060  bne cr6, 0x828d1f28
	if !ctx.cr[6].eq {
	pc = 0x828D1F28; continue 'dispatch;
	}
	// 828D1ECC: 81796F6C  lwz r11, 0x6f6c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28524 as u32) ) } as u64;
	// 828D1ED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D1ED4: 419A0014  beq cr6, 0x828d1ee8
	if ctx.cr[6].eq {
	pc = 0x828D1EE8; continue 'dispatch;
	}
	// 828D1ED8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828D1EDC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D1EE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D1EE4: 4E800421  bctrl
	ctx.lr = 0x828D1EE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D1EE8: 483F04C1  bl 0x82cc23a8
	ctx.lr = 0x828D1EEC;
	sub_82CC23A8(ctx, base);
	// 828D1EEC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 828D1EF0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828D1EF4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D1EF8: 419A00A8  beq cr6, 0x828d1fa0
	if ctx.cr[6].eq {
	pc = 0x828D1FA0; continue 'dispatch;
	}
	// 828D1EFC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D1F00: 4B94D359  bl 0x8221f258
	ctx.lr = 0x828D1F04;
	sub_8221F258(ctx, base);
	// 828D1F04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D1F08: 419A0098  beq cr6, 0x828d1fa0
	if ctx.cr[6].eq {
	pc = 0x828D1FA0; continue 'dispatch;
	}
	// 828D1F0C: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D1F10: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828D1F14: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 828D1F18: 394B5960  addi r10, r11, 0x5960
	ctx.r[10].s64 = ctx.r[11].s64 + 22880;
	// 828D1F1C: 93030000  stw r24, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 828D1F20: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D1F24: 48000080  b 0x828d1fa4
	pc = 0x828D1FA4; continue 'dispatch;
	// 828D1F28: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828D1F2C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 828D1F30: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828D1F34: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D1F38: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 828D1F3C: 4B95AF95  bl 0x8222ced0
	ctx.lr = 0x828D1F40;
	sub_8222CED0(ctx, base);
	// 828D1F40: 817A6AB8  lwz r11, 0x6ab8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D1F44: D3FF0040  stfs f31, 0x40(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 828D1F48: 9BDF000C  stb r30, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u8 ) };
	// 828D1F4C: 9BDF000D  stb r30, 0xd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(13 as u32), ctx.r[30].u8 ) };
	// 828D1F50: 9BDF000E  stb r30, 0xe(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(14 as u32), ctx.r[30].u8 ) };
	// 828D1F54: 9BDF000F  stb r30, 0xf(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(15 as u32), ctx.r[30].u8 ) };
	// 828D1F58: 9BDF0012  stb r30, 0x12(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[30].u8 ) };
	// 828D1F5C: 9BDF0013  stb r30, 0x13(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(19 as u32), ctx.r[30].u8 ) };
	// 828D1F60: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 828D1F64: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 828D1F68: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 828D1F6C: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 828D1F70: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 828D1F74: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 828D1F78: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 828D1F7C: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 828D1F80: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 828D1F84: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D1F88: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D1F8C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1F90: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D1F94: 80E80008  lwz r7, 8(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D1F98: 90FF0028  stw r7, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[7].u32 ) };
	// 828D1F9C: 4BFFFF54  b 0x828d1ef0
	pc = 0x828D1EF0; continue 'dispatch;
	// 828D1FA0: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 828D1FA4: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 828D1FA8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D1FAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D1FB0: 4BFFC169  bl 0x828ce118
	ctx.lr = 0x828D1FB4;
	sub_828CE118(ctx, base);
	// 828D1FB4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D1FB8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828D1FBC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D1FC0: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828D1FC4: E8810070  ld r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828D1FC8: 4BD4BB21  bl 0x8261dae8
	ctx.lr = 0x828D1FCC;
	sub_8261DAE8(ctx, base);
	// 828D1FCC: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1FD0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D1FD4: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D1FD8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828D1FDC: 4E800421  bctrl
	ctx.lr = 0x828D1FE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D1FE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1FE4: 4B8E5B35  bl 0x821b7b18
	ctx.lr = 0x828D1FE8;
	sub_821B7B18(ctx, base);
	// 828D1FE8: 811D0000  lwz r8, 0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1FEC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D1FF0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D1FF4: 80E80008  lwz r7, 8(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D1FF8: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 828D1FFC: 4E800421  bctrl
	ctx.lr = 0x828D2000;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D2000: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828D2004: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 828D2008: 409AFEB0  bne cr6, 0x828d1eb8
	if !ctx.cr[6].eq {
	pc = 0x828D1EB8; continue 'dispatch;
	}
	// 828D200C: 3B75000C  addi r27, r21, 0xc
	ctx.r[27].s64 = ctx.r[21].s64 + 12;
	// 828D2010: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D2014: 4BC15D8D  bl 0x824e7da0
	ctx.lr = 0x828D2018;
	sub_824E7DA0(ctx, base);
	// 828D2018: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D201C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D2020: 3B4B36B8  addi r26, r11, 0x36b8
	ctx.r[26].s64 = ctx.r[11].s64 + 14008;
	// 828D2024: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828D2028: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D202C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D2030: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828D2034: 4E800421  bctrl
	ctx.lr = 0x828D2038;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D2038: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828D203C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D2040: 419A0154  beq cr6, 0x828d2194
	if ctx.cr[6].eq {
	pc = 0x828D2194; continue 'dispatch;
	}
	// 828D2044: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828D2048: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828D204C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D2050: 3BE97088  addi r31, r9, 0x7088
	ctx.r[31].s64 = ctx.r[9].s64 + 28808;
	// 828D2054: 3B8A4A80  addi r28, r10, 0x4a80
	ctx.r[28].s64 = ctx.r[10].s64 + 19072;
	// 828D2058: 3B2B36C8  addi r25, r11, 0x36c8
	ctx.r[25].s64 = ctx.r[11].s64 + 14024;
	// 828D205C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828D2060: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 828D2064: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D2068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D206C: 4B95AE65  bl 0x8222ced0
	ctx.lr = 0x828D2070;
	sub_8222CED0(ctx, base);
	// 828D2070: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828D2074: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D2078: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D207C: 4B95AE55  bl 0x8222ced0
	ctx.lr = 0x828D2080;
	sub_8222CED0(ctx, base);
	// 828D2080: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D2084: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828D2088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D208C: 419A0008  beq cr6, 0x828d2094
	if ctx.cr[6].eq {
	pc = 0x828D2094; continue 'dispatch;
	}
	// 828D2090: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2094: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828D2098: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D209C: 4BABDFED  bl 0x82390088
	ctx.lr = 0x828D20A0;
	sub_82390088(ctx, base);
	// 828D20A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D20A4: 4B8F46C5  bl 0x821c6768
	ctx.lr = 0x828D20A8;
	sub_821C6768(ctx, base);
	// 828D20A8: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 828D20AC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D20B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D20B4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D20B8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D20BC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D20C0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D20C4: 4082FFE8  bne 0x828d20ac
	if !ctx.cr[0].eq {
	pc = 0x828D20AC; continue 'dispatch;
	}
	// 828D20C8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828D20CC: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 828D20D0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D20D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D20D8: 4B95ADF9  bl 0x8222ced0
	ctx.lr = 0x828D20DC;
	sub_8222CED0(ctx, base);
	// 828D20DC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D20E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D20E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D20E8: 4814AE01  bl 0x82a1cee8
	ctx.lr = 0x828D20EC;
	sub_82A1CEE8(ctx, base);
	// 828D20EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D20F0: 4B8F4679  bl 0x821c6768
	ctx.lr = 0x828D20F4;
	sub_821C6768(ctx, base);
	// 828D20F4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828D20F8: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 828D20FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D2100: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 828D2104: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 828D2108: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D210C: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D2110: 4082FFE8  bne 0x828d20f8
	if !ctx.cr[0].eq {
	pc = 0x828D20F8; continue 'dispatch;
	}
	// 828D2114: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828D2118: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828D211C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D2120: 3B010050  addi r24, r1, 0x50
	ctx.r[24].s64 = ctx.r[1].s64 + 80;
	// 828D2124: 4BA4EFD5  bl 0x823210f8
	ctx.lr = 0x828D2128;
	sub_823210F8(ctx, base);
	// 828D2128: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828D212C: 4B993075  bl 0x822651a0
	ctx.lr = 0x828D2130;
	sub_822651A0(ctx, base);
	// 828D2130: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2134: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D2138: 8085000C  lwz r4, 0xc(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D213C: 7C8903A6  mtctr r4
	ctx.ctr.u64 = ctx.r[4].u64;
	// 828D2140: 4E800421  bctrl
	ctx.lr = 0x828D2144;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D2144: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D2148: 4B8F4621  bl 0x821c6768
	ctx.lr = 0x828D214C;
	sub_821C6768(ctx, base);
	// 828D214C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828D2150: 7D6000A6  mfmsr r11
	ctx.r[11].u64 = ctx.msr;
	// 828D2154: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D2158: 7C605028  lwarx r3, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[3].u64 = ctx.reserved.u32 as u64;
	// 828D215C: 3863FFFF  addi r3, r3, -1
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	// 828D2160: 7C60512D  stwcx. r3, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[3].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D2164: 7D610164  mtmsrd r11, 1
	ctx.msr = (ctx.r[11].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D2168: 4082FFE8  bne 0x828d2150
	if !ctx.cr[0].eq {
	pc = 0x828D2150; continue 'dispatch;
	}
	// 828D216C: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2170: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828D2174: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828D2178: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D217C: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D2180: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828D2184: 4E800421  bctrl
	ctx.lr = 0x828D2188;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D2188: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828D218C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D2190: 409AFECC  bne cr6, 0x828d205c
	if !ctx.cr[6].eq {
	pc = 0x828D205C; continue 'dispatch;
	}
	// 828D2194: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D2198: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D219C: 388B36D0  addi r4, r11, 0x36d0
	ctx.r[4].s64 = ctx.r[11].s64 + 14032;
	// 828D21A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D21A4: 4B95AD2D  bl 0x8222ced0
	ctx.lr = 0x828D21A8;
	sub_8222CED0(ctx, base);
	// 828D21A8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D21AC: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828D21B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D21B4: 419A0008  beq cr6, 0x828d21bc
	if ctx.cr[6].eq {
	pc = 0x828D21BC; continue 'dispatch;
	}
	// 828D21B8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D21BC: 3BD50074  addi r30, r21, 0x74
	ctx.r[30].s64 = ctx.r[21].s64 + 116;
	// 828D21C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D21C4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D21C8: 4BABDEC1  bl 0x82390088
	ctx.lr = 0x828D21CC;
	sub_82390088(ctx, base);
	// 828D21CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D21D0: 4B942C09  bl 0x82214dd8
	ctx.lr = 0x828D21D4;
	sub_82214DD8(ctx, base);
	// 828D21D4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D21D8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D21DC: 388B36E4  addi r4, r11, 0x36e4
	ctx.r[4].s64 = ctx.r[11].s64 + 14052;
	// 828D21E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D21E4: 4B95ACED  bl 0x8222ced0
	ctx.lr = 0x828D21E8;
	sub_8222CED0(ctx, base);
	// 828D21E8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D21EC: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828D21F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D21F4: 419A0008  beq cr6, 0x828d21fc
	if ctx.cr[6].eq {
	pc = 0x828D21FC; continue 'dispatch;
	}
	// 828D21F8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D21FC: 38B50070  addi r5, r21, 0x70
	ctx.r[5].s64 = ctx.r[21].s64 + 112;
	// 828D2200: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D2204: 4BABDE85  bl 0x82390088
	ctx.lr = 0x828D2208;
	sub_82390088(ctx, base);
	// 828D2208: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D220C: 4B942BCD  bl 0x82214dd8
	ctx.lr = 0x828D2210;
	sub_82214DD8(ctx, base);
	// 828D2210: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2214: 81550070  lwz r10, 0x70(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(112 as u32) ) } as u64;
	// 828D2218: 796907E6  rldicr r9, r11, 0x20, 0x3f
	ctx.r[9].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 828D221C: 7D285378  or r8, r9, r10
	ctx.r[8].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 828D2220: F9150068  std r8, 0x68(r21)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[21].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 828D2224: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 828D2228: CBE1FF90  lfd f31, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 828D222C: 483D720C  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D2230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D2230 size=84
    let mut pc: u32 = 0x828D2230;
    'dispatch: loop {
        match pc {
            0x828D2230 => {
    //   block [0x828D2230..0x828D2284)
	// 828D2230: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D2234: 38C30018  addi r6, r3, 0x18
	ctx.r[6].s64 = ctx.r[3].s64 + 24;
	// 828D2238: E9440014  ld r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	// 828D223C: 90C1FFF0  stw r6, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[6].u32 ) };
	// 828D2240: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2244: F941FFF8  std r10, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[10].u64 ) };
	// 828D2248: 8061FFFC  lwz r3, -4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) } as u64;
	// 828D224C: 8081FFF8  lwz r4, -8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D2250: 9121FFF4  stw r9, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[9].u32 ) };
	// 828D2254: E901FFF0  ld r8, -0x10(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D2258: F901FFF0  std r8, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[8].u64 ) };
	// 828D225C: 80E1FFF0  lwz r7, -0x10(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828D2260: 8121FFF4  lwz r9, -0xc(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 828D2264: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2268: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D226C: 419A000C  beq cr6, 0x828d2278
	if ctx.cr[6].eq {
	pc = 0x828D2278; continue 'dispatch;
	}
	// 828D2270: 7F073040  cmplw cr6, r7, r6
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D2274: 419A0008  beq cr6, 0x828d227c
	if ctx.cr[6].eq {
	pc = 0x828D227C; continue 'dispatch;
	}
	// 828D2278: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D227C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D2280: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D2284(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D2284 size=116
    let mut pc: u32 = 0x828D2284;
    'dispatch: loop {
        match pc {
            0x828D2284 => {
    //   block [0x828D2284..0x828D22F8)
	// 828D2284: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D2288: 409A0008  bne cr6, 0x828d2290
	if !ctx.cr[6].eq {
	pc = 0x828D2290; continue 'dispatch;
	}
	// 828D228C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2290: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2294: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828D2298: 409A0008  bne cr6, 0x828d22a0
	if !ctx.cr[6].eq {
	pc = 0x828D22A0; continue 'dispatch;
	}
	// 828D229C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D22A0: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D22A4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D22A8: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D22AC: 409A0014  bne cr6, 0x828d22c0
	if !ctx.cr[6].eq {
	pc = 0x828D22C0; continue 'dispatch;
	}
	// 828D22B0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D22B4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D22B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D22BC: 419A0008  beq cr6, 0x828d22c4
	if ctx.cr[6].eq {
	pc = 0x828D22C4; continue 'dispatch;
	}
	// 828D22C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D22C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D22C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D22CC: 419A0014  beq cr6, 0x828d22e0
	if ctx.cr[6].eq {
	pc = 0x828D22E0; continue 'dispatch;
	}
	// 828D22D0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828D22D4: 409A0008  bne cr6, 0x828d22dc
	if !ctx.cr[6].eq {
	pc = 0x828D22DC; continue 'dispatch;
	}
	// 828D22D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D22DC: 98AA000C  stb r5, 0xc(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[5].u8 ) };
	// 828D22E0: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D22E4: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D22E8: 409A0008  bne cr6, 0x828d22f0
	if !ctx.cr[6].eq {
	pc = 0x828D22F0; continue 'dispatch;
	}
	// 828D22EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D22F0: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D22F4: 4BFFFF70  b 0x828d2264
	sub_828D2230(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D22F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D22F8 size=4
    let mut pc: u32 = 0x828D22F8;
    'dispatch: loop {
        match pc {
            0x828D22F8 => {
    //   block [0x828D22F8..0x828D22FC)
	// 828D22F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D2300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D2300 size=84
    let mut pc: u32 = 0x828D2300;
    'dispatch: loop {
        match pc {
            0x828D2300 => {
    //   block [0x828D2300..0x828D2354)
	// 828D2300: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D2304: 38C30018  addi r6, r3, 0x18
	ctx.r[6].s64 = ctx.r[3].s64 + 24;
	// 828D2308: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 828D230C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D2310: 90C1FFF0  stw r6, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[6].u32 ) };
	// 828D2314: 8061001C  lwz r3, 0x1c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D2318: 80A10018  lwz r5, 0x18(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) } as u64;
	// 828D231C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2320: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 828D2324: E921FFF0  ld r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D2328: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 828D232C: 80E1FFF0  lwz r7, -0x10(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828D2330: 8121FFF4  lwz r9, -0xc(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 828D2334: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2338: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D233C: 419A000C  beq cr6, 0x828d2348
	if ctx.cr[6].eq {
	pc = 0x828D2348; continue 'dispatch;
	}
	// 828D2340: 7F073040  cmplw cr6, r7, r6
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D2344: 419A0008  beq cr6, 0x828d234c
	if ctx.cr[6].eq {
	pc = 0x828D234C; continue 'dispatch;
	}
	// 828D2348: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D234C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D2350: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D2354(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D2354 size=116
    let mut pc: u32 = 0x828D2354;
    'dispatch: loop {
        match pc {
            0x828D2354 => {
    //   block [0x828D2354..0x828D23C8)
	// 828D2354: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D2358: 409A0008  bne cr6, 0x828d2360
	if !ctx.cr[6].eq {
	pc = 0x828D2360; continue 'dispatch;
	}
	// 828D235C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2360: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2364: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828D2368: 409A0008  bne cr6, 0x828d2370
	if !ctx.cr[6].eq {
	pc = 0x828D2370; continue 'dispatch;
	}
	// 828D236C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2370: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D2374: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2378: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D237C: 409A0014  bne cr6, 0x828d2390
	if !ctx.cr[6].eq {
	pc = 0x828D2390; continue 'dispatch;
	}
	// 828D2380: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2384: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D2388: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D238C: 419A0008  beq cr6, 0x828d2394
	if ctx.cr[6].eq {
	pc = 0x828D2394; continue 'dispatch;
	}
	// 828D2390: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828D2394: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D2398: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D239C: 419A0014  beq cr6, 0x828d23b0
	if ctx.cr[6].eq {
	pc = 0x828D23B0; continue 'dispatch;
	}
	// 828D23A0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828D23A4: 409A0008  bne cr6, 0x828d23ac
	if !ctx.cr[6].eq {
	pc = 0x828D23AC; continue 'dispatch;
	}
	// 828D23A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D23AC: 988A000C  stb r4, 0xc(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[4].u8 ) };
	// 828D23B0: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D23B4: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D23B8: 409A0008  bne cr6, 0x828d23c0
	if !ctx.cr[6].eq {
	pc = 0x828D23C0; continue 'dispatch;
	}
	// 828D23BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D23C0: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D23C4: 4BFFFF70  b 0x828d2334
	sub_828D2300(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D23C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D23C8 size=4
    let mut pc: u32 = 0x828D23C8;
    'dispatch: loop {
        match pc {
            0x828D23C8 => {
    //   block [0x828D23C8..0x828D23CC)
	// 828D23C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D23D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D23D0 size=900
    let mut pc: u32 = 0x828D23D0;
    'dispatch: loop {
        match pc {
            0x828D23D0 => {
    //   block [0x828D23D0..0x828D2754)
	// 828D23D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D23D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D23D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D23DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D23E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D23E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D23E8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828D23EC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828D23F0: 419A0018  beq cr6, 0x828d2408
	if ctx.cr[6].eq {
	pc = 0x828D2408; continue 'dispatch;
	}
	// 828D23F4: 89650090  lbz r11, 0x90(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D23F8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D23FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D2400: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D2404: 409A0008  bne cr6, 0x828d240c
	if !ctx.cr[6].eq {
	pc = 0x828D240C; continue 'dispatch;
	}
	// 828D2408: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828D240C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D2410: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2414: 409A0174  bne cr6, 0x828d2588
	if !ctx.cr[6].eq {
	pc = 0x828D2588; continue 'dispatch;
	}
	// 828D2418: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D241C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D2420: 4BFFF3B1  bl 0x828d17d0
	ctx.lr = 0x828D2424;
	sub_828D17D0(ctx, base);
	// 828D2424: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D2428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D242C: 409A0014  bne cr6, 0x828d2440
	if !ctx.cr[6].eq {
	pc = 0x828D2440; continue 'dispatch;
	}
	// 828D2430: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D2434: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2438: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828D243C: 419A0008  beq cr6, 0x828d2444
	if ctx.cr[6].eq {
	pc = 0x828D2444; continue 'dispatch;
	}
	// 828D2440: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D2444: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D2448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D244C: 419A02F0  beq cr6, 0x828d273c
	if ctx.cr[6].eq {
	pc = 0x828D273C; continue 'dispatch;
	}
	// 828D2450: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828D2454: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D2458: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D245C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D2460: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D2464: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2468: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D246C: 4B99201D  bl 0x82264488
	ctx.lr = 0x828D2470;
	sub_82264488(ctx, base);
	// 828D2470: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D2474: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828D2478: 419A02C4  beq cr6, 0x828d273c
	if ctx.cr[6].eq {
	pc = 0x828D273C; continue 'dispatch;
	}
	// 828D247C: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 828D2480: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828D2484: 554937FE  rlwinm r9, r10, 6, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x03FFFFFFu64;
	// 828D2488: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D248C: 419A00E8  beq cr6, 0x828d2574
	if ctx.cr[6].eq {
	pc = 0x828D2574; continue 'dispatch;
	}
	// 828D2490: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D2494: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2498: 419A0020  beq cr6, 0x828d24b8
	if ctx.cr[6].eq {
	pc = 0x828D24B8; continue 'dispatch;
	}
	// 828D249C: 894B001A  lbz r10, 0x1a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(26 as u32) ) } as u64;
	// 828D24A0: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D24A4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D24A8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D24AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D24B0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D24B4: 480000C4  b 0x828d2578
	pc = 0x828D2578; continue 'dispatch;
	// 828D24B8: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D24BC: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D24C0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828D24C4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D24C8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D24CC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D24D0: 40810054  ble 0x828d2524
	if !ctx.cr[0].gt {
	pc = 0x828D2524; continue 'dispatch;
	}
	// 828D24D4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D24D8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D24DC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D24E0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D24E4: 2F07001A  cmpwi cr6, r7, 0x1a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 26, &mut ctx.xer);
	// 828D24E8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D24EC: 41980008  blt cr6, 0x828d24f4
	if ctx.cr[6].lt {
	pc = 0x828D24F4; continue 'dispatch;
	}
	// 828D24F0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828D24F4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D24F8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D24FC: 419A0014  beq cr6, 0x828d2510
	if ctx.cr[6].eq {
	pc = 0x828D2510; continue 'dispatch;
	}
	// 828D2500: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D2504: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D2508: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D250C: 4800000C  b 0x828d2518
	pc = 0x828D2518; continue 'dispatch;
	// 828D2510: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D2514: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D2518: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D251C: 4199FFB8  bgt cr6, 0x828d24d4
	if ctx.cr[6].gt {
	pc = 0x828D24D4; continue 'dispatch;
	}
	// 828D2520: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D2524: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D2528: 419A003C  beq cr6, 0x828d2564
	if ctx.cr[6].eq {
	pc = 0x828D2564; continue 'dispatch;
	}
	// 828D252C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2530: 2F0B001A  cmpwi cr6, r11, 0x1a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 26, &mut ctx.xer);
	// 828D2534: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D2538: 41990008  bgt cr6, 0x828d2540
	if ctx.cr[6].gt {
	pc = 0x828D2540; continue 'dispatch;
	}
	// 828D253C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828D2540: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D2544: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2548: 409A001C  bne cr6, 0x828d2564
	if !ctx.cr[6].eq {
	pc = 0x828D2564; continue 'dispatch;
	}
	// 828D254C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D2550: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D2554: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D2558: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D255C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2560: 48000018  b 0x828d2578
	pc = 0x828D2578; continue 'dispatch;
	// 828D2564: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D2568: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D256C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2570: 48000008  b 0x828d2578
	pc = 0x828D2578; continue 'dispatch;
	// 828D2574: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828D2578: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D257C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D2580: 419A01BC  beq cr6, 0x828d273c
	if ctx.cr[6].eq {
	pc = 0x828D273C; continue 'dispatch;
	}
	// 828D2584: 480001B0  b 0x828d2734
	pc = 0x828D2734; continue 'dispatch;
	// 828D2588: E9650014  ld r11, 0x14(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) };
	// 828D258C: 39030018  addi r8, r3, 0x18
	ctx.r[8].s64 = ctx.r[3].s64 + 24;
	// 828D2590: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D2594: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 828D2598: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D259C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D25A0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D25A4: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D25A8: 7F084040  cmplw cr6, r8, r8
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828D25AC: 419A0008  beq cr6, 0x828d25b4
	if ctx.cr[6].eq {
	pc = 0x828D25B4; continue 'dispatch;
	}
	// 828D25B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D25B4: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D25B8: 419A0184  beq cr6, 0x828d273c
	if ctx.cr[6].eq {
	pc = 0x828D273C; continue 'dispatch;
	}
	// 828D25BC: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D25C0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D25C4: 409A0008  bne cr6, 0x828d25cc
	if !ctx.cr[6].eq {
	pc = 0x828D25CC; continue 'dispatch;
	}
	// 828D25C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D25CC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D25D0: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D25D4: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828D25D8: 409A0014  bne cr6, 0x828d25ec
	if !ctx.cr[6].eq {
	pc = 0x828D25EC; continue 'dispatch;
	}
	// 828D25DC: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D25E0: 7F035040  cmplw cr6, r3, r10
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828D25E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D25E8: 419A0008  beq cr6, 0x828d25f0
	if ctx.cr[6].eq {
	pc = 0x828D25F0; continue 'dispatch;
	}
	// 828D25EC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828D25F0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D25F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D25F8: 409A0018  bne cr6, 0x828d2610
	if !ctx.cr[6].eq {
	pc = 0x828D2610; continue 'dispatch;
	}
	// 828D25FC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D2600: 409A0008  bne cr6, 0x828d2608
	if !ctx.cr[6].eq {
	pc = 0x828D2608; continue 'dispatch;
	}
	// 828D2604: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2608: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D260C: 4BFFFF9C  b 0x828d25a8
	pc = 0x828D25A8; continue 'dispatch;
	// 828D2610: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2614: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828D2618: 409A0008  bne cr6, 0x828d2620
	if !ctx.cr[6].eq {
	pc = 0x828D2620; continue 'dispatch;
	}
	// 828D261C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2620: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D2624: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 828D2628: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828D262C: 992A000C  stb r9, 0xc(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[9].u8 ) };
	// 828D2630: 811F0024  lwz r8, 0x24(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 828D2634: 550737FE  rlwinm r7, r8, 6, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x03FFFFFFu64;
	// 828D2638: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D263C: 419A00E4  beq cr6, 0x828d2720
	if ctx.cr[6].eq {
	pc = 0x828D2720; continue 'dispatch;
	}
	// 828D2640: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D2644: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D2648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D264C: 419A001C  beq cr6, 0x828d2668
	if ctx.cr[6].eq {
	pc = 0x828D2668; continue 'dispatch;
	}
	// 828D2650: 896B001A  lbz r11, 0x1a(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(26 as u32) ) } as u64;
	// 828D2654: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828D2658: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828D265C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2660: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D2664: 480000C0  b 0x828d2724
	pc = 0x828D2724; continue 'dispatch;
	// 828D2668: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D266C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828D2670: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D2674: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D2678: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D267C: 40810054  ble 0x828d26d0
	if !ctx.cr[0].gt {
	pc = 0x828D26D0; continue 'dispatch;
	}
	// 828D2680: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D2684: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D2688: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D268C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2690: 2F07001A  cmpwi cr6, r7, 0x1a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 26, &mut ctx.xer);
	// 828D2694: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D2698: 41980008  blt cr6, 0x828d26a0
	if ctx.cr[6].lt {
	pc = 0x828D26A0; continue 'dispatch;
	}
	// 828D269C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828D26A0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D26A4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D26A8: 419A0014  beq cr6, 0x828d26bc
	if ctx.cr[6].eq {
	pc = 0x828D26BC; continue 'dispatch;
	}
	// 828D26AC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D26B0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D26B4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D26B8: 4800000C  b 0x828d26c4
	pc = 0x828D26C4; continue 'dispatch;
	// 828D26BC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D26C0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D26C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D26C8: 4199FFB8  bgt cr6, 0x828d2680
	if ctx.cr[6].gt {
	pc = 0x828D2680; continue 'dispatch;
	}
	// 828D26CC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D26D0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D26D4: 419A003C  beq cr6, 0x828d2710
	if ctx.cr[6].eq {
	pc = 0x828D2710; continue 'dispatch;
	}
	// 828D26D8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D26DC: 2F0B001A  cmpwi cr6, r11, 0x1a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 26, &mut ctx.xer);
	// 828D26E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D26E4: 41990008  bgt cr6, 0x828d26ec
	if ctx.cr[6].gt {
	pc = 0x828D26EC; continue 'dispatch;
	}
	// 828D26E8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828D26EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D26F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D26F4: 409A001C  bne cr6, 0x828d2710
	if !ctx.cr[6].eq {
	pc = 0x828D2710; continue 'dispatch;
	}
	// 828D26F8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D26FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D2700: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D2704: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D2708: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D270C: 48000018  b 0x828d2724
	pc = 0x828D2724; continue 'dispatch;
	// 828D2710: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D2714: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D2718: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D271C: 48000008  b 0x828d2724
	pc = 0x828D2724; continue 'dispatch;
	// 828D2720: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828D2724: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D2728: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D272C: 419A0010  beq cr6, 0x828d273c
	if ctx.cr[6].eq {
	pc = 0x828D273C; continue 'dispatch;
	}
	// 828D2730: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828D2734: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D2738: 4BF07051  bl 0x827d9788
	ctx.lr = 0x828D273C;
	sub_827D9788(ctx, base);
	// 828D273C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D2740: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D2744: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D2748: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D274C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D2750: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D2758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D2758 size=132
    let mut pc: u32 = 0x828D2758;
    'dispatch: loop {
        match pc {
            0x828D2758 => {
    //   block [0x828D2758..0x828D27DC)
	// 828D2758: E9640014  ld r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	// 828D275C: 39030018  addi r8, r3, 0x18
	ctx.r[8].s64 = ctx.r[3].s64 + 24;
	// 828D2760: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D2764: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 828D2768: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 828D276C: 80C1FFF4  lwz r6, -0xc(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 828D2770: 80E1FFF0  lwz r7, -0x10(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828D2774: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2778: 7F084040  cmplw cr6, r8, r8
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828D277C: 419A0008  beq cr6, 0x828d2784
	if ctx.cr[6].eq {
	pc = 0x828D2784; continue 'dispatch;
	}
	// 828D2780: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2784: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828D2788: 419A0070  beq cr6, 0x828d27f8
	if ctx.cr[6].eq {
		sub_828D27F8(ctx, base);
		return;
	}
	// 828D278C: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2790: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D2794: 409A0008  bne cr6, 0x828d279c
	if !ctx.cr[6].eq {
	pc = 0x828D279C; continue 'dispatch;
	}
	// 828D2798: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D279C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D27A0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D27A4: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828D27A8: 409A0014  bne cr6, 0x828d27bc
	if !ctx.cr[6].eq {
	pc = 0x828D27BC; continue 'dispatch;
	}
	// 828D27AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D27B0: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D27B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D27B8: 419A0008  beq cr6, 0x828d27c0
	if ctx.cr[6].eq {
	pc = 0x828D27C0; continue 'dispatch;
	}
	// 828D27BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D27C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D27C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D27C8: 409A0014  bne cr6, 0x828d27dc
	if !ctx.cr[6].eq {
		sub_828D27DC(ctx, base);
		return;
	}
	// 828D27CC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D27D0: 409AFFA4  bne cr6, 0x828d2774
	if !ctx.cr[6].eq {
	pc = 0x828D2774; continue 'dispatch;
	}
	// 828D27D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D27D8: 4BFFFF9C  b 0x828d2774
	pc = 0x828D2774; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D27DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D27DC size=28
    let mut pc: u32 = 0x828D27DC;
    'dispatch: loop {
        match pc {
            0x828D27DC => {
    //   block [0x828D27DC..0x828D27F8)
	// 828D27DC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D27E0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D27E4: 409A0008  bne cr6, 0x828d27ec
	if !ctx.cr[6].eq {
	pc = 0x828D27EC; continue 'dispatch;
	}
	// 828D27E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D27EC: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D27F0: 886B000C  lbz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D27F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D27F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D27F8 size=8
    let mut pc: u32 = 0x828D27F8;
    'dispatch: loop {
        match pc {
            0x828D27F8 => {
    //   block [0x828D27F8..0x828D2800)
	// 828D27F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828D27FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D2800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D2800 size=176
    let mut pc: u32 = 0x828D2800;
    'dispatch: loop {
        match pc {
            0x828D2800 => {
    //   block [0x828D2800..0x828D28B0)
	// 828D2800: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828D2804: 419A0018  beq cr6, 0x828d281c
	if ctx.cr[6].eq {
	pc = 0x828D281C; continue 'dispatch;
	}
	// 828D2808: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D280C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D2810: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D2814: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D2818: 409A0008  bne cr6, 0x828d2820
	if !ctx.cr[6].eq {
	pc = 0x828D2820; continue 'dispatch;
	}
	// 828D281C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D2820: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D2824: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2828: 419A00A4  beq cr6, 0x828d28cc
	if ctx.cr[6].eq {
		sub_828D28CC(ctx, base);
		return;
	}
	// 828D282C: E9640014  ld r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	// 828D2830: 39030018  addi r8, r3, 0x18
	ctx.r[8].s64 = ctx.r[3].s64 + 24;
	// 828D2834: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D2838: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 828D283C: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 828D2840: 80A1FFF4  lwz r5, -0xc(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 828D2844: 80E1FFF0  lwz r7, -0x10(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828D2848: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D284C: 7F084040  cmplw cr6, r8, r8
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828D2850: 419A0008  beq cr6, 0x828d2858
	if ctx.cr[6].eq {
	pc = 0x828D2858; continue 'dispatch;
	}
	// 828D2854: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2858: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D285C: 419A0070  beq cr6, 0x828d28cc
	if ctx.cr[6].eq {
		sub_828D28CC(ctx, base);
		return;
	}
	// 828D2860: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2864: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D2868: 409A0008  bne cr6, 0x828d2870
	if !ctx.cr[6].eq {
	pc = 0x828D2870; continue 'dispatch;
	}
	// 828D286C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2870: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D2874: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2878: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828D287C: 409A0014  bne cr6, 0x828d2890
	if !ctx.cr[6].eq {
	pc = 0x828D2890; continue 'dispatch;
	}
	// 828D2880: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2884: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D2888: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D288C: 419A0008  beq cr6, 0x828d2894
	if ctx.cr[6].eq {
	pc = 0x828D2894; continue 'dispatch;
	}
	// 828D2890: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D2894: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D2898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D289C: 409A0014  bne cr6, 0x828d28b0
	if !ctx.cr[6].eq {
		sub_828D28B0(ctx, base);
		return;
	}
	// 828D28A0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D28A4: 409AFFA4  bne cr6, 0x828d2848
	if !ctx.cr[6].eq {
	pc = 0x828D2848; continue 'dispatch;
	}
	// 828D28A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D28AC: 4BFFFF9C  b 0x828d2848
	pc = 0x828D2848; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D28B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D28B0 size=28
    let mut pc: u32 = 0x828D28B0;
    'dispatch: loop {
        match pc {
            0x828D28B0 => {
    //   block [0x828D28B0..0x828D28CC)
	// 828D28B0: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D28B4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D28B8: 409A0008  bne cr6, 0x828d28c0
	if !ctx.cr[6].eq {
	pc = 0x828D28C0; continue 'dispatch;
	}
	// 828D28BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D28C0: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D28C4: 886B000D  lbz r3, 0xd(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(13 as u32) ) } as u64;
	// 828D28C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D28CC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D28CC size=8
    let mut pc: u32 = 0x828D28CC;
    'dispatch: loop {
        match pc {
            0x828D28CC => {
    //   block [0x828D28CC..0x828D28D4)
	// 828D28CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828D28D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D28D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D28D8 size=280
    let mut pc: u32 = 0x828D28D8;
    'dispatch: loop {
        match pc {
            0x828D28D8 => {
    //   block [0x828D28D8..0x828D29F0)
	// 828D28D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D28DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D28E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D28E4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D28E8: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D28EC: 38C30018  addi r6, r3, 0x18
	ctx.r[6].s64 = ctx.r[3].s64 + 24;
	// 828D28F0: E9440014  ld r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	// 828D28F4: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 828D28F8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D28FC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2900: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 828D2904: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D2908: 80E10058  lwz r7, 0x58(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D290C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828D2910: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D2914: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 828D2918: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D291C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D2920: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828D2924: 419A000C  beq cr6, 0x828d2930
	if ctx.cr[6].eq {
	pc = 0x828D2930; continue 'dispatch;
	}
	// 828D2928: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D292C: 419A0008  beq cr6, 0x828d2934
	if ctx.cr[6].eq {
	pc = 0x828D2934; continue 'dispatch;
	}
	// 828D2930: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2934: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828D2938: 419A00A4  beq cr6, 0x828d29dc
	if ctx.cr[6].eq {
	pc = 0x828D29DC; continue 'dispatch;
	}
	// 828D293C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828D2940: 409A0008  bne cr6, 0x828d2948
	if !ctx.cr[6].eq {
	pc = 0x828D2948; continue 'dispatch;
	}
	// 828D2944: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2948: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D294C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D2950: 409A0008  bne cr6, 0x828d2958
	if !ctx.cr[6].eq {
	pc = 0x828D2958; continue 'dispatch;
	}
	// 828D2954: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2958: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D295C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2960: 7F07F840  cmplw cr6, r7, r31
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828D2964: 409A0014  bne cr6, 0x828d2978
	if !ctx.cr[6].eq {
	pc = 0x828D2978; continue 'dispatch;
	}
	// 828D2968: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D296C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D2970: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D2974: 419A0008  beq cr6, 0x828d297c
	if ctx.cr[6].eq {
	pc = 0x828D297C; continue 'dispatch;
	}
	// 828D2978: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D297C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D2980: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2984: 409A0018  bne cr6, 0x828d299c
	if !ctx.cr[6].eq {
	pc = 0x828D299C; continue 'dispatch;
	}
	// 828D2988: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D298C: 409A0008  bne cr6, 0x828d2994
	if !ctx.cr[6].eq {
	pc = 0x828D2994; continue 'dispatch;
	}
	// 828D2990: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2994: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2998: 4BFFFF88  b 0x828d2920
	pc = 0x828D2920; continue 'dispatch;
	// 828D299C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D29A0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D29A4: 409A0008  bne cr6, 0x828d29ac
	if !ctx.cr[6].eq {
	pc = 0x828D29AC; continue 'dispatch;
	}
	// 828D29A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D29AC: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D29B0: 54AA063E  clrlwi r10, r5, 0x18
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 828D29B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D29B8: 98AB000D  stb r5, 0xd(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(13 as u32), ctx.r[5].u8 ) };
	// 828D29BC: 419A0020  beq cr6, 0x828d29dc
	if ctx.cr[6].eq {
	pc = 0x828D29DC; continue 'dispatch;
	}
	// 828D29C0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828D29C4: 38800038  li r4, 0x38
	ctx.r[4].s64 = 56;
	// 828D29C8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D29CC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D29D0: 812A00A8  lwz r9, 0xa8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(168 as u32) ) } as u64;
	// 828D29D4: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D29D8: 4B8E2889  bl 0x821b5260
	ctx.lr = 0x828D29DC;
	sub_821B5260(ctx, base);
	// 828D29DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D29E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D29E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D29E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D29EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D29F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D29F0 size=216
    let mut pc: u32 = 0x828D29F0;
    'dispatch: loop {
        match pc {
            0x828D29F0 => {
    //   block [0x828D29F0..0x828D2AC8)
	// 828D29F0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 828D29F4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D29F8: 38C30018  addi r6, r3, 0x18
	ctx.r[6].s64 = ctx.r[3].s64 + 24;
	// 828D29FC: E9440014  ld r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	// 828D2A00: 90C1FFE0  stw r6, -0x20(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[6].u32 ) };
	// 828D2A04: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D2A08: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2A0C: F941FFE8  std r10, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[10].u64 ) };
	// 828D2A10: 8081FFEC  lwz r4, -0x14(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 828D2A14: 80E1FFE8  lwz r7, -0x18(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) } as u64;
	// 828D2A18: 9121FFE4  stw r9, -0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), ctx.r[9].u32 ) };
	// 828D2A1C: E901FFE0  ld r8, -0x20(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828D2A20: F901FFE0  std r8, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[8].u64 ) };
	// 828D2A24: 8101FFE0  lwz r8, -0x20(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) } as u64;
	// 828D2A28: 8141FFE4  lwz r10, -0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-28 as u32) ) } as u64;
	// 828D2A2C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828D2A30: 419A000C  beq cr6, 0x828d2a3c
	if ctx.cr[6].eq {
	pc = 0x828D2A3C; continue 'dispatch;
	}
	// 828D2A34: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D2A38: 419A0008  beq cr6, 0x828d2a40
	if ctx.cr[6].eq {
	pc = 0x828D2A40; continue 'dispatch;
	}
	// 828D2A3C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2A40: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828D2A44: 419A007C  beq cr6, 0x828d2ac0
	if ctx.cr[6].eq {
	pc = 0x828D2AC0; continue 'dispatch;
	}
	// 828D2A48: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828D2A4C: 409A0008  bne cr6, 0x828d2a54
	if !ctx.cr[6].eq {
	pc = 0x828D2A54; continue 'dispatch;
	}
	// 828D2A50: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2A54: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2A58: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D2A5C: 409A0008  bne cr6, 0x828d2a64
	if !ctx.cr[6].eq {
	pc = 0x828D2A64; continue 'dispatch;
	}
	// 828D2A60: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2A64: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D2A68: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2A6C: 7F07F840  cmplw cr6, r7, r31
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828D2A70: 409A0014  bne cr6, 0x828d2a84
	if !ctx.cr[6].eq {
	pc = 0x828D2A84; continue 'dispatch;
	}
	// 828D2A74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2A78: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D2A7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D2A80: 419A0008  beq cr6, 0x828d2a88
	if ctx.cr[6].eq {
	pc = 0x828D2A88; continue 'dispatch;
	}
	// 828D2A84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D2A88: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D2A8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2A90: 409A0018  bne cr6, 0x828d2aa8
	if !ctx.cr[6].eq {
	pc = 0x828D2AA8; continue 'dispatch;
	}
	// 828D2A94: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D2A98: 409A0008  bne cr6, 0x828d2aa0
	if !ctx.cr[6].eq {
	pc = 0x828D2AA0; continue 'dispatch;
	}
	// 828D2A9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2AA0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2AA4: 4BFFFF88  b 0x828d2a2c
	pc = 0x828D2A2C; continue 'dispatch;
	// 828D2AA8: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2AAC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D2AB0: 409A0008  bne cr6, 0x828d2ab8
	if !ctx.cr[6].eq {
	pc = 0x828D2AB8; continue 'dispatch;
	}
	// 828D2AB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2AB8: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D2ABC: 90AB001C  stw r5, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[5].u32 ) };
	// 828D2AC0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 828D2AC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D2AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D2AC8 size=216
    let mut pc: u32 = 0x828D2AC8;
    'dispatch: loop {
        match pc {
            0x828D2AC8 => {
    //   block [0x828D2AC8..0x828D2BA0)
	// 828D2AC8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 828D2ACC: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D2AD0: 38C30018  addi r6, r3, 0x18
	ctx.r[6].s64 = ctx.r[3].s64 + 24;
	// 828D2AD4: E9440014  ld r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	// 828D2AD8: 90C1FFE0  stw r6, -0x20(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[6].u32 ) };
	// 828D2ADC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D2AE0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2AE4: F941FFE8  std r10, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[10].u64 ) };
	// 828D2AE8: 8081FFEC  lwz r4, -0x14(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 828D2AEC: 80E1FFE8  lwz r7, -0x18(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) } as u64;
	// 828D2AF0: 9121FFE4  stw r9, -0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), ctx.r[9].u32 ) };
	// 828D2AF4: E901FFE0  ld r8, -0x20(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828D2AF8: F901FFE0  std r8, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[8].u64 ) };
	// 828D2AFC: 8101FFE0  lwz r8, -0x20(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) } as u64;
	// 828D2B00: 8141FFE4  lwz r10, -0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-28 as u32) ) } as u64;
	// 828D2B04: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828D2B08: 419A000C  beq cr6, 0x828d2b14
	if ctx.cr[6].eq {
	pc = 0x828D2B14; continue 'dispatch;
	}
	// 828D2B0C: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D2B10: 419A0008  beq cr6, 0x828d2b18
	if ctx.cr[6].eq {
	pc = 0x828D2B18; continue 'dispatch;
	}
	// 828D2B14: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2B18: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828D2B1C: 419A007C  beq cr6, 0x828d2b98
	if ctx.cr[6].eq {
	pc = 0x828D2B98; continue 'dispatch;
	}
	// 828D2B20: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828D2B24: 409A0008  bne cr6, 0x828d2b2c
	if !ctx.cr[6].eq {
	pc = 0x828D2B2C; continue 'dispatch;
	}
	// 828D2B28: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2B2C: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2B30: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D2B34: 409A0008  bne cr6, 0x828d2b3c
	if !ctx.cr[6].eq {
	pc = 0x828D2B3C; continue 'dispatch;
	}
	// 828D2B38: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2B3C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D2B40: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2B44: 7F07F840  cmplw cr6, r7, r31
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828D2B48: 409A0014  bne cr6, 0x828d2b5c
	if !ctx.cr[6].eq {
	pc = 0x828D2B5C; continue 'dispatch;
	}
	// 828D2B4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2B50: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D2B54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D2B58: 419A0008  beq cr6, 0x828d2b60
	if ctx.cr[6].eq {
	pc = 0x828D2B60; continue 'dispatch;
	}
	// 828D2B5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D2B60: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D2B64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2B68: 409A0018  bne cr6, 0x828d2b80
	if !ctx.cr[6].eq {
	pc = 0x828D2B80; continue 'dispatch;
	}
	// 828D2B6C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D2B70: 409A0008  bne cr6, 0x828d2b78
	if !ctx.cr[6].eq {
	pc = 0x828D2B78; continue 'dispatch;
	}
	// 828D2B74: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2B78: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2B7C: 4BFFFF88  b 0x828d2b04
	pc = 0x828D2B04; continue 'dispatch;
	// 828D2B80: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2B84: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D2B88: 409A0008  bne cr6, 0x828d2b90
	if !ctx.cr[6].eq {
	pc = 0x828D2B90; continue 'dispatch;
	}
	// 828D2B8C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2B90: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D2B94: 90AB003C  stw r5, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[5].u32 ) };
	// 828D2B98: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 828D2B9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D2BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D2BA0 size=1060
    let mut pc: u32 = 0x828D2BA0;
    'dispatch: loop {
        match pc {
            0x828D2BA0 => {
    //   block [0x828D2BA0..0x828D2FC4)
	// 828D2BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D2BA4: 483D6855  bl 0x82ca93f8
	ctx.lr = 0x828D2BA8;
	sub_82CA93D0(ctx, base);
	// 828D2BA8: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 828D2BAC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D2BB0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828D2BB4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828D2BB8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828D2BBC: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828D2BC0: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 828D2BC4: 817A002C  lwz r11, 0x2c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D2BC8: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828D2BCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D2BD0: 419A00F4  beq cr6, 0x828d2cc4
	if ctx.cr[6].eq {
	pc = 0x828D2CC4; continue 'dispatch;
	}
	// 828D2BD4: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D2BD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2BDC: 419A0024  beq cr6, 0x828d2c00
	if ctx.cr[6].eq {
	pc = 0x828D2C00; continue 'dispatch;
	}
	// 828D2BE0: 894B0043  lbz r10, 0x43(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(67 as u32) ) } as u64;
	// 828D2BE4: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D2BE8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D2BEC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D2BF0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2BF4: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 828D2BF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D2BFC: 480000CC  b 0x828d2cc8
	pc = 0x828D2CC8; continue 'dispatch;
	// 828D2C00: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D2C04: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D2C08: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 828D2C0C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D2C10: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828D2C14: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D2C18: 40810054  ble 0x828d2c6c
	if !ctx.cr[0].gt {
	pc = 0x828D2C6C; continue 'dispatch;
	}
	// 828D2C1C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D2C20: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D2C24: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D2C28: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2C2C: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 828D2C30: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D2C34: 41980008  blt cr6, 0x828d2c3c
	if ctx.cr[6].lt {
	pc = 0x828D2C3C; continue 'dispatch;
	}
	// 828D2C38: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828D2C3C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D2C40: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D2C44: 419A0014  beq cr6, 0x828d2c58
	if ctx.cr[6].eq {
	pc = 0x828D2C58; continue 'dispatch;
	}
	// 828D2C48: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D2C4C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D2C50: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D2C54: 4800000C  b 0x828d2c60
	pc = 0x828D2C60; continue 'dispatch;
	// 828D2C58: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D2C5C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D2C60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D2C64: 4199FFB8  bgt cr6, 0x828d2c1c
	if ctx.cr[6].gt {
	pc = 0x828D2C1C; continue 'dispatch;
	}
	// 828D2C68: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828D2C6C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D2C70: 419A0040  beq cr6, 0x828d2cb0
	if ctx.cr[6].eq {
	pc = 0x828D2CB0; continue 'dispatch;
	}
	// 828D2C74: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2C78: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 828D2C7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D2C80: 41990008  bgt cr6, 0x828d2c88
	if ctx.cr[6].gt {
	pc = 0x828D2C88; continue 'dispatch;
	}
	// 828D2C84: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828D2C88: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D2C8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2C90: 409A0020  bne cr6, 0x828d2cb0
	if !ctx.cr[6].eq {
	pc = 0x828D2CB0; continue 'dispatch;
	}
	// 828D2C94: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828D2C98: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828D2C9C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D2CA0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2CA4: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 828D2CA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D2CAC: 4800001C  b 0x828d2cc8
	pc = 0x828D2CC8; continue 'dispatch;
	// 828D2CB0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D2CB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2CB8: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 828D2CBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D2CC0: 48000008  b 0x828d2cc8
	pc = 0x828D2CC8; continue 'dispatch;
	// 828D2CC4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828D2CC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D2CCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2CD0: 419A02E8  beq cr6, 0x828d2fb8
	if ctx.cr[6].eq {
	pc = 0x828D2FB8; continue 'dispatch;
	}
	// 828D2CD4: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2CD8: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 828D2CDC: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828D2CE0: 55493FFE  rlwinm r9, r10, 7, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x01FFFFFFu64;
	// 828D2CE4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D2CE8: 419A00F4  beq cr6, 0x828d2ddc
	if ctx.cr[6].eq {
	pc = 0x828D2DDC; continue 'dispatch;
	}
	// 828D2CEC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D2CF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D2CF4: 419A0024  beq cr6, 0x828d2d18
	if ctx.cr[6].eq {
	pc = 0x828D2D18; continue 'dispatch;
	}
	// 828D2CF8: 894A0039  lbz r10, 0x39(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(57 as u32) ) } as u64;
	// 828D2CFC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D2D00: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D2D04: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D2D08: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2D0C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 828D2D10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D2D14: 480000CC  b 0x828d2de0
	pc = 0x828D2DE0; continue 'dispatch;
	// 828D2D18: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D2D1C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D2D20: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 828D2D24: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D2D28: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828D2D2C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D2D30: 40810054  ble 0x828d2d84
	if !ctx.cr[0].gt {
	pc = 0x828D2D84; continue 'dispatch;
	}
	// 828D2D34: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D2D38: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D2D3C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D2D40: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2D44: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 828D2D48: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D2D4C: 41980008  blt cr6, 0x828d2d54
	if ctx.cr[6].lt {
	pc = 0x828D2D54; continue 'dispatch;
	}
	// 828D2D50: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828D2D54: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D2D58: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D2D5C: 419A0014  beq cr6, 0x828d2d70
	if ctx.cr[6].eq {
	pc = 0x828D2D70; continue 'dispatch;
	}
	// 828D2D60: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D2D64: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D2D68: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D2D6C: 4800000C  b 0x828d2d78
	pc = 0x828D2D78; continue 'dispatch;
	// 828D2D70: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D2D74: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D2D78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D2D7C: 4199FFB8  bgt cr6, 0x828d2d34
	if ctx.cr[6].gt {
	pc = 0x828D2D34; continue 'dispatch;
	}
	// 828D2D80: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828D2D84: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D2D88: 419A0040  beq cr6, 0x828d2dc8
	if ctx.cr[6].eq {
	pc = 0x828D2DC8; continue 'dispatch;
	}
	// 828D2D8C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2D90: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 828D2D94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D2D98: 41990008  bgt cr6, 0x828d2da0
	if ctx.cr[6].gt {
	pc = 0x828D2DA0; continue 'dispatch;
	}
	// 828D2D9C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828D2DA0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D2DA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2DA8: 409A0020  bne cr6, 0x828d2dc8
	if !ctx.cr[6].eq {
	pc = 0x828D2DC8; continue 'dispatch;
	}
	// 828D2DAC: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828D2DB0: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828D2DB4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D2DB8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2DBC: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 828D2DC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D2DC4: 4800001C  b 0x828d2de0
	pc = 0x828D2DE0; continue 'dispatch;
	// 828D2DC8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D2DCC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2DD0: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 828D2DD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D2DD8: 48000008  b 0x828d2de0
	pc = 0x828D2DE0; continue 'dispatch;
	// 828D2DDC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828D2DE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D2DE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2DE8: 419A0120  beq cr6, 0x828d2f08
	if ctx.cr[6].eq {
	pc = 0x828D2F08; continue 'dispatch;
	}
	// 828D2DEC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828D2DF0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D2DF4: C02B9484  lfs f1, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D2DF8: 4BC03DE9  bl 0x824d6be0
	ctx.lr = 0x828D2DFC;
	sub_824D6BE0(ctx, base);
	// 828D2DFC: 8158001C  lwz r10, 0x1c(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D2E00: 3BB80018  addi r29, r24, 0x18
	ctx.r[29].s64 = ctx.r[24].s64 + 24;
	// 828D2E04: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828D2E08: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2E0C: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 828D2E10: E9010058  ld r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828D2E14: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 828D2E18: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D2E1C: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D2E20: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2E24: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D2E28: 419A000C  beq cr6, 0x828d2e34
	if ctx.cr[6].eq {
	pc = 0x828D2E34; continue 'dispatch;
	}
	// 828D2E2C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828D2E30: 419A0008  beq cr6, 0x828d2e38
	if ctx.cr[6].eq {
	pc = 0x828D2E38; continue 'dispatch;
	}
	// 828D2E34: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2E38: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D2E3C: 419A00CC  beq cr6, 0x828d2f08
	if ctx.cr[6].eq {
	pc = 0x828D2F08; continue 'dispatch;
	}
	// 828D2E40: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D2E44: 409A0008  bne cr6, 0x828d2e4c
	if !ctx.cr[6].eq {
	pc = 0x828D2E4C; continue 'dispatch;
	}
	// 828D2E48: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2E4C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2E50: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D2E54: 409A0008  bne cr6, 0x828d2e5c
	if !ctx.cr[6].eq {
	pc = 0x828D2E5C; continue 'dispatch;
	}
	// 828D2E58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2E5C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D2E60: 817A0014  lwz r11, 0x14(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D2E64: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2E68: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828D2E6C: 409A0018  bne cr6, 0x828d2e84
	if !ctx.cr[6].eq {
	pc = 0x828D2E84; continue 'dispatch;
	}
	// 828D2E70: 817A0018  lwz r11, 0x18(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 828D2E74: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2E78: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828D2E7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D2E80: 419A0008  beq cr6, 0x828d2e88
	if ctx.cr[6].eq {
	pc = 0x828D2E88; continue 'dispatch;
	}
	// 828D2E84: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828D2E88: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D2E8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2E90: 419A0060  beq cr6, 0x828d2ef0
	if ctx.cr[6].eq {
	pc = 0x828D2EF0; continue 'dispatch;
	}
	// 828D2E94: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D2E98: 409A0008  bne cr6, 0x828d2ea0
	if !ctx.cr[6].eq {
	pc = 0x828D2EA0; continue 'dispatch;
	}
	// 828D2E9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2EA0: 896A000E  lbz r11, 0xe(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(14 as u32) ) } as u64;
	// 828D2EA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2EA8: 419A0030  beq cr6, 0x828d2ed8
	if ctx.cr[6].eq {
	pc = 0x828D2ED8; continue 'dispatch;
	}
	// 828D2EAC: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D2EB0: 409A0008  bne cr6, 0x828d2eb8
	if !ctx.cr[6].eq {
	pc = 0x828D2EB8; continue 'dispatch;
	}
	// 828D2EB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2EB8: 816A0038  lwz r11, 0x38(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 828D2EBC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D2EC0: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 828D2EC4: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 828D2EC8: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828D2ECC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828D2ED0: FC206818  frsp f1, f13
	ctx.f[1].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828D2ED4: 4BC02CED  bl 0x824d5bc0
	ctx.lr = 0x828D2ED8;
	sub_824D5BC0(ctx, base);
	// 828D2ED8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2EDC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D2EE0: 409A0008  bne cr6, 0x828d2ee8
	if !ctx.cr[6].eq {
	pc = 0x828D2EE8; continue 'dispatch;
	}
	// 828D2EE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2EE8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D2EEC: 932B0020  stw r25, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[25].u32 ) };
	// 828D2EF0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2EF4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D2EF8: 409A0008  bne cr6, 0x828d2f00
	if !ctx.cr[6].eq {
	pc = 0x828D2F00; continue 'dispatch;
	}
	// 828D2EFC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D2F00: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2F04: 4BFFFF1C  b 0x828d2e20
	pc = 0x828D2E20; continue 'dispatch;
	// 828D2F08: FDA0FA10  fabs f13, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[31].u64 & !0x8000_0000_0000_0000u64;
	// 828D2F0C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828D2F10: C00B9054  lfs f0, -0x6fac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28588 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D2F14: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828D2F18: 41980020  blt cr6, 0x828d2f38
	if ctx.cr[6].lt {
	pc = 0x828D2F38; continue 'dispatch;
	}
	// 828D2F1C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828D2F20: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D2F24: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828D2F28: 480000A1  bl 0x828d2fc8
	ctx.lr = 0x828D2F2C;
	sub_828D2FC8(ctx, base);
	// 828D2F2C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828D2F30: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828D2F34: 483D6514  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 828D2F38: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D2F3C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D2F40: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828D2F44: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828D2F48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D2F4C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D2F50: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D2F54: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D2F58: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2F5C: 83E70028  lwz r31, 0x28(r7)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(40 as u32) ) } as u64;
	// 828D2F60: 419A0020  beq cr6, 0x828d2f80
	if ctx.cr[6].eq {
	pc = 0x828D2F80; continue 'dispatch;
	}
	// 828D2F64: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828D2F68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D2F6C: 388A3618  addi r4, r10, 0x3618
	ctx.r[4].s64 = ctx.r[10].s64 + 13848;
	// 828D2F70: 4B959F61  bl 0x8222ced0
	ctx.lr = 0x828D2F74;
	sub_8222CED0(ctx, base);
	// 828D2F74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D2F78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2F7C: 4800001C  b 0x828d2f98
	pc = 0x828D2F98; continue 'dispatch;
	// 828D2F80: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828D2F84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2F88: 388A3630  addi r4, r10, 0x3630
	ctx.r[4].s64 = ctx.r[10].s64 + 13872;
	// 828D2F8C: 4B959F45  bl 0x8222ced0
	ctx.lr = 0x828D2F90;
	sub_8222CED0(ctx, base);
	// 828D2F90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D2F94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D2F98: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 828D2F9C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D2FA0: 3886E950  addi r4, r6, -0x16b0
	ctx.r[4].s64 = ctx.r[6].s64 + -5808;
	// 828D2FA4: 4B959F2D  bl 0x8222ced0
	ctx.lr = 0x828D2FA8;
	sub_8222CED0(ctx, base);
	// 828D2FA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D2FAC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D2FB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D2FB4: 4BBA7ABD  bl 0x8247aa70
	ctx.lr = 0x828D2FB8;
	sub_8247AA70(ctx, base);
	// 828D2FB8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828D2FBC: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828D2FC0: 483D6488  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D2FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D2FC8 size=1384
    let mut pc: u32 = 0x828D2FC8;
    'dispatch: loop {
        match pc {
            0x828D2FC8 => {
    //   block [0x828D2FC8..0x828D3530)
	// 828D2FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D2FCC: 483D6431  bl 0x82ca93fc
	ctx.lr = 0x828D2FD0;
	sub_82CA93D0(ctx, base);
	// 828D2FD0: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828D2FD4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D2FD8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D2FDC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828D2FE0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828D2FE4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D2FE8: 3BBE0024  addi r29, r30, 0x24
	ctx.r[29].s64 = ctx.r[30].s64 + 36;
	// 828D2FEC: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
	// 828D2FF0: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D2FF4: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828D2FF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D2FFC: 419A00F4  beq cr6, 0x828d30f0
	if ctx.cr[6].eq {
	pc = 0x828D30F0; continue 'dispatch;
	}
	// 828D3000: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D3004: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3008: 419A0024  beq cr6, 0x828d302c
	if ctx.cr[6].eq {
	pc = 0x828D302C; continue 'dispatch;
	}
	// 828D300C: 894B0043  lbz r10, 0x43(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(67 as u32) ) } as u64;
	// 828D3010: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D3014: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D3018: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D301C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3020: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 828D3024: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D3028: 480000CC  b 0x828d30f4
	pc = 0x828D30F4; continue 'dispatch;
	// 828D302C: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D3030: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D3034: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 828D3038: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D303C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828D3040: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D3044: 40810054  ble 0x828d3098
	if !ctx.cr[0].gt {
	pc = 0x828D3098; continue 'dispatch;
	}
	// 828D3048: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D304C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D3050: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D3054: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3058: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 828D305C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D3060: 41980008  blt cr6, 0x828d3068
	if ctx.cr[6].lt {
	pc = 0x828D3068; continue 'dispatch;
	}
	// 828D3064: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828D3068: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D306C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D3070: 419A0014  beq cr6, 0x828d3084
	if ctx.cr[6].eq {
	pc = 0x828D3084; continue 'dispatch;
	}
	// 828D3074: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D3078: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D307C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D3080: 4800000C  b 0x828d308c
	pc = 0x828D308C; continue 'dispatch;
	// 828D3084: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D3088: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D308C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D3090: 4199FFB8  bgt cr6, 0x828d3048
	if ctx.cr[6].gt {
	pc = 0x828D3048; continue 'dispatch;
	}
	// 828D3094: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828D3098: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D309C: 419A0040  beq cr6, 0x828d30dc
	if ctx.cr[6].eq {
	pc = 0x828D30DC; continue 'dispatch;
	}
	// 828D30A0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D30A4: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 828D30A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D30AC: 41990008  bgt cr6, 0x828d30b4
	if ctx.cr[6].gt {
	pc = 0x828D30B4; continue 'dispatch;
	}
	// 828D30B0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828D30B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D30B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D30BC: 409A0020  bne cr6, 0x828d30dc
	if !ctx.cr[6].eq {
	pc = 0x828D30DC; continue 'dispatch;
	}
	// 828D30C0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828D30C4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828D30C8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D30CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D30D0: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 828D30D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D30D8: 4800001C  b 0x828d30f4
	pc = 0x828D30F4; continue 'dispatch;
	// 828D30DC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D30E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D30E4: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 828D30E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D30EC: 48000008  b 0x828d30f4
	pc = 0x828D30F4; continue 'dispatch;
	// 828D30F0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828D30F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D30F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D30FC: 419A0428  beq cr6, 0x828d3524
	if ctx.cr[6].eq {
	pc = 0x828D3524; continue 'dispatch;
	}
	// 828D3100: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D3104: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828D3108: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828D310C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828D3110: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D3114: 83EA6DA0  lwz r31, 0x6da0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828D3118: 3B2B9054  addi r25, r11, -0x6fac
	ctx.r[25].s64 = ctx.r[11].s64 + -28588;
	// 828D311C: C00B9054  lfs f0, -0x6fac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28588 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D3120: 419A0084  beq cr6, 0x828d31a4
	if ctx.cr[6].eq {
	pc = 0x828D31A4; continue 'dispatch;
	}
	// 828D3124: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828D3128: 4099003C  ble cr6, 0x828d3164
	if !ctx.cr[6].gt {
	pc = 0x828D3164; continue 'dispatch;
	}
	// 828D312C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D3130: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828D3134: 386B36F8  addi r3, r11, 0x36f8
	ctx.r[3].s64 = ctx.r[11].s64 + 14072;
	// 828D3138: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828D313C: 4B920C1D  bl 0x821f3d58
	ctx.lr = 0x828D3140;
	sub_821F3D58(ctx, base);
	// 828D3140: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D3144: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828D3148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D314C: 4B9FA37D  bl 0x822cd4c8
	ctx.lr = 0x828D3150;
	sub_822CD4C8(ctx, base);
	// 828D3150: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D3154: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D3158: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D315C: 4BF5AAFD  bl 0x8282dc58
	ctx.lr = 0x828D3160;
	sub_8282DC58(ctx, base);
	// 828D3160: 48000300  b 0x828d3460
	pc = 0x828D3460; continue 'dispatch;
	// 828D3164: FF1F0000  fcmpu cr6, f31, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828D3168: 409802F8  bge cr6, 0x828d3460
	if !ctx.cr[6].lt {
	pc = 0x828D3460; continue 'dispatch;
	}
	// 828D316C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D3170: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828D3174: 386B3708  addi r3, r11, 0x3708
	ctx.r[3].s64 = ctx.r[11].s64 + 14088;
	// 828D3178: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828D317C: 4B920BDD  bl 0x821f3d58
	ctx.lr = 0x828D3180;
	sub_821F3D58(ctx, base);
	// 828D3180: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D3184: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828D3188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D318C: 4B9FA33D  bl 0x822cd4c8
	ctx.lr = 0x828D3190;
	sub_822CD4C8(ctx, base);
	// 828D3190: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D3194: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D3198: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D319C: 4BF5AABD  bl 0x8282dc58
	ctx.lr = 0x828D31A0;
	sub_8282DC58(ctx, base);
	// 828D31A0: 480002C0  b 0x828d3460
	pc = 0x828D3460; continue 'dispatch;
	// 828D31A4: FF1F0000  fcmpu cr6, f31, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828D31A8: 40990010  ble cr6, 0x828d31b8
	if !ctx.cr[6].gt {
	pc = 0x828D31B8; continue 'dispatch;
	}
	// 828D31AC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D31B0: 386B3718  addi r3, r11, 0x3718
	ctx.r[3].s64 = ctx.r[11].s64 + 14104;
	// 828D31B4: 48000014  b 0x828d31c8
	pc = 0x828D31C8; continue 'dispatch;
	// 828D31B8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828D31BC: 409802A4  bge cr6, 0x828d3460
	if !ctx.cr[6].lt {
	pc = 0x828D3460; continue 'dispatch;
	}
	// 828D31C0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D31C4: 386B3730  addi r3, r11, 0x3730
	ctx.r[3].s64 = ctx.r[11].s64 + 14128;
	// 828D31C8: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828D31CC: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828D31D0: 4B920B89  bl 0x821f3d58
	ctx.lr = 0x828D31D4;
	sub_821F3D58(ctx, base);
	// 828D31D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D31D8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828D31DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D31E0: 4B9FA2E9  bl 0x822cd4c8
	ctx.lr = 0x828D31E4;
	sub_822CD4C8(ctx, base);
	// 828D31E4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D31E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D31EC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828D31F0: 4B911061  bl 0x821e4250
	ctx.lr = 0x828D31F4;
	sub_821E4250(ctx, base);
	// 828D31F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D31F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D31FC: 419A0264  beq cr6, 0x828d3460
	if ctx.cr[6].eq {
	pc = 0x828D3460; continue 'dispatch;
	}
	// 828D3200: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D3204: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828D3208: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 828D320C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D3210: 419A00E8  beq cr6, 0x828d32f8
	if ctx.cr[6].eq {
	pc = 0x828D32F8; continue 'dispatch;
	}
	// 828D3214: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D3218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D321C: 419A0020  beq cr6, 0x828d323c
	if ctx.cr[6].eq {
	pc = 0x828D323C; continue 'dispatch;
	}
	// 828D3220: 894B0042  lbz r10, 0x42(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(66 as u32) ) } as u64;
	// 828D3224: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D3228: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D322C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D3230: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D3234: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3238: 480000C4  b 0x828d32fc
	pc = 0x828D32FC; continue 'dispatch;
	// 828D323C: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D3240: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D3244: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 828D3248: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D324C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828D3250: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D3254: 40810054  ble 0x828d32a8
	if !ctx.cr[0].gt {
	pc = 0x828D32A8; continue 'dispatch;
	}
	// 828D3258: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D325C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D3260: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D3264: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3268: 2F070042  cmpwi cr6, r7, 0x42
	ctx.cr[6].compare_i32(ctx.r[7].s32, 66, &mut ctx.xer);
	// 828D326C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D3270: 41980008  blt cr6, 0x828d3278
	if ctx.cr[6].lt {
	pc = 0x828D3278; continue 'dispatch;
	}
	// 828D3274: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828D3278: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D327C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D3280: 419A0014  beq cr6, 0x828d3294
	if ctx.cr[6].eq {
	pc = 0x828D3294; continue 'dispatch;
	}
	// 828D3284: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D3288: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D328C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D3290: 4800000C  b 0x828d329c
	pc = 0x828D329C; continue 'dispatch;
	// 828D3294: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D3298: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D329C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D32A0: 4199FFB8  bgt cr6, 0x828d3258
	if ctx.cr[6].gt {
	pc = 0x828D3258; continue 'dispatch;
	}
	// 828D32A4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828D32A8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D32AC: 419A003C  beq cr6, 0x828d32e8
	if ctx.cr[6].eq {
	pc = 0x828D32E8; continue 'dispatch;
	}
	// 828D32B0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D32B4: 2F0B0042  cmpwi cr6, r11, 0x42
	ctx.cr[6].compare_i32(ctx.r[11].s32, 66, &mut ctx.xer);
	// 828D32B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D32BC: 41990008  bgt cr6, 0x828d32c4
	if ctx.cr[6].gt {
	pc = 0x828D32C4; continue 'dispatch;
	}
	// 828D32C0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828D32C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D32C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D32CC: 409A001C  bne cr6, 0x828d32e8
	if !ctx.cr[6].eq {
	pc = 0x828D32E8; continue 'dispatch;
	}
	// 828D32D0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828D32D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D32D8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828D32DC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D32E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D32E4: 48000018  b 0x828d32fc
	pc = 0x828D32FC; continue 'dispatch;
	// 828D32E8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D32EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D32F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D32F4: 48000008  b 0x828d32fc
	pc = 0x828D32FC; continue 'dispatch;
	// 828D32F8: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 828D32FC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D3300: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D3304: 419A015C  beq cr6, 0x828d3460
	if ctx.cr[6].eq {
	pc = 0x828D3460; continue 'dispatch;
	}
	// 828D3308: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D330C: 4B9CBB6D  bl 0x8229ee78
	ctx.lr = 0x828D3310;
	sub_8229EE78(ctx, base);
	// 828D3310: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D3314: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3318: 419A0018  beq cr6, 0x828d3330
	if ctx.cr[6].eq {
	pc = 0x828D3330; continue 'dispatch;
	}
	// 828D331C: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D3320: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828D3324: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D3328: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D332C: 409A0008  bne cr6, 0x828d3334
	if !ctx.cr[6].eq {
	pc = 0x828D3334; continue 'dispatch;
	}
	// 828D3330: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 828D3334: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D3338: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D333C: 419A0124  beq cr6, 0x828d3460
	if ctx.cr[6].eq {
	pc = 0x828D3460; continue 'dispatch;
	}
	// 828D3340: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D3344: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D3348: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 828D334C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D3350: 419A00F4  beq cr6, 0x828d3444
	if ctx.cr[6].eq {
	pc = 0x828D3444; continue 'dispatch;
	}
	// 828D3354: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D3358: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D335C: 419A0024  beq cr6, 0x828d3380
	if ctx.cr[6].eq {
	pc = 0x828D3380; continue 'dispatch;
	}
	// 828D3360: 894A0041  lbz r10, 0x41(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(65 as u32) ) } as u64;
	// 828D3364: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D3368: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D336C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D3370: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3374: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D3378: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D337C: 480000CC  b 0x828d3448
	pc = 0x828D3448; continue 'dispatch;
	// 828D3380: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D3384: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D3388: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 828D338C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D3390: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828D3394: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D3398: 40810054  ble 0x828d33ec
	if !ctx.cr[0].gt {
	pc = 0x828D33EC; continue 'dispatch;
	}
	// 828D339C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D33A0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D33A4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828D33A8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D33AC: 2F070041  cmpwi cr6, r7, 0x41
	ctx.cr[6].compare_i32(ctx.r[7].s32, 65, &mut ctx.xer);
	// 828D33B0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D33B4: 41980008  blt cr6, 0x828d33bc
	if ctx.cr[6].lt {
	pc = 0x828D33BC; continue 'dispatch;
	}
	// 828D33B8: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828D33BC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D33C0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D33C4: 419A0014  beq cr6, 0x828d33d8
	if ctx.cr[6].eq {
	pc = 0x828D33D8; continue 'dispatch;
	}
	// 828D33C8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D33CC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D33D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D33D4: 4800000C  b 0x828d33e0
	pc = 0x828D33E0; continue 'dispatch;
	// 828D33D8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D33DC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D33E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D33E4: 4199FFB8  bgt cr6, 0x828d339c
	if ctx.cr[6].gt {
	pc = 0x828D339C; continue 'dispatch;
	}
	// 828D33E8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828D33EC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D33F0: 419A0040  beq cr6, 0x828d3430
	if ctx.cr[6].eq {
	pc = 0x828D3430; continue 'dispatch;
	}
	// 828D33F4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D33F8: 2F0B0041  cmpwi cr6, r11, 0x41
	ctx.cr[6].compare_i32(ctx.r[11].s32, 65, &mut ctx.xer);
	// 828D33FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D3400: 41990008  bgt cr6, 0x828d3408
	if ctx.cr[6].gt {
	pc = 0x828D3408; continue 'dispatch;
	}
	// 828D3404: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828D3408: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D340C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3410: 409A0020  bne cr6, 0x828d3430
	if !ctx.cr[6].eq {
	pc = 0x828D3430; continue 'dispatch;
	}
	// 828D3414: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828D3418: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828D341C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D3420: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3424: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D3428: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D342C: 4800001C  b 0x828d3448
	pc = 0x828D3448; continue 'dispatch;
	// 828D3430: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D3434: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3438: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D343C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D3440: 48000008  b 0x828d3448
	pc = 0x828D3448; continue 'dispatch;
	// 828D3444: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828D3448: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D344C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3450: 419A0010  beq cr6, 0x828d3460
	if ctx.cr[6].eq {
	pc = 0x828D3460; continue 'dispatch;
	}
	// 828D3454: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828D3458: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D345C: 4BBC5F75  bl 0x824993d0
	ctx.lr = 0x828D3460;
	sub_824993D0(ctx, base);
	// 828D3460: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D3464: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D3468: 388B3748  addi r4, r11, 0x3748
	ctx.r[4].s64 = ctx.r[11].s64 + 14152;
	// 828D346C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3470: 4B959A61  bl 0x8222ced0
	ctx.lr = 0x828D3474;
	sub_8222CED0(ctx, base);
	// 828D3474: 815B001C  lwz r10, 0x1c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D3478: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 828D347C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D3480: 409A0014  bne cr6, 0x828d3494
	if !ctx.cr[6].eq {
	pc = 0x828D3494; continue 'dispatch;
	}
	// 828D3484: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D3488: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D348C: 388B3758  addi r4, r11, 0x3758
	ctx.r[4].s64 = ctx.r[11].s64 + 14168;
	// 828D3490: 4B9A1FA9  bl 0x82275438
	ctx.lr = 0x828D3494;
	sub_82275438(ctx, base);
	// 828D3494: C0190000  lfs f0, 0(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D3498: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828D349C: 4099001C  ble cr6, 0x828d34b8
	if !ctx.cr[6].gt {
	pc = 0x828D34B8; continue 'dispatch;
	}
	// 828D34A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D34A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D34A8: 4B91CD99  bl 0x821f0240
	ctx.lr = 0x828D34AC;
	sub_821F0240(ctx, base);
	// 828D34AC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D34B0: 388B376C  addi r4, r11, 0x376c
	ctx.r[4].s64 = ctx.r[11].s64 + 14188;
	// 828D34B4: 48000020  b 0x828d34d4
	pc = 0x828D34D4; continue 'dispatch;
	// 828D34B8: FF1F0000  fcmpu cr6, f31, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828D34BC: 40980060  bge cr6, 0x828d351c
	if !ctx.cr[6].lt {
	pc = 0x828D351C; continue 'dispatch;
	}
	// 828D34C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D34C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D34C8: 4B91CD79  bl 0x821f0240
	ctx.lr = 0x828D34CC;
	sub_821F0240(ctx, base);
	// 828D34CC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D34D0: 388B3774  addi r4, r11, 0x3774
	ctx.r[4].s64 = ctx.r[11].s64 + 14196;
	// 828D34D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D34D8: 4B9074E9  bl 0x821da9c0
	ctx.lr = 0x828D34DC;
	sub_821DA9C0(ctx, base);
	// 828D34DC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828D34E0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 828D34E4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D34E8: 3889E950  addi r4, r9, -0x16b0
	ctx.r[4].s64 = ctx.r[9].s64 + -5808;
	// 828D34EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D34F0: 816A6AB8  lwz r11, 0x6ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D34F4: 3BE10054  addi r31, r1, 0x54
	ctx.r[31].s64 = ctx.r[1].s64 + 84;
	// 828D34F8: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D34FC: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D3500: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3504: 83C60028  lwz r30, 0x28(r6)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(40 as u32) ) } as u64;
	// 828D3508: 4B9599C9  bl 0x8222ced0
	ctx.lr = 0x828D350C;
	sub_8222CED0(ctx, base);
	// 828D350C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D3510: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D3514: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D3518: 4BBA7559  bl 0x8247aa70
	ctx.lr = 0x828D351C;
	sub_8247AA70(ctx, base);
	// 828D351C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3520: 4B9418B9  bl 0x82214dd8
	ctx.lr = 0x828D3524;
	sub_82214DD8(ctx, base);
	// 828D3524: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828D3528: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 828D352C: 483D5F20  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D3530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D3530 size=1700
    let mut pc: u32 = 0x828D3530;
    'dispatch: loop {
        match pc {
            0x828D3530 => {
    //   block [0x828D3530..0x828D3BD4)
	// 828D3530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D3534: 483D5EC5  bl 0x82ca93f8
	ctx.lr = 0x828D3538;
	sub_82CA93D0(ctx, base);
	// 828D3538: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 828D353C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D3540: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 828D3544: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828D3548: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D354C: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828D3550: 83DB6AB8  lwz r30, 0x6ab8(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D3554: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D3558: 83896DA0  lwz r28, 0x6da0(r9)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828D355C: 8B5F000F  lbz r26, 0xf(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(15 as u32) ) } as u64;
	// 828D3560: 811E000C  lwz r8, 0xc(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D3564: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828D3568: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D356C: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3570: 80A60008  lwz r5, 8(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D3574: 80850004  lwz r4, 4(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3578: 80640024  lwz r3, 0x24(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 828D357C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3580: 812A00B4  lwz r9, 0xb4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(180 as u32) ) } as u64;
	// 828D3584: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D3588: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828D358C: 7D070034  cntlzw r7, r8
	ctx.r[7].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 828D3590: 3B2B9054  addi r25, r11, -0x6fac
	ctx.r[25].s64 = ctx.r[11].s64 + -28588;
	// 828D3594: 54F8DFFE  rlwinm r24, r7, 0x1b, 0x1f, 0x1f
	ctx.r[24].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 828D3598: C00B9054  lfs f0, -0x6fac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28588 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D359C: 419A0214  beq cr6, 0x828d37b0
	if ctx.cr[6].eq {
	pc = 0x828D37B0; continue 'dispatch;
	}
	// 828D35A0: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828D35A4: 40990010  ble cr6, 0x828d35b4
	if !ctx.cr[6].gt {
	pc = 0x828D35B4; continue 'dispatch;
	}
	// 828D35A8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D35AC: 386B36F8  addi r3, r11, 0x36f8
	ctx.r[3].s64 = ctx.r[11].s64 + 14072;
	// 828D35B0: 48000014  b 0x828d35c4
	pc = 0x828D35C4; continue 'dispatch;
	// 828D35B4: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828D35B8: 4098054C  bge cr6, 0x828d3b04
	if !ctx.cr[6].lt {
	pc = 0x828D3B04; continue 'dispatch;
	}
	// 828D35BC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D35C0: 386B3708  addi r3, r11, 0x3708
	ctx.r[3].s64 = ctx.r[11].s64 + 14088;
	// 828D35C4: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828D35C8: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828D35CC: 4B92078D  bl 0x821f3d58
	ctx.lr = 0x828D35D0;
	sub_821F3D58(ctx, base);
	// 828D35D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D35D4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828D35D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D35DC: 4B9F9EED  bl 0x822cd4c8
	ctx.lr = 0x828D35E0;
	sub_822CD4C8(ctx, base);
	// 828D35E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D35E4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D35E8: 419A051C  beq cr6, 0x828d3b04
	if ctx.cr[6].eq {
	pc = 0x828D3B04; continue 'dispatch;
	}
	// 828D35EC: 570B063E  clrlwi r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	// 828D35F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D35F4: 409A000C  bne cr6, 0x828d3600
	if !ctx.cr[6].eq {
	pc = 0x828D3600; continue 'dispatch;
	}
	// 828D35F8: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 828D35FC: 48000508  b 0x828d3b04
	pc = 0x828D3B04; continue 'dispatch;
	// 828D3600: E97F0000  ld r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 828D3604: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D3608: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828D360C: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D3610: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D3614: 409A0014  bne cr6, 0x828d3628
	if !ctx.cr[6].eq {
	pc = 0x828D3628; continue 'dispatch;
	}
	// 828D3618: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D361C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3620: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D3624: 419A0008  beq cr6, 0x828d362c
	if ctx.cr[6].eq {
	pc = 0x828D362C; continue 'dispatch;
	}
	// 828D3628: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D362C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D3630: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3634: 419A04D0  beq cr6, 0x828d3b04
	if ctx.cr[6].eq {
	pc = 0x828D3B04; continue 'dispatch;
	}
	// 828D3638: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D363C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D3640: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D3644: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3648: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D364C: 4B990E3D  bl 0x82264488
	ctx.lr = 0x828D3650;
	sub_82264488(ctx, base);
	// 828D3650: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D3654: 419A0018  beq cr6, 0x828d366c
	if ctx.cr[6].eq {
	pc = 0x828D366C; continue 'dispatch;
	}
	// 828D3658: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D365C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D3660: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D3664: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D3668: 409A0008  bne cr6, 0x828d3670
	if !ctx.cr[6].eq {
	pc = 0x828D3670; continue 'dispatch;
	}
	// 828D366C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D3670: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D3674: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3678: 419A048C  beq cr6, 0x828d3b04
	if ctx.cr[6].eq {
	pc = 0x828D3B04; continue 'dispatch;
	}
	// 828D367C: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D3680: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828D3684: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828D3688: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D368C: 419A00F4  beq cr6, 0x828d3780
	if ctx.cr[6].eq {
	pc = 0x828D3780; continue 'dispatch;
	}
	// 828D3690: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D3694: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3698: 419A0024  beq cr6, 0x828d36bc
	if ctx.cr[6].eq {
	pc = 0x828D36BC; continue 'dispatch;
	}
	// 828D369C: 894B0043  lbz r10, 0x43(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(67 as u32) ) } as u64;
	// 828D36A0: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D36A4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D36A8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D36AC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D36B0: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 828D36B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D36B8: 480000CC  b 0x828d3784
	pc = 0x828D3784; continue 'dispatch;
	// 828D36BC: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D36C0: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D36C4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828D36C8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D36CC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828D36D0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D36D4: 40810054  ble 0x828d3728
	if !ctx.cr[0].gt {
	pc = 0x828D3728; continue 'dispatch;
	}
	// 828D36D8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D36DC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D36E0: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828D36E4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D36E8: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 828D36EC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D36F0: 41980008  blt cr6, 0x828d36f8
	if ctx.cr[6].lt {
	pc = 0x828D36F8; continue 'dispatch;
	}
	// 828D36F4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828D36F8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D36FC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D3700: 419A0014  beq cr6, 0x828d3714
	if ctx.cr[6].eq {
	pc = 0x828D3714; continue 'dispatch;
	}
	// 828D3704: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D3708: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D370C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D3710: 4800000C  b 0x828d371c
	pc = 0x828D371C; continue 'dispatch;
	// 828D3714: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D3718: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D371C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D3720: 4199FFB8  bgt cr6, 0x828d36d8
	if ctx.cr[6].gt {
	pc = 0x828D36D8; continue 'dispatch;
	}
	// 828D3724: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828D3728: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D372C: 419A0040  beq cr6, 0x828d376c
	if ctx.cr[6].eq {
	pc = 0x828D376C; continue 'dispatch;
	}
	// 828D3730: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3734: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 828D3738: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D373C: 41990008  bgt cr6, 0x828d3744
	if ctx.cr[6].gt {
	pc = 0x828D3744; continue 'dispatch;
	}
	// 828D3740: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D3744: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D3748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D374C: 409A0020  bne cr6, 0x828d376c
	if !ctx.cr[6].eq {
	pc = 0x828D376C; continue 'dispatch;
	}
	// 828D3750: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828D3754: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828D3758: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D375C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3760: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 828D3764: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D3768: 4800001C  b 0x828d3784
	pc = 0x828D3784; continue 'dispatch;
	// 828D376C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D3770: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3774: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 828D3778: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D377C: 48000008  b 0x828d3784
	pc = 0x828D3784; continue 'dispatch;
	// 828D3780: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D3784: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D3788: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D378C: 419A0378  beq cr6, 0x828d3b04
	if ctx.cr[6].eq {
	pc = 0x828D3B04; continue 'dispatch;
	}
	// 828D3790: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D3794: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D3798: 4B910AB9  bl 0x821e4250
	ctx.lr = 0x828D379C;
	sub_821E4250(ctx, base);
	// 828D379C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D37A0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828D37A4: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 828D37A8: 4BF5A5C1  bl 0x8282dd68
	ctx.lr = 0x828D37AC;
	sub_8282DD68(ctx, base);
	// 828D37AC: 48000358  b 0x828d3b04
	pc = 0x828D3B04; continue 'dispatch;
	// 828D37B0: FF1F0000  fcmpu cr6, f31, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828D37B4: 40990010  ble cr6, 0x828d37c4
	if !ctx.cr[6].gt {
	pc = 0x828D37C4; continue 'dispatch;
	}
	// 828D37B8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D37BC: 386B3718  addi r3, r11, 0x3718
	ctx.r[3].s64 = ctx.r[11].s64 + 14104;
	// 828D37C0: 48000014  b 0x828d37d4
	pc = 0x828D37D4; continue 'dispatch;
	// 828D37C4: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828D37C8: 4098033C  bge cr6, 0x828d3b04
	if !ctx.cr[6].lt {
	pc = 0x828D3B04; continue 'dispatch;
	}
	// 828D37CC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D37D0: 386B3730  addi r3, r11, 0x3730
	ctx.r[3].s64 = ctx.r[11].s64 + 14128;
	// 828D37D4: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828D37D8: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828D37DC: 4B92057D  bl 0x821f3d58
	ctx.lr = 0x828D37E0;
	sub_821F3D58(ctx, base);
	// 828D37E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D37E4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828D37E8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D37EC: 4B9F9CDD  bl 0x822cd4c8
	ctx.lr = 0x828D37F0;
	sub_822CD4C8(ctx, base);
	// 828D37F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D37F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D37F8: 419A030C  beq cr6, 0x828d3b04
	if ctx.cr[6].eq {
	pc = 0x828D3B04; continue 'dispatch;
	}
	// 828D37FC: 570B063E  clrlwi r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	// 828D3800: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3804: 409A000C  bne cr6, 0x828d3810
	if !ctx.cr[6].eq {
	pc = 0x828D3810; continue 'dispatch;
	}
	// 828D3808: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 828D380C: 480002F8  b 0x828d3b04
	pc = 0x828D3B04; continue 'dispatch;
	// 828D3810: E97F0000  ld r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 828D3814: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D3818: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828D381C: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D3820: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D3824: 409A0014  bne cr6, 0x828d3838
	if !ctx.cr[6].eq {
	pc = 0x828D3838; continue 'dispatch;
	}
	// 828D3828: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D382C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3830: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D3834: 419A0008  beq cr6, 0x828d383c
	if ctx.cr[6].eq {
	pc = 0x828D383C; continue 'dispatch;
	}
	// 828D3838: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D383C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D3840: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3844: 419A02C0  beq cr6, 0x828d3b04
	if ctx.cr[6].eq {
	pc = 0x828D3B04; continue 'dispatch;
	}
	// 828D3848: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D384C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D3850: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D3854: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3858: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D385C: 4B990C2D  bl 0x82264488
	ctx.lr = 0x828D3860;
	sub_82264488(ctx, base);
	// 828D3860: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D3864: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3868: 419A0018  beq cr6, 0x828d3880
	if ctx.cr[6].eq {
	pc = 0x828D3880; continue 'dispatch;
	}
	// 828D386C: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D3870: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828D3874: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D3878: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D387C: 409A0008  bne cr6, 0x828d3884
	if !ctx.cr[6].eq {
	pc = 0x828D3884; continue 'dispatch;
	}
	// 828D3880: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828D3884: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D3888: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D388C: 419A0278  beq cr6, 0x828d3b04
	if ctx.cr[6].eq {
	pc = 0x828D3B04; continue 'dispatch;
	}
	// 828D3890: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D3894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D3898: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 828D389C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D38A0: 419A00F4  beq cr6, 0x828d3994
	if ctx.cr[6].eq {
	pc = 0x828D3994; continue 'dispatch;
	}
	// 828D38A4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D38A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D38AC: 419A0024  beq cr6, 0x828d38d0
	if ctx.cr[6].eq {
	pc = 0x828D38D0; continue 'dispatch;
	}
	// 828D38B0: 894A0042  lbz r10, 0x42(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(66 as u32) ) } as u64;
	// 828D38B4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D38B8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D38BC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D38C0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D38C4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D38C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D38CC: 480000CC  b 0x828d3998
	pc = 0x828D3998; continue 'dispatch;
	// 828D38D0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D38D4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D38D8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828D38DC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D38E0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828D38E4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D38E8: 40810054  ble 0x828d393c
	if !ctx.cr[0].gt {
	pc = 0x828D393C; continue 'dispatch;
	}
	// 828D38EC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D38F0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D38F4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828D38F8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D38FC: 2F070042  cmpwi cr6, r7, 0x42
	ctx.cr[6].compare_i32(ctx.r[7].s32, 66, &mut ctx.xer);
	// 828D3900: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D3904: 41980008  blt cr6, 0x828d390c
	if ctx.cr[6].lt {
	pc = 0x828D390C; continue 'dispatch;
	}
	// 828D3908: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828D390C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D3910: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D3914: 419A0014  beq cr6, 0x828d3928
	if ctx.cr[6].eq {
	pc = 0x828D3928; continue 'dispatch;
	}
	// 828D3918: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D391C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D3920: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D3924: 4800000C  b 0x828d3930
	pc = 0x828D3930; continue 'dispatch;
	// 828D3928: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D392C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D3930: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D3934: 4199FFB8  bgt cr6, 0x828d38ec
	if ctx.cr[6].gt {
	pc = 0x828D38EC; continue 'dispatch;
	}
	// 828D3938: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828D393C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D3940: 419A0040  beq cr6, 0x828d3980
	if ctx.cr[6].eq {
	pc = 0x828D3980; continue 'dispatch;
	}
	// 828D3944: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3948: 2F0B0042  cmpwi cr6, r11, 0x42
	ctx.cr[6].compare_i32(ctx.r[11].s32, 66, &mut ctx.xer);
	// 828D394C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D3950: 41990008  bgt cr6, 0x828d3958
	if ctx.cr[6].gt {
	pc = 0x828D3958; continue 'dispatch;
	}
	// 828D3954: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D3958: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D395C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3960: 409A0020  bne cr6, 0x828d3980
	if !ctx.cr[6].eq {
	pc = 0x828D3980; continue 'dispatch;
	}
	// 828D3964: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828D3968: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828D396C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D3970: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3974: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D3978: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D397C: 4800001C  b 0x828d3998
	pc = 0x828D3998; continue 'dispatch;
	// 828D3980: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D3984: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3988: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D398C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D3990: 48000008  b 0x828d3998
	pc = 0x828D3998; continue 'dispatch;
	// 828D3994: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D3998: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D399C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D39A0: 419A0164  beq cr6, 0x828d3b04
	if ctx.cr[6].eq {
	pc = 0x828D3B04; continue 'dispatch;
	}
	// 828D39A4: 4B9CB4D5  bl 0x8229ee78
	ctx.lr = 0x828D39A8;
	sub_8229EE78(ctx, base);
	// 828D39A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D39AC: 419A0018  beq cr6, 0x828d39c4
	if ctx.cr[6].eq {
	pc = 0x828D39C4; continue 'dispatch;
	}
	// 828D39B0: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D39B4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D39B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D39BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D39C0: 409A0008  bne cr6, 0x828d39c8
	if !ctx.cr[6].eq {
	pc = 0x828D39C8; continue 'dispatch;
	}
	// 828D39C4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D39C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D39CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D39D0: 419A0134  beq cr6, 0x828d3b04
	if ctx.cr[6].eq {
	pc = 0x828D3B04; continue 'dispatch;
	}
	// 828D39D4: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D39D8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828D39DC: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828D39E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D39E4: 419A00F4  beq cr6, 0x828d3ad8
	if ctx.cr[6].eq {
	pc = 0x828D3AD8; continue 'dispatch;
	}
	// 828D39E8: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D39EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D39F0: 419A0024  beq cr6, 0x828d3a14
	if ctx.cr[6].eq {
	pc = 0x828D3A14; continue 'dispatch;
	}
	// 828D39F4: 894B0041  lbz r10, 0x41(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 828D39F8: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D39FC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D3A00: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D3A04: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3A08: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 828D3A0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D3A10: 480000CC  b 0x828d3adc
	pc = 0x828D3ADC; continue 'dispatch;
	// 828D3A14: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D3A18: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D3A1C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828D3A20: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D3A24: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828D3A28: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D3A2C: 40810054  ble 0x828d3a80
	if !ctx.cr[0].gt {
	pc = 0x828D3A80; continue 'dispatch;
	}
	// 828D3A30: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D3A34: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D3A38: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828D3A3C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3A40: 2F070041  cmpwi cr6, r7, 0x41
	ctx.cr[6].compare_i32(ctx.r[7].s32, 65, &mut ctx.xer);
	// 828D3A44: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D3A48: 41980008  blt cr6, 0x828d3a50
	if ctx.cr[6].lt {
	pc = 0x828D3A50; continue 'dispatch;
	}
	// 828D3A4C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828D3A50: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D3A54: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D3A58: 419A0014  beq cr6, 0x828d3a6c
	if ctx.cr[6].eq {
	pc = 0x828D3A6C; continue 'dispatch;
	}
	// 828D3A5C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D3A60: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D3A64: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D3A68: 4800000C  b 0x828d3a74
	pc = 0x828D3A74; continue 'dispatch;
	// 828D3A6C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D3A70: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D3A74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D3A78: 4199FFB8  bgt cr6, 0x828d3a30
	if ctx.cr[6].gt {
	pc = 0x828D3A30; continue 'dispatch;
	}
	// 828D3A7C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828D3A80: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D3A84: 419A0040  beq cr6, 0x828d3ac4
	if ctx.cr[6].eq {
	pc = 0x828D3AC4; continue 'dispatch;
	}
	// 828D3A88: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3A8C: 2F0B0041  cmpwi cr6, r11, 0x41
	ctx.cr[6].compare_i32(ctx.r[11].s32, 65, &mut ctx.xer);
	// 828D3A90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D3A94: 41990008  bgt cr6, 0x828d3a9c
	if ctx.cr[6].gt {
	pc = 0x828D3A9C; continue 'dispatch;
	}
	// 828D3A98: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D3A9C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D3AA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3AA4: 409A0020  bne cr6, 0x828d3ac4
	if !ctx.cr[6].eq {
	pc = 0x828D3AC4; continue 'dispatch;
	}
	// 828D3AA8: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828D3AAC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828D3AB0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D3AB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3AB8: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 828D3ABC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D3AC0: 4800001C  b 0x828d3adc
	pc = 0x828D3ADC; continue 'dispatch;
	// 828D3AC4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D3AC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3ACC: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 828D3AD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D3AD4: 48000008  b 0x828d3adc
	pc = 0x828D3ADC; continue 'dispatch;
	// 828D3AD8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D3ADC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D3AE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3AE4: 419A0020  beq cr6, 0x828d3b04
	if ctx.cr[6].eq {
	pc = 0x828D3B04; continue 'dispatch;
	}
	// 828D3AE8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D3AEC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D3AF0: 4B910761  bl 0x821e4250
	ctx.lr = 0x828D3AF4;
	sub_821E4250(ctx, base);
	// 828D3AF4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D3AF8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828D3AFC: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 828D3B00: 4BBC58D1  bl 0x824993d0
	ctx.lr = 0x828D3B04;
	sub_824993D0(ctx, base);
	// 828D3B04: 570B063E  clrlwi r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	// 828D3B08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3B0C: 419A00BC  beq cr6, 0x828d3bc8
	if ctx.cr[6].eq {
	pc = 0x828D3BC8; continue 'dispatch;
	}
	// 828D3B10: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D3B14: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D3B18: 388B3748  addi r4, r11, 0x3748
	ctx.r[4].s64 = ctx.r[11].s64 + 14152;
	// 828D3B1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3B20: 4B9593B1  bl 0x8222ced0
	ctx.lr = 0x828D3B24;
	sub_8222CED0(ctx, base);
	// 828D3B24: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828D3B28: 409A0014  bne cr6, 0x828d3b3c
	if !ctx.cr[6].eq {
	pc = 0x828D3B3C; continue 'dispatch;
	}
	// 828D3B2C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D3B30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3B34: 388B3758  addi r4, r11, 0x3758
	ctx.r[4].s64 = ctx.r[11].s64 + 14168;
	// 828D3B38: 4B9A1901  bl 0x82275438
	ctx.lr = 0x828D3B3C;
	sub_82275438(ctx, base);
	// 828D3B3C: C0190000  lfs f0, 0(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D3B40: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828D3B44: 4099001C  ble cr6, 0x828d3b60
	if !ctx.cr[6].gt {
	pc = 0x828D3B60; continue 'dispatch;
	}
	// 828D3B48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D3B4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D3B50: 4B91C6F1  bl 0x821f0240
	ctx.lr = 0x828D3B54;
	sub_821F0240(ctx, base);
	// 828D3B54: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D3B58: 388B376C  addi r4, r11, 0x376c
	ctx.r[4].s64 = ctx.r[11].s64 + 14188;
	// 828D3B5C: 48000020  b 0x828d3b7c
	pc = 0x828D3B7C; continue 'dispatch;
	// 828D3B60: FF1F0000  fcmpu cr6, f31, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828D3B64: 4098005C  bge cr6, 0x828d3bc0
	if !ctx.cr[6].lt {
	pc = 0x828D3BC0; continue 'dispatch;
	}
	// 828D3B68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D3B6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D3B70: 4B91C6D1  bl 0x821f0240
	ctx.lr = 0x828D3B74;
	sub_821F0240(ctx, base);
	// 828D3B74: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D3B78: 388B3774  addi r4, r11, 0x3774
	ctx.r[4].s64 = ctx.r[11].s64 + 14196;
	// 828D3B7C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D3B80: 4B906E41  bl 0x821da9c0
	ctx.lr = 0x828D3B84;
	sub_821DA9C0(ctx, base);
	// 828D3B84: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D3B88: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 828D3B8C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D3B90: 388AE950  addi r4, r10, -0x16b0
	ctx.r[4].s64 = ctx.r[10].s64 + -5808;
	// 828D3B94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3B98: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D3B9C: 3BE10054  addi r31, r1, 0x54
	ctx.r[31].s64 = ctx.r[1].s64 + 84;
	// 828D3BA0: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D3BA4: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3BA8: 83C70028  lwz r30, 0x28(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(40 as u32) ) } as u64;
	// 828D3BAC: 4B959325  bl 0x8222ced0
	ctx.lr = 0x828D3BB0;
	sub_8222CED0(ctx, base);
	// 828D3BB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D3BB4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D3BB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D3BBC: 4BBA6EB5  bl 0x8247aa70
	ctx.lr = 0x828D3BC0;
	sub_8247AA70(ctx, base);
	// 828D3BC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3BC4: 4B941215  bl 0x82214dd8
	ctx.lr = 0x828D3BC8;
	sub_82214DD8(ctx, base);
	// 828D3BC8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828D3BCC: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828D3BD0: 483D5878  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D3BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D3BD8 size=308
    let mut pc: u32 = 0x828D3BD8;
    'dispatch: loop {
        match pc {
            0x828D3BD8 => {
    //   block [0x828D3BD8..0x828D3D0C)
	// 828D3BD8: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 828D3BDC: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 828D3BE0: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D3BE4: 3BE30018  addi r31, r3, 0x18
	ctx.r[31].s64 = ctx.r[3].s64 + 24;
	// 828D3BE8: E9440014  ld r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	// 828D3BEC: 93E1FFE0  stw r31, -0x20(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[31].u32 ) };
	// 828D3BF0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D3BF4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3BF8: F941FFE8  std r10, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[10].u64 ) };
	// 828D3BFC: 8081FFEC  lwz r4, -0x14(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 828D3C00: 80E1FFE8  lwz r7, -0x18(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) } as u64;
	// 828D3C04: 9121FFE4  stw r9, -0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), ctx.r[9].u32 ) };
	// 828D3C08: E901FFE0  ld r8, -0x20(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828D3C0C: F901FFE0  std r8, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[8].u64 ) };
	// 828D3C10: 8101FFE0  lwz r8, -0x20(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) } as u64;
	// 828D3C14: 8141FFE4  lwz r10, -0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-28 as u32) ) } as u64;
	// 828D3C18: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828D3C1C: 419A000C  beq cr6, 0x828d3c28
	if ctx.cr[6].eq {
	pc = 0x828D3C28; continue 'dispatch;
	}
	// 828D3C20: 7F08F840  cmplw cr6, r8, r31
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828D3C24: 419A0008  beq cr6, 0x828d3c2c
	if ctx.cr[6].eq {
	pc = 0x828D3C2C; continue 'dispatch;
	}
	// 828D3C28: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D3C2C: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828D3C30: 419A00D0  beq cr6, 0x828d3d00
	if ctx.cr[6].eq {
	pc = 0x828D3D00; continue 'dispatch;
	}
	// 828D3C34: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828D3C38: 409A0008  bne cr6, 0x828d3c40
	if !ctx.cr[6].eq {
	pc = 0x828D3C40; continue 'dispatch;
	}
	// 828D3C3C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D3C40: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3C44: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D3C48: 409A0008  bne cr6, 0x828d3c50
	if !ctx.cr[6].eq {
	pc = 0x828D3C50; continue 'dispatch;
	}
	// 828D3C4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D3C50: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D3C54: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3C58: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828D3C5C: 409A0014  bne cr6, 0x828d3c70
	if !ctx.cr[6].eq {
	pc = 0x828D3C70; continue 'dispatch;
	}
	// 828D3C60: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3C64: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D3C68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D3C6C: 419A0008  beq cr6, 0x828d3c74
	if ctx.cr[6].eq {
	pc = 0x828D3C74; continue 'dispatch;
	}
	// 828D3C70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D3C74: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D3C78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3C7C: 409A0018  bne cr6, 0x828d3c94
	if !ctx.cr[6].eq {
	pc = 0x828D3C94; continue 'dispatch;
	}
	// 828D3C80: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D3C84: 409A0008  bne cr6, 0x828d3c8c
	if !ctx.cr[6].eq {
	pc = 0x828D3C8C; continue 'dispatch;
	}
	// 828D3C88: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D3C8C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3C90: 4BFFFF88  b 0x828d3c18
	pc = 0x828D3C18; continue 'dispatch;
	// 828D3C94: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3C98: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D3C9C: 409A0008  bne cr6, 0x828d3ca4
	if !ctx.cr[6].eq {
	pc = 0x828D3CA4; continue 'dispatch;
	}
	// 828D3CA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D3CA4: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D3CA8: 894B0012  lbz r10, 0x12(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 828D3CAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D3CB0: 409A0010  bne cr6, 0x828d3cc0
	if !ctx.cr[6].eq {
	pc = 0x828D3CC0; continue 'dispatch;
	}
	// 828D3CB4: 54AA063E  clrlwi r10, r5, 0x18
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 828D3CB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D3CBC: 409A001C  bne cr6, 0x828d3cd8
	if !ctx.cr[6].eq {
	pc = 0x828D3CD8; continue 'dispatch;
	}
	// 828D3CC0: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 828D3CC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D3CC8: 409A0030  bne cr6, 0x828d3cf8
	if !ctx.cr[6].eq {
	pc = 0x828D3CF8; continue 'dispatch;
	}
	// 828D3CCC: 54CA063E  clrlwi r10, r6, 0x18
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 828D3CD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D3CD4: 419A0024  beq cr6, 0x828d3cf8
	if ctx.cr[6].eq {
	pc = 0x828D3CF8; continue 'dispatch;
	}
	// 828D3CD8: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828D3CDC: 814A6AB8  lwz r10, 0x6ab8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D3CE0: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D3CE4: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D3CE8: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3CEC: 80870014  lwz r4, 0x14(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D3CF0: 80640008  lwz r3, 8(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D3CF4: 906B0028  stw r3, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[3].u32 ) };
	// 828D3CF8: 98AB0012  stb r5, 0x12(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[5].u8 ) };
	// 828D3CFC: 98CB0013  stb r6, 0x13(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(19 as u32), ctx.r[6].u8 ) };
	// 828D3D00: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D3D04: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 828D3D08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D3D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D3D10 size=1024
    let mut pc: u32 = 0x828D3D10;
    'dispatch: loop {
        match pc {
            0x828D3D10 => {
    //   block [0x828D3D10..0x828D4110)
	// 828D3D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D3D14: 483D56C5  bl 0x82ca93d8
	ctx.lr = 0x828D3D18;
	sub_82CA93D0(ctx, base);
	// 828D3D18: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D3D1C: 3E608349  lis r19, -0x7cb7
	ctx.r[19].s64 = -2092367872;
	// 828D3D20: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D3D24: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 828D3D28: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828D3D2C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D3D30: 81736AB8  lwz r11, 0x6ab8(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D3D34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D3D38: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D3D3C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D3D40: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3D44: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D3D48: 80E90014  lwz r7, 0x14(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D3D4C: 80C80004  lwz r6, 4(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3D50: 82270008  lwz r17, 8(r7)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D3D54: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 828D3D58: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3D5C: 820A00B4  lwz r16, 0xb4(r10)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(180 as u32) ) } as u64;
	// 828D3D60: 4B90DE49  bl 0x821e1ba8
	ctx.lr = 0x828D3D64;
	sub_821E1BA8(ctx, base);
	// 828D3D64: 8134001C  lwz r9, 0x1c(r20)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D3D68: 3A540018  addi r18, r20, 0x18
	ctx.r[18].s64 = ctx.r[20].s64 + 24;
	// 828D3D6C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D3D70: 92410050  stw r18, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[18].u32 ) };
	// 828D3D74: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828D3D78: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 828D3D7C: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 828D3D80: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3D84: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828D3D88: 3B400003  li r26, 3
	ctx.r[26].s64 = 3;
	// 828D3D8C: 3B0B3778  addi r24, r11, 0x3778
	ctx.r[24].s64 = ctx.r[11].s64 + 14200;
	// 828D3D90: 3AEA33B8  addi r23, r10, 0x33b8
	ctx.r[23].s64 = ctx.r[10].s64 + 13240;
	// 828D3D94: 3AC9D5AC  addi r22, r9, -0x2a54
	ctx.r[22].s64 = ctx.r[9].s64 + -10836;
	// 828D3D98: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 828D3D9C: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D3DA0: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 828D3DA4: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D3DA8: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D3DAC: 81720004  lwz r11, 4(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3DB0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828D3DB4: 419A000C  beq cr6, 0x828d3dc0
	if ctx.cr[6].eq {
	pc = 0x828D3DC0; continue 'dispatch;
	}
	// 828D3DB8: 7F1C9040  cmplw cr6, r28, r18
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[18].u32, &mut ctx.xer);
	// 828D3DBC: 419A0008  beq cr6, 0x828d3dc4
	if ctx.cr[6].eq {
	pc = 0x828D3DC4; continue 'dispatch;
	}
	// 828D3DC0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D3DC4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D3DC8: 419A033C  beq cr6, 0x828d4104
	if ctx.cr[6].eq {
	pc = 0x828D4104; continue 'dispatch;
	}
	// 828D3DCC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828D3DD0: 409A0008  bne cr6, 0x828d3dd8
	if !ctx.cr[6].eq {
	pc = 0x828D3DD8; continue 'dispatch;
	}
	// 828D3DD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D3DD8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3DDC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D3DE0: 409A0008  bne cr6, 0x828d3de8
	if !ctx.cr[6].eq {
	pc = 0x828D3DE8; continue 'dispatch;
	}
	// 828D3DE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D3DE8: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D3DEC: 81440014  lwz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D3DF0: 7F105040  cmplw cr6, r16, r10
	ctx.cr[6].compare_u32(ctx.r[16].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828D3DF4: 409A02F8  bne cr6, 0x828d40ec
	if !ctx.cr[6].eq {
	pc = 0x828D40EC; continue 'dispatch;
	}
	// 828D3DF8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D3DFC: 409A0008  bne cr6, 0x828d3e04
	if !ctx.cr[6].eq {
	pc = 0x828D3E04; continue 'dispatch;
	}
	// 828D3E00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D3E04: 81736AB8  lwz r11, 0x6ab8(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D3E08: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D3E0C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D3E10: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3E14: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3E18: 4B990671  bl 0x82264488
	ctx.lr = 0x828D3E1C;
	sub_82264488(ctx, base);
	// 828D3E1C: 811C0004  lwz r8, 4(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3E20: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D3E24: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828D3E28: 409A0008  bne cr6, 0x828d3e30
	if !ctx.cr[6].eq {
	pc = 0x828D3E30; continue 'dispatch;
	}
	// 828D3E2C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D3E30: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 828D3E34: 80D4002C  lwz r6, 0x2c(r20)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D3E38: 80B40028  lwz r5, 0x28(r20)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(40 as u32) ) } as u64;
	// 828D3E3C: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D3E40: 4BFF9D31  bl 0x828cdb70
	ctx.lr = 0x828D3E44;
	sub_828CDB70(ctx, base);
	// 828D3E44: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3E48: 7F1E2040  cmplw cr6, r30, r4
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828D3E4C: 409A0008  bne cr6, 0x828d3e54
	if !ctx.cr[6].eq {
	pc = 0x828D3E54; continue 'dispatch;
	}
	// 828D3E50: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D3E54: 80BE0008  lwz r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D3E58: 8965000E  lbz r11, 0xe(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(14 as u32) ) } as u64;
	// 828D3E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3E60: 419A000C  beq cr6, 0x828d3e6c
	if ctx.cr[6].eq {
	pc = 0x828D3E6C; continue 'dispatch;
	}
	// 828D3E64: 83650034  lwz r27, 0x34(r5)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(52 as u32) ) } as u64;
	// 828D3E68: 48000008  b 0x828d3e70
	pc = 0x828D3E70; continue 'dispatch;
	// 828D3E6C: 83650024  lwz r27, 0x24(r5)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 828D3E70: 815D002C  lwz r10, 0x2c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D3E74: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 828D3E78: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828D3E7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D3E80: 419A00E8  beq cr6, 0x828d3f68
	if ctx.cr[6].eq {
	pc = 0x828D3F68; continue 'dispatch;
	}
	// 828D3E84: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D3E88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3E8C: 419A0020  beq cr6, 0x828d3eac
	if ctx.cr[6].eq {
	pc = 0x828D3EAC; continue 'dispatch;
	}
	// 828D3E90: 894B0043  lbz r10, 0x43(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(67 as u32) ) } as u64;
	// 828D3E94: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D3E98: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D3E9C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D3EA0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D3EA4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3EA8: 480000C4  b 0x828d3f6c
	pc = 0x828D3F6C; continue 'dispatch;
	// 828D3EAC: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D3EB0: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D3EB4: 92A10050  stw r21, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[21].u32 ) };
	// 828D3EB8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D3EBC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D3EC0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D3EC4: 40810054  ble 0x828d3f18
	if !ctx.cr[0].gt {
	pc = 0x828D3F18; continue 'dispatch;
	}
	// 828D3EC8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D3ECC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D3ED0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D3ED4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3ED8: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 828D3EDC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D3EE0: 41980008  blt cr6, 0x828d3ee8
	if ctx.cr[6].lt {
	pc = 0x828D3EE8; continue 'dispatch;
	}
	// 828D3EE4: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 828D3EE8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D3EEC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D3EF0: 419A0014  beq cr6, 0x828d3f04
	if ctx.cr[6].eq {
	pc = 0x828D3F04; continue 'dispatch;
	}
	// 828D3EF4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D3EF8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D3EFC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D3F00: 4800000C  b 0x828d3f0c
	pc = 0x828D3F0C; continue 'dispatch;
	// 828D3F04: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D3F08: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D3F0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D3F10: 4199FFB8  bgt cr6, 0x828d3ec8
	if ctx.cr[6].gt {
	pc = 0x828D3EC8; continue 'dispatch;
	}
	// 828D3F14: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D3F18: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D3F1C: 419A003C  beq cr6, 0x828d3f58
	if ctx.cr[6].eq {
	pc = 0x828D3F58; continue 'dispatch;
	}
	// 828D3F20: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3F24: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 828D3F28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D3F2C: 41990008  bgt cr6, 0x828d3f34
	if ctx.cr[6].gt {
	pc = 0x828D3F34; continue 'dispatch;
	}
	// 828D3F30: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 828D3F34: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D3F38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3F3C: 409A001C  bne cr6, 0x828d3f58
	if !ctx.cr[6].eq {
	pc = 0x828D3F58; continue 'dispatch;
	}
	// 828D3F40: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D3F44: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D3F48: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828D3F4C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D3F50: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3F54: 48000018  b 0x828d3f6c
	pc = 0x828D3F6C; continue 'dispatch;
	// 828D3F58: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D3F5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D3F60: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3F64: 48000008  b 0x828d3f6c
	pc = 0x828D3F6C; continue 'dispatch;
	// 828D3F68: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	// 828D3F6C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D3F70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D3F74: 419A001C  beq cr6, 0x828d3f90
	if ctx.cr[6].eq {
	pc = 0x828D3F90; continue 'dispatch;
	}
	// 828D3F78: 7F1E2040  cmplw cr6, r30, r4
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828D3F7C: 409A0008  bne cr6, 0x828d3f84
	if !ctx.cr[6].eq {
	pc = 0x828D3F84; continue 'dispatch;
	}
	// 828D3F80: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D3F84: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D3F88: C0250040  lfs f1, 0x40(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(64 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D3F8C: 4BF590CD  bl 0x8282d058
	ctx.lr = 0x828D3F90;
	sub_8282D058(ctx, base);
	// 828D3F90: 897D0090  lbz r11, 0x90(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D3F94: 556AD7FE  rlwinm r10, r11, 0x1a, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 828D3F98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D3F9C: 419A0150  beq cr6, 0x828d40ec
	if ctx.cr[6].eq {
	pc = 0x828D40EC; continue 'dispatch;
	}
	// 828D3FA0: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 828D3FA4: 40990148  ble cr6, 0x828d40ec
	if !ctx.cr[6].gt {
	pc = 0x828D40EC; continue 'dispatch;
	}
	// 828D3FA8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3FAC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D3FB0: 409A0008  bne cr6, 0x828d3fb8
	if !ctx.cr[6].eq {
	pc = 0x828D3FB8; continue 'dispatch;
	}
	// 828D3FB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D3FB8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D3FBC: 894B000C  lbz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D3FC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D3FC4: 409A0128  bne cr6, 0x828d40ec
	if !ctx.cr[6].eq {
	pc = 0x828D40EC; continue 'dispatch;
	}
	// 828D3FC8: 7F2B07B4  extsw r11, r25
	ctx.r[11].s64 = ctx.r[25].s32 as i64;
	// 828D3FCC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D3FD0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828D3FD4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828D3FD8: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828D3FDC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828D3FE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D3FE4: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828D3FE8: D18A0000  stfs f12, 0(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828D3FEC: 934A0004  stw r26, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 828D3FF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D3FF4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D3FF8: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 828D3FFC: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828D4000: 4B90DBA9  bl 0x821e1ba8
	ctx.lr = 0x828D4004;
	sub_821E1BA8(ctx, base);
	// 828D4004: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828D4008: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 828D400C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4010: 481504C9  bl 0x82a244d8
	ctx.lr = 0x828D4014;
	sub_82A244D8(ctx, base);
	// 828D4014: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D4018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D401C: 4BACEFA5  bl 0x823a2fc0
	ctx.lr = 0x828D4020;
	sub_823A2FC0(ctx, base);
	// 828D4020: 3880FFFD  li r4, -3
	ctx.r[4].s64 = -3;
	// 828D4024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4028: 4B9E9E29  bl 0x822bde50
	ctx.lr = 0x828D402C;
	sub_822BDE50(ctx, base);
	// 828D402C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 828D4030: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 828D4034: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4038: 481504A1  bl 0x82a244d8
	ctx.lr = 0x828D403C;
	sub_82A244D8(ctx, base);
	// 828D403C: 7F6807B4  extsw r8, r27
	ctx.r[8].s64 = ctx.r[27].s32 as i64;
	// 828D4040: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D4044: 3880FFFD  li r4, -3
	ctx.r[4].s64 = -3;
	// 828D4048: F9010068  std r8, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 828D404C: C9610068  lfd f11, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828D4050: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 828D4054: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4058: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 828D405C: D1270000  stfs f9, 0(r7)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828D4060: 93470004  stw r26, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 828D4064: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D4068: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 828D406C: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 828D4070: 4B9E9DE1  bl 0x822bde50
	ctx.lr = 0x828D4074;
	sub_822BDE50(ctx, base);
	// 828D4074: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828D4078: 38A00009  li r5, 9
	ctx.r[5].s64 = 9;
	// 828D407C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4080: 48150459  bl 0x82a244d8
	ctx.lr = 0x828D4084;
	sub_82A244D8(ctx, base);
	// 828D4084: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4088: 7F1E2840  cmplw cr6, r30, r5
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828D408C: 409A0008  bne cr6, 0x828d4094
	if !ctx.cr[6].eq {
	pc = 0x828D4094; continue 'dispatch;
	}
	// 828D4090: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D4094: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D4098: 3880FFFD  li r4, -3
	ctx.r[4].s64 = -3;
	// 828D409C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D40A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D40A4: C00B0040  lfs f0, 0x40(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D40A8: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828D40AC: 934A0004  stw r26, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 828D40B0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D40B4: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 828D40B8: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828D40BC: 4B9E9D95  bl 0x822bde50
	ctx.lr = 0x828D40C0;
	sub_822BDE50(ctx, base);
	// 828D40C0: 3880FFFD  li r4, -3
	ctx.r[4].s64 = -3;
	// 828D40C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D40C8: 4B9E9D89  bl 0x822bde50
	ctx.lr = 0x828D40CC;
	sub_822BDE50(ctx, base);
	// 828D40CC: 811C0004  lwz r8, 4(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D40D0: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 828D40D4: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828D40D8: 409A0008  bne cr6, 0x828d40e0
	if !ctx.cr[6].eq {
	pc = 0x828D40E0; continue 'dispatch;
	}
	// 828D40DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D40E0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D40E4: 92AB0024  stw r21, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[21].u32 ) };
	// 828D40E8: 92AB003C  stw r21, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[21].u32 ) };
	// 828D40EC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D40F0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D40F4: 409A0008  bne cr6, 0x828d40fc
	if !ctx.cr[6].eq {
	pc = 0x828D40FC; continue 'dispatch;
	}
	// 828D40F8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D40FC: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4100: 4BFFFCAC  b 0x828d3dac
	pc = 0x828D3DAC; continue 'dispatch;
	// 828D4104: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828D4108: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 828D410C: 483D531C  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D4110 size=8
    let mut pc: u32 = 0x828D4110;
    'dispatch: loop {
        match pc {
            0x828D4110 => {
    //   block [0x828D4110..0x828D4118)
	// 828D4110: 80630020  lwz r3, 0x20(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 828D4114: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D4118 size=252
    let mut pc: u32 = 0x828D4118;
    'dispatch: loop {
        match pc {
            0x828D4118 => {
    //   block [0x828D4118..0x828D4214)
	// 828D4118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D411C: 483D52ED  bl 0x82ca9408
	ctx.lr = 0x828D4120;
	sub_82CA93D0(ctx, base);
	// 828D4120: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4124: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828D4128: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D412C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D4130: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4134: 388B49D8  addi r4, r11, 0x49d8
	ctx.r[4].s64 = ctx.r[11].s64 + 18904;
	// 828D4138: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D413C: 4B958D95  bl 0x8222ced0
	ctx.lr = 0x828D4140;
	sub_8222CED0(ctx, base);
	// 828D4140: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828D4144: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D4148: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D414C: 816A6AB8  lwz r11, 0x6ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D4150: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D4154: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D4158: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D415C: 80C70008  lwz r6, 8(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D4160: 80660004  lwz r3, 4(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4164: 4BA488B5  bl 0x8231ca18
	ctx.lr = 0x828D4168;
	sub_8231CA18(ctx, base);
	// 828D4168: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D416C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4170: 4B940C69  bl 0x82214dd8
	ctx.lr = 0x828D4174;
	sub_82214DD8(ctx, base);
	// 828D4174: 811F001C  lwz r8, 0x1c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D4178: 395F0018  addi r10, r31, 0x18
	ctx.r[10].s64 = ctx.r[31].s64 + 24;
	// 828D417C: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 828D4180: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D4184: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4188: 7F0A5040  cmplw cr6, r10, r10
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828D418C: 419A0008  beq cr6, 0x828d4194
	if ctx.cr[6].eq {
	pc = 0x828D4194; continue 'dispatch;
	}
	// 828D4190: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D4194: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828D4198: 419A003C  beq cr6, 0x828d41d4
	if ctx.cr[6].eq {
	pc = 0x828D41D4; continue 'dispatch;
	}
	// 828D419C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D41A0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D41A4: 409A0008  bne cr6, 0x828d41ac
	if !ctx.cr[6].eq {
	pc = 0x828D41AC; continue 'dispatch;
	}
	// 828D41A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D41AC: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D41B0: 80C70014  lwz r6, 0x14(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D41B4: 7F1C3040  cmplw cr6, r28, r6
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D41B8: 409A0008  bne cr6, 0x828d41c0
	if !ctx.cr[6].eq {
	pc = 0x828D41C0; continue 'dispatch;
	}
	// 828D41BC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828D41C0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D41C4: 409A0008  bne cr6, 0x828d41cc
	if !ctx.cr[6].eq {
	pc = 0x828D41CC; continue 'dispatch;
	}
	// 828D41C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D41CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D41D0: 4BFFFFB8  b 0x828d4188
	pc = 0x828D4188; continue 'dispatch;
	// 828D41D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D41D8: 4B8F2591  bl 0x821c6768
	ctx.lr = 0x828D41DC;
	sub_821C6768(ctx, base);
	// 828D41DC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828D41E0: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	// 828D41E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D41E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D41EC: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D41F0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828D41F4: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D41F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D41FC: 4082FFE8  bne 0x828d41e4
	if !ctx.cr[0].eq {
	pc = 0x828D41E4; continue 'dispatch;
	}
	// 828D4200: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828D4204: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D4208: 90FE0000  stw r7, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828D420C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D4210: 483D5248  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D4218 size=896
    let mut pc: u32 = 0x828D4218;
    'dispatch: loop {
        match pc {
            0x828D4218 => {
    //   block [0x828D4218..0x828D4598)
	// 828D4218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D421C: 483D51E9  bl 0x82ca9404
	ctx.lr = 0x828D4220;
	sub_82CA93D0(ctx, base);
	// 828D4220: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4224: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D4228: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828D422C: 3BBB0018  addi r29, r27, 0x18
	ctx.r[29].s64 = ctx.r[27].s64 + 24;
	// 828D4230: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828D4234: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D4238: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D423C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D4240: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D4244: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 828D4248: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D424C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D4250: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4254: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D4258: 419A000C  beq cr6, 0x828d4264
	if ctx.cr[6].eq {
	pc = 0x828D4264; continue 'dispatch;
	}
	// 828D425C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828D4260: 419A0008  beq cr6, 0x828d4268
	if ctx.cr[6].eq {
	pc = 0x828D4268; continue 'dispatch;
	}
	// 828D4264: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D4268: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D426C: 419A0058  beq cr6, 0x828d42c4
	if ctx.cr[6].eq {
	pc = 0x828D42C4; continue 'dispatch;
	}
	// 828D4270: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D4274: 409A0008  bne cr6, 0x828d427c
	if !ctx.cr[6].eq {
	pc = 0x828D427C; continue 'dispatch;
	}
	// 828D4278: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D427C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4280: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D4284: 409A0008  bne cr6, 0x828d428c
	if !ctx.cr[6].eq {
	pc = 0x828D428C; continue 'dispatch;
	}
	// 828D4288: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D428C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D4290: 4BFFA339  bl 0x828ce5c8
	ctx.lr = 0x828D4294;
	sub_828CE5C8(ctx, base);
	// 828D4294: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4298: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D429C: 409A0008  bne cr6, 0x828d42a4
	if !ctx.cr[6].eq {
	pc = 0x828D42A4; continue 'dispatch;
	}
	// 828D42A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D42A4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D42A8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D42AC: 816A002C  lwz r11, 0x2c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D42B0: 7F8BE214  add r28, r11, r28
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828D42B4: 409A0008  bne cr6, 0x828d42bc
	if !ctx.cr[6].eq {
	pc = 0x828D42BC; continue 'dispatch;
	}
	// 828D42B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D42BC: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D42C0: 4BFFFF90  b 0x828d4250
	pc = 0x828D4250; continue 'dispatch;
	// 828D42C4: 7F8A07B4  extsw r10, r28
	ctx.r[10].s64 = ctx.r[28].s32 as i64;
	// 828D42C8: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D42CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D42D0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 828D42D4: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D42D8: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828D42DC: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828D42E0: D19B0030  stfs f12, 0x30(r27)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 828D42E4: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828D42E8: 55283FFE  rlwinm r8, r9, 7, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x01FFFFFFu64;
	// 828D42EC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828D42F0: 419A00EC  beq cr6, 0x828d43dc
	if ctx.cr[6].eq {
	pc = 0x828D43DC; continue 'dispatch;
	}
	// 828D42F4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D42F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D42FC: 419A0020  beq cr6, 0x828d431c
	if ctx.cr[6].eq {
	pc = 0x828D431C; continue 'dispatch;
	}
	// 828D4300: 894A0039  lbz r10, 0x39(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(57 as u32) ) } as u64;
	// 828D4304: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D4308: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D430C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D4310: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D4314: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4318: 480000C8  b 0x828d43e0
	pc = 0x828D43E0; continue 'dispatch;
	// 828D431C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D4320: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828D4324: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D4328: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828D432C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D4330: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D4334: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D4338: 40810054  ble 0x828d438c
	if !ctx.cr[0].gt {
	pc = 0x828D438C; continue 'dispatch;
	}
	// 828D433C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D4340: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D4344: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D4348: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D434C: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 828D4350: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D4354: 41980008  blt cr6, 0x828d435c
	if ctx.cr[6].lt {
	pc = 0x828D435C; continue 'dispatch;
	}
	// 828D4358: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828D435C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D4360: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D4364: 419A0014  beq cr6, 0x828d4378
	if ctx.cr[6].eq {
	pc = 0x828D4378; continue 'dispatch;
	}
	// 828D4368: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D436C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D4370: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D4374: 4800000C  b 0x828d4380
	pc = 0x828D4380; continue 'dispatch;
	// 828D4378: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D437C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D4380: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D4384: 4199FFB8  bgt cr6, 0x828d433c
	if ctx.cr[6].gt {
	pc = 0x828D433C; continue 'dispatch;
	}
	// 828D4388: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D438C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D4390: 419A003C  beq cr6, 0x828d43cc
	if ctx.cr[6].eq {
	pc = 0x828D43CC; continue 'dispatch;
	}
	// 828D4394: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4398: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 828D439C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D43A0: 41990008  bgt cr6, 0x828d43a8
	if ctx.cr[6].gt {
	pc = 0x828D43A8; continue 'dispatch;
	}
	// 828D43A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D43A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D43AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D43B0: 409A001C  bne cr6, 0x828d43cc
	if !ctx.cr[6].eq {
	pc = 0x828D43CC; continue 'dispatch;
	}
	// 828D43B4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D43B8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D43BC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D43C0: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D43C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D43C8: 48000018  b 0x828d43e0
	pc = 0x828D43E0; continue 'dispatch;
	// 828D43CC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D43D0: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D43D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D43D8: 48000008  b 0x828d43e0
	pc = 0x828D43E0; continue 'dispatch;
	// 828D43DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D43E0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D43E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D43E8: 419A01A8  beq cr6, 0x828d4590
	if ctx.cr[6].eq {
	pc = 0x828D4590; continue 'dispatch;
	}
	// 828D43EC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828D43F0: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D43F4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D43F8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D43FC: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D4400: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4404: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4408: 4B95E371  bl 0x82232778
	ctx.lr = 0x828D440C;
	sub_82232778(ctx, base);
	// 828D440C: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828D4410: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D4414: 419A0030  beq cr6, 0x828d4444
	if ctx.cr[6].eq {
	pc = 0x828D4444; continue 'dispatch;
	}
	// 828D4418: 38600011  li r3, 0x11
	ctx.r[3].s64 = 17;
	// 828D441C: 939F01A0  stw r28, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[28].u32 ) };
	// 828D4420: 4BC0B9A9  bl 0x824dfdc8
	ctx.lr = 0x828D4424;
	sub_824DFDC8(ctx, base);
	// 828D4424: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D4428: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828D442C: 40990018  ble cr6, 0x828d4444
	if !ctx.cr[6].gt {
	pc = 0x828D4444; continue 'dispatch;
	}
	// 828D4430: 4B8AA6D9  bl 0x8217eb08
	ctx.lr = 0x828D4434;
	sub_8217EB08(ctx, base);
	// 828D4434: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D4438: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828D443C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828D4440: 4BA17719  bl 0x822ebb58
	ctx.lr = 0x828D4444;
	sub_822EBB58(ctx, base);
	// 828D4444: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D4448: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D444C: 388B1AEC  addi r4, r11, 0x1aec
	ctx.r[4].s64 = ctx.r[11].s64 + 6892;
	// 828D4450: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4454: 4B958A7D  bl 0x8222ced0
	ctx.lr = 0x828D4458;
	sub_8222CED0(ctx, base);
	// 828D4458: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D445C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D4460: 4B8C8189  bl 0x8219c5e8
	ctx.lr = 0x828D4464;
	sub_8219C5E8(ctx, base);
	// 828D4464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4468: 4B8F2301  bl 0x821c6768
	ctx.lr = 0x828D446C;
	sub_821C6768(ctx, base);
	// 828D446C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828D4470: 38EA7088  addi r7, r10, 0x7088
	ctx.r[7].s64 = ctx.r[10].s64 + 28808;
	// 828D4474: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828D4478: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D447C: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828D4480: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 828D4484: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D4488: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D448C: 4082FFE8  bne 0x828d4474
	if !ctx.cr[0].eq {
	pc = 0x828D4474; continue 'dispatch;
	}
	// 828D4490: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828D4494: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D4498: 38A63784  addi r5, r6, 0x3784
	ctx.r[5].s64 = ctx.r[6].s64 + 14212;
	// 828D449C: 4B8DE05D  bl 0x821b24f8
	ctx.lr = 0x828D44A0;
	sub_821B24F8(ctx, base);
	// 828D44A0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828D44A4: 4B8C26DD  bl 0x82196b80
	ctx.lr = 0x828D44A8;
	sub_82196B80(ctx, base);
	// 828D44A8: C01B0030  lfs f0, 0x30(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D44AC: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 828D44B0: 419800E0  blt cr6, 0x828d4590
	if ctx.cr[6].lt {
	pc = 0x828D4590; continue 'dispatch;
	}
	// 828D44B4: 38800028  li r4, 0x28
	ctx.r[4].s64 = 40;
	// 828D44B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D44BC: 4BC04ACD  bl 0x824d8f88
	ctx.lr = 0x828D44C0;
	sub_824D8F88(ctx, base);
	// 828D44C0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D44C4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D44C8: 3BAB37A8  addi r29, r11, 0x37a8
	ctx.r[29].s64 = ctx.r[11].s64 + 14248;
	// 828D44CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D44D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D44D4: 4B9589FD  bl 0x8222ced0
	ctx.lr = 0x828D44D8;
	sub_8222CED0(ctx, base);
	// 828D44D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D44DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D44E0: 4B8C8109  bl 0x8219c5e8
	ctx.lr = 0x828D44E4;
	sub_8219C5E8(ctx, base);
	// 828D44E4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D44E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D44EC: 419A0010  beq cr6, 0x828d44fc
	if ctx.cr[6].eq {
	pc = 0x828D44FC; continue 'dispatch;
	}
	// 828D44F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D44F4: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 828D44F8: 4BA4CE11  bl 0x82321308
	ctx.lr = 0x828D44FC;
	sub_82321308(ctx, base);
	// 828D44FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4500: 4B9408D9  bl 0x82214dd8
	ctx.lr = 0x828D4504;
	sub_82214DD8(ctx, base);
	// 828D4504: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D4508: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D450C: 3BCB37C8  addi r30, r11, 0x37c8
	ctx.r[30].s64 = ctx.r[11].s64 + 14280;
	// 828D4510: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4514: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D4518: 4B9589B9  bl 0x8222ced0
	ctx.lr = 0x828D451C;
	sub_8222CED0(ctx, base);
	// 828D451C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D4520: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D4524: 4B8C80C5  bl 0x8219c5e8
	ctx.lr = 0x828D4528;
	sub_8219C5E8(ctx, base);
	// 828D4528: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D452C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D4530: 419A0010  beq cr6, 0x828d4540
	if ctx.cr[6].eq {
	pc = 0x828D4540; continue 'dispatch;
	}
	// 828D4534: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D4538: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 828D453C: 4BA4CDCD  bl 0x82321308
	ctx.lr = 0x828D4540;
	sub_82321308(ctx, base);
	// 828D4540: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4544: 4B940895  bl 0x82214dd8
	ctx.lr = 0x828D4548;
	sub_82214DD8(ctx, base);
	// 828D4548: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D454C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4550: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4554: 4B95897D  bl 0x8222ced0
	ctx.lr = 0x828D4558;
	sub_8222CED0(ctx, base);
	// 828D4558: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D455C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4560: 4BC041C9  bl 0x824d8728
	ctx.lr = 0x828D4564;
	sub_824D8728(ctx, base);
	// 828D4564: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4568: 4B940871  bl 0x82214dd8
	ctx.lr = 0x828D456C;
	sub_82214DD8(ctx, base);
	// 828D456C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D4570: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4574: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4578: 4B958959  bl 0x8222ced0
	ctx.lr = 0x828D457C;
	sub_8222CED0(ctx, base);
	// 828D457C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D4580: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4584: 4BC041A5  bl 0x824d8728
	ctx.lr = 0x828D4588;
	sub_824D8728(ctx, base);
	// 828D4588: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D458C: 4B94084D  bl 0x82214dd8
	ctx.lr = 0x828D4590;
	sub_82214DD8(ctx, base);
	// 828D4590: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828D4594: 483D4EC0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D4598 size=28
    let mut pc: u32 = 0x828D4598;
    'dispatch: loop {
        match pc {
            0x828D4598 => {
    //   block [0x828D4598..0x828D45B4)
	// 828D4598: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828D459C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D45A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828D45A4: 80A60004  lwz r5, 4(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D45A8: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D45AC: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828D45B0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D45B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D45B4 size=68
    let mut pc: u32 = 0x828D45B4;
    'dispatch: loop {
        match pc {
            0x828D45B4 => {
    //   block [0x828D45B4..0x828D45F8)
	// 828D45B4: 80E60004  lwz r7, 4(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D45B8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828D45BC: 409A0008  bne cr6, 0x828d45c4
	if !ctx.cr[6].eq {
	pc = 0x828D45C4; continue 'dispatch;
	}
	// 828D45C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D45C4: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D45C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D45CC: 419A0018  beq cr6, 0x828d45e4
	if ctx.cr[6].eq {
	pc = 0x828D45E4; continue 'dispatch;
	}
	// 828D45D0: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D45D4: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 828D45D8: 4099000C  ble cr6, 0x828d45e4
	if !ctx.cr[6].gt {
	pc = 0x828D45E4; continue 'dispatch;
	}
	// 828D45DC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D45E0: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 828D45E4: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828D45E8: 409A0008  bne cr6, 0x828d45f0
	if !ctx.cr[6].eq {
	pc = 0x828D45F0; continue 'dispatch;
	}
	// 828D45EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D45F0: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D45F4: 4BFFFFB8  b 0x828d45ac
	sub_828D4598(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D45F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D45F8 size=4
    let mut pc: u32 = 0x828D45F8;
    'dispatch: loop {
        match pc {
            0x828D45F8 => {
    //   block [0x828D45F8..0x828D45FC)
	// 828D45F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D4600 size=1052
    let mut pc: u32 = 0x828D4600;
    'dispatch: loop {
        match pc {
            0x828D4600 => {
    //   block [0x828D4600..0x828D4A1C)
	// 828D4600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D4604: 483D4DF5  bl 0x82ca93f8
	ctx.lr = 0x828D4608;
	sub_82CA93D0(ctx, base);
	// 828D4608: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D460C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D4610: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D4614: 4B94AC45  bl 0x8221f258
	ctx.lr = 0x828D4618;
	sub_8221F258(ctx, base);
	// 828D4618: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D461C: 419A0008  beq cr6, 0x828d4624
	if ctx.cr[6].eq {
	pc = 0x828D4624; continue 'dispatch;
	}
	// 828D4620: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828D4624: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D4628: 41820008  beq 0x828d4630
	if ctx.cr[0].eq {
	pc = 0x828D4630; continue 'dispatch;
	}
	// 828D462C: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828D4630: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 828D4634: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 828D4638: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 828D463C: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D4640: 3B9F0018  addi r28, r31, 0x18
	ctx.r[28].s64 = ctx.r[31].s64 + 24;
	// 828D4644: 93010068  stw r24, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[24].u32 ) };
	// 828D4648: 817A6AB8  lwz r11, 0x6ab8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D464C: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4650: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D4654: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D4658: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D465C: 80C70008  lwz r6, 8(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D4660: 80A60004  lwz r5, 4(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4664: 80850024  lwz r4, 0x24(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 828D4668: 80640004  lwz r3, 4(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D466C: 836300B4  lwz r27, 0xb4(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(180 as u32) ) } as u64;
	// 828D4670: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4674: 7F1CE040  cmplw cr6, r28, r28
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828D4678: 419A0008  beq cr6, 0x828d4680
	if ctx.cr[6].eq {
	pc = 0x828D4680; continue 'dispatch;
	}
	// 828D467C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D4680: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D4684: 419A009C  beq cr6, 0x828d4720
	if ctx.cr[6].eq {
	pc = 0x828D4720; continue 'dispatch;
	}
	// 828D4688: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D468C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D4690: 409A0008  bne cr6, 0x828d4698
	if !ctx.cr[6].eq {
	pc = 0x828D4698; continue 'dispatch;
	}
	// 828D4694: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D4698: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D469C: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D46A0: 7F09D840  cmplw cr6, r9, r27
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828D46A4: 409A0064  bne cr6, 0x828d4708
	if !ctx.cr[6].eq {
	pc = 0x828D4708; continue 'dispatch;
	}
	// 828D46A8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D46AC: 409A0008  bne cr6, 0x828d46b4
	if !ctx.cr[6].eq {
	pc = 0x828D46B4; continue 'dispatch;
	}
	// 828D46B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D46B4: 892A000F  lbz r9, 0xf(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(15 as u32) ) } as u64;
	// 828D46B8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D46BC: 419A004C  beq cr6, 0x828d4708
	if ctx.cr[6].eq {
	pc = 0x828D4708; continue 'dispatch;
	}
	// 828D46C0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D46C4: 409A0008  bne cr6, 0x828d46cc
	if !ctx.cr[6].eq {
	pc = 0x828D46CC; continue 'dispatch;
	}
	// 828D46C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D46CC: 892A000C  lbz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D46D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D46D4: 409A0034  bne cr6, 0x828d4708
	if !ctx.cr[6].eq {
	pc = 0x828D4708; continue 'dispatch;
	}
	// 828D46D8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D46DC: 409A0008  bne cr6, 0x828d46e4
	if !ctx.cr[6].eq {
	pc = 0x828D46E4; continue 'dispatch;
	}
	// 828D46E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D46E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D46E8: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 828D46EC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D46F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D46F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D46F8: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 828D46FC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828D4700: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828D4704: 481C2C65  bl 0x82a97368
	ctx.lr = 0x828D4708;
	sub_82A97368(ctx, base);
	// 828D4708: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D470C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D4710: 409A0008  bne cr6, 0x828d4718
	if !ctx.cr[6].eq {
	pc = 0x828D4718; continue 'dispatch;
	}
	// 828D4714: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D4718: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D471C: 4BFFFF54  b 0x828d4670
	pc = 0x828D4670; continue 'dispatch;
	// 828D4720: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828D4724: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D4728: 419A0068  beq cr6, 0x828d4790
	if ctx.cr[6].eq {
	pc = 0x828D4790; continue 'dispatch;
	}
	// 828D472C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D4730: 4BFFFE69  bl 0x828d4598
	ctx.lr = 0x828D4734;
	sub_828D4598(ctx, base);
	// 828D4734: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D4738: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D473C: 419A0054  beq cr6, 0x828d4790
	if ctx.cr[6].eq {
	pc = 0x828D4790; continue 'dispatch;
	}
	// 828D4740: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D4744: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4748: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D474C: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D4750: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D4754: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D4758: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828D475C: 93010068  stw r24, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[24].u32 ) };
	// 828D4760: 419A0020  beq cr6, 0x828d4780
	if ctx.cr[6].eq {
	pc = 0x828D4780; continue 'dispatch;
	}
	// 828D4764: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D4768: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D476C: 4B9475CD  bl 0x8221bd38
	ctx.lr = 0x828D4770;
	sub_8221BD38(ctx, base);
	// 828D4770: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D4774: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D4778: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828D477C: 409AFFE8  bne cr6, 0x828d4764
	if !ctx.cr[6].eq {
	pc = 0x828D4764; continue 'dispatch;
	}
	// 828D4780: 4B9475B9  bl 0x8221bd38
	ctx.lr = 0x828D4784;
	sub_8221BD38(ctx, base);
	// 828D4784: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D4788: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828D478C: 483D4CBC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 828D4790: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4794: 3FA00098  lis r29, 0x98
	ctx.r[29].s64 = 9961472;
	// 828D4798: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	// 828D479C: 63BD9680  ori r29, r29, 0x9680
	ctx.r[29].u64 = ctx.r[29].u64 | 38528;
	// 828D47A0: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D47A4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D47A8: 7F1CE040  cmplw cr6, r28, r28
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828D47AC: 419A0008  beq cr6, 0x828d47b4
	if ctx.cr[6].eq {
	pc = 0x828D47B4; continue 'dispatch;
	}
	// 828D47B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D47B4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D47B8: 419A00A8  beq cr6, 0x828d4860
	if ctx.cr[6].eq {
	pc = 0x828D4860; continue 'dispatch;
	}
	// 828D47BC: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D47C0: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828D47C4: 409A0008  bne cr6, 0x828d47cc
	if !ctx.cr[6].eq {
	pc = 0x828D47CC; continue 'dispatch;
	}
	// 828D47C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D47CC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D47D0: 83EB0014  lwz r31, 0x14(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D47D4: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828D47D8: 419A0070  beq cr6, 0x828d4848
	if ctx.cr[6].eq {
	pc = 0x828D4848; continue 'dispatch;
	}
	// 828D47DC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828D47E0: 409A0008  bne cr6, 0x828d47e8
	if !ctx.cr[6].eq {
	pc = 0x828D47E8; continue 'dispatch;
	}
	// 828D47E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D47E8: 892B000F  lbz r9, 0xf(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(15 as u32) ) } as u64;
	// 828D47EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D47F0: 419A0058  beq cr6, 0x828d4848
	if ctx.cr[6].eq {
	pc = 0x828D4848; continue 'dispatch;
	}
	// 828D47F4: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828D47F8: 409A0008  bne cr6, 0x828d4800
	if !ctx.cr[6].eq {
	pc = 0x828D4800; continue 'dispatch;
	}
	// 828D47FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D4800: 896B000C  lbz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D4804: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D4808: 409A0040  bne cr6, 0x828d4848
	if !ctx.cr[6].eq {
	pc = 0x828D4848; continue 'dispatch;
	}
	// 828D480C: 817A6AB8  lwz r11, 0x6ab8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D4810: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D4814: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D4818: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D481C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D4820: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D4824: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4828: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D482C: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4830: 80670008  lwz r3, 8(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D4834: 4BC3F255  bl 0x82513a88
	ctx.lr = 0x828D4838;
	sub_82513A88(ctx, base);
	// 828D4838: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828D483C: 4098000C  bge cr6, 0x828d4848
	if !ctx.cr[6].lt {
	pc = 0x828D4848; continue 'dispatch;
	}
	// 828D4840: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D4844: 7FF9FB78  mr r25, r31
	ctx.r[25].u64 = ctx.r[31].u64;
	// 828D4848: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D484C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D4850: 409A0008  bne cr6, 0x828d4858
	if !ctx.cr[6].eq {
	pc = 0x828D4858; continue 'dispatch;
	}
	// 828D4854: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D4858: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D485C: 4BFFFF48  b 0x828d47a4
	pc = 0x828D47A4; continue 'dispatch;
	// 828D4860: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 828D4864: 419A0168  beq cr6, 0x828d49cc
	if ctx.cr[6].eq {
	pc = 0x828D49CC; continue 'dispatch;
	}
	// 828D4868: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D486C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4870: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4874: 7F1CE040  cmplw cr6, r28, r28
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828D4878: 419A0008  beq cr6, 0x828d4880
	if ctx.cr[6].eq {
	pc = 0x828D4880; continue 'dispatch;
	}
	// 828D487C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D4880: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D4884: 419A009C  beq cr6, 0x828d4920
	if ctx.cr[6].eq {
	pc = 0x828D4920; continue 'dispatch;
	}
	// 828D4888: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D488C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D4890: 409A0008  bne cr6, 0x828d4898
	if !ctx.cr[6].eq {
	pc = 0x828D4898; continue 'dispatch;
	}
	// 828D4894: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D4898: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D489C: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D48A0: 7F09C840  cmplw cr6, r9, r25
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[25].u32, &mut ctx.xer);
	// 828D48A4: 409A0064  bne cr6, 0x828d4908
	if !ctx.cr[6].eq {
	pc = 0x828D4908; continue 'dispatch;
	}
	// 828D48A8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D48AC: 409A0008  bne cr6, 0x828d48b4
	if !ctx.cr[6].eq {
	pc = 0x828D48B4; continue 'dispatch;
	}
	// 828D48B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D48B4: 892A000F  lbz r9, 0xf(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(15 as u32) ) } as u64;
	// 828D48B8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D48BC: 419A004C  beq cr6, 0x828d4908
	if ctx.cr[6].eq {
	pc = 0x828D4908; continue 'dispatch;
	}
	// 828D48C0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D48C4: 409A0008  bne cr6, 0x828d48cc
	if !ctx.cr[6].eq {
	pc = 0x828D48CC; continue 'dispatch;
	}
	// 828D48C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D48CC: 892A000C  lbz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D48D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D48D4: 409A0034  bne cr6, 0x828d4908
	if !ctx.cr[6].eq {
	pc = 0x828D4908; continue 'dispatch;
	}
	// 828D48D8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D48DC: 409A0008  bne cr6, 0x828d48e4
	if !ctx.cr[6].eq {
	pc = 0x828D48E4; continue 'dispatch;
	}
	// 828D48E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D48E4: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 828D48E8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D48EC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D48F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D48F4: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 828D48F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D48FC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828D4900: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828D4904: 481C2A65  bl 0x82a97368
	ctx.lr = 0x828D4908;
	sub_82A97368(ctx, base);
	// 828D4908: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D490C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D4910: 409A0008  bne cr6, 0x828d4918
	if !ctx.cr[6].eq {
	pc = 0x828D4918; continue 'dispatch;
	}
	// 828D4914: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D4918: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D491C: 4BFFFF54  b 0x828d4870
	pc = 0x828D4870; continue 'dispatch;
	// 828D4920: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828D4924: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D4928: 419A00A4  beq cr6, 0x828d49cc
	if ctx.cr[6].eq {
	pc = 0x828D49CC; continue 'dispatch;
	}
	// 828D492C: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D4930: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 828D4934: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 828D4938: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D493C: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 828D4940: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D4944: 419A0038  beq cr6, 0x828d497c
	if ctx.cr[6].eq {
	pc = 0x828D497C; continue 'dispatch;
	}
	// 828D4948: 81470008  lwz r10, 8(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D494C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D4950: 419A0018  beq cr6, 0x828d4968
	if ctx.cr[6].eq {
	pc = 0x828D4968; continue 'dispatch;
	}
	// 828D4954: 810A002C  lwz r8, 0x2c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D4958: 7F083000  cmpw cr6, r8, r6
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[6].s32, &mut ctx.xer);
	// 828D495C: 4099000C  ble cr6, 0x828d4968
	if !ctx.cr[6].gt {
	pc = 0x828D4968; continue 'dispatch;
	}
	// 828D4960: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 828D4964: 7D064378  mr r6, r8
	ctx.r[6].u64 = ctx.r[8].u64;
	// 828D4968: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D496C: 409A0008  bne cr6, 0x828d4974
	if !ctx.cr[6].eq {
	pc = 0x828D4974; continue 'dispatch;
	}
	// 828D4970: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D4974: 80E70000  lwz r7, 0(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4978: 4BFFFFC8  b 0x828d4940
	pc = 0x828D4940; continue 'dispatch;
	// 828D497C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D4980: 419A0050  beq cr6, 0x828d49d0
	if ctx.cr[6].eq {
	pc = 0x828D49D0; continue 'dispatch;
	}
	// 828D4984: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D4988: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D498C: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D4990: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D4994: 93010068  stw r24, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[24].u32 ) };
	// 828D4998: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828D499C: 419A0020  beq cr6, 0x828d49bc
	if ctx.cr[6].eq {
	pc = 0x828D49BC; continue 'dispatch;
	}
	// 828D49A0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D49A4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D49A8: 4B947391  bl 0x8221bd38
	ctx.lr = 0x828D49AC;
	sub_8221BD38(ctx, base);
	// 828D49AC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D49B0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D49B4: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828D49B8: 409AFFE8  bne cr6, 0x828d49a0
	if !ctx.cr[6].eq {
	pc = 0x828D49A0; continue 'dispatch;
	}
	// 828D49BC: 4B94737D  bl 0x8221bd38
	ctx.lr = 0x828D49C0;
	sub_8221BD38(ctx, base);
	// 828D49C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D49C4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828D49C8: 483D4A80  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 828D49CC: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D49D0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D49D4: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D49D8: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D49DC: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D49E0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D49E4: 93010068  stw r24, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[24].u32 ) };
	// 828D49E8: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828D49EC: 419A0020  beq cr6, 0x828d4a0c
	if ctx.cr[6].eq {
	pc = 0x828D4A0C; continue 'dispatch;
	}
	// 828D49F0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D49F4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D49F8: 4B947341  bl 0x8221bd38
	ctx.lr = 0x828D49FC;
	sub_8221BD38(ctx, base);
	// 828D49FC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D4A00: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D4A04: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828D4A08: 409AFFE8  bne cr6, 0x828d49f0
	if !ctx.cr[6].eq {
	pc = 0x828D49F0; continue 'dispatch;
	}
	// 828D4A0C: 4B94732D  bl 0x8221bd38
	ctx.lr = 0x828D4A10;
	sub_8221BD38(ctx, base);
	// 828D4A10: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828D4A14: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828D4A18: 483D4A30  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D4A20 size=96
    let mut pc: u32 = 0x828D4A20;
    'dispatch: loop {
        match pc {
            0x828D4A20 => {
    //   block [0x828D4A20..0x828D4A80)
	// 828D4A20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D4A24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D4A28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D4A2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4A30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D4A34: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828D4A38: 4BFFFBC9  bl 0x828d4600
	ctx.lr = 0x828D4A3C;
	sub_828D4600(ctx, base);
	// 828D4A3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D4A40: 419A0014  beq cr6, 0x828d4a54
	if ctx.cr[6].eq {
	pc = 0x828D4A54; continue 'dispatch;
	}
	// 828D4A44: 38830008  addi r4, r3, 8
	ctx.r[4].s64 = ctx.r[3].s64 + 8;
	// 828D4A48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4A4C: 4B91B7F5  bl 0x821f0240
	ctx.lr = 0x828D4A50;
	sub_821F0240(ctx, base);
	// 828D4A50: 48000018  b 0x828d4a68
	pc = 0x828D4A68; continue 'dispatch;
	// 828D4A54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D4A58: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4A5C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 828D4A60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4A64: 4B95846D  bl 0x8222ced0
	ctx.lr = 0x828D4A68;
	sub_8222CED0(ctx, base);
	// 828D4A68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4A6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D4A70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D4A74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D4A78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D4A7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D4A80 size=376
    let mut pc: u32 = 0x828D4A80;
    'dispatch: loop {
        match pc {
            0x828D4A80 => {
    //   block [0x828D4A80..0x828D4BF8)
	// 828D4A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D4A84: 483D4989  bl 0x82ca940c
	ctx.lr = 0x828D4A88;
	sub_82CA93D0(ctx, base);
	// 828D4A88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4A8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D4A90: 4BFFFB71  bl 0x828d4600
	ctx.lr = 0x828D4A94;
	sub_828D4600(ctx, base);
	// 828D4A94: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D4A98: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D4A9C: 419A0154  beq cr6, 0x828d4bf0
	if ctx.cr[6].eq {
	pc = 0x828D4BF0; continue 'dispatch;
	}
	// 828D4AA0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4AA4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D4AA8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828D4AAC: 5549D7FE  rlwinm r9, r10, 0x1a, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 828D4AB0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D4AB4: 419A00F4  beq cr6, 0x828d4ba8
	if ctx.cr[6].eq {
	pc = 0x828D4BA8; continue 'dispatch;
	}
	// 828D4AB8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D4ABC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D4AC0: 419A0024  beq cr6, 0x828d4ae4
	if ctx.cr[6].eq {
	pc = 0x828D4AE4; continue 'dispatch;
	}
	// 828D4AC4: 892A0066  lbz r9, 0x66(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(102 as u32) ) } as u64;
	// 828D4AC8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D4ACC: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828D4AD0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828D4AD4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4AD8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D4ADC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D4AE0: 480000CC  b 0x828d4bac
	pc = 0x828D4BAC; continue 'dispatch;
	// 828D4AE4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D4AE8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D4AEC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828D4AF0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D4AF4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D4AF8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D4AFC: 40810054  ble 0x828d4b50
	if !ctx.cr[0].gt {
	pc = 0x828D4B50; continue 'dispatch;
	}
	// 828D4B00: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D4B04: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D4B08: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D4B0C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4B10: 2F070066  cmpwi cr6, r7, 0x66
	ctx.cr[6].compare_i32(ctx.r[7].s32, 102, &mut ctx.xer);
	// 828D4B14: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D4B18: 41980008  blt cr6, 0x828d4b20
	if ctx.cr[6].lt {
	pc = 0x828D4B20; continue 'dispatch;
	}
	// 828D4B1C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828D4B20: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D4B24: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D4B28: 419A0014  beq cr6, 0x828d4b3c
	if ctx.cr[6].eq {
	pc = 0x828D4B3C; continue 'dispatch;
	}
	// 828D4B2C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D4B30: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D4B34: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D4B38: 4800000C  b 0x828d4b44
	pc = 0x828D4B44; continue 'dispatch;
	// 828D4B3C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D4B40: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D4B44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D4B48: 4199FFB8  bgt cr6, 0x828d4b00
	if ctx.cr[6].gt {
	pc = 0x828D4B00; continue 'dispatch;
	}
	// 828D4B4C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D4B50: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D4B54: 419A0040  beq cr6, 0x828d4b94
	if ctx.cr[6].eq {
	pc = 0x828D4B94; continue 'dispatch;
	}
	// 828D4B58: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4B5C: 2F0B0066  cmpwi cr6, r11, 0x66
	ctx.cr[6].compare_i32(ctx.r[11].s32, 102, &mut ctx.xer);
	// 828D4B60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D4B64: 41990008  bgt cr6, 0x828d4b6c
	if ctx.cr[6].gt {
	pc = 0x828D4B6C; continue 'dispatch;
	}
	// 828D4B68: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D4B6C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D4B70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D4B74: 409A0020  bne cr6, 0x828d4b94
	if !ctx.cr[6].eq {
	pc = 0x828D4B94; continue 'dispatch;
	}
	// 828D4B78: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D4B7C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D4B80: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D4B84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4B88: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D4B8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D4B90: 4800001C  b 0x828d4bac
	pc = 0x828D4BAC; continue 'dispatch;
	// 828D4B94: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D4B98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4B9C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D4BA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D4BA4: 48000008  b 0x828d4bac
	pc = 0x828D4BAC; continue 'dispatch;
	// 828D4BA8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D4BAC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D4BB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D4BB4: 419A003C  beq cr6, 0x828d4bf0
	if ctx.cr[6].eq {
	pc = 0x828D4BF0; continue 'dispatch;
	}
	// 828D4BB8: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D4BBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D4BC0: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 828D4BC4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828D4BC8: 4BA4C531  bl 0x823210f8
	ctx.lr = 0x828D4BCC;
	sub_823210F8(ctx, base);
	// 828D4BCC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D4BD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4BD4: 4B91B66D  bl 0x821f0240
	ctx.lr = 0x828D4BD8;
	sub_821F0240(ctx, base);
	// 828D4BD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D4BDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4BE0: E8BD0000  ld r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 828D4BE4: 4BC4C9C5  bl 0x825215a8
	ctx.lr = 0x828D4BE8;
	sub_825215A8(ctx, base);
	// 828D4BE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4BEC: 4B9401ED  bl 0x82214dd8
	ctx.lr = 0x828D4BF0;
	sub_82214DD8(ctx, base);
	// 828D4BF0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D4BF4: 483D4868  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D4BF8 size=928
    let mut pc: u32 = 0x828D4BF8;
    'dispatch: loop {
        match pc {
            0x828D4BF8 => {
    //   block [0x828D4BF8..0x828D4F98)
	// 828D4BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D4BFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D4C00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D4C04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D4C08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4C0C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D4C10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D4C14: 3BCB37E8  addi r30, r11, 0x37e8
	ctx.r[30].s64 = ctx.r[11].s64 + 14312;
	// 828D4C18: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4C1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4C20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D4C24: 4B9582AD  bl 0x8222ced0
	ctx.lr = 0x828D4C28;
	sub_8222CED0(ctx, base);
	// 828D4C28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4C2C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D4C30: 48000D71  bl 0x828d59a0
	ctx.lr = 0x828D4C34;
	sub_828D59A0(ctx, base);
	// 828D4C34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4C38: 4B9401A1  bl 0x82214dd8
	ctx.lr = 0x828D4C3C;
	sub_82214DD8(ctx, base);
	// 828D4C3C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828D4C40: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4C44: 388A37FC  addi r4, r10, 0x37fc
	ctx.r[4].s64 = ctx.r[10].s64 + 14332;
	// 828D4C48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4C4C: 4B958285  bl 0x8222ced0
	ctx.lr = 0x828D4C50;
	sub_8222CED0(ctx, base);
	// 828D4C50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D4C54: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4C58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4C5C: 4B958275  bl 0x8222ced0
	ctx.lr = 0x828D4C60;
	sub_8222CED0(ctx, base);
	// 828D4C60: 3D20828D  lis r9, -0x7d73
	ctx.r[9].s64 = -2104688640;
	// 828D4C64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4C68: 38C915E0  addi r6, r9, 0x15e0
	ctx.r[6].s64 = ctx.r[9].s64 + 5600;
	// 828D4C6C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828D4C70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D4C74: 48000F75  bl 0x828d5be8
	ctx.lr = 0x828D4C78;
	sub_828D5BE8(ctx, base);
	// 828D4C78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4C7C: 4B94015D  bl 0x82214dd8
	ctx.lr = 0x828D4C80;
	sub_82214DD8(ctx, base);
	// 828D4C80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4C84: 4B940155  bl 0x82214dd8
	ctx.lr = 0x828D4C88;
	sub_82214DD8(ctx, base);
	// 828D4C88: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828D4C8C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4C90: 38883820  addi r4, r8, 0x3820
	ctx.r[4].s64 = ctx.r[8].s64 + 14368;
	// 828D4C94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4C98: 4B958239  bl 0x8222ced0
	ctx.lr = 0x828D4C9C;
	sub_8222CED0(ctx, base);
	// 828D4C9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D4CA0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4CA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4CA8: 4B958229  bl 0x8222ced0
	ctx.lr = 0x828D4CAC;
	sub_8222CED0(ctx, base);
	// 828D4CAC: 3CE08219  lis r7, -0x7de7
	ctx.r[7].s64 = -2112290816;
	// 828D4CB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4CB4: 38C77CE0  addi r6, r7, 0x7ce0
	ctx.r[6].s64 = ctx.r[7].s64 + 31968;
	// 828D4CB8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D4CBC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828D4CC0: 48001131  bl 0x828d5df0
	ctx.lr = 0x828D4CC4;
	sub_828D5DF0(ctx, base);
	// 828D4CC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4CC8: 4B940111  bl 0x82214dd8
	ctx.lr = 0x828D4CCC;
	sub_82214DD8(ctx, base);
	// 828D4CCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4CD0: 4B940109  bl 0x82214dd8
	ctx.lr = 0x828D4CD4;
	sub_82214DD8(ctx, base);
	// 828D4CD4: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828D4CD8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4CDC: 38863830  addi r4, r6, 0x3830
	ctx.r[4].s64 = ctx.r[6].s64 + 14384;
	// 828D4CE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4CE4: 4B9581ED  bl 0x8222ced0
	ctx.lr = 0x828D4CE8;
	sub_8222CED0(ctx, base);
	// 828D4CE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D4CEC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4CF0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4CF4: 4B9581DD  bl 0x8222ced0
	ctx.lr = 0x828D4CF8;
	sub_8222CED0(ctx, base);
	// 828D4CF8: 3C80828D  lis r4, -0x7d73
	ctx.r[4].s64 = -2104688640;
	// 828D4CFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4D00: 38C43D10  addi r6, r4, 0x3d10
	ctx.r[6].s64 = ctx.r[4].s64 + 15632;
	// 828D4D04: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D4D08: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828D4D0C: 480012E5  bl 0x828d5ff0
	ctx.lr = 0x828D4D10;
	sub_828D5FF0(ctx, base);
	// 828D4D10: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4D14: 4B9400C5  bl 0x82214dd8
	ctx.lr = 0x828D4D18;
	sub_82214DD8(ctx, base);
	// 828D4D18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4D1C: 4B9400BD  bl 0x82214dd8
	ctx.lr = 0x828D4D20;
	sub_82214DD8(ctx, base);
	// 828D4D20: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 828D4D24: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4D28: 38833850  addi r4, r3, 0x3850
	ctx.r[4].s64 = ctx.r[3].s64 + 14416;
	// 828D4D2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4D30: 4B9581A1  bl 0x8222ced0
	ctx.lr = 0x828D4D34;
	sub_8222CED0(ctx, base);
	// 828D4D34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D4D38: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4D3C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4D40: 4B958191  bl 0x8222ced0
	ctx.lr = 0x828D4D44;
	sub_8222CED0(ctx, base);
	// 828D4D44: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D4D48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4D4C: 38CB2800  addi r6, r11, 0x2800
	ctx.r[6].s64 = ctx.r[11].s64 + 10240;
	// 828D4D50: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D4D54: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828D4D58: 48001099  bl 0x828d5df0
	ctx.lr = 0x828D4D5C;
	sub_828D5DF0(ctx, base);
	// 828D4D5C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4D60: 4B940079  bl 0x82214dd8
	ctx.lr = 0x828D4D64;
	sub_82214DD8(ctx, base);
	// 828D4D64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4D68: 4B940071  bl 0x82214dd8
	ctx.lr = 0x828D4D6C;
	sub_82214DD8(ctx, base);
	// 828D4D6C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828D4D70: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4D74: 388A3864  addi r4, r10, 0x3864
	ctx.r[4].s64 = ctx.r[10].s64 + 14436;
	// 828D4D78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4D7C: 4B958155  bl 0x8222ced0
	ctx.lr = 0x828D4D80;
	sub_8222CED0(ctx, base);
	// 828D4D80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D4D84: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4D88: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4D8C: 4B958145  bl 0x8222ced0
	ctx.lr = 0x828D4D90;
	sub_8222CED0(ctx, base);
	// 828D4D90: 3D20828D  lis r9, -0x7d73
	ctx.r[9].s64 = -2104688640;
	// 828D4D94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4D98: 38C90530  addi r6, r9, 0x530
	ctx.r[6].s64 = ctx.r[9].s64 + 1328;
	// 828D4D9C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D4DA0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828D4DA4: 48001455  bl 0x828d61f8
	ctx.lr = 0x828D4DA8;
	sub_828D61F8(ctx, base);
	// 828D4DA8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4DAC: 4B94002D  bl 0x82214dd8
	ctx.lr = 0x828D4DB0;
	sub_82214DD8(ctx, base);
	// 828D4DB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4DB4: 4B940025  bl 0x82214dd8
	ctx.lr = 0x828D4DB8;
	sub_82214DD8(ctx, base);
	// 828D4DB8: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828D4DBC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4DC0: 38883878  addi r4, r8, 0x3878
	ctx.r[4].s64 = ctx.r[8].s64 + 14456;
	// 828D4DC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4DC8: 4B958109  bl 0x8222ced0
	ctx.lr = 0x828D4DCC;
	sub_8222CED0(ctx, base);
	// 828D4DCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D4DD0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4DD4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4DD8: 4B9580F9  bl 0x8222ced0
	ctx.lr = 0x828D4DDC;
	sub_8222CED0(ctx, base);
	// 828D4DDC: 3CE0828D  lis r7, -0x7d73
	ctx.r[7].s64 = -2104688640;
	// 828D4DE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4DE4: 38C70568  addi r6, r7, 0x568
	ctx.r[6].s64 = ctx.r[7].s64 + 1384;
	// 828D4DE8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D4DEC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828D4DF0: 48001409  bl 0x828d61f8
	ctx.lr = 0x828D4DF4;
	sub_828D61F8(ctx, base);
	// 828D4DF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4DF8: 4B93FFE1  bl 0x82214dd8
	ctx.lr = 0x828D4DFC;
	sub_82214DD8(ctx, base);
	// 828D4DFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4E00: 4B93FFD9  bl 0x82214dd8
	ctx.lr = 0x828D4E04;
	sub_82214DD8(ctx, base);
	// 828D4E04: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828D4E08: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4E0C: 38863890  addi r4, r6, 0x3890
	ctx.r[4].s64 = ctx.r[6].s64 + 14480;
	// 828D4E10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4E14: 4B9580BD  bl 0x8222ced0
	ctx.lr = 0x828D4E18;
	sub_8222CED0(ctx, base);
	// 828D4E18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D4E1C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4E20: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4E24: 4B9580AD  bl 0x8222ced0
	ctx.lr = 0x828D4E28;
	sub_8222CED0(ctx, base);
	// 828D4E28: 3C80828D  lis r4, -0x7d73
	ctx.r[4].s64 = -2104688640;
	// 828D4E2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4E30: 38C44110  addi r6, r4, 0x4110
	ctx.r[6].s64 = ctx.r[4].s64 + 16656;
	// 828D4E34: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D4E38: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828D4E3C: 480015BD  bl 0x828d63f8
	ctx.lr = 0x828D4E40;
	sub_828D63F8(ctx, base);
	// 828D4E40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4E44: 4B93FF95  bl 0x82214dd8
	ctx.lr = 0x828D4E48;
	sub_82214DD8(ctx, base);
	// 828D4E48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4E4C: 4B93FF8D  bl 0x82214dd8
	ctx.lr = 0x828D4E50;
	sub_82214DD8(ctx, base);
	// 828D4E50: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 828D4E54: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4E58: 388338AC  addi r4, r3, 0x38ac
	ctx.r[4].s64 = ctx.r[3].s64 + 14508;
	// 828D4E5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4E60: 4B958071  bl 0x8222ced0
	ctx.lr = 0x828D4E64;
	sub_8222CED0(ctx, base);
	// 828D4E64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D4E68: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4E6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4E70: 4B958061  bl 0x8222ced0
	ctx.lr = 0x828D4E74;
	sub_8222CED0(ctx, base);
	// 828D4E74: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D4E78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4E7C: 38CB4118  addi r6, r11, 0x4118
	ctx.r[6].s64 = ctx.r[11].s64 + 16664;
	// 828D4E80: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D4E84: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828D4E88: 48001779  bl 0x828d6600
	ctx.lr = 0x828D4E8C;
	sub_828D6600(ctx, base);
	// 828D4E8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4E90: 4B93FF49  bl 0x82214dd8
	ctx.lr = 0x828D4E94;
	sub_82214DD8(ctx, base);
	// 828D4E94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4E98: 4B93FF41  bl 0x82214dd8
	ctx.lr = 0x828D4E9C;
	sub_82214DD8(ctx, base);
	// 828D4E9C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828D4EA0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4EA4: 388A38D0  addi r4, r10, 0x38d0
	ctx.r[4].s64 = ctx.r[10].s64 + 14544;
	// 828D4EA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4EAC: 4B958025  bl 0x8222ced0
	ctx.lr = 0x828D4EB0;
	sub_8222CED0(ctx, base);
	// 828D4EB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D4EB4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4EB8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4EBC: 4B958015  bl 0x8222ced0
	ctx.lr = 0x828D4EC0;
	sub_8222CED0(ctx, base);
	// 828D4EC0: 3D20828D  lis r9, -0x7d73
	ctx.r[9].s64 = -2104688640;
	// 828D4EC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4EC8: 38C9D2A0  addi r6, r9, -0x2d60
	ctx.r[6].s64 = ctx.r[9].s64 + -11616;
	// 828D4ECC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D4ED0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828D4ED4: 48001935  bl 0x828d6808
	ctx.lr = 0x828D4ED8;
	sub_828D6808(ctx, base);
	// 828D4ED8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4EDC: 4B93FEFD  bl 0x82214dd8
	ctx.lr = 0x828D4EE0;
	sub_82214DD8(ctx, base);
	// 828D4EE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4EE4: 4B93FEF5  bl 0x82214dd8
	ctx.lr = 0x828D4EE8;
	sub_82214DD8(ctx, base);
	// 828D4EE8: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828D4EEC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4EF0: 388838E8  addi r4, r8, 0x38e8
	ctx.r[4].s64 = ctx.r[8].s64 + 14568;
	// 828D4EF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4EF8: 4B957FD9  bl 0x8222ced0
	ctx.lr = 0x828D4EFC;
	sub_8222CED0(ctx, base);
	// 828D4EFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D4F00: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4F04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4F08: 4B957FC9  bl 0x8222ced0
	ctx.lr = 0x828D4F0C;
	sub_8222CED0(ctx, base);
	// 828D4F0C: 3CE0828D  lis r7, -0x7d73
	ctx.r[7].s64 = -2104688640;
	// 828D4F10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4F14: 38C74A20  addi r6, r7, 0x4a20
	ctx.r[6].s64 = ctx.r[7].s64 + 18976;
	// 828D4F18: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D4F1C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828D4F20: 48001AF1  bl 0x828d6a10
	ctx.lr = 0x828D4F24;
	sub_828D6A10(ctx, base);
	// 828D4F24: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4F28: 4B93FEB1  bl 0x82214dd8
	ctx.lr = 0x828D4F2C;
	sub_82214DD8(ctx, base);
	// 828D4F2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4F30: 4B93FEA9  bl 0x82214dd8
	ctx.lr = 0x828D4F34;
	sub_82214DD8(ctx, base);
	// 828D4F34: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828D4F38: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4F3C: 38863910  addi r4, r6, 0x3910
	ctx.r[4].s64 = ctx.r[6].s64 + 14608;
	// 828D4F40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4F44: 4B957F8D  bl 0x8222ced0
	ctx.lr = 0x828D4F48;
	sub_8222CED0(ctx, base);
	// 828D4F48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D4F4C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D4F50: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4F54: 4B957F7D  bl 0x8222ced0
	ctx.lr = 0x828D4F58;
	sub_8222CED0(ctx, base);
	// 828D4F58: 3C80828D  lis r4, -0x7d73
	ctx.r[4].s64 = -2104688640;
	// 828D4F5C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D4F60: 38C44A80  addi r6, r4, 0x4a80
	ctx.r[6].s64 = ctx.r[4].s64 + 19072;
	// 828D4F64: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828D4F68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4F6C: 48001CAD  bl 0x828d6c18
	ctx.lr = 0x828D4F70;
	sub_828D6C18(ctx, base);
	// 828D4F70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4F74: 4B93FE65  bl 0x82214dd8
	ctx.lr = 0x828D4F78;
	sub_82214DD8(ctx, base);
	// 828D4F78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4F7C: 4B93FE5D  bl 0x82214dd8
	ctx.lr = 0x828D4F80;
	sub_82214DD8(ctx, base);
	// 828D4F80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D4F84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D4F88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D4F8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D4F90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D4F94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D4F98 size=116
    let mut pc: u32 = 0x828D4F98;
    'dispatch: loop {
        match pc {
            0x828D4F98 => {
    //   block [0x828D4F98..0x828D500C)
	// 828D4F98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D4F9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D4FA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D4FA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D4FA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4FAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D4FB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D4FB4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828D4FB8: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 828D4FBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D4FC0: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 828D4FC4: 4B8BEE75  bl 0x82193e38
	ctx.lr = 0x828D4FC8;
	sub_82193E38(ctx, base);
	// 828D4FC8: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828D4FCC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D4FD0: 38E92850  addi r7, r9, 0x2850
	ctx.r[7].s64 = ctx.r[9].s64 + 10320;
	// 828D4FD4: 57C607FE  clrlwi r6, r30, 0x1f
	ctx.r[6].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828D4FD8: 911F0010  stw r8, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 828D4FDC: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828D4FE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4FE4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 828D4FE8: 419A000C  beq cr6, 0x828d4ff4
	if ctx.cr[6].eq {
	pc = 0x828D4FF4; continue 'dispatch;
	}
	// 828D4FEC: 4B946D4D  bl 0x8221bd38
	ctx.lr = 0x828D4FF0;
	sub_8221BD38(ctx, base);
	// 828D4FF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4FF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D4FF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D4FFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D5000: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D5004: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D5008: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D5010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D5010 size=80
    let mut pc: u32 = 0x828D5010;
    'dispatch: loop {
        match pc {
            0x828D5010 => {
    //   block [0x828D5010..0x828D5060)
	// 828D5010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D5014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D5018: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D501C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D5020: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D5024: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828D5028: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D502C: 419A0020  beq cr6, 0x828d504c
	if ctx.cr[6].eq {
	pc = 0x828D504C; continue 'dispatch;
	}
	// 828D5030: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D5034: 38BF001C  addi r5, r31, 0x1c
	ctx.r[5].s64 = ctx.r[31].s64 + 28;
	// 828D5038: 388B393C  addi r4, r11, 0x393c
	ctx.r[4].s64 = ctx.r[11].s64 + 14652;
	// 828D503C: 4BAD842D  bl 0x823ad468
	ctx.lr = 0x828D5040;
	sub_823AD468(ctx, base);
	// 828D5040: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D5044: 7D2A51D6  mullw r9, r10, r10
	ctx.r[9].s64 = (ctx.r[10].s32 as i64) * (ctx.r[10].s32 as i64);
	// 828D5048: 913F001C  stw r9, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 828D504C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D5050: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D5054: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D5058: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D505C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D5060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D5060 size=180
    let mut pc: u32 = 0x828D5060;
    'dispatch: loop {
        match pc {
            0x828D5060 => {
    //   block [0x828D5060..0x828D5114)
	// 828D5060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D5064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D5068: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D506C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D5070: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D5074: 389F0014  addi r4, r31, 0x14
	ctx.r[4].s64 = ctx.r[31].s64 + 20;
	// 828D5078: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D507C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D5080: 41990014  bgt cr6, 0x828d5094
	if ctx.cr[6].gt {
	pc = 0x828D5094; continue 'dispatch;
	}
	// 828D5084: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D5088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D508C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D5090: 40990008  ble cr6, 0x828d5098
	if !ctx.cr[6].gt {
	pc = 0x828D5098; continue 'dispatch;
	}
	// 828D5094: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D5098: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D509C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D50A0: 419A0060  beq cr6, 0x828d5100
	if ctx.cr[6].eq {
	pc = 0x828D5100; continue 'dispatch;
	}
	// 828D50A4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828D50A8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D50AC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D50B0: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D50B4: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D50B8: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D50BC: 4B98F3CD  bl 0x82264488
	ctx.lr = 0x828D50C0;
	sub_82264488(ctx, base);
	// 828D50C0: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 828D50C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D50C8: 38A70B7C  addi r5, r7, 0xb7c
	ctx.r[5].s64 = ctx.r[7].s64 + 2940;
	// 828D50CC: 90C10054  stw r6, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[6].u32 ) };
	// 828D50D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D50D4: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 828D50D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D50DC: 4B93F7BD  bl 0x82214898
	ctx.lr = 0x828D50E0;
	sub_82214898(ctx, base);
	// 828D50E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D50E4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828D50E8: 4BBFCDE1  bl 0x824d1ec8
	ctx.lr = 0x828D50EC;
	sub_824D1EC8(ctx, base);
	// 828D50EC: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 828D50F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D50F4: 39640B7C  addi r11, r4, 0xb7c
	ctx.r[11].s64 = ctx.r[4].s64 + 2940;
	// 828D50F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828D50FC: 4B8BED3D  bl 0x82193e38
	ctx.lr = 0x828D5100;
	sub_82193E38(ctx, base);
	// 828D5100: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D5104: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D5108: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D510C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D5110: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D5118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D5118 size=1424
    let mut pc: u32 = 0x828D5118;
    'dispatch: loop {
        match pc {
            0x828D5118 => {
    //   block [0x828D5118..0x828D56A8)
	// 828D5118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D511C: 483D42E9  bl 0x82ca9404
	ctx.lr = 0x828D5120;
	sub_82CA93D0(ctx, base);
	// 828D5120: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828D5124: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D5128: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828D512C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D5130: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828D5134: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D5138: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D513C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D5140: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5144: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828D5148: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828D514C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D5150: 419A054C  beq cr6, 0x828d569c
	if ctx.cr[6].eq {
	pc = 0x828D569C; continue 'dispatch;
	}
	// 828D5154: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5158: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D515C: 419A00CC  beq cr6, 0x828d5228
	if ctx.cr[6].eq {
	pc = 0x828D5228; continue 'dispatch;
	}
	// 828D5160: 555E003E  slwi r30, r10, 0
	ctx.r[30].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 828D5164: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D5168: 419A0534  beq cr6, 0x828d569c
	if ctx.cr[6].eq {
	pc = 0x828D569C; continue 'dispatch;
	}
	// 828D516C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D5170: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D5174: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828D5178: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D517C: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 828D5180: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828D5184: 4E800421  bctrl
	ctx.lr = 0x828D5188;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D5188: 809E007C  lwz r4, 0x7c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 828D518C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828D5190: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5194: 80E80040  lwz r7, 0x40(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(64 as u32) ) } as u64;
	// 828D5198: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 828D519C: 4E800421  bctrl
	ctx.lr = 0x828D51A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D51A0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828D51A4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828D51A8: 807B001C  lwz r3, 0x1c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D51AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D51B0: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D56A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D56A8 size=172
    let mut pc: u32 = 0x828D56A8;
    'dispatch: loop {
        match pc {
            0x828D56A8 => {
    //   block [0x828D56A8..0x828D5754)
	// 828D56A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D56AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D56B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D56B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D56B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D56BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D56C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D56C4: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828D56C8: 409A0074  bne cr6, 0x828d573c
	if !ctx.cr[6].eq {
	pc = 0x828D573C; continue 'dispatch;
	}
	// 828D56CC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D56D0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D56D4: 388B394C  addi r4, r11, 0x394c
	ctx.r[4].s64 = ctx.r[11].s64 + 14668;
	// 828D56D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D56DC: 4B9577F5  bl 0x8222ced0
	ctx.lr = 0x828D56E0;
	sub_8222CED0(ctx, base);
	// 828D56E0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D56E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D56E8: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 828D56EC: 4BBDD0CD  bl 0x824b27b8
	ctx.lr = 0x828D56F0;
	sub_824B27B8(ctx, base);
	// 828D56F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D56F4: 4B93F6E5  bl 0x82214dd8
	ctx.lr = 0x828D56F8;
	sub_82214DD8(ctx, base);
	// 828D56F8: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828D56FC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D5700: 388A33EC  addi r4, r10, 0x33ec
	ctx.r[4].s64 = ctx.r[10].s64 + 13292;
	// 828D5704: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5708: 4B9577C9  bl 0x8222ced0
	ctx.lr = 0x828D570C;
	sub_8222CED0(ctx, base);
	// 828D570C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D5710: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D5714: 409A0010  bne cr6, 0x828d5724
	if !ctx.cr[6].eq {
	pc = 0x828D5724; continue 'dispatch;
	}
	// 828D5718: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D571C: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 828D5720: 48000008  b 0x828d5728
	pc = 0x828D5728; continue 'dispatch;
	// 828D5724: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5728: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 828D572C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D5730: 4BBAB121  bl 0x82480850
	ctx.lr = 0x828D5734;
	sub_82480850(ctx, base);
	// 828D5734: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5738: 4B93F6A1  bl 0x82214dd8
	ctx.lr = 0x828D573C;
	sub_82214DD8(ctx, base);
	// 828D573C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D5740: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D5744: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D5748: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D574C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D5750: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D5758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D5758 size=172
    let mut pc: u32 = 0x828D5758;
    'dispatch: loop {
        match pc {
            0x828D5758 => {
    //   block [0x828D5758..0x828D5804)
	// 828D5758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D575C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D5760: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D5764: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D5768: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D576C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D5770: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D5774: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 828D5778: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D577C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D5780: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828D5784: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5788: 4B93F111  bl 0x82214898
	ctx.lr = 0x828D578C;
	sub_82214898(ctx, base);
	// 828D578C: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	// 828D5790: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D5794: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D5798: 4BBFC731  bl 0x824d1ec8
	ctx.lr = 0x828D579C;
	sub_824D1EC8(ctx, base);
	// 828D579C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828D57A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D57A4: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 828D57A8: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 828D57AC: 4B8BE68D  bl 0x82193e38
	ctx.lr = 0x828D57B0;
	sub_82193E38(ctx, base);
	// 828D57B0: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D57B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D57B8: 419A0020  beq cr6, 0x828d57d8
	if ctx.cr[6].eq {
	pc = 0x828D57D8; continue 'dispatch;
	}
	// 828D57BC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D57C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D57C4: 419A000C  beq cr6, 0x828d57d0
	if ctx.cr[6].eq {
	pc = 0x828D57D0; continue 'dispatch;
	}
	// 828D57C8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828D57CC: 48000010  b 0x828d57dc
	pc = 0x828D57DC; continue 'dispatch;
	// 828D57D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D57D4: 4B8BE665  bl 0x82193e38
	ctx.lr = 0x828D57D8;
	sub_82193E38(ctx, base);
	// 828D57D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D57DC: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D57E0: 915E0014  stw r10, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 828D57E4: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828D57E8: 913E0018  stw r9, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 828D57EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D57F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D57F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D57F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D57FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D5800: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D5808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828D5808 size=8
    let mut pc: u32 = 0x828D5808;
    'dispatch: loop {
        match pc {
            0x828D5808 => {
    //   block [0x828D5808..0x828D5810)
	// 828D5808: D0230020  stfs f1, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 828D580C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D5810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828D5810 size=16
    let mut pc: u32 = 0x828D5810;
    'dispatch: loop {
        match pc {
            0x828D5810 => {
    //   block [0x828D5810..0x828D5820)
	// 828D5810: C0030020  lfs f0, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D5814: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 828D5818: D1A30020  stfs f13, 0x20(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 828D581C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D5820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D5820 size=320
    let mut pc: u32 = 0x828D5820;
    'dispatch: loop {
        match pc {
            0x828D5820 => {
    //   block [0x828D5820..0x828D5960)
	// 828D5820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D5824: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D5828: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D582C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D5830: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D5834: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D5838: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D583C: 3BCB3958  addi r30, r11, 0x3958
	ctx.r[30].s64 = ctx.r[11].s64 + 14680;
	// 828D5840: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D5844: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5848: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D584C: 4B957685  bl 0x8222ced0
	ctx.lr = 0x828D5850;
	sub_8222CED0(ctx, base);
	// 828D5850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D5854: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D5858: 480015C9  bl 0x828d6e20
	ctx.lr = 0x828D585C;
	sub_828D6E20(ctx, base);
	// 828D585C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5860: 4B93F579  bl 0x82214dd8
	ctx.lr = 0x828D5864;
	sub_82214DD8(ctx, base);
	// 828D5864: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828D5868: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D586C: 388A3968  addi r4, r10, 0x3968
	ctx.r[4].s64 = ctx.r[10].s64 + 14696;
	// 828D5870: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D5874: 4B95765D  bl 0x8222ced0
	ctx.lr = 0x828D5878;
	sub_8222CED0(ctx, base);
	// 828D5878: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D587C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D5880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5884: 4B95764D  bl 0x8222ced0
	ctx.lr = 0x828D5888;
	sub_8222CED0(ctx, base);
	// 828D5888: 3D20828D  lis r9, -0x7d73
	ctx.r[9].s64 = -2104688640;
	// 828D588C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D5890: 38C95758  addi r6, r9, 0x5758
	ctx.r[6].s64 = ctx.r[9].s64 + 22360;
	// 828D5894: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828D5898: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D589C: 480017CD  bl 0x828d7068
	ctx.lr = 0x828D58A0;
	sub_828D7068(ctx, base);
	// 828D58A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D58A4: 4B93F535  bl 0x82214dd8
	ctx.lr = 0x828D58A8;
	sub_82214DD8(ctx, base);
	// 828D58A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D58AC: 4B93F52D  bl 0x82214dd8
	ctx.lr = 0x828D58B0;
	sub_82214DD8(ctx, base);
	// 828D58B0: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828D58B4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D58B8: 38883974  addi r4, r8, 0x3974
	ctx.r[4].s64 = ctx.r[8].s64 + 14708;
	// 828D58BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D58C0: 4B957611  bl 0x8222ced0
	ctx.lr = 0x828D58C4;
	sub_8222CED0(ctx, base);
	// 828D58C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D58C8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D58CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D58D0: 4B957601  bl 0x8222ced0
	ctx.lr = 0x828D58D4;
	sub_8222CED0(ctx, base);
	// 828D58D4: 3CE0828D  lis r7, -0x7d73
	ctx.r[7].s64 = -2104688640;
	// 828D58D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D58DC: 38C75808  addi r6, r7, 0x5808
	ctx.r[6].s64 = ctx.r[7].s64 + 22536;
	// 828D58E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D58E4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828D58E8: 48001989  bl 0x828d7270
	ctx.lr = 0x828D58EC;
	sub_828D7270(ctx, base);
	// 828D58EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D58F0: 4B93F4E9  bl 0x82214dd8
	ctx.lr = 0x828D58F4;
	sub_82214DD8(ctx, base);
	// 828D58F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D58F8: 4B93F4E1  bl 0x82214dd8
	ctx.lr = 0x828D58FC;
	sub_82214DD8(ctx, base);
	// 828D58FC: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828D5900: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D5904: 3886398C  addi r4, r6, 0x398c
	ctx.r[4].s64 = ctx.r[6].s64 + 14732;
	// 828D5908: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D590C: 4B9575C5  bl 0x8222ced0
	ctx.lr = 0x828D5910;
	sub_8222CED0(ctx, base);
	// 828D5910: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D5914: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D5918: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D591C: 4B9575B5  bl 0x8222ced0
	ctx.lr = 0x828D5920;
	sub_8222CED0(ctx, base);
	// 828D5920: 3C80828D  lis r4, -0x7d73
	ctx.r[4].s64 = -2104688640;
	// 828D5924: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D5928: 38C45810  addi r6, r4, 0x5810
	ctx.r[6].s64 = ctx.r[4].s64 + 22544;
	// 828D592C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828D5930: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D5934: 4800193D  bl 0x828d7270
	ctx.lr = 0x828D5938;
	sub_828D7270(ctx, base);
	// 828D5938: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D593C: 4B93F49D  bl 0x82214dd8
	ctx.lr = 0x828D5940;
	sub_82214DD8(ctx, base);
	// 828D5940: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5944: 4B93F495  bl 0x82214dd8
	ctx.lr = 0x828D5948;
	sub_82214DD8(ctx, base);
	// 828D5948: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D594C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D5950: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D5954: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D5958: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D595C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D5960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D5960 size=64
    let mut pc: u32 = 0x828D5960;
    'dispatch: loop {
        match pc {
            0x828D5960 => {
    //   block [0x828D5960..0x828D59A0)
	// 828D5960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D5964: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D5968: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D596C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D5970: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D5974: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D5978: 419A0014  beq cr6, 0x828d598c
	if ctx.cr[6].eq {
	pc = 0x828D598C; continue 'dispatch;
	}
	// 828D597C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 828D5980: 4B93F459  bl 0x82214dd8
	ctx.lr = 0x828D5984;
	sub_82214DD8(ctx, base);
	// 828D5984: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D5988: 4B9463B1  bl 0x8221bd38
	ctx.lr = 0x828D598C;
	sub_8221BD38(ctx, base);
	// 828D598C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D5990: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D5994: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D5998: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D599C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D59A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D59A0 size=584
    let mut pc: u32 = 0x828D59A0;
    'dispatch: loop {
        match pc {
            0x828D59A0 => {
    //   block [0x828D59A0..0x828D5BE8)
	// 828D59A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D59A4: 483D3A5D  bl 0x82ca9400
	ctx.lr = 0x828D59A8;
	sub_82CA93D0(ctx, base);
	// 828D59A8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D59AC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D59B0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D59B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D59B8: 409A0010  bne cr6, 0x828d59c8
	if !ctx.cr[6].eq {
	pc = 0x828D59C8; continue 'dispatch;
	}
	// 828D59BC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D59C0: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828D59C4: 48000008  b 0x828d59cc
	pc = 0x828D59CC; continue 'dispatch;
	// 828D59C8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D59CC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D59D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D59D4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D59D8: 4BAF8BE9  bl 0x823ce5c0
	ctx.lr = 0x828D59DC;
	sub_823CE5C0(ctx, base);
	// 828D59DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D59E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D59E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D59E8: 4BAF8819  bl 0x823ce200
	ctx.lr = 0x828D59EC;
	sub_823CE200(ctx, base);
	// 828D59EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D59F0: 4B8E2129  bl 0x821b7b18
	ctx.lr = 0x828D59F4;
	sub_821B7B18(ctx, base);
	// 828D59F4: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828D59F8: 4B949861  bl 0x8221f258
	ctx.lr = 0x828D59FC;
	sub_8221F258(ctx, base);
	// 828D59FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D5A00: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D5A04: 419A0040  beq cr6, 0x828d5a44
	if ctx.cr[6].eq {
	pc = 0x828D5A44; continue 'dispatch;
	}
	// 828D5A08: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828D5A0C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D5A10: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828D5A14: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D5A18: 4B949841  bl 0x8221f258
	ctx.lr = 0x828D5A1C;
	sub_8221F258(ctx, base);
	// 828D5A1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D5A20: 419A0028  beq cr6, 0x828d5a48
	if ctx.cr[6].eq {
	pc = 0x828D5A48; continue 'dispatch;
	}
	// 828D5A24: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828D5A28: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828D5A2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D5A30: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828D5A34: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D5A38: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D5A3C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D5A40: 4800000C  b 0x828d5a4c
	pc = 0x828D5A4C; continue 'dispatch;
	// 828D5A44: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D5A48: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828D5A4C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D5A50: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D5A54: 419A00FC  beq cr6, 0x828d5b50
	if ctx.cr[6].eq {
	pc = 0x828D5B50; continue 'dispatch;
	}
	// 828D5A58: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5A5C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828D5A60: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D5A64: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D5A68: 4B9536A1  bl 0x82229108
	ctx.lr = 0x828D5A6C;
	sub_82229108(ctx, base);
	// 828D5A6C: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D5A70: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828D5A74: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D5A78: 3BCB7470  addi r30, r11, 0x7470
	ctx.r[30].s64 = ctx.r[11].s64 + 29808;
	// 828D5A7C: 4B951E05  bl 0x82227880
	ctx.lr = 0x828D5A80;
	sub_82227880(ctx, base);
	// 828D5A80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D5A84: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828D5A88: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D5A8C: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828D5A90: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D5A94: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828D5A98: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828D5A9C: 4B8C4FE5  bl 0x8219aa80
	ctx.lr = 0x828D5AA0;
	sub_8219AA80(ctx, base);
	// 828D5AA0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828D5AA4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828D5AA8: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828D5AAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5AB0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D5AB4: 4BAF896D  bl 0x823ce420
	ctx.lr = 0x828D5AB8;
	sub_823CE420(ctx, base);
	// 828D5AB8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D5ABC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828D5AC0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D5AC4: 4814EC05  bl 0x82a246c8
	ctx.lr = 0x828D5AC8;
	sub_82A246C8(ctx, base);
	// 828D5AC8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D5ACC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828D5AD0: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828D5AD4: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828D5AD8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D5ADC: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5AE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D5AE4: 4B953625  bl 0x82229108
	ctx.lr = 0x828D5AE8;
	sub_82229108(ctx, base);
	// 828D5AE8: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 828D5AEC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828D5AF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D5AF4: 3BEB6A78  addi r31, r11, 0x6a78
	ctx.r[31].s64 = ctx.r[11].s64 + 27256;
	// 828D5AF8: 4B951D89  bl 0x82227880
	ctx.lr = 0x828D5AFC;
	sub_82227880(ctx, base);
	// 828D5AFC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828D5B00: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828D5B04: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D5B08: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828D5B0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D5B10: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828D5B14: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828D5B18: 4B8C4F69  bl 0x8219aa80
	ctx.lr = 0x828D5B1C;
	sub_8219AA80(ctx, base);
	// 828D5B1C: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828D5B20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D5B24: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828D5B28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5B2C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D5B30: 4BAF88F1  bl 0x823ce420
	ctx.lr = 0x828D5B34;
	sub_823CE420(ctx, base);
	// 828D5B34: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D5B38: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828D5B3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D5B40: 4814EB89  bl 0x82a246c8
	ctx.lr = 0x828D5B44;
	sub_82A246C8(ctx, base);
	// 828D5B44: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D5B48: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828D5B4C: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828D5B50: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828D5B54: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828D5B58: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828D5B5C: 419A0020  beq cr6, 0x828d5b7c
	if ctx.cr[6].eq {
	pc = 0x828D5B7C; continue 'dispatch;
	}
	// 828D5B60: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D5B64: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D5B68: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D5B6C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828D5B70: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D5B74: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D5B78: 4082FFE8  bne 0x828d5b60
	if !ctx.cr[0].eq {
	pc = 0x828D5B60; continue 'dispatch;
	}
	// 828D5B7C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D5B80: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D5B84: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828D5B88: 4BA1FDC1  bl 0x822f5948
	ctx.lr = 0x828D5B8C;
	sub_822F5948(ctx, base);
	// 828D5B8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D5B90: 4B8E1F89  bl 0x821b7b18
	ctx.lr = 0x828D5B94;
	sub_821B7B18(ctx, base);
	// 828D5B94: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828D5B98: 419A0040  beq cr6, 0x828d5bd8
	if ctx.cr[6].eq {
	pc = 0x828D5BD8; continue 'dispatch;
	}
	// 828D5B9C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D5BA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D5BA4: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D5BA8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D5BAC: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D5BB0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D5BB4: 4082FFE8  bne 0x828d5b9c
	if !ctx.cr[0].eq {
	pc = 0x828D5B9C; continue 'dispatch;
	}
	// 828D5BB8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D5BBC: 409A001C  bne cr6, 0x828d5bd8
	if !ctx.cr[6].eq {
	pc = 0x828D5BD8; continue 'dispatch;
	}
	// 828D5BC0: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D5BC4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D5BC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D5BCC: 4E800421  bctrl
	ctx.lr = 0x828D5BD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D5BD0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D5BD4: 4B946165  bl 0x8221bd38
	ctx.lr = 0x828D5BD8;
	sub_8221BD38(ctx, base);
	// 828D5BD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5BDC: 4B8E1F3D  bl 0x821b7b18
	ctx.lr = 0x828D5BE0;
	sub_821B7B18(ctx, base);
	// 828D5BE0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828D5BE4: 483D386C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D5BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D5BE8 size=516
    let mut pc: u32 = 0x828D5BE8;
    'dispatch: loop {
        match pc {
            0x828D5BE8 => {
    //   block [0x828D5BE8..0x828D5DEC)
	// 828D5BE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D5BEC: 483D3811  bl 0x82ca93fc
	ctx.lr = 0x828D5BF0;
	sub_82CA93D0(ctx, base);
	// 828D5BF0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D5BF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D5BF8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828D5BFC: 3D40828D  lis r10, -0x7d73
	ctx.r[10].s64 = -2104688640;
	// 828D5C00: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828D5C04: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828D5C08: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5C0C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828D5C10: 3BAA15E0  addi r29, r10, 0x15e0
	ctx.r[29].s64 = ctx.r[10].s64 + 5600;
	// 828D5C14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D5C18: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D5C1C: 419A0008  beq cr6, 0x828d5c24
	if ctx.cr[6].eq {
	pc = 0x828D5C24; continue 'dispatch;
	}
	// 828D5C20: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5C24: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D5C28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D5C2C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5C30: 4BAF8991  bl 0x823ce5c0
	ctx.lr = 0x828D5C34;
	sub_823CE5C0(ctx, base);
	// 828D5C34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D5C38: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D5C3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D5C40: 4BAF84D1  bl 0x823ce110
	ctx.lr = 0x828D5C44;
	sub_823CE110(ctx, base);
	// 828D5C44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D5C48: 4B8E1ED1  bl 0x821b7b18
	ctx.lr = 0x828D5C4C;
	sub_821B7B18(ctx, base);
	// 828D5C4C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D5C50: 4B949609  bl 0x8221f258
	ctx.lr = 0x828D5C54;
	sub_8221F258(ctx, base);
	// 828D5C54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D5C58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D5C5C: 419A005C  beq cr6, 0x828d5cb8
	if ctx.cr[6].eq {
	pc = 0x828D5CB8; continue 'dispatch;
	}
	// 828D5C60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828D5C64: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828D5C68: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D5C6C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828D5C70: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D5C74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D5C78: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D5C7C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828D5C80: 4B91A5C1  bl 0x821f0240
	ctx.lr = 0x828D5C84;
	sub_821F0240(ctx, base);
	// 828D5C84: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D5C88: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828D5C8C: 4B9495CD  bl 0x8221f258
	ctx.lr = 0x828D5C90;
	sub_8221F258(ctx, base);
	// 828D5C90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D5C94: 419A0028  beq cr6, 0x828d5cbc
	if ctx.cr[6].eq {
	pc = 0x828D5CBC; continue 'dispatch;
	}
	// 828D5C98: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828D5C9C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828D5CA0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D5CA4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828D5CA8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D5CAC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D5CB0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D5CB4: 4800000C  b 0x828d5cc0
	pc = 0x828D5CC0; continue 'dispatch;
	// 828D5CB8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828D5CBC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D5CC0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5CC4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D5CC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D5CCC: 419A0008  beq cr6, 0x828d5cd4
	if ctx.cr[6].eq {
	pc = 0x828D5CD4; continue 'dispatch;
	}
	// 828D5CD0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5CD4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D5CD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D5CDC: 419A0078  beq cr6, 0x828d5d54
	if ctx.cr[6].eq {
	pc = 0x828D5D54; continue 'dispatch;
	}
	// 828D5CE0: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5CE4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828D5CE8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D5CEC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D5CF0: 4B953419  bl 0x82229108
	ctx.lr = 0x828D5CF4;
	sub_82229108(ctx, base);
	// 828D5CF4: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D5CF8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828D5CFC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D5D00: 3BCB77F8  addi r30, r11, 0x77f8
	ctx.r[30].s64 = ctx.r[11].s64 + 30712;
	// 828D5D04: 4B951B7D  bl 0x82227880
	ctx.lr = 0x828D5D08;
	sub_82227880(ctx, base);
	// 828D5D08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D5D0C: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828D5D10: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D5D14: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828D5D18: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D5D1C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828D5D20: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828D5D24: 4B8C4D5D  bl 0x8219aa80
	ctx.lr = 0x828D5D28;
	sub_8219AA80(ctx, base);
	// 828D5D28: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D5D2C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D5D30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D5D34: 4BAF86ED  bl 0x823ce420
	ctx.lr = 0x828D5D38;
	sub_823CE420(ctx, base);
	// 828D5D38: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D5D3C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828D5D40: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D5D44: 4814E985  bl 0x82a246c8
	ctx.lr = 0x828D5D48;
	sub_82A246C8(ctx, base);
	// 828D5D48: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D5D4C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828D5D50: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828D5D54: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828D5D58: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D5D5C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828D5D60: 419A0020  beq cr6, 0x828d5d80
	if ctx.cr[6].eq {
	pc = 0x828D5D80; continue 'dispatch;
	}
	// 828D5D64: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D5D68: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D5D6C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D5D70: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828D5D74: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D5D78: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D5D7C: 4082FFE8  bne 0x828d5d64
	if !ctx.cr[0].eq {
	pc = 0x828D5D64; continue 'dispatch;
	}
	// 828D5D80: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D5D84: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D5D88: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828D5D8C: 4BA1FBBD  bl 0x822f5948
	ctx.lr = 0x828D5D90;
	sub_822F5948(ctx, base);
	// 828D5D90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5D94: 4B8E1D85  bl 0x821b7b18
	ctx.lr = 0x828D5D98;
	sub_821B7B18(ctx, base);
	// 828D5D98: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D5D9C: 419A0040  beq cr6, 0x828d5ddc
	if ctx.cr[6].eq {
	pc = 0x828D5DDC; continue 'dispatch;
	}
	// 828D5DA0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D5DA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D5DA8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D5DAC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D5DB0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D5DB4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D5DB8: 4082FFE8  bne 0x828d5da0
	if !ctx.cr[0].eq {
	pc = 0x828D5DA0; continue 'dispatch;
	}
	// 828D5DBC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D5DC0: 409A001C  bne cr6, 0x828d5ddc
	if !ctx.cr[6].eq {
	pc = 0x828D5DDC; continue 'dispatch;
	}
	// 828D5DC4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D5DC8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D5DCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D5DD0: 4E800421  bctrl
	ctx.lr = 0x828D5DD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D5DD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D5DD8: 4B945F61  bl 0x8221bd38
	ctx.lr = 0x828D5DDC;
	sub_8221BD38(ctx, base);
	// 828D5DDC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D5DE0: 4B8E1D39  bl 0x821b7b18
	ctx.lr = 0x828D5DE4;
	sub_821B7B18(ctx, base);
	// 828D5DE4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828D5DE8: 483D3664  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D5DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D5DF0 size=512
    let mut pc: u32 = 0x828D5DF0;
    'dispatch: loop {
        match pc {
            0x828D5DF0 => {
    //   block [0x828D5DF0..0x828D5FF0)
	// 828D5DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D5DF4: 483D3609  bl 0x82ca93fc
	ctx.lr = 0x828D5DF8;
	sub_82CA93D0(ctx, base);
	// 828D5DF8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D5DFC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D5E00: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828D5E04: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828D5E08: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828D5E0C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828D5E10: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5E14: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828D5E18: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D5E1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D5E20: 419A0008  beq cr6, 0x828d5e28
	if ctx.cr[6].eq {
	pc = 0x828D5E28; continue 'dispatch;
	}
	// 828D5E24: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5E28: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D5E2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D5E30: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5E34: 4BAF878D  bl 0x823ce5c0
	ctx.lr = 0x828D5E38;
	sub_823CE5C0(ctx, base);
	// 828D5E38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D5E3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D5E40: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D5E44: 4BAF82CD  bl 0x823ce110
	ctx.lr = 0x828D5E48;
	sub_823CE110(ctx, base);
	// 828D5E48: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D5E4C: 4B8E1CCD  bl 0x821b7b18
	ctx.lr = 0x828D5E50;
	sub_821B7B18(ctx, base);
	// 828D5E50: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D5E54: 4B949405  bl 0x8221f258
	ctx.lr = 0x828D5E58;
	sub_8221F258(ctx, base);
	// 828D5E58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D5E5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D5E60: 419A005C  beq cr6, 0x828d5ebc
	if ctx.cr[6].eq {
	pc = 0x828D5EBC; continue 'dispatch;
	}
	// 828D5E64: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828D5E68: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828D5E6C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D5E70: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828D5E74: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D5E78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D5E7C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D5E80: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828D5E84: 4B91A3BD  bl 0x821f0240
	ctx.lr = 0x828D5E88;
	sub_821F0240(ctx, base);
	// 828D5E88: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D5E8C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828D5E90: 4B9493C9  bl 0x8221f258
	ctx.lr = 0x828D5E94;
	sub_8221F258(ctx, base);
	// 828D5E94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D5E98: 419A0028  beq cr6, 0x828d5ec0
	if ctx.cr[6].eq {
	pc = 0x828D5EC0; continue 'dispatch;
	}
	// 828D5E9C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828D5EA0: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828D5EA4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D5EA8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828D5EAC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D5EB0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D5EB4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D5EB8: 4800000C  b 0x828d5ec4
	pc = 0x828D5EC4; continue 'dispatch;
	// 828D5EBC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828D5EC0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D5EC4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5EC8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D5ECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D5ED0: 419A0008  beq cr6, 0x828d5ed8
	if ctx.cr[6].eq {
	pc = 0x828D5ED8; continue 'dispatch;
	}
	// 828D5ED4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5ED8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D5EDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D5EE0: 419A0078  beq cr6, 0x828d5f58
	if ctx.cr[6].eq {
	pc = 0x828D5F58; continue 'dispatch;
	}
	// 828D5EE4: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5EE8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828D5EEC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D5EF0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D5EF4: 4B953215  bl 0x82229108
	ctx.lr = 0x828D5EF8;
	sub_82229108(ctx, base);
	// 828D5EF8: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 828D5EFC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828D5F00: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D5F04: 3BCB7E00  addi r30, r11, 0x7e00
	ctx.r[30].s64 = ctx.r[11].s64 + 32256;
	// 828D5F08: 4B951979  bl 0x82227880
	ctx.lr = 0x828D5F0C;
	sub_82227880(ctx, base);
	// 828D5F0C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D5F10: 3D408291  lis r10, -0x7d6f
	ctx.r[10].s64 = -2104426496;
	// 828D5F14: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D5F18: 388A4F40  addi r4, r10, 0x4f40
	ctx.r[4].s64 = ctx.r[10].s64 + 20288;
	// 828D5F1C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D5F20: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828D5F24: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828D5F28: 4B8C4B59  bl 0x8219aa80
	ctx.lr = 0x828D5F2C;
	sub_8219AA80(ctx, base);
	// 828D5F2C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D5F30: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D5F34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D5F38: 4BAF84E9  bl 0x823ce420
	ctx.lr = 0x828D5F3C;
	sub_823CE420(ctx, base);
	// 828D5F3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D5F40: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828D5F44: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D5F48: 4814E781  bl 0x82a246c8
	ctx.lr = 0x828D5F4C;
	sub_82A246C8(ctx, base);
	// 828D5F4C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D5F50: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828D5F54: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828D5F58: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828D5F5C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D5F60: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828D5F64: 419A0020  beq cr6, 0x828d5f84
	if ctx.cr[6].eq {
	pc = 0x828D5F84; continue 'dispatch;
	}
	// 828D5F68: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D5F6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D5F70: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D5F74: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828D5F78: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D5F7C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D5F80: 4082FFE8  bne 0x828d5f68
	if !ctx.cr[0].eq {
	pc = 0x828D5F68; continue 'dispatch;
	}
	// 828D5F84: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D5F88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D5F8C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828D5F90: 4BA1F9B9  bl 0x822f5948
	ctx.lr = 0x828D5F94;
	sub_822F5948(ctx, base);
	// 828D5F94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5F98: 4B8E1B81  bl 0x821b7b18
	ctx.lr = 0x828D5F9C;
	sub_821B7B18(ctx, base);
	// 828D5F9C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D5FA0: 419A0040  beq cr6, 0x828d5fe0
	if ctx.cr[6].eq {
	pc = 0x828D5FE0; continue 'dispatch;
	}
	// 828D5FA4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D5FA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D5FAC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D5FB0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D5FB4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D5FB8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D5FBC: 4082FFE8  bne 0x828d5fa4
	if !ctx.cr[0].eq {
	pc = 0x828D5FA4; continue 'dispatch;
	}
	// 828D5FC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D5FC4: 409A001C  bne cr6, 0x828d5fe0
	if !ctx.cr[6].eq {
	pc = 0x828D5FE0; continue 'dispatch;
	}
	// 828D5FC8: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D5FCC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D5FD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D5FD4: 4E800421  bctrl
	ctx.lr = 0x828D5FD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D5FD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D5FDC: 4B945D5D  bl 0x8221bd38
	ctx.lr = 0x828D5FE0;
	sub_8221BD38(ctx, base);
	// 828D5FE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D5FE4: 4B8E1B35  bl 0x821b7b18
	ctx.lr = 0x828D5FE8;
	sub_821B7B18(ctx, base);
	// 828D5FE8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828D5FEC: 483D3460  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D5FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D5FF0 size=516
    let mut pc: u32 = 0x828D5FF0;
    'dispatch: loop {
        match pc {
            0x828D5FF0 => {
    //   block [0x828D5FF0..0x828D61F4)
	// 828D5FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D5FF4: 483D3409  bl 0x82ca93fc
	ctx.lr = 0x828D5FF8;
	sub_82CA93D0(ctx, base);
	// 828D5FF8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D5FFC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D6000: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828D6004: 3D40828D  lis r10, -0x7d73
	ctx.r[10].s64 = -2104688640;
	// 828D6008: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828D600C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828D6010: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6014: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828D6018: 3BAA3D10  addi r29, r10, 0x3d10
	ctx.r[29].s64 = ctx.r[10].s64 + 15632;
	// 828D601C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D6020: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D6024: 419A0008  beq cr6, 0x828d602c
	if ctx.cr[6].eq {
	pc = 0x828D602C; continue 'dispatch;
	}
	// 828D6028: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D602C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6030: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D6034: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6038: 4BAF8589  bl 0x823ce5c0
	ctx.lr = 0x828D603C;
	sub_823CE5C0(ctx, base);
	// 828D603C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D6040: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D6044: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6048: 4BAF80C9  bl 0x823ce110
	ctx.lr = 0x828D604C;
	sub_823CE110(ctx, base);
	// 828D604C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D6050: 4B8E1AC9  bl 0x821b7b18
	ctx.lr = 0x828D6054;
	sub_821B7B18(ctx, base);
	// 828D6054: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D6058: 4B949201  bl 0x8221f258
	ctx.lr = 0x828D605C;
	sub_8221F258(ctx, base);
	// 828D605C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6060: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D6064: 419A005C  beq cr6, 0x828d60c0
	if ctx.cr[6].eq {
	pc = 0x828D60C0; continue 'dispatch;
	}
	// 828D6068: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828D606C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828D6070: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D6074: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828D6078: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D607C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D6080: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D6084: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828D6088: 4B91A1B9  bl 0x821f0240
	ctx.lr = 0x828D608C;
	sub_821F0240(ctx, base);
	// 828D608C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D6090: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828D6094: 4B9491C5  bl 0x8221f258
	ctx.lr = 0x828D6098;
	sub_8221F258(ctx, base);
	// 828D6098: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D609C: 419A0028  beq cr6, 0x828d60c4
	if ctx.cr[6].eq {
	pc = 0x828D60C4; continue 'dispatch;
	}
	// 828D60A0: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828D60A4: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828D60A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D60AC: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828D60B0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D60B4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D60B8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D60BC: 4800000C  b 0x828d60c8
	pc = 0x828D60C8; continue 'dispatch;
	// 828D60C0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828D60C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D60C8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D60CC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D60D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D60D4: 419A0008  beq cr6, 0x828d60dc
	if ctx.cr[6].eq {
	pc = 0x828D60DC; continue 'dispatch;
	}
	// 828D60D8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D60DC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D60E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D60E4: 419A0078  beq cr6, 0x828d615c
	if ctx.cr[6].eq {
	pc = 0x828D615C; continue 'dispatch;
	}
	// 828D60E8: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D60EC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828D60F0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D60F4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D60F8: 4B953011  bl 0x82229108
	ctx.lr = 0x828D60FC;
	sub_82229108(ctx, base);
	// 828D60FC: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D6100: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828D6104: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6108: 3BCB74B0  addi r30, r11, 0x74b0
	ctx.r[30].s64 = ctx.r[11].s64 + 29872;
	// 828D610C: 4B951775  bl 0x82227880
	ctx.lr = 0x828D6110;
	sub_82227880(ctx, base);
	// 828D6110: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D6114: 3D408248  lis r10, -0x7db8
	ctx.r[10].s64 = -2109210624;
	// 828D6118: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D611C: 388A1200  addi r4, r10, 0x1200
	ctx.r[4].s64 = ctx.r[10].s64 + 4608;
	// 828D6120: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6124: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828D6128: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828D612C: 4B8C4955  bl 0x8219aa80
	ctx.lr = 0x828D6130;
	sub_8219AA80(ctx, base);
	// 828D6130: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6134: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D6138: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D613C: 4BAF82E5  bl 0x823ce420
	ctx.lr = 0x828D6140;
	sub_823CE420(ctx, base);
	// 828D6140: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6144: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828D6148: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D614C: 4814E57D  bl 0x82a246c8
	ctx.lr = 0x828D6150;
	sub_82A246C8(ctx, base);
	// 828D6150: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D6154: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828D6158: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828D615C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828D6160: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D6164: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828D6168: 419A0020  beq cr6, 0x828d6188
	if ctx.cr[6].eq {
	pc = 0x828D6188; continue 'dispatch;
	}
	// 828D616C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D6170: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6174: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D6178: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828D617C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D6180: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6184: 4082FFE8  bne 0x828d616c
	if !ctx.cr[0].eq {
	pc = 0x828D616C; continue 'dispatch;
	}
	// 828D6188: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D618C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D6190: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828D6194: 4BA1F7B5  bl 0x822f5948
	ctx.lr = 0x828D6198;
	sub_822F5948(ctx, base);
	// 828D6198: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D619C: 4B8E197D  bl 0x821b7b18
	ctx.lr = 0x828D61A0;
	sub_821B7B18(ctx, base);
	// 828D61A0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D61A4: 419A0040  beq cr6, 0x828d61e4
	if ctx.cr[6].eq {
	pc = 0x828D61E4; continue 'dispatch;
	}
	// 828D61A8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D61AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D61B0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D61B4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D61B8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D61BC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D61C0: 4082FFE8  bne 0x828d61a8
	if !ctx.cr[0].eq {
	pc = 0x828D61A8; continue 'dispatch;
	}
	// 828D61C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D61C8: 409A001C  bne cr6, 0x828d61e4
	if !ctx.cr[6].eq {
	pc = 0x828D61E4; continue 'dispatch;
	}
	// 828D61CC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D61D0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D61D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D61D8: 4E800421  bctrl
	ctx.lr = 0x828D61DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D61DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D61E0: 4B945B59  bl 0x8221bd38
	ctx.lr = 0x828D61E4;
	sub_8221BD38(ctx, base);
	// 828D61E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D61E8: 4B8E1931  bl 0x821b7b18
	ctx.lr = 0x828D61EC;
	sub_821B7B18(ctx, base);
	// 828D61EC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828D61F0: 483D325C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D61F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D61F8 size=512
    let mut pc: u32 = 0x828D61F8;
    'dispatch: loop {
        match pc {
            0x828D61F8 => {
    //   block [0x828D61F8..0x828D63F8)
	// 828D61F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D61FC: 483D3201  bl 0x82ca93fc
	ctx.lr = 0x828D6200;
	sub_82CA93D0(ctx, base);
	// 828D6200: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D6204: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D6208: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828D620C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828D6210: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828D6214: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828D6218: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D621C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828D6220: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D6224: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D6228: 419A0008  beq cr6, 0x828d6230
	if ctx.cr[6].eq {
	pc = 0x828D6230; continue 'dispatch;
	}
	// 828D622C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6230: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6234: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D6238: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D623C: 4BAF8385  bl 0x823ce5c0
	ctx.lr = 0x828D6240;
	sub_823CE5C0(ctx, base);
	// 828D6240: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D6244: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D6248: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D624C: 4BAF7EC5  bl 0x823ce110
	ctx.lr = 0x828D6250;
	sub_823CE110(ctx, base);
	// 828D6250: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D6254: 4B8E18C5  bl 0x821b7b18
	ctx.lr = 0x828D6258;
	sub_821B7B18(ctx, base);
	// 828D6258: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D625C: 4B948FFD  bl 0x8221f258
	ctx.lr = 0x828D6260;
	sub_8221F258(ctx, base);
	// 828D6260: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6264: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D6268: 419A005C  beq cr6, 0x828d62c4
	if ctx.cr[6].eq {
	pc = 0x828D62C4; continue 'dispatch;
	}
	// 828D626C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828D6270: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828D6274: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D6278: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828D627C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D6280: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D6284: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D6288: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828D628C: 4B919FB5  bl 0x821f0240
	ctx.lr = 0x828D6290;
	sub_821F0240(ctx, base);
	// 828D6290: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D6294: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828D6298: 4B948FC1  bl 0x8221f258
	ctx.lr = 0x828D629C;
	sub_8221F258(ctx, base);
	// 828D629C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D62A0: 419A0028  beq cr6, 0x828d62c8
	if ctx.cr[6].eq {
	pc = 0x828D62C8; continue 'dispatch;
	}
	// 828D62A4: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828D62A8: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828D62AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D62B0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828D62B4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D62B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D62BC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D62C0: 4800000C  b 0x828d62cc
	pc = 0x828D62CC; continue 'dispatch;
	// 828D62C4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828D62C8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D62CC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D62D0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D62D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D62D8: 419A0008  beq cr6, 0x828d62e0
	if ctx.cr[6].eq {
	pc = 0x828D62E0; continue 'dispatch;
	}
	// 828D62DC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D62E0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D62E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D62E8: 419A0078  beq cr6, 0x828d6360
	if ctx.cr[6].eq {
	pc = 0x828D6360; continue 'dispatch;
	}
	// 828D62EC: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D62F0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828D62F4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D62F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D62FC: 4B952E0D  bl 0x82229108
	ctx.lr = 0x828D6300;
	sub_82229108(ctx, base);
	// 828D6300: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D6304: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828D6308: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D630C: 3BCB7680  addi r30, r11, 0x7680
	ctx.r[30].s64 = ctx.r[11].s64 + 30336;
	// 828D6310: 4B951571  bl 0x82227880
	ctx.lr = 0x828D6314;
	sub_82227880(ctx, base);
	// 828D6314: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D6318: 3D408278  lis r10, -0x7d88
	ctx.r[10].s64 = -2106064896;
	// 828D631C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D6320: 388A3318  addi r4, r10, 0x3318
	ctx.r[4].s64 = ctx.r[10].s64 + 13080;
	// 828D6324: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6328: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828D632C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828D6330: 4B8C4751  bl 0x8219aa80
	ctx.lr = 0x828D6334;
	sub_8219AA80(ctx, base);
	// 828D6334: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6338: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D633C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D6340: 4BAF80E1  bl 0x823ce420
	ctx.lr = 0x828D6344;
	sub_823CE420(ctx, base);
	// 828D6344: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6348: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828D634C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6350: 4814E379  bl 0x82a246c8
	ctx.lr = 0x828D6354;
	sub_82A246C8(ctx, base);
	// 828D6354: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D6358: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828D635C: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828D6360: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828D6364: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D6368: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828D636C: 419A0020  beq cr6, 0x828d638c
	if ctx.cr[6].eq {
	pc = 0x828D638C; continue 'dispatch;
	}
	// 828D6370: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D6374: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6378: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D637C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828D6380: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D6384: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6388: 4082FFE8  bne 0x828d6370
	if !ctx.cr[0].eq {
	pc = 0x828D6370; continue 'dispatch;
	}
	// 828D638C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6390: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D6394: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828D6398: 4BA1F5B1  bl 0x822f5948
	ctx.lr = 0x828D639C;
	sub_822F5948(ctx, base);
	// 828D639C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D63A0: 4B8E1779  bl 0x821b7b18
	ctx.lr = 0x828D63A4;
	sub_821B7B18(ctx, base);
	// 828D63A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D63A8: 419A0040  beq cr6, 0x828d63e8
	if ctx.cr[6].eq {
	pc = 0x828D63E8; continue 'dispatch;
	}
	// 828D63AC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D63B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D63B4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D63B8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D63BC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D63C0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D63C4: 4082FFE8  bne 0x828d63ac
	if !ctx.cr[0].eq {
	pc = 0x828D63AC; continue 'dispatch;
	}
	// 828D63C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D63CC: 409A001C  bne cr6, 0x828d63e8
	if !ctx.cr[6].eq {
	pc = 0x828D63E8; continue 'dispatch;
	}
	// 828D63D0: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D63D4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D63D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D63DC: 4E800421  bctrl
	ctx.lr = 0x828D63E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D63E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D63E4: 4B945955  bl 0x8221bd38
	ctx.lr = 0x828D63E8;
	sub_8221BD38(ctx, base);
	// 828D63E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D63EC: 4B8E172D  bl 0x821b7b18
	ctx.lr = 0x828D63F0;
	sub_821B7B18(ctx, base);
	// 828D63F0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828D63F4: 483D3058  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D63F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D63F8 size=516
    let mut pc: u32 = 0x828D63F8;
    'dispatch: loop {
        match pc {
            0x828D63F8 => {
    //   block [0x828D63F8..0x828D65FC)
	// 828D63F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D63FC: 483D3001  bl 0x82ca93fc
	ctx.lr = 0x828D6400;
	sub_82CA93D0(ctx, base);
	// 828D6400: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D6404: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D6408: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828D640C: 3D40828D  lis r10, -0x7d73
	ctx.r[10].s64 = -2104688640;
	// 828D6410: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828D6414: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828D6418: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D641C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828D6420: 3BAA4110  addi r29, r10, 0x4110
	ctx.r[29].s64 = ctx.r[10].s64 + 16656;
	// 828D6424: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D6428: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D642C: 419A0008  beq cr6, 0x828d6434
	if ctx.cr[6].eq {
	pc = 0x828D6434; continue 'dispatch;
	}
	// 828D6430: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6434: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6438: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D643C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6440: 4BAF8181  bl 0x823ce5c0
	ctx.lr = 0x828D6444;
	sub_823CE5C0(ctx, base);
	// 828D6444: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D6448: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D644C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6450: 4BAF7CC1  bl 0x823ce110
	ctx.lr = 0x828D6454;
	sub_823CE110(ctx, base);
	// 828D6454: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D6458: 4B8E16C1  bl 0x821b7b18
	ctx.lr = 0x828D645C;
	sub_821B7B18(ctx, base);
	// 828D645C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D6460: 4B948DF9  bl 0x8221f258
	ctx.lr = 0x828D6464;
	sub_8221F258(ctx, base);
	// 828D6464: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6468: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D646C: 419A005C  beq cr6, 0x828d64c8
	if ctx.cr[6].eq {
	pc = 0x828D64C8; continue 'dispatch;
	}
	// 828D6470: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828D6474: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828D6478: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D647C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828D6480: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D6484: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D6488: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D648C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828D6490: 4B919DB1  bl 0x821f0240
	ctx.lr = 0x828D6494;
	sub_821F0240(ctx, base);
	// 828D6494: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D6498: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828D649C: 4B948DBD  bl 0x8221f258
	ctx.lr = 0x828D64A0;
	sub_8221F258(ctx, base);
	// 828D64A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D64A4: 419A0028  beq cr6, 0x828d64cc
	if ctx.cr[6].eq {
	pc = 0x828D64CC; continue 'dispatch;
	}
	// 828D64A8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828D64AC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828D64B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D64B4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828D64B8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D64BC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D64C0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D64C4: 4800000C  b 0x828d64d0
	pc = 0x828D64D0; continue 'dispatch;
	// 828D64C8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828D64CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D64D0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D64D4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D64D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D64DC: 419A0008  beq cr6, 0x828d64e4
	if ctx.cr[6].eq {
	pc = 0x828D64E4; continue 'dispatch;
	}
	// 828D64E0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D64E4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D64E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D64EC: 419A0078  beq cr6, 0x828d6564
	if ctx.cr[6].eq {
	pc = 0x828D6564; continue 'dispatch;
	}
	// 828D64F0: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D64F4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828D64F8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D64FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6500: 4B952C09  bl 0x82229108
	ctx.lr = 0x828D6504;
	sub_82229108(ctx, base);
	// 828D6504: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D6508: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828D650C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6510: 3BCB77F8  addi r30, r11, 0x77f8
	ctx.r[30].s64 = ctx.r[11].s64 + 30712;
	// 828D6514: 4B95136D  bl 0x82227880
	ctx.lr = 0x828D6518;
	sub_82227880(ctx, base);
	// 828D6518: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D651C: 3D408295  lis r10, -0x7d6b
	ctx.r[10].s64 = -2104164352;
	// 828D6520: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D6524: 388AC430  addi r4, r10, -0x3bd0
	ctx.r[4].s64 = ctx.r[10].s64 + -15312;
	// 828D6528: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D652C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828D6530: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828D6534: 4B8C454D  bl 0x8219aa80
	ctx.lr = 0x828D6538;
	sub_8219AA80(ctx, base);
	// 828D6538: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D653C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D6540: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D6544: 4BAF7EDD  bl 0x823ce420
	ctx.lr = 0x828D6548;
	sub_823CE420(ctx, base);
	// 828D6548: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D654C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828D6550: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6554: 4814E175  bl 0x82a246c8
	ctx.lr = 0x828D6558;
	sub_82A246C8(ctx, base);
	// 828D6558: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D655C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828D6560: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828D6564: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828D6568: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D656C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828D6570: 419A0020  beq cr6, 0x828d6590
	if ctx.cr[6].eq {
	pc = 0x828D6590; continue 'dispatch;
	}
	// 828D6574: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D6578: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D657C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D6580: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828D6584: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D6588: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D658C: 4082FFE8  bne 0x828d6574
	if !ctx.cr[0].eq {
	pc = 0x828D6574; continue 'dispatch;
	}
	// 828D6590: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6594: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D6598: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828D659C: 4BA1F3AD  bl 0x822f5948
	ctx.lr = 0x828D65A0;
	sub_822F5948(ctx, base);
	// 828D65A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D65A4: 4B8E1575  bl 0x821b7b18
	ctx.lr = 0x828D65A8;
	sub_821B7B18(ctx, base);
	// 828D65A8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D65AC: 419A0040  beq cr6, 0x828d65ec
	if ctx.cr[6].eq {
	pc = 0x828D65EC; continue 'dispatch;
	}
	// 828D65B0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D65B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D65B8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D65BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D65C0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D65C4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D65C8: 4082FFE8  bne 0x828d65b0
	if !ctx.cr[0].eq {
	pc = 0x828D65B0; continue 'dispatch;
	}
	// 828D65CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D65D0: 409A001C  bne cr6, 0x828d65ec
	if !ctx.cr[6].eq {
	pc = 0x828D65EC; continue 'dispatch;
	}
	// 828D65D4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D65D8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D65DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D65E0: 4E800421  bctrl
	ctx.lr = 0x828D65E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D65E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D65E8: 4B945751  bl 0x8221bd38
	ctx.lr = 0x828D65EC;
	sub_8221BD38(ctx, base);
	// 828D65EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D65F0: 4B8E1529  bl 0x821b7b18
	ctx.lr = 0x828D65F4;
	sub_821B7B18(ctx, base);
	// 828D65F4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828D65F8: 483D2E54  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D6600 size=516
    let mut pc: u32 = 0x828D6600;
    'dispatch: loop {
        match pc {
            0x828D6600 => {
    //   block [0x828D6600..0x828D6804)
	// 828D6600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D6604: 483D2DF9  bl 0x82ca93fc
	ctx.lr = 0x828D6608;
	sub_82CA93D0(ctx, base);
	// 828D6608: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D660C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D6610: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828D6614: 3D40828D  lis r10, -0x7d73
	ctx.r[10].s64 = -2104688640;
	// 828D6618: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828D661C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828D6620: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6624: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828D6628: 3BAA4118  addi r29, r10, 0x4118
	ctx.r[29].s64 = ctx.r[10].s64 + 16664;
	// 828D662C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D6630: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D6634: 419A0008  beq cr6, 0x828d663c
	if ctx.cr[6].eq {
	pc = 0x828D663C; continue 'dispatch;
	}
	// 828D6638: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D663C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6640: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D6644: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6648: 4BAF7F79  bl 0x823ce5c0
	ctx.lr = 0x828D664C;
	sub_823CE5C0(ctx, base);
	// 828D664C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D6650: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D6654: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6658: 4BAF7AB9  bl 0x823ce110
	ctx.lr = 0x828D665C;
	sub_823CE110(ctx, base);
	// 828D665C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D6660: 4B8E14B9  bl 0x821b7b18
	ctx.lr = 0x828D6664;
	sub_821B7B18(ctx, base);
	// 828D6664: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D6668: 4B948BF1  bl 0x8221f258
	ctx.lr = 0x828D666C;
	sub_8221F258(ctx, base);
	// 828D666C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6670: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D6674: 419A005C  beq cr6, 0x828d66d0
	if ctx.cr[6].eq {
	pc = 0x828D66D0; continue 'dispatch;
	}
	// 828D6678: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828D667C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828D6680: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D6684: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828D6688: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D668C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D6690: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D6694: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828D6698: 4B919BA9  bl 0x821f0240
	ctx.lr = 0x828D669C;
	sub_821F0240(ctx, base);
	// 828D669C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D66A0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828D66A4: 4B948BB5  bl 0x8221f258
	ctx.lr = 0x828D66A8;
	sub_8221F258(ctx, base);
	// 828D66A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D66AC: 419A0028  beq cr6, 0x828d66d4
	if ctx.cr[6].eq {
	pc = 0x828D66D4; continue 'dispatch;
	}
	// 828D66B0: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828D66B4: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828D66B8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D66BC: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828D66C0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D66C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D66C8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D66CC: 4800000C  b 0x828d66d8
	pc = 0x828D66D8; continue 'dispatch;
	// 828D66D0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828D66D4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D66D8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D66DC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D66E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D66E4: 419A0008  beq cr6, 0x828d66ec
	if ctx.cr[6].eq {
	pc = 0x828D66EC; continue 'dispatch;
	}
	// 828D66E8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D66EC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D66F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D66F4: 419A0078  beq cr6, 0x828d676c
	if ctx.cr[6].eq {
	pc = 0x828D676C; continue 'dispatch;
	}
	// 828D66F8: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D66FC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828D6700: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6704: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6708: 4B952A01  bl 0x82229108
	ctx.lr = 0x828D670C;
	sub_82229108(ctx, base);
	// 828D670C: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D6710: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828D6714: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6718: 3BCB7970  addi r30, r11, 0x7970
	ctx.r[30].s64 = ctx.r[11].s64 + 31088;
	// 828D671C: 4B951165  bl 0x82227880
	ctx.lr = 0x828D6720;
	sub_82227880(ctx, base);
	// 828D6720: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D6724: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828D6728: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D672C: 388A82C0  addi r4, r10, -0x7d40
	ctx.r[4].s64 = ctx.r[10].s64 + -32064;
	// 828D6730: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6734: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828D6738: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828D673C: 4B8C4345  bl 0x8219aa80
	ctx.lr = 0x828D6740;
	sub_8219AA80(ctx, base);
	// 828D6740: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6744: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D6748: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D674C: 4BAF7CD5  bl 0x823ce420
	ctx.lr = 0x828D6750;
	sub_823CE420(ctx, base);
	// 828D6750: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6754: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828D6758: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D675C: 4814DF6D  bl 0x82a246c8
	ctx.lr = 0x828D6760;
	sub_82A246C8(ctx, base);
	// 828D6760: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D6764: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828D6768: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828D676C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828D6770: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D6774: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828D6778: 419A0020  beq cr6, 0x828d6798
	if ctx.cr[6].eq {
	pc = 0x828D6798; continue 'dispatch;
	}
	// 828D677C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D6780: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6784: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D6788: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828D678C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D6790: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6794: 4082FFE8  bne 0x828d677c
	if !ctx.cr[0].eq {
	pc = 0x828D677C; continue 'dispatch;
	}
	// 828D6798: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D679C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D67A0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828D67A4: 4BA1F1A5  bl 0x822f5948
	ctx.lr = 0x828D67A8;
	sub_822F5948(ctx, base);
	// 828D67A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D67AC: 4B8E136D  bl 0x821b7b18
	ctx.lr = 0x828D67B0;
	sub_821B7B18(ctx, base);
	// 828D67B0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D67B4: 419A0040  beq cr6, 0x828d67f4
	if ctx.cr[6].eq {
	pc = 0x828D67F4; continue 'dispatch;
	}
	// 828D67B8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D67BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D67C0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D67C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D67C8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D67CC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D67D0: 4082FFE8  bne 0x828d67b8
	if !ctx.cr[0].eq {
	pc = 0x828D67B8; continue 'dispatch;
	}
	// 828D67D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D67D8: 409A001C  bne cr6, 0x828d67f4
	if !ctx.cr[6].eq {
	pc = 0x828D67F4; continue 'dispatch;
	}
	// 828D67DC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D67E0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D67E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D67E8: 4E800421  bctrl
	ctx.lr = 0x828D67EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D67EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D67F0: 4B945549  bl 0x8221bd38
	ctx.lr = 0x828D67F4;
	sub_8221BD38(ctx, base);
	// 828D67F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D67F8: 4B8E1321  bl 0x821b7b18
	ctx.lr = 0x828D67FC;
	sub_821B7B18(ctx, base);
	// 828D67FC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828D6800: 483D2C4C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D6808 size=516
    let mut pc: u32 = 0x828D6808;
    'dispatch: loop {
        match pc {
            0x828D6808 => {
    //   block [0x828D6808..0x828D6A0C)
	// 828D6808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D680C: 483D2BF1  bl 0x82ca93fc
	ctx.lr = 0x828D6810;
	sub_82CA93D0(ctx, base);
	// 828D6810: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D6814: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D6818: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828D681C: 3D40828D  lis r10, -0x7d73
	ctx.r[10].s64 = -2104688640;
	// 828D6820: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828D6824: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828D6828: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D682C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828D6830: 3BAAD2A0  addi r29, r10, -0x2d60
	ctx.r[29].s64 = ctx.r[10].s64 + -11616;
	// 828D6834: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D6838: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D683C: 419A0008  beq cr6, 0x828d6844
	if ctx.cr[6].eq {
	pc = 0x828D6844; continue 'dispatch;
	}
	// 828D6840: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6844: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6848: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D684C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6850: 4BAF7D71  bl 0x823ce5c0
	ctx.lr = 0x828D6854;
	sub_823CE5C0(ctx, base);
	// 828D6854: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D6858: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D685C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6860: 4BAF78B1  bl 0x823ce110
	ctx.lr = 0x828D6864;
	sub_823CE110(ctx, base);
	// 828D6864: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D6868: 4B8E12B1  bl 0x821b7b18
	ctx.lr = 0x828D686C;
	sub_821B7B18(ctx, base);
	// 828D686C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D6870: 4B9489E9  bl 0x8221f258
	ctx.lr = 0x828D6874;
	sub_8221F258(ctx, base);
	// 828D6874: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6878: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D687C: 419A005C  beq cr6, 0x828d68d8
	if ctx.cr[6].eq {
	pc = 0x828D68D8; continue 'dispatch;
	}
	// 828D6880: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828D6884: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828D6888: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D688C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828D6890: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D6894: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D6898: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D689C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828D68A0: 4B9199A1  bl 0x821f0240
	ctx.lr = 0x828D68A4;
	sub_821F0240(ctx, base);
	// 828D68A4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D68A8: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828D68AC: 4B9489AD  bl 0x8221f258
	ctx.lr = 0x828D68B0;
	sub_8221F258(ctx, base);
	// 828D68B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D68B4: 419A0028  beq cr6, 0x828d68dc
	if ctx.cr[6].eq {
	pc = 0x828D68DC; continue 'dispatch;
	}
	// 828D68B8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828D68BC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828D68C0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D68C4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828D68C8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D68CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D68D0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D68D4: 4800000C  b 0x828d68e0
	pc = 0x828D68E0; continue 'dispatch;
	// 828D68D8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828D68DC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D68E0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D68E4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D68E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D68EC: 419A0008  beq cr6, 0x828d68f4
	if ctx.cr[6].eq {
	pc = 0x828D68F4; continue 'dispatch;
	}
	// 828D68F0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D68F4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D68F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D68FC: 419A0078  beq cr6, 0x828d6974
	if ctx.cr[6].eq {
	pc = 0x828D6974; continue 'dispatch;
	}
	// 828D6900: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6904: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828D6908: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D690C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6910: 4B9527F9  bl 0x82229108
	ctx.lr = 0x828D6914;
	sub_82229108(ctx, base);
	// 828D6914: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D6918: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828D691C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6920: 3BCB7B10  addi r30, r11, 0x7b10
	ctx.r[30].s64 = ctx.r[11].s64 + 31504;
	// 828D6924: 4B950F5D  bl 0x82227880
	ctx.lr = 0x828D6928;
	sub_82227880(ctx, base);
	// 828D6928: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D692C: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828D6930: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D6934: 388A8370  addi r4, r10, -0x7c90
	ctx.r[4].s64 = ctx.r[10].s64 + -31888;
	// 828D6938: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D693C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828D6940: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828D6944: 4B8C413D  bl 0x8219aa80
	ctx.lr = 0x828D6948;
	sub_8219AA80(ctx, base);
	// 828D6948: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D694C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D6950: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D6954: 4BAF7ACD  bl 0x823ce420
	ctx.lr = 0x828D6958;
	sub_823CE420(ctx, base);
	// 828D6958: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D695C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828D6960: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6964: 4814DD65  bl 0x82a246c8
	ctx.lr = 0x828D6968;
	sub_82A246C8(ctx, base);
	// 828D6968: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D696C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828D6970: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828D6974: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828D6978: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D697C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828D6980: 419A0020  beq cr6, 0x828d69a0
	if ctx.cr[6].eq {
	pc = 0x828D69A0; continue 'dispatch;
	}
	// 828D6984: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D6988: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D698C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D6990: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828D6994: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D6998: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D699C: 4082FFE8  bne 0x828d6984
	if !ctx.cr[0].eq {
	pc = 0x828D6984; continue 'dispatch;
	}
	// 828D69A0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D69A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D69A8: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828D69AC: 4BA1EF9D  bl 0x822f5948
	ctx.lr = 0x828D69B0;
	sub_822F5948(ctx, base);
	// 828D69B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D69B4: 4B8E1165  bl 0x821b7b18
	ctx.lr = 0x828D69B8;
	sub_821B7B18(ctx, base);
	// 828D69B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D69BC: 419A0040  beq cr6, 0x828d69fc
	if ctx.cr[6].eq {
	pc = 0x828D69FC; continue 'dispatch;
	}
	// 828D69C0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D69C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D69C8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D69CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D69D0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D69D4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D69D8: 4082FFE8  bne 0x828d69c0
	if !ctx.cr[0].eq {
	pc = 0x828D69C0; continue 'dispatch;
	}
	// 828D69DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D69E0: 409A001C  bne cr6, 0x828d69fc
	if !ctx.cr[6].eq {
	pc = 0x828D69FC; continue 'dispatch;
	}
	// 828D69E4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D69E8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D69EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D69F0: 4E800421  bctrl
	ctx.lr = 0x828D69F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D69F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D69F8: 4B945341  bl 0x8221bd38
	ctx.lr = 0x828D69FC;
	sub_8221BD38(ctx, base);
	// 828D69FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D6A00: 4B8E1119  bl 0x821b7b18
	ctx.lr = 0x828D6A04;
	sub_821B7B18(ctx, base);
	// 828D6A04: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828D6A08: 483D2A44  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D6A10 size=516
    let mut pc: u32 = 0x828D6A10;
    'dispatch: loop {
        match pc {
            0x828D6A10 => {
    //   block [0x828D6A10..0x828D6C14)
	// 828D6A10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D6A14: 483D29E9  bl 0x82ca93fc
	ctx.lr = 0x828D6A18;
	sub_82CA93D0(ctx, base);
	// 828D6A18: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D6A1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D6A20: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828D6A24: 3D40828D  lis r10, -0x7d73
	ctx.r[10].s64 = -2104688640;
	// 828D6A28: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828D6A2C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828D6A30: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6A34: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828D6A38: 3BAA4A20  addi r29, r10, 0x4a20
	ctx.r[29].s64 = ctx.r[10].s64 + 18976;
	// 828D6A3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D6A40: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D6A44: 419A0008  beq cr6, 0x828d6a4c
	if ctx.cr[6].eq {
	pc = 0x828D6A4C; continue 'dispatch;
	}
	// 828D6A48: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6A4C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6A50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D6A54: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6A58: 4BAF7B69  bl 0x823ce5c0
	ctx.lr = 0x828D6A5C;
	sub_823CE5C0(ctx, base);
	// 828D6A5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D6A60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D6A64: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6A68: 4BAF76A9  bl 0x823ce110
	ctx.lr = 0x828D6A6C;
	sub_823CE110(ctx, base);
	// 828D6A6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D6A70: 4B8E10A9  bl 0x821b7b18
	ctx.lr = 0x828D6A74;
	sub_821B7B18(ctx, base);
	// 828D6A74: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D6A78: 4B9487E1  bl 0x8221f258
	ctx.lr = 0x828D6A7C;
	sub_8221F258(ctx, base);
	// 828D6A7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6A80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D6A84: 419A005C  beq cr6, 0x828d6ae0
	if ctx.cr[6].eq {
	pc = 0x828D6AE0; continue 'dispatch;
	}
	// 828D6A88: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828D6A8C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828D6A90: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D6A94: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828D6A98: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D6A9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D6AA0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D6AA4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828D6AA8: 4B919799  bl 0x821f0240
	ctx.lr = 0x828D6AAC;
	sub_821F0240(ctx, base);
	// 828D6AAC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D6AB0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828D6AB4: 4B9487A5  bl 0x8221f258
	ctx.lr = 0x828D6AB8;
	sub_8221F258(ctx, base);
	// 828D6AB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D6ABC: 419A0028  beq cr6, 0x828d6ae4
	if ctx.cr[6].eq {
	pc = 0x828D6AE4; continue 'dispatch;
	}
	// 828D6AC0: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828D6AC4: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828D6AC8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D6ACC: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828D6AD0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D6AD4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D6AD8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D6ADC: 4800000C  b 0x828d6ae8
	pc = 0x828D6AE8; continue 'dispatch;
	// 828D6AE0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828D6AE4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D6AE8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6AEC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D6AF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D6AF4: 419A0008  beq cr6, 0x828d6afc
	if ctx.cr[6].eq {
	pc = 0x828D6AFC; continue 'dispatch;
	}
	// 828D6AF8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6AFC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D6B00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D6B04: 419A0078  beq cr6, 0x828d6b7c
	if ctx.cr[6].eq {
	pc = 0x828D6B7C; continue 'dispatch;
	}
	// 828D6B08: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6B0C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828D6B10: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6B14: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6B18: 4B9525F1  bl 0x82229108
	ctx.lr = 0x828D6B1C;
	sub_82229108(ctx, base);
	// 828D6B1C: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D6B20: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828D6B24: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6B28: 3BCB7C90  addi r30, r11, 0x7c90
	ctx.r[30].s64 = ctx.r[11].s64 + 31888;
	// 828D6B2C: 4B950D55  bl 0x82227880
	ctx.lr = 0x828D6B30;
	sub_82227880(ctx, base);
	// 828D6B30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D6B34: 3D408289  lis r10, -0x7d77
	ctx.r[10].s64 = -2104950784;
	// 828D6B38: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D6B3C: 388A39E8  addi r4, r10, 0x39e8
	ctx.r[4].s64 = ctx.r[10].s64 + 14824;
	// 828D6B40: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6B44: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828D6B48: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828D6B4C: 4B8C3F35  bl 0x8219aa80
	ctx.lr = 0x828D6B50;
	sub_8219AA80(ctx, base);
	// 828D6B50: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6B54: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D6B58: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D6B5C: 4BAF78C5  bl 0x823ce420
	ctx.lr = 0x828D6B60;
	sub_823CE420(ctx, base);
	// 828D6B60: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6B64: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828D6B68: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6B6C: 4814DB5D  bl 0x82a246c8
	ctx.lr = 0x828D6B70;
	sub_82A246C8(ctx, base);
	// 828D6B70: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D6B74: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828D6B78: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828D6B7C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828D6B80: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D6B84: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828D6B88: 419A0020  beq cr6, 0x828d6ba8
	if ctx.cr[6].eq {
	pc = 0x828D6BA8; continue 'dispatch;
	}
	// 828D6B8C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D6B90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6B94: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D6B98: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828D6B9C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D6BA0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6BA4: 4082FFE8  bne 0x828d6b8c
	if !ctx.cr[0].eq {
	pc = 0x828D6B8C; continue 'dispatch;
	}
	// 828D6BA8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6BAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D6BB0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828D6BB4: 4BA1ED95  bl 0x822f5948
	ctx.lr = 0x828D6BB8;
	sub_822F5948(ctx, base);
	// 828D6BB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6BBC: 4B8E0F5D  bl 0x821b7b18
	ctx.lr = 0x828D6BC0;
	sub_821B7B18(ctx, base);
	// 828D6BC0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D6BC4: 419A0040  beq cr6, 0x828d6c04
	if ctx.cr[6].eq {
	pc = 0x828D6C04; continue 'dispatch;
	}
	// 828D6BC8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D6BCC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6BD0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D6BD4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D6BD8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D6BDC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6BE0: 4082FFE8  bne 0x828d6bc8
	if !ctx.cr[0].eq {
	pc = 0x828D6BC8; continue 'dispatch;
	}
	// 828D6BE4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D6BE8: 409A001C  bne cr6, 0x828d6c04
	if !ctx.cr[6].eq {
	pc = 0x828D6C04; continue 'dispatch;
	}
	// 828D6BEC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D6BF0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6BF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D6BF8: 4E800421  bctrl
	ctx.lr = 0x828D6BFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D6BFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D6C00: 4B945139  bl 0x8221bd38
	ctx.lr = 0x828D6C04;
	sub_8221BD38(ctx, base);
	// 828D6C04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D6C08: 4B8E0F11  bl 0x821b7b18
	ctx.lr = 0x828D6C0C;
	sub_821B7B18(ctx, base);
	// 828D6C0C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828D6C10: 483D283C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D6C18 size=516
    let mut pc: u32 = 0x828D6C18;
    'dispatch: loop {
        match pc {
            0x828D6C18 => {
    //   block [0x828D6C18..0x828D6E1C)
	// 828D6C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D6C1C: 483D27E1  bl 0x82ca93fc
	ctx.lr = 0x828D6C20;
	sub_82CA93D0(ctx, base);
	// 828D6C20: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D6C24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D6C28: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828D6C2C: 3D40828D  lis r10, -0x7d73
	ctx.r[10].s64 = -2104688640;
	// 828D6C30: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828D6C34: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828D6C38: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6C3C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828D6C40: 3BAA4A80  addi r29, r10, 0x4a80
	ctx.r[29].s64 = ctx.r[10].s64 + 19072;
	// 828D6C44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D6C48: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D6C4C: 419A0008  beq cr6, 0x828d6c54
	if ctx.cr[6].eq {
	pc = 0x828D6C54; continue 'dispatch;
	}
	// 828D6C50: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6C54: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6C58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D6C5C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6C60: 4BAF7961  bl 0x823ce5c0
	ctx.lr = 0x828D6C64;
	sub_823CE5C0(ctx, base);
	// 828D6C64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D6C68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D6C6C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6C70: 4BAF74A1  bl 0x823ce110
	ctx.lr = 0x828D6C74;
	sub_823CE110(ctx, base);
	// 828D6C74: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D6C78: 4B8E0EA1  bl 0x821b7b18
	ctx.lr = 0x828D6C7C;
	sub_821B7B18(ctx, base);
	// 828D6C7C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D6C80: 4B9485D9  bl 0x8221f258
	ctx.lr = 0x828D6C84;
	sub_8221F258(ctx, base);
	// 828D6C84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6C88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D6C8C: 419A005C  beq cr6, 0x828d6ce8
	if ctx.cr[6].eq {
	pc = 0x828D6CE8; continue 'dispatch;
	}
	// 828D6C90: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828D6C94: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828D6C98: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D6C9C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828D6CA0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D6CA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D6CA8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D6CAC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828D6CB0: 4B919591  bl 0x821f0240
	ctx.lr = 0x828D6CB4;
	sub_821F0240(ctx, base);
	// 828D6CB4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D6CB8: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828D6CBC: 4B94859D  bl 0x8221f258
	ctx.lr = 0x828D6CC0;
	sub_8221F258(ctx, base);
	// 828D6CC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D6CC4: 419A0028  beq cr6, 0x828d6cec
	if ctx.cr[6].eq {
	pc = 0x828D6CEC; continue 'dispatch;
	}
	// 828D6CC8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828D6CCC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828D6CD0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D6CD4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828D6CD8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D6CDC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D6CE0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D6CE4: 4800000C  b 0x828d6cf0
	pc = 0x828D6CF0; continue 'dispatch;
	// 828D6CE8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828D6CEC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D6CF0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6CF4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D6CF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D6CFC: 419A0008  beq cr6, 0x828d6d04
	if ctx.cr[6].eq {
	pc = 0x828D6D04; continue 'dispatch;
	}
	// 828D6D00: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6D04: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D6D08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D6D0C: 419A0078  beq cr6, 0x828d6d84
	if ctx.cr[6].eq {
	pc = 0x828D6D84; continue 'dispatch;
	}
	// 828D6D10: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6D14: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828D6D18: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6D1C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6D20: 4B9523E9  bl 0x82229108
	ctx.lr = 0x828D6D24;
	sub_82229108(ctx, base);
	// 828D6D24: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D6D28: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828D6D2C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6D30: 3BCB7E48  addi r30, r11, 0x7e48
	ctx.r[30].s64 = ctx.r[11].s64 + 32328;
	// 828D6D34: 4B950B4D  bl 0x82227880
	ctx.lr = 0x828D6D38;
	sub_82227880(ctx, base);
	// 828D6D38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D6D3C: 3D408246  lis r10, -0x7dba
	ctx.r[10].s64 = -2109341696;
	// 828D6D40: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D6D44: 388A5B50  addi r4, r10, 0x5b50
	ctx.r[4].s64 = ctx.r[10].s64 + 23376;
	// 828D6D48: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6D4C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828D6D50: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828D6D54: 4B8C3D2D  bl 0x8219aa80
	ctx.lr = 0x828D6D58;
	sub_8219AA80(ctx, base);
	// 828D6D58: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6D5C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D6D60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D6D64: 4BAF76BD  bl 0x823ce420
	ctx.lr = 0x828D6D68;
	sub_823CE420(ctx, base);
	// 828D6D68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6D6C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828D6D70: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D6D74: 4814D955  bl 0x82a246c8
	ctx.lr = 0x828D6D78;
	sub_82A246C8(ctx, base);
	// 828D6D78: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D6D7C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828D6D80: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828D6D84: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828D6D88: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D6D8C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828D6D90: 419A0020  beq cr6, 0x828d6db0
	if ctx.cr[6].eq {
	pc = 0x828D6DB0; continue 'dispatch;
	}
	// 828D6D94: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D6D98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6D9C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D6DA0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828D6DA4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D6DA8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6DAC: 4082FFE8  bne 0x828d6d94
	if !ctx.cr[0].eq {
	pc = 0x828D6D94; continue 'dispatch;
	}
	// 828D6DB0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6DB4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D6DB8: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828D6DBC: 4BA1EB8D  bl 0x822f5948
	ctx.lr = 0x828D6DC0;
	sub_822F5948(ctx, base);
	// 828D6DC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6DC4: 4B8E0D55  bl 0x821b7b18
	ctx.lr = 0x828D6DC8;
	sub_821B7B18(ctx, base);
	// 828D6DC8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D6DCC: 419A0040  beq cr6, 0x828d6e0c
	if ctx.cr[6].eq {
	pc = 0x828D6E0C; continue 'dispatch;
	}
	// 828D6DD0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D6DD4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6DD8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D6DDC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D6DE0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D6DE4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6DE8: 4082FFE8  bne 0x828d6dd0
	if !ctx.cr[0].eq {
	pc = 0x828D6DD0; continue 'dispatch;
	}
	// 828D6DEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D6DF0: 409A001C  bne cr6, 0x828d6e0c
	if !ctx.cr[6].eq {
	pc = 0x828D6E0C; continue 'dispatch;
	}
	// 828D6DF4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D6DF8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6DFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D6E00: 4E800421  bctrl
	ctx.lr = 0x828D6E04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D6E04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D6E08: 4B944F31  bl 0x8221bd38
	ctx.lr = 0x828D6E0C;
	sub_8221BD38(ctx, base);
	// 828D6E0C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D6E10: 4B8E0D09  bl 0x821b7b18
	ctx.lr = 0x828D6E14;
	sub_821B7B18(ctx, base);
	// 828D6E14: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828D6E18: 483D2634  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D6E20 size=584
    let mut pc: u32 = 0x828D6E20;
    'dispatch: loop {
        match pc {
            0x828D6E20 => {
    //   block [0x828D6E20..0x828D7068)
	// 828D6E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D6E24: 483D25DD  bl 0x82ca9400
	ctx.lr = 0x828D6E28;
	sub_82CA93D0(ctx, base);
	// 828D6E28: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D6E2C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6E30: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D6E34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D6E38: 409A0010  bne cr6, 0x828d6e48
	if !ctx.cr[6].eq {
	pc = 0x828D6E48; continue 'dispatch;
	}
	// 828D6E3C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D6E40: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828D6E44: 48000008  b 0x828d6e4c
	pc = 0x828D6E4C; continue 'dispatch;
	// 828D6E48: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6E4C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6E50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D6E54: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6E58: 4BAF7769  bl 0x823ce5c0
	ctx.lr = 0x828D6E5C;
	sub_823CE5C0(ctx, base);
	// 828D6E5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D6E60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6E64: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6E68: 4BAF7399  bl 0x823ce200
	ctx.lr = 0x828D6E6C;
	sub_823CE200(ctx, base);
	// 828D6E6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D6E70: 4B8E0CA9  bl 0x821b7b18
	ctx.lr = 0x828D6E74;
	sub_821B7B18(ctx, base);
	// 828D6E74: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828D6E78: 4B9483E1  bl 0x8221f258
	ctx.lr = 0x828D6E7C;
	sub_8221F258(ctx, base);
	// 828D6E7C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D6E80: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D6E84: 419A0040  beq cr6, 0x828d6ec4
	if ctx.cr[6].eq {
	pc = 0x828D6EC4; continue 'dispatch;
	}
	// 828D6E88: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828D6E8C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D6E90: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828D6E94: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D6E98: 4B9483C1  bl 0x8221f258
	ctx.lr = 0x828D6E9C;
	sub_8221F258(ctx, base);
	// 828D6E9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D6EA0: 419A0028  beq cr6, 0x828d6ec8
	if ctx.cr[6].eq {
	pc = 0x828D6EC8; continue 'dispatch;
	}
	// 828D6EA4: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828D6EA8: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828D6EAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D6EB0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828D6EB4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D6EB8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D6EBC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D6EC0: 4800000C  b 0x828d6ecc
	pc = 0x828D6ECC; continue 'dispatch;
	// 828D6EC4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D6EC8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828D6ECC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D6ED0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D6ED4: 419A00FC  beq cr6, 0x828d6fd0
	if ctx.cr[6].eq {
	pc = 0x828D6FD0; continue 'dispatch;
	}
	// 828D6ED8: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6EDC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828D6EE0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6EE4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D6EE8: 4B952221  bl 0x82229108
	ctx.lr = 0x828D6EEC;
	sub_82229108(ctx, base);
	// 828D6EEC: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D6EF0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828D6EF4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D6EF8: 3BCB7FA8  addi r30, r11, 0x7fa8
	ctx.r[30].s64 = ctx.r[11].s64 + 32680;
	// 828D6EFC: 4B950985  bl 0x82227880
	ctx.lr = 0x828D6F00;
	sub_82227880(ctx, base);
	// 828D6F00: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D6F04: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828D6F08: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D6F0C: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828D6F10: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D6F14: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828D6F18: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828D6F1C: 4B8C3B65  bl 0x8219aa80
	ctx.lr = 0x828D6F20;
	sub_8219AA80(ctx, base);
	// 828D6F20: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828D6F24: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828D6F28: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828D6F2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6F30: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D6F34: 4BAF74ED  bl 0x823ce420
	ctx.lr = 0x828D6F38;
	sub_823CE420(ctx, base);
	// 828D6F38: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D6F3C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828D6F40: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D6F44: 4814D785  bl 0x82a246c8
	ctx.lr = 0x828D6F48;
	sub_82A246C8(ctx, base);
	// 828D6F48: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D6F4C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828D6F50: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828D6F54: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828D6F58: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6F5C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6F60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6F64: 4B9521A5  bl 0x82229108
	ctx.lr = 0x828D6F68;
	sub_82229108(ctx, base);
	// 828D6F68: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D6F6C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828D6F70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6F74: 3BEBD2A8  addi r31, r11, -0x2d58
	ctx.r[31].s64 = ctx.r[11].s64 + -11608;
	// 828D6F78: 4B950909  bl 0x82227880
	ctx.lr = 0x828D6F7C;
	sub_82227880(ctx, base);
	// 828D6F7C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828D6F80: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828D6F84: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D6F88: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828D6F8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6F90: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828D6F94: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828D6F98: 4B8C3AE9  bl 0x8219aa80
	ctx.lr = 0x828D6F9C;
	sub_8219AA80(ctx, base);
	// 828D6F9C: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828D6FA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D6FA4: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828D6FA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6FAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6FB0: 4BAF7471  bl 0x823ce420
	ctx.lr = 0x828D6FB4;
	sub_823CE420(ctx, base);
	// 828D6FB4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6FB8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828D6FBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6FC0: 4814D709  bl 0x82a246c8
	ctx.lr = 0x828D6FC4;
	sub_82A246C8(ctx, base);
	// 828D6FC4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D6FC8: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828D6FCC: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828D6FD0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828D6FD4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828D6FD8: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828D6FDC: 419A0020  beq cr6, 0x828d6ffc
	if ctx.cr[6].eq {
	pc = 0x828D6FFC; continue 'dispatch;
	}
	// 828D6FE0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D6FE4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6FE8: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D6FEC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828D6FF0: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D6FF4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6FF8: 4082FFE8  bne 0x828d6fe0
	if !ctx.cr[0].eq {
	pc = 0x828D6FE0; continue 'dispatch;
	}
	// 828D6FFC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7000: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D7004: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828D7008: 4BA1E941  bl 0x822f5948
	ctx.lr = 0x828D700C;
	sub_822F5948(ctx, base);
	// 828D700C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D7010: 4B8E0B09  bl 0x821b7b18
	ctx.lr = 0x828D7014;
	sub_821B7B18(ctx, base);
	// 828D7014: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828D7018: 419A0040  beq cr6, 0x828d7058
	if ctx.cr[6].eq {
	pc = 0x828D7058; continue 'dispatch;
	}
	// 828D701C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D7020: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D7024: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D7028: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D702C: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D7030: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D7034: 4082FFE8  bne 0x828d701c
	if !ctx.cr[0].eq {
	pc = 0x828D701C; continue 'dispatch;
	}
	// 828D7038: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D703C: 409A001C  bne cr6, 0x828d7058
	if !ctx.cr[6].eq {
	pc = 0x828D7058; continue 'dispatch;
	}
	// 828D7040: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D7044: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7048: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D704C: 4E800421  bctrl
	ctx.lr = 0x828D7050;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7050: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D7054: 4B944CE5  bl 0x8221bd38
	ctx.lr = 0x828D7058;
	sub_8221BD38(ctx, base);
	// 828D7058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D705C: 4B8E0ABD  bl 0x821b7b18
	ctx.lr = 0x828D7060;
	sub_821B7B18(ctx, base);
	// 828D7060: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828D7064: 483D23EC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7068 size=516
    let mut pc: u32 = 0x828D7068;
    'dispatch: loop {
        match pc {
            0x828D7068 => {
    //   block [0x828D7068..0x828D726C)
	// 828D7068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D706C: 483D2391  bl 0x82ca93fc
	ctx.lr = 0x828D7070;
	sub_82CA93D0(ctx, base);
	// 828D7070: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7074: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D7078: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828D707C: 3D40828D  lis r10, -0x7d73
	ctx.r[10].s64 = -2104688640;
	// 828D7080: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828D7084: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828D7088: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D708C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828D7090: 3BAA5758  addi r29, r10, 0x5758
	ctx.r[29].s64 = ctx.r[10].s64 + 22360;
	// 828D7094: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7098: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D709C: 419A0008  beq cr6, 0x828d70a4
	if ctx.cr[6].eq {
	pc = 0x828D70A4; continue 'dispatch;
	}
	// 828D70A0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D70A4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D70A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D70AC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D70B0: 4BAF7511  bl 0x823ce5c0
	ctx.lr = 0x828D70B4;
	sub_823CE5C0(ctx, base);
	// 828D70B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D70B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D70BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D70C0: 4BAF7051  bl 0x823ce110
	ctx.lr = 0x828D70C4;
	sub_823CE110(ctx, base);
	// 828D70C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D70C8: 4B8E0A51  bl 0x821b7b18
	ctx.lr = 0x828D70CC;
	sub_821B7B18(ctx, base);
	// 828D70CC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D70D0: 4B948189  bl 0x8221f258
	ctx.lr = 0x828D70D4;
	sub_8221F258(ctx, base);
	// 828D70D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D70D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D70DC: 419A005C  beq cr6, 0x828d7138
	if ctx.cr[6].eq {
	pc = 0x828D7138; continue 'dispatch;
	}
	// 828D70E0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828D70E4: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828D70E8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D70EC: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828D70F0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D70F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D70F8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D70FC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828D7100: 4B919141  bl 0x821f0240
	ctx.lr = 0x828D7104;
	sub_821F0240(ctx, base);
	// 828D7104: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D7108: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828D710C: 4B94814D  bl 0x8221f258
	ctx.lr = 0x828D7110;
	sub_8221F258(ctx, base);
	// 828D7110: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D7114: 419A0028  beq cr6, 0x828d713c
	if ctx.cr[6].eq {
	pc = 0x828D713C; continue 'dispatch;
	}
	// 828D7118: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828D711C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828D7120: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7124: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828D7128: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D712C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D7130: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D7134: 4800000C  b 0x828d7140
	pc = 0x828D7140; continue 'dispatch;
	// 828D7138: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828D713C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D7140: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7144: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D7148: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D714C: 419A0008  beq cr6, 0x828d7154
	if ctx.cr[6].eq {
	pc = 0x828D7154; continue 'dispatch;
	}
	// 828D7150: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7154: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D7158: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D715C: 419A0078  beq cr6, 0x828d71d4
	if ctx.cr[6].eq {
	pc = 0x828D71D4; continue 'dispatch;
	}
	// 828D7160: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7164: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828D7168: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D716C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D7170: 4B951F99  bl 0x82229108
	ctx.lr = 0x828D7174;
	sub_82229108(ctx, base);
	// 828D7174: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D7178: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828D717C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D7180: 3BCB7FE8  addi r30, r11, 0x7fe8
	ctx.r[30].s64 = ctx.r[11].s64 + 32744;
	// 828D7184: 4B9506FD  bl 0x82227880
	ctx.lr = 0x828D7188;
	sub_82227880(ctx, base);
	// 828D7188: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D718C: 3D408278  lis r10, -0x7d88
	ctx.r[10].s64 = -2106064896;
	// 828D7190: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D7194: 388A3318  addi r4, r10, 0x3318
	ctx.r[4].s64 = ctx.r[10].s64 + 13080;
	// 828D7198: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D719C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828D71A0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828D71A4: 4B8C38DD  bl 0x8219aa80
	ctx.lr = 0x828D71A8;
	sub_8219AA80(ctx, base);
	// 828D71A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D71AC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D71B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D71B4: 4BAF726D  bl 0x823ce420
	ctx.lr = 0x828D71B8;
	sub_823CE420(ctx, base);
	// 828D71B8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D71BC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828D71C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D71C4: 4814D505  bl 0x82a246c8
	ctx.lr = 0x828D71C8;
	sub_82A246C8(ctx, base);
	// 828D71C8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D71CC: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828D71D0: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828D71D4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828D71D8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D71DC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828D71E0: 419A0020  beq cr6, 0x828d7200
	if ctx.cr[6].eq {
	pc = 0x828D7200; continue 'dispatch;
	}
	// 828D71E4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D71E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D71EC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D71F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828D71F4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D71F8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D71FC: 4082FFE8  bne 0x828d71e4
	if !ctx.cr[0].eq {
	pc = 0x828D71E4; continue 'dispatch;
	}
	// 828D7200: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7204: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D7208: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828D720C: 4BA1E73D  bl 0x822f5948
	ctx.lr = 0x828D7210;
	sub_822F5948(ctx, base);
	// 828D7210: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D7214: 4B8E0905  bl 0x821b7b18
	ctx.lr = 0x828D7218;
	sub_821B7B18(ctx, base);
	// 828D7218: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D721C: 419A0040  beq cr6, 0x828d725c
	if ctx.cr[6].eq {
	pc = 0x828D725C; continue 'dispatch;
	}
	// 828D7220: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D7224: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D7228: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D722C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D7230: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D7234: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D7238: 4082FFE8  bne 0x828d7220
	if !ctx.cr[0].eq {
	pc = 0x828D7220; continue 'dispatch;
	}
	// 828D723C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D7240: 409A001C  bne cr6, 0x828d725c
	if !ctx.cr[6].eq {
	pc = 0x828D725C; continue 'dispatch;
	}
	// 828D7244: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D7248: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D724C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D7250: 4E800421  bctrl
	ctx.lr = 0x828D7254;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7254: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D7258: 4B944AE1  bl 0x8221bd38
	ctx.lr = 0x828D725C;
	sub_8221BD38(ctx, base);
	// 828D725C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D7260: 4B8E08B9  bl 0x821b7b18
	ctx.lr = 0x828D7264;
	sub_821B7B18(ctx, base);
	// 828D7264: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828D7268: 483D21E4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7270 size=512
    let mut pc: u32 = 0x828D7270;
    'dispatch: loop {
        match pc {
            0x828D7270 => {
    //   block [0x828D7270..0x828D7470)
	// 828D7270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7274: 483D2189  bl 0x82ca93fc
	ctx.lr = 0x828D7278;
	sub_82CA93D0(ctx, base);
	// 828D7278: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D727C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D7280: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828D7284: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828D7288: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828D728C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828D7290: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7294: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828D7298: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D729C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D72A0: 419A0008  beq cr6, 0x828d72a8
	if ctx.cr[6].eq {
	pc = 0x828D72A8; continue 'dispatch;
	}
	// 828D72A4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D72A8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D72AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D72B0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D72B4: 4BAF730D  bl 0x823ce5c0
	ctx.lr = 0x828D72B8;
	sub_823CE5C0(ctx, base);
	// 828D72B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D72BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D72C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D72C4: 4BAF6E4D  bl 0x823ce110
	ctx.lr = 0x828D72C8;
	sub_823CE110(ctx, base);
	// 828D72C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D72CC: 4B8E084D  bl 0x821b7b18
	ctx.lr = 0x828D72D0;
	sub_821B7B18(ctx, base);
	// 828D72D0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D72D4: 4B947F85  bl 0x8221f258
	ctx.lr = 0x828D72D8;
	sub_8221F258(ctx, base);
	// 828D72D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D72DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D72E0: 419A005C  beq cr6, 0x828d733c
	if ctx.cr[6].eq {
	pc = 0x828D733C; continue 'dispatch;
	}
	// 828D72E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828D72E8: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828D72EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D72F0: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828D72F4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D72F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D72FC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D7300: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828D7304: 4B918F3D  bl 0x821f0240
	ctx.lr = 0x828D7308;
	sub_821F0240(ctx, base);
	// 828D7308: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D730C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828D7310: 4B947F49  bl 0x8221f258
	ctx.lr = 0x828D7314;
	sub_8221F258(ctx, base);
	// 828D7314: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D7318: 419A0028  beq cr6, 0x828d7340
	if ctx.cr[6].eq {
	pc = 0x828D7340; continue 'dispatch;
	}
	// 828D731C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828D7320: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828D7324: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7328: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828D732C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D7330: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D7334: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D7338: 4800000C  b 0x828d7344
	pc = 0x828D7344; continue 'dispatch;
	// 828D733C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828D7340: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D7344: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7348: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D734C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7350: 419A0008  beq cr6, 0x828d7358
	if ctx.cr[6].eq {
	pc = 0x828D7358; continue 'dispatch;
	}
	// 828D7354: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7358: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D735C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7360: 419A0078  beq cr6, 0x828d73d8
	if ctx.cr[6].eq {
	pc = 0x828D73D8; continue 'dispatch;
	}
	// 828D7364: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7368: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828D736C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7370: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D7374: 4B951D95  bl 0x82229108
	ctx.lr = 0x828D7378;
	sub_82229108(ctx, base);
	// 828D7378: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828D737C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828D7380: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D7384: 3BCB8160  addi r30, r11, -0x7ea0
	ctx.r[30].s64 = ctx.r[11].s64 + -32416;
	// 828D7388: 4B9504F9  bl 0x82227880
	ctx.lr = 0x828D738C;
	sub_82227880(ctx, base);
	// 828D738C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D7390: 3D408295  lis r10, -0x7d6b
	ctx.r[10].s64 = -2104164352;
	// 828D7394: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D7398: 388A3B58  addi r4, r10, 0x3b58
	ctx.r[4].s64 = ctx.r[10].s64 + 15192;
	// 828D739C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D73A0: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828D73A4: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828D73A8: 4B8C36D9  bl 0x8219aa80
	ctx.lr = 0x828D73AC;
	sub_8219AA80(ctx, base);
	// 828D73AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D73B0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D73B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D73B8: 4BAF7069  bl 0x823ce420
	ctx.lr = 0x828D73BC;
	sub_823CE420(ctx, base);
	// 828D73BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D73C0: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828D73C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D73C8: 4814D301  bl 0x82a246c8
	ctx.lr = 0x828D73CC;
	sub_82A246C8(ctx, base);
	// 828D73CC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D73D0: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828D73D4: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828D73D8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828D73DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D73E0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828D73E4: 419A0020  beq cr6, 0x828d7404
	if ctx.cr[6].eq {
	pc = 0x828D7404; continue 'dispatch;
	}
	// 828D73E8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D73EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D73F0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D73F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828D73F8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D73FC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D7400: 4082FFE8  bne 0x828d73e8
	if !ctx.cr[0].eq {
	pc = 0x828D73E8; continue 'dispatch;
	}
	// 828D7404: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7408: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D740C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828D7410: 4BA1E539  bl 0x822f5948
	ctx.lr = 0x828D7414;
	sub_822F5948(ctx, base);
	// 828D7414: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D7418: 4B8E0701  bl 0x821b7b18
	ctx.lr = 0x828D741C;
	sub_821B7B18(ctx, base);
	// 828D741C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D7420: 419A0040  beq cr6, 0x828d7460
	if ctx.cr[6].eq {
	pc = 0x828D7460; continue 'dispatch;
	}
	// 828D7424: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D7428: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D742C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D7430: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D7434: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D7438: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D743C: 4082FFE8  bne 0x828d7424
	if !ctx.cr[0].eq {
	pc = 0x828D7424; continue 'dispatch;
	}
	// 828D7440: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D7444: 409A001C  bne cr6, 0x828d7460
	if !ctx.cr[6].eq {
	pc = 0x828D7460; continue 'dispatch;
	}
	// 828D7448: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D744C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7450: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D7454: 4E800421  bctrl
	ctx.lr = 0x828D7458;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7458: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D745C: 4B9448DD  bl 0x8221bd38
	ctx.lr = 0x828D7460;
	sub_8221BD38(ctx, base);
	// 828D7460: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D7464: 4B8E06B5  bl 0x821b7b18
	ctx.lr = 0x828D7468;
	sub_821B7B18(ctx, base);
	// 828D7468: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828D746C: 483D1FE0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D7470 size=56
    let mut pc: u32 = 0x828D7470;
    'dispatch: loop {
        match pc {
            0x828D7470 => {
    //   block [0x828D7470..0x828D74A8)
	// 828D7470: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828D7474: 419A0018  beq cr6, 0x828d748c
	if ctx.cr[6].eq {
	pc = 0x828D748C; continue 'dispatch;
	}
	// 828D7478: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D747C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D7480: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D7484: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D7488: 409A0008  bne cr6, 0x828d7490
	if !ctx.cr[6].eq {
	pc = 0x828D7490; continue 'dispatch;
	}
	// 828D748C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7490: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D7494: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7498: 419A0010  beq cr6, 0x828d74a8
	if ctx.cr[6].eq {
		sub_828D74A8(ctx, base);
		return;
	}
	// 828D749C: 8164002C  lwz r11, 0x2c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D74A0: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828D74A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D74A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D74A8 size=8
    let mut pc: u32 = 0x828D74A8;
    'dispatch: loop {
        match pc {
            0x828D74A8 => {
    //   block [0x828D74A8..0x828D74B0)
	// 828D74A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828D74AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D74B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D74B0 size=464
    let mut pc: u32 = 0x828D74B0;
    'dispatch: loop {
        match pc {
            0x828D74B0 => {
    //   block [0x828D74B0..0x828D7680)
	// 828D74B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D74B4: 483D1F59  bl 0x82ca940c
	ctx.lr = 0x828D74B8;
	sub_82CA93D0(ctx, base);
	// 828D74B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D74BC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D74C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D74C4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D74C8: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D74CC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828D74D0: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 828D74D4: 2F080008  cmpwi cr6, r8, 8
	ctx.cr[6].compare_i32(ctx.r[8].s32, 8, &mut ctx.xer);
	// 828D74D8: 4198019C  blt cr6, 0x828d7674
	if ctx.cr[6].lt {
	pc = 0x828D7674; continue 'dispatch;
	}
	// 828D74DC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828D74E0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D74E4: 38AB79B0  addi r5, r11, 0x79b0
	ctx.r[5].s64 = ctx.r[11].s64 + 31152;
	// 828D74E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D74EC: 4B950ADD  bl 0x82227fc8
	ctx.lr = 0x828D74F0;
	sub_82227FC8(ctx, base);
	// 828D74F0: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828D74F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D74F8: 419A017C  beq cr6, 0x828d7674
	if ctx.cr[6].eq {
	pc = 0x828D7674; continue 'dispatch;
	}
	// 828D74FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D7500: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7504: 4B950BF5  bl 0x822280f8
	ctx.lr = 0x828D7508;
	sub_822280F8(ctx, base);
	// 828D7508: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D750C: 4B950055  bl 0x82227560
	ctx.lr = 0x828D7510;
	sub_82227560(ctx, base);
	// 828D7510: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D7514: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D7518: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D751C: 4B908E6D  bl 0x821e0388
	ctx.lr = 0x828D7520;
	sub_821E0388(ctx, base);
	// 828D7520: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D7524: 419A0018  beq cr6, 0x828d753c
	if ctx.cr[6].eq {
	pc = 0x828D753C; continue 'dispatch;
	}
	// 828D7528: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D752C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D7530: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D7534: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D7538: 409A0008  bne cr6, 0x828d7540
	if !ctx.cr[6].eq {
	pc = 0x828D7540; continue 'dispatch;
	}
	// 828D753C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7540: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D7544: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7548: 419A012C  beq cr6, 0x828d7674
	if ctx.cr[6].eq {
	pc = 0x828D7674; continue 'dispatch;
	}
	// 828D754C: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D7550: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7554: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828D7558: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D755C: 419A00EC  beq cr6, 0x828d7648
	if ctx.cr[6].eq {
	pc = 0x828D7648; continue 'dispatch;
	}
	// 828D7560: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D7564: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7568: 419A0020  beq cr6, 0x828d7588
	if ctx.cr[6].eq {
	pc = 0x828D7588; continue 'dispatch;
	}
	// 828D756C: 894B0045  lbz r10, 0x45(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(69 as u32) ) } as u64;
	// 828D7570: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D7574: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D7578: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D757C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7580: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7584: 480000C8  b 0x828d764c
	pc = 0x828D764C; continue 'dispatch;
	// 828D7588: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D758C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7590: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D7594: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828D7598: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D759C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D75A0: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D75A4: 40810054  ble 0x828d75f8
	if !ctx.cr[0].gt {
	pc = 0x828D75F8; continue 'dispatch;
	}
	// 828D75A8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D75AC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D75B0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D75B4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D75B8: 2F070045  cmpwi cr6, r7, 0x45
	ctx.cr[6].compare_i32(ctx.r[7].s32, 69, &mut ctx.xer);
	// 828D75BC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D75C0: 41980008  blt cr6, 0x828d75c8
	if ctx.cr[6].lt {
	pc = 0x828D75C8; continue 'dispatch;
	}
	// 828D75C4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828D75C8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D75CC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D75D0: 419A0014  beq cr6, 0x828d75e4
	if ctx.cr[6].eq {
	pc = 0x828D75E4; continue 'dispatch;
	}
	// 828D75D4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D75D8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D75DC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D75E0: 4800000C  b 0x828d75ec
	pc = 0x828D75EC; continue 'dispatch;
	// 828D75E4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D75E8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D75EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D75F0: 4199FFB8  bgt cr6, 0x828d75a8
	if ctx.cr[6].gt {
	pc = 0x828D75A8; continue 'dispatch;
	}
	// 828D75F4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D75F8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D75FC: 419A003C  beq cr6, 0x828d7638
	if ctx.cr[6].eq {
	pc = 0x828D7638; continue 'dispatch;
	}
	// 828D7600: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7604: 2F0B0045  cmpwi cr6, r11, 0x45
	ctx.cr[6].compare_i32(ctx.r[11].s32, 69, &mut ctx.xer);
	// 828D7608: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D760C: 41990008  bgt cr6, 0x828d7614
	if ctx.cr[6].gt {
	pc = 0x828D7614; continue 'dispatch;
	}
	// 828D7610: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7614: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D7618: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D761C: 409A001C  bne cr6, 0x828d7638
	if !ctx.cr[6].eq {
	pc = 0x828D7638; continue 'dispatch;
	}
	// 828D7620: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D7624: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7628: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D762C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D7630: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7634: 48000018  b 0x828d764c
	pc = 0x828D764C; continue 'dispatch;
	// 828D7638: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D763C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7640: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7644: 48000008  b 0x828d764c
	pc = 0x828D764C; continue 'dispatch;
	// 828D7648: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D764C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D7650: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D7654: 419A0020  beq cr6, 0x828d7674
	if ctx.cr[6].eq {
	pc = 0x828D7674; continue 'dispatch;
	}
	// 828D7658: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D765C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D7660: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D7664: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828D7668: 4E800421  bctrl
	ctx.lr = 0x828D766C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D766C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D7670: 483D1DEC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828D7674: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828D7678: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D767C: 483D1DE0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7680 size=376
    let mut pc: u32 = 0x828D7680;
    'dispatch: loop {
        match pc {
            0x828D7680 => {
    //   block [0x828D7680..0x828D77F8)
	// 828D7680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D7688: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D768C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828D7690: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7694: 419A0018  beq cr6, 0x828d76ac
	if ctx.cr[6].eq {
	pc = 0x828D76AC; continue 'dispatch;
	}
	// 828D7698: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D769C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828D76A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D76A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D76A8: 409A0008  bne cr6, 0x828d76b0
	if !ctx.cr[6].eq {
	pc = 0x828D76B0; continue 'dispatch;
	}
	// 828D76AC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D76B0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D76B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D76B8: 419A0130  beq cr6, 0x828d77e8
	if ctx.cr[6].eq {
	pc = 0x828D77E8; continue 'dispatch;
	}
	// 828D76BC: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D76C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D76C4: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 828D76C8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828D76CC: 419A00F8  beq cr6, 0x828d77c4
	if ctx.cr[6].eq {
	pc = 0x828D77C4; continue 'dispatch;
	}
	// 828D76D0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D76D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D76D8: 419A0024  beq cr6, 0x828d76fc
	if ctx.cr[6].eq {
	pc = 0x828D76FC; continue 'dispatch;
	}
	// 828D76DC: 892A0045  lbz r9, 0x45(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(69 as u32) ) } as u64;
	// 828D76E0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D76E4: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828D76E8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828D76EC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D76F0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828D76F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D76F8: 480000D0  b 0x828d77c8
	pc = 0x828D77C8; continue 'dispatch;
	// 828D76FC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D7700: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828D7704: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D7708: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828D770C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D7710: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D7714: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D7718: 40810054  ble 0x828d776c
	if !ctx.cr[0].gt {
	pc = 0x828D776C; continue 'dispatch;
	}
	// 828D771C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D7720: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D7724: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D7728: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D772C: 2F070045  cmpwi cr6, r7, 0x45
	ctx.cr[6].compare_i32(ctx.r[7].s32, 69, &mut ctx.xer);
	// 828D7730: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D7734: 41980008  blt cr6, 0x828d773c
	if ctx.cr[6].lt {
	pc = 0x828D773C; continue 'dispatch;
	}
	// 828D7738: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828D773C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D7740: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D7744: 419A0014  beq cr6, 0x828d7758
	if ctx.cr[6].eq {
	pc = 0x828D7758; continue 'dispatch;
	}
	// 828D7748: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D774C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D7750: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D7754: 4800000C  b 0x828d7760
	pc = 0x828D7760; continue 'dispatch;
	// 828D7758: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D775C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D7760: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D7764: 4199FFB8  bgt cr6, 0x828d771c
	if ctx.cr[6].gt {
	pc = 0x828D771C; continue 'dispatch;
	}
	// 828D7768: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D776C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D7770: 419A0040  beq cr6, 0x828d77b0
	if ctx.cr[6].eq {
	pc = 0x828D77B0; continue 'dispatch;
	}
	// 828D7774: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7778: 2F0B0045  cmpwi cr6, r11, 0x45
	ctx.cr[6].compare_i32(ctx.r[11].s32, 69, &mut ctx.xer);
	// 828D777C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D7780: 41990008  bgt cr6, 0x828d7788
	if ctx.cr[6].gt {
	pc = 0x828D7788; continue 'dispatch;
	}
	// 828D7784: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7788: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D778C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7790: 409A0020  bne cr6, 0x828d77b0
	if !ctx.cr[6].eq {
	pc = 0x828D77B0; continue 'dispatch;
	}
	// 828D7794: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D7798: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D779C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D77A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D77A4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828D77A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D77AC: 4800001C  b 0x828d77c8
	pc = 0x828D77C8; continue 'dispatch;
	// 828D77B0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D77B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D77B8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828D77BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D77C0: 48000008  b 0x828d77c8
	pc = 0x828D77C8; continue 'dispatch;
	// 828D77C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D77C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D77CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D77D0: 419A0018  beq cr6, 0x828d77e8
	if ctx.cr[6].eq {
	pc = 0x828D77E8; continue 'dispatch;
	}
	// 828D77D4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D77D8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828D77DC: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828D77E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D77E4: 4E800421  bctrl
	ctx.lr = 0x828D77E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D77E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D77EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D77F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D77F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D77F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D77F8 size=372
    let mut pc: u32 = 0x828D77F8;
    'dispatch: loop {
        match pc {
            0x828D77F8 => {
    //   block [0x828D77F8..0x828D796C)
	// 828D77F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D77FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D7800: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7804: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828D7808: 419A0018  beq cr6, 0x828d7820
	if ctx.cr[6].eq {
	pc = 0x828D7820; continue 'dispatch;
	}
	// 828D780C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D7810: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D7814: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D7818: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D781C: 409A0008  bne cr6, 0x828d7824
	if !ctx.cr[6].eq {
	pc = 0x828D7824; continue 'dispatch;
	}
	// 828D7820: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7824: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D7828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D782C: 419A012C  beq cr6, 0x828d7958
	if ctx.cr[6].eq {
	pc = 0x828D7958; continue 'dispatch;
	}
	// 828D7830: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D7834: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7838: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828D783C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D7840: 419A00E8  beq cr6, 0x828d7928
	if ctx.cr[6].eq {
	pc = 0x828D7928; continue 'dispatch;
	}
	// 828D7844: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D7848: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D784C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7850: 419A001C  beq cr6, 0x828d786c
	if ctx.cr[6].eq {
	pc = 0x828D786C; continue 'dispatch;
	}
	// 828D7854: 896B0045  lbz r11, 0x45(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(69 as u32) ) } as u64;
	// 828D7858: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828D785C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828D7860: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7864: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7868: 480000C4  b 0x828d792c
	pc = 0x828D792C; continue 'dispatch;
	// 828D786C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D7870: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7874: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D7878: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D787C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828D7880: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D7884: 40810054  ble 0x828d78d8
	if !ctx.cr[0].gt {
	pc = 0x828D78D8; continue 'dispatch;
	}
	// 828D7888: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D788C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D7890: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D7894: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7898: 2F070045  cmpwi cr6, r7, 0x45
	ctx.cr[6].compare_i32(ctx.r[7].s32, 69, &mut ctx.xer);
	// 828D789C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D78A0: 41980008  blt cr6, 0x828d78a8
	if ctx.cr[6].lt {
	pc = 0x828D78A8; continue 'dispatch;
	}
	// 828D78A4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828D78A8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D78AC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D78B0: 419A0014  beq cr6, 0x828d78c4
	if ctx.cr[6].eq {
	pc = 0x828D78C4; continue 'dispatch;
	}
	// 828D78B4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D78B8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D78BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D78C0: 4800000C  b 0x828d78cc
	pc = 0x828D78CC; continue 'dispatch;
	// 828D78C4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D78C8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D78CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D78D0: 4199FFB8  bgt cr6, 0x828d7888
	if ctx.cr[6].gt {
	pc = 0x828D7888; continue 'dispatch;
	}
	// 828D78D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D78D8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D78DC: 419A003C  beq cr6, 0x828d7918
	if ctx.cr[6].eq {
	pc = 0x828D7918; continue 'dispatch;
	}
	// 828D78E0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D78E4: 2F0B0045  cmpwi cr6, r11, 0x45
	ctx.cr[6].compare_i32(ctx.r[11].s32, 69, &mut ctx.xer);
	// 828D78E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D78EC: 41990008  bgt cr6, 0x828d78f4
	if ctx.cr[6].gt {
	pc = 0x828D78F4; continue 'dispatch;
	}
	// 828D78F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D78F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D78F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D78FC: 409A001C  bne cr6, 0x828d7918
	if !ctx.cr[6].eq {
	pc = 0x828D7918; continue 'dispatch;
	}
	// 828D7900: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D7904: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7908: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D790C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D7910: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7914: 48000018  b 0x828d792c
	pc = 0x828D792C; continue 'dispatch;
	// 828D7918: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D791C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7920: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7924: 48000008  b 0x828d792c
	pc = 0x828D792C; continue 'dispatch;
	// 828D7928: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D792C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D7930: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D7934: 419A0024  beq cr6, 0x828d7958
	if ctx.cr[6].eq {
	pc = 0x828D7958; continue 'dispatch;
	}
	// 828D7938: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D793C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D7940: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828D7944: 4E800421  bctrl
	ctx.lr = 0x828D7948;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7948: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D794C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D7950: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D7954: 4E800020  blr
	return;
	// 828D7958: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828D795C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D7960: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D7964: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D7968: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7970 size=416
    let mut pc: u32 = 0x828D7970;
    'dispatch: loop {
        match pc {
            0x828D7970 => {
    //   block [0x828D7970..0x828D7B10)
	// 828D7970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7974: 483D1A99  bl 0x82ca940c
	ctx.lr = 0x828D7978;
	sub_82CA93D0(ctx, base);
	// 828D7978: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D797C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D7980: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828D7984: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D7988: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828D798C: 419A0018  beq cr6, 0x828d79a4
	if ctx.cr[6].eq {
	pc = 0x828D79A4; continue 'dispatch;
	}
	// 828D7990: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D7994: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D7998: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D799C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D79A0: 409A0008  bne cr6, 0x828d79a8
	if !ctx.cr[6].eq {
	pc = 0x828D79A8; continue 'dispatch;
	}
	// 828D79A4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D79A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D79AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D79B0: 419A014C  beq cr6, 0x828d7afc
	if ctx.cr[6].eq {
	pc = 0x828D7AFC; continue 'dispatch;
	}
	// 828D79B4: 8164002C  lwz r11, 0x2c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D79B8: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828D79BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D79C0: 419A00F4  beq cr6, 0x828d7ab4
	if ctx.cr[6].eq {
	pc = 0x828D7AB4; continue 'dispatch;
	}
	// 828D79C4: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D79C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D79CC: 419A0024  beq cr6, 0x828d79f0
	if ctx.cr[6].eq {
	pc = 0x828D79F0; continue 'dispatch;
	}
	// 828D79D0: 894B0045  lbz r10, 0x45(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(69 as u32) ) } as u64;
	// 828D79D4: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D79D8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D79DC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D79E0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D79E4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D79E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D79EC: 480000CC  b 0x828d7ab8
	pc = 0x828D7AB8; continue 'dispatch;
	// 828D79F0: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D79F4: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D79F8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828D79FC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D7A00: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D7A04: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D7A08: 40810054  ble 0x828d7a5c
	if !ctx.cr[0].gt {
	pc = 0x828D7A5C; continue 'dispatch;
	}
	// 828D7A0C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D7A10: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D7A14: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D7A18: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7A1C: 2F070045  cmpwi cr6, r7, 0x45
	ctx.cr[6].compare_i32(ctx.r[7].s32, 69, &mut ctx.xer);
	// 828D7A20: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D7A24: 41980008  blt cr6, 0x828d7a2c
	if ctx.cr[6].lt {
	pc = 0x828D7A2C; continue 'dispatch;
	}
	// 828D7A28: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828D7A2C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D7A30: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D7A34: 419A0014  beq cr6, 0x828d7a48
	if ctx.cr[6].eq {
	pc = 0x828D7A48; continue 'dispatch;
	}
	// 828D7A38: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D7A3C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D7A40: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D7A44: 4800000C  b 0x828d7a50
	pc = 0x828D7A50; continue 'dispatch;
	// 828D7A48: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D7A4C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D7A50: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D7A54: 4199FFB8  bgt cr6, 0x828d7a0c
	if ctx.cr[6].gt {
	pc = 0x828D7A0C; continue 'dispatch;
	}
	// 828D7A58: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D7A5C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D7A60: 419A0040  beq cr6, 0x828d7aa0
	if ctx.cr[6].eq {
	pc = 0x828D7AA0; continue 'dispatch;
	}
	// 828D7A64: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7A68: 2F0B0045  cmpwi cr6, r11, 0x45
	ctx.cr[6].compare_i32(ctx.r[11].s32, 69, &mut ctx.xer);
	// 828D7A6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D7A70: 41990008  bgt cr6, 0x828d7a78
	if ctx.cr[6].gt {
	pc = 0x828D7A78; continue 'dispatch;
	}
	// 828D7A74: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D7A78: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D7A7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7A80: 409A0020  bne cr6, 0x828d7aa0
	if !ctx.cr[6].eq {
	pc = 0x828D7AA0; continue 'dispatch;
	}
	// 828D7A84: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D7A88: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D7A8C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D7A90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7A94: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D7A98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D7A9C: 4800001C  b 0x828d7ab8
	pc = 0x828D7AB8; continue 'dispatch;
	// 828D7AA0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D7AA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7AA8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828D7AAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D7AB0: 48000008  b 0x828d7ab8
	pc = 0x828D7AB8; continue 'dispatch;
	// 828D7AB4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D7AB8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D7ABC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7AC0: 419A003C  beq cr6, 0x828d7afc
	if ctx.cr[6].eq {
	pc = 0x828D7AFC; continue 'dispatch;
	}
	// 828D7AC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D7AC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D7ACC: 4B918775  bl 0x821f0240
	ctx.lr = 0x828D7AD0;
	sub_821F0240(ctx, base);
	// 828D7AD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D7AD4: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D7AD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D7ADC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D7AE0: 4E800421  bctrl
	ctx.lr = 0x828D7AE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7AE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D7AE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7AEC: 4B93D2ED  bl 0x82214dd8
	ctx.lr = 0x828D7AF0;
	sub_82214DD8(ctx, base);
	// 828D7AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D7AF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D7AF8: 483D1964  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828D7AFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7B00: 4B93D2D9  bl 0x82214dd8
	ctx.lr = 0x828D7B04;
	sub_82214DD8(ctx, base);
	// 828D7B04: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828D7B08: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D7B0C: 483D1950  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D7B10 size=380
    let mut pc: u32 = 0x828D7B10;
    'dispatch: loop {
        match pc {
            0x828D7B10 => {
    //   block [0x828D7B10..0x828D7C8C)
	// 828D7B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7B14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D7B18: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7B1C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828D7B20: 419A0018  beq cr6, 0x828d7b38
	if ctx.cr[6].eq {
	pc = 0x828D7B38; continue 'dispatch;
	}
	// 828D7B24: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D7B28: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D7B2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D7B30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D7B34: 409A0008  bne cr6, 0x828d7b3c
	if !ctx.cr[6].eq {
	pc = 0x828D7B3C; continue 'dispatch;
	}
	// 828D7B38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7B3C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D7B40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7B44: 419A0130  beq cr6, 0x828d7c74
	if ctx.cr[6].eq {
	pc = 0x828D7C74; continue 'dispatch;
	}
	// 828D7B48: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D7B4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7B50: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828D7B54: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D7B58: 419A00EC  beq cr6, 0x828d7c44
	if ctx.cr[6].eq {
	pc = 0x828D7C44; continue 'dispatch;
	}
	// 828D7B5C: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D7B60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7B64: 419A0020  beq cr6, 0x828d7b84
	if ctx.cr[6].eq {
	pc = 0x828D7B84; continue 'dispatch;
	}
	// 828D7B68: 894B0045  lbz r10, 0x45(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(69 as u32) ) } as u64;
	// 828D7B6C: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D7B70: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D7B74: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D7B78: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7B7C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7B80: 480000C8  b 0x828d7c48
	pc = 0x828D7C48; continue 'dispatch;
	// 828D7B84: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D7B88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7B8C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D7B90: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828D7B94: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D7B98: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D7B9C: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D7BA0: 40810054  ble 0x828d7bf4
	if !ctx.cr[0].gt {
	pc = 0x828D7BF4; continue 'dispatch;
	}
	// 828D7BA4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D7BA8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D7BAC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D7BB0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7BB4: 2F070045  cmpwi cr6, r7, 0x45
	ctx.cr[6].compare_i32(ctx.r[7].s32, 69, &mut ctx.xer);
	// 828D7BB8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D7BBC: 41980008  blt cr6, 0x828d7bc4
	if ctx.cr[6].lt {
	pc = 0x828D7BC4; continue 'dispatch;
	}
	// 828D7BC0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828D7BC4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D7BC8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D7BCC: 419A0014  beq cr6, 0x828d7be0
	if ctx.cr[6].eq {
	pc = 0x828D7BE0; continue 'dispatch;
	}
	// 828D7BD0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D7BD4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D7BD8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D7BDC: 4800000C  b 0x828d7be8
	pc = 0x828D7BE8; continue 'dispatch;
	// 828D7BE0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D7BE4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D7BE8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D7BEC: 4199FFB8  bgt cr6, 0x828d7ba4
	if ctx.cr[6].gt {
	pc = 0x828D7BA4; continue 'dispatch;
	}
	// 828D7BF0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D7BF4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D7BF8: 419A003C  beq cr6, 0x828d7c34
	if ctx.cr[6].eq {
	pc = 0x828D7C34; continue 'dispatch;
	}
	// 828D7BFC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7C00: 2F0B0045  cmpwi cr6, r11, 0x45
	ctx.cr[6].compare_i32(ctx.r[11].s32, 69, &mut ctx.xer);
	// 828D7C04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D7C08: 41990008  bgt cr6, 0x828d7c10
	if ctx.cr[6].gt {
	pc = 0x828D7C10; continue 'dispatch;
	}
	// 828D7C0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7C10: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D7C14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7C18: 409A001C  bne cr6, 0x828d7c34
	if !ctx.cr[6].eq {
	pc = 0x828D7C34; continue 'dispatch;
	}
	// 828D7C1C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D7C20: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7C24: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D7C28: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D7C2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7C30: 48000018  b 0x828d7c48
	pc = 0x828D7C48; continue 'dispatch;
	// 828D7C34: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D7C38: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7C3C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7C40: 48000008  b 0x828d7c48
	pc = 0x828D7C48; continue 'dispatch;
	// 828D7C44: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D7C48: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D7C4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D7C50: 419A0024  beq cr6, 0x828d7c74
	if ctx.cr[6].eq {
	pc = 0x828D7C74; continue 'dispatch;
	}
	// 828D7C54: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D7C58: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D7C5C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828D7C60: 4E800421  bctrl
	ctx.lr = 0x828D7C64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7C64: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D7C68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D7C6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D7C70: 4E800020  blr
	return;
	// 828D7C74: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828D7C78: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D7C7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D7C80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D7C84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D7C88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7C90 size=440
    let mut pc: u32 = 0x828D7C90;
    'dispatch: loop {
        match pc {
            0x828D7C90 => {
    //   block [0x828D7C90..0x828D7E48)
	// 828D7C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7C94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D7C98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D7C9C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7CA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D7CA4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828D7CA8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828D7CAC: 419A0018  beq cr6, 0x828d7cc4
	if ctx.cr[6].eq {
	pc = 0x828D7CC4; continue 'dispatch;
	}
	// 828D7CB0: 89650090  lbz r11, 0x90(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D7CB4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D7CB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D7CBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D7CC0: 409A0008  bne cr6, 0x828d7cc8
	if !ctx.cr[6].eq {
	pc = 0x828D7CC8; continue 'dispatch;
	}
	// 828D7CC4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D7CC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D7CCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7CD0: 419A0138  beq cr6, 0x828d7e08
	if ctx.cr[6].eq {
	pc = 0x828D7E08; continue 'dispatch;
	}
	// 828D7CD4: 8145002C  lwz r10, 0x2c(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D7CD8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D7CDC: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828D7CE0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D7CE4: 419A00E8  beq cr6, 0x828d7dcc
	if ctx.cr[6].eq {
	pc = 0x828D7DCC; continue 'dispatch;
	}
	// 828D7CE8: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D7CEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7CF0: 419A0020  beq cr6, 0x828d7d10
	if ctx.cr[6].eq {
	pc = 0x828D7D10; continue 'dispatch;
	}
	// 828D7CF4: 894B0045  lbz r10, 0x45(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(69 as u32) ) } as u64;
	// 828D7CF8: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D7CFC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828D7D00: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D7D04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7D08: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7D0C: 480000C4  b 0x828d7dd0
	pc = 0x828D7DD0; continue 'dispatch;
	// 828D7D10: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D7D14: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D7D18: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828D7D1C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D7D20: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D7D24: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D7D28: 40810054  ble 0x828d7d7c
	if !ctx.cr[0].gt {
	pc = 0x828D7D7C; continue 'dispatch;
	}
	// 828D7D2C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D7D30: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D7D34: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D7D38: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7D3C: 2F070045  cmpwi cr6, r7, 0x45
	ctx.cr[6].compare_i32(ctx.r[7].s32, 69, &mut ctx.xer);
	// 828D7D40: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D7D44: 41980008  blt cr6, 0x828d7d4c
	if ctx.cr[6].lt {
	pc = 0x828D7D4C; continue 'dispatch;
	}
	// 828D7D48: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828D7D4C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D7D50: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D7D54: 419A0014  beq cr6, 0x828d7d68
	if ctx.cr[6].eq {
	pc = 0x828D7D68; continue 'dispatch;
	}
	// 828D7D58: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D7D5C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D7D60: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D7D64: 4800000C  b 0x828d7d70
	pc = 0x828D7D70; continue 'dispatch;
	// 828D7D68: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D7D6C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D7D70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D7D74: 4199FFB8  bgt cr6, 0x828d7d2c
	if ctx.cr[6].gt {
	pc = 0x828D7D2C; continue 'dispatch;
	}
	// 828D7D78: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D7D7C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D7D80: 419A003C  beq cr6, 0x828d7dbc
	if ctx.cr[6].eq {
	pc = 0x828D7DBC; continue 'dispatch;
	}
	// 828D7D84: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7D88: 2F0B0045  cmpwi cr6, r11, 0x45
	ctx.cr[6].compare_i32(ctx.r[11].s32, 69, &mut ctx.xer);
	// 828D7D8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D7D90: 41990008  bgt cr6, 0x828d7d98
	if ctx.cr[6].gt {
	pc = 0x828D7D98; continue 'dispatch;
	}
	// 828D7D94: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D7D98: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D7D9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7DA0: 409A001C  bne cr6, 0x828d7dbc
	if !ctx.cr[6].eq {
	pc = 0x828D7DBC; continue 'dispatch;
	}
	// 828D7DA4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D7DA8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7DAC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D7DB0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D7DB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7DB8: 48000018  b 0x828d7dd0
	pc = 0x828D7DD0; continue 'dispatch;
	// 828D7DBC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D7DC0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7DC4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7DC8: 48000008  b 0x828d7dd0
	pc = 0x828D7DD0; continue 'dispatch;
	// 828D7DCC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828D7DD0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D7DD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D7DD8: 419A0030  beq cr6, 0x828d7e08
	if ctx.cr[6].eq {
	pc = 0x828D7E08; continue 'dispatch;
	}
	// 828D7DDC: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D7DE0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828D7DE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D7DE8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828D7DEC: 4E800421  bctrl
	ctx.lr = 0x828D7DF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7DF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D7DF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D7DF8: 4B918449  bl 0x821f0240
	ctx.lr = 0x828D7DFC;
	sub_821F0240(ctx, base);
	// 828D7DFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D7E00: 4B93CFD9  bl 0x82214dd8
	ctx.lr = 0x828D7E04;
	sub_82214DD8(ctx, base);
	// 828D7E04: 4800002C  b 0x828d7e30
	pc = 0x828D7E30; continue 'dispatch;
	// 828D7E08: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828D7E0C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828D7E10: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	// 828D7E14: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D7E18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D7E1C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D7E20: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D7E24: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D7E28: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D7E2C: 4082FFE8  bne 0x828d7e14
	if !ctx.cr[0].eq {
	pc = 0x828D7E14; continue 'dispatch;
	}
	// 828D7E30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D7E34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D7E38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D7E3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D7E40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D7E44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7E48 size=352
    let mut pc: u32 = 0x828D7E48;
    'dispatch: loop {
        match pc {
            0x828D7E48 => {
    //   block [0x828D7E48..0x828D7FA8)
	// 828D7E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7E4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D7E50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7E54: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828D7E58: 419A0018  beq cr6, 0x828d7e70
	if ctx.cr[6].eq {
	pc = 0x828D7E70; continue 'dispatch;
	}
	// 828D7E5C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D7E60: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D7E64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D7E68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D7E6C: 409A0008  bne cr6, 0x828d7e74
	if !ctx.cr[6].eq {
	pc = 0x828D7E74; continue 'dispatch;
	}
	// 828D7E70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7E74: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D7E78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7E7C: 419A011C  beq cr6, 0x828d7f98
	if ctx.cr[6].eq {
	pc = 0x828D7F98; continue 'dispatch;
	}
	// 828D7E80: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D7E84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7E88: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828D7E8C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D7E90: 419A00E8  beq cr6, 0x828d7f78
	if ctx.cr[6].eq {
	pc = 0x828D7F78; continue 'dispatch;
	}
	// 828D7E94: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D7E98: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D7E9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7EA0: 419A001C  beq cr6, 0x828d7ebc
	if ctx.cr[6].eq {
	pc = 0x828D7EBC; continue 'dispatch;
	}
	// 828D7EA4: 896B0045  lbz r11, 0x45(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(69 as u32) ) } as u64;
	// 828D7EA8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828D7EAC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828D7EB0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7EB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7EB8: 480000C4  b 0x828d7f7c
	pc = 0x828D7F7C; continue 'dispatch;
	// 828D7EBC: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D7EC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7EC4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D7EC8: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D7ECC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828D7ED0: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D7ED4: 40810054  ble 0x828d7f28
	if !ctx.cr[0].gt {
	pc = 0x828D7F28; continue 'dispatch;
	}
	// 828D7ED8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D7EDC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D7EE0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D7EE4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7EE8: 2F070045  cmpwi cr6, r7, 0x45
	ctx.cr[6].compare_i32(ctx.r[7].s32, 69, &mut ctx.xer);
	// 828D7EEC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D7EF0: 41980008  blt cr6, 0x828d7ef8
	if ctx.cr[6].lt {
	pc = 0x828D7EF8; continue 'dispatch;
	}
	// 828D7EF4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828D7EF8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D7EFC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D7F00: 419A0014  beq cr6, 0x828d7f14
	if ctx.cr[6].eq {
	pc = 0x828D7F14; continue 'dispatch;
	}
	// 828D7F04: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D7F08: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D7F0C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D7F10: 4800000C  b 0x828d7f1c
	pc = 0x828D7F1C; continue 'dispatch;
	// 828D7F14: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D7F18: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D7F1C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D7F20: 4199FFB8  bgt cr6, 0x828d7ed8
	if ctx.cr[6].gt {
	pc = 0x828D7ED8; continue 'dispatch;
	}
	// 828D7F24: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D7F28: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D7F2C: 419A003C  beq cr6, 0x828d7f68
	if ctx.cr[6].eq {
	pc = 0x828D7F68; continue 'dispatch;
	}
	// 828D7F30: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7F34: 2F0B0045  cmpwi cr6, r11, 0x45
	ctx.cr[6].compare_i32(ctx.r[11].s32, 69, &mut ctx.xer);
	// 828D7F38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D7F3C: 41990008  bgt cr6, 0x828d7f44
	if ctx.cr[6].gt {
	pc = 0x828D7F44; continue 'dispatch;
	}
	// 828D7F40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7F44: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D7F48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7F4C: 409A001C  bne cr6, 0x828d7f68
	if !ctx.cr[6].eq {
	pc = 0x828D7F68; continue 'dispatch;
	}
	// 828D7F50: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D7F54: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7F58: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D7F5C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D7F60: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7F64: 48000018  b 0x828d7f7c
	pc = 0x828D7F7C; continue 'dispatch;
	// 828D7F68: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D7F6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7F70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7F74: 48000008  b 0x828d7f7c
	pc = 0x828D7F7C; continue 'dispatch;
	// 828D7F78: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D7F7C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D7F80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D7F84: 419A0014  beq cr6, 0x828d7f98
	if ctx.cr[6].eq {
	pc = 0x828D7F98; continue 'dispatch;
	}
	// 828D7F88: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7F8C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D7F90: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828D7F94: 4E800421  bctrl
	ctx.lr = 0x828D7F98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7F98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D7F9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D7FA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D7FA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D7FA8 size=56
    let mut pc: u32 = 0x828D7FA8;
    'dispatch: loop {
        match pc {
            0x828D7FA8 => {
    //   block [0x828D7FA8..0x828D7FE0)
	// 828D7FA8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828D7FAC: 419A0018  beq cr6, 0x828d7fc4
	if ctx.cr[6].eq {
	pc = 0x828D7FC4; continue 'dispatch;
	}
	// 828D7FB0: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D7FB4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D7FB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D7FBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D7FC0: 409A0008  bne cr6, 0x828d7fc8
	if !ctx.cr[6].eq {
	pc = 0x828D7FC8; continue 'dispatch;
	}
	// 828D7FC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7FC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D7FCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7FD0: 419A0010  beq cr6, 0x828d7fe0
	if ctx.cr[6].eq {
		sub_828D7FE0(ctx, base);
		return;
	}
	// 828D7FD4: 8164003C  lwz r11, 0x3c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 828D7FD8: 556357FE  rlwinm r3, r11, 0xa, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x003FFFFFu64;
	// 828D7FDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D7FE0 size=8
    let mut pc: u32 = 0x828D7FE0;
    'dispatch: loop {
        match pc {
            0x828D7FE0 => {
    //   block [0x828D7FE0..0x828D7FE8)
	// 828D7FE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828D7FE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7FE8 size=376
    let mut pc: u32 = 0x828D7FE8;
    'dispatch: loop {
        match pc {
            0x828D7FE8 => {
    //   block [0x828D7FE8..0x828D8160)
	// 828D7FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7FEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D7FF0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7FF4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828D7FF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7FFC: 419A0018  beq cr6, 0x828d8014
	if ctx.cr[6].eq {
	pc = 0x828D8014; continue 'dispatch;
	}
	// 828D8000: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D8004: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828D8008: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D800C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D8010: 409A0008  bne cr6, 0x828d8018
	if !ctx.cr[6].eq {
	pc = 0x828D8018; continue 'dispatch;
	}
	// 828D8014: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D8018: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D801C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D8020: 419A0130  beq cr6, 0x828d8150
	if ctx.cr[6].eq {
	pc = 0x828D8150; continue 'dispatch;
	}
	// 828D8024: 812B003C  lwz r9, 0x3c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828D8028: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D802C: 552857FE  rlwinm r8, r9, 0xa, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x003FFFFFu64;
	// 828D8030: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828D8034: 419A00F8  beq cr6, 0x828d812c
	if ctx.cr[6].eq {
	pc = 0x828D812C; continue 'dispatch;
	}
	// 828D8038: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D803C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D8040: 419A0024  beq cr6, 0x828d8064
	if ctx.cr[6].eq {
	pc = 0x828D8064; continue 'dispatch;
	}
	// 828D8044: 892A00D6  lbz r9, 0xd6(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(214 as u32) ) } as u64;
	// 828D8048: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D804C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828D8050: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828D8054: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8058: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828D805C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D8060: 480000D0  b 0x828d8130
	pc = 0x828D8130; continue 'dispatch;
	// 828D8064: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D8068: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828D806C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D8070: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828D8074: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D8078: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D807C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D8080: 40810054  ble 0x828d80d4
	if !ctx.cr[0].gt {
	pc = 0x828D80D4; continue 'dispatch;
	}
	// 828D8084: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D8088: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D808C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D8090: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8094: 2F0700D6  cmpwi cr6, r7, 0xd6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 214, &mut ctx.xer);
	// 828D8098: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D809C: 41980008  blt cr6, 0x828d80a4
	if ctx.cr[6].lt {
	pc = 0x828D80A4; continue 'dispatch;
	}
	// 828D80A0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828D80A4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D80A8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D80AC: 419A0014  beq cr6, 0x828d80c0
	if ctx.cr[6].eq {
	pc = 0x828D80C0; continue 'dispatch;
	}
	// 828D80B0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D80B4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D80B8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D80BC: 4800000C  b 0x828d80c8
	pc = 0x828D80C8; continue 'dispatch;
	// 828D80C0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D80C4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D80C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D80CC: 4199FFB8  bgt cr6, 0x828d8084
	if ctx.cr[6].gt {
	pc = 0x828D8084; continue 'dispatch;
	}
	// 828D80D0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D80D4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D80D8: 419A0040  beq cr6, 0x828d8118
	if ctx.cr[6].eq {
	pc = 0x828D8118; continue 'dispatch;
	}
	// 828D80DC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D80E0: 2F0B00D6  cmpwi cr6, r11, 0xd6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 214, &mut ctx.xer);
	// 828D80E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D80E8: 41990008  bgt cr6, 0x828d80f0
	if ctx.cr[6].gt {
	pc = 0x828D80F0; continue 'dispatch;
	}
	// 828D80EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D80F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D80F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D80F8: 409A0020  bne cr6, 0x828d8118
	if !ctx.cr[6].eq {
	pc = 0x828D8118; continue 'dispatch;
	}
	// 828D80FC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D8100: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D8104: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D8108: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D810C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828D8110: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D8114: 4800001C  b 0x828d8130
	pc = 0x828D8130; continue 'dispatch;
	// 828D8118: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D811C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8120: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828D8124: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D8128: 48000008  b 0x828d8130
	pc = 0x828D8130; continue 'dispatch;
	// 828D812C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D8130: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D8134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D8138: 419A0018  beq cr6, 0x828d8150
	if ctx.cr[6].eq {
	pc = 0x828D8150; continue 'dispatch;
	}
	// 828D813C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8140: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828D8144: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828D8148: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D814C: 4E800421  bctrl
	ctx.lr = 0x828D8150;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8150: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D8154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D8158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D815C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D8160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D8160 size=352
    let mut pc: u32 = 0x828D8160;
    'dispatch: loop {
        match pc {
            0x828D8160 => {
    //   block [0x828D8160..0x828D82C0)
	// 828D8160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D8164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D8168: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D816C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828D8170: 419A0018  beq cr6, 0x828d8188
	if ctx.cr[6].eq {
	pc = 0x828D8188; continue 'dispatch;
	}
	// 828D8174: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D8178: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D817C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D8180: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D8184: 409A0008  bne cr6, 0x828d818c
	if !ctx.cr[6].eq {
	pc = 0x828D818C; continue 'dispatch;
	}
	// 828D8188: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D818C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D8190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D8194: 419A011C  beq cr6, 0x828d82b0
	if ctx.cr[6].eq {
	pc = 0x828D82B0; continue 'dispatch;
	}
	// 828D8198: 8144003C  lwz r10, 0x3c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 828D819C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D81A0: 554957FE  rlwinm r9, r10, 0xa, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x003FFFFFu64;
	// 828D81A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D81A8: 419A00E8  beq cr6, 0x828d8290
	if ctx.cr[6].eq {
	pc = 0x828D8290; continue 'dispatch;
	}
	// 828D81AC: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D81B0: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D81B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D81B8: 419A001C  beq cr6, 0x828d81d4
	if ctx.cr[6].eq {
	pc = 0x828D81D4; continue 'dispatch;
	}
	// 828D81BC: 896B00D6  lbz r11, 0xd6(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(214 as u32) ) } as u64;
	// 828D81C0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828D81C4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828D81C8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D81CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D81D0: 480000C4  b 0x828d8294
	pc = 0x828D8294; continue 'dispatch;
	// 828D81D4: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D81D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D81DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D81E0: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D81E4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828D81E8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D81EC: 40810054  ble 0x828d8240
	if !ctx.cr[0].gt {
	pc = 0x828D8240; continue 'dispatch;
	}
	// 828D81F0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D81F4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D81F8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D81FC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8200: 2F0700D6  cmpwi cr6, r7, 0xd6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 214, &mut ctx.xer);
	// 828D8204: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D8208: 41980008  blt cr6, 0x828d8210
	if ctx.cr[6].lt {
	pc = 0x828D8210; continue 'dispatch;
	}
	// 828D820C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828D8210: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D8214: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D8218: 419A0014  beq cr6, 0x828d822c
	if ctx.cr[6].eq {
	pc = 0x828D822C; continue 'dispatch;
	}
	// 828D821C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D8220: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D8224: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D8228: 4800000C  b 0x828d8234
	pc = 0x828D8234; continue 'dispatch;
	// 828D822C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D8230: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D8234: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D8238: 4199FFB8  bgt cr6, 0x828d81f0
	if ctx.cr[6].gt {
	pc = 0x828D81F0; continue 'dispatch;
	}
	// 828D823C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D8240: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D8244: 419A003C  beq cr6, 0x828d8280
	if ctx.cr[6].eq {
	pc = 0x828D8280; continue 'dispatch;
	}
	// 828D8248: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D824C: 2F0B00D6  cmpwi cr6, r11, 0xd6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 214, &mut ctx.xer);
	// 828D8250: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D8254: 41990008  bgt cr6, 0x828d825c
	if ctx.cr[6].gt {
	pc = 0x828D825C; continue 'dispatch;
	}
	// 828D8258: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D825C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D8260: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D8264: 409A001C  bne cr6, 0x828d8280
	if !ctx.cr[6].eq {
	pc = 0x828D8280; continue 'dispatch;
	}
	// 828D8268: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D826C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D8270: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D8274: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D8278: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D827C: 48000018  b 0x828d8294
	pc = 0x828D8294; continue 'dispatch;
	// 828D8280: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D8284: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D8288: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D828C: 48000008  b 0x828d8294
	pc = 0x828D8294; continue 'dispatch;
	// 828D8290: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D8294: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D8298: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D829C: 419A0014  beq cr6, 0x828d82b0
	if ctx.cr[6].eq {
	pc = 0x828D82B0; continue 'dispatch;
	}
	// 828D82A0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D82A4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D82A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828D82AC: 4E800421  bctrl
	ctx.lr = 0x828D82B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D82B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D82B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D82B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D82BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D82C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D82C0 size=172
    let mut pc: u32 = 0x828D82C0;
    'dispatch: loop {
        match pc {
            0x828D82C0 => {
    //   block [0x828D82C0..0x828D836C)
	// 828D82C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D82C4: 483D1145  bl 0x82ca9408
	ctx.lr = 0x828D82C8;
	sub_82CA93D0(ctx, base);
	// 828D82C8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D82CC: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 828D82D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D82D4: 4B94FE25  bl 0x822280f8
	ctx.lr = 0x828D82D8;
	sub_822280F8(ctx, base);
	// 828D82D8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828D82DC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828D82E0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828D82E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D82E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D82EC: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 828D82F0: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D82F4: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D82F8: 4B94FE01  bl 0x822280f8
	ctx.lr = 0x828D82FC;
	sub_822280F8(ctx, base);
	// 828D82FC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8300: 4B94F261  bl 0x82227560
	ctx.lr = 0x828D8304;
	sub_82227560(ctx, base);
	// 828D8304: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D8308: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D830C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 828D8310: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D8314: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D8318: 4BA29CD1  bl 0x82301fe8
	ctx.lr = 0x828D831C;
	sub_82301FE8(ctx, base);
	// 828D831C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D8320: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828D8324: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D8328: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 828D832C: 4E800421  bctrl
	ctx.lr = 0x828D8330;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8330: 7C6807B4  extsw r8, r3
	ctx.r[8].s64 = ctx.r[3].s32 as i64;
	// 828D8334: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D8338: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 828D833C: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 828D8340: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828D8344: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828D8348: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828D834C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828D8350: D1870000  stfs f12, 0(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828D8354: 90C70004  stw r6, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 828D8358: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D835C: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 828D8360: 90BF0008  stw r5, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 828D8364: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828D8368: 483D10F0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D8370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D8370 size=112
    let mut pc: u32 = 0x828D8370;
    'dispatch: loop {
        match pc {
            0x828D8370 => {
    //   block [0x828D8370..0x828D83E0)
	// 828D8370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D8374: 483D1099  bl 0x82ca940c
	ctx.lr = 0x828D8378;
	sub_82CA93D0(ctx, base);
	// 828D8378: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D837C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 828D8380: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D8384: 4B94FD75  bl 0x822280f8
	ctx.lr = 0x828D8388;
	sub_822280F8(ctx, base);
	// 828D8388: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D838C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D8390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8394: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8398: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D839C: 4B94FD5D  bl 0x822280f8
	ctx.lr = 0x828D83A0;
	sub_822280F8(ctx, base);
	// 828D83A0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D83A4: 4B94F1BD  bl 0x82227560
	ctx.lr = 0x828D83A8;
	sub_82227560(ctx, base);
	// 828D83A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D83AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D83B0: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 828D83B4: 4E800421  bctrl
	ctx.lr = 0x828D83B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D83B8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D83BC: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 828D83C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828D83C4: D02A0000  stfs f1, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828D83C8: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D83CC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D83D0: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 828D83D4: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828D83D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D83DC: 483D1080  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D83E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D83E0 size=60
    let mut pc: u32 = 0x828D83E0;
    'dispatch: loop {
        match pc {
            0x828D83E0 => {
    //   block [0x828D83E0..0x828D841C)
	// 828D83E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D83E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D83E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D83EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D83F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828D83F4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D83F8: 388B9984  addi r4, r11, -0x667c
	ctx.r[4].s64 = ctx.r[11].s64 + -26236;
	// 828D83FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D8400: 4B954AD1  bl 0x8222ced0
	ctx.lr = 0x828D8404;
	sub_8222CED0(ctx, base);
	// 828D8404: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8408: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D840C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D8410: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D8414: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D8418: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D8420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D8420 size=96
    let mut pc: u32 = 0x828D8420;
    'dispatch: loop {
        match pc {
            0x828D8420 => {
    //   block [0x828D8420..0x828D8480)
	// 828D8420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D8424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D8428: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D842C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D8430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D8434: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D8438: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D843C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828D8440: 480004E9  bl 0x828d8928
	ctx.lr = 0x828D8444;
	sub_828D8928(ctx, base);
	// 828D8444: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828D8448: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828D844C: 392B2850  addi r9, r11, 0x2850
	ctx.r[9].s64 = ctx.r[11].s64 + 10320;
	// 828D8450: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D8454: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D8458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D845C: 419A000C  beq cr6, 0x828d8468
	if ctx.cr[6].eq {
	pc = 0x828D8468; continue 'dispatch;
	}
	// 828D8460: 4B9438D9  bl 0x8221bd38
	ctx.lr = 0x828D8464;
	sub_8221BD38(ctx, base);
	// 828D8464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8468: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D846C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D8470: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D8474: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D8478: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D847C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D8480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D8480 size=212
    let mut pc: u32 = 0x828D8480;
    'dispatch: loop {
        match pc {
            0x828D8480 => {
    //   block [0x828D8480..0x828D8554)
	// 828D8480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D8484: 483D0F89  bl 0x82ca940c
	ctx.lr = 0x828D8488;
	sub_82CA93D0(ctx, base);
	// 828D8488: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D848C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D8490: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D8494: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828D8498: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D849C: 419A0018  beq cr6, 0x828d84b4
	if ctx.cr[6].eq {
	pc = 0x828D84B4; continue 'dispatch;
	}
	// 828D84A0: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D84A4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D84A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D84AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D84B0: 409A0008  bne cr6, 0x828d84b8
	if !ctx.cr[6].eq {
	pc = 0x828D84B8; continue 'dispatch;
	}
	// 828D84B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D84B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D84BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D84C0: 419A008C  beq cr6, 0x828d854c
	if ctx.cr[6].eq {
	pc = 0x828D854C; continue 'dispatch;
	}
	// 828D84C4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D84C8: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828D84CC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D84D0: 812A005C  lwz r9, 0x5c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D84D4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828D84D8: 4E800421  bctrl
	ctx.lr = 0x828D84DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D84DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D84E0: 419A0018  beq cr6, 0x828d84f8
	if ctx.cr[6].eq {
	pc = 0x828D84F8; continue 'dispatch;
	}
	// 828D84E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D84E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D84EC: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D84F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828D84F4: 4E800421  bctrl
	ctx.lr = 0x828D84F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D84F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D84FC: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828D8500: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D8504: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 828D8508: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828D850C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D8510: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 828D8514: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828D8518: 4B93C381  bl 0x82214898
	ctx.lr = 0x828D851C;
	sub_82214898(ctx, base);
	// 828D851C: 811E0010  lwz r8, 0x10(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D8520: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 828D8524: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828D8528: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828D852C: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 828D8530: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D8534: 480004AD  bl 0x828d89e0
	ctx.lr = 0x828D8538;
	sub_828D89E0(ctx, base);
	// 828D8538: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 828D853C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828D8540: 38C70B7C  addi r6, r7, 0xb7c
	ctx.r[6].s64 = ctx.r[7].s64 + 2940;
	// 828D8544: 90C1005C  stw r6, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[6].u32 ) };
	// 828D8548: 4B8BB8F1  bl 0x82193e38
	ctx.lr = 0x828D854C;
	sub_82193E38(ctx, base);
	// 828D854C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828D8550: 483D0F0C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D8558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D8558 size=312
    let mut pc: u32 = 0x828D8558;
    'dispatch: loop {
        match pc {
            0x828D8558 => {
    //   block [0x828D8558..0x828D8690)
	// 828D8558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D855C: 483D0EA5  bl 0x82ca9400
	ctx.lr = 0x828D8560;
	sub_82CA93D0(ctx, base);
	// 828D8560: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D8564: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D8568: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828D856C: 3BBB000C  addi r29, r27, 0xc
	ctx.r[29].s64 = ctx.r[27].s64 + 12;
	// 828D8570: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828D8574: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 828D8578: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D857C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828D8580: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8584: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828D8588: 4800000C  b 0x828d8594
	pc = 0x828D8594; continue 'dispatch;
	// 828D858C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D8590: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D8594: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8598: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D859C: 419A000C  beq cr6, 0x828d85a8
	if ctx.cr[6].eq {
	pc = 0x828D85A8; continue 'dispatch;
	}
	// 828D85A0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828D85A4: 419A0008  beq cr6, 0x828d85ac
	if ctx.cr[6].eq {
	pc = 0x828D85AC; continue 'dispatch;
	}
	// 828D85A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D85AC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D85B0: 419A00D8  beq cr6, 0x828d8688
	if ctx.cr[6].eq {
	pc = 0x828D8688; continue 'dispatch;
	}
	// 828D85B4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D85B8: 409A0008  bne cr6, 0x828d85c0
	if !ctx.cr[6].eq {
	pc = 0x828D85C0; continue 'dispatch;
	}
	// 828D85BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D85C0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D85C4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D85C8: 409A0008  bne cr6, 0x828d85d0
	if !ctx.cr[6].eq {
	pc = 0x828D85D0; continue 'dispatch;
	}
	// 828D85CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D85D0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D85D4: 7F0AD000  cmpw cr6, r10, r26
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[26].s32, &mut ctx.xer);
	// 828D85D8: 409A0094  bne cr6, 0x828d866c
	if !ctx.cr[6].eq {
	pc = 0x828D866C; continue 'dispatch;
	}
	// 828D85DC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D85E0: 409A0008  bne cr6, 0x828d85e8
	if !ctx.cr[6].eq {
	pc = 0x828D85E8; continue 'dispatch;
	}
	// 828D85E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D85E8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D85EC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828D85F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D85F4: 419A001C  beq cr6, 0x828d8610
	if ctx.cr[6].eq {
	pc = 0x828D8610; continue 'dispatch;
	}
	// 828D85F8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D85FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D8600: 419A000C  beq cr6, 0x828d860c
	if ctx.cr[6].eq {
	pc = 0x828D860C; continue 'dispatch;
	}
	// 828D8604: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828D8608: 4800000C  b 0x828d8614
	pc = 0x828D8614; continue 'dispatch;
	// 828D860C: 4B8BB82D  bl 0x82193e38
	ctx.lr = 0x828D8610;
	sub_82193E38(ctx, base);
	// 828D8610: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D8614: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828D8618: 409A0054  bne cr6, 0x828d866c
	if !ctx.cr[6].eq {
	pc = 0x828D866C; continue 'dispatch;
	}
	// 828D861C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D8620: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D8624: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D8628: 4BB75029  bl 0x8244d650
	ctx.lr = 0x828D862C;
	sub_8244D650(ctx, base);
	// 828D862C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8630: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 828D8634: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828D8638: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 828D863C: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8640: 8109005C  lwz r8, 0x5c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D8644: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828D8648: 4E800421  bctrl
	ctx.lr = 0x828D864C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D864C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D8650: 419AFF3C  beq cr6, 0x828d858c
	if ctx.cr[6].eq {
	pc = 0x828D858C; continue 'dispatch;
	}
	// 828D8654: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8658: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828D865C: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D8660: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828D8664: 4E800421  bctrl
	ctx.lr = 0x828D8668;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8668: 4BFFFF24  b 0x828d858c
	pc = 0x828D858C; continue 'dispatch;
	// 828D866C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8670: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D8674: 409A0008  bne cr6, 0x828d867c
	if !ctx.cr[6].eq {
	pc = 0x828D867C; continue 'dispatch;
	}
	// 828D8678: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D867C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8680: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828D8684: 4BFFFF10  b 0x828d8594
	pc = 0x828D8594; continue 'dispatch;
	// 828D8688: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828D868C: 483D0DC4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D8690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D8690 size=340
    let mut pc: u32 = 0x828D8690;
    'dispatch: loop {
        match pc {
            0x828D8690 => {
    //   block [0x828D8690..0x828D87E4)
	// 828D8690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D8694: 483D0D6D  bl 0x82ca9400
	ctx.lr = 0x828D8698;
	sub_82CA93D0(ctx, base);
	// 828D8698: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D869C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D86A0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828D86A4: 3B9B000C  addi r28, r27, 0xc
	ctx.r[28].s64 = ctx.r[27].s64 + 12;
	// 828D86A8: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828D86AC: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D86B0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828D86B4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D86B8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828D86BC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D86C0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D86C4: 419A000C  beq cr6, 0x828d86d0
	if ctx.cr[6].eq {
	pc = 0x828D86D0; continue 'dispatch;
	}
	// 828D86C8: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828D86CC: 419A0008  beq cr6, 0x828d86d4
	if ctx.cr[6].eq {
	pc = 0x828D86D4; continue 'dispatch;
	}
	// 828D86D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D86D4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D86D8: 419A0104  beq cr6, 0x828d87dc
	if ctx.cr[6].eq {
	pc = 0x828D87DC; continue 'dispatch;
	}
	// 828D86DC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D86E0: 409A0008  bne cr6, 0x828d86e8
	if !ctx.cr[6].eq {
	pc = 0x828D86E8; continue 'dispatch;
	}
	// 828D86E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D86E8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D86EC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D86F0: 409A0008  bne cr6, 0x828d86f8
	if !ctx.cr[6].eq {
	pc = 0x828D86F8; continue 'dispatch;
	}
	// 828D86F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D86F8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D86FC: 7F0AD000  cmpw cr6, r10, r26
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[26].s32, &mut ctx.xer);
	// 828D8700: 409A00C8  bne cr6, 0x828d87c8
	if !ctx.cr[6].eq {
	pc = 0x828D87C8; continue 'dispatch;
	}
	// 828D8704: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8708: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828D870C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8710: 812A005C  lwz r9, 0x5c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D8714: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828D8718: 4E800421  bctrl
	ctx.lr = 0x828D871C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D871C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D8720: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D8724: 419A0074  beq cr6, 0x828d8798
	if ctx.cr[6].eq {
	pc = 0x828D8798; continue 'dispatch;
	}
	// 828D8728: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D872C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D8730: 409A0008  bne cr6, 0x828d8738
	if !ctx.cr[6].eq {
	pc = 0x828D8738; continue 'dispatch;
	}
	// 828D8734: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D8738: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D873C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828D8740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D8744: 419A007C  beq cr6, 0x828d87c0
	if ctx.cr[6].eq {
	pc = 0x828D87C0; continue 'dispatch;
	}
	// 828D8748: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D874C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D8750: 419A006C  beq cr6, 0x828d87bc
	if ctx.cr[6].eq {
	pc = 0x828D87BC; continue 'dispatch;
	}
	// 828D8754: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828D8758: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828D875C: 419A0018  beq cr6, 0x828d8774
	if ctx.cr[6].eq {
	pc = 0x828D8774; continue 'dispatch;
	}
	// 828D8760: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D8764: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D8768: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D876C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D8770: 409A0008  bne cr6, 0x828d8778
	if !ctx.cr[6].eq {
	pc = 0x828D8778; continue 'dispatch;
	}
	// 828D8774: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D8778: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D877C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D8780: 419A0018  beq cr6, 0x828d8798
	if ctx.cr[6].eq {
	pc = 0x828D8798; continue 'dispatch;
	}
	// 828D8784: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8788: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D878C: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D8790: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828D8794: 4E800421  bctrl
	ctx.lr = 0x828D8798;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8798: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828D879C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D87A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D87A4: 4BB74EAD  bl 0x8244d650
	ctx.lr = 0x828D87A8;
	sub_8244D650(ctx, base);
	// 828D87A8: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 828D87AC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D87B0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D87B4: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D87B8: 4BFFFF04  b 0x828d86bc
	pc = 0x828D86BC; continue 'dispatch;
	// 828D87BC: 4B8BB67D  bl 0x82193e38
	ctx.lr = 0x828D87C0;
	sub_82193E38(ctx, base);
	// 828D87C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D87C4: 4BFFFFB0  b 0x828d8774
	pc = 0x828D8774; continue 'dispatch;
	// 828D87C8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D87CC: 409A0008  bne cr6, 0x828d87d4
	if !ctx.cr[6].eq {
	pc = 0x828D87D4; continue 'dispatch;
	}
	// 828D87D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D87D4: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D87D8: 4BFFFEE0  b 0x828d86b8
	pc = 0x828D86B8; continue 'dispatch;
	// 828D87DC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828D87E0: 483D0C70  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D87E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D87E8 size=320
    let mut pc: u32 = 0x828D87E8;
    'dispatch: loop {
        match pc {
            0x828D87E8 => {
    //   block [0x828D87E8..0x828D8928)
	// 828D87E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D87EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D87F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D87F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D87F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D87FC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D8800: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D8804: 3BCB39E8  addi r30, r11, 0x39e8
	ctx.r[30].s64 = ctx.r[11].s64 + 14824;
	// 828D8808: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D880C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8810: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D8814: 4B9546BD  bl 0x8222ced0
	ctx.lr = 0x828D8818;
	sub_8222CED0(ctx, base);
	// 828D8818: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D881C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D8820: 480002A1  bl 0x828d8ac0
	ctx.lr = 0x828D8824;
	sub_828D8AC0(ctx, base);
	// 828D8824: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8828: 4B93C5B1  bl 0x82214dd8
	ctx.lr = 0x828D882C;
	sub_82214DD8(ctx, base);
	// 828D882C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828D8830: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D8834: 388A3A00  addi r4, r10, 0x3a00
	ctx.r[4].s64 = ctx.r[10].s64 + 14848;
	// 828D8838: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D883C: 4B954695  bl 0x8222ced0
	ctx.lr = 0x828D8840;
	sub_8222CED0(ctx, base);
	// 828D8840: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D8844: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D8848: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D884C: 4B954685  bl 0x8222ced0
	ctx.lr = 0x828D8850;
	sub_8222CED0(ctx, base);
	// 828D8850: 3D20828E  lis r9, -0x7d72
	ctx.r[9].s64 = -2104623104;
	// 828D8854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8858: 38C98480  addi r6, r9, -0x7b80
	ctx.r[6].s64 = ctx.r[9].s64 + -31616;
	// 828D885C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828D8860: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D8864: 480004A5  bl 0x828d8d08
	ctx.lr = 0x828D8868;
	sub_828D8D08(ctx, base);
	// 828D8868: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D886C: 4B93C56D  bl 0x82214dd8
	ctx.lr = 0x828D8870;
	sub_82214DD8(ctx, base);
	// 828D8870: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D8874: 4B93C565  bl 0x82214dd8
	ctx.lr = 0x828D8878;
	sub_82214DD8(ctx, base);
	// 828D8878: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828D887C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D8880: 38883A10  addi r4, r8, 0x3a10
	ctx.r[4].s64 = ctx.r[8].s64 + 14864;
	// 828D8884: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8888: 4B954649  bl 0x8222ced0
	ctx.lr = 0x828D888C;
	sub_8222CED0(ctx, base);
	// 828D888C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D8890: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D8894: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D8898: 4B954639  bl 0x8222ced0
	ctx.lr = 0x828D889C;
	sub_8222CED0(ctx, base);
	// 828D889C: 3CE0828E  lis r7, -0x7d72
	ctx.r[7].s64 = -2104623104;
	// 828D88A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D88A4: 38C78558  addi r6, r7, -0x7aa8
	ctx.r[6].s64 = ctx.r[7].s64 + -31400;
	// 828D88A8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D88AC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828D88B0: 48000459  bl 0x828d8d08
	ctx.lr = 0x828D88B4;
	sub_828D8D08(ctx, base);
	// 828D88B4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D88B8: 4B93C521  bl 0x82214dd8
	ctx.lr = 0x828D88BC;
	sub_82214DD8(ctx, base);
	// 828D88BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D88C0: 4B93C519  bl 0x82214dd8
	ctx.lr = 0x828D88C4;
	sub_82214DD8(ctx, base);
	// 828D88C4: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828D88C8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D88CC: 38863A24  addi r4, r6, 0x3a24
	ctx.r[4].s64 = ctx.r[6].s64 + 14884;
	// 828D88D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D88D4: 4B9545FD  bl 0x8222ced0
	ctx.lr = 0x828D88D8;
	sub_8222CED0(ctx, base);
	// 828D88D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D88DC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D88E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D88E4: 4B9545ED  bl 0x8222ced0
	ctx.lr = 0x828D88E8;
	sub_8222CED0(ctx, base);
	// 828D88E8: 3C80828E  lis r4, -0x7d72
	ctx.r[4].s64 = -2104623104;
	// 828D88EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D88F0: 38C48690  addi r6, r4, -0x7970
	ctx.r[6].s64 = ctx.r[4].s64 + -31088;
	// 828D88F4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828D88F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D88FC: 4800060D  bl 0x828d8f08
	ctx.lr = 0x828D8900;
	sub_828D8F08(ctx, base);
	// 828D8900: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D8904: 4B93C4D5  bl 0x82214dd8
	ctx.lr = 0x828D8908;
	sub_82214DD8(ctx, base);
	// 828D8908: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D890C: 4B93C4CD  bl 0x82214dd8
	ctx.lr = 0x828D8910;
	sub_82214DD8(ctx, base);
	// 828D8910: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D8914: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D8918: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D891C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D8920: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D8924: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D8928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D8928 size=184
    let mut pc: u32 = 0x828D8928;
    'dispatch: loop {
        match pc {
            0x828D8928 => {
    //   block [0x828D8928..0x828D89E0)
	// 828D8928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D892C: 483D0AD5  bl 0x82ca9400
	ctx.lr = 0x828D8930;
	sub_82CA93D0(ctx, base);
	// 828D8930: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D8934: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D8938: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828D893C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8940: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8944: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D8948: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D894C: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D8950: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8954: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828D8958: 937C0008  stw r27, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 828D895C: 419A0070  beq cr6, 0x828d89cc
	if ctx.cr[6].eq {
	pc = 0x828D89CC; continue 'dispatch;
	}
	// 828D8960: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D8964: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	// 828D8968: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D896C: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 828D8970: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8974: 935F000C  stw r26, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 828D8978: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D897C: 419A0034  beq cr6, 0x828d89b0
	if ctx.cr[6].eq {
	pc = 0x828D89B0; continue 'dispatch;
	}
	// 828D8980: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8984: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828D8988: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D898C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8990: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8994: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D8998: 409A0014  bne cr6, 0x828d89ac
	if !ctx.cr[6].eq {
	pc = 0x828D89AC; continue 'dispatch;
	}
	// 828D899C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D89A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D89A4: 409A0008  bne cr6, 0x828d89ac
	if !ctx.cr[6].eq {
	pc = 0x828D89AC; continue 'dispatch;
	}
	// 828D89A8: 4B943391  bl 0x8221bd38
	ctx.lr = 0x828D89AC;
	sub_8221BD38(ctx, base);
	// 828D89AC: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828D89B0: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828D89B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D89B8: 4B943381  bl 0x8221bd38
	ctx.lr = 0x828D89BC;
	sub_8221BD38(ctx, base);
	// 828D89BC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D89C0: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 828D89C4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D89C8: 409AFFA0  bne cr6, 0x828d8968
	if !ctx.cr[6].eq {
	pc = 0x828D8968; continue 'dispatch;
	}
	// 828D89CC: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D89D0: 4B943369  bl 0x8221bd38
	ctx.lr = 0x828D89D4;
	sub_8221BD38(ctx, base);
	// 828D89D4: 937C0004  stw r27, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828D89D8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828D89DC: 483D0A74  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D89E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D89E0 size=224
    let mut pc: u32 = 0x828D89E0;
    'dispatch: loop {
        match pc {
            0x828D89E0 => {
    //   block [0x828D89E0..0x828D8AC0)
	// 828D89E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D89E4: 483D0A1D  bl 0x82ca9400
	ctx.lr = 0x828D89E8;
	sub_82CA93D0(ctx, base);
	// 828D89E8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D89EC: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 828D89F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D89F4: 838100EC  lwz r28, 0xec(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 828D89F8: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 828D89FC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828D8A00: 837C0004  lwz r27, 4(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8A04: 4B946855  bl 0x8221f258
	ctx.lr = 0x828D8A08;
	sub_8221F258(ctx, base);
	// 828D8A08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D8A0C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D8A10: 419A0008  beq cr6, 0x828d8a18
	if ctx.cr[6].eq {
	pc = 0x828D8A18; continue 'dispatch;
	}
	// 828D8A14: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828D8A18: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 828D8A1C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D8A20: 419A0008  beq cr6, 0x828d8a28
	if ctx.cr[6].eq {
	pc = 0x828D8A28; continue 'dispatch;
	}
	// 828D8A24: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828D8A28: 357F0008  addic. r11, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D8A2C: 41820018  beq 0x828d8a44
	if ctx.cr[0].eq {
	pc = 0x828D8A44; continue 'dispatch;
	}
	// 828D8A30: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8A34: 389A0004  addi r4, r26, 4
	ctx.r[4].s64 = ctx.r[26].s64 + 4;
	// 828D8A38: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 828D8A3C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D8A40: 4B8BE331  bl 0x82196d70
	ctx.lr = 0x828D8A44;
	sub_82196D70(ctx, base);
	// 828D8A44: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 828D8A48: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D8A4C: 61695555  ori r9, r11, 0x5555
	ctx.r[9].u64 = ctx.r[11].u64 | 21845;
	// 828D8A50: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 828D8A54: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 828D8A58: 40980048  bge cr6, 0x828d8aa0
	if !ctx.cr[6].lt {
	pc = 0x828D8AA0; continue 'dispatch;
	}
	// 828D8A5C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828D8A60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8A64: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 828D8A68: 4BA194D9  bl 0x822f1f40
	ctx.lr = 0x828D8A6C;
	sub_822F1F40(ctx, base);
	// 828D8A6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D8A70: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828D8A74: 4BA1933D  bl 0x822f1db0
	ctx.lr = 0x828D8A78;
	sub_822F1DB0(ctx, base);
	// 828D8A78: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828D8A7C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828D8A80: 3B6A1720  addi r27, r10, 0x1720
	ctx.r[27].s64 = ctx.r[10].s64 + 5920;
	// 828D8A84: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 828D8A88: 4BA19399  bl 0x822f1e20
	ctx.lr = 0x828D8A8C;
	sub_822F1E20(ctx, base);
	// 828D8A8C: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 828D8A90: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828D8A94: 4BDA2D4D  bl 0x8267b7e0
	ctx.lr = 0x828D8A98;
	sub_8267B7E0(ctx, base);
	// 828D8A98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8A9C: 4B898D75  bl 0x82171810
	ctx.lr = 0x828D8AA0;
	sub_82171810(ctx, base);
	// 828D8AA0: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D8AA4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828D8AA8: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828D8AAC: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828D8AB0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8AB4: 93EA0000  stw r31, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D8AB8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828D8ABC: 483D0994  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D8AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D8AC0 size=584
    let mut pc: u32 = 0x828D8AC0;
    'dispatch: loop {
        match pc {
            0x828D8AC0 => {
    //   block [0x828D8AC0..0x828D8D08)
	// 828D8AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D8AC4: 483D093D  bl 0x82ca9400
	ctx.lr = 0x828D8AC8;
	sub_82CA93D0(ctx, base);
	// 828D8AC8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D8ACC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8AD0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D8AD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D8AD8: 409A0010  bne cr6, 0x828d8ae8
	if !ctx.cr[6].eq {
	pc = 0x828D8AE8; continue 'dispatch;
	}
	// 828D8ADC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D8AE0: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828D8AE4: 48000008  b 0x828d8aec
	pc = 0x828D8AEC; continue 'dispatch;
	// 828D8AE8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8AEC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8AF0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D8AF4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8AF8: 4BAF5AC9  bl 0x823ce5c0
	ctx.lr = 0x828D8AFC;
	sub_823CE5C0(ctx, base);
	// 828D8AFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D8B00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8B04: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D8B08: 4BAF56F9  bl 0x823ce200
	ctx.lr = 0x828D8B0C;
	sub_823CE200(ctx, base);
	// 828D8B0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D8B10: 4B8DF009  bl 0x821b7b18
	ctx.lr = 0x828D8B14;
	sub_821B7B18(ctx, base);
	// 828D8B14: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828D8B18: 4B946741  bl 0x8221f258
	ctx.lr = 0x828D8B1C;
	sub_8221F258(ctx, base);
	// 828D8B1C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D8B20: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D8B24: 419A0040  beq cr6, 0x828d8b64
	if ctx.cr[6].eq {
	pc = 0x828D8B64; continue 'dispatch;
	}
	// 828D8B28: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828D8B2C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D8B30: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828D8B34: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D8B38: 4B946721  bl 0x8221f258
	ctx.lr = 0x828D8B3C;
	sub_8221F258(ctx, base);
	// 828D8B3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D8B40: 419A0028  beq cr6, 0x828d8b68
	if ctx.cr[6].eq {
	pc = 0x828D8B68; continue 'dispatch;
	}
	// 828D8B44: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828D8B48: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828D8B4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D8B50: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828D8B54: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D8B58: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D8B5C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D8B60: 4800000C  b 0x828d8b6c
	pc = 0x828D8B6C; continue 'dispatch;
	// 828D8B64: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D8B68: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828D8B6C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D8B70: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D8B74: 419A00FC  beq cr6, 0x828d8c70
	if ctx.cr[6].eq {
	pc = 0x828D8C70; continue 'dispatch;
	}
	// 828D8B78: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8B7C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828D8B80: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8B84: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D8B88: 4B950581  bl 0x82229108
	ctx.lr = 0x828D8B8C;
	sub_82229108(ctx, base);
	// 828D8B8C: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828D8B90: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828D8B94: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D8B98: 3BCB9110  addi r30, r11, -0x6ef0
	ctx.r[30].s64 = ctx.r[11].s64 + -28400;
	// 828D8B9C: 4B94ECE5  bl 0x82227880
	ctx.lr = 0x828D8BA0;
	sub_82227880(ctx, base);
	// 828D8BA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D8BA4: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828D8BA8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D8BAC: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828D8BB0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D8BB4: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828D8BB8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828D8BBC: 4B8C1EC5  bl 0x8219aa80
	ctx.lr = 0x828D8BC0;
	sub_8219AA80(ctx, base);
	// 828D8BC0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828D8BC4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828D8BC8: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828D8BCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8BD0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D8BD4: 4BAF584D  bl 0x823ce420
	ctx.lr = 0x828D8BD8;
	sub_823CE420(ctx, base);
	// 828D8BD8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D8BDC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828D8BE0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D8BE4: 4814BAE5  bl 0x82a246c8
	ctx.lr = 0x828D8BE8;
	sub_82A246C8(ctx, base);
	// 828D8BE8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D8BEC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828D8BF0: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828D8BF4: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828D8BF8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8BFC: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8C00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D8C04: 4B950505  bl 0x82229108
	ctx.lr = 0x828D8C08;
	sub_82229108(ctx, base);
	// 828D8C08: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 828D8C0C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828D8C10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D8C14: 3BEB6C88  addi r31, r11, 0x6c88
	ctx.r[31].s64 = ctx.r[11].s64 + 27784;
	// 828D8C18: 4B94EC69  bl 0x82227880
	ctx.lr = 0x828D8C1C;
	sub_82227880(ctx, base);
	// 828D8C1C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828D8C20: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828D8C24: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D8C28: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828D8C2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D8C30: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828D8C34: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828D8C38: 4B8C1E49  bl 0x8219aa80
	ctx.lr = 0x828D8C3C;
	sub_8219AA80(ctx, base);
	// 828D8C3C: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828D8C40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D8C44: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828D8C48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8C4C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D8C50: 4BAF57D1  bl 0x823ce420
	ctx.lr = 0x828D8C54;
	sub_823CE420(ctx, base);
	// 828D8C54: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D8C58: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828D8C5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D8C60: 4814BA69  bl 0x82a246c8
	ctx.lr = 0x828D8C64;
	sub_82A246C8(ctx, base);
	// 828D8C64: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D8C68: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828D8C6C: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828D8C70: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828D8C74: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828D8C78: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828D8C7C: 419A0020  beq cr6, 0x828d8c9c
	if ctx.cr[6].eq {
	pc = 0x828D8C9C; continue 'dispatch;
	}
	// 828D8C80: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D8C84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D8C88: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D8C8C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828D8C90: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D8C94: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D8C98: 4082FFE8  bne 0x828d8c80
	if !ctx.cr[0].eq {
	pc = 0x828D8C80; continue 'dispatch;
	}
	// 828D8C9C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8CA0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D8CA4: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828D8CA8: 4BA1CCA1  bl 0x822f5948
	ctx.lr = 0x828D8CAC;
	sub_822F5948(ctx, base);
	// 828D8CAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D8CB0: 4B8DEE69  bl 0x821b7b18
	ctx.lr = 0x828D8CB4;
	sub_821B7B18(ctx, base);
	// 828D8CB4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828D8CB8: 419A0040  beq cr6, 0x828d8cf8
	if ctx.cr[6].eq {
	pc = 0x828D8CF8; continue 'dispatch;
	}
	// 828D8CBC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D8CC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D8CC4: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D8CC8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D8CCC: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D8CD0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D8CD4: 4082FFE8  bne 0x828d8cbc
	if !ctx.cr[0].eq {
	pc = 0x828D8CBC; continue 'dispatch;
	}
	// 828D8CD8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D8CDC: 409A001C  bne cr6, 0x828d8cf8
	if !ctx.cr[6].eq {
	pc = 0x828D8CF8; continue 'dispatch;
	}
	// 828D8CE0: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D8CE4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8CE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D8CEC: 4E800421  bctrl
	ctx.lr = 0x828D8CF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8CF0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D8CF4: 4B943045  bl 0x8221bd38
	ctx.lr = 0x828D8CF8;
	sub_8221BD38(ctx, base);
	// 828D8CF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8CFC: 4B8DEE1D  bl 0x821b7b18
	ctx.lr = 0x828D8D00;
	sub_821B7B18(ctx, base);
	// 828D8D00: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828D8D04: 483D074C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D8D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D8D08 size=512
    let mut pc: u32 = 0x828D8D08;
    'dispatch: loop {
        match pc {
            0x828D8D08 => {
    //   block [0x828D8D08..0x828D8F08)
	// 828D8D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D8D0C: 483D06F1  bl 0x82ca93fc
	ctx.lr = 0x828D8D10;
	sub_82CA93D0(ctx, base);
	// 828D8D10: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D8D14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D8D18: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828D8D1C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828D8D20: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828D8D24: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828D8D28: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8D2C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828D8D30: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D8D34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D8D38: 419A0008  beq cr6, 0x828d8d40
	if ctx.cr[6].eq {
	pc = 0x828D8D40; continue 'dispatch;
	}
	// 828D8D3C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8D40: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8D44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D8D48: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8D4C: 4BAF5875  bl 0x823ce5c0
	ctx.lr = 0x828D8D50;
	sub_823CE5C0(ctx, base);
	// 828D8D50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D8D54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D8D58: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D8D5C: 4BAF53B5  bl 0x823ce110
	ctx.lr = 0x828D8D60;
	sub_823CE110(ctx, base);
	// 828D8D60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D8D64: 4B8DEDB5  bl 0x821b7b18
	ctx.lr = 0x828D8D68;
	sub_821B7B18(ctx, base);
	// 828D8D68: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D8D6C: 4B9464ED  bl 0x8221f258
	ctx.lr = 0x828D8D70;
	sub_8221F258(ctx, base);
	// 828D8D70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D8D74: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D8D78: 419A005C  beq cr6, 0x828d8dd4
	if ctx.cr[6].eq {
	pc = 0x828D8DD4; continue 'dispatch;
	}
	// 828D8D7C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828D8D80: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828D8D84: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D8D88: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828D8D8C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D8D90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D8D94: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D8D98: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828D8D9C: 4B9174A5  bl 0x821f0240
	ctx.lr = 0x828D8DA0;
	sub_821F0240(ctx, base);
	// 828D8DA0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D8DA4: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828D8DA8: 4B9464B1  bl 0x8221f258
	ctx.lr = 0x828D8DAC;
	sub_8221F258(ctx, base);
	// 828D8DAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D8DB0: 419A0028  beq cr6, 0x828d8dd8
	if ctx.cr[6].eq {
	pc = 0x828D8DD8; continue 'dispatch;
	}
	// 828D8DB4: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828D8DB8: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828D8DBC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D8DC0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828D8DC4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D8DC8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D8DCC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D8DD0: 4800000C  b 0x828d8ddc
	pc = 0x828D8DDC; continue 'dispatch;
	// 828D8DD4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828D8DD8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D8DDC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8DE0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D8DE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D8DE8: 419A0008  beq cr6, 0x828d8df0
	if ctx.cr[6].eq {
	pc = 0x828D8DF0; continue 'dispatch;
	}
	// 828D8DEC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8DF0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D8DF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D8DF8: 419A0078  beq cr6, 0x828d8e70
	if ctx.cr[6].eq {
	pc = 0x828D8E70; continue 'dispatch;
	}
	// 828D8DFC: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8E00: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828D8E04: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8E08: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D8E0C: 4B9502FD  bl 0x82229108
	ctx.lr = 0x828D8E10;
	sub_82229108(ctx, base);
	// 828D8E10: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828D8E14: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828D8E18: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D8E1C: 3BCB9150  addi r30, r11, -0x6eb0
	ctx.r[30].s64 = ctx.r[11].s64 + -28336;
	// 828D8E20: 4B94EA61  bl 0x82227880
	ctx.lr = 0x828D8E24;
	sub_82227880(ctx, base);
	// 828D8E24: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D8E28: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828D8E2C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D8E30: 388A9450  addi r4, r10, -0x6bb0
	ctx.r[4].s64 = ctx.r[10].s64 + -27568;
	// 828D8E34: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D8E38: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828D8E3C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828D8E40: 4B8C1C41  bl 0x8219aa80
	ctx.lr = 0x828D8E44;
	sub_8219AA80(ctx, base);
	// 828D8E44: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D8E48: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D8E4C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D8E50: 4BAF55D1  bl 0x823ce420
	ctx.lr = 0x828D8E54;
	sub_823CE420(ctx, base);
	// 828D8E54: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D8E58: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828D8E5C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D8E60: 4814B869  bl 0x82a246c8
	ctx.lr = 0x828D8E64;
	sub_82A246C8(ctx, base);
	// 828D8E64: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D8E68: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828D8E6C: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828D8E70: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828D8E74: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D8E78: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828D8E7C: 419A0020  beq cr6, 0x828d8e9c
	if ctx.cr[6].eq {
	pc = 0x828D8E9C; continue 'dispatch;
	}
	// 828D8E80: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D8E84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D8E88: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D8E8C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828D8E90: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D8E94: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D8E98: 4082FFE8  bne 0x828d8e80
	if !ctx.cr[0].eq {
	pc = 0x828D8E80; continue 'dispatch;
	}
	// 828D8E9C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8EA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D8EA4: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828D8EA8: 4BA1CAA1  bl 0x822f5948
	ctx.lr = 0x828D8EAC;
	sub_822F5948(ctx, base);
	// 828D8EAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8EB0: 4B8DEC69  bl 0x821b7b18
	ctx.lr = 0x828D8EB4;
	sub_821B7B18(ctx, base);
	// 828D8EB4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D8EB8: 419A0040  beq cr6, 0x828d8ef8
	if ctx.cr[6].eq {
	pc = 0x828D8EF8; continue 'dispatch;
	}
	// 828D8EBC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D8EC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D8EC4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D8EC8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D8ECC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D8ED0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D8ED4: 4082FFE8  bne 0x828d8ebc
	if !ctx.cr[0].eq {
	pc = 0x828D8EBC; continue 'dispatch;
	}
	// 828D8ED8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D8EDC: 409A001C  bne cr6, 0x828d8ef8
	if !ctx.cr[6].eq {
	pc = 0x828D8EF8; continue 'dispatch;
	}
	// 828D8EE0: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D8EE4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8EE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D8EEC: 4E800421  bctrl
	ctx.lr = 0x828D8EF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8EF0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D8EF4: 4B942E45  bl 0x8221bd38
	ctx.lr = 0x828D8EF8;
	sub_8221BD38(ctx, base);
	// 828D8EF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D8EFC: 4B8DEC1D  bl 0x821b7b18
	ctx.lr = 0x828D8F00;
	sub_821B7B18(ctx, base);
	// 828D8F00: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828D8F04: 483D0548  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D8F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D8F08 size=516
    let mut pc: u32 = 0x828D8F08;
    'dispatch: loop {
        match pc {
            0x828D8F08 => {
    //   block [0x828D8F08..0x828D910C)
	// 828D8F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D8F0C: 483D04F1  bl 0x82ca93fc
	ctx.lr = 0x828D8F10;
	sub_82CA93D0(ctx, base);
	// 828D8F10: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D8F14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D8F18: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828D8F1C: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828D8F20: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828D8F24: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828D8F28: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8F2C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828D8F30: 3BAA8690  addi r29, r10, -0x7970
	ctx.r[29].s64 = ctx.r[10].s64 + -31088;
	// 828D8F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D8F38: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D8F3C: 419A0008  beq cr6, 0x828d8f44
	if ctx.cr[6].eq {
	pc = 0x828D8F44; continue 'dispatch;
	}
	// 828D8F40: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8F44: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8F48: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D8F4C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8F50: 4BAF5671  bl 0x823ce5c0
	ctx.lr = 0x828D8F54;
	sub_823CE5C0(ctx, base);
	// 828D8F54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D8F58: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D8F5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D8F60: 4BAF51B1  bl 0x823ce110
	ctx.lr = 0x828D8F64;
	sub_823CE110(ctx, base);
	// 828D8F64: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D8F68: 4B8DEBB1  bl 0x821b7b18
	ctx.lr = 0x828D8F6C;
	sub_821B7B18(ctx, base);
	// 828D8F6C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D8F70: 4B9462E9  bl 0x8221f258
	ctx.lr = 0x828D8F74;
	sub_8221F258(ctx, base);
	// 828D8F74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D8F78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D8F7C: 419A005C  beq cr6, 0x828d8fd8
	if ctx.cr[6].eq {
	pc = 0x828D8FD8; continue 'dispatch;
	}
	// 828D8F80: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828D8F84: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828D8F88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D8F8C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828D8F90: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D8F94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D8F98: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D8F9C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828D8FA0: 4B9172A1  bl 0x821f0240
	ctx.lr = 0x828D8FA4;
	sub_821F0240(ctx, base);
	// 828D8FA4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D8FA8: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828D8FAC: 4B9462AD  bl 0x8221f258
	ctx.lr = 0x828D8FB0;
	sub_8221F258(ctx, base);
	// 828D8FB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D8FB4: 419A0028  beq cr6, 0x828d8fdc
	if ctx.cr[6].eq {
	pc = 0x828D8FDC; continue 'dispatch;
	}
	// 828D8FB8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828D8FBC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828D8FC0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D8FC4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828D8FC8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D8FCC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D8FD0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D8FD4: 4800000C  b 0x828d8fe0
	pc = 0x828D8FE0; continue 'dispatch;
	// 828D8FD8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828D8FDC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D8FE0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8FE4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828D8FE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D8FEC: 419A0008  beq cr6, 0x828d8ff4
	if ctx.cr[6].eq {
	pc = 0x828D8FF4; continue 'dispatch;
	}
	// 828D8FF0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8FF4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D8FF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D8FFC: 419A0078  beq cr6, 0x828d9074
	if ctx.cr[6].eq {
	pc = 0x828D9074; continue 'dispatch;
	}
	// 828D9000: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9004: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828D9008: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D900C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D9010: 4B9500F9  bl 0x82229108
	ctx.lr = 0x828D9014;
	sub_82229108(ctx, base);
	// 828D9014: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828D9018: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828D901C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D9020: 3BCB92D8  addi r30, r11, -0x6d28
	ctx.r[30].s64 = ctx.r[11].s64 + -27944;
	// 828D9024: 4B94E85D  bl 0x82227880
	ctx.lr = 0x828D9028;
	sub_82227880(ctx, base);
	// 828D9028: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D902C: 3D40825F  lis r10, -0x7da1
	ctx.r[10].s64 = -2107703296;
	// 828D9030: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D9034: 388A8BA8  addi r4, r10, -0x7458
	ctx.r[4].s64 = ctx.r[10].s64 + -29784;
	// 828D9038: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D903C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828D9040: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828D9044: 4B8C1A3D  bl 0x8219aa80
	ctx.lr = 0x828D9048;
	sub_8219AA80(ctx, base);
	// 828D9048: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D904C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D9050: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D9054: 4BAF53CD  bl 0x823ce420
	ctx.lr = 0x828D9058;
	sub_823CE420(ctx, base);
	// 828D9058: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D905C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828D9060: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D9064: 4814B665  bl 0x82a246c8
	ctx.lr = 0x828D9068;
	sub_82A246C8(ctx, base);
	// 828D9068: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D906C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828D9070: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828D9074: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828D9078: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D907C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828D9080: 419A0020  beq cr6, 0x828d90a0
	if ctx.cr[6].eq {
	pc = 0x828D90A0; continue 'dispatch;
	}
	// 828D9084: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D9088: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D908C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D9090: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828D9094: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D9098: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D909C: 4082FFE8  bne 0x828d9084
	if !ctx.cr[0].eq {
	pc = 0x828D9084; continue 'dispatch;
	}
	// 828D90A0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D90A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D90A8: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828D90AC: 4BA1C89D  bl 0x822f5948
	ctx.lr = 0x828D90B0;
	sub_822F5948(ctx, base);
	// 828D90B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D90B4: 4B8DEA65  bl 0x821b7b18
	ctx.lr = 0x828D90B8;
	sub_821B7B18(ctx, base);
	// 828D90B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D90BC: 419A0040  beq cr6, 0x828d90fc
	if ctx.cr[6].eq {
	pc = 0x828D90FC; continue 'dispatch;
	}
	// 828D90C0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D90C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D90C8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D90CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D90D0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D90D4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D90D8: 4082FFE8  bne 0x828d90c0
	if !ctx.cr[0].eq {
	pc = 0x828D90C0; continue 'dispatch;
	}
	// 828D90DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D90E0: 409A001C  bne cr6, 0x828d90fc
	if !ctx.cr[6].eq {
	pc = 0x828D90FC; continue 'dispatch;
	}
	// 828D90E4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D90E8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D90EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D90F0: 4E800421  bctrl
	ctx.lr = 0x828D90F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D90F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D90F8: 4B942C41  bl 0x8221bd38
	ctx.lr = 0x828D90FC;
	sub_8221BD38(ctx, base);
	// 828D90FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D9100: 4B8DEA19  bl 0x821b7b18
	ctx.lr = 0x828D9104;
	sub_821B7B18(ctx, base);
	// 828D9104: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828D9108: 483D0344  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D9110 size=56
    let mut pc: u32 = 0x828D9110;
    'dispatch: loop {
        match pc {
            0x828D9110 => {
    //   block [0x828D9110..0x828D9148)
	// 828D9110: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828D9114: 419A0018  beq cr6, 0x828d912c
	if ctx.cr[6].eq {
	pc = 0x828D912C; continue 'dispatch;
	}
	// 828D9118: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D911C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D9120: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D9124: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D9128: 409A0008  bne cr6, 0x828d9130
	if !ctx.cr[6].eq {
	pc = 0x828D9130; continue 'dispatch;
	}
	// 828D912C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D9130: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D9134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D9138: 419A0010  beq cr6, 0x828d9148
	if ctx.cr[6].eq {
		sub_828D9148(ctx, base);
		return;
	}
	// 828D913C: 81640034  lwz r11, 0x34(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 828D9140: 55633FFE  rlwinm r3, r11, 7, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x01FFFFFFu64;
	// 828D9144: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D9148 size=8
    let mut pc: u32 = 0x828D9148;
    'dispatch: loop {
        match pc {
            0x828D9148 => {
    //   block [0x828D9148..0x828D9150)
	// 828D9148: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828D914C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9150 size=388
    let mut pc: u32 = 0x828D9150;
    'dispatch: loop {
        match pc {
            0x828D9150 => {
    //   block [0x828D9150..0x828D92D4)
	// 828D9150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D9154: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D9158: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D915C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D9160: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828D9164: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828D9168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D916C: 419A0018  beq cr6, 0x828d9184
	if ctx.cr[6].eq {
	pc = 0x828D9184; continue 'dispatch;
	}
	// 828D9170: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D9174: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828D9178: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D917C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D9180: 409A0008  bne cr6, 0x828d9188
	if !ctx.cr[6].eq {
	pc = 0x828D9188; continue 'dispatch;
	}
	// 828D9184: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D9188: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D918C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D9190: 419A0130  beq cr6, 0x828d92c0
	if ctx.cr[6].eq {
	pc = 0x828D92C0; continue 'dispatch;
	}
	// 828D9194: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828D9198: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D919C: 55283FFE  rlwinm r8, r9, 7, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x01FFFFFFu64;
	// 828D91A0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828D91A4: 419A00F8  beq cr6, 0x828d929c
	if ctx.cr[6].eq {
	pc = 0x828D929C; continue 'dispatch;
	}
	// 828D91A8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D91AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D91B0: 419A0024  beq cr6, 0x828d91d4
	if ctx.cr[6].eq {
	pc = 0x828D91D4; continue 'dispatch;
	}
	// 828D91B4: 892A0099  lbz r9, 0x99(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(153 as u32) ) } as u64;
	// 828D91B8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D91BC: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828D91C0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828D91C4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D91C8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828D91CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D91D0: 480000D0  b 0x828d92a0
	pc = 0x828D92A0; continue 'dispatch;
	// 828D91D4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D91D8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828D91DC: 83EB004C  lwz r31, 0x4c(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D91E0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828D91E4: 7D0AF850  subf r8, r10, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 828D91E8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D91EC: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D91F0: 40810054  ble 0x828d9244
	if !ctx.cr[0].gt {
	pc = 0x828D9244; continue 'dispatch;
	}
	// 828D91F4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D91F8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D91FC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D9200: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9204: 2F070099  cmpwi cr6, r7, 0x99
	ctx.cr[6].compare_i32(ctx.r[7].s32, 153, &mut ctx.xer);
	// 828D9208: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D920C: 41980008  blt cr6, 0x828d9214
	if ctx.cr[6].lt {
	pc = 0x828D9214; continue 'dispatch;
	}
	// 828D9210: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828D9214: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D9218: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D921C: 419A0014  beq cr6, 0x828d9230
	if ctx.cr[6].eq {
	pc = 0x828D9230; continue 'dispatch;
	}
	// 828D9220: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D9224: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D9228: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D922C: 4800000C  b 0x828d9238
	pc = 0x828D9238; continue 'dispatch;
	// 828D9230: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D9234: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D9238: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D923C: 4199FFB8  bgt cr6, 0x828d91f4
	if ctx.cr[6].gt {
	pc = 0x828D91F4; continue 'dispatch;
	}
	// 828D9240: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D9244: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828D9248: 419A0040  beq cr6, 0x828d9288
	if ctx.cr[6].eq {
	pc = 0x828D9288; continue 'dispatch;
	}
	// 828D924C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9250: 2F0B0099  cmpwi cr6, r11, 0x99
	ctx.cr[6].compare_i32(ctx.r[11].s32, 153, &mut ctx.xer);
	// 828D9254: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D9258: 41990008  bgt cr6, 0x828d9260
	if ctx.cr[6].gt {
	pc = 0x828D9260; continue 'dispatch;
	}
	// 828D925C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D9260: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D9264: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D9268: 409A0020  bne cr6, 0x828d9288
	if !ctx.cr[6].eq {
	pc = 0x828D9288; continue 'dispatch;
	}
	// 828D926C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D9270: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D9274: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D9278: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D927C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828D9280: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D9284: 4800001C  b 0x828d92a0
	pc = 0x828D92A0; continue 'dispatch;
	// 828D9288: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D928C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D9290: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828D9294: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D9298: 48000008  b 0x828d92a0
	pc = 0x828D92A0; continue 'dispatch;
	// 828D929C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D92A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D92A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D92A8: 419A0018  beq cr6, 0x828d92c0
	if ctx.cr[6].eq {
	pc = 0x828D92C0; continue 'dispatch;
	}
	// 828D92AC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D92B0: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 828D92B4: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828D92B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D92BC: 4E800421  bctrl
	ctx.lr = 0x828D92C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D92C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D92C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D92C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D92CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D92D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D92D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D92D8 size=376
    let mut pc: u32 = 0x828D92D8;
    'dispatch: loop {
        match pc {
            0x828D92D8 => {
    //   block [0x828D92D8..0x828D9450)
	// 828D92D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D92DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D92E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D92E4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828D92E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D92EC: 419A0018  beq cr6, 0x828d9304
	if ctx.cr[6].eq {
	pc = 0x828D9304; continue 'dispatch;
	}
	// 828D92F0: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D92F4: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828D92F8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D92FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D9300: 409A0008  bne cr6, 0x828d9308
	if !ctx.cr[6].eq {
	pc = 0x828D9308; continue 'dispatch;
	}
	// 828D9304: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D9308: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828D930C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D9310: 419A0130  beq cr6, 0x828d9440
	if ctx.cr[6].eq {
	pc = 0x828D9440; continue 'dispatch;
	}
	// 828D9314: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828D9318: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D931C: 55283FFE  rlwinm r8, r9, 7, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x01FFFFFFu64;
	// 828D9320: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828D9324: 419A00F8  beq cr6, 0x828d941c
	if ctx.cr[6].eq {
	pc = 0x828D941C; continue 'dispatch;
	}
	// 828D9328: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D932C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D9330: 419A0024  beq cr6, 0x828d9354
	if ctx.cr[6].eq {
	pc = 0x828D9354; continue 'dispatch;
	}
	// 828D9334: 892A0099  lbz r9, 0x99(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(153 as u32) ) } as u64;
	// 828D9338: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D933C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828D9340: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828D9344: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D9348: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828D934C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D9350: 480000D0  b 0x828d9420
	pc = 0x828D9420; continue 'dispatch;
	// 828D9354: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D9358: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828D935C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D9360: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828D9364: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828D9368: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D936C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D9370: 40810054  ble 0x828d93c4
	if !ctx.cr[0].gt {
	pc = 0x828D93C4; continue 'dispatch;
	}
	// 828D9374: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828D9378: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828D937C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828D9380: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9384: 2F070099  cmpwi cr6, r7, 0x99
	ctx.cr[6].compare_i32(ctx.r[7].s32, 153, &mut ctx.xer);
	// 828D9388: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828D938C: 41980008  blt cr6, 0x828d9394
	if ctx.cr[6].lt {
	pc = 0x828D9394; continue 'dispatch;
	}
	// 828D9390: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828D9394: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828D9398: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828D939C: 419A0014  beq cr6, 0x828d93b0
	if ctx.cr[6].eq {
	pc = 0x828D93B0; continue 'dispatch;
	}
	// 828D93A0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828D93A4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828D93A8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D93AC: 4800000C  b 0x828d93b8
	pc = 0x828D93B8; continue 'dispatch;
	// 828D93B0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828D93B4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828D93B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D93BC: 4199FFB8  bgt cr6, 0x828d9374
	if ctx.cr[6].gt {
	pc = 0x828D9374; continue 'dispatch;
	}
	// 828D93C0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828D93C4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828D93C8: 419A0040  beq cr6, 0x828d9408
	if ctx.cr[6].eq {
	pc = 0x828D9408; continue 'dispatch;
	}
	// 828D93CC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D93D0: 2F0B0099  cmpwi cr6, r11, 0x99
	ctx.cr[6].compare_i32(ctx.r[11].s32, 153, &mut ctx.xer);
	// 828D93D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D93D8: 41990008  bgt cr6, 0x828d93e0
	if ctx.cr[6].gt {
	pc = 0x828D93E0; continue 'dispatch;
	}
	// 828D93DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D93E0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D93E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D93E8: 409A0020  bne cr6, 0x828d9408
	if !ctx.cr[6].eq {
	pc = 0x828D9408; continue 'dispatch;
	}
	// 828D93EC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828D93F0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828D93F4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D93F8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D93FC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828D9400: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D9404: 4800001C  b 0x828d9420
	pc = 0x828D9420; continue 'dispatch;
	// 828D9408: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828D940C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D9410: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828D9414: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D9418: 48000008  b 0x828d9420
	pc = 0x828D9420; continue 'dispatch;
	// 828D941C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D9420: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D9424: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D9428: 419A0018  beq cr6, 0x828d9440
	if ctx.cr[6].eq {
	pc = 0x828D9440; continue 'dispatch;
	}
	// 828D942C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D9430: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828D9434: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828D9438: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D943C: 4E800421  bctrl
	ctx.lr = 0x828D9440;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D9440: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D9444: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D9448: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D944C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9450 size=148
    let mut pc: u32 = 0x828D9450;
    'dispatch: loop {
        match pc {
            0x828D9450 => {
    //   block [0x828D9450..0x828D94E4)
	// 828D9450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D9454: 483CFFB5  bl 0x82ca9408
	ctx.lr = 0x828D9458;
	sub_82CA93D0(ctx, base);
	// 828D9458: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D945C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 828D9460: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D9464: 4B94EC95  bl 0x822280f8
	ctx.lr = 0x828D9468;
	sub_822280F8(ctx, base);
	// 828D9468: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828D946C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828D9470: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828D9474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D9478: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828D947C: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 828D9480: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D9484: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9488: 4B94EC71  bl 0x822280f8
	ctx.lr = 0x828D948C;
	sub_822280F8(ctx, base);
	// 828D948C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9490: 4B94E0D1  bl 0x82227560
	ctx.lr = 0x828D9494;
	sub_82227560(ctx, base);
	// 828D9494: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D9498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D949C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D94A0: 4B94EC59  bl 0x822280f8
	ctx.lr = 0x828D94A4;
	sub_822280F8(ctx, base);
	// 828D94A4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D94A8: 4B94E0B9  bl 0x82227560
	ctx.lr = 0x828D94AC;
	sub_82227560(ctx, base);
	// 828D94AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D94B0: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828D94B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D94B8: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D94BC: 4BF191B5  bl 0x827f2670
	ctx.lr = 0x828D94C0;
	sub_827F2670(ctx, base);
	// 828D94C0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828D94C4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828D94C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D94CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D94D0: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 828D94D4: 4E800421  bctrl
	ctx.lr = 0x828D94D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D94D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828D94DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D94E0: 483CFF78  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D94E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D94E8 size=60
    let mut pc: u32 = 0x828D94E8;
    'dispatch: loop {
        match pc {
            0x828D94E8 => {
    //   block [0x828D94E8..0x828D9524)
	// 828D94E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D94EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D94F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D94F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D94F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828D94FC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D9500: 388B94EC  addi r4, r11, -0x6b14
	ctx.r[4].s64 = ctx.r[11].s64 + -27412;
	// 828D9504: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D9508: 4B9539C9  bl 0x8222ced0
	ctx.lr = 0x828D950C;
	sub_8222CED0(ctx, base);
	// 828D950C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D9510: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D9514: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D9518: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D951C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D9520: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D9528 size=1144
    let mut pc: u32 = 0x828D9528;
    'dispatch: loop {
        match pc {
            0x828D9528 => {
    //   block [0x828D9528..0x828D99A0)
	// 828D9528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D952C: 483CFEC9  bl 0x82ca93f4
	ctx.lr = 0x828D9530;
	sub_82CA93D0(ctx, base);
	// 828D9530: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D99A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D99A0 size=108
    let mut pc: u32 = 0x828D99A0;
    'dispatch: loop {
        match pc {
            0x828D99A0 => {
    //   block [0x828D99A0..0x828D9A0C)
	// 828D99A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D99A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D99A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D99AC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D99B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D99B4: 13010C84  vmr v24, v1
	ctx.v[24] = ctx.v[1];
	// 828D99B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D99BC: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9A10 size=152
    let mut pc: u32 = 0x828D9A10;
    'dispatch: loop {
        match pc {
            0x828D9A10 => {
    //   block [0x828D9A10..0x828D9AA8)
	// 828D9A10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D9A14: 483CF9F5  bl 0x82ca9408
	ctx.lr = 0x828D9A18;
	sub_82CA93D0(ctx, base);
	// 828D9A18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D9A1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D9A20: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828D9A24: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 828D9A28: 4BE53911  bl 0x8272d338
	ctx.lr = 0x828D9A2C;
	sub_8272D338(ctx, base);
	// 828D9A2C: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 828D9A30: 4B942309  bl 0x8221bd38
	ctx.lr = 0x828D9A34;
	sub_8221BD38(ctx, base);
	// 828D9A34: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D9A38: 3BDF0024  addi r30, r31, 0x24
	ctx.r[30].s64 = ctx.r[31].s64 + 36;
	// 828D9A3C: 93BF0038  stw r29, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[29].u32 ) };
	// 828D9A40: 809F0028  lwz r4, 0x28(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 828D9A44: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828D9A48: 419A0018  beq cr6, 0x828d9a60
	if ctx.cr[6].eq {
	pc = 0x828D9A60; continue 'dispatch;
	}
	// 828D9A4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D9A50: 80BE0008  lwz r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D9A54: 481B84AD  bl 0x82a91f00
	ctx.lr = 0x828D9A58;
	sub_82A91F00(ctx, base);
	// 828D9A58: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D9A5C: 4B9422DD  bl 0x8221bd38
	ctx.lr = 0x828D9A60;
	sub_8221BD38(ctx, base);
	// 828D9A60: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828D9A64: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 828D9A68: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828D9A6C: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 828D9A70: 4BB02DB9  bl 0x823dc828
	ctx.lr = 0x828D9A74;
	sub_823DC828(ctx, base);
	// 828D9A74: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828D9A78: 4B8DE0A1  bl 0x821b7b18
	ctx.lr = 0x828D9A7C;
	sub_821B7B18(ctx, base);
	// 828D9A7C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828D9A80: 578A07FE  clrlwi r10, r28, 0x1f
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	// 828D9A84: 392B2850  addi r9, r11, 0x2850
	ctx.r[9].s64 = ctx.r[11].s64 + 10320;
	// 828D9A88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D9A8C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D9A90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D9A94: 419A000C  beq cr6, 0x828d9aa0
	if ctx.cr[6].eq {
	pc = 0x828D9AA0; continue 'dispatch;
	}
	// 828D9A98: 4B9422A1  bl 0x8221bd38
	ctx.lr = 0x828D9A9C;
	sub_8221BD38(ctx, base);
	// 828D9A9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D9AA0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D9AA4: 483CF9B4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9AA8 size=212
    let mut pc: u32 = 0x828D9AA8;
    'dispatch: loop {
        match pc {
            0x828D9AA8 => {
    //   block [0x828D9AA8..0x828D9B7C)
	// 828D9AA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D9AAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D9AB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D9AB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D9AB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D9ABC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D9AC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D9AC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D9AC8: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D9ACC: 4BAB39ED  bl 0x8238d4b8
	ctx.lr = 0x828D9AD0;
	sub_8238D4B8(ctx, base);
	// 828D9AD0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D9AD4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D9AD8: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D9ADC: 61490001  ori r9, r10, 1
	ctx.r[9].u64 = ctx.r[10].u64 | 1;
	// 828D9AE0: 992B0090  stb r9, 0x90(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[9].u8 ) };
	// 828D9AE4: 419A0080  beq cr6, 0x828d9b64
	if ctx.cr[6].eq {
	pc = 0x828D9B64; continue 'dispatch;
	}
	// 828D9AE8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D9AEC: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828D9AF0: 386B3A38  addi r3, r11, 0x3a38
	ctx.r[3].s64 = ctx.r[11].s64 + 14904;
	// 828D9AF4: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828D9AF8: 4B91A261  bl 0x821f3d58
	ctx.lr = 0x828D9AFC;
	sub_821F3D58(ctx, base);
	// 828D9AFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D9B00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D9B04: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 828D9B08: 48126BC1  bl 0x82a006c8
	ctx.lr = 0x828D9B0C;
	sub_82A006C8(ctx, base);
	// 828D9B0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D9B10: 419A000C  beq cr6, 0x828d9b1c
	if ctx.cr[6].eq {
	pc = 0x828D9B1C; continue 'dispatch;
	}
	// 828D9B14: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9B18: 48000008  b 0x828d9b20
	pc = 0x828D9B20; continue 'dispatch;
	// 828D9B1C: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 828D9B20: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 828D9B24: 4B945735  bl 0x8221f258
	ctx.lr = 0x828D9B28;
	sub_8221F258(ctx, base);
	// 828D9B28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D9B2C: 419A002C  beq cr6, 0x828d9b58
	if ctx.cr[6].eq {
	pc = 0x828D9B58; continue 'dispatch;
	}
	// 828D9B30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D9B34: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D9B38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D9B3C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828D9B40: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828D9B44: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 828D9B48: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 828D9B4C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 828D9B50: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 828D9B54: 48000008  b 0x828d9b5c
	pc = 0x828D9B5C; continue 'dispatch;
	// 828D9B58: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D9B5C: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 828D9B60: 48001F59  bl 0x828dbab8
	ctx.lr = 0x828D9B64;
	sub_828DBAB8(ctx, base);
	// 828D9B64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D9B68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D9B6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D9B70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D9B74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D9B78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9B80 size=1256
    let mut pc: u32 = 0x828D9B80;
    'dispatch: loop {
        match pc {
            0x828D9B80 => {
    //   block [0x828D9B80..0x828DA068)
	// 828D9B80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D9B84: 483CF871  bl 0x82ca93f4
	ctx.lr = 0x828D9B88;
	sub_82CA93D0(ctx, base);
	// 828D9B88: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D9B8C: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 828D9B90: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828D9B94: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 828D9B98: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828D9B9C: 409A04C4  bne cr6, 0x828da060
	if !ctx.cr[6].eq {
	pc = 0x828DA060; continue 'dispatch;
	}
	// 828D9BA0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D9BA4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D9BA8: 388B3A48  addi r4, r11, 0x3a48
	ctx.r[4].s64 = ctx.r[11].s64 + 14920;
	// 828D9BAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D9BB0: 4B953321  bl 0x8222ced0
	ctx.lr = 0x828D9BB4;
	sub_8222CED0(ctx, base);
	// 828D9BB4: 38B70040  addi r5, r23, 0x40
	ctx.r[5].s64 = ctx.r[23].s64 + 64;
	// 828D9BB8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828D9BBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D9BC0: 48143289  bl 0x82a1ce48
	ctx.lr = 0x828D9BC4;
	sub_82A1CE48(ctx, base);
	// 828D9BC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D9BC8: 4B93B211  bl 0x82214dd8
	ctx.lr = 0x828D9BCC;
	sub_82214DD8(ctx, base);
	// 828D9BCC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 828D9BD0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D9BD4: 388ACE8C  addi r4, r10, -0x3174
	ctx.r[4].s64 = ctx.r[10].s64 + -12660;
	// 828D9BD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D9BDC: 4B9532F5  bl 0x8222ced0
	ctx.lr = 0x828D9BE0;
	sub_8222CED0(ctx, base);
	// 828D9BE0: 38B70041  addi r5, r23, 0x41
	ctx.r[5].s64 = ctx.r[23].s64 + 65;
	// 828D9BE4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828D9BE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D9BEC: 4814325D  bl 0x82a1ce48
	ctx.lr = 0x828D9BF0;
	sub_82A1CE48(ctx, base);
	// 828D9BF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D9BF4: 4B93B1E5  bl 0x82214dd8
	ctx.lr = 0x828D9BF8;
	sub_82214DD8(ctx, base);
	// 828D9BF8: 81770028  lwz r11, 0x28(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(40 as u32) ) } as u64;
	// 828D9BFC: 3BB70024  addi r29, r23, 0x24
	ctx.r[29].s64 = ctx.r[23].s64 + 36;
	// 828D9C00: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828D9C04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D9C08: 409A000C  bne cr6, 0x828d9c14
	if !ctx.cr[6].eq {
	pc = 0x828D9C14; continue 'dispatch;
	}
	// 828D9C0C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828D9C10: 48000014  b 0x828d9c24
	pc = 0x828D9C24; continue 'dispatch;
	// 828D9C14: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D9C18: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828D9C1C: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828D9C20: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828D9C24: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D9C28: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D9C2C: 388B3A64  addi r4, r11, 0x3a64
	ctx.r[4].s64 = ctx.r[11].s64 + 14948;
	// 828D9C30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D9C34: 4B95329D  bl 0x8222ced0
	ctx.lr = 0x828D9C38;
	sub_8222CED0(ctx, base);
	// 828D9C38: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D9C3C: 3B2BFFDF  addi r25, r11, -0x21
	ctx.r[25].s64 = ctx.r[11].s64 + -33;
	// 828D9C40: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828D9C44: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D9C48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D9C4C: 419A0008  beq cr6, 0x828d9c54
	if ctx.cr[6].eq {
	pc = 0x828D9C54; continue 'dispatch;
	}
	// 828D9C50: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9C54: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D9C58: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D9C5C: 4BBA6B6D  bl 0x824807c8
	ctx.lr = 0x828D9C60;
	sub_824807C8(ctx, base);
	// 828D9C60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D9C64: 4B93B175  bl 0x82214dd8
	ctx.lr = 0x828D9C68;
	sub_82214DD8(ctx, base);
	// 828D9C68: 57F8063E  clrlwi r24, r31, 0x18
	ctx.r[24].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 828D9C6C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D9C70: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828D9C74: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 828D9C78: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 828D9C7C: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 828D9C80: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 828D9C84: 419A0098  beq cr6, 0x828d9d1c
	if ctx.cr[6].eq {
	pc = 0x828D9D1C; continue 'dispatch;
	}
	// 828D9C88: 48001D29  bl 0x828db9b0
	ctx.lr = 0x828D9C8C;
	sub_828DB9B0(ctx, base);
	// 828D9C8C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D9C90: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828D9C94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D9C98: 40990094  ble cr6, 0x828d9d2c
	if !ctx.cr[6].gt {
	pc = 0x828D9D2C; continue 'dispatch;
	}
	// 828D9C9C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828D9CA0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D9CA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D9CA8: 419A0018  beq cr6, 0x828d9cc0
	if ctx.cr[6].eq {
	pc = 0x828D9CC0; continue 'dispatch;
	}
	// 828D9CAC: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D9CB0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828D9CB4: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828D9CB8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828D9CBC: 41980008  blt cr6, 0x828d9cc4
	if ctx.cr[6].lt {
	pc = 0x828D9CC4; continue 'dispatch;
	}
	// 828D9CC0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D9CC4: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828D9CC8: 4B89A171  bl 0x82173e38
	ctx.lr = 0x828D9CCC;
	sub_82173E38(ctx, base);
	// 828D9CCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D9CD0: 419A0018  beq cr6, 0x828d9ce8
	if ctx.cr[6].eq {
	pc = 0x828D9CE8; continue 'dispatch;
	}
	// 828D9CD4: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D9CD8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D9CDC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D9CE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D9CE4: 409A0008  bne cr6, 0x828d9cec
	if !ctx.cr[6].eq {
	pc = 0x828D9CEC; continue 'dispatch;
	}
	// 828D9CE8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828D9CEC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D9CF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D9CF4: 419A0010  beq cr6, 0x828d9d04
	if ctx.cr[6].eq {
	pc = 0x828D9D04; continue 'dispatch;
	}
	// 828D9CF8: 38830014  addi r4, r3, 0x14
	ctx.r[4].s64 = ctx.r[3].s64 + 20;
	// 828D9CFC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828D9D00: 4BFD0641  bl 0x828aa340
	ctx.lr = 0x828D9D04;
	sub_828AA340(ctx, base);
	// 828D9D04: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D9D08: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828D9D0C: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 828D9D10: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828D9D14: 4198FF8C  blt cr6, 0x828d9ca0
	if ctx.cr[6].lt {
	pc = 0x828D9CA0; continue 'dispatch;
	}
	// 828D9D18: 48000014  b 0x828d9d2c
	pc = 0x828D9D2C; continue 'dispatch;
	// 828D9D1C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 828D9D20: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828D9D24: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828D9D28: 48001E11  bl 0x828dbb38
	ctx.lr = 0x828D9D2C;
	sub_828DBB38(ctx, base);
	// 828D9D2C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828D9D30: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 828D9D34: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828D9D38: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828D9D3C: 3B6B7088  addi r27, r11, 0x7088
	ctx.r[27].s64 = ctx.r[11].s64 + 28808;
	// 828D9D40: 3BAA4218  addi r29, r10, 0x4218
	ctx.r[29].s64 = ctx.r[10].s64 + 16920;
	// 828D9D44: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828D9D48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D9D4C: 419A0094  beq cr6, 0x828d9de0
	if ctx.cr[6].eq {
	pc = 0x828D9DE0; continue 'dispatch;
	}
	// 828D9D50: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828D9D54: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828D9D58: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828D9D5C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D9D60: 40980080  bge cr6, 0x828d9de0
	if !ctx.cr[6].lt {
	pc = 0x828D9DE0; continue 'dispatch;
	}
	// 828D9D64: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D9D68: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D9D6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D9D70: 4B953161  bl 0x8222ced0
	ctx.lr = 0x828D9D74;
	sub_8222CED0(ctx, base);
	// 828D9D74: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828D9D78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D9D7C: 419A0018  beq cr6, 0x828d9d94
	if ctx.cr[6].eq {
	pc = 0x828D9D94; continue 'dispatch;
	}
	// 828D9D80: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828D9D84: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828D9D88: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828D9D8C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828D9D90: 41980008  blt cr6, 0x828d9d98
	if ctx.cr[6].lt {
	pc = 0x828D9D98; continue 'dispatch;
	}
	// 828D9D94: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D9D98: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828D9D9C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D9DA0: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828D9DA4: 4BBD8A15  bl 0x824b27b8
	ctx.lr = 0x828D9DA8;
	sub_824B27B8(ctx, base);
	// 828D9DA8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D9DAC: 4B8EC9BD  bl 0x821c6768
	ctx.lr = 0x828D9DB0;
	sub_821C6768(ctx, base);
	// 828D9DB0: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 828D9DB4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D9DB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D9DBC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D9DC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D9DC4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D9DC8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D9DCC: 4082FFE8  bne 0x828d9db4
	if !ctx.cr[0].eq {
	pc = 0x828D9DB4; continue 'dispatch;
	}
	// 828D9DD0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828D9DD4: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 828D9DD8: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 828D9DDC: 4BFFFF68  b 0x828d9d44
	pc = 0x828D9D44; continue 'dispatch;
	// 828D9DE0: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 828D9DE4: 409A001C  bne cr6, 0x828d9e00
	if !ctx.cr[6].eq {
	pc = 0x828D9E00; continue 'dispatch;
	}
	// 828D9DE8: 8177000C  lwz r11, 0xc(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D9DEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D9DF0: 419A0010  beq cr6, 0x828d9e00
	if ctx.cr[6].eq {
	pc = 0x828D9E00; continue 'dispatch;
	}
	// 828D9DF4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828D9DF8: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 828D9DFC: 4800190D  bl 0x828db708
	ctx.lr = 0x828D9E00;
	sub_828DB708(ctx, base);
	// 828D9E00: 8097003C  lwz r4, 0x3c(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(60 as u32) ) } as u64;
	// 828D9E04: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 828D9E08: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 828D9E0C: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 828D9E10: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 828D9E14: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 828D9E18: 419A00C8  beq cr6, 0x828d9ee0
	if ctx.cr[6].eq {
	pc = 0x828D9EE0; continue 'dispatch;
	}
	// 828D9E1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D9E20: 48001B91  bl 0x828db9b0
	ctx.lr = 0x828D9E24;
	sub_828DB9B0(ctx, base);
	// 828D9E24: 81770038  lwz r11, 0x38(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(56 as u32) ) } as u64;
	// 828D9E28: 3BD70034  addi r30, r23, 0x34
	ctx.r[30].s64 = ctx.r[23].s64 + 52;
	// 828D9E2C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9E30: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D9E34: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828D9E38: 419A0008  beq cr6, 0x828d9e40
	if ctx.cr[6].eq {
	pc = 0x828D9E40; continue 'dispatch;
	}
	// 828D9E3C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D9E40: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D9E44: 419A0090  beq cr6, 0x828d9ed4
	if ctx.cr[6].eq {
	pc = 0x828D9ED4; continue 'dispatch;
	}
	// 828D9E48: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D9E4C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D9E50: 409A0008  bne cr6, 0x828d9e58
	if !ctx.cr[6].eq {
	pc = 0x828D9E58; continue 'dispatch;
	}
	// 828D9E54: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D9E58: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D9E5C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 828D9E60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D9E64: 419A0068  beq cr6, 0x828d9ecc
	if ctx.cr[6].eq {
	pc = 0x828D9ECC; continue 'dispatch;
	}
	// 828D9E68: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9E6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D9E70: 419A0058  beq cr6, 0x828d9ec8
	if ctx.cr[6].eq {
	pc = 0x828D9EC8; continue 'dispatch;
	}
	// 828D9E74: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828D9E78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828D9E7C: 419A0018  beq cr6, 0x828d9e94
	if ctx.cr[6].eq {
	pc = 0x828D9E94; continue 'dispatch;
	}
	// 828D9E80: 896A0090  lbz r11, 0x90(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 828D9E84: 55690672  rlwinm r9, r11, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D9E88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D9E8C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828D9E90: 409A0008  bne cr6, 0x828d9e98
	if !ctx.cr[6].eq {
	pc = 0x828D9E98; continue 'dispatch;
	}
	// 828D9E94: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828D9E98: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D9E9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D9EA0: 419A0010  beq cr6, 0x828d9eb0
	if ctx.cr[6].eq {
	pc = 0x828D9EB0; continue 'dispatch;
	}
	// 828D9EA4: 388A0014  addi r4, r10, 0x14
	ctx.r[4].s64 = ctx.r[10].s64 + 20;
	// 828D9EA8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D9EAC: 4BFD0495  bl 0x828aa340
	ctx.lr = 0x828D9EB0;
	sub_828AA340(ctx, base);
	// 828D9EB0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D9EB4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828D9EB8: 409A0008  bne cr6, 0x828d9ec0
	if !ctx.cr[6].eq {
	pc = 0x828D9EC0; continue 'dispatch;
	}
	// 828D9EBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D9EC0: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9EC4: 4BFFFF6C  b 0x828d9e30
	pc = 0x828D9E30; continue 'dispatch;
	// 828D9EC8: 4B8B9F71  bl 0x82193e38
	ctx.lr = 0x828D9ECC;
	sub_82193E38(ctx, base);
	// 828D9ECC: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 828D9ED0: 4BFFFFC4  b 0x828d9e94
	pc = 0x828D9E94; continue 'dispatch;
	// 828D9ED4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D9ED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D9EDC: 409A000C  bne cr6, 0x828d9ee8
	if !ctx.cr[6].eq {
	pc = 0x828D9EE8; continue 'dispatch;
	}
	// 828D9EE0: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828D9EE4: 48000014  b 0x828d9ef8
	pc = 0x828D9EF8; continue 'dispatch;
	// 828D9EE8: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828D9EEC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828D9EF0: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828D9EF4: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 828D9EF8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D9EFC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D9F00: 388B3A7C  addi r4, r11, 0x3a7c
	ctx.r[4].s64 = ctx.r[11].s64 + 14972;
	// 828D9F04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D9F08: 4B952FC9  bl 0x8222ced0
	ctx.lr = 0x828D9F0C;
	sub_8222CED0(ctx, base);
	// 828D9F0C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D9F10: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828D9F14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D9F18: 419A0008  beq cr6, 0x828d9f20
	if ctx.cr[6].eq {
	pc = 0x828D9F20; continue 'dispatch;
	}
	// 828D9F1C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9F20: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828D9F24: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D9F28: 4BBA68A1  bl 0x824807c8
	ctx.lr = 0x828D9F2C;
	sub_824807C8(ctx, base);
	// 828D9F2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D9F30: 4B8EC839  bl 0x821c6768
	ctx.lr = 0x828D9F34;
	sub_821C6768(ctx, base);
	// 828D9F34: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 828D9F38: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D9F3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D9F40: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D9F44: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D9F48: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D9F4C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D9F50: 4082FFE8  bne 0x828d9f38
	if !ctx.cr[0].eq {
	pc = 0x828D9F38; continue 'dispatch;
	}
	// 828D9F54: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 828D9F58: 409A001C  bne cr6, 0x828d9f74
	if !ctx.cr[6].eq {
	pc = 0x828D9F74; continue 'dispatch;
	}
	// 828D9F5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D9F60: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 828D9F64: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828D9F68: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D9F6C: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828D9F70: 48001BC9  bl 0x828dbb38
	ctx.lr = 0x828D9F74;
	sub_828DBB38(ctx, base);
	// 828D9F74: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D9F78: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828D9F7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D9F80: 40990094  ble cr6, 0x828da014
	if !ctx.cr[6].gt {
	pc = 0x828DA014; continue 'dispatch;
	}
	// 828D9F84: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828D9F88: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828D9F8C: 3BAB3A94  addi r29, r11, 0x3a94
	ctx.r[29].s64 = ctx.r[11].s64 + 14996;
	// 828D9F90: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D9F94: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828D9F98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D9F9C: 4B952F35  bl 0x8222ced0
	ctx.lr = 0x828D9FA0;
	sub_8222CED0(ctx, base);
	// 828D9FA0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D9FA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D9FA8: 419A0018  beq cr6, 0x828d9fc0
	if ctx.cr[6].eq {
	pc = 0x828D9FC0; continue 'dispatch;
	}
	// 828D9FAC: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828D9FB0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828D9FB4: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828D9FB8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828D9FBC: 41980008  blt cr6, 0x828d9fc4
	if ctx.cr[6].lt {
	pc = 0x828D9FC4; continue 'dispatch;
	}
	// 828D9FC0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828D9FC4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828D9FC8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D9FCC: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828D9FD0: 4BBD87E9  bl 0x824b27b8
	ctx.lr = 0x828D9FD4;
	sub_824B27B8(ctx, base);
	// 828D9FD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D9FD8: 4B8EC791  bl 0x821c6768
	ctx.lr = 0x828D9FDC;
	sub_821C6768(ctx, base);
	// 828D9FDC: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 828D9FE0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828D9FE4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D9FE8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828D9FEC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828D9FF0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D9FF4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D9FF8: 4082FFE8  bne 0x828d9fe0
	if !ctx.cr[0].eq {
	pc = 0x828D9FE0; continue 'dispatch;
	}
	// 828D9FFC: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DA000: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828DA004: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 828DA008: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 828DA00C: 7F1F4000  cmpw cr6, r31, r8
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[8].s32, &mut ctx.xer);
	// 828DA010: 4198FF80  blt cr6, 0x828d9f90
	if ctx.cr[6].lt {
	pc = 0x828D9F90; continue 'dispatch;
	}
	// 828DA014: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 828DA018: 409A001C  bne cr6, 0x828da034
	if !ctx.cr[6].eq {
	pc = 0x828DA034; continue 'dispatch;
	}
	// 828DA01C: 8177000C  lwz r11, 0xc(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 828DA020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA024: 419A0010  beq cr6, 0x828da034
	if ctx.cr[6].eq {
	pc = 0x828DA034; continue 'dispatch;
	}
	// 828DA028: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828DA02C: 386B0014  addi r3, r11, 0x14
	ctx.r[3].s64 = ctx.r[11].s64 + 20;
	// 828DA030: 480016D9  bl 0x828db708
	ctx.lr = 0x828DA034;
	sub_828DB708(ctx, base);
	// 828DA034: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828DA038: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DA03C: 419A0008  beq cr6, 0x828da044
	if ctx.cr[6].eq {
	pc = 0x828DA044; continue 'dispatch;
	}
	// 828DA040: 4B941CF9  bl 0x8221bd38
	ctx.lr = 0x828DA044;
	sub_8221BD38(ctx, base);
	// 828DA044: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828DA048: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 828DA04C: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 828DA050: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DA054: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 828DA058: 419A0008  beq cr6, 0x828da060
	if ctx.cr[6].eq {
	pc = 0x828DA060; continue 'dispatch;
	}
	// 828DA05C: 4B941CDD  bl 0x8221bd38
	ctx.lr = 0x828DA060;
	sub_8221BD38(ctx, base);
	// 828DA060: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828DA064: 483CF3E0  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DA068 size=700
    let mut pc: u32 = 0x828DA068;
    'dispatch: loop {
        match pc {
            0x828DA068 => {
    //   block [0x828DA068..0x828DA324)
	// 828DA068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DA06C: 483CF385  bl 0x82ca93f0
	ctx.lr = 0x828DA070;
	sub_82CA93D0(ctx, base);
	// 828DA070: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DA074: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828DA078: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828DA07C: 3ADB000C  addi r22, r27, 0xc
	ctx.r[22].s64 = ctx.r[27].s64 + 12;
	// 828DA080: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 828DA084: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA088: 419A0288  beq cr6, 0x828da310
	if ctx.cr[6].eq {
	pc = 0x828DA310; continue 'dispatch;
	}
	// 828DA08C: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 828DA090: 4B9451C9  bl 0x8221f258
	ctx.lr = 0x828DA094;
	sub_8221F258(ctx, base);
	// 828DA094: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DA098: 419A001C  beq cr6, 0x828da0b4
	if ctx.cr[6].eq {
	pc = 0x828DA0B4; continue 'dispatch;
	}
	// 828DA09C: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA0A0: 809B0004  lwz r4, 4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DA0A4: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA0A8: 4BFFF481  bl 0x828d9528
	ctx.lr = 0x828DA0AC;
	sub_828D9528(ctx, base);
	// 828DA0AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DA0B0: 48000008  b 0x828da0b8
	pc = 0x828DA0B8; continue 'dispatch;
	// 828DA0B4: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 828DA0B8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828DA0BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DA0C0: 419A0034  beq cr6, 0x828da0f4
	if ctx.cr[6].eq {
	pc = 0x828DA0F4; continue 'dispatch;
	}
	// 828DA0C4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828DA0C8: 4B945191  bl 0x8221f258
	ctx.lr = 0x828DA0CC;
	sub_8221F258(ctx, base);
	// 828DA0CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DA0D0: 419A0024  beq cr6, 0x828da0f4
	if ctx.cr[6].eq {
	pc = 0x828DA0F4; continue 'dispatch;
	}
	// 828DA0D4: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DA0D8: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828DA0DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DA0E0: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 828DA0E4: 392BBDD0  addi r9, r11, -0x4230
	ctx.r[9].s64 = ctx.r[11].s64 + -16944;
	// 828DA0E8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DA0EC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DA0F0: 48000008  b 0x828da0f8
	pc = 0x828DA0F8; continue 'dispatch;
	// 828DA0F4: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 828DA0F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DA0FC: 387B0014  addi r3, r27, 0x14
	ctx.r[3].s64 = ctx.r[27].s64 + 20;
	// 828DA100: 4BA1B849  bl 0x822f5948
	ctx.lr = 0x828DA104;
	sub_822F5948(ctx, base);
	// 828DA104: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA108: 4B8DDA11  bl 0x821b7b18
	ctx.lr = 0x828DA10C;
	sub_821B7B18(ctx, base);
	// 828DA10C: 81560000  lwz r10, 0(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA110: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DA114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA118: 409A000C  bne cr6, 0x828da124
	if !ctx.cr[6].eq {
	pc = 0x828DA124; continue 'dispatch;
	}
	// 828DA11C: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 828DA120: 48000010  b 0x828da130
	pc = 0x828DA130; continue 'dispatch;
	// 828DA124: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828DA128: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DA12C: 7D3C1E70  srawi r28, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828DA130: 3BFB0024  addi r31, r27, 0x24
	ctx.r[31].s64 = ctx.r[27].s64 + 36;
	// 828DA134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DA138: 4BA67089  bl 0x823411c0
	ctx.lr = 0x828DA13C;
	sub_823411C0(ctx, base);
	// 828DA13C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828DA140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DA144: 4BDA3D75  bl 0x8267deb8
	ctx.lr = 0x828DA148;
	sub_8267DEB8(ctx, base);
	// 828DA148: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828DA14C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DA150: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828DA154: 3B0B0B7C  addi r24, r11, 0xb7c
	ctx.r[24].s64 = ctx.r[11].s64 + 2940;
	// 828DA158: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 828DA15C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828DA160: 3AEA0B7C  addi r23, r10, 0xb7c
	ctx.r[23].s64 = ctx.r[10].s64 + 2940;
	// 828DA164: 81696AB8  lwz r11, 0x6ab8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828DA168: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828DA16C: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DA170: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DA174: 83260000  lwz r25, 0(r6)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA178: 409900A8  ble cr6, 0x828da220
	if !ctx.cr[6].gt {
	pc = 0x828DA220; continue 'dispatch;
	}
	// 828DA17C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 828DA180: 81560000  lwz r10, 0(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA184: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DA188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA18C: 419A0018  beq cr6, 0x828da1a4
	if ctx.cr[6].eq {
	pc = 0x828DA1A4; continue 'dispatch;
	}
	// 828DA190: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828DA194: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DA198: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828DA19C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828DA1A0: 41980008  blt cr6, 0x828da1a8
	if ctx.cr[6].lt {
	pc = 0x828DA1A8; continue 'dispatch;
	}
	// 828DA1A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DA1A8: 7C9D5A14  add r4, r29, r11
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 828DA1AC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828DA1B0: 4B98A2D9  bl 0x82264488
	ctx.lr = 0x828DA1B4;
	sub_82264488(ctx, base);
	// 828DA1B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DA1B8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828DA1BC: 419A0018  beq cr6, 0x828da1d4
	if ctx.cr[6].eq {
	pc = 0x828DA1D4; continue 'dispatch;
	}
	// 828DA1C0: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DA1C4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DA1C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DA1CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DA1D0: 409A0008  bne cr6, 0x828da1d8
	if !ctx.cr[6].eq {
	pc = 0x828DA1D8; continue 'dispatch;
	}
	// 828DA1D4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828DA1D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DA1DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA1E0: 419A0030  beq cr6, 0x828da210
	if ctx.cr[6].eq {
	pc = 0x828DA210; continue 'dispatch;
	}
	// 828DA1E4: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 828DA1E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA1EC: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 828DA1F0: 4B93A6A9  bl 0x82214898
	ctx.lr = 0x828DA1F4;
	sub_82214898(ctx, base);
	// 828DA1F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DA1F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DA1FC: 4BA90A3D  bl 0x8236ac38
	ctx.lr = 0x828DA200;
	sub_8236AC38(ctx, base);
	// 828DA200: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 828DA204: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA208: 4B8B9C31  bl 0x82193e38
	ctx.lr = 0x828DA20C;
	sub_82193E38(ctx, base);
	// 828DA20C: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 828DA210: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828DA214: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828DA218: 7F1EE000  cmpw cr6, r30, r28
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[28].s32, &mut ctx.xer);
	// 828DA21C: 4198FF64  blt cr6, 0x828da180
	if ctx.cr[6].lt {
	pc = 0x828DA180; continue 'dispatch;
	}
	// 828DA220: 3BBB0034  addi r29, r27, 0x34
	ctx.r[29].s64 = ctx.r[27].s64 + 52;
	// 828DA224: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DA228: 4BE53111  bl 0x8272d338
	ctx.lr = 0x828DA22C;
	sub_8272D338(ctx, base);
	// 828DA22C: 81560000  lwz r10, 0(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA230: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 828DA234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA238: 409A000C  bne cr6, 0x828da244
	if !ctx.cr[6].eq {
	pc = 0x828DA244; continue 'dispatch;
	}
	// 828DA23C: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 828DA240: 48000010  b 0x828da250
	pc = 0x828DA250; continue 'dispatch;
	// 828DA244: 814A001C  lwz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 828DA248: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DA24C: 7D3C1E70  srawi r28, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828DA250: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 828DA254: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828DA258: 409900B8  ble cr6, 0x828da310
	if !ctx.cr[6].gt {
	pc = 0x828DA310; continue 'dispatch;
	}
	// 828DA25C: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 828DA260: 81560000  lwz r10, 0(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA264: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 828DA268: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA26C: 419A0018  beq cr6, 0x828da284
	if ctx.cr[6].eq {
	pc = 0x828DA284; continue 'dispatch;
	}
	// 828DA270: 814A001C  lwz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 828DA274: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DA278: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828DA27C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828DA280: 41980008  blt cr6, 0x828da288
	if ctx.cr[6].lt {
	pc = 0x828DA288; continue 'dispatch;
	}
	// 828DA284: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DA288: 7C9E5A14  add r4, r30, r11
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828DA28C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828DA290: 4B98A1F9  bl 0x82264488
	ctx.lr = 0x828DA294;
	sub_82264488(ctx, base);
	// 828DA294: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DA298: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828DA29C: 419A0018  beq cr6, 0x828da2b4
	if ctx.cr[6].eq {
	pc = 0x828DA2B4; continue 'dispatch;
	}
	// 828DA2A0: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DA2A4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DA2A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DA2AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DA2B0: 409A0008  bne cr6, 0x828da2b8
	if !ctx.cr[6].eq {
	pc = 0x828DA2B8; continue 'dispatch;
	}
	// 828DA2B4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828DA2B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DA2BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA2C0: 419A0040  beq cr6, 0x828da300
	if ctx.cr[6].eq {
	pc = 0x828DA300; continue 'dispatch;
	}
	// 828DA2C4: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 828DA2C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA2CC: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 828DA2D0: 4B93A5C9  bl 0x82214898
	ctx.lr = 0x828DA2D4;
	sub_82214898(ctx, base);
	// 828DA2D4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DA2D8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DA2DC: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828DA2E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DA2E4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828DA2E8: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828DA2EC: 4BB7BE2D  bl 0x82456118
	ctx.lr = 0x828DA2F0;
	sub_82456118(ctx, base);
	// 828DA2F0: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 828DA2F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA2F8: 4B8B9B41  bl 0x82193e38
	ctx.lr = 0x828DA2FC;
	sub_82193E38(ctx, base);
	// 828DA2FC: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 828DA300: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828DA304: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 828DA308: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 828DA30C: 4198FF54  blt cr6, 0x828da260
	if ctx.cr[6].lt {
	pc = 0x828DA260; continue 'dispatch;
	}
	// 828DA310: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 828DA314: 4B8DD805  bl 0x821b7b18
	ctx.lr = 0x828DA318;
	sub_821B7B18(ctx, base);
	// 828DA318: 93560000  stw r26, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 828DA31C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828DA320: 483CF120  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DA328 size=152
    let mut pc: u32 = 0x828DA328;
    'dispatch: loop {
        match pc {
            0x828DA328 => {
    //   block [0x828DA328..0x828DA3C0)
	// 828DA328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DA32C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DA330: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DA334: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DA338: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DA33C: 897F0041  lbz r11, 0x41(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(65 as u32) ) } as u64;
	// 828DA340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA344: 409A0068  bne cr6, 0x828da3ac
	if !ctx.cr[6].eq {
	pc = 0x828DA3AC; continue 'dispatch;
	}
	// 828DA348: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DA34C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA350: 4B900061  bl 0x821da3b0
	ctx.lr = 0x828DA354;
	sub_821DA3B0(ctx, base);
	// 828DA354: 4B8D81A5  bl 0x821b24f8
	ctx.lr = 0x828DA358;
	sub_821B24F8(ctx, base);
	// 828DA358: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828DA35C: 388B3AA4  addi r4, r11, 0x3aa4
	ctx.r[4].s64 = ctx.r[11].s64 + 15012;
	// 828DA360: 4BA35F31  bl 0x82310290
	ctx.lr = 0x828DA364;
	sub_82310290(ctx, base);
	// 828DA364: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828DA368: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DA36C: 419A0040  beq cr6, 0x828da3ac
	if ctx.cr[6].eq {
	pc = 0x828DA3AC; continue 'dispatch;
	}
	// 828DA370: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828DA374: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828DA378: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828DA37C: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DA380: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DA384: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA388: 4B951E31  bl 0x8222c1b8
	ctx.lr = 0x828DA38C;
	sub_8222C1B8(ctx, base);
	// 828DA38C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DA390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DA394: 48000055  bl 0x828da3e8
	ctx.lr = 0x828DA398;
	sub_828DA3E8(ctx, base);
	// 828DA398: 88FF0041  lbz r7, 0x41(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(65 as u32) ) } as u64;
	// 828DA39C: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 828DA3A0: 419A000C  beq cr6, 0x828da3ac
	if ctx.cr[6].eq {
	pc = 0x828DA3AC; continue 'dispatch;
	}
	// 828DA3A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DA3A8: 997F0041  stb r11, 0x41(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(65 as u32), ctx.r[11].u8 ) };
	// 828DA3AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DA3B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DA3B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DA3B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DA3BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA3C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DA3C0 size=16
    let mut pc: u32 = 0x828DA3C0;
    'dispatch: loop {
        match pc {
            0x828DA3C0 => {
    //   block [0x828DA3C0..0x828DA3D0)
	// 828DA3C0: 89430041  lbz r10, 0x41(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(65 as u32) ) } as u64;
	// 828DA3C4: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 828DA3C8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828DA3CC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DA3D0 size=12
    let mut pc: u32 = 0x828DA3D0;
    'dispatch: loop {
        match pc {
            0x828DA3D0 => {
    //   block [0x828DA3D0..0x828DA3DC)
	// 828DA3D0: 98830041  stb r4, 0x41(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(65 as u32), ctx.r[4].u8 ) };
	// 828DA3D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA3D8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA3DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DA3DC size=8
    let mut pc: u32 = 0x828DA3DC;
    'dispatch: loop {
        match pc {
            0x828DA3DC => {
    //   block [0x828DA3DC..0x828DA3E4)
	// 828DA3DC: 38630034  addi r3, r3, 0x34
	ctx.r[3].s64 = ctx.r[3].s64 + 52;
	// 828DA3E0: 4BE52F58  b 0x8272d338
	sub_8272D338(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA3E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DA3E4 size=4
    let mut pc: u32 = 0x828DA3E4;
    'dispatch: loop {
        match pc {
            0x828DA3E4 => {
    //   block [0x828DA3E4..0x828DA3E8)
	// 828DA3E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DA3E8 size=300
    let mut pc: u32 = 0x828DA3E8;
    'dispatch: loop {
        match pc {
            0x828DA3E8 => {
    //   block [0x828DA3E8..0x828DA514)
	// 828DA3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DA3EC: 483CF019  bl 0x82ca9404
	ctx.lr = 0x828DA3F0;
	sub_82CA93D0(ctx, base);
	// 828DA3F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DA3F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DA3F8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828DA3FC: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 828DA400: 938100BC  stw r28, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[28].u32 ) };
	// 828DA404: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828DA408: 9B7D0040  stb r27, 0x40(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(64 as u32), ctx.r[27].u8 ) };
	// 828DA40C: 419A0018  beq cr6, 0x828da424
	if ctx.cr[6].eq {
	pc = 0x828DA424; continue 'dispatch;
	}
	// 828DA410: 897C0090  lbz r11, 0x90(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DA414: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DA418: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828DA41C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DA420: 409A0008  bne cr6, 0x828da428
	if !ctx.cr[6].eq {
	pc = 0x828DA428; continue 'dispatch;
	}
	// 828DA424: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DA428: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DA42C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA430: 419A00CC  beq cr6, 0x828da4fc
	if ctx.cr[6].eq {
	pc = 0x828DA4FC; continue 'dispatch;
	}
	// 828DA434: 83DD002C  lwz r30, 0x2c(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 828DA438: 3BFD0024  addi r31, r29, 0x24
	ctx.r[31].s64 = ctx.r[29].s64 + 36;
	// 828DA43C: 817D0028  lwz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 828DA440: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828DA444: 40990008  ble cr6, 0x828da44c
	if !ctx.cr[6].gt {
	pc = 0x828DA44C; continue 'dispatch;
	}
	// 828DA448: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DA44C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DA450: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DA454: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828DA458: 40990008  ble cr6, 0x828da460
	if !ctx.cr[6].gt {
	pc = 0x828DA460; continue 'dispatch;
	}
	// 828DA45C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DA460: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DA464: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DA468: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828DA46C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DA470: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828DA474: 40990008  ble cr6, 0x828da47c
	if !ctx.cr[6].gt {
	pc = 0x828DA47C; continue 'dispatch;
	}
	// 828DA478: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DA47C: 38C100BC  addi r6, r1, 0xbc
	ctx.r[6].s64 = ctx.r[1].s64 + 188;
	// 828DA480: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828DA484: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DA488: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828DA48C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828DA490: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828DA494: 4BA696F5  bl 0x82343b88
	ctx.lr = 0x828DA498;
	sub_82343B88(ctx, base);
	// 828DA498: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA49C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA4A0: 419A000C  beq cr6, 0x828da4ac
	if ctx.cr[6].eq {
	pc = 0x828DA4AC; continue 'dispatch;
	}
	// 828DA4A4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828DA4A8: 419A0008  beq cr6, 0x828da4b0
	if ctx.cr[6].eq {
	pc = 0x828DA4B0; continue 'dispatch;
	}
	// 828DA4AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DA4B0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DA4B4: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828DA4B8: 409A0044  bne cr6, 0x828da4fc
	if !ctx.cr[6].eq {
	pc = 0x828DA4FC; continue 'dispatch;
	}
	// 828DA4BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DA4C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DA4C4: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 828DA4C8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DA4CC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828DA4D0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828DA4D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA4D8: 4B93A3C1  bl 0x82214898
	ctx.lr = 0x828DA4DC;
	sub_82214898(ctx, base);
	// 828DA4DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DA4E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DA4E4: 4BA90755  bl 0x8236ac38
	ctx.lr = 0x828DA4E8;
	sub_8236AC38(ctx, base);
	// 828DA4E8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828DA4EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA4F0: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 828DA4F4: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 828DA4F8: 4B8B9941  bl 0x82193e38
	ctx.lr = 0x828DA4FC;
	sub_82193E38(ctx, base);
	// 828DA4FC: 897D0041  lbz r11, 0x41(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(65 as u32) ) } as u64;
	// 828DA500: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828DA504: 419A0008  beq cr6, 0x828da50c
	if ctx.cr[6].eq {
	pc = 0x828DA50C; continue 'dispatch;
	}
	// 828DA508: 9B7D0041  stb r27, 0x41(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(65 as u32), ctx.r[27].u8 ) };
	// 828DA50C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828DA510: 483CEF44  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DA518 size=76
    let mut pc: u32 = 0x828DA518;
    'dispatch: loop {
        match pc {
            0x828DA518 => {
    //   block [0x828DA518..0x828DA564)
	// 828DA518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DA51C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DA520: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DA524: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DA528: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DA52C: 387F0024  addi r3, r31, 0x24
	ctx.r[3].s64 = ctx.r[31].s64 + 36;
	// 828DA530: 4BA66C91  bl 0x823411c0
	ctx.lr = 0x828DA534;
	sub_823411C0(ctx, base);
	// 828DA534: 895F0041  lbz r10, 0x41(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(65 as u32) ) } as u64;
	// 828DA538: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DA53C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 828DA540: 997F0040  stb r11, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
	// 828DA544: 419A000C  beq cr6, 0x828da550
	if ctx.cr[6].eq {
	pc = 0x828DA550; continue 'dispatch;
	}
	// 828DA548: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DA54C: 997F0041  stb r11, 0x41(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(65 as u32), ctx.r[11].u8 ) };
	// 828DA550: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DA554: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DA558: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DA55C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DA560: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DA568 size=312
    let mut pc: u32 = 0x828DA568;
    'dispatch: loop {
        match pc {
            0x828DA568 => {
    //   block [0x828DA568..0x828DA6A0)
	// 828DA568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DA56C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DA570: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DA574: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DA578: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DA57C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DA580: 897F0040  lbz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828DA584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA588: 419A0014  beq cr6, 0x828da59c
	if ctx.cr[6].eq {
	pc = 0x828DA59C; continue 'dispatch;
	}
	// 828DA58C: 897F0041  lbz r11, 0x41(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(65 as u32) ) } as u64;
	// 828DA590: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828DA594: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828DA598: 692B0001  xori r11, r9, 1
	ctx.r[11].u64 = ctx.r[9].u64 ^ 1;
	// 828DA59C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DA5A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA5A4: 409A000C  bne cr6, 0x828da5b0
	if !ctx.cr[6].eq {
	pc = 0x828DA5B0; continue 'dispatch;
	}
	// 828DA5A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828DA5AC: 480000DC  b 0x828da688
	pc = 0x828DA688; continue 'dispatch;
	// 828DA5B0: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 828DA5B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA5B8: 419AFFF0  beq cr6, 0x828da5a8
	if ctx.cr[6].eq {
	pc = 0x828DA5A8; continue 'dispatch;
	}
	// 828DA5BC: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 828DA5C0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DA5C4: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828DA5C8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828DA5CC: 409AFFDC  bne cr6, 0x828da5a8
	if !ctx.cr[6].eq {
	pc = 0x828DA5A8; continue 'dispatch;
	}
	// 828DA5D0: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 828DA5D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DA5D8: 419A0014  beq cr6, 0x828da5ec
	if ctx.cr[6].eq {
	pc = 0x828DA5EC; continue 'dispatch;
	}
	// 828DA5DC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828DA5E0: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 828DA5E4: 7D4B1E71  srawi. r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DA5E8: 40820008  bne 0x828da5f0
	if !ctx.cr[0].eq {
	pc = 0x828DA5F0; continue 'dispatch;
	}
	// 828DA5EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DA5F0: 4B899849  bl 0x82173e38
	ctx.lr = 0x828DA5F4;
	sub_82173E38(ctx, base);
	// 828DA5F4: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828DA5F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DA5FC: 419A0018  beq cr6, 0x828da614
	if ctx.cr[6].eq {
	pc = 0x828DA614; continue 'dispatch;
	}
	// 828DA600: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DA604: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DA608: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DA60C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DA610: 409A0008  bne cr6, 0x828da618
	if !ctx.cr[6].eq {
	pc = 0x828DA618; continue 'dispatch;
	}
	// 828DA614: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DA618: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DA61C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA620: 419AFF88  beq cr6, 0x828da5a8
	if ctx.cr[6].eq {
	pc = 0x828DA5A8; continue 'dispatch;
	}
	// 828DA624: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 828DA628: 3BDF0034  addi r30, r31, 0x34
	ctx.r[30].s64 = ctx.r[31].s64 + 52;
	// 828DA62C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828DA630: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828DA634: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 828DA638: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828DA63C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DA640: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828DA644: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828DA648: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828DA64C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA650: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 828DA654: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828DA658: 480017B9  bl 0x828dbe10
	ctx.lr = 0x828DA65C;
	sub_828DBE10(ctx, base);
	// 828DA65C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA660: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA664: 419A000C  beq cr6, 0x828da670
	if ctx.cr[6].eq {
	pc = 0x828DA670; continue 'dispatch;
	}
	// 828DA668: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828DA66C: 419A0008  beq cr6, 0x828da674
	if ctx.cr[6].eq {
	pc = 0x828DA674; continue 'dispatch;
	}
	// 828DA670: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DA674: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DA678: 7D4BF850  subf r10, r11, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 828DA67C: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 828DA680: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 828DA684: 69030001  xori r3, r8, 1
	ctx.r[3].u64 = ctx.r[8].u64 ^ 1;
	// 828DA688: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DA68C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DA690: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DA694: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DA698: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DA69C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DA6A0 size=420
    let mut pc: u32 = 0x828DA6A0;
    'dispatch: loop {
        match pc {
            0x828DA6A0 => {
    //   block [0x828DA6A0..0x828DA844)
	// 828DA6A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DA6A4: 483CED65  bl 0x82ca9408
	ctx.lr = 0x828DA6A8;
	sub_82CA93D0(ctx, base);
	// 828DA6A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DA6AC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828DA6B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DA6B4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828DA6B8: 419A0018  beq cr6, 0x828da6d0
	if ctx.cr[6].eq {
	pc = 0x828DA6D0; continue 'dispatch;
	}
	// 828DA6BC: 897C0090  lbz r11, 0x90(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DA6C0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DA6C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DA6C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DA6CC: 409A0008  bne cr6, 0x828da6d4
	if !ctx.cr[6].eq {
	pc = 0x828DA6D4; continue 'dispatch;
	}
	// 828DA6D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DA6D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DA6D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA6DC: 419A015C  beq cr6, 0x828da838
	if ctx.cr[6].eq {
	pc = 0x828DA838; continue 'dispatch;
	}
	// 828DA6E0: 897E0040  lbz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 828DA6E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA6E8: 419A0014  beq cr6, 0x828da6fc
	if ctx.cr[6].eq {
	pc = 0x828DA6FC; continue 'dispatch;
	}
	// 828DA6EC: 897E0041  lbz r11, 0x41(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(65 as u32) ) } as u64;
	// 828DA6F0: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828DA6F4: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828DA6F8: 692B0001  xori r11, r9, 1
	ctx.r[11].u64 = ctx.r[9].u64 ^ 1;
	// 828DA6FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DA700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA704: 419A0134  beq cr6, 0x828da838
	if ctx.cr[6].eq {
	pc = 0x828DA838; continue 'dispatch;
	}
	// 828DA708: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DA70C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DA710: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 828DA714: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA718: 419A0120  beq cr6, 0x828da838
	if ctx.cr[6].eq {
	pc = 0x828DA838; continue 'dispatch;
	}
	// 828DA71C: 815E002C  lwz r10, 0x2c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 828DA720: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DA724: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828DA728: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828DA72C: 4098010C  bge cr6, 0x828da838
	if !ctx.cr[6].lt {
	pc = 0x828DA838; continue 'dispatch;
	}
	// 828DA730: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 828DA734: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA738: 419A0018  beq cr6, 0x828da750
	if ctx.cr[6].eq {
	pc = 0x828DA750; continue 'dispatch;
	}
	// 828DA73C: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828DA740: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DA744: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828DA748: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828DA74C: 41980008  blt cr6, 0x828da754
	if ctx.cr[6].lt {
	pc = 0x828DA754; continue 'dispatch;
	}
	// 828DA750: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DA754: 7C7D5A14  add r3, r29, r11
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 828DA758: 4B8996E1  bl 0x82173e38
	ctx.lr = 0x828DA75C;
	sub_82173E38(ctx, base);
	// 828DA75C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828DA760: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DA764: 419A0018  beq cr6, 0x828da77c
	if ctx.cr[6].eq {
	pc = 0x828DA77C; continue 'dispatch;
	}
	// 828DA768: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DA76C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DA770: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DA774: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DA778: 409A0008  bne cr6, 0x828da780
	if !ctx.cr[6].eq {
	pc = 0x828DA780; continue 'dispatch;
	}
	// 828DA77C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DA780: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DA784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA788: 419A0038  beq cr6, 0x828da7c0
	if ctx.cr[6].eq {
	pc = 0x828DA7C0; continue 'dispatch;
	}
	// 828DA78C: 817C0014  lwz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 828DA790: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 828DA794: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828DA798: 409A0018  bne cr6, 0x828da7b0
	if !ctx.cr[6].eq {
	pc = 0x828DA7B0; continue 'dispatch;
	}
	// 828DA79C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 828DA7A0: 815C0018  lwz r10, 0x18(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 828DA7A4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828DA7A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DA7AC: 419A0008  beq cr6, 0x828da7b4
	if ctx.cr[6].eq {
	pc = 0x828DA7B4; continue 'dispatch;
	}
	// 828DA7B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DA7B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DA7B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA7BC: 409A0010  bne cr6, 0x828da7cc
	if !ctx.cr[6].eq {
	pc = 0x828DA7CC; continue 'dispatch;
	}
	// 828DA7C0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828DA7C4: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828DA7C8: 4BFFFF48  b 0x828da710
	pc = 0x828DA710; continue 'dispatch;
	// 828DA7CC: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 828DA7D0: 3BFE0034  addi r31, r30, 0x34
	ctx.r[31].s64 = ctx.r[30].s64 + 52;
	// 828DA7D4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828DA7D8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828DA7DC: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828DA7E0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DA7E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DA7E8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828DA7EC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828DA7F0: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828DA7F4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA7F8: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 828DA7FC: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828DA800: 48001611  bl 0x828dbe10
	ctx.lr = 0x828DA804;
	sub_828DBE10(ctx, base);
	// 828DA804: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA808: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA80C: 419A000C  beq cr6, 0x828da818
	if ctx.cr[6].eq {
	pc = 0x828DA818; continue 'dispatch;
	}
	// 828DA810: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828DA814: 419A0008  beq cr6, 0x828da81c
	if ctx.cr[6].eq {
	pc = 0x828DA81C; continue 'dispatch;
	}
	// 828DA818: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DA81C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DA820: 7D4BF050  subf r10, r11, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 828DA824: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 828DA828: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 828DA82C: 69030001  xori r3, r8, 1
	ctx.r[3].u64 = ctx.r[8].u64 ^ 1;
	// 828DA830: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828DA834: 483CEC24  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 828DA838: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828DA83C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828DA840: 483CEC18  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DA848 size=48
    let mut pc: u32 = 0x828DA848;
    'dispatch: loop {
        match pc {
            0x828DA848 => {
    //   block [0x828DA848..0x828DA878)
	// 828DA848: 89630040  lbz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 828DA84C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA850: 419A0014  beq cr6, 0x828da864
	if ctx.cr[6].eq {
	pc = 0x828DA864; continue 'dispatch;
	}
	// 828DA854: 89630041  lbz r11, 0x41(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(65 as u32) ) } as u64;
	// 828DA858: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828DA85C: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828DA860: 692B0001  xori r11, r9, 1
	ctx.r[11].u64 = ctx.r[9].u64 ^ 1;
	// 828DA864: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DA868: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA86C: 409A000C  bne cr6, 0x828da878
	if !ctx.cr[6].eq {
		sub_828DA878(ctx, base);
		return;
	}
	// 828DA870: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828DA874: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DA878 size=20
    let mut pc: u32 = 0x828DA878;
    'dispatch: loop {
        match pc {
            0x828DA878 => {
    //   block [0x828DA878..0x828DA88C)
	// 828DA878: 8163003C  lwz r11, 0x3c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 828DA87C: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828DA880: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828DA884: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 828DA888: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DA890 size=48
    let mut pc: u32 = 0x828DA890;
    'dispatch: loop {
        match pc {
            0x828DA890 => {
    //   block [0x828DA890..0x828DA8C0)
	// 828DA890: 89630040  lbz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 828DA894: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA898: 419A0014  beq cr6, 0x828da8ac
	if ctx.cr[6].eq {
	pc = 0x828DA8AC; continue 'dispatch;
	}
	// 828DA89C: 89630041  lbz r11, 0x41(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(65 as u32) ) } as u64;
	// 828DA8A0: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828DA8A4: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828DA8A8: 692B0001  xori r11, r9, 1
	ctx.r[11].u64 = ctx.r[9].u64 ^ 1;
	// 828DA8AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DA8B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA8B4: 409A000C  bne cr6, 0x828da8c0
	if !ctx.cr[6].eq {
		sub_828DA8C0(ctx, base);
		return;
	}
	// 828DA8B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828DA8BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA8C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DA8C0 size=32
    let mut pc: u32 = 0x828DA8C0;
    'dispatch: loop {
        match pc {
            0x828DA8C0 => {
    //   block [0x828DA8C0..0x828DA8E0)
	// 828DA8C0: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 828DA8C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA8C8: 409A0018  bne cr6, 0x828da8e0
	if !ctx.cr[6].eq {
		sub_828DA8E0(ctx, base);
		return;
	}
	// 828DA8CC: 8143003C  lwz r10, 0x3c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 828DA8D0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DA8D4: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828DA8D8: 5503DFFE  rlwinm r3, r8, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 828DA8DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DA8E0 size=32
    let mut pc: u32 = 0x828DA8E0;
    'dispatch: loop {
        match pc {
            0x828DA8E0 => {
    //   block [0x828DA8E0..0x828DA900)
	// 828DA8E0: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 828DA8E4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DA8E8: 8143003C  lwz r10, 0x3c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 828DA8EC: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828DA8F0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DA8F4: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828DA8F8: 5503DFFE  rlwinm r3, r8, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 828DA8FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DA900 size=224
    let mut pc: u32 = 0x828DA900;
    'dispatch: loop {
        match pc {
            0x828DA900 => {
    //   block [0x828DA900..0x828DA9E0)
	// 828DA900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DA904: 483CEB09  bl 0x82ca940c
	ctx.lr = 0x828DA908;
	sub_82CA93D0(ctx, base);
	// 828DA908: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DA90C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DA910: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828DA914: 419A0018  beq cr6, 0x828da92c
	if ctx.cr[6].eq {
	pc = 0x828DA92C; continue 'dispatch;
	}
	// 828DA918: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DA91C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DA920: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DA924: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DA928: 409A0008  bne cr6, 0x828da930
	if !ctx.cr[6].eq {
	pc = 0x828DA930; continue 'dispatch;
	}
	// 828DA92C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DA930: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DA934: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA938: 419A009C  beq cr6, 0x828da9d4
	if ctx.cr[6].eq {
	pc = 0x828DA9D4; continue 'dispatch;
	}
	// 828DA93C: 8084007C  lwz r4, 0x7c(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(124 as u32) ) } as u64;
	// 828DA940: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA944: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA948: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 828DA94C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828DA950: 4E800421  bctrl
	ctx.lr = 0x828DA954;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DA954: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DA958: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DA95C: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828DA960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA964: 419A0070  beq cr6, 0x828da9d4
	if ctx.cr[6].eq {
	pc = 0x828DA9D4; continue 'dispatch;
	}
	// 828DA968: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 828DA96C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DA970: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828DA974: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828DA978: 4098005C  bge cr6, 0x828da9d4
	if !ctx.cr[6].lt {
	pc = 0x828DA9D4; continue 'dispatch;
	}
	// 828DA97C: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828DA980: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA984: 419A0018  beq cr6, 0x828da99c
	if ctx.cr[6].eq {
	pc = 0x828DA99C; continue 'dispatch;
	}
	// 828DA988: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828DA98C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DA990: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828DA994: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828DA998: 41980008  blt cr6, 0x828da9a0
	if ctx.cr[6].lt {
	pc = 0x828DA9A0; continue 'dispatch;
	}
	// 828DA99C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DA9A0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828DA9A4: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA9E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DA9E0 size=156
    let mut pc: u32 = 0x828DA9E0;
    'dispatch: loop {
        match pc {
            0x828DA9E0 => {
    //   block [0x828DA9E0..0x828DAA7C)
	// 828DA9E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DA9E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DA9E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DA9EC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DA9F0: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 828DA9F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DA9F8: 38E30014  addi r7, r3, 0x14
	ctx.r[7].s64 = ctx.r[3].s64 + 20;
	// 828DA9FC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828DAA00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DAA04: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828DAA08: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 828DAA0C: 81486AB8  lwz r10, 0x6ab8(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828DAA10: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828DAA14: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 828DAA18: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828DAA1C: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 828DAA20: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 828DAA24: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 828DAA28: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DAA2C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828DAA30: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DAA34: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DAA38: 8068000C  lwz r3, 0xc(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 828DAA3C: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 828DAA40: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828DAA44: 4800147D  bl 0x828dbec0
	ctx.lr = 0x828DAA48;
	sub_828DBEC0(ctx, base);
	// 828DAA48: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828DAA4C: 80E10068  lwz r7, 0x68(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828DAA50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DAA54: 7CC33850  subf r6, r3, r7
	ctx.r[6].s64 = ctx.r[7].s64 - ctx.r[3].s64;
	// 828DAA58: 7CDF1670  srawi r31, r6, 2
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[6].s32 >> 2) as i64;
	// 828DAA5C: 419A0008  beq cr6, 0x828daa64
	if ctx.cr[6].eq {
	pc = 0x828DAA64; continue 'dispatch;
	}
	// 828DAA60: 4B9412D9  bl 0x8221bd38
	ctx.lr = 0x828DAA64;
	sub_8221BD38(ctx, base);
	// 828DAA64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DAA68: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DAA6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DAA70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DAA74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DAA78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DAA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DAA80 size=96
    let mut pc: u32 = 0x828DAA80;
    'dispatch: loop {
        match pc {
            0x828DAA80 => {
    //   block [0x828DAA80..0x828DAAE0)
	// 828DAA80: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 828DAA84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DAA88: 419A0190  beq cr6, 0x828dac18
	if ctx.cr[6].eq {
		sub_828DAC18(ctx, base);
		return;
	}
	// 828DAA8C: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 828DAA90: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DAA94: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DAA98: 41820180  beq 0x828dac18
	if ctx.cr[0].eq {
		sub_828DAC18(ctx, base);
		return;
	}
	// 828DAA9C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DAAA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DAAA4: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828DAAA8: 5528F7FE  rlwinm r8, r9, 0x1e, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 828DAAAC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828DAAB0: 419A00F8  beq cr6, 0x828daba8
	if ctx.cr[6].eq {
		sub_828DABA8(ctx, base);
		return;
	}
	// 828DAAB4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828DAAB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DAABC: 419A0024  beq cr6, 0x828daae0
	if ctx.cr[6].eq {
		sub_828DAAE0(ctx, base);
		return;
	}
	// 828DAAC0: 894A0002  lbz r10, 2(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 828DAAC4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DAAC8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828DAACC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828DAAD0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DAAD4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828DAAD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DAADC: 480000D0  b 0x828dabac
	sub_828DABA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DAAE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DAAE0 size=92
    let mut pc: u32 = 0x828DAAE0;
    'dispatch: loop {
        match pc {
            0x828DAAE0 => {
    //   block [0x828DAAE0..0x828DAB3C)
	// 828DAAE0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DAAE4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828DAAE8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828DAAEC: 9121FFE0  stw r9, -0x20(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[9].u32 ) };
	// 828DAAF0: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828DAAF4: 9141FFE4  stw r10, -0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), ctx.r[10].u32 ) };
	// 828DAAF8: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DAAFC: 40810054  ble 0x828dab50
	if !ctx.cr[0].gt {
		sub_828DAB3C(ctx, base);
		return;
	}
	// 828DAB00: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828DAB04: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828DAB08: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828DAB0C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DAB10: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 828DAB14: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828DAB18: 41980008  blt cr6, 0x828dab20
	if ctx.cr[6].lt {
	pc = 0x828DAB20; continue 'dispatch;
	}
	// 828DAB1C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828DAB20: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828DAB24: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828DAB28: 419A0014  beq cr6, 0x828dab3c
	if ctx.cr[6].eq {
		sub_828DAB3C(ctx, base);
		return;
	}
	// 828DAB2C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828DAB30: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828DAB34: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DAB38: 4800000C  b 0x828dab44
	sub_828DAB3C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DAB3C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DAB3C size=88
    let mut pc: u32 = 0x828DAB3C;
    'dispatch: loop {
        match pc {
            0x828DAB3C => {
    //   block [0x828DAB3C..0x828DAB94)
	// 828DAB3C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828DAB40: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828DAB44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DAB48: 4199FFB8  bgt cr6, 0x828dab00
	if ctx.cr[6].gt {
		sub_828DAAE0(ctx, base);
		return;
	}
	// 828DAB4C: 9141FFE4  stw r10, -0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), ctx.r[10].u32 ) };
	// 828DAB50: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828DAB54: 419A0040  beq cr6, 0x828dab94
	if ctx.cr[6].eq {
		sub_828DAB94(ctx, base);
		return;
	}
	// 828DAB58: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DAB5C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 828DAB60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DAB64: 41990008  bgt cr6, 0x828dab6c
	if ctx.cr[6].gt {
	pc = 0x828DAB6C; continue 'dispatch;
	}
	// 828DAB68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DAB6C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DAB70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DAB74: 409A0020  bne cr6, 0x828dab94
	if !ctx.cr[6].eq {
		sub_828DAB94(ctx, base);
		return;
	}
	// 828DAB78: E961FFE0  ld r11, -0x20(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828DAB7C: F961FFE0  std r11, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[11].u64 ) };
	// 828DAB80: 8161FFE4  lwz r11, -0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-28 as u32) ) } as u64;
	// 828DAB84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DAB88: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828DAB8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DAB90: 4800001C  b 0x828dabac
	sub_828DABA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DAB94(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DAB94 size=20
    let mut pc: u32 = 0x828DAB94;
    'dispatch: loop {
        match pc {
            0x828DAB94 => {
    //   block [0x828DAB94..0x828DABA8)
	// 828DAB94: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828DAB98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DAB9C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828DABA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DABA4: 48000008  b 0x828dabac
	sub_828DABA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DABA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DABA8 size=112
    let mut pc: u32 = 0x828DABA8;
    'dispatch: loop {
        match pc {
            0x828DABA8 => {
    //   block [0x828DABA8..0x828DAC18)
	// 828DABA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DABAC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DABB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DABB4: 419A0064  beq cr6, 0x828dac18
	if ctx.cr[6].eq {
		sub_828DAC18(ctx, base);
		return;
	}
	// 828DABB8: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 828DABBC: 3921FFE0  addi r9, r1, -0x20
	ctx.r[9].s64 = ctx.r[1].s64 + -32;
	// 828DABC0: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 828DABC4: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 828DABC8: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DAC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828DAC18 size=16
    let mut pc: u32 = 0x828DAC18;
    'dispatch: loop {
        match pc {
            0x828DAC18 => {
    //   block [0x828DAC18..0x828DAC28)
	// 828DAC18: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828DAC1C: 394B92D4  addi r10, r11, -0x6d2c
	ctx.r[10].s64 = ctx.r[11].s64 + -27948;
	// 828DAC20: C02A01B0  lfs f1, 0x1b0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(432 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DAC24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DAC28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DAC28 size=484
    let mut pc: u32 = 0x828DAC28;
    'dispatch: loop {
        match pc {
            0x828DAC28 => {
    //   block [0x828DAC28..0x828DAE0C)
	// 828DAC28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DAC2C: 483CE7D1  bl 0x82ca93fc
	ctx.lr = 0x828DAC30;
	sub_82CA93D0(ctx, base);
	// 828DAC30: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DAE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DAE10 size=200
    let mut pc: u32 = 0x828DAE10;
    'dispatch: loop {
        match pc {
            0x828DAE10 => {
    //   block [0x828DAE10..0x828DAED8)
	// 828DAE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DAE14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DAE18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DAE1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DAE20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DAE24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DAE28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DAE2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DAE30: 4B8FF581  bl 0x821da3b0
	ctx.lr = 0x828DAE34;
	sub_821DA3B0(ctx, base);
	// 828DAE34: 4B8D76C5  bl 0x821b24f8
	ctx.lr = 0x828DAE38;
	sub_821B24F8(ctx, base);
	// 828DAE38: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828DAE3C: 388B3AA4  addi r4, r11, 0x3aa4
	ctx.r[4].s64 = ctx.r[11].s64 + 15012;
	// 828DAE40: 4BA35451  bl 0x82310290
	ctx.lr = 0x828DAE44;
	sub_82310290(ctx, base);
	// 828DAE44: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828DAE48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DAE4C: 419A0074  beq cr6, 0x828daec0
	if ctx.cr[6].eq {
	pc = 0x828DAEC0; continue 'dispatch;
	}
	// 828DAE50: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828DAE54: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828DAE58: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828DAE5C: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DAE60: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DAE64: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DAE68: 4B951351  bl 0x8222c1b8
	ctx.lr = 0x828DAE6C;
	sub_8222C1B8(ctx, base);
	// 828DAE6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DAE70: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DAE74: 419A0018  beq cr6, 0x828dae8c
	if ctx.cr[6].eq {
	pc = 0x828DAE8C; continue 'dispatch;
	}
	// 828DAE78: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DAE7C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DAE80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DAE84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DAE88: 409A0008  bne cr6, 0x828dae90
	if !ctx.cr[6].eq {
	pc = 0x828DAE90; continue 'dispatch;
	}
	// 828DAE8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DAE90: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DAE94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DAE98: 419A0028  beq cr6, 0x828daec0
	if ctx.cr[6].eq {
	pc = 0x828DAEC0; continue 'dispatch;
	}
	// 828DAE9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DAEA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DAEA4: 4BFFF7FD  bl 0x828da6a0
	ctx.lr = 0x828DAEA8;
	sub_828DA6A0(ctx, base);
	// 828DAEA8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828DAEAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DAEB0: 419A0010  beq cr6, 0x828daec0
	if ctx.cr[6].eq {
	pc = 0x828DAEC0; continue 'dispatch;
	}
	// 828DAEB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DAEB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DAEBC: 480003C5  bl 0x828db280
	ctx.lr = 0x828DAEC0;
	sub_828DB280(ctx, base);
	// 828DAEC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DAEC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DAEC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DAECC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DAED0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DAED4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DAED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DAED8 size=380
    let mut pc: u32 = 0x828DAED8;
    'dispatch: loop {
        match pc {
            0x828DAED8 => {
    //   block [0x828DAED8..0x828DB054)
	// 828DAED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DAEDC: 483CE521  bl 0x82ca93fc
	ctx.lr = 0x828DAEE0;
	sub_82CA93D0(ctx, base);
	// 828DAEE0: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828DAEE4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DAEE8: 3F20834C  lis r25, -0x7cb4
	ctx.r[25].s64 = -2092171264;
	// 828DAEEC: 8979EBCA  lbz r11, -0x1436(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(-5174 as u32) ) } as u64;
	// 828DAEF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DAEF4: 409A0154  bne cr6, 0x828db048
	if !ctx.cr[6].eq {
	pc = 0x828DB048; continue 'dispatch;
	}
	// 828DAEF8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828DAEFC: 3B6BC87C  addi r27, r11, -0x3784
	ctx.r[27].s64 = ctx.r[11].s64 + -14212;
	// 828DAF00: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DAF04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DAF08: 419A0138  beq cr6, 0x828db040
	if ctx.cr[6].eq {
	pc = 0x828DB040; continue 'dispatch;
	}
	// 828DAF0C: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DAF10: 3B40000C  li r26, 0xc
	ctx.r[26].s64 = 12;
	// 828DAF14: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DAF18: 7D09D3D7  divw. r8, r9, r26
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828DAF1C: 41820124  beq 0x828db040
	if ctx.cr[0].eq {
	pc = 0x828DB040; continue 'dispatch;
	}
	// 828DAF20: 392000FF  li r9, 0xff
	ctx.r[9].s64 = 255;
	// 828DAF24: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 828DAF28: 9921007A  stb r9, 0x7a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(122 as u32), ctx.r[9].u8 ) };
	// 828DAF2C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DAF30: 99210079  stb r9, 0x79(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(121 as u32), ctx.r[9].u8 ) };
	// 828DAF34: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 828DAF38: 99210078  stb r9, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[9].u8 ) };
	// 828DAF3C: 38C84C64  addi r6, r8, 0x4c64
	ctx.r[6].s64 = ctx.r[8].s64 + 19556;
	// 828DAF40: 9921007B  stb r9, 0x7b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(123 as u32), ctx.r[9].u8 ) };
	// 828DAF44: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 828DAF48: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 828DAF4C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 828DAF50: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 828DAF54: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 828DAF58: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 828DAF5C: 3BA00008  li r29, 8
	ctx.r[29].s64 = 8;
	// 828DAF60: 9BE1007C  stb r31, 0x7c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u8 ) };
	// 828DAF64: C3E99484  lfs f31, -0x6b7c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828DAF68: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 828DAF6C: 90C10060  stw r6, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[6].u32 ) };
	// 828DAF70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DAF74: 419A0094  beq cr6, 0x828db008
	if ctx.cr[6].eq {
	pc = 0x828DB008; continue 'dispatch;
	}
	// 828DAF78: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DAF7C: 7D4AD3D6  divw r10, r10, r26
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	// 828DAF80: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828DAF84: 40980084  bge cr6, 0x828db008
	if !ctx.cr[6].lt {
	pc = 0x828DB008; continue 'dispatch;
	}
	// 828DAF88: 7D3F5A14  add r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[11].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DB058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DB058 size=244
    let mut pc: u32 = 0x828DB058;
    'dispatch: loop {
        match pc {
            0x828DB058 => {
    //   block [0x828DB058..0x828DB14C)
	// 828DB058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DB05C: 483CE3AD  bl 0x82ca9408
	ctx.lr = 0x828DB060;
	sub_82CA93D0(ctx, base);
	// 828DB060: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DB064: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828DB068: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DB06C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DB070: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DB074: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828DB078: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB07C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828DB080: 809D007C  lwz r4, 0x7c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 828DB084: 810A0058  lwz r8, 0x58(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DB088: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DB08C: 80C80004  lwz r6, 4(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB090: 80E90040  lwz r7, 0x40(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 828DB094: 83860010  lwz r28, 0x10(r6)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 828DB098: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 828DB09C: 4E800421  bctrl
	ctx.lr = 0x828DB0A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DB0A0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828DB0A4: 39000065  li r8, 0x65
	ctx.r[8].s64 = 101;
	// 828DB0A8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828DB0AC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828DB0B0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828DB0B4: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 828DB0B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DB0BC: 4B99EAC5  bl 0x82279b80
	ctx.lr = 0x828DB0C0;
	sub_82279B80(ctx, base);
	// 828DB0C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DB0C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DB0C8: 4B8FF2E9  bl 0x821da3b0
	ctx.lr = 0x828DB0CC;
	sub_821DA3B0(ctx, base);
	// 828DB0CC: 4B8D742D  bl 0x821b24f8
	ctx.lr = 0x828DB0D0;
	sub_821B24F8(ctx, base);
	// 828DB0D0: 3CA0820E  lis r5, -0x7df2
	ctx.r[5].s64 = -2113011712;
	// 828DB0D4: 38853AA4  addi r4, r5, 0x3aa4
	ctx.r[4].s64 = ctx.r[5].s64 + 15012;
	// 828DB0D8: 4BA351B9  bl 0x82310290
	ctx.lr = 0x828DB0DC;
	sub_82310290(ctx, base);
	// 828DB0DC: 5464063E  clrlwi r4, r3, 0x18
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828DB0E0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828DB0E4: 419A0010  beq cr6, 0x828db0f4
	if ctx.cr[6].eq {
	pc = 0x828DB0F4; continue 'dispatch;
	}
	// 828DB0E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DB0EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB0F0: 48000061  bl 0x828db150
	ctx.lr = 0x828DB0F4;
	sub_828DB150(ctx, base);
	// 828DB0F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DB0F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DB0FC: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 828DB100: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DB104: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DB108: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828DB10C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB110: 4B939789  bl 0x82214898
	ctx.lr = 0x828DB114;
	sub_82214898(ctx, base);
	// 828DB114: 811F0038  lwz r8, 0x38(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 828DB118: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 828DB11C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DB120: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 828DB124: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 828DB128: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828DB12C: 4BB7AFED  bl 0x82456118
	ctx.lr = 0x828DB130;
	sub_82456118(ctx, base);
	// 828DB130: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 828DB134: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB138: 38C70B7C  addi r6, r7, 0xb7c
	ctx.r[6].s64 = ctx.r[7].s64 + 2940;
	// 828DB13C: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 828DB140: 4B8B8CF9  bl 0x82193e38
	ctx.lr = 0x828DB144;
	sub_82193E38(ctx, base);
	// 828DB144: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828DB148: 483CE310  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DB150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DB150 size=300
    let mut pc: u32 = 0x828DB150;
    'dispatch: loop {
        match pc {
            0x828DB150 => {
    //   block [0x828DB150..0x828DB27C)
	// 828DB150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DB154: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DB158: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DB15C: 81440028  lwz r10, 0x28(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 828DB160: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DB164: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 828DB168: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828DB16C: 419A00E8  beq cr6, 0x828db254
	if ctx.cr[6].eq {
	pc = 0x828DB254; continue 'dispatch;
	}
	// 828DB170: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828DB174: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DB178: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DB17C: 419A001C  beq cr6, 0x828db198
	if ctx.cr[6].eq {
	pc = 0x828DB198; continue 'dispatch;
	}
	// 828DB180: 896B0021  lbz r11, 0x21(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828DB184: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828DB188: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828DB18C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB190: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DB194: 480000C4  b 0x828db258
	pc = 0x828DB258; continue 'dispatch;
	// 828DB198: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828DB19C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DB1A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DB1A4: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828DB1A8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828DB1AC: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DB1B0: 40810054  ble 0x828db204
	if !ctx.cr[0].gt {
	pc = 0x828DB204; continue 'dispatch;
	}
	// 828DB1B4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828DB1B8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828DB1BC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828DB1C0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DB1C4: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 828DB1C8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828DB1CC: 41980008  blt cr6, 0x828db1d4
	if ctx.cr[6].lt {
	pc = 0x828DB1D4; continue 'dispatch;
	}
	// 828DB1D0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828DB1D4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828DB1D8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828DB1DC: 419A0014  beq cr6, 0x828db1f0
	if ctx.cr[6].eq {
	pc = 0x828DB1F0; continue 'dispatch;
	}
	// 828DB1E0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828DB1E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828DB1E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DB1EC: 4800000C  b 0x828db1f8
	pc = 0x828DB1F8; continue 'dispatch;
	// 828DB1F0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828DB1F4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828DB1F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DB1FC: 4199FFB8  bgt cr6, 0x828db1b4
	if ctx.cr[6].gt {
	pc = 0x828DB1B4; continue 'dispatch;
	}
	// 828DB200: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DB204: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828DB208: 419A003C  beq cr6, 0x828db244
	if ctx.cr[6].eq {
	pc = 0x828DB244; continue 'dispatch;
	}
	// 828DB20C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DB210: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 828DB214: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DB218: 41990008  bgt cr6, 0x828db220
	if ctx.cr[6].gt {
	pc = 0x828DB220; continue 'dispatch;
	}
	// 828DB21C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DB220: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DB224: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DB228: 409A001C  bne cr6, 0x828db244
	if !ctx.cr[6].eq {
	pc = 0x828DB244; continue 'dispatch;
	}
	// 828DB22C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828DB230: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DB234: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828DB238: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DB23C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB240: 48000018  b 0x828db258
	pc = 0x828DB258; continue 'dispatch;
	// 828DB244: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828DB248: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DB24C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB250: 48000008  b 0x828db258
	pc = 0x828DB258; continue 'dispatch;
	// 828DB254: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DB258: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828DB25C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DB260: 419A000C  beq cr6, 0x828db26c
	if ctx.cr[6].eq {
	pc = 0x828DB26C; continue 'dispatch;
	}
	// 828DB264: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828DB268: 4BB08271  bl 0x823e34d8
	ctx.lr = 0x828DB26C;
	sub_823E34D8(ctx, base);
	// 828DB26C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DB270: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DB274: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DB278: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DB280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DB280 size=300
    let mut pc: u32 = 0x828DB280;
    'dispatch: loop {
        match pc {
            0x828DB280 => {
    //   block [0x828DB280..0x828DB3AC)
	// 828DB280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DB284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DB288: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DB28C: 81440028  lwz r10, 0x28(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 828DB290: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DB294: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 828DB298: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828DB29C: 419A00E8  beq cr6, 0x828db384
	if ctx.cr[6].eq {
	pc = 0x828DB384; continue 'dispatch;
	}
	// 828DB2A0: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828DB2A4: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DB2A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DB2AC: 419A001C  beq cr6, 0x828db2c8
	if ctx.cr[6].eq {
	pc = 0x828DB2C8; continue 'dispatch;
	}
	// 828DB2B0: 896B0021  lbz r11, 0x21(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828DB2B4: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828DB2B8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828DB2BC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB2C0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DB2C4: 480000C4  b 0x828db388
	pc = 0x828DB388; continue 'dispatch;
	// 828DB2C8: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828DB2CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DB2D0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DB2D4: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828DB2D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828DB2DC: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DB2E0: 40810054  ble 0x828db334
	if !ctx.cr[0].gt {
	pc = 0x828DB334; continue 'dispatch;
	}
	// 828DB2E4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828DB2E8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828DB2EC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828DB2F0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DB2F4: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 828DB2F8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828DB2FC: 41980008  blt cr6, 0x828db304
	if ctx.cr[6].lt {
	pc = 0x828DB304; continue 'dispatch;
	}
	// 828DB300: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828DB304: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828DB308: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828DB30C: 419A0014  beq cr6, 0x828db320
	if ctx.cr[6].eq {
	pc = 0x828DB320; continue 'dispatch;
	}
	// 828DB310: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828DB314: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828DB318: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DB31C: 4800000C  b 0x828db328
	pc = 0x828DB328; continue 'dispatch;
	// 828DB320: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828DB324: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828DB328: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DB32C: 4199FFB8  bgt cr6, 0x828db2e4
	if ctx.cr[6].gt {
	pc = 0x828DB2E4; continue 'dispatch;
	}
	// 828DB330: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DB334: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828DB338: 419A003C  beq cr6, 0x828db374
	if ctx.cr[6].eq {
	pc = 0x828DB374; continue 'dispatch;
	}
	// 828DB33C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DB340: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 828DB344: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DB348: 41990008  bgt cr6, 0x828db350
	if ctx.cr[6].gt {
	pc = 0x828DB350; continue 'dispatch;
	}
	// 828DB34C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DB350: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DB354: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DB358: 409A001C  bne cr6, 0x828db374
	if !ctx.cr[6].eq {
	pc = 0x828DB374; continue 'dispatch;
	}
	// 828DB35C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828DB360: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DB364: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828DB368: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DB36C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB370: 48000018  b 0x828db388
	pc = 0x828DB388; continue 'dispatch;
	// 828DB374: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828DB378: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DB37C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB380: 48000008  b 0x828db388
	pc = 0x828DB388; continue 'dispatch;
	// 828DB384: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DB388: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828DB38C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DB390: 419A000C  beq cr6, 0x828db39c
	if ctx.cr[6].eq {
	pc = 0x828DB39C; continue 'dispatch;
	}
	// 828DB394: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828DB398: 4BB08291  bl 0x823e3628
	ctx.lr = 0x828DB39C;
	sub_823E3628(ctx, base);
	// 828DB39C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DB3A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DB3A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DB3A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DB3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DB3B0 size=852
    let mut pc: u32 = 0x828DB3B0;
    'dispatch: loop {
        match pc {
            0x828DB3B0 => {
    //   block [0x828DB3B0..0x828DB704)
	// 828DB3B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DB3B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DB3B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DB3BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DB3C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DB3C4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828DB3C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DB3CC: 3BCB886C  addi r30, r11, -0x7794
	ctx.r[30].s64 = ctx.r[11].s64 + -30612;
	// 828DB3D0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB3D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB3D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DB3DC: 4B951AF5  bl 0x8222ced0
	ctx.lr = 0x828DB3E0;
	sub_8222CED0(ctx, base);
	// 828DB3E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB3E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DB3E8: 48000CB9  bl 0x828dc0a0
	ctx.lr = 0x828DB3EC;
	sub_828DC0A0(ctx, base);
	// 828DB3EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB3F0: 4B9399E9  bl 0x82214dd8
	ctx.lr = 0x828DB3F4;
	sub_82214DD8(ctx, base);
	// 828DB3F4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 828DB3F8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB3FC: 388AFF40  addi r4, r10, -0xc0
	ctx.r[4].s64 = ctx.r[10].s64 + -192;
	// 828DB400: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB404: 4B951ACD  bl 0x8222ced0
	ctx.lr = 0x828DB408;
	sub_8222CED0(ctx, base);
	// 828DB408: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DB40C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB410: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB414: 4B951ABD  bl 0x8222ced0
	ctx.lr = 0x828DB418;
	sub_8222CED0(ctx, base);
	// 828DB418: 3D20828E  lis r9, -0x7d72
	ctx.r[9].s64 = -2104623104;
	// 828DB41C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB420: 38C9A3C0  addi r6, r9, -0x5c40
	ctx.r[6].s64 = ctx.r[9].s64 + -23616;
	// 828DB424: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828DB428: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DB42C: 48000EBD  bl 0x828dc2e8
	ctx.lr = 0x828DB430;
	sub_828DC2E8(ctx, base);
	// 828DB430: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB434: 4B9399A5  bl 0x82214dd8
	ctx.lr = 0x828DB438;
	sub_82214DD8(ctx, base);
	// 828DB438: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB43C: 4B93999D  bl 0x82214dd8
	ctx.lr = 0x828DB440;
	sub_82214DD8(ctx, base);
	// 828DB440: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828DB444: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB448: 38883AB0  addi r4, r8, 0x3ab0
	ctx.r[4].s64 = ctx.r[8].s64 + 15024;
	// 828DB44C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB450: 4B951A81  bl 0x8222ced0
	ctx.lr = 0x828DB454;
	sub_8222CED0(ctx, base);
	// 828DB454: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DB458: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB45C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB460: 4B951A71  bl 0x8222ced0
	ctx.lr = 0x828DB464;
	sub_8222CED0(ctx, base);
	// 828DB464: 3CE0828E  lis r7, -0x7d72
	ctx.r[7].s64 = -2104623104;
	// 828DB468: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB46C: 38C7A3E8  addi r6, r7, -0x5c18
	ctx.r[6].s64 = ctx.r[7].s64 + -23576;
	// 828DB470: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DB474: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828DB478: 48001079  bl 0x828dc4f0
	ctx.lr = 0x828DB47C;
	sub_828DC4F0(ctx, base);
	// 828DB47C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB480: 4B939959  bl 0x82214dd8
	ctx.lr = 0x828DB484;
	sub_82214DD8(ctx, base);
	// 828DB484: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB488: 4B939951  bl 0x82214dd8
	ctx.lr = 0x828DB48C;
	sub_82214DD8(ctx, base);
	// 828DB48C: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828DB490: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB494: 38863AD0  addi r4, r6, 0x3ad0
	ctx.r[4].s64 = ctx.r[6].s64 + 15056;
	// 828DB498: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB49C: 4B951A35  bl 0x8222ced0
	ctx.lr = 0x828DB4A0;
	sub_8222CED0(ctx, base);
	// 828DB4A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DB4A4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB4A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB4AC: 4B951A25  bl 0x8222ced0
	ctx.lr = 0x828DB4B0;
	sub_8222CED0(ctx, base);
	// 828DB4B0: 3C80828E  lis r4, -0x7d72
	ctx.r[4].s64 = -2104623104;
	// 828DB4B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB4B8: 38C4A518  addi r6, r4, -0x5ae8
	ctx.r[6].s64 = ctx.r[4].s64 + -23272;
	// 828DB4BC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DB4C0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828DB4C4: 48001235  bl 0x828dc6f8
	ctx.lr = 0x828DB4C8;
	sub_828DC6F8(ctx, base);
	// 828DB4C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB4CC: 4B93990D  bl 0x82214dd8
	ctx.lr = 0x828DB4D0;
	sub_82214DD8(ctx, base);
	// 828DB4D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB4D4: 4B939905  bl 0x82214dd8
	ctx.lr = 0x828DB4D8;
	sub_82214DD8(ctx, base);
	// 828DB4D8: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 828DB4DC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB4E0: 38833AE8  addi r4, r3, 0x3ae8
	ctx.r[4].s64 = ctx.r[3].s64 + 15080;
	// 828DB4E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB4E8: 4B9519E9  bl 0x8222ced0
	ctx.lr = 0x828DB4EC;
	sub_8222CED0(ctx, base);
	// 828DB4EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DB4F0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB4F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB4F8: 4B9519D9  bl 0x8222ced0
	ctx.lr = 0x828DB4FC;
	sub_8222CED0(ctx, base);
	// 828DB4FC: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DB500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB504: 38CBA568  addi r6, r11, -0x5a98
	ctx.r[6].s64 = ctx.r[11].s64 + -23192;
	// 828DB508: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DB50C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828DB510: 480013F1  bl 0x828dc900
	ctx.lr = 0x828DB514;
	sub_828DC900(ctx, base);
	// 828DB514: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB518: 4B9398C1  bl 0x82214dd8
	ctx.lr = 0x828DB51C;
	sub_82214DD8(ctx, base);
	// 828DB51C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB520: 4B9398B9  bl 0x82214dd8
	ctx.lr = 0x828DB524;
	sub_82214DD8(ctx, base);
	// 828DB524: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828DB528: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB52C: 388A3B0C  addi r4, r10, 0x3b0c
	ctx.r[4].s64 = ctx.r[10].s64 + 15116;
	// 828DB530: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB534: 4B95199D  bl 0x8222ced0
	ctx.lr = 0x828DB538;
	sub_8222CED0(ctx, base);
	// 828DB538: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DB53C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB540: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB544: 4B95198D  bl 0x8222ced0
	ctx.lr = 0x828DB548;
	sub_8222CED0(ctx, base);
	// 828DB548: 3D20828E  lis r9, -0x7d72
	ctx.r[9].s64 = -2104623104;
	// 828DB54C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB550: 38C9A6A0  addi r6, r9, -0x5960
	ctx.r[6].s64 = ctx.r[9].s64 + -22880;
	// 828DB554: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DB558: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828DB55C: 480015A5  bl 0x828dcb00
	ctx.lr = 0x828DB560;
	sub_828DCB00(ctx, base);
	// 828DB560: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB564: 4B939875  bl 0x82214dd8
	ctx.lr = 0x828DB568;
	sub_82214DD8(ctx, base);
	// 828DB568: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB56C: 4B93986D  bl 0x82214dd8
	ctx.lr = 0x828DB570;
	sub_82214DD8(ctx, base);
	// 828DB570: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828DB574: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB578: 38883B38  addi r4, r8, 0x3b38
	ctx.r[4].s64 = ctx.r[8].s64 + 15160;
	// 828DB57C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB580: 4B951951  bl 0x8222ced0
	ctx.lr = 0x828DB584;
	sub_8222CED0(ctx, base);
	// 828DB584: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DB588: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB58C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB590: 4B951941  bl 0x8222ced0
	ctx.lr = 0x828DB594;
	sub_8222CED0(ctx, base);
	// 828DB594: 3CE0828E  lis r7, -0x7d72
	ctx.r[7].s64 = -2104623104;
	// 828DB598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB59C: 38C7A848  addi r6, r7, -0x57b8
	ctx.r[6].s64 = ctx.r[7].s64 + -22456;
	// 828DB5A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DB5A4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828DB5A8: 48001359  bl 0x828dc900
	ctx.lr = 0x828DB5AC;
	sub_828DC900(ctx, base);
	// 828DB5AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB5B0: 4B939829  bl 0x82214dd8
	ctx.lr = 0x828DB5B4;
	sub_82214DD8(ctx, base);
	// 828DB5B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB5B8: 4B939821  bl 0x82214dd8
	ctx.lr = 0x828DB5BC;
	sub_82214DD8(ctx, base);
	// 828DB5BC: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828DB5C0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB5C4: 38863B60  addi r4, r6, 0x3b60
	ctx.r[4].s64 = ctx.r[6].s64 + 15200;
	// 828DB5C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB5CC: 4B951905  bl 0x8222ced0
	ctx.lr = 0x828DB5D0;
	sub_8222CED0(ctx, base);
	// 828DB5D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DB5D4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB5D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB5DC: 4B9518F5  bl 0x8222ced0
	ctx.lr = 0x828DB5E0;
	sub_8222CED0(ctx, base);
	// 828DB5E0: 3C80828E  lis r4, -0x7d72
	ctx.r[4].s64 = -2104623104;
	// 828DB5E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB5E8: 38C4A890  addi r6, r4, -0x5770
	ctx.r[6].s64 = ctx.r[4].s64 + -22384;
	// 828DB5EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DB5F0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828DB5F4: 4800130D  bl 0x828dc900
	ctx.lr = 0x828DB5F8;
	sub_828DC900(ctx, base);
	// 828DB5F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB5FC: 4B9397DD  bl 0x82214dd8
	ctx.lr = 0x828DB600;
	sub_82214DD8(ctx, base);
	// 828DB600: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB604: 4B9397D5  bl 0x82214dd8
	ctx.lr = 0x828DB608;
	sub_82214DD8(ctx, base);
	// 828DB608: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 828DB60C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB610: 38833B8C  addi r4, r3, 0x3b8c
	ctx.r[4].s64 = ctx.r[3].s64 + 15244;
	// 828DB614: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB618: 4B9518B9  bl 0x8222ced0
	ctx.lr = 0x828DB61C;
	sub_8222CED0(ctx, base);
	// 828DB61C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DB620: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB624: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB628: 4B9518A9  bl 0x8222ced0
	ctx.lr = 0x828DB62C;
	sub_8222CED0(ctx, base);
	// 828DB62C: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DB630: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB634: 38CBA9E0  addi r6, r11, -0x5620
	ctx.r[6].s64 = ctx.r[11].s64 + -22048;
	// 828DB638: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DB63C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828DB640: 480016C9  bl 0x828dcd08
	ctx.lr = 0x828DB644;
	sub_828DCD08(ctx, base);
	// 828DB644: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB648: 4B939791  bl 0x82214dd8
	ctx.lr = 0x828DB64C;
	sub_82214DD8(ctx, base);
	// 828DB64C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB650: 4B939789  bl 0x82214dd8
	ctx.lr = 0x828DB654;
	sub_82214DD8(ctx, base);
	// 828DB654: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828DB658: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB65C: 388A3BBC  addi r4, r10, 0x3bbc
	ctx.r[4].s64 = ctx.r[10].s64 + 15292;
	// 828DB660: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB664: 4B95186D  bl 0x8222ced0
	ctx.lr = 0x828DB668;
	sub_8222CED0(ctx, base);
	// 828DB668: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DB66C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB670: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB674: 4B95185D  bl 0x8222ced0
	ctx.lr = 0x828DB678;
	sub_8222CED0(ctx, base);
	// 828DB678: 3D20828E  lis r9, -0x7d72
	ctx.r[9].s64 = -2104623104;
	// 828DB67C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB680: 38C9A900  addi r6, r9, -0x5700
	ctx.r[6].s64 = ctx.r[9].s64 + -22272;
	// 828DB684: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DB688: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828DB68C: 48001885  bl 0x828dcf10
	ctx.lr = 0x828DB690;
	sub_828DCF10(ctx, base);
	// 828DB690: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB694: 4B939745  bl 0x82214dd8
	ctx.lr = 0x828DB698;
	sub_82214DD8(ctx, base);
	// 828DB698: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB69C: 4B93973D  bl 0x82214dd8
	ctx.lr = 0x828DB6A0;
	sub_82214DD8(ctx, base);
	// 828DB6A0: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828DB6A4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB6A8: 38883BE0  addi r4, r8, 0x3be0
	ctx.r[4].s64 = ctx.r[8].s64 + 15328;
	// 828DB6AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB6B0: 4B951821  bl 0x8222ced0
	ctx.lr = 0x828DB6B4;
	sub_8222CED0(ctx, base);
	// 828DB6B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DB6B8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DB6BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB6C0: 4B951811  bl 0x8222ced0
	ctx.lr = 0x828DB6C4;
	sub_8222CED0(ctx, base);
	// 828DB6C4: 3CE0828E  lis r7, -0x7d72
	ctx.r[7].s64 = -2104623104;
	// 828DB6C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DB6CC: 38C7AA80  addi r6, r7, -0x5580
	ctx.r[6].s64 = ctx.r[7].s64 + -21888;
	// 828DB6D0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828DB6D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB6D8: 48001A41  bl 0x828dd118
	ctx.lr = 0x828DB6DC;
	sub_828DD118(ctx, base);
	// 828DB6DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB6E0: 4B9396F9  bl 0x82214dd8
	ctx.lr = 0x828DB6E4;
	sub_82214DD8(ctx, base);
	// 828DB6E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB6E8: 4B9396F1  bl 0x82214dd8
	ctx.lr = 0x828DB6EC;
	sub_82214DD8(ctx, base);
	// 828DB6EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DB6F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DB6F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DB6F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DB6FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DB700: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DB708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DB708 size=676
    let mut pc: u32 = 0x828DB708;
    'dispatch: loop {
        match pc {
            0x828DB708 => {
    //   block [0x828DB708..0x828DB9AC)
	// 828DB708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DB70C: 483CDD01  bl 0x82ca940c
	ctx.lr = 0x828DB710;
	sub_82CA93D0(ctx, base);
	// 828DB710: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DB714: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DB718: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DB71C: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828DB720: 419A0280  beq cr6, 0x828db9a0
	if ctx.cr[6].eq {
	pc = 0x828DB9A0; continue 'dispatch;
	}
	// 828DB724: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB728: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DB72C: 419A0018  beq cr6, 0x828db744
	if ctx.cr[6].eq {
	pc = 0x828DB744; continue 'dispatch;
	}
	// 828DB730: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DB734: 7D4B4850  subf r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 828DB738: 7D471E70  srawi r7, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 828DB73C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828DB740: 409A0054  bne cr6, 0x828db794
	if !ctx.cr[6].eq {
	pc = 0x828DB794; continue 'dispatch;
	}
	// 828DB744: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DB748: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB74C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828DB750: 40990008  ble cr6, 0x828db758
	if !ctx.cr[6].gt {
	pc = 0x828DB758; continue 'dispatch;
	}
	// 828DB754: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DB758: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828DB75C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828DB760: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828DB764: 40990008  ble cr6, 0x828db76c
	if !ctx.cr[6].gt {
	pc = 0x828DB76C; continue 'dispatch;
	}
	// 828DB768: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DB76C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DB770: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828DB774: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DB778: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828DB77C: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828DB780: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828DB784: 4825A905  bl 0x82b36088
	ctx.lr = 0x828DB788;
	sub_82B36088(ctx, base);
	// 828DB788: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB78C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828DB790: 483CDCCC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828DB794: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB798: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DB79C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DB7A0: 409A000C  bne cr6, 0x828db7ac
	if !ctx.cr[6].eq {
	pc = 0x828DB7AC; continue 'dispatch;
	}
	// 828DB7A4: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 828DB7A8: 48000010  b 0x828db7b8
	pc = 0x828DB7B8; continue 'dispatch;
	// 828DB7AC: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DB7B0: 7CCA4050  subf r6, r10, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 828DB7B4: 7CC81E70  srawi r8, r6, 3
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[6].s32 >> 3) as i64;
	// 828DB7B8: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828DB7BC: 41990080  bgt cr6, 0x828db83c
	if ctx.cr[6].gt {
	pc = 0x828DB83C; continue 'dispatch;
	}
	// 828DB7C0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828DB7C4: 419A0024  beq cr6, 0x828db7e8
	if ctx.cr[6].eq {
	pc = 0x828DB7E8; continue 'dispatch;
	}
	// 828DB7C8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DB7CC: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828DB7D0: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB7D4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828DB7D8: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 828DB7DC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828DB7E0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828DB7E4: 409AFFE4  bne cr6, 0x828db7c8
	if !ctx.cr[6].eq {
	pc = 0x828DB7C8; continue 'dispatch;
	}
	// 828DB7E8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB7EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DB7F0: 409A0024  bne cr6, 0x828db814
	if !ctx.cr[6].eq {
	pc = 0x828DB814; continue 'dispatch;
	}
	// 828DB7F4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828DB7F8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB7FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB800: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828DB804: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828DB808: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828DB80C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828DB810: 483CDC4C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828DB814: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DB818: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB81C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DB820: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB824: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828DB828: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828DB82C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828DB830: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828DB834: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828DB838: 483CDC24  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828DB83C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DB840: 409A000C  bne cr6, 0x828db84c
	if !ctx.cr[6].eq {
	pc = 0x828DB84C; continue 'dispatch;
	}
	// 828DB844: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828DB848: 48000010  b 0x828db858
	pc = 0x828DB858; continue 'dispatch;
	// 828DB84C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828DB850: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828DB854: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828DB858: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828DB85C: 419900A4  bgt cr6, 0x828db900
	if ctx.cr[6].gt {
	pc = 0x828DB900; continue 'dispatch;
	}
	// 828DB860: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DB864: 409A000C  bne cr6, 0x828db870
	if !ctx.cr[6].eq {
	pc = 0x828DB870; continue 'dispatch;
	}
	// 828DB868: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 828DB86C: 48000010  b 0x828db87c
	pc = 0x828DB87C; continue 'dispatch;
	// 828DB870: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DB874: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828DB878: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828DB87C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB880: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828DB884: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 828DB888: 7D485A14  add r10, r8, r11
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 828DB88C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828DB890: 419A0024  beq cr6, 0x828db8b4
	if ctx.cr[6].eq {
	pc = 0x828DB8B4; continue 'dispatch;
	}
	// 828DB894: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DB898: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828DB89C: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB8A0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828DB8A4: 90E90004  stw r7, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 828DB8A8: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 828DB8AC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828DB8B0: 409AFFE4  bne cr6, 0x828db894
	if !ctx.cr[6].eq {
	pc = 0x828DB894; continue 'dispatch;
	}
	// 828DB8B4: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DB8B8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828DB8BC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828DB8C0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DB8C4: 419A00D8  beq cr6, 0x828db99c
	if ctx.cr[6].eq {
	pc = 0x828DB99C; continue 'dispatch;
	}
	// 828DB8C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DB8CC: 419A0014  beq cr6, 0x828db8e0
	if ctx.cr[6].eq {
	pc = 0x828DB8E0; continue 'dispatch;
	}
	// 828DB8D0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DB8D4: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828DB8D8: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB8DC: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 828DB8E0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828DB8E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828DB8E8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828DB8EC: 409AFFDC  bne cr6, 0x828db8c8
	if !ctx.cr[6].eq {
	pc = 0x828DB8C8; continue 'dispatch;
	}
	// 828DB8F0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828DB8F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB8F8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828DB8FC: 483CDB60  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828DB900: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DB904: 419A000C  beq cr6, 0x828db910
	if ctx.cr[6].eq {
	pc = 0x828DB910; continue 'dispatch;
	}
	// 828DB908: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828DB90C: 4B94042D  bl 0x8221bd38
	ctx.lr = 0x828DB910;
	sub_8221BD38(ctx, base);
	// 828DB910: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DB918: 409A000C  bne cr6, 0x828db924
	if !ctx.cr[6].eq {
	pc = 0x828DB924; continue 'dispatch;
	}
	// 828DB91C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DB920: 48000010  b 0x828db930
	pc = 0x828DB930; continue 'dispatch;
	// 828DB924: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DB928: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DB92C: 7D241E70  srawi r4, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828DB930: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828DB934: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828DB938: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828DB93C: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 828DB940: 409A000C  bne cr6, 0x828db94c
	if !ctx.cr[6].eq {
	pc = 0x828DB94C; continue 'dispatch;
	}
	// 828DB944: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DB948: 4800000C  b 0x828db954
	pc = 0x828DB954; continue 'dispatch;
	// 828DB94C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB950: 4BDC2541  bl 0x8269de90
	ctx.lr = 0x828DB954;
	sub_8269DE90(ctx, base);
	// 828DB954: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828DB958: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DB95C: 419A0044  beq cr6, 0x828db9a0
	if ctx.cr[6].eq {
	pc = 0x828DB9A0; continue 'dispatch;
	}
	// 828DB960: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DB964: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB968: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB96C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828DB970: 419A002C  beq cr6, 0x828db99c
	if ctx.cr[6].eq {
	pc = 0x828DB99C; continue 'dispatch;
	}
	// 828DB974: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DB978: 419A0014  beq cr6, 0x828db98c
	if ctx.cr[6].eq {
	pc = 0x828DB98C; continue 'dispatch;
	}
	// 828DB97C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DB980: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828DB984: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB988: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 828DB98C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828DB990: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828DB994: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828DB998: 409AFFDC  bne cr6, 0x828db974
	if !ctx.cr[6].eq {
	pc = 0x828DB974; continue 'dispatch;
	}
	// 828DB99C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828DB9A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB9A4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828DB9A8: 483CDAB4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DB9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DB9B0 size=260
    let mut pc: u32 = 0x828DB9B0;
    'dispatch: loop {
        match pc {
            0x828DB9B0 => {
    //   block [0x828DB9B0..0x828DBAB4)
	// 828DB9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DB9B4: 483CDA55  bl 0x82ca9408
	ctx.lr = 0x828DB9B8;
	sub_82CA93D0(ctx, base);
	// 828DB9B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DB9BC: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 828DB9C0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828DB9C4: 616AFFFF  ori r10, r11, 0xffff
	ctx.r[10].u64 = ctx.r[11].u64 | 65535;
	// 828DB9C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DB9CC: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828DB9D0: 40990010  ble cr6, 0x828db9e0
	if !ctx.cr[6].gt {
	pc = 0x828DB9E0; continue 'dispatch;
	}
	// 828DB9D4: 4BC190FD  bl 0x824f4ad0
	ctx.lr = 0x828DB9D8;
	sub_824F4AD0(ctx, base);
	// 828DB9D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DB9DC: 483CDA7C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 828DB9E0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB9E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DB9E8: 419A0010  beq cr6, 0x828db9f8
	if ctx.cr[6].eq {
	pc = 0x828DB9F8; continue 'dispatch;
	}
	// 828DB9EC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828DB9F0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DB9F4: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828DB9F8: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828DB9FC: 409800B0  bge cr6, 0x828dbaac
	if !ctx.cr[6].lt {
	pc = 0x828DBAAC; continue 'dispatch;
	}
	// 828DBA00: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828DBA04: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DBA08: 4BB1E5D1  bl 0x823f9fd8
	ctx.lr = 0x828DBA0C;
	sub_823F9FD8(ctx, base);
	// 828DBA0C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DBA10: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DBA14: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DBA18: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828DBA1C: 4099000C  ble cr6, 0x828dba28
	if !ctx.cr[6].gt {
	pc = 0x828DBA28; continue 'dispatch;
	}
	// 828DBA20: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DBA24: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DBA28: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828DBA2C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828DBA30: 419A0034  beq cr6, 0x828dba64
	if ctx.cr[6].eq {
	pc = 0x828DBA64; continue 'dispatch;
	}
	// 828DBA34: 7D5D5050  subf r10, r29, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[29].s64;
	// 828DBA38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DBA3C: 419A0018  beq cr6, 0x828dba54
	if ctx.cr[6].eq {
	pc = 0x828DBA54; continue 'dispatch;
	}
	// 828DBA40: 7D0A582E  lwzx r8, r10, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828DBA44: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828DBA48: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828DBA4C: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DBA50: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 828DBA54: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828DBA58: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828DBA5C: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828DBA60: 409AFFD8  bne cr6, 0x828dba38
	if !ctx.cr[6].eq {
	pc = 0x828DBA38; continue 'dispatch;
	}
	// 828DBA64: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DBA68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DBA6C: 409A000C  bne cr6, 0x828dba78
	if !ctx.cr[6].eq {
	pc = 0x828DBA78; continue 'dispatch;
	}
	// 828DBA70: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828DBA74: 48000010  b 0x828dba84
	pc = 0x828DBA84; continue 'dispatch;
	// 828DBA78: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DBA7C: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 828DBA80: 7D5E1E70  srawi r30, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 828DBA84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DBA88: 419A0008  beq cr6, 0x828dba90
	if ctx.cr[6].eq {
	pc = 0x828DBA90; continue 'dispatch;
	}
	// 828DBA8C: 4B9402AD  bl 0x8221bd38
	ctx.lr = 0x828DBA90;
	sub_8221BD38(ctx, base);
	// 828DBA90: 578A1838  slwi r10, r28, 3
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828DBA94: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828DBA98: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828DBA9C: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 828DBAA0: 7D2BEA14  add r9, r11, r29
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 828DBAA4: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 828DBAA8: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828DBAAC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DBAB0: 483CD9A8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DBAB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DBAB8 size=128
    let mut pc: u32 = 0x828DBAB8;
    'dispatch: loop {
        match pc {
            0x828DBAB8 => {
    //   block [0x828DBAB8..0x828DBB38)
	// 828DBAB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DBABC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DBAC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DBAC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DBAC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DBACC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DBAD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DBAD4: 4B8DC045  bl 0x821b7b18
	ctx.lr = 0x828DBAD8;
	sub_821B7B18(ctx, base);
	// 828DBAD8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828DBADC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828DBAE0: 419A0040  beq cr6, 0x828dbb20
	if ctx.cr[6].eq {
	pc = 0x828DBB20; continue 'dispatch;
	}
	// 828DBAE4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828DBAE8: 4B943771  bl 0x8221f258
	ctx.lr = 0x828DBAEC;
	sub_8221F258(ctx, base);
	// 828DBAEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DBAF0: 419A0028  beq cr6, 0x828dbb18
	if ctx.cr[6].eq {
	pc = 0x828DBB18; continue 'dispatch;
	}
	// 828DBAF4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DBAF8: 3D20828E  lis r9, -0x7d72
	ctx.r[9].s64 = -2104623104;
	// 828DBAFC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828DBB00: 38E9BC60  addi r7, r9, -0x43a0
	ctx.r[7].s64 = ctx.r[9].s64 + -17312;
	// 828DBB04: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828DBB08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DBB0C: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 828DBB10: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828DBB14: 48000008  b 0x828dbb1c
	pc = 0x828DBB1C; continue 'dispatch;
	// 828DBB18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DBB1C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828DBB20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DBB24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DBB28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DBB2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DBB30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DBB34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DBB38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DBB38 size=292
    let mut pc: u32 = 0x828DBB38;
    'dispatch: loop {
        match pc {
            0x828DBB38 => {
    //   block [0x828DBB38..0x828DBC5C)
	// 828DBB38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DBB3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DBB40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DBB44: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DBB48: F8A10090  std r5, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[5].u64 ) };
	// 828DBB4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DBB50: 409A000C  bne cr6, 0x828dbb5c
	if !ctx.cr[6].eq {
	pc = 0x828DBB5C; continue 'dispatch;
	}
	// 828DBB54: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DBB58: 48000010  b 0x828dbb68
	pc = 0x828DBB68; continue 'dispatch;
	// 828DBB5C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DBB60: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DBB64: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828DBB68: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828DBB6C: 40980058  bge cr6, 0x828dbbc4
	if !ctx.cr[6].lt {
	pc = 0x828DBBC4; continue 'dispatch;
	}
	// 828DBB70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DBB74: 409A000C  bne cr6, 0x828dbb80
	if !ctx.cr[6].eq {
	pc = 0x828DBB80; continue 'dispatch;
	}
	// 828DBB78: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828DBB7C: 48000010  b 0x828dbb8c
	pc = 0x828DBB8C; continue 'dispatch;
	// 828DBB80: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DBB84: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DBB88: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828DBB8C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DBB90: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828DBB94: 40990008  ble cr6, 0x828dbb9c
	if !ctx.cr[6].gt {
	pc = 0x828DBB9C; continue 'dispatch;
	}
	// 828DBB98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DBB9C: 7CA92050  subf r5, r9, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 828DBBA0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828DBBA4: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828DBBA8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DBBAC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828DBBB0: 4BFCEDA1  bl 0x828aa950
	ctx.lr = 0x828DBBB4;
	sub_828AA950(ctx, base);
	// 828DBBB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DBBB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DBBBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DBBC0: 4E800020  blr
	return;
	// 828DBBC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DBBC8: 419A0084  beq cr6, 0x828dbc4c
	if ctx.cr[6].eq {
	pc = 0x828DBC4C; continue 'dispatch;
	}
	// 828DBBCC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DBBD0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828DBBD4: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828DBBD8: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828DBBDC: 40980070  bge cr6, 0x828dbc4c
	if !ctx.cr[6].lt {
	pc = 0x828DBC4C; continue 'dispatch;
	}
	// 828DBBE0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828DBBE4: 40990008  ble cr6, 0x828dbbec
	if !ctx.cr[6].gt {
	pc = 0x828DBBEC; continue 'dispatch;
	}
	// 828DBBE8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DBBEC: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 828DBBF0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828DBBF4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828DBBF8: 40990008  ble cr6, 0x828dbc00
	if !ctx.cr[6].gt {
	pc = 0x828DBC00; continue 'dispatch;
	}
	// 828DBBFC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DBC00: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828DBC04: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DBC08: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828DBC0C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828DBC10: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828DBC14: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828DBC18: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828DBC1C: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 828DBC20: 41990010  bgt cr6, 0x828dbc30
	if ctx.cr[6].gt {
	pc = 0x828DBC30; continue 'dispatch;
	}
	// 828DBC24: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DBC28: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828DBC2C: 40980008  bge cr6, 0x828dbc34
	if !ctx.cr[6].lt {
	pc = 0x828DBC34; continue 'dispatch;
	}
	// 828DBC30: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DBC34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DBC38: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DBC3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DBC40: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828DBC44: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828DBC48: 4825A441  bl 0x82b36088
	ctx.lr = 0x828DBC4C;
	sub_82B36088(ctx, base);
	// 828DBC4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DBC50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DBC54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DBC58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DBC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DBC60 size=108
    let mut pc: u32 = 0x828DBC60;
    'dispatch: loop {
        match pc {
            0x828DBC60 => {
    //   block [0x828DBC60..0x828DBCCC)
	// 828DBC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DBC64: 483CD7A5  bl 0x82ca9408
	ctx.lr = 0x828DBC68;
	sub_82CA93D0(ctx, base);
	// 828DBC68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DBC6C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828DBC70: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828DBC74: 419A0050  beq cr6, 0x828dbcc4
	if ctx.cr[6].eq {
	pc = 0x828DBCC4; continue 'dispatch;
	}
	// 828DBC78: 807C0018  lwz r3, 0x18(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 828DBC7C: 3BDC0014  addi r30, r28, 0x14
	ctx.r[30].s64 = ctx.r[28].s64 + 20;
	// 828DBC80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DBC84: 419A0008  beq cr6, 0x828dbc8c
	if ctx.cr[6].eq {
	pc = 0x828DBC8C; continue 'dispatch;
	}
	// 828DBC88: 4B9400B1  bl 0x8221bd38
	ctx.lr = 0x828DBC8C;
	sub_8221BD38(ctx, base);
	// 828DBC8C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DBC90: 3BBC0004  addi r29, r28, 4
	ctx.r[29].s64 = ctx.r[28].s64 + 4;
	// 828DBC94: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828DBC98: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828DBC9C: 93FE000C  stw r31, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828DBCA0: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DBCA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DBCA8: 419A0008  beq cr6, 0x828dbcb0
	if ctx.cr[6].eq {
	pc = 0x828DBCB0; continue 'dispatch;
	}
	// 828DBCAC: 4B94008D  bl 0x8221bd38
	ctx.lr = 0x828DBCB0;
	sub_8221BD38(ctx, base);
	// 828DBCB0: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828DBCB4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DBCB8: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828DBCBC: 93FD000C  stw r31, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828DBCC0: 4B940079  bl 0x8221bd38
	ctx.lr = 0x828DBCC4;
	sub_8221BD38(ctx, base);
	// 828DBCC4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DBCC8: 483CD790  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DBCD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DBCD0 size=256
    let mut pc: u32 = 0x828DBCD0;
    'dispatch: loop {
        match pc {
            0x828DBCD0 => {
    //   block [0x828DBCD0..0x828DBDD0)
	// 828DBCD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DBCD4: 483CD739  bl 0x82ca940c
	ctx.lr = 0x828DBCD8;
	sub_82CA93D0(ctx, base);
	// 828DBCD8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DBCDC: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 828DBCE0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828DBCE4: 616A5555  ori r10, r11, 0x5555
	ctx.r[10].u64 = ctx.r[11].u64 | 21845;
	// 828DBCE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DBCEC: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828DBCF0: 40990060  ble cr6, 0x828dbd50
	if !ctx.cr[6].gt {
	pc = 0x828DBD50; continue 'dispatch;
	}
	// 828DBCF4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828DBCF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DBCFC: 388B16DC  addi r4, r11, 0x16dc
	ctx.r[4].s64 = ctx.r[11].s64 + 5852;
	// 828DBD00: 4BA16241  bl 0x822f1f40
	ctx.lr = 0x828DBD04;
	sub_822F1F40(ctx, base);
	// 828DBD04: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828DBD08: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828DBD0C: 4BA160A5  bl 0x822f1db0
	ctx.lr = 0x828DBD10;
	sub_822F1DB0(ctx, base);
	// 828DBD10: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828DBD14: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828DBD18: 3BEA1720  addi r31, r10, 0x1720
	ctx.r[31].s64 = ctx.r[10].s64 + 5920;
	// 828DBD1C: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 828DBD20: 4BA16101  bl 0x822f1e20
	ctx.lr = 0x828DBD24;
	sub_822F1E20(ctx, base);
	// 828DBD24: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 828DBD28: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828DBD2C: 4BD9FAB5  bl 0x8267b7e0
	ctx.lr = 0x828DBD30;
	sub_8267B7E0(ctx, base);
	// 828DBD30: 81210078  lwz r9, 0x78(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828DBD34: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 828DBD38: 4198008C  blt cr6, 0x828dbdc4
	if ctx.cr[6].lt {
	pc = 0x828DBDC4; continue 'dispatch;
	}
	// 828DBD3C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828DBD40: 4B93FFF9  bl 0x8221bd38
	ctx.lr = 0x828DBD44;
	sub_8221BD38(ctx, base);
	// 828DBD44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828DBD48: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828DBD4C: 483CD710  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828DBD50: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 828DBD54: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DBD58: 419A003C  beq cr6, 0x828dbd94
	if ctx.cr[6].eq {
	pc = 0x828DBD94; continue 'dispatch;
	}
	// 828DBD5C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 828DBD60: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 828DBD64: 2B0A000C  cmplwi cr6, r10, 0xc
	ctx.cr[6].compare_u32(ctx.r[10].u32, 12 as u32, &mut ctx.xer);
	// 828DBD68: 4098002C  bge cr6, 0x828dbd94
	if !ctx.cr[6].lt {
	pc = 0x828DBD94; continue 'dispatch;
	}
	// 828DBD6C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828DBD70: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DBD74: 392B1714  addi r9, r11, 0x1714
	ctx.r[9].s64 = ctx.r[11].s64 + 5908;
	// 828DBD78: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DBD7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DBD80: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828DBD84: 4BA1609D  bl 0x822f1e20
	ctx.lr = 0x828DBD88;
	sub_822F1E20(ctx, base);
	// 828DBD88: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 828DBD8C: 38E81708  addi r7, r8, 0x1708
	ctx.r[7].s64 = ctx.r[8].s64 + 5896;
	// 828DBD90: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 828DBD94: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828DBD98: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 828DBD9C: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828DBDA0: 4B9434B9  bl 0x8221f258
	ctx.lr = 0x828DBDA4;
	sub_8221F258(ctx, base);
	// 828DBDA4: 57EA083C  slwi r10, r31, 1
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828DBDA8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DBDAC: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 828DBDB0: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828DBDB4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828DBDB8: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828DBDBC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828DBDC0: 913E000C  stw r9, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 828DBDC4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828DBDC8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828DBDCC: 483CD690  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DBDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DBDD0 size=64
    let mut pc: u32 = 0x828DBDD0;
    'dispatch: loop {
        match pc {
            0x828DBDD0 => {
    //   block [0x828DBDD0..0x828DBE10)
	// 828DBDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DBDD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DBDD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DBDDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DBDE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DBDE4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DBDE8: 419A0014  beq cr6, 0x828dbdfc
	if ctx.cr[6].eq {
	pc = 0x828DBDFC; continue 'dispatch;
	}
	// 828DBDEC: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 828DBDF0: 4B8DBD29  bl 0x821b7b18
	ctx.lr = 0x828DBDF4;
	sub_821B7B18(ctx, base);
	// 828DBDF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DBDF8: 4B93FF41  bl 0x8221bd38
	ctx.lr = 0x828DBDFC;
	sub_8221BD38(ctx, base);
	// 828DBDFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DBE00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DBE04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DBE08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DBE0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DBE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DBE10 size=172
    let mut pc: u32 = 0x828DBE10;
    'dispatch: loop {
        match pc {
            0x828DBE10 => {
    //   block [0x828DBE10..0x828DBEBC)
	// 828DBE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DBE14: 483CD5ED  bl 0x82ca9400
	ctx.lr = 0x828DBE18;
	sub_82CA93D0(ctx, base);
	// 828DBE18: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DBE1C: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 828DBE20: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828DBE24: 834100A8  lwz r26, 0xa8(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 828DBE28: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828DBE2C: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 828DBE30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828DBE34: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 828DBE38: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828DBE3C: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 828DBE40: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 828DBE44: 838100B4  lwz r28, 0xb4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 828DBE48: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DBE4C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828DBE50: 419A0044  beq cr6, 0x828dbe94
	if ctx.cr[6].eq {
	pc = 0x828DBE94; continue 'dispatch;
	}
	// 828DBE54: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828DBE58: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 828DBE5C: 83DD0000  lwz r30, 0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DBE60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DBE64: 419A001C  beq cr6, 0x828dbe80
	if ctx.cr[6].eq {
	pc = 0x828DBE80; continue 'dispatch;
	}
	// 828DBE68: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DBE6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DBE70: 419A000C  beq cr6, 0x828dbe7c
	if ctx.cr[6].eq {
	pc = 0x828DBE7C; continue 'dispatch;
	}
	// 828DBE74: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828DBE78: 4800000C  b 0x828dbe84
	pc = 0x828DBE84; continue 'dispatch;
	// 828DBE7C: 4B8B7FBD  bl 0x82193e38
	ctx.lr = 0x828DBE80;
	sub_82193E38(ctx, base);
	// 828DBE80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DBE84: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828DBE88: 419A000C  beq cr6, 0x828dbe94
	if ctx.cr[6].eq {
	pc = 0x828DBE94; continue 'dispatch;
	}
	// 828DBE8C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DBE90: 4BFFFFBC  b 0x828dbe4c
	pc = 0x828DBE4C; continue 'dispatch;
	// 828DBE94: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DBE98: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828DBE9C: 419A0008  beq cr6, 0x828dbea4
	if ctx.cr[6].eq {
	pc = 0x828DBEA4; continue 'dispatch;
	}
	// 828DBEA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828DBEA4: 93E100AC  stw r31, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[31].u32 ) };
	// 828DBEA8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DBEAC: E96100A8  ld r11, 0xa8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828DBEB0: F97B0000  std r11, 0(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828DBEB4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828DBEB8: 483CD598  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DBEC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DBEC0 size=260
    let mut pc: u32 = 0x828DBEC0;
    'dispatch: loop {
        match pc {
            0x828DBEC0 => {
    //   block [0x828DBEC0..0x828DBFC4)
	// 828DBEC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DBEC4: 483CD53D  bl 0x82ca9400
	ctx.lr = 0x828DBEC8;
	sub_82CA93D0(ctx, base);
	// 828DBEC8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DBECC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DBED0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828DBED4: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 828DBED8: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828DBEDC: 3B8B0018  addi r28, r11, 0x18
	ctx.r[28].s64 = ctx.r[11].s64 + 24;
	// 828DBEE0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828DBEE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DBEE8: 419A0010  beq cr6, 0x828dbef8
	if ctx.cr[6].eq {
	pc = 0x828DBEF8; continue 'dispatch;
	}
	// 828DBEEC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828DBEF0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DBEF4: 4800000C  b 0x828dbf00
	pc = 0x828DBF00; continue 'dispatch;
	// 828DBEF8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828DBEFC: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828DBF00: 57AA063E  clrlwi r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828DBF04: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DBF08: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 828DBF0C: 409A0010  bne cr6, 0x828dbf1c
	if !ctx.cr[6].eq {
	pc = 0x828DBF1C; continue 'dispatch;
	}
	// 828DBF10: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828DBF14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DBF18: 419A0008  beq cr6, 0x828dbf20
	if ctx.cr[6].eq {
	pc = 0x828DBF20; continue 'dispatch;
	}
	// 828DBF1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DBF20: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DBF24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DBF28: 409A0094  bne cr6, 0x828dbfbc
	if !ctx.cr[6].eq {
	pc = 0x828DBFBC; continue 'dispatch;
	}
	// 828DBF2C: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DBF30: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DBF34: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828DBF38: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DBF3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DBF40: 419A0068  beq cr6, 0x828dbfa8
	if ctx.cr[6].eq {
	pc = 0x828DBFA8; continue 'dispatch;
	}
	// 828DBF44: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828DBF48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DBF4C: 4B927695  bl 0x822035e0
	ctx.lr = 0x828DBF50;
	sub_822035E0(ctx, base);
	// 828DBF50: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828DBF54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DBF58: 419A0050  beq cr6, 0x828dbfa8
	if ctx.cr[6].eq {
	pc = 0x828DBFA8; continue 'dispatch;
	}
	// 828DBF5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DBF60: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DBF64: 4BC3503D  bl 0x82510fa0
	ctx.lr = 0x828DBF68;
	sub_82510FA0(ctx, base);
	// 828DBF68: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828DBF6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DBF70: 419A001C  beq cr6, 0x828dbf8c
	if ctx.cr[6].eq {
	pc = 0x828DBF8C; continue 'dispatch;
	}
	// 828DBF74: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DBF78: 4B8B0361  bl 0x8218c2d8
	ctx.lr = 0x828DBF7C;
	sub_8218C2D8(ctx, base);
	// 828DBF7C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828DBF80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DBF84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DBF88: 409A0008  bne cr6, 0x828dbf90
	if !ctx.cr[6].eq {
	pc = 0x828DBF90; continue 'dispatch;
	}
	// 828DBF8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DBF90: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DBF94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DBF98: 419A0010  beq cr6, 0x828dbfa8
	if ctx.cr[6].eq {
	pc = 0x828DBFA8; continue 'dispatch;
	}
	// 828DBF9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DBFA0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828DBFA4: 4B8FFD5D  bl 0x821dbd00
	ctx.lr = 0x828DBFA8;
	sub_821DBD00(ctx, base);
	// 828DBFA8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DBFAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DBFB0: 419AFF4C  beq cr6, 0x828dbefc
	if ctx.cr[6].eq {
	pc = 0x828DBEFC; continue 'dispatch;
	}
	// 828DBFB4: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828DBFB8: 4BFFFF48  b 0x828dbf00
	pc = 0x828DBF00; continue 'dispatch;
	// 828DBFBC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828DBFC0: 483CD490  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DBFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DBFC8 size=216
    let mut pc: u32 = 0x828DBFC8;
    'dispatch: loop {
        match pc {
            0x828DBFC8 => {
    //   block [0x828DBFC8..0x828DC0A0)
	// 828DBFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DBFCC: 483CD439  bl 0x82ca9404
	ctx.lr = 0x828DBFD0;
	sub_82CA93D0(ctx, base);
	// 828DBFD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DBFD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DBFD8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828DBFDC: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828DBFE0: 3B8B0018  addi r28, r11, 0x18
	ctx.r[28].s64 = ctx.r[11].s64 + 24;
	// 828DBFE4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828DBFE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DBFEC: 419A0010  beq cr6, 0x828dbffc
	if ctx.cr[6].eq {
	pc = 0x828DBFFC; continue 'dispatch;
	}
	// 828DBFF0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828DBFF4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DBFF8: 4800000C  b 0x828dc004
	pc = 0x828DC004; continue 'dispatch;
	// 828DBFFC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828DC000: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828DC004: 57AA063E  clrlwi r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828DC008: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC00C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 828DC010: 409A0010  bne cr6, 0x828dc020
	if !ctx.cr[6].eq {
	pc = 0x828DC020; continue 'dispatch;
	}
	// 828DC014: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828DC018: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DC01C: 419A0008  beq cr6, 0x828dc024
	if ctx.cr[6].eq {
	pc = 0x828DC024; continue 'dispatch;
	}
	// 828DC020: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DC024: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DC028: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DC02C: 409A0068  bne cr6, 0x828dc094
	if !ctx.cr[6].eq {
	pc = 0x828DC094; continue 'dispatch;
	}
	// 828DC030: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DC034: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DC038: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DC03C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DC040: 419A0034  beq cr6, 0x828dc074
	if ctx.cr[6].eq {
	pc = 0x828DC074; continue 'dispatch;
	}
	// 828DC044: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828DC048: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DC04C: 4B927595  bl 0x822035e0
	ctx.lr = 0x828DC050;
	sub_822035E0(ctx, base);
	// 828DC050: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828DC054: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DC058: 419A001C  beq cr6, 0x828dc074
	if ctx.cr[6].eq {
	pc = 0x828DC074; continue 'dispatch;
	}
	// 828DC05C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DC060: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DC064: 4B8B0275  bl 0x8218c2d8
	ctx.lr = 0x828DC068;
	sub_8218C2D8(ctx, base);
	// 828DC068: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828DC06C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DC070: 409A0018  bne cr6, 0x828dc088
	if !ctx.cr[6].eq {
	pc = 0x828DC088; continue 'dispatch;
	}
	// 828DC074: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DC07C: 419AFF84  beq cr6, 0x828dc000
	if ctx.cr[6].eq {
	pc = 0x828DC000; continue 'dispatch;
	}
	// 828DC080: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828DC084: 4BFFFF80  b 0x828dc004
	pc = 0x828DC004; continue 'dispatch;
	// 828DC088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DC08C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DC090: 483CD3C4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828DC094: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828DC098: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DC09C: 483CD3B8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DC0A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DC0A0 size=584
    let mut pc: u32 = 0x828DC0A0;
    'dispatch: loop {
        match pc {
            0x828DC0A0 => {
    //   block [0x828DC0A0..0x828DC2E8)
	// 828DC0A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DC0A4: 483CD35D  bl 0x82ca9400
	ctx.lr = 0x828DC0A8;
	sub_82CA93D0(ctx, base);
	// 828DC0A8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DC0AC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC0B0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828DC0B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DC0B8: 409A0010  bne cr6, 0x828dc0c8
	if !ctx.cr[6].eq {
	pc = 0x828DC0C8; continue 'dispatch;
	}
	// 828DC0BC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DC0C0: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828DC0C4: 48000008  b 0x828dc0cc
	pc = 0x828DC0CC; continue 'dispatch;
	// 828DC0C8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC0CC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC0D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DC0D4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC0D8: 4BAF24E9  bl 0x823ce5c0
	ctx.lr = 0x828DC0DC;
	sub_823CE5C0(ctx, base);
	// 828DC0DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DC0E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DC0E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DC0E8: 4BAF2119  bl 0x823ce200
	ctx.lr = 0x828DC0EC;
	sub_823CE200(ctx, base);
	// 828DC0EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DC0F0: 4B8DBA29  bl 0x821b7b18
	ctx.lr = 0x828DC0F4;
	sub_821B7B18(ctx, base);
	// 828DC0F4: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828DC0F8: 4B943161  bl 0x8221f258
	ctx.lr = 0x828DC0FC;
	sub_8221F258(ctx, base);
	// 828DC0FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DC100: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DC104: 419A0040  beq cr6, 0x828dc144
	if ctx.cr[6].eq {
	pc = 0x828DC144; continue 'dispatch;
	}
	// 828DC108: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828DC10C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828DC110: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828DC114: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DC118: 4B943141  bl 0x8221f258
	ctx.lr = 0x828DC11C;
	sub_8221F258(ctx, base);
	// 828DC11C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DC120: 419A0028  beq cr6, 0x828dc148
	if ctx.cr[6].eq {
	pc = 0x828DC148; continue 'dispatch;
	}
	// 828DC124: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828DC128: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828DC12C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DC130: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828DC134: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DC138: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828DC13C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DC140: 4800000C  b 0x828dc14c
	pc = 0x828DC14C; continue 'dispatch;
	// 828DC144: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DC148: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828DC14C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DC150: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DC154: 419A00FC  beq cr6, 0x828dc250
	if ctx.cr[6].eq {
	pc = 0x828DC250; continue 'dispatch;
	}
	// 828DC158: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC15C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828DC160: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC164: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828DC168: 4B94CFA1  bl 0x82229108
	ctx.lr = 0x828DC16C;
	sub_82229108(ctx, base);
	// 828DC16C: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DC170: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828DC174: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828DC178: 3BCBD320  addi r30, r11, -0x2ce0
	ctx.r[30].s64 = ctx.r[11].s64 + -11488;
	// 828DC17C: 4B94B705  bl 0x82227880
	ctx.lr = 0x828DC180;
	sub_82227880(ctx, base);
	// 828DC180: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DC184: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828DC188: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828DC18C: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828DC190: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828DC194: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828DC198: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828DC19C: 4B8BE8E5  bl 0x8219aa80
	ctx.lr = 0x828DC1A0;
	sub_8219AA80(ctx, base);
	// 828DC1A0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828DC1A4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828DC1A8: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828DC1AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DC1B0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828DC1B4: 4BAF226D  bl 0x823ce420
	ctx.lr = 0x828DC1B8;
	sub_823CE420(ctx, base);
	// 828DC1B8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828DC1BC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828DC1C0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828DC1C4: 48148505  bl 0x82a246c8
	ctx.lr = 0x828DC1C8;
	sub_82A246C8(ctx, base);
	// 828DC1C8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DC1CC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828DC1D0: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828DC1D4: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828DC1D8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC1DC: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC1E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DC1E4: 4B94CF25  bl 0x82229108
	ctx.lr = 0x828DC1E8;
	sub_82229108(ctx, base);
	// 828DC1E8: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 828DC1EC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828DC1F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DC1F4: 3BEB6C10  addi r31, r11, 0x6c10
	ctx.r[31].s64 = ctx.r[11].s64 + 27664;
	// 828DC1F8: 4B94B689  bl 0x82227880
	ctx.lr = 0x828DC1FC;
	sub_82227880(ctx, base);
	// 828DC1FC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828DC200: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828DC204: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828DC208: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828DC20C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DC210: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828DC214: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828DC218: 4B8BE869  bl 0x8219aa80
	ctx.lr = 0x828DC21C;
	sub_8219AA80(ctx, base);
	// 828DC21C: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828DC220: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DC224: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828DC228: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DC22C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DC230: 4BAF21F1  bl 0x823ce420
	ctx.lr = 0x828DC234;
	sub_823CE420(ctx, base);
	// 828DC234: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DC238: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828DC23C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DC240: 48148489  bl 0x82a246c8
	ctx.lr = 0x828DC244;
	sub_82A246C8(ctx, base);
	// 828DC244: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DC248: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828DC24C: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828DC250: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828DC254: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828DC258: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828DC25C: 419A0020  beq cr6, 0x828dc27c
	if ctx.cr[6].eq {
	pc = 0x828DC27C; continue 'dispatch;
	}
	// 828DC260: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DC264: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC268: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DC26C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828DC270: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DC274: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC278: 4082FFE8  bne 0x828dc260
	if !ctx.cr[0].eq {
	pc = 0x828DC260; continue 'dispatch;
	}
	// 828DC27C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC280: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DC284: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828DC288: 4BA196C1  bl 0x822f5948
	ctx.lr = 0x828DC28C;
	sub_822F5948(ctx, base);
	// 828DC28C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DC290: 4B8DB889  bl 0x821b7b18
	ctx.lr = 0x828DC294;
	sub_821B7B18(ctx, base);
	// 828DC294: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828DC298: 419A0040  beq cr6, 0x828dc2d8
	if ctx.cr[6].eq {
	pc = 0x828DC2D8; continue 'dispatch;
	}
	// 828DC29C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DC2A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC2A4: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DC2A8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DC2AC: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DC2B0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC2B4: 4082FFE8  bne 0x828dc29c
	if !ctx.cr[0].eq {
	pc = 0x828DC29C; continue 'dispatch;
	}
	// 828DC2B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DC2BC: 409A001C  bne cr6, 0x828dc2d8
	if !ctx.cr[6].eq {
	pc = 0x828DC2D8; continue 'dispatch;
	}
	// 828DC2C0: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DC2C4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC2C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DC2CC: 4E800421  bctrl
	ctx.lr = 0x828DC2D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DC2D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DC2D4: 4B93FA65  bl 0x8221bd38
	ctx.lr = 0x828DC2D8;
	sub_8221BD38(ctx, base);
	// 828DC2D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DC2DC: 4B8DB83D  bl 0x821b7b18
	ctx.lr = 0x828DC2E0;
	sub_821B7B18(ctx, base);
	// 828DC2E0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828DC2E4: 483CD16C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DC2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DC2E8 size=516
    let mut pc: u32 = 0x828DC2E8;
    'dispatch: loop {
        match pc {
            0x828DC2E8 => {
    //   block [0x828DC2E8..0x828DC4EC)
	// 828DC2E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DC2EC: 483CD111  bl 0x82ca93fc
	ctx.lr = 0x828DC2F0;
	sub_82CA93D0(ctx, base);
	// 828DC2F0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DC2F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DC2F8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828DC2FC: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828DC300: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828DC304: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828DC308: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC30C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828DC310: 3BAAA3C0  addi r29, r10, -0x5c40
	ctx.r[29].s64 = ctx.r[10].s64 + -23616;
	// 828DC314: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DC318: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DC31C: 419A0008  beq cr6, 0x828dc324
	if ctx.cr[6].eq {
	pc = 0x828DC324; continue 'dispatch;
	}
	// 828DC320: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC324: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC328: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DC32C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC330: 4BAF2291  bl 0x823ce5c0
	ctx.lr = 0x828DC334;
	sub_823CE5C0(ctx, base);
	// 828DC334: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DC338: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DC33C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DC340: 4BAF1DD1  bl 0x823ce110
	ctx.lr = 0x828DC344;
	sub_823CE110(ctx, base);
	// 828DC344: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DC348: 4B8DB7D1  bl 0x821b7b18
	ctx.lr = 0x828DC34C;
	sub_821B7B18(ctx, base);
	// 828DC34C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828DC350: 4B942F09  bl 0x8221f258
	ctx.lr = 0x828DC354;
	sub_8221F258(ctx, base);
	// 828DC354: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DC358: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DC35C: 419A005C  beq cr6, 0x828dc3b8
	if ctx.cr[6].eq {
	pc = 0x828DC3B8; continue 'dispatch;
	}
	// 828DC360: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828DC364: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828DC368: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DC36C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828DC370: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828DC374: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DC378: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828DC37C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828DC380: 4B913EC1  bl 0x821f0240
	ctx.lr = 0x828DC384;
	sub_821F0240(ctx, base);
	// 828DC384: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828DC388: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828DC38C: 4B942ECD  bl 0x8221f258
	ctx.lr = 0x828DC390;
	sub_8221F258(ctx, base);
	// 828DC390: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DC394: 419A0028  beq cr6, 0x828dc3bc
	if ctx.cr[6].eq {
	pc = 0x828DC3BC; continue 'dispatch;
	}
	// 828DC398: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828DC39C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828DC3A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DC3A4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828DC3A8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DC3AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DC3B0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DC3B4: 4800000C  b 0x828dc3c0
	pc = 0x828DC3C0; continue 'dispatch;
	// 828DC3B8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828DC3BC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DC3C0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC3C4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DC3C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DC3CC: 419A0008  beq cr6, 0x828dc3d4
	if ctx.cr[6].eq {
	pc = 0x828DC3D4; continue 'dispatch;
	}
	// 828DC3D0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC3D4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DC3D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DC3DC: 419A0078  beq cr6, 0x828dc454
	if ctx.cr[6].eq {
	pc = 0x828DC454; continue 'dispatch;
	}
	// 828DC3E0: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC3E4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828DC3E8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC3EC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DC3F0: 4B94CD19  bl 0x82229108
	ctx.lr = 0x828DC3F4;
	sub_82229108(ctx, base);
	// 828DC3F4: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DC3F8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828DC3FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DC400: 3BCBD360  addi r30, r11, -0x2ca0
	ctx.r[30].s64 = ctx.r[11].s64 + -11424;
	// 828DC404: 4B94B47D  bl 0x82227880
	ctx.lr = 0x828DC408;
	sub_82227880(ctx, base);
	// 828DC408: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DC40C: 3D40827C  lis r10, -0x7d84
	ctx.r[10].s64 = -2105802752;
	// 828DC410: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828DC414: 388AD6C8  addi r4, r10, -0x2938
	ctx.r[4].s64 = ctx.r[10].s64 + -10552;
	// 828DC418: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DC41C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828DC420: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828DC424: 4B8BE65D  bl 0x8219aa80
	ctx.lr = 0x828DC428;
	sub_8219AA80(ctx, base);
	// 828DC428: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DC42C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828DC430: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DC434: 4BAF1FED  bl 0x823ce420
	ctx.lr = 0x828DC438;
	sub_823CE420(ctx, base);
	// 828DC438: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DC43C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828DC440: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DC444: 48148285  bl 0x82a246c8
	ctx.lr = 0x828DC448;
	sub_82A246C8(ctx, base);
	// 828DC448: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DC44C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828DC450: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828DC454: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828DC458: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DC45C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828DC460: 419A0020  beq cr6, 0x828dc480
	if ctx.cr[6].eq {
	pc = 0x828DC480; continue 'dispatch;
	}
	// 828DC464: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DC468: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC46C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DC470: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828DC474: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DC478: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC47C: 4082FFE8  bne 0x828dc464
	if !ctx.cr[0].eq {
	pc = 0x828DC464; continue 'dispatch;
	}
	// 828DC480: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC484: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DC488: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828DC48C: 4BA194BD  bl 0x822f5948
	ctx.lr = 0x828DC490;
	sub_822F5948(ctx, base);
	// 828DC490: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DC494: 4B8DB685  bl 0x821b7b18
	ctx.lr = 0x828DC498;
	sub_821B7B18(ctx, base);
	// 828DC498: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DC49C: 419A0040  beq cr6, 0x828dc4dc
	if ctx.cr[6].eq {
	pc = 0x828DC4DC; continue 'dispatch;
	}
	// 828DC4A0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DC4A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC4A8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DC4AC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DC4B0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DC4B4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC4B8: 4082FFE8  bne 0x828dc4a0
	if !ctx.cr[0].eq {
	pc = 0x828DC4A0; continue 'dispatch;
	}
	// 828DC4BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DC4C0: 409A001C  bne cr6, 0x828dc4dc
	if !ctx.cr[6].eq {
	pc = 0x828DC4DC; continue 'dispatch;
	}
	// 828DC4C4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DC4C8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC4CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DC4D0: 4E800421  bctrl
	ctx.lr = 0x828DC4D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DC4D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DC4D8: 4B93F861  bl 0x8221bd38
	ctx.lr = 0x828DC4DC;
	sub_8221BD38(ctx, base);
	// 828DC4DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DC4E0: 4B8DB639  bl 0x821b7b18
	ctx.lr = 0x828DC4E4;
	sub_821B7B18(ctx, base);
	// 828DC4E4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828DC4E8: 483CCF64  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DC4F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DC4F0 size=516
    let mut pc: u32 = 0x828DC4F0;
    'dispatch: loop {
        match pc {
            0x828DC4F0 => {
    //   block [0x828DC4F0..0x828DC6F4)
	// 828DC4F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DC4F4: 483CCF09  bl 0x82ca93fc
	ctx.lr = 0x828DC4F8;
	sub_82CA93D0(ctx, base);
	// 828DC4F8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DC4FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DC500: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828DC504: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828DC508: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828DC50C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828DC510: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC514: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828DC518: 3BAAA3E8  addi r29, r10, -0x5c18
	ctx.r[29].s64 = ctx.r[10].s64 + -23576;
	// 828DC51C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DC520: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DC524: 419A0008  beq cr6, 0x828dc52c
	if ctx.cr[6].eq {
	pc = 0x828DC52C; continue 'dispatch;
	}
	// 828DC528: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC52C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC530: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DC534: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC538: 4BAF2089  bl 0x823ce5c0
	ctx.lr = 0x828DC53C;
	sub_823CE5C0(ctx, base);
	// 828DC53C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DC540: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DC544: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DC548: 4BAF1BC9  bl 0x823ce110
	ctx.lr = 0x828DC54C;
	sub_823CE110(ctx, base);
	// 828DC54C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DC550: 4B8DB5C9  bl 0x821b7b18
	ctx.lr = 0x828DC554;
	sub_821B7B18(ctx, base);
	// 828DC554: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828DC558: 4B942D01  bl 0x8221f258
	ctx.lr = 0x828DC55C;
	sub_8221F258(ctx, base);
	// 828DC55C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DC560: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DC564: 419A005C  beq cr6, 0x828dc5c0
	if ctx.cr[6].eq {
	pc = 0x828DC5C0; continue 'dispatch;
	}
	// 828DC568: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828DC56C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828DC570: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DC574: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828DC578: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828DC57C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DC580: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828DC584: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828DC588: 4B913CB9  bl 0x821f0240
	ctx.lr = 0x828DC58C;
	sub_821F0240(ctx, base);
	// 828DC58C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828DC590: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828DC594: 4B942CC5  bl 0x8221f258
	ctx.lr = 0x828DC598;
	sub_8221F258(ctx, base);
	// 828DC598: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DC59C: 419A0028  beq cr6, 0x828dc5c4
	if ctx.cr[6].eq {
	pc = 0x828DC5C4; continue 'dispatch;
	}
	// 828DC5A0: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828DC5A4: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828DC5A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DC5AC: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828DC5B0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DC5B4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DC5B8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DC5BC: 4800000C  b 0x828dc5c8
	pc = 0x828DC5C8; continue 'dispatch;
	// 828DC5C0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828DC5C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DC5C8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC5CC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DC5D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DC5D4: 419A0008  beq cr6, 0x828dc5dc
	if ctx.cr[6].eq {
	pc = 0x828DC5DC; continue 'dispatch;
	}
	// 828DC5D8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC5DC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DC5E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DC5E4: 419A0078  beq cr6, 0x828dc65c
	if ctx.cr[6].eq {
	pc = 0x828DC65C; continue 'dispatch;
	}
	// 828DC5E8: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC5EC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828DC5F0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC5F4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DC5F8: 4B94CB11  bl 0x82229108
	ctx.lr = 0x828DC5FC;
	sub_82229108(ctx, base);
	// 828DC5FC: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DC600: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828DC604: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DC608: 3BCBD360  addi r30, r11, -0x2ca0
	ctx.r[30].s64 = ctx.r[11].s64 + -11424;
	// 828DC60C: 4B94B275  bl 0x82227880
	ctx.lr = 0x828DC610;
	sub_82227880(ctx, base);
	// 828DC610: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DC614: 3D408278  lis r10, -0x7d88
	ctx.r[10].s64 = -2106064896;
	// 828DC618: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828DC61C: 388A3318  addi r4, r10, 0x3318
	ctx.r[4].s64 = ctx.r[10].s64 + 13080;
	// 828DC620: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DC624: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828DC628: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828DC62C: 4B8BE455  bl 0x8219aa80
	ctx.lr = 0x828DC630;
	sub_8219AA80(ctx, base);
	// 828DC630: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DC634: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828DC638: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DC63C: 4BAF1DE5  bl 0x823ce420
	ctx.lr = 0x828DC640;
	sub_823CE420(ctx, base);
	// 828DC640: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DC644: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828DC648: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DC64C: 4814807D  bl 0x82a246c8
	ctx.lr = 0x828DC650;
	sub_82A246C8(ctx, base);
	// 828DC650: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DC654: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828DC658: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828DC65C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828DC660: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DC664: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828DC668: 419A0020  beq cr6, 0x828dc688
	if ctx.cr[6].eq {
	pc = 0x828DC688; continue 'dispatch;
	}
	// 828DC66C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DC670: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC674: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DC678: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828DC67C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DC680: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC684: 4082FFE8  bne 0x828dc66c
	if !ctx.cr[0].eq {
	pc = 0x828DC66C; continue 'dispatch;
	}
	// 828DC688: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC68C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DC690: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828DC694: 4BA192B5  bl 0x822f5948
	ctx.lr = 0x828DC698;
	sub_822F5948(ctx, base);
	// 828DC698: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DC69C: 4B8DB47D  bl 0x821b7b18
	ctx.lr = 0x828DC6A0;
	sub_821B7B18(ctx, base);
	// 828DC6A0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DC6A4: 419A0040  beq cr6, 0x828dc6e4
	if ctx.cr[6].eq {
	pc = 0x828DC6E4; continue 'dispatch;
	}
	// 828DC6A8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DC6AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC6B0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DC6B4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DC6B8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DC6BC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC6C0: 4082FFE8  bne 0x828dc6a8
	if !ctx.cr[0].eq {
	pc = 0x828DC6A8; continue 'dispatch;
	}
	// 828DC6C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DC6C8: 409A001C  bne cr6, 0x828dc6e4
	if !ctx.cr[6].eq {
	pc = 0x828DC6E4; continue 'dispatch;
	}
	// 828DC6CC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DC6D0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC6D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DC6D8: 4E800421  bctrl
	ctx.lr = 0x828DC6DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DC6DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DC6E0: 4B93F659  bl 0x8221bd38
	ctx.lr = 0x828DC6E4;
	sub_8221BD38(ctx, base);
	// 828DC6E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DC6E8: 4B8DB431  bl 0x821b7b18
	ctx.lr = 0x828DC6EC;
	sub_821B7B18(ctx, base);
	// 828DC6EC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828DC6F0: 483CCD5C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DC6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DC6F8 size=516
    let mut pc: u32 = 0x828DC6F8;
    'dispatch: loop {
        match pc {
            0x828DC6F8 => {
    //   block [0x828DC6F8..0x828DC8FC)
	// 828DC6F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DC6FC: 483CCD01  bl 0x82ca93fc
	ctx.lr = 0x828DC700;
	sub_82CA93D0(ctx, base);
	// 828DC700: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DC704: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DC708: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828DC70C: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828DC710: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828DC714: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828DC718: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC71C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828DC720: 3BAAA518  addi r29, r10, -0x5ae8
	ctx.r[29].s64 = ctx.r[10].s64 + -23272;
	// 828DC724: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DC728: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DC72C: 419A0008  beq cr6, 0x828dc734
	if ctx.cr[6].eq {
	pc = 0x828DC734; continue 'dispatch;
	}
	// 828DC730: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC734: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC738: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DC73C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC740: 4BAF1E81  bl 0x823ce5c0
	ctx.lr = 0x828DC744;
	sub_823CE5C0(ctx, base);
	// 828DC744: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DC748: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DC74C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DC750: 4BAF19C1  bl 0x823ce110
	ctx.lr = 0x828DC754;
	sub_823CE110(ctx, base);
	// 828DC754: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DC758: 4B8DB3C1  bl 0x821b7b18
	ctx.lr = 0x828DC75C;
	sub_821B7B18(ctx, base);
	// 828DC75C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828DC760: 4B942AF9  bl 0x8221f258
	ctx.lr = 0x828DC764;
	sub_8221F258(ctx, base);
	// 828DC764: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DC768: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DC76C: 419A005C  beq cr6, 0x828dc7c8
	if ctx.cr[6].eq {
	pc = 0x828DC7C8; continue 'dispatch;
	}
	// 828DC770: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828DC774: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828DC778: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DC77C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828DC780: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828DC784: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DC788: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828DC78C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828DC790: 4B913AB1  bl 0x821f0240
	ctx.lr = 0x828DC794;
	sub_821F0240(ctx, base);
	// 828DC794: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828DC798: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828DC79C: 4B942ABD  bl 0x8221f258
	ctx.lr = 0x828DC7A0;
	sub_8221F258(ctx, base);
	// 828DC7A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DC7A4: 419A0028  beq cr6, 0x828dc7cc
	if ctx.cr[6].eq {
	pc = 0x828DC7CC; continue 'dispatch;
	}
	// 828DC7A8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828DC7AC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828DC7B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DC7B4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828DC7B8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DC7BC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DC7C0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DC7C4: 4800000C  b 0x828dc7d0
	pc = 0x828DC7D0; continue 'dispatch;
	// 828DC7C8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828DC7CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DC7D0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC7D4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DC7D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DC7DC: 419A0008  beq cr6, 0x828dc7e4
	if ctx.cr[6].eq {
	pc = 0x828DC7E4; continue 'dispatch;
	}
	// 828DC7E0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC7E4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DC7E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DC7EC: 419A0078  beq cr6, 0x828dc864
	if ctx.cr[6].eq {
	pc = 0x828DC864; continue 'dispatch;
	}
	// 828DC7F0: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC7F4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828DC7F8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC7FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DC800: 4B94C909  bl 0x82229108
	ctx.lr = 0x828DC804;
	sub_82229108(ctx, base);
	// 828DC804: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DC808: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828DC80C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DC810: 3BCBD4D8  addi r30, r11, -0x2b28
	ctx.r[30].s64 = ctx.r[11].s64 + -11048;
	// 828DC814: 4B94B06D  bl 0x82227880
	ctx.lr = 0x828DC818;
	sub_82227880(ctx, base);
	// 828DC818: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DC81C: 3D408246  lis r10, -0x7dba
	ctx.r[10].s64 = -2109341696;
	// 828DC820: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828DC824: 388A5B50  addi r4, r10, 0x5b50
	ctx.r[4].s64 = ctx.r[10].s64 + 23376;
	// 828DC828: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DC82C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828DC830: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828DC834: 4B8BE24D  bl 0x8219aa80
	ctx.lr = 0x828DC838;
	sub_8219AA80(ctx, base);
	// 828DC838: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DC83C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828DC840: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DC844: 4BAF1BDD  bl 0x823ce420
	ctx.lr = 0x828DC848;
	sub_823CE420(ctx, base);
	// 828DC848: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DC84C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828DC850: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DC854: 48147E75  bl 0x82a246c8
	ctx.lr = 0x828DC858;
	sub_82A246C8(ctx, base);
	// 828DC858: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DC85C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828DC860: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828DC864: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828DC868: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DC86C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828DC870: 419A0020  beq cr6, 0x828dc890
	if ctx.cr[6].eq {
	pc = 0x828DC890; continue 'dispatch;
	}
	// 828DC874: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DC878: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC87C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DC880: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828DC884: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DC888: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC88C: 4082FFE8  bne 0x828dc874
	if !ctx.cr[0].eq {
	pc = 0x828DC874; continue 'dispatch;
	}
	// 828DC890: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC894: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DC898: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828DC89C: 4BA190AD  bl 0x822f5948
	ctx.lr = 0x828DC8A0;
	sub_822F5948(ctx, base);
	// 828DC8A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DC8A4: 4B8DB275  bl 0x821b7b18
	ctx.lr = 0x828DC8A8;
	sub_821B7B18(ctx, base);
	// 828DC8A8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DC8AC: 419A0040  beq cr6, 0x828dc8ec
	if ctx.cr[6].eq {
	pc = 0x828DC8EC; continue 'dispatch;
	}
	// 828DC8B0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DC8B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC8B8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DC8BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DC8C0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DC8C4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC8C8: 4082FFE8  bne 0x828dc8b0
	if !ctx.cr[0].eq {
	pc = 0x828DC8B0; continue 'dispatch;
	}
	// 828DC8CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DC8D0: 409A001C  bne cr6, 0x828dc8ec
	if !ctx.cr[6].eq {
	pc = 0x828DC8EC; continue 'dispatch;
	}
	// 828DC8D4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DC8D8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC8DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DC8E0: 4E800421  bctrl
	ctx.lr = 0x828DC8E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DC8E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DC8E8: 4B93F451  bl 0x8221bd38
	ctx.lr = 0x828DC8EC;
	sub_8221BD38(ctx, base);
	// 828DC8EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DC8F0: 4B8DB229  bl 0x821b7b18
	ctx.lr = 0x828DC8F4;
	sub_821B7B18(ctx, base);
	// 828DC8F4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828DC8F8: 483CCB54  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DC900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DC900 size=512
    let mut pc: u32 = 0x828DC900;
    'dispatch: loop {
        match pc {
            0x828DC900 => {
    //   block [0x828DC900..0x828DCB00)
	// 828DC900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DC904: 483CCAF9  bl 0x82ca93fc
	ctx.lr = 0x828DC908;
	sub_82CA93D0(ctx, base);
	// 828DC908: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DC90C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DC910: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828DC914: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828DC918: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828DC91C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828DC920: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC924: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828DC928: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DC92C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DC930: 419A0008  beq cr6, 0x828dc938
	if ctx.cr[6].eq {
	pc = 0x828DC938; continue 'dispatch;
	}
	// 828DC934: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC938: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC93C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DC940: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC944: 4BAF1C7D  bl 0x823ce5c0
	ctx.lr = 0x828DC948;
	sub_823CE5C0(ctx, base);
	// 828DC948: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DC94C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DC950: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DC954: 4BAF17BD  bl 0x823ce110
	ctx.lr = 0x828DC958;
	sub_823CE110(ctx, base);
	// 828DC958: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DC95C: 4B8DB1BD  bl 0x821b7b18
	ctx.lr = 0x828DC960;
	sub_821B7B18(ctx, base);
	// 828DC960: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828DC964: 4B9428F5  bl 0x8221f258
	ctx.lr = 0x828DC968;
	sub_8221F258(ctx, base);
	// 828DC968: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DC96C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DC970: 419A005C  beq cr6, 0x828dc9cc
	if ctx.cr[6].eq {
	pc = 0x828DC9CC; continue 'dispatch;
	}
	// 828DC974: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828DC978: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828DC97C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DC980: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828DC984: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828DC988: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DC98C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828DC990: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828DC994: 4B9138AD  bl 0x821f0240
	ctx.lr = 0x828DC998;
	sub_821F0240(ctx, base);
	// 828DC998: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828DC99C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828DC9A0: 4B9428B9  bl 0x8221f258
	ctx.lr = 0x828DC9A4;
	sub_8221F258(ctx, base);
	// 828DC9A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DC9A8: 419A0028  beq cr6, 0x828dc9d0
	if ctx.cr[6].eq {
	pc = 0x828DC9D0; continue 'dispatch;
	}
	// 828DC9AC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828DC9B0: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828DC9B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DC9B8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828DC9BC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DC9C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DC9C4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DC9C8: 4800000C  b 0x828dc9d4
	pc = 0x828DC9D4; continue 'dispatch;
	// 828DC9CC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828DC9D0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DC9D4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC9D8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DC9DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DC9E0: 419A0008  beq cr6, 0x828dc9e8
	if ctx.cr[6].eq {
	pc = 0x828DC9E8; continue 'dispatch;
	}
	// 828DC9E4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC9E8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DC9EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DC9F0: 419A0078  beq cr6, 0x828dca68
	if ctx.cr[6].eq {
	pc = 0x828DCA68; continue 'dispatch;
	}
	// 828DC9F4: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC9F8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828DC9FC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DCA00: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DCA04: 4B94C705  bl 0x82229108
	ctx.lr = 0x828DCA08;
	sub_82229108(ctx, base);
	// 828DCA08: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DCA0C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828DCA10: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DCA14: 3BCBD638  addi r30, r11, -0x29c8
	ctx.r[30].s64 = ctx.r[11].s64 + -10696;
	// 828DCA18: 4B94AE69  bl 0x82227880
	ctx.lr = 0x828DCA1C;
	sub_82227880(ctx, base);
	// 828DCA1C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DCA20: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828DCA24: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828DCA28: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828DCA2C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DCA30: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828DCA34: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828DCA38: 4B8BE049  bl 0x8219aa80
	ctx.lr = 0x828DCA3C;
	sub_8219AA80(ctx, base);
	// 828DCA3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DCA40: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828DCA44: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DCA48: 4BAF19D9  bl 0x823ce420
	ctx.lr = 0x828DCA4C;
	sub_823CE420(ctx, base);
	// 828DCA4C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DCA50: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828DCA54: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DCA58: 48147C71  bl 0x82a246c8
	ctx.lr = 0x828DCA5C;
	sub_82A246C8(ctx, base);
	// 828DCA5C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DCA60: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828DCA64: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828DCA68: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828DCA6C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DCA70: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828DCA74: 419A0020  beq cr6, 0x828dca94
	if ctx.cr[6].eq {
	pc = 0x828DCA94; continue 'dispatch;
	}
	// 828DCA78: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DCA7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DCA80: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DCA84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828DCA88: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DCA8C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DCA90: 4082FFE8  bne 0x828dca78
	if !ctx.cr[0].eq {
	pc = 0x828DCA78; continue 'dispatch;
	}
	// 828DCA94: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DCA98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DCA9C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828DCAA0: 4BA18EA9  bl 0x822f5948
	ctx.lr = 0x828DCAA4;
	sub_822F5948(ctx, base);
	// 828DCAA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DCAA8: 4B8DB071  bl 0x821b7b18
	ctx.lr = 0x828DCAAC;
	sub_821B7B18(ctx, base);
	// 828DCAAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DCAB0: 419A0040  beq cr6, 0x828dcaf0
	if ctx.cr[6].eq {
	pc = 0x828DCAF0; continue 'dispatch;
	}
	// 828DCAB4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DCAB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DCABC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DCAC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DCAC4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DCAC8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DCACC: 4082FFE8  bne 0x828dcab4
	if !ctx.cr[0].eq {
	pc = 0x828DCAB4; continue 'dispatch;
	}
	// 828DCAD0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DCAD4: 409A001C  bne cr6, 0x828dcaf0
	if !ctx.cr[6].eq {
	pc = 0x828DCAF0; continue 'dispatch;
	}
	// 828DCAD8: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DCADC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DCAE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DCAE4: 4E800421  bctrl
	ctx.lr = 0x828DCAE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DCAE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DCAEC: 4B93F24D  bl 0x8221bd38
	ctx.lr = 0x828DCAF0;
	sub_8221BD38(ctx, base);
	// 828DCAF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DCAF4: 4B8DB025  bl 0x821b7b18
	ctx.lr = 0x828DCAF8;
	sub_821B7B18(ctx, base);
	// 828DCAF8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828DCAFC: 483CC950  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DCB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DCB00 size=516
    let mut pc: u32 = 0x828DCB00;
    'dispatch: loop {
        match pc {
            0x828DCB00 => {
    //   block [0x828DCB00..0x828DCD04)
	// 828DCB00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DCB04: 483CC8F9  bl 0x82ca93fc
	ctx.lr = 0x828DCB08;
	sub_82CA93D0(ctx, base);
	// 828DCB08: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DCB0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DCB10: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828DCB14: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828DCB18: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828DCB1C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828DCB20: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCB24: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828DCB28: 3BAAA6A0  addi r29, r10, -0x5960
	ctx.r[29].s64 = ctx.r[10].s64 + -22880;
	// 828DCB2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DCB30: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DCB34: 419A0008  beq cr6, 0x828dcb3c
	if ctx.cr[6].eq {
	pc = 0x828DCB3C; continue 'dispatch;
	}
	// 828DCB38: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCB3C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DCB40: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DCB44: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCB48: 4BAF1A79  bl 0x823ce5c0
	ctx.lr = 0x828DCB4C;
	sub_823CE5C0(ctx, base);
	// 828DCB4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DCB50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DCB54: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DCB58: 4BAF15B9  bl 0x823ce110
	ctx.lr = 0x828DCB5C;
	sub_823CE110(ctx, base);
	// 828DCB5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DCB60: 4B8DAFB9  bl 0x821b7b18
	ctx.lr = 0x828DCB64;
	sub_821B7B18(ctx, base);
	// 828DCB64: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828DCB68: 4B9426F1  bl 0x8221f258
	ctx.lr = 0x828DCB6C;
	sub_8221F258(ctx, base);
	// 828DCB6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DCB70: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DCB74: 419A005C  beq cr6, 0x828dcbd0
	if ctx.cr[6].eq {
	pc = 0x828DCBD0; continue 'dispatch;
	}
	// 828DCB78: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828DCB7C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828DCB80: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DCB84: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828DCB88: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828DCB8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DCB90: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828DCB94: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828DCB98: 4B9136A9  bl 0x821f0240
	ctx.lr = 0x828DCB9C;
	sub_821F0240(ctx, base);
	// 828DCB9C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828DCBA0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828DCBA4: 4B9426B5  bl 0x8221f258
	ctx.lr = 0x828DCBA8;
	sub_8221F258(ctx, base);
	// 828DCBA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DCBAC: 419A0028  beq cr6, 0x828dcbd4
	if ctx.cr[6].eq {
	pc = 0x828DCBD4; continue 'dispatch;
	}
	// 828DCBB0: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828DCBB4: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828DCBB8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DCBBC: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828DCBC0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DCBC4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DCBC8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DCBCC: 4800000C  b 0x828dcbd8
	pc = 0x828DCBD8; continue 'dispatch;
	// 828DCBD0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828DCBD4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DCBD8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCBDC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DCBE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DCBE4: 419A0008  beq cr6, 0x828dcbec
	if ctx.cr[6].eq {
	pc = 0x828DCBEC; continue 'dispatch;
	}
	// 828DCBE8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCBEC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DCBF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DCBF4: 419A0078  beq cr6, 0x828dcc6c
	if ctx.cr[6].eq {
	pc = 0x828DCC6C; continue 'dispatch;
	}
	// 828DCBF8: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCBFC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828DCC00: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DCC04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DCC08: 4B94C501  bl 0x82229108
	ctx.lr = 0x828DCC0C;
	sub_82229108(ctx, base);
	// 828DCC0C: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DCC10: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828DCC14: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DCC18: 3BCBD7B0  addi r30, r11, -0x2850
	ctx.r[30].s64 = ctx.r[11].s64 + -10320;
	// 828DCC1C: 4B94AC65  bl 0x82227880
	ctx.lr = 0x828DCC20;
	sub_82227880(ctx, base);
	// 828DCC20: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DCC24: 3D408291  lis r10, -0x7d6f
	ctx.r[10].s64 = -2104426496;
	// 828DCC28: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828DCC2C: 388A4F40  addi r4, r10, 0x4f40
	ctx.r[4].s64 = ctx.r[10].s64 + 20288;
	// 828DCC30: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DCC34: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828DCC38: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828DCC3C: 4B8BDE45  bl 0x8219aa80
	ctx.lr = 0x828DCC40;
	sub_8219AA80(ctx, base);
	// 828DCC40: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DCC44: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828DCC48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DCC4C: 4BAF17D5  bl 0x823ce420
	ctx.lr = 0x828DCC50;
	sub_823CE420(ctx, base);
	// 828DCC50: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DCC54: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828DCC58: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DCC5C: 48147A6D  bl 0x82a246c8
	ctx.lr = 0x828DCC60;
	sub_82A246C8(ctx, base);
	// 828DCC60: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DCC64: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828DCC68: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828DCC6C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828DCC70: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DCC74: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828DCC78: 419A0020  beq cr6, 0x828dcc98
	if ctx.cr[6].eq {
	pc = 0x828DCC98; continue 'dispatch;
	}
	// 828DCC7C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DCC80: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DCC84: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DCC88: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828DCC8C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DCC90: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DCC94: 4082FFE8  bne 0x828dcc7c
	if !ctx.cr[0].eq {
	pc = 0x828DCC7C; continue 'dispatch;
	}
	// 828DCC98: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DCC9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DCCA0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828DCCA4: 4BA18CA5  bl 0x822f5948
	ctx.lr = 0x828DCCA8;
	sub_822F5948(ctx, base);
	// 828DCCA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DCCAC: 4B8DAE6D  bl 0x821b7b18
	ctx.lr = 0x828DCCB0;
	sub_821B7B18(ctx, base);
	// 828DCCB0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DCCB4: 419A0040  beq cr6, 0x828dccf4
	if ctx.cr[6].eq {
	pc = 0x828DCCF4; continue 'dispatch;
	}
	// 828DCCB8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DCCBC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DCCC0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DCCC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DCCC8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DCCCC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DCCD0: 4082FFE8  bne 0x828dccb8
	if !ctx.cr[0].eq {
	pc = 0x828DCCB8; continue 'dispatch;
	}
	// 828DCCD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DCCD8: 409A001C  bne cr6, 0x828dccf4
	if !ctx.cr[6].eq {
	pc = 0x828DCCF4; continue 'dispatch;
	}
	// 828DCCDC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DCCE0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DCCE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DCCE8: 4E800421  bctrl
	ctx.lr = 0x828DCCEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DCCEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DCCF0: 4B93F049  bl 0x8221bd38
	ctx.lr = 0x828DCCF4;
	sub_8221BD38(ctx, base);
	// 828DCCF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DCCF8: 4B8DAE21  bl 0x821b7b18
	ctx.lr = 0x828DCCFC;
	sub_821B7B18(ctx, base);
	// 828DCCFC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828DCD00: 483CC74C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DCD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DCD08 size=516
    let mut pc: u32 = 0x828DCD08;
    'dispatch: loop {
        match pc {
            0x828DCD08 => {
    //   block [0x828DCD08..0x828DCF0C)
	// 828DCD08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DCD0C: 483CC6F1  bl 0x82ca93fc
	ctx.lr = 0x828DCD10;
	sub_82CA93D0(ctx, base);
	// 828DCD10: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DCD14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DCD18: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828DCD1C: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828DCD20: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828DCD24: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828DCD28: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCD2C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828DCD30: 3BAAA9E0  addi r29, r10, -0x5620
	ctx.r[29].s64 = ctx.r[10].s64 + -22048;
	// 828DCD34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DCD38: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DCD3C: 419A0008  beq cr6, 0x828dcd44
	if ctx.cr[6].eq {
	pc = 0x828DCD44; continue 'dispatch;
	}
	// 828DCD40: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCD44: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DCD48: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DCD4C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCD50: 4BAF1871  bl 0x823ce5c0
	ctx.lr = 0x828DCD54;
	sub_823CE5C0(ctx, base);
	// 828DCD54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DCD58: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DCD5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DCD60: 4BAF13B1  bl 0x823ce110
	ctx.lr = 0x828DCD64;
	sub_823CE110(ctx, base);
	// 828DCD64: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DCD68: 4B8DADB1  bl 0x821b7b18
	ctx.lr = 0x828DCD6C;
	sub_821B7B18(ctx, base);
	// 828DCD6C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828DCD70: 4B9424E9  bl 0x8221f258
	ctx.lr = 0x828DCD74;
	sub_8221F258(ctx, base);
	// 828DCD74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DCD78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DCD7C: 419A005C  beq cr6, 0x828dcdd8
	if ctx.cr[6].eq {
	pc = 0x828DCDD8; continue 'dispatch;
	}
	// 828DCD80: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828DCD84: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828DCD88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DCD8C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828DCD90: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828DCD94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DCD98: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828DCD9C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828DCDA0: 4B9134A1  bl 0x821f0240
	ctx.lr = 0x828DCDA4;
	sub_821F0240(ctx, base);
	// 828DCDA4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828DCDA8: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828DCDAC: 4B9424AD  bl 0x8221f258
	ctx.lr = 0x828DCDB0;
	sub_8221F258(ctx, base);
	// 828DCDB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DCDB4: 419A0028  beq cr6, 0x828dcddc
	if ctx.cr[6].eq {
	pc = 0x828DCDDC; continue 'dispatch;
	}
	// 828DCDB8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828DCDBC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828DCDC0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DCDC4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828DCDC8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DCDCC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DCDD0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DCDD4: 4800000C  b 0x828dcde0
	pc = 0x828DCDE0; continue 'dispatch;
	// 828DCDD8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828DCDDC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DCDE0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCDE4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DCDE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DCDEC: 419A0008  beq cr6, 0x828dcdf4
	if ctx.cr[6].eq {
	pc = 0x828DCDF4; continue 'dispatch;
	}
	// 828DCDF0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCDF4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DCDF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DCDFC: 419A0078  beq cr6, 0x828dce74
	if ctx.cr[6].eq {
	pc = 0x828DCE74; continue 'dispatch;
	}
	// 828DCE00: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCE04: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828DCE08: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DCE0C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DCE10: 4B94C2F9  bl 0x82229108
	ctx.lr = 0x828DCE14;
	sub_82229108(ctx, base);
	// 828DCE14: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DCE18: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828DCE1C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DCE20: 3BCBD7B0  addi r30, r11, -0x2850
	ctx.r[30].s64 = ctx.r[11].s64 + -10320;
	// 828DCE24: 4B94AA5D  bl 0x82227880
	ctx.lr = 0x828DCE28;
	sub_82227880(ctx, base);
	// 828DCE28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DCE2C: 3D40824F  lis r10, -0x7db1
	ctx.r[10].s64 = -2108751872;
	// 828DCE30: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828DCE34: 388AE790  addi r4, r10, -0x1870
	ctx.r[4].s64 = ctx.r[10].s64 + -6256;
	// 828DCE38: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DCE3C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828DCE40: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828DCE44: 4B8BDC3D  bl 0x8219aa80
	ctx.lr = 0x828DCE48;
	sub_8219AA80(ctx, base);
	// 828DCE48: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DCE4C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828DCE50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DCE54: 4BAF15CD  bl 0x823ce420
	ctx.lr = 0x828DCE58;
	sub_823CE420(ctx, base);
	// 828DCE58: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DCE5C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828DCE60: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DCE64: 48147865  bl 0x82a246c8
	ctx.lr = 0x828DCE68;
	sub_82A246C8(ctx, base);
	// 828DCE68: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DCE6C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828DCE70: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828DCE74: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828DCE78: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DCE7C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828DCE80: 419A0020  beq cr6, 0x828dcea0
	if ctx.cr[6].eq {
	pc = 0x828DCEA0; continue 'dispatch;
	}
	// 828DCE84: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DCE88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DCE8C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DCE90: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828DCE94: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DCE98: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DCE9C: 4082FFE8  bne 0x828dce84
	if !ctx.cr[0].eq {
	pc = 0x828DCE84; continue 'dispatch;
	}
	// 828DCEA0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DCEA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DCEA8: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828DCEAC: 4BA18A9D  bl 0x822f5948
	ctx.lr = 0x828DCEB0;
	sub_822F5948(ctx, base);
	// 828DCEB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DCEB4: 4B8DAC65  bl 0x821b7b18
	ctx.lr = 0x828DCEB8;
	sub_821B7B18(ctx, base);
	// 828DCEB8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DCEBC: 419A0040  beq cr6, 0x828dcefc
	if ctx.cr[6].eq {
	pc = 0x828DCEFC; continue 'dispatch;
	}
	// 828DCEC0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DCEC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DCEC8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DCECC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DCED0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DCED4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DCED8: 4082FFE8  bne 0x828dcec0
	if !ctx.cr[0].eq {
	pc = 0x828DCEC0; continue 'dispatch;
	}
	// 828DCEDC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DCEE0: 409A001C  bne cr6, 0x828dcefc
	if !ctx.cr[6].eq {
	pc = 0x828DCEFC; continue 'dispatch;
	}
	// 828DCEE4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DCEE8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DCEEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DCEF0: 4E800421  bctrl
	ctx.lr = 0x828DCEF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DCEF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DCEF8: 4B93EE41  bl 0x8221bd38
	ctx.lr = 0x828DCEFC;
	sub_8221BD38(ctx, base);
	// 828DCEFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DCF00: 4B8DAC19  bl 0x821b7b18
	ctx.lr = 0x828DCF04;
	sub_821B7B18(ctx, base);
	// 828DCF04: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828DCF08: 483CC544  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DCF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DCF10 size=516
    let mut pc: u32 = 0x828DCF10;
    'dispatch: loop {
        match pc {
            0x828DCF10 => {
    //   block [0x828DCF10..0x828DD114)
	// 828DCF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DCF14: 483CC4E9  bl 0x82ca93fc
	ctx.lr = 0x828DCF18;
	sub_82CA93D0(ctx, base);
	// 828DCF18: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DCF1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DCF20: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828DCF24: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828DCF28: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828DCF2C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828DCF30: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCF34: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828DCF38: 3BAAA900  addi r29, r10, -0x5700
	ctx.r[29].s64 = ctx.r[10].s64 + -22272;
	// 828DCF3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DCF40: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DCF44: 419A0008  beq cr6, 0x828dcf4c
	if ctx.cr[6].eq {
	pc = 0x828DCF4C; continue 'dispatch;
	}
	// 828DCF48: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCF4C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DCF50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DCF54: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCF58: 4BAF1669  bl 0x823ce5c0
	ctx.lr = 0x828DCF5C;
	sub_823CE5C0(ctx, base);
	// 828DCF5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DCF60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DCF64: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DCF68: 4BAF11A9  bl 0x823ce110
	ctx.lr = 0x828DCF6C;
	sub_823CE110(ctx, base);
	// 828DCF6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DCF70: 4B8DABA9  bl 0x821b7b18
	ctx.lr = 0x828DCF74;
	sub_821B7B18(ctx, base);
	// 828DCF74: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828DCF78: 4B9422E1  bl 0x8221f258
	ctx.lr = 0x828DCF7C;
	sub_8221F258(ctx, base);
	// 828DCF7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DCF80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DCF84: 419A005C  beq cr6, 0x828dcfe0
	if ctx.cr[6].eq {
	pc = 0x828DCFE0; continue 'dispatch;
	}
	// 828DCF88: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828DCF8C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828DCF90: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DCF94: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828DCF98: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828DCF9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DCFA0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828DCFA4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828DCFA8: 4B913299  bl 0x821f0240
	ctx.lr = 0x828DCFAC;
	sub_821F0240(ctx, base);
	// 828DCFAC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828DCFB0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828DCFB4: 4B9422A5  bl 0x8221f258
	ctx.lr = 0x828DCFB8;
	sub_8221F258(ctx, base);
	// 828DCFB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DCFBC: 419A0028  beq cr6, 0x828dcfe4
	if ctx.cr[6].eq {
	pc = 0x828DCFE4; continue 'dispatch;
	}
	// 828DCFC0: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828DCFC4: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828DCFC8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DCFCC: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828DCFD0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DCFD4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DCFD8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DCFDC: 4800000C  b 0x828dcfe8
	pc = 0x828DCFE8; continue 'dispatch;
	// 828DCFE0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828DCFE4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DCFE8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCFEC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DCFF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DCFF4: 419A0008  beq cr6, 0x828dcffc
	if ctx.cr[6].eq {
	pc = 0x828DCFFC; continue 'dispatch;
	}
	// 828DCFF8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCFFC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DD000: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD004: 419A0078  beq cr6, 0x828dd07c
	if ctx.cr[6].eq {
	pc = 0x828DD07C; continue 'dispatch;
	}
	// 828DD008: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD00C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828DD010: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD014: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DD018: 4B94C0F1  bl 0x82229108
	ctx.lr = 0x828DD01C;
	sub_82229108(ctx, base);
	// 828DD01C: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DD020: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828DD024: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DD028: 3BCBD7B0  addi r30, r11, -0x2850
	ctx.r[30].s64 = ctx.r[11].s64 + -10320;
	// 828DD02C: 4B94A855  bl 0x82227880
	ctx.lr = 0x828DD030;
	sub_82227880(ctx, base);
	// 828DD030: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DD034: 3D408291  lis r10, -0x7d6f
	ctx.r[10].s64 = -2104426496;
	// 828DD038: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828DD03C: 388A4F40  addi r4, r10, 0x4f40
	ctx.r[4].s64 = ctx.r[10].s64 + 20288;
	// 828DD040: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DD044: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828DD048: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828DD04C: 4B8BDA35  bl 0x8219aa80
	ctx.lr = 0x828DD050;
	sub_8219AA80(ctx, base);
	// 828DD050: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DD054: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828DD058: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DD05C: 4BAF13C5  bl 0x823ce420
	ctx.lr = 0x828DD060;
	sub_823CE420(ctx, base);
	// 828DD060: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DD064: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828DD068: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DD06C: 4814765D  bl 0x82a246c8
	ctx.lr = 0x828DD070;
	sub_82A246C8(ctx, base);
	// 828DD070: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DD074: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828DD078: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828DD07C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828DD080: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DD084: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828DD088: 419A0020  beq cr6, 0x828dd0a8
	if ctx.cr[6].eq {
	pc = 0x828DD0A8; continue 'dispatch;
	}
	// 828DD08C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DD090: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DD094: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DD098: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828DD09C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DD0A0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DD0A4: 4082FFE8  bne 0x828dd08c
	if !ctx.cr[0].eq {
	pc = 0x828DD08C; continue 'dispatch;
	}
	// 828DD0A8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD0AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD0B0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828DD0B4: 4BA18895  bl 0x822f5948
	ctx.lr = 0x828DD0B8;
	sub_822F5948(ctx, base);
	// 828DD0B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD0BC: 4B8DAA5D  bl 0x821b7b18
	ctx.lr = 0x828DD0C0;
	sub_821B7B18(ctx, base);
	// 828DD0C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DD0C4: 419A0040  beq cr6, 0x828dd104
	if ctx.cr[6].eq {
	pc = 0x828DD104; continue 'dispatch;
	}
	// 828DD0C8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DD0CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DD0D0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DD0D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DD0D8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DD0DC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DD0E0: 4082FFE8  bne 0x828dd0c8
	if !ctx.cr[0].eq {
	pc = 0x828DD0C8; continue 'dispatch;
	}
	// 828DD0E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DD0E8: 409A001C  bne cr6, 0x828dd104
	if !ctx.cr[6].eq {
	pc = 0x828DD104; continue 'dispatch;
	}
	// 828DD0EC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DD0F0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD0F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DD0F8: 4E800421  bctrl
	ctx.lr = 0x828DD0FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DD0FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DD100: 4B93EC39  bl 0x8221bd38
	ctx.lr = 0x828DD104;
	sub_8221BD38(ctx, base);
	// 828DD104: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DD108: 4B8DAA11  bl 0x821b7b18
	ctx.lr = 0x828DD10C;
	sub_821B7B18(ctx, base);
	// 828DD10C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828DD110: 483CC33C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DD118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DD118 size=516
    let mut pc: u32 = 0x828DD118;
    'dispatch: loop {
        match pc {
            0x828DD118 => {
    //   block [0x828DD118..0x828DD31C)
	// 828DD118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DD11C: 483CC2E1  bl 0x82ca93fc
	ctx.lr = 0x828DD120;
	sub_82CA93D0(ctx, base);
	// 828DD120: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DD124: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DD128: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828DD12C: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828DD130: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828DD134: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828DD138: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD13C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828DD140: 3BAAAA80  addi r29, r10, -0x5580
	ctx.r[29].s64 = ctx.r[10].s64 + -21888;
	// 828DD144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD148: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DD14C: 419A0008  beq cr6, 0x828dd154
	if ctx.cr[6].eq {
	pc = 0x828DD154; continue 'dispatch;
	}
	// 828DD150: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD154: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD158: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DD15C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD160: 4BAF1461  bl 0x823ce5c0
	ctx.lr = 0x828DD164;
	sub_823CE5C0(ctx, base);
	// 828DD164: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DD168: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DD16C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DD170: 4BAF0FA1  bl 0x823ce110
	ctx.lr = 0x828DD174;
	sub_823CE110(ctx, base);
	// 828DD174: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DD178: 4B8DA9A1  bl 0x821b7b18
	ctx.lr = 0x828DD17C;
	sub_821B7B18(ctx, base);
	// 828DD17C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828DD180: 4B9420D9  bl 0x8221f258
	ctx.lr = 0x828DD184;
	sub_8221F258(ctx, base);
	// 828DD184: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DD188: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DD18C: 419A005C  beq cr6, 0x828dd1e8
	if ctx.cr[6].eq {
	pc = 0x828DD1E8; continue 'dispatch;
	}
	// 828DD190: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828DD194: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828DD198: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DD19C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828DD1A0: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828DD1A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DD1A8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828DD1AC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828DD1B0: 4B913091  bl 0x821f0240
	ctx.lr = 0x828DD1B4;
	sub_821F0240(ctx, base);
	// 828DD1B4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828DD1B8: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828DD1BC: 4B94209D  bl 0x8221f258
	ctx.lr = 0x828DD1C0;
	sub_8221F258(ctx, base);
	// 828DD1C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DD1C4: 419A0028  beq cr6, 0x828dd1ec
	if ctx.cr[6].eq {
	pc = 0x828DD1EC; continue 'dispatch;
	}
	// 828DD1C8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828DD1CC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828DD1D0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DD1D4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828DD1D8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DD1DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DD1E0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DD1E4: 4800000C  b 0x828dd1f0
	pc = 0x828DD1F0; continue 'dispatch;
	// 828DD1E8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828DD1EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DD1F0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD1F4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DD1F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD1FC: 419A0008  beq cr6, 0x828dd204
	if ctx.cr[6].eq {
	pc = 0x828DD204; continue 'dispatch;
	}
	// 828DD200: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD204: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DD208: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD20C: 419A0078  beq cr6, 0x828dd284
	if ctx.cr[6].eq {
	pc = 0x828DD284; continue 'dispatch;
	}
	// 828DD210: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD214: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828DD218: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD21C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DD220: 4B94BEE9  bl 0x82229108
	ctx.lr = 0x828DD224;
	sub_82229108(ctx, base);
	// 828DD224: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DD228: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828DD22C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DD230: 3BCBD940  addi r30, r11, -0x26c0
	ctx.r[30].s64 = ctx.r[11].s64 + -9920;
	// 828DD234: 4B94A64D  bl 0x82227880
	ctx.lr = 0x828DD238;
	sub_82227880(ctx, base);
	// 828DD238: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DD23C: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828DD240: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828DD244: 388A8370  addi r4, r10, -0x7c90
	ctx.r[4].s64 = ctx.r[10].s64 + -31888;
	// 828DD248: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DD24C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828DD250: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828DD254: 4B8BD82D  bl 0x8219aa80
	ctx.lr = 0x828DD258;
	sub_8219AA80(ctx, base);
	// 828DD258: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DD25C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828DD260: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DD264: 4BAF11BD  bl 0x823ce420
	ctx.lr = 0x828DD268;
	sub_823CE420(ctx, base);
	// 828DD268: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DD26C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828DD270: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DD274: 48147455  bl 0x82a246c8
	ctx.lr = 0x828DD278;
	sub_82A246C8(ctx, base);
	// 828DD278: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DD27C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828DD280: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828DD284: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828DD288: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DD28C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828DD290: 419A0020  beq cr6, 0x828dd2b0
	if ctx.cr[6].eq {
	pc = 0x828DD2B0; continue 'dispatch;
	}
	// 828DD294: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DD298: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DD29C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DD2A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828DD2A4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DD2A8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DD2AC: 4082FFE8  bne 0x828dd294
	if !ctx.cr[0].eq {
	pc = 0x828DD294; continue 'dispatch;
	}
	// 828DD2B0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD2B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD2B8: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828DD2BC: 4BA1868D  bl 0x822f5948
	ctx.lr = 0x828DD2C0;
	sub_822F5948(ctx, base);
	// 828DD2C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD2C4: 4B8DA855  bl 0x821b7b18
	ctx.lr = 0x828DD2C8;
	sub_821B7B18(ctx, base);
	// 828DD2C8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DD2CC: 419A0040  beq cr6, 0x828dd30c
	if ctx.cr[6].eq {
	pc = 0x828DD30C; continue 'dispatch;
	}
	// 828DD2D0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DD2D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DD2D8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DD2DC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DD2E0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DD2E4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DD2E8: 4082FFE8  bne 0x828dd2d0
	if !ctx.cr[0].eq {
	pc = 0x828DD2D0; continue 'dispatch;
	}
	// 828DD2EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DD2F0: 409A001C  bne cr6, 0x828dd30c
	if !ctx.cr[6].eq {
	pc = 0x828DD30C; continue 'dispatch;
	}
	// 828DD2F4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DD2F8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD2FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DD300: 4E800421  bctrl
	ctx.lr = 0x828DD304;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DD304: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DD308: 4B93EA31  bl 0x8221bd38
	ctx.lr = 0x828DD30C;
	sub_8221BD38(ctx, base);
	// 828DD30C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DD310: 4B8DA809  bl 0x821b7b18
	ctx.lr = 0x828DD314;
	sub_821B7B18(ctx, base);
	// 828DD314: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828DD318: 483CC134  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DD320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DD320 size=56
    let mut pc: u32 = 0x828DD320;
    'dispatch: loop {
        match pc {
            0x828DD320 => {
    //   block [0x828DD320..0x828DD358)
	// 828DD320: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828DD324: 419A0018  beq cr6, 0x828dd33c
	if ctx.cr[6].eq {
	pc = 0x828DD33C; continue 'dispatch;
	}
	// 828DD328: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DD32C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DD330: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DD334: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DD338: 409A0008  bne cr6, 0x828dd340
	if !ctx.cr[6].eq {
	pc = 0x828DD340; continue 'dispatch;
	}
	// 828DD33C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DD340: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DD344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD348: 419A0010  beq cr6, 0x828dd358
	if ctx.cr[6].eq {
		sub_828DD358(ctx, base);
		return;
	}
	// 828DD34C: 8164002C  lwz r11, 0x2c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 828DD350: 556327FE  rlwinm r3, r11, 4, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 828DD354: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DD358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DD358 size=8
    let mut pc: u32 = 0x828DD358;
    'dispatch: loop {
        match pc {
            0x828DD358 => {
    //   block [0x828DD358..0x828DD360)
	// 828DD358: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828DD35C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DD360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DD360 size=376
    let mut pc: u32 = 0x828DD360;
    'dispatch: loop {
        match pc {
            0x828DD360 => {
    //   block [0x828DD360..0x828DD4D8)
	// 828DD360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DD364: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DD368: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DD36C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828DD370: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD374: 419A0018  beq cr6, 0x828dd38c
	if ctx.cr[6].eq {
	pc = 0x828DD38C; continue 'dispatch;
	}
	// 828DD378: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DD37C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828DD380: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DD384: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828DD388: 409A0008  bne cr6, 0x828dd390
	if !ctx.cr[6].eq {
	pc = 0x828DD390; continue 'dispatch;
	}
	// 828DD38C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DD390: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828DD394: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DD398: 419A0130  beq cr6, 0x828dd4c8
	if ctx.cr[6].eq {
	pc = 0x828DD4C8; continue 'dispatch;
	}
	// 828DD39C: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828DD3A0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DD3A4: 552827FE  rlwinm r8, r9, 4, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0FFFFFFFu64;
	// 828DD3A8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828DD3AC: 419A00F8  beq cr6, 0x828dd4a4
	if ctx.cr[6].eq {
	pc = 0x828DD4A4; continue 'dispatch;
	}
	// 828DD3B0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828DD3B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DD3B8: 419A0024  beq cr6, 0x828dd3dc
	if ctx.cr[6].eq {
	pc = 0x828DD3DC; continue 'dispatch;
	}
	// 828DD3BC: 892A005C  lbz r9, 0x5c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(92 as u32) ) } as u64;
	// 828DD3C0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DD3C4: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828DD3C8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828DD3CC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD3D0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828DD3D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DD3D8: 480000D0  b 0x828dd4a8
	pc = 0x828DD4A8; continue 'dispatch;
	// 828DD3DC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DD3E0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828DD3E4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828DD3E8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828DD3EC: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828DD3F0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DD3F4: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DD3F8: 40810054  ble 0x828dd44c
	if !ctx.cr[0].gt {
	pc = 0x828DD44C; continue 'dispatch;
	}
	// 828DD3FC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828DD400: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828DD404: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828DD408: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD40C: 2F07005C  cmpwi cr6, r7, 0x5c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 92, &mut ctx.xer);
	// 828DD410: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828DD414: 41980008  blt cr6, 0x828dd41c
	if ctx.cr[6].lt {
	pc = 0x828DD41C; continue 'dispatch;
	}
	// 828DD418: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828DD41C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828DD420: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828DD424: 419A0014  beq cr6, 0x828dd438
	if ctx.cr[6].eq {
	pc = 0x828DD438; continue 'dispatch;
	}
	// 828DD428: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828DD42C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828DD430: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DD434: 4800000C  b 0x828dd440
	pc = 0x828DD440; continue 'dispatch;
	// 828DD438: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828DD43C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828DD440: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DD444: 4199FFB8  bgt cr6, 0x828dd3fc
	if ctx.cr[6].gt {
	pc = 0x828DD3FC; continue 'dispatch;
	}
	// 828DD448: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DD44C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828DD450: 419A0040  beq cr6, 0x828dd490
	if ctx.cr[6].eq {
	pc = 0x828DD490; continue 'dispatch;
	}
	// 828DD454: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD458: 2F0B005C  cmpwi cr6, r11, 0x5c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 92, &mut ctx.xer);
	// 828DD45C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DD460: 41990008  bgt cr6, 0x828dd468
	if ctx.cr[6].gt {
	pc = 0x828DD468; continue 'dispatch;
	}
	// 828DD464: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DD468: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DD46C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD470: 409A0020  bne cr6, 0x828dd490
	if !ctx.cr[6].eq {
	pc = 0x828DD490; continue 'dispatch;
	}
	// 828DD474: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828DD478: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828DD47C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DD480: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD484: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828DD488: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DD48C: 4800001C  b 0x828dd4a8
	pc = 0x828DD4A8; continue 'dispatch;
	// 828DD490: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828DD494: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD498: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828DD49C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DD4A0: 48000008  b 0x828dd4a8
	pc = 0x828DD4A8; continue 'dispatch;
	// 828DD4A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DD4A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DD4AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD4B0: 419A0018  beq cr6, 0x828dd4c8
	if ctx.cr[6].eq {
	pc = 0x828DD4C8; continue 'dispatch;
	}
	// 828DD4B4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD4B8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828DD4BC: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828DD4C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DD4C4: 4E800421  bctrl
	ctx.lr = 0x828DD4C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DD4C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DD4CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DD4D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DD4D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DD4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DD4D8 size=352
    let mut pc: u32 = 0x828DD4D8;
    'dispatch: loop {
        match pc {
            0x828DD4D8 => {
    //   block [0x828DD4D8..0x828DD638)
	// 828DD4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DD4DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DD4E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DD4E4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828DD4E8: 419A0018  beq cr6, 0x828dd500
	if ctx.cr[6].eq {
	pc = 0x828DD500; continue 'dispatch;
	}
	// 828DD4EC: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DD4F0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DD4F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DD4F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DD4FC: 409A0008  bne cr6, 0x828dd504
	if !ctx.cr[6].eq {
	pc = 0x828DD504; continue 'dispatch;
	}
	// 828DD500: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DD504: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DD508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD50C: 419A011C  beq cr6, 0x828dd628
	if ctx.cr[6].eq {
	pc = 0x828DD628; continue 'dispatch;
	}
	// 828DD510: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 828DD514: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DD518: 554927FE  rlwinm r9, r10, 4, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0FFFFFFFu64;
	// 828DD51C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828DD520: 419A00E8  beq cr6, 0x828dd608
	if ctx.cr[6].eq {
	pc = 0x828DD608; continue 'dispatch;
	}
	// 828DD524: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828DD528: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DD52C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD530: 419A001C  beq cr6, 0x828dd54c
	if ctx.cr[6].eq {
	pc = 0x828DD54C; continue 'dispatch;
	}
	// 828DD534: 896B005C  lbz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828DD538: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828DD53C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828DD540: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD544: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DD548: 480000C4  b 0x828dd60c
	pc = 0x828DD60C; continue 'dispatch;
	// 828DD54C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828DD550: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DD554: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DD558: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828DD55C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828DD560: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DD564: 40810054  ble 0x828dd5b8
	if !ctx.cr[0].gt {
	pc = 0x828DD5B8; continue 'dispatch;
	}
	// 828DD568: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828DD56C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828DD570: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828DD574: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD578: 2F07005C  cmpwi cr6, r7, 0x5c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 92, &mut ctx.xer);
	// 828DD57C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828DD580: 41980008  blt cr6, 0x828dd588
	if ctx.cr[6].lt {
	pc = 0x828DD588; continue 'dispatch;
	}
	// 828DD584: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828DD588: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828DD58C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828DD590: 419A0014  beq cr6, 0x828dd5a4
	if ctx.cr[6].eq {
	pc = 0x828DD5A4; continue 'dispatch;
	}
	// 828DD594: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828DD598: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828DD59C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DD5A0: 4800000C  b 0x828dd5ac
	pc = 0x828DD5AC; continue 'dispatch;
	// 828DD5A4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828DD5A8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828DD5AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DD5B0: 4199FFB8  bgt cr6, 0x828dd568
	if ctx.cr[6].gt {
	pc = 0x828DD568; continue 'dispatch;
	}
	// 828DD5B4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DD5B8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828DD5BC: 419A003C  beq cr6, 0x828dd5f8
	if ctx.cr[6].eq {
	pc = 0x828DD5F8; continue 'dispatch;
	}
	// 828DD5C0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD5C4: 2F0B005C  cmpwi cr6, r11, 0x5c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 92, &mut ctx.xer);
	// 828DD5C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DD5CC: 41990008  bgt cr6, 0x828dd5d4
	if ctx.cr[6].gt {
	pc = 0x828DD5D4; continue 'dispatch;
	}
	// 828DD5D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DD5D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DD5D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD5DC: 409A001C  bne cr6, 0x828dd5f8
	if !ctx.cr[6].eq {
	pc = 0x828DD5F8; continue 'dispatch;
	}
	// 828DD5E0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828DD5E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DD5E8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828DD5EC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DD5F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD5F4: 48000018  b 0x828dd60c
	pc = 0x828DD60C; continue 'dispatch;
	// 828DD5F8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828DD5FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DD600: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD604: 48000008  b 0x828dd60c
	pc = 0x828DD60C; continue 'dispatch;
	// 828DD608: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DD60C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828DD610: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DD614: 419A0014  beq cr6, 0x828dd628
	if ctx.cr[6].eq {
	pc = 0x828DD628; continue 'dispatch;
	}
	// 828DD618: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD61C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828DD620: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828DD624: 4E800421  bctrl
	ctx.lr = 0x828DD628;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DD628: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DD62C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DD630: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DD634: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DD638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DD638 size=372
    let mut pc: u32 = 0x828DD638;
    'dispatch: loop {
        match pc {
            0x828DD638 => {
    //   block [0x828DD638..0x828DD7AC)
	// 828DD638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DD63C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DD640: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DD644: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828DD648: 419A0018  beq cr6, 0x828dd660
	if ctx.cr[6].eq {
	pc = 0x828DD660; continue 'dispatch;
	}
	// 828DD64C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DD650: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DD654: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DD658: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DD65C: 409A0008  bne cr6, 0x828dd664
	if !ctx.cr[6].eq {
	pc = 0x828DD664; continue 'dispatch;
	}
	// 828DD660: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DD664: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DD668: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD66C: 419A012C  beq cr6, 0x828dd798
	if ctx.cr[6].eq {
	pc = 0x828DD798; continue 'dispatch;
	}
	// 828DD670: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 828DD674: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DD678: 554927FE  rlwinm r9, r10, 4, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0FFFFFFFu64;
	// 828DD67C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828DD680: 419A00E8  beq cr6, 0x828dd768
	if ctx.cr[6].eq {
	pc = 0x828DD768; continue 'dispatch;
	}
	// 828DD684: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828DD688: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DD68C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD690: 419A001C  beq cr6, 0x828dd6ac
	if ctx.cr[6].eq {
	pc = 0x828DD6AC; continue 'dispatch;
	}
	// 828DD694: 896B005C  lbz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828DD698: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828DD69C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828DD6A0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD6A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DD6A8: 480000C4  b 0x828dd76c
	pc = 0x828DD76C; continue 'dispatch;
	// 828DD6AC: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828DD6B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DD6B4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DD6B8: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828DD6BC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828DD6C0: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DD6C4: 40810054  ble 0x828dd718
	if !ctx.cr[0].gt {
	pc = 0x828DD718; continue 'dispatch;
	}
	// 828DD6C8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828DD6CC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828DD6D0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828DD6D4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD6D8: 2F07005C  cmpwi cr6, r7, 0x5c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 92, &mut ctx.xer);
	// 828DD6DC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828DD6E0: 41980008  blt cr6, 0x828dd6e8
	if ctx.cr[6].lt {
	pc = 0x828DD6E8; continue 'dispatch;
	}
	// 828DD6E4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828DD6E8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828DD6EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828DD6F0: 419A0014  beq cr6, 0x828dd704
	if ctx.cr[6].eq {
	pc = 0x828DD704; continue 'dispatch;
	}
	// 828DD6F4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828DD6F8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828DD6FC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DD700: 4800000C  b 0x828dd70c
	pc = 0x828DD70C; continue 'dispatch;
	// 828DD704: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828DD708: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828DD70C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DD710: 4199FFB8  bgt cr6, 0x828dd6c8
	if ctx.cr[6].gt {
	pc = 0x828DD6C8; continue 'dispatch;
	}
	// 828DD714: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DD718: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828DD71C: 419A003C  beq cr6, 0x828dd758
	if ctx.cr[6].eq {
	pc = 0x828DD758; continue 'dispatch;
	}
	// 828DD720: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD724: 2F0B005C  cmpwi cr6, r11, 0x5c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 92, &mut ctx.xer);
	// 828DD728: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DD72C: 41990008  bgt cr6, 0x828dd734
	if ctx.cr[6].gt {
	pc = 0x828DD734; continue 'dispatch;
	}
	// 828DD730: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DD734: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DD738: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD73C: 409A001C  bne cr6, 0x828dd758
	if !ctx.cr[6].eq {
	pc = 0x828DD758; continue 'dispatch;
	}
	// 828DD740: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828DD744: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DD748: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828DD74C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DD750: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD754: 48000018  b 0x828dd76c
	pc = 0x828DD76C; continue 'dispatch;
	// 828DD758: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828DD75C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DD760: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD764: 48000008  b 0x828dd76c
	pc = 0x828DD76C; continue 'dispatch;
	// 828DD768: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DD76C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828DD770: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DD774: 419A0024  beq cr6, 0x828dd798
	if ctx.cr[6].eq {
	pc = 0x828DD798; continue 'dispatch;
	}
	// 828DD778: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DD77C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828DD780: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828DD784: 4E800421  bctrl
	ctx.lr = 0x828DD788;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DD788: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DD78C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DD790: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DD794: 4E800020  blr
	return;
	// 828DD798: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828DD79C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DD7A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DD7A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DD7A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DD7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DD7B0 size=396
    let mut pc: u32 = 0x828DD7B0;
    'dispatch: loop {
        match pc {
            0x828DD7B0 => {
    //   block [0x828DD7B0..0x828DD93C)
	// 828DD7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DD7B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DD7B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DD7BC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828DD7C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD7C4: 419A0018  beq cr6, 0x828dd7dc
	if ctx.cr[6].eq {
	pc = 0x828DD7DC; continue 'dispatch;
	}
	// 828DD7C8: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DD7CC: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828DD7D0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DD7D4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828DD7D8: 409A0008  bne cr6, 0x828dd7e0
	if !ctx.cr[6].eq {
	pc = 0x828DD7E0; continue 'dispatch;
	}
	// 828DD7DC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DD7E0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828DD7E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DD7E8: 419A0140  beq cr6, 0x828dd928
	if ctx.cr[6].eq {
	pc = 0x828DD928; continue 'dispatch;
	}
	// 828DD7EC: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828DD7F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DD7F4: 552827FE  rlwinm r8, r9, 4, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0FFFFFFFu64;
	// 828DD7F8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828DD7FC: 419A00F8  beq cr6, 0x828dd8f4
	if ctx.cr[6].eq {
	pc = 0x828DD8F4; continue 'dispatch;
	}
	// 828DD800: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828DD804: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DD808: 419A0024  beq cr6, 0x828dd82c
	if ctx.cr[6].eq {
	pc = 0x828DD82C; continue 'dispatch;
	}
	// 828DD80C: 892A005C  lbz r9, 0x5c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(92 as u32) ) } as u64;
	// 828DD810: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DD814: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828DD818: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828DD81C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD820: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828DD824: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DD828: 480000D0  b 0x828dd8f8
	pc = 0x828DD8F8; continue 'dispatch;
	// 828DD82C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DD830: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828DD834: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828DD838: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828DD83C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828DD840: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DD844: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DD848: 40810054  ble 0x828dd89c
	if !ctx.cr[0].gt {
	pc = 0x828DD89C; continue 'dispatch;
	}
	// 828DD84C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828DD850: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828DD854: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828DD858: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD85C: 2F07005C  cmpwi cr6, r7, 0x5c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 92, &mut ctx.xer);
	// 828DD860: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828DD864: 41980008  blt cr6, 0x828dd86c
	if ctx.cr[6].lt {
	pc = 0x828DD86C; continue 'dispatch;
	}
	// 828DD868: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828DD86C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828DD870: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828DD874: 419A0014  beq cr6, 0x828dd888
	if ctx.cr[6].eq {
	pc = 0x828DD888; continue 'dispatch;
	}
	// 828DD878: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828DD87C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828DD880: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DD884: 4800000C  b 0x828dd890
	pc = 0x828DD890; continue 'dispatch;
	// 828DD888: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828DD88C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828DD890: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DD894: 4199FFB8  bgt cr6, 0x828dd84c
	if ctx.cr[6].gt {
	pc = 0x828DD84C; continue 'dispatch;
	}
	// 828DD898: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DD89C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828DD8A0: 419A0040  beq cr6, 0x828dd8e0
	if ctx.cr[6].eq {
	pc = 0x828DD8E0; continue 'dispatch;
	}
	// 828DD8A4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD8A8: 2F0B005C  cmpwi cr6, r11, 0x5c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 92, &mut ctx.xer);
	// 828DD8AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DD8B0: 41990008  bgt cr6, 0x828dd8b8
	if ctx.cr[6].gt {
	pc = 0x828DD8B8; continue 'dispatch;
	}
	// 828DD8B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DD8B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DD8BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD8C0: 409A0020  bne cr6, 0x828dd8e0
	if !ctx.cr[6].eq {
	pc = 0x828DD8E0; continue 'dispatch;
	}
	// 828DD8C4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828DD8C8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828DD8CC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DD8D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD8D4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828DD8D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DD8DC: 4800001C  b 0x828dd8f8
	pc = 0x828DD8F8; continue 'dispatch;
	// 828DD8E0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828DD8E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD8E8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828DD8EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DD8F0: 48000008  b 0x828dd8f8
	pc = 0x828DD8F8; continue 'dispatch;
	// 828DD8F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DD8F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DD8FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD900: 419A0028  beq cr6, 0x828dd928
	if ctx.cr[6].eq {
	pc = 0x828DD928; continue 'dispatch;
	}
	// 828DD904: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DD908: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828DD90C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828DD910: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DD914: 4E800421  bctrl
	ctx.lr = 0x828DD918;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DD918: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DD91C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DD920: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DD924: 4E800020  blr
	return;
	// 828DD928: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828DD92C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DD930: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DD934: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DD938: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DD940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DD940 size=380
    let mut pc: u32 = 0x828DD940;
    'dispatch: loop {
        match pc {
            0x828DD940 => {
    //   block [0x828DD940..0x828DDABC)
	// 828DD940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DD944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DD948: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DD94C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828DD950: 419A0018  beq cr6, 0x828dd968
	if ctx.cr[6].eq {
	pc = 0x828DD968; continue 'dispatch;
	}
	// 828DD954: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DD958: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DD95C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DD960: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DD964: 409A0008  bne cr6, 0x828dd96c
	if !ctx.cr[6].eq {
	pc = 0x828DD96C; continue 'dispatch;
	}
	// 828DD968: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DD96C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DD970: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD974: 419A0130  beq cr6, 0x828ddaa4
	if ctx.cr[6].eq {
	pc = 0x828DDAA4; continue 'dispatch;
	}
	// 828DD978: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 828DD97C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DD980: 554927FE  rlwinm r9, r10, 4, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0FFFFFFFu64;
	// 828DD984: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828DD988: 419A00EC  beq cr6, 0x828dda74
	if ctx.cr[6].eq {
	pc = 0x828DDA74; continue 'dispatch;
	}
	// 828DD98C: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828DD990: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD994: 419A0020  beq cr6, 0x828dd9b4
	if ctx.cr[6].eq {
	pc = 0x828DD9B4; continue 'dispatch;
	}
	// 828DD998: 894B005C  lbz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828DD99C: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DD9A0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828DD9A4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828DD9A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DD9AC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD9B0: 480000C8  b 0x828dda78
	pc = 0x828DDA78; continue 'dispatch;
	// 828DD9B4: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DD9B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DD9BC: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828DD9C0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828DD9C4: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828DD9C8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DD9CC: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DD9D0: 40810054  ble 0x828dda24
	if !ctx.cr[0].gt {
	pc = 0x828DDA24; continue 'dispatch;
	}
	// 828DD9D4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828DD9D8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828DD9DC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828DD9E0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD9E4: 2F07005C  cmpwi cr6, r7, 0x5c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 92, &mut ctx.xer);
	// 828DD9E8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828DD9EC: 41980008  blt cr6, 0x828dd9f4
	if ctx.cr[6].lt {
	pc = 0x828DD9F4; continue 'dispatch;
	}
	// 828DD9F0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828DD9F4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828DD9F8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828DD9FC: 419A0014  beq cr6, 0x828dda10
	if ctx.cr[6].eq {
	pc = 0x828DDA10; continue 'dispatch;
	}
	// 828DDA00: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828DDA04: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828DDA08: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DDA0C: 4800000C  b 0x828dda18
	pc = 0x828DDA18; continue 'dispatch;
	// 828DDA10: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828DDA14: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828DDA18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DDA1C: 4199FFB8  bgt cr6, 0x828dd9d4
	if ctx.cr[6].gt {
	pc = 0x828DD9D4; continue 'dispatch;
	}
	// 828DDA20: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DDA24: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828DDA28: 419A003C  beq cr6, 0x828dda64
	if ctx.cr[6].eq {
	pc = 0x828DDA64; continue 'dispatch;
	}
	// 828DDA2C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDA30: 2F0B005C  cmpwi cr6, r11, 0x5c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 92, &mut ctx.xer);
	// 828DDA34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DDA38: 41990008  bgt cr6, 0x828dda40
	if ctx.cr[6].gt {
	pc = 0x828DDA40; continue 'dispatch;
	}
	// 828DDA3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DDA40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DDA44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DDA48: 409A001C  bne cr6, 0x828dda64
	if !ctx.cr[6].eq {
	pc = 0x828DDA64; continue 'dispatch;
	}
	// 828DDA4C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828DDA50: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DDA54: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828DDA58: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DDA5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DDA60: 48000018  b 0x828dda78
	pc = 0x828DDA78; continue 'dispatch;
	// 828DDA64: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828DDA68: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DDA6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DDA70: 48000008  b 0x828dda78
	pc = 0x828DDA78; continue 'dispatch;
	// 828DDA74: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DDA78: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828DDA7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DDA80: 419A0024  beq cr6, 0x828ddaa4
	if ctx.cr[6].eq {
	pc = 0x828DDAA4; continue 'dispatch;
	}
	// 828DDA84: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DDA88: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828DDA8C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828DDA90: 4E800421  bctrl
	ctx.lr = 0x828DDA94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DDA94: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DDA98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DDA9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DDAA0: 4E800020  blr
	return;
	// 828DDAA4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828DDAA8: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DDAAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DDAB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DDAB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DDAB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DDAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DDAC0 size=8
    let mut pc: u32 = 0x828DDAC0;
    'dispatch: loop {
        match pc {
            0x828DDAC0 => {
    //   block [0x828DDAC0..0x828DDAC8)
	// 828DDAC0: 386000C5  li r3, 0xc5
	ctx.r[3].s64 = 197;
	// 828DDAC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DDAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DDAC8 size=60
    let mut pc: u32 = 0x828DDAC8;
    'dispatch: loop {
        match pc {
            0x828DDAC8 => {
    //   block [0x828DDAC8..0x828DDB04)
	// 828DDAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DDACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DDAD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DDAD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DDAD8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828DDADC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DDAE0: 388B9C48  addi r4, r11, -0x63b8
	ctx.r[4].s64 = ctx.r[11].s64 + -25528;
	// 828DDAE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DDAE8: 4B94F3E9  bl 0x8222ced0
	ctx.lr = 0x828DDAEC;
	sub_8222CED0(ctx, base);
	// 828DDAEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DDAF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DDAF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DDAF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DDAFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DDB00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DDB08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DDB08 size=188
    let mut pc: u32 = 0x828DDB08;
    'dispatch: loop {
        match pc {
            0x828DDB08 => {
    //   block [0x828DDB08..0x828DDBC4)
	// 828DDB08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DDB0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DDB10: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DDB14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DDB18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDB1C: 4B8FC895  bl 0x821da3b0
	ctx.lr = 0x828DDB20;
	sub_821DA3B0(ctx, base);
	// 828DDB20: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DDB24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DDB28: 419A0088  beq cr6, 0x828ddbb0
	if ctx.cr[6].eq {
	pc = 0x828DDBB0; continue 'dispatch;
	}
	// 828DDB2C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828DDB30: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828DDB34: 386B435C  addi r3, r11, 0x435c
	ctx.r[3].s64 = ctx.r[11].s64 + 17244;
	// 828DDB38: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828DDB3C: 4B91621D  bl 0x821f3d58
	ctx.lr = 0x828DDB40;
	sub_821F3D58(ctx, base);
	// 828DDB40: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828DDB44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDB48: 4B8D49B1  bl 0x821b24f8
	ctx.lr = 0x828DDB4C;
	sub_821B24F8(ctx, base);
	// 828DDB4C: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 828DDB50: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 828DDB54: 48122B75  bl 0x82a006c8
	ctx.lr = 0x828DDB58;
	sub_82A006C8(ctx, base);
	// 828DDB58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DDB5C: 419A000C  beq cr6, 0x828ddb68
	if ctx.cr[6].eq {
	pc = 0x828DDB68; continue 'dispatch;
	}
	// 828DDB60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDB64: 48000008  b 0x828ddb6c
	pc = 0x828DDB6C; continue 'dispatch;
	// 828DDB68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DDB6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DDB70: 419A0040  beq cr6, 0x828ddbb0
	if ctx.cr[6].eq {
	pc = 0x828DDBB0; continue 'dispatch;
	}
	// 828DDB74: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828DDB78: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828DDB7C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828DDB80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DDB84: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828DDB88: 816A6AB8  lwz r11, 0x6ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828DDB8C: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828DDB90: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DDB94: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DDB98: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDB9C: 4B9868ED  bl 0x82264488
	ctx.lr = 0x828DDBA0;
	sub_82264488(ctx, base);
	// 828DDBA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DDBA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DDBA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DDBAC: 4E800020  blr
	return;
	// 828DDBB0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828DDBB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DDBB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DDBBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DDBC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DDBC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DDBC8 size=136
    let mut pc: u32 = 0x828DDBC8;
    'dispatch: loop {
        match pc {
            0x828DDBC8 => {
    //   block [0x828DDBC8..0x828DDC50)
	// 828DDBC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DDBCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DDBD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DDBD4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DDBD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DDBDC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828DDBE0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828DDBE4: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 828DDBE8: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828DDBEC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DDBF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DDBF4: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DDBF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DDBFC: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DDC00: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DDC04: 4082FFE8  bne 0x828ddbec
	if !ctx.cr[0].eq {
	pc = 0x828DDBEC; continue 'dispatch;
	}
	// 828DDC08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDC0C: 4B8FC7A5  bl 0x821da3b0
	ctx.lr = 0x828DDC10;
	sub_821DA3B0(ctx, base);
	// 828DDC10: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DDC14: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 828DDC18: 419A0020  beq cr6, 0x828ddc38
	if ctx.cr[6].eq {
	pc = 0x828DDC38; continue 'dispatch;
	}
	// 828DDC1C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828DDC20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDC24: 38EB4448  addi r7, r11, 0x4448
	ctx.r[7].s64 = ctx.r[11].s64 + 17480;
	// 828DDC28: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DDC2C: 4B8D48CD  bl 0x821b24f8
	ctx.lr = 0x828DDC30;
	sub_821B24F8(ctx, base);
	// 828DDC30: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 828DDC34: 4BACF765  bl 0x823ad398
	ctx.lr = 0x828DDC38;
	sub_823AD398(ctx, base);
	// 828DDC38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DDC3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DDC40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DDC44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DDC48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DDC4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DDC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DDC50 size=136
    let mut pc: u32 = 0x828DDC50;
    'dispatch: loop {
        match pc {
            0x828DDC50 => {
    //   block [0x828DDC50..0x828DDCD8)
	// 828DDC50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DDC54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DDC58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DDC5C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DDC60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DDC64: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828DDC68: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828DDC6C: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 828DDC70: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828DDC74: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DDC78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DDC7C: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DDC80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DDC84: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DDC88: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DDC8C: 4082FFE8  bne 0x828ddc74
	if !ctx.cr[0].eq {
	pc = 0x828DDC74; continue 'dispatch;
	}
	// 828DDC90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDC94: 4B8FC71D  bl 0x821da3b0
	ctx.lr = 0x828DDC98;
	sub_821DA3B0(ctx, base);
	// 828DDC98: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DDC9C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 828DDCA0: 419A0020  beq cr6, 0x828ddcc0
	if ctx.cr[6].eq {
	pc = 0x828DDCC0; continue 'dispatch;
	}
	// 828DDCA4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828DDCA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDCAC: 38EB3BF4  addi r7, r11, 0x3bf4
	ctx.r[7].s64 = ctx.r[11].s64 + 15348;
	// 828DDCB0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DDCB4: 4B8D4845  bl 0x821b24f8
	ctx.lr = 0x828DDCB8;
	sub_821B24F8(ctx, base);
	// 828DDCB8: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 828DDCBC: 4BACF6DD  bl 0x823ad398
	ctx.lr = 0x828DDCC0;
	sub_823AD398(ctx, base);
	// 828DDCC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DDCC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DDCC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DDCCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DDCD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DDCD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DDCD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DDCD8 size=396
    let mut pc: u32 = 0x828DDCD8;
    'dispatch: loop {
        match pc {
            0x828DDCD8 => {
    //   block [0x828DDCD8..0x828DDE64)
	// 828DDCD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DDCDC: 483CB719  bl 0x82ca93f4
	ctx.lr = 0x828DDCE0;
	sub_82CA93D0(ctx, base);
	// 828DDCE0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DDCE4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828DDCE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DDCEC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828DDCF0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828DDCF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DDCF8: 4B903EB1  bl 0x821e1ba8
	ctx.lr = 0x828DDCFC;
	sub_821E1BA8(ctx, base);
	// 828DDCFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DDD00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDD04: 4B8FC6AD  bl 0x821da3b0
	ctx.lr = 0x828DDD08;
	sub_821DA3B0(ctx, base);
	// 828DDD08: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DDD0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DDD10: 419A0148  beq cr6, 0x828dde58
	if ctx.cr[6].eq {
	pc = 0x828DDE58; continue 'dispatch;
	}
	// 828DDD14: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828DDD18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDD1C: 38EB45AC  addi r7, r11, 0x45ac
	ctx.r[7].s64 = ctx.r[11].s64 + 17836;
	// 828DDD20: 4B8D47D9  bl 0x821b24f8
	ctx.lr = 0x828DDD24;
	sub_821B24F8(ctx, base);
	// 828DDD24: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 828DDD28: 4B9CBCC1  bl 0x822a99e8
	ctx.lr = 0x828DDD2C;
	sub_822A99E8(ctx, base);
	// 828DDD2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DDD30: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828DDD34: 419A0124  beq cr6, 0x828dde58
	if ctx.cr[6].eq {
	pc = 0x828DDE58; continue 'dispatch;
	}
	// 828DDD38: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDD3C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828DDD40: 48122C51  bl 0x82a00990
	ctx.lr = 0x828DDD44;
	sub_82A00990(ctx, base);
	// 828DDD44: 83C10060  lwz r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828DDD48: 82E1005C  lwz r23, 0x5c(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828DDD4C: 83610058  lwz r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DDD50: 7F1EB840  cmplw cr6, r30, r23
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[23].u32, &mut ctx.xer);
	// 828DDD54: 419A00FC  beq cr6, 0x828dde50
	if ctx.cr[6].eq {
	pc = 0x828DDE50; continue 'dispatch;
	}
	// 828DDD58: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828DDD5C: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 828DDD60: 3B800003  li r28, 3
	ctx.r[28].s64 = 3;
	// 828DDD64: 3F00834A  lis r24, -0x7cb6
	ctx.r[24].s64 = -2092302336;
	// 828DDD68: 3B2BE460  addi r25, r11, -0x1ba0
	ctx.r[25].s64 = ctx.r[11].s64 + -7072;
	// 828DDD6C: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828DDD70: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828DDD74: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828DDD78: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828DDD7C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DDD80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDD84: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 828DDD88: 419A0020  beq cr6, 0x828ddda8
	if ctx.cr[6].eq {
	pc = 0x828DDDA8; continue 'dispatch;
	}
	// 828DDD8C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 828DDD90: 409A0018  bne cr6, 0x828ddda8
	if !ctx.cr[6].eq {
	pc = 0x828DDDA8; continue 'dispatch;
	}
	// 828DDD94: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDD98: 8138E454  lwz r9, -0x1bac(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 828DDD9C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828DDDA0: 409A0008  bne cr6, 0x828ddda8
	if !ctx.cr[6].eq {
	pc = 0x828DDDA8; continue 'dispatch;
	}
	// 828DDDA4: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 828DDDA8: 807A6DA0  lwz r3, 0x6da0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828DDDAC: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDDB0: 4B9064A1  bl 0x821e4250
	ctx.lr = 0x828DDDB4;
	sub_821E4250(ctx, base);
	// 828DDDB4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828DDDB8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828DDDBC: 419A0088  beq cr6, 0x828dde44
	if ctx.cr[6].eq {
	pc = 0x828DDE44; continue 'dispatch;
	}
	// 828DDDC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DDDC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDDC8: 480000A1  bl 0x828dde68
	ctx.lr = 0x828DDDCC;
	sub_828DDE68(ctx, base);
	// 828DDDCC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DDDD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DDDD4: 419A0068  beq cr6, 0x828dde3c
	if ctx.cr[6].eq {
	pc = 0x828DDE3C; continue 'dispatch;
	}
	// 828DDDD8: 7FAB07B4  extsw r11, r29
	ctx.r[11].s64 = ctx.r[29].s32 as i64;
	// 828DDDDC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DDDE0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828DDDE4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828DDDE8: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828DDDEC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828DDDF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DDDF4: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828DDDF8: D1890000  stfs f12, 0(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828DDDFC: 93890004  stw r28, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828DDE00: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DDE04: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 828DDE08: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828DDE0C: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DDE10: 4B94B2F9  bl 0x82229108
	ctx.lr = 0x828DDE14;
	sub_82229108(ctx, base);
	// 828DDE14: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DDE18: 388BFFE8  addi r4, r11, -0x18
	ctx.r[4].s64 = ctx.r[11].s64 + -24;
	// 828DDE1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DDE20: 38CBFFF8  addi r6, r11, -8
	ctx.r[6].s64 = ctx.r[11].s64 + -8;
	// 828DDE24: 38ABFFF0  addi r5, r11, -0x10
	ctx.r[5].s64 = ctx.r[11].s64 + -16;
	// 828DDE28: 4B94AF01  bl 0x82228d28
	ctx.lr = 0x828DDE2C;
	sub_82228D28(ctx, base);
	// 828DDE2C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DDE30: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828DDE34: 38EBFFF0  addi r7, r11, -0x10
	ctx.r[7].s64 = ctx.r[11].s64 + -16;
	// 828DDE38: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 828DDE3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDE40: 4B8D9CD9  bl 0x821b7b18
	ctx.lr = 0x828DDE44;
	sub_821B7B18(ctx, base);
	// 828DDE44: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828DDE48: 7F1EB840  cmplw cr6, r30, r23
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[23].u32, &mut ctx.xer);
	// 828DDE4C: 409AFF20  bne cr6, 0x828ddd6c
	if !ctx.cr[6].eq {
	pc = 0x828DDD6C; continue 'dispatch;
	}
	// 828DDE50: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DDE54: 4B93DEE5  bl 0x8221bd38
	ctx.lr = 0x828DDE58;
	sub_8221BD38(ctx, base);
	// 828DDE58: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828DDE5C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828DDE60: 483CB5E4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DDE68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DDE68 size=568
    let mut pc: u32 = 0x828DDE68;
    'dispatch: loop {
        match pc {
            0x828DDE68 => {
    //   block [0x828DDE68..0x828DE0A0)
	// 828DDE68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DDE6C: 483CB595  bl 0x82ca9400
	ctx.lr = 0x828DDE70;
	sub_82CA93D0(ctx, base);
	// 828DDE70: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DDE74: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 828DDE78: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828DDE7C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828DDE80: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DDE84: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DDE88: 419A0204  beq cr6, 0x828de08c
	if ctx.cr[6].eq {
	pc = 0x828DE08C; continue 'dispatch;
	}
	// 828DDE8C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828DDE90: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828DDE94: 3B6B87B0  addi r27, r11, -0x7850
	ctx.r[27].s64 = ctx.r[11].s64 + -30800;
	// 828DDE98: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828DDE9C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DDEA0: 4B915EB9  bl 0x821f3d58
	ctx.lr = 0x828DDEA4;
	sub_821F3D58(ctx, base);
	// 828DDEA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DDEA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DDEAC: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 828DDEB0: 48122819  bl 0x82a006c8
	ctx.lr = 0x828DDEB4;
	sub_82A006C8(ctx, base);
	// 828DDEB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DDEB8: 419A000C  beq cr6, 0x828ddec4
	if ctx.cr[6].eq {
	pc = 0x828DDEC4; continue 'dispatch;
	}
	// 828DDEBC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDEC0: 48000008  b 0x828ddec8
	pc = 0x828DDEC8; continue 'dispatch;
	// 828DDEC4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828DDEC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DDECC: 419A01C0  beq cr6, 0x828de08c
	if ctx.cr[6].eq {
	pc = 0x828DE08C; continue 'dispatch;
	}
	// 828DDED0: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828DDED4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828DDED8: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 828DDEDC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828DDEE0: 816A6AB8  lwz r11, 0x6ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828DDEE4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828DDEE8: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DDEEC: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DDEF0: 80670000  lwz r3, 0(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDEF4: 4B986595  bl 0x82264488
	ctx.lr = 0x828DDEF8;
	sub_82264488(ctx, base);
	// 828DDEF8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DDEFC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828DDF00: 419A0018  beq cr6, 0x828ddf18
	if ctx.cr[6].eq {
	pc = 0x828DDF18; continue 'dispatch;
	}
	// 828DDF04: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DDF08: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DDF0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DDF10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DDF14: 409A0008  bne cr6, 0x828ddf1c
	if !ctx.cr[6].eq {
	pc = 0x828DDF1C; continue 'dispatch;
	}
	// 828DDF18: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828DDF1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DDF20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DDF24: 419A0168  beq cr6, 0x828de08c
	if ctx.cr[6].eq {
	pc = 0x828DE08C; continue 'dispatch;
	}
	// 828DDF28: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828DDF2C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828DDF30: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828DDF34: 4B903C75  bl 0x821e1ba8
	ctx.lr = 0x828DDF38;
	sub_821E1BA8(ctx, base);
	// 828DDF38: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828DDF3C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828DDF40: 38AB3C08  addi r5, r11, 0x3c08
	ctx.r[5].s64 = ctx.r[11].s64 + 15368;
	// 828DDF44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DDF48: 4B9DB8A9  bl 0x822b97f0
	ctx.lr = 0x828DDF4C;
	sub_822B97F0(ctx, base);
	// 828DDF4C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828DDF50: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828DDF54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DDF58: 4BB236D9  bl 0x82401630
	ctx.lr = 0x828DDF5C;
	sub_82401630(ctx, base);
	// 828DDF5C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828DDF60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DDF64: 3BCA3C20  addi r30, r10, 0x3c20
	ctx.r[30].s64 = ctx.r[10].s64 + 15392;
	// 828DDF68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DDF6C: 4BAE18B5  bl 0x823bf820
	ctx.lr = 0x828DDF70;
	sub_823BF820(ctx, base);
	// 828DDF70: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828DDF74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DDF78: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DDF7C: 4BB23545  bl 0x824014c0
	ctx.lr = 0x828DDF80;
	sub_824014C0(ctx, base);
	// 828DDF80: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828DDF84: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828DDF88: 3BC97088  addi r30, r9, 0x7088
	ctx.r[30].s64 = ctx.r[9].s64 + 28808;
	// 828DDF8C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828DDF90: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 828DDF94: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DDF98: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 828DDF9C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 828DDFA0: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DDFA4: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DDFA8: 4082FFE8  bne 0x828ddf90
	if !ctx.cr[0].eq {
	pc = 0x828DDF90; continue 'dispatch;
	}
	// 828DDFAC: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 828DDFB0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828DDFB4: 3B643C38  addi r27, r4, 0x3c38
	ctx.r[27].s64 = ctx.r[4].s64 + 15416;
	// 828DDFB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DDFBC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828DDFC0: 4BACF3D9  bl 0x823ad398
	ctx.lr = 0x828DDFC4;
	sub_823AD398(ctx, base);
	// 828DDFC4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828DDFC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDFCC: 4B912275  bl 0x821f0240
	ctx.lr = 0x828DDFD0;
	sub_821F0240(ctx, base);
	// 828DDFD0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828DDFD4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828DDFD8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DDFDC: 4BB2356D  bl 0x82401548
	ctx.lr = 0x828DDFE0;
	sub_82401548(ctx, base);
	// 828DDFE0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828DDFE4: 7D6000A6  mfmsr r11
	ctx.r[11].u64 = ctx.msr;
	// 828DDFE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DDFEC: 7C60F028  lwarx r3, 0, r30
	// lwarx
	let ea = ctx.r[30].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[3].u64 = ctx.reserved.u32 as u64;
	// 828DDFF0: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 828DDFF4: 7C60F12D  stwcx. r3, 0, r30
	// stwcx.
	let addr = ctx.r[30].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[3].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DDFF8: 7D610164  mtmsrd r11, 1
	ctx.msr = (ctx.r[11].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DDFFC: 4082FFE8  bne 0x828ddfe4
	if !ctx.cr[0].eq {
	pc = 0x828DDFE4; continue 'dispatch;
	}
	// 828DE000: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828DE004: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DE008: 3BCA3C40  addi r30, r10, 0x3c40
	ctx.r[30].s64 = ctx.r[10].s64 + 15424;
	// 828DE00C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DE010: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DE014: 4BACF385  bl 0x823ad398
	ctx.lr = 0x828DE018;
	sub_823AD398(ctx, base);
	// 828DE018: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DE01C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE020: 4B912221  bl 0x821f0240
	ctx.lr = 0x828DE024;
	sub_821F0240(ctx, base);
	// 828DE024: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828DE028: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DE02C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE030: 4BB23519  bl 0x82401548
	ctx.lr = 0x828DE034;
	sub_82401548(ctx, base);
	// 828DE034: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828DE038: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828DE03C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DE040: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828DE044: 913C0000  stw r9, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828DE048: 419A0020  beq cr6, 0x828de068
	if ctx.cr[6].eq {
	pc = 0x828DE068; continue 'dispatch;
	}
	// 828DE04C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DE050: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DE054: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DE058: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DE05C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DE060: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DE064: 4082FFE8  bne 0x828de04c
	if !ctx.cr[0].eq {
	pc = 0x828DE04C; continue 'dispatch;
	}
	// 828DE068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DE06C: 4B936D6D  bl 0x82214dd8
	ctx.lr = 0x828DE070;
	sub_82214DD8(ctx, base);
	// 828DE070: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DE074: 4B936D65  bl 0x82214dd8
	ctx.lr = 0x828DE078;
	sub_82214DD8(ctx, base);
	// 828DE078: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE07C: 4B8D9A9D  bl 0x821b7b18
	ctx.lr = 0x828DE080;
	sub_821B7B18(ctx, base);
	// 828DE080: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DE084: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828DE088: 483CB3C8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828DE08C: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828DE090: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DE094: 93BC0004  stw r29, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828DE098: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828DE09C: 483CB3B4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DE0A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DE0A0 size=396
    let mut pc: u32 = 0x828DE0A0;
    'dispatch: loop {
        match pc {
            0x828DE0A0 => {
    //   block [0x828DE0A0..0x828DE22C)
	// 828DE0A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DE0A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DE0A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DE0AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DE0B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DE0B4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828DE0B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DE0BC: 3BCB3C50  addi r30, r11, 0x3c50
	ctx.r[30].s64 = ctx.r[11].s64 + 15440;
	// 828DE0C0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DE0C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DE0C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DE0CC: 4B94EE05  bl 0x8222ced0
	ctx.lr = 0x828DE0D0;
	sub_8222CED0(ctx, base);
	// 828DE0D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DE0D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DE0D8: 48000159  bl 0x828de230
	ctx.lr = 0x828DE0DC;
	sub_828DE230(ctx, base);
	// 828DE0DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DE0E0: 4B936CF9  bl 0x82214dd8
	ctx.lr = 0x828DE0E4;
	sub_82214DD8(ctx, base);
	// 828DE0E4: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828DE0E8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DE0EC: 388A3C64  addi r4, r10, 0x3c64
	ctx.r[4].s64 = ctx.r[10].s64 + 15460;
	// 828DE0F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DE0F4: 4B94EDDD  bl 0x8222ced0
	ctx.lr = 0x828DE0F8;
	sub_8222CED0(ctx, base);
	// 828DE0F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DE0FC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DE100: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DE104: 4B94EDCD  bl 0x8222ced0
	ctx.lr = 0x828DE108;
	sub_8222CED0(ctx, base);
	// 828DE108: 3D20828E  lis r9, -0x7d72
	ctx.r[9].s64 = -2104623104;
	// 828DE10C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DE110: 38C9DB08  addi r6, r9, -0x24f8
	ctx.r[6].s64 = ctx.r[9].s64 + -9464;
	// 828DE114: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828DE118: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DE11C: 4800035D  bl 0x828de478
	ctx.lr = 0x828DE120;
	sub_828DE478(ctx, base);
	// 828DE120: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DE124: 4B936CB5  bl 0x82214dd8
	ctx.lr = 0x828DE128;
	sub_82214DD8(ctx, base);
	// 828DE128: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DE12C: 4B936CAD  bl 0x82214dd8
	ctx.lr = 0x828DE130;
	sub_82214DD8(ctx, base);
	// 828DE130: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828DE134: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DE138: 38883C78  addi r4, r8, 0x3c78
	ctx.r[4].s64 = ctx.r[8].s64 + 15480;
	// 828DE13C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DE140: 4B94ED91  bl 0x8222ced0
	ctx.lr = 0x828DE144;
	sub_8222CED0(ctx, base);
	// 828DE144: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DE148: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DE14C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DE150: 4B94ED81  bl 0x8222ced0
	ctx.lr = 0x828DE154;
	sub_8222CED0(ctx, base);
	// 828DE154: 3CE0828E  lis r7, -0x7d72
	ctx.r[7].s64 = -2104623104;
	// 828DE158: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DE15C: 38C7DBC8  addi r6, r7, -0x2438
	ctx.r[6].s64 = ctx.r[7].s64 + -9272;
	// 828DE160: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DE164: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828DE168: 48000519  bl 0x828de680
	ctx.lr = 0x828DE16C;
	sub_828DE680(ctx, base);
	// 828DE16C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DE170: 4B936C69  bl 0x82214dd8
	ctx.lr = 0x828DE174;
	sub_82214DD8(ctx, base);
	// 828DE174: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DE178: 4B936C61  bl 0x82214dd8
	ctx.lr = 0x828DE17C;
	sub_82214DD8(ctx, base);
	// 828DE17C: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828DE180: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DE184: 38863C88  addi r4, r6, 0x3c88
	ctx.r[4].s64 = ctx.r[6].s64 + 15496;
	// 828DE188: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DE18C: 4B94ED45  bl 0x8222ced0
	ctx.lr = 0x828DE190;
	sub_8222CED0(ctx, base);
	// 828DE190: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DE194: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DE198: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DE19C: 4B94ED35  bl 0x8222ced0
	ctx.lr = 0x828DE1A0;
	sub_8222CED0(ctx, base);
	// 828DE1A0: 3C80828E  lis r4, -0x7d72
	ctx.r[4].s64 = -2104623104;
	// 828DE1A4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DE1A8: 38C4DC50  addi r6, r4, -0x23b0
	ctx.r[6].s64 = ctx.r[4].s64 + -9136;
	// 828DE1AC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828DE1B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DE1B4: 480004CD  bl 0x828de680
	ctx.lr = 0x828DE1B8;
	sub_828DE680(ctx, base);
	// 828DE1B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DE1BC: 4B936C1D  bl 0x82214dd8
	ctx.lr = 0x828DE1C0;
	sub_82214DD8(ctx, base);
	// 828DE1C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DE1C4: 4B936C15  bl 0x82214dd8
	ctx.lr = 0x828DE1C8;
	sub_82214DD8(ctx, base);
	// 828DE1C8: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 828DE1CC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DE1D0: 38833C9C  addi r4, r3, 0x3c9c
	ctx.r[4].s64 = ctx.r[3].s64 + 15516;
	// 828DE1D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DE1D8: 4B94ECF9  bl 0x8222ced0
	ctx.lr = 0x828DE1DC;
	sub_8222CED0(ctx, base);
	// 828DE1DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DE1E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DE1E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DE1E8: 4B94ECE9  bl 0x8222ced0
	ctx.lr = 0x828DE1EC;
	sub_8222CED0(ctx, base);
	// 828DE1EC: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DE1F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DE1F4: 38CBDCD8  addi r6, r11, -0x2328
	ctx.r[6].s64 = ctx.r[11].s64 + -9000;
	// 828DE1F8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828DE1FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DE200: 48000681  bl 0x828de880
	ctx.lr = 0x828DE204;
	sub_828DE880(ctx, base);
	// 828DE204: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DE208: 4B936BD1  bl 0x82214dd8
	ctx.lr = 0x828DE20C;
	sub_82214DD8(ctx, base);
	// 828DE20C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DE210: 4B936BC9  bl 0x82214dd8
	ctx.lr = 0x828DE214;
	sub_82214DD8(ctx, base);
	// 828DE214: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DE218: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DE21C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DE220: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DE224: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DE228: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DE230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DE230 size=584
    let mut pc: u32 = 0x828DE230;
    'dispatch: loop {
        match pc {
            0x828DE230 => {
    //   block [0x828DE230..0x828DE478)
	// 828DE230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DE234: 483CB1CD  bl 0x82ca9400
	ctx.lr = 0x828DE238;
	sub_82CA93D0(ctx, base);
	// 828DE238: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DE23C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE240: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828DE244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DE248: 409A0010  bne cr6, 0x828de258
	if !ctx.cr[6].eq {
	pc = 0x828DE258; continue 'dispatch;
	}
	// 828DE24C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DE250: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828DE254: 48000008  b 0x828de25c
	pc = 0x828DE25C; continue 'dispatch;
	// 828DE258: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE25C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DE260: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE264: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE268: 4BAF0359  bl 0x823ce5c0
	ctx.lr = 0x828DE26C;
	sub_823CE5C0(ctx, base);
	// 828DE26C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE270: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DE274: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DE278: 4BAEFF89  bl 0x823ce200
	ctx.lr = 0x828DE27C;
	sub_823CE200(ctx, base);
	// 828DE27C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE280: 4B8D9899  bl 0x821b7b18
	ctx.lr = 0x828DE284;
	sub_821B7B18(ctx, base);
	// 828DE284: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828DE288: 4B940FD1  bl 0x8221f258
	ctx.lr = 0x828DE28C;
	sub_8221F258(ctx, base);
	// 828DE28C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DE290: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DE294: 419A0040  beq cr6, 0x828de2d4
	if ctx.cr[6].eq {
	pc = 0x828DE2D4; continue 'dispatch;
	}
	// 828DE298: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828DE29C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828DE2A0: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828DE2A4: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DE2A8: 4B940FB1  bl 0x8221f258
	ctx.lr = 0x828DE2AC;
	sub_8221F258(ctx, base);
	// 828DE2AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DE2B0: 419A0028  beq cr6, 0x828de2d8
	if ctx.cr[6].eq {
	pc = 0x828DE2D8; continue 'dispatch;
	}
	// 828DE2B4: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828DE2B8: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828DE2BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DE2C0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828DE2C4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DE2C8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828DE2CC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DE2D0: 4800000C  b 0x828de2dc
	pc = 0x828DE2DC; continue 'dispatch;
	// 828DE2D4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DE2D8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828DE2DC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DE2E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DE2E4: 419A00FC  beq cr6, 0x828de3e0
	if ctx.cr[6].eq {
	pc = 0x828DE3E0; continue 'dispatch;
	}
	// 828DE2E8: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE2EC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828DE2F0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DE2F4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828DE2F8: 4B94AE11  bl 0x82229108
	ctx.lr = 0x828DE2FC;
	sub_82229108(ctx, base);
	// 828DE2FC: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DE300: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828DE304: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828DE308: 3BCBEA88  addi r30, r11, -0x1578
	ctx.r[30].s64 = ctx.r[11].s64 + -5496;
	// 828DE30C: 4B949575  bl 0x82227880
	ctx.lr = 0x828DE310;
	sub_82227880(ctx, base);
	// 828DE310: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DE314: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828DE318: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828DE31C: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828DE320: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828DE324: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828DE328: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828DE32C: 4B8BC755  bl 0x8219aa80
	ctx.lr = 0x828DE330;
	sub_8219AA80(ctx, base);
	// 828DE330: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828DE334: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828DE338: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828DE33C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DE340: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828DE344: 4BAF00DD  bl 0x823ce420
	ctx.lr = 0x828DE348;
	sub_823CE420(ctx, base);
	// 828DE348: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828DE34C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828DE350: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828DE354: 48146375  bl 0x82a246c8
	ctx.lr = 0x828DE358;
	sub_82A246C8(ctx, base);
	// 828DE358: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DE35C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828DE360: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828DE364: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828DE368: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DE36C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE370: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE374: 4B94AD95  bl 0x82229108
	ctx.lr = 0x828DE378;
	sub_82229108(ctx, base);
	// 828DE378: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DE37C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828DE380: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE384: 3BEBDAC0  addi r31, r11, -0x2540
	ctx.r[31].s64 = ctx.r[11].s64 + -9536;
	// 828DE388: 4B9494F9  bl 0x82227880
	ctx.lr = 0x828DE38C;
	sub_82227880(ctx, base);
	// 828DE38C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828DE390: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828DE394: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828DE398: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828DE39C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE3A0: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828DE3A4: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828DE3A8: 4B8BC6D9  bl 0x8219aa80
	ctx.lr = 0x828DE3AC;
	sub_8219AA80(ctx, base);
	// 828DE3AC: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828DE3B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DE3B4: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828DE3B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DE3BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DE3C0: 4BAF0061  bl 0x823ce420
	ctx.lr = 0x828DE3C4;
	sub_823CE420(ctx, base);
	// 828DE3C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DE3C8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828DE3CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE3D0: 481462F9  bl 0x82a246c8
	ctx.lr = 0x828DE3D4;
	sub_82A246C8(ctx, base);
	// 828DE3D4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DE3D8: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828DE3DC: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828DE3E0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828DE3E4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828DE3E8: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828DE3EC: 419A0020  beq cr6, 0x828de40c
	if ctx.cr[6].eq {
	pc = 0x828DE40C; continue 'dispatch;
	}
	// 828DE3F0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DE3F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DE3F8: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DE3FC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828DE400: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DE404: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DE408: 4082FFE8  bne 0x828de3f0
	if !ctx.cr[0].eq {
	pc = 0x828DE3F0; continue 'dispatch;
	}
	// 828DE40C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DE410: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DE414: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828DE418: 4BA17531  bl 0x822f5948
	ctx.lr = 0x828DE41C;
	sub_822F5948(ctx, base);
	// 828DE41C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE420: 4B8D96F9  bl 0x821b7b18
	ctx.lr = 0x828DE424;
	sub_821B7B18(ctx, base);
	// 828DE424: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828DE428: 419A0040  beq cr6, 0x828de468
	if ctx.cr[6].eq {
	pc = 0x828DE468; continue 'dispatch;
	}
	// 828DE42C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DE430: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DE434: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DE438: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DE43C: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DE440: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DE444: 4082FFE8  bne 0x828de42c
	if !ctx.cr[0].eq {
	pc = 0x828DE42C; continue 'dispatch;
	}
	// 828DE448: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DE44C: 409A001C  bne cr6, 0x828de468
	if !ctx.cr[6].eq {
	pc = 0x828DE468; continue 'dispatch;
	}
	// 828DE450: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DE454: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DE458: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DE45C: 4E800421  bctrl
	ctx.lr = 0x828DE460;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DE460: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DE464: 4B93D8D5  bl 0x8221bd38
	ctx.lr = 0x828DE468;
	sub_8221BD38(ctx, base);
	// 828DE468: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DE46C: 4B8D96AD  bl 0x821b7b18
	ctx.lr = 0x828DE470;
	sub_821B7B18(ctx, base);
	// 828DE470: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828DE474: 483CAFDC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DE478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DE478 size=516
    let mut pc: u32 = 0x828DE478;
    'dispatch: loop {
        match pc {
            0x828DE478 => {
    //   block [0x828DE478..0x828DE67C)
	// 828DE478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DE47C: 483CAF81  bl 0x82ca93fc
	ctx.lr = 0x828DE480;
	sub_82CA93D0(ctx, base);
	// 828DE480: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DE484: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DE488: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828DE48C: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828DE490: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828DE494: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828DE498: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE49C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828DE4A0: 3BAADB08  addi r29, r10, -0x24f8
	ctx.r[29].s64 = ctx.r[10].s64 + -9464;
	// 828DE4A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DE4A8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DE4AC: 419A0008  beq cr6, 0x828de4b4
	if ctx.cr[6].eq {
	pc = 0x828DE4B4; continue 'dispatch;
	}
	// 828DE4B0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE4B4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DE4B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE4BC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE4C0: 4BAF0101  bl 0x823ce5c0
	ctx.lr = 0x828DE4C4;
	sub_823CE5C0(ctx, base);
	// 828DE4C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE4C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE4CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DE4D0: 4BAEFC41  bl 0x823ce110
	ctx.lr = 0x828DE4D4;
	sub_823CE110(ctx, base);
	// 828DE4D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE4D8: 4B8D9641  bl 0x821b7b18
	ctx.lr = 0x828DE4DC;
	sub_821B7B18(ctx, base);
	// 828DE4DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828DE4E0: 4B940D79  bl 0x8221f258
	ctx.lr = 0x828DE4E4;
	sub_8221F258(ctx, base);
	// 828DE4E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DE4E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DE4EC: 419A005C  beq cr6, 0x828de548
	if ctx.cr[6].eq {
	pc = 0x828DE548; continue 'dispatch;
	}
	// 828DE4F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828DE4F4: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828DE4F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DE4FC: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828DE500: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828DE504: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DE508: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828DE50C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828DE510: 4B911D31  bl 0x821f0240
	ctx.lr = 0x828DE514;
	sub_821F0240(ctx, base);
	// 828DE514: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828DE518: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828DE51C: 4B940D3D  bl 0x8221f258
	ctx.lr = 0x828DE520;
	sub_8221F258(ctx, base);
	// 828DE520: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DE524: 419A0028  beq cr6, 0x828de54c
	if ctx.cr[6].eq {
	pc = 0x828DE54C; continue 'dispatch;
	}
	// 828DE528: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828DE52C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828DE530: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DE534: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828DE538: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DE53C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DE540: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DE544: 4800000C  b 0x828de550
	pc = 0x828DE550; continue 'dispatch;
	// 828DE548: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828DE54C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DE550: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE554: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DE558: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DE55C: 419A0008  beq cr6, 0x828de564
	if ctx.cr[6].eq {
	pc = 0x828DE564; continue 'dispatch;
	}
	// 828DE560: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE564: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DE568: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DE56C: 419A0078  beq cr6, 0x828de5e4
	if ctx.cr[6].eq {
	pc = 0x828DE5E4; continue 'dispatch;
	}
	// 828DE570: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE574: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828DE578: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DE57C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DE580: 4B94AB89  bl 0x82229108
	ctx.lr = 0x828DE584;
	sub_82229108(ctx, base);
	// 828DE584: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DE588: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828DE58C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DE590: 3BCBEAC8  addi r30, r11, -0x1538
	ctx.r[30].s64 = ctx.r[11].s64 + -5432;
	// 828DE594: 4B9492ED  bl 0x82227880
	ctx.lr = 0x828DE598;
	sub_82227880(ctx, base);
	// 828DE598: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DE59C: 3D40823B  lis r10, -0x7dc5
	ctx.r[10].s64 = -2110062592;
	// 828DE5A0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828DE5A4: 388A08A0  addi r4, r10, 0x8a0
	ctx.r[4].s64 = ctx.r[10].s64 + 2208;
	// 828DE5A8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DE5AC: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828DE5B0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828DE5B4: 4B8BC4CD  bl 0x8219aa80
	ctx.lr = 0x828DE5B8;
	sub_8219AA80(ctx, base);
	// 828DE5B8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DE5BC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828DE5C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE5C4: 4BAEFE5D  bl 0x823ce420
	ctx.lr = 0x828DE5C8;
	sub_823CE420(ctx, base);
	// 828DE5C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DE5CC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828DE5D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DE5D4: 481460F5  bl 0x82a246c8
	ctx.lr = 0x828DE5D8;
	sub_82A246C8(ctx, base);
	// 828DE5D8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DE5DC: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828DE5E0: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828DE5E4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828DE5E8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DE5EC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828DE5F0: 419A0020  beq cr6, 0x828de610
	if ctx.cr[6].eq {
	pc = 0x828DE610; continue 'dispatch;
	}
	// 828DE5F4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DE5F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DE5FC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DE600: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828DE604: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DE608: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DE60C: 4082FFE8  bne 0x828de5f4
	if !ctx.cr[0].eq {
	pc = 0x828DE5F4; continue 'dispatch;
	}
	// 828DE610: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DE614: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DE618: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828DE61C: 4BA1732D  bl 0x822f5948
	ctx.lr = 0x828DE620;
	sub_822F5948(ctx, base);
	// 828DE620: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DE624: 4B8D94F5  bl 0x821b7b18
	ctx.lr = 0x828DE628;
	sub_821B7B18(ctx, base);
	// 828DE628: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DE62C: 419A0040  beq cr6, 0x828de66c
	if ctx.cr[6].eq {
	pc = 0x828DE66C; continue 'dispatch;
	}
	// 828DE630: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DE634: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DE638: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DE63C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DE640: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DE644: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DE648: 4082FFE8  bne 0x828de630
	if !ctx.cr[0].eq {
	pc = 0x828DE630; continue 'dispatch;
	}
	// 828DE64C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DE650: 409A001C  bne cr6, 0x828de66c
	if !ctx.cr[6].eq {
	pc = 0x828DE66C; continue 'dispatch;
	}
	// 828DE654: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DE658: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DE65C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DE660: 4E800421  bctrl
	ctx.lr = 0x828DE664;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DE664: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DE668: 4B93D6D1  bl 0x8221bd38
	ctx.lr = 0x828DE66C;
	sub_8221BD38(ctx, base);
	// 828DE66C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE670: 4B8D94A9  bl 0x821b7b18
	ctx.lr = 0x828DE674;
	sub_821B7B18(ctx, base);
	// 828DE674: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828DE678: 483CADD4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DE680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DE680 size=512
    let mut pc: u32 = 0x828DE680;
    'dispatch: loop {
        match pc {
            0x828DE680 => {
    //   block [0x828DE680..0x828DE880)
	// 828DE680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DE684: 483CAD79  bl 0x82ca93fc
	ctx.lr = 0x828DE688;
	sub_82CA93D0(ctx, base);
	// 828DE688: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DE68C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DE690: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828DE694: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828DE698: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828DE69C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828DE6A0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE6A4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828DE6A8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DE6AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DE6B0: 419A0008  beq cr6, 0x828de6b8
	if ctx.cr[6].eq {
	pc = 0x828DE6B8; continue 'dispatch;
	}
	// 828DE6B4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE6B8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DE6BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE6C0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE6C4: 4BAEFEFD  bl 0x823ce5c0
	ctx.lr = 0x828DE6C8;
	sub_823CE5C0(ctx, base);
	// 828DE6C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE6CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE6D0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DE6D4: 4BAEFA3D  bl 0x823ce110
	ctx.lr = 0x828DE6D8;
	sub_823CE110(ctx, base);
	// 828DE6D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE6DC: 4B8D943D  bl 0x821b7b18
	ctx.lr = 0x828DE6E0;
	sub_821B7B18(ctx, base);
	// 828DE6E0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828DE6E4: 4B940B75  bl 0x8221f258
	ctx.lr = 0x828DE6E8;
	sub_8221F258(ctx, base);
	// 828DE6E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DE6EC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DE6F0: 419A005C  beq cr6, 0x828de74c
	if ctx.cr[6].eq {
	pc = 0x828DE74C; continue 'dispatch;
	}
	// 828DE6F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828DE6F8: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828DE6FC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DE700: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828DE704: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828DE708: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DE70C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828DE710: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828DE714: 4B911B2D  bl 0x821f0240
	ctx.lr = 0x828DE718;
	sub_821F0240(ctx, base);
	// 828DE718: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828DE71C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828DE720: 4B940B39  bl 0x8221f258
	ctx.lr = 0x828DE724;
	sub_8221F258(ctx, base);
	// 828DE724: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DE728: 419A0028  beq cr6, 0x828de750
	if ctx.cr[6].eq {
	pc = 0x828DE750; continue 'dispatch;
	}
	// 828DE72C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828DE730: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828DE734: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DE738: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828DE73C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DE740: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DE744: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DE748: 4800000C  b 0x828de754
	pc = 0x828DE754; continue 'dispatch;
	// 828DE74C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828DE750: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DE754: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE758: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DE75C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DE760: 419A0008  beq cr6, 0x828de768
	if ctx.cr[6].eq {
	pc = 0x828DE768; continue 'dispatch;
	}
	// 828DE764: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE768: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DE76C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DE770: 419A0078  beq cr6, 0x828de7e8
	if ctx.cr[6].eq {
	pc = 0x828DE7E8; continue 'dispatch;
	}
	// 828DE774: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE778: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828DE77C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DE780: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DE784: 4B94A985  bl 0x82229108
	ctx.lr = 0x828DE788;
	sub_82229108(ctx, base);
	// 828DE788: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DE78C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828DE790: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DE794: 3BCBEC40  addi r30, r11, -0x13c0
	ctx.r[30].s64 = ctx.r[11].s64 + -5056;
	// 828DE798: 4B9490E9  bl 0x82227880
	ctx.lr = 0x828DE79C;
	sub_82227880(ctx, base);
	// 828DE79C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DE7A0: 3D408289  lis r10, -0x7d77
	ctx.r[10].s64 = -2104950784;
	// 828DE7A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828DE7A8: 388A39E8  addi r4, r10, 0x39e8
	ctx.r[4].s64 = ctx.r[10].s64 + 14824;
	// 828DE7AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DE7B0: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828DE7B4: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828DE7B8: 4B8BC2C9  bl 0x8219aa80
	ctx.lr = 0x828DE7BC;
	sub_8219AA80(ctx, base);
	// 828DE7BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DE7C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828DE7C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE7C8: 4BAEFC59  bl 0x823ce420
	ctx.lr = 0x828DE7CC;
	sub_823CE420(ctx, base);
	// 828DE7CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DE7D0: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828DE7D4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DE7D8: 48145EF1  bl 0x82a246c8
	ctx.lr = 0x828DE7DC;
	sub_82A246C8(ctx, base);
	// 828DE7DC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DE7E0: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828DE7E4: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828DE7E8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828DE7EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DE7F0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828DE7F4: 419A0020  beq cr6, 0x828de814
	if ctx.cr[6].eq {
	pc = 0x828DE814; continue 'dispatch;
	}
	// 828DE7F8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DE7FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DE800: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DE804: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828DE808: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DE80C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DE810: 4082FFE8  bne 0x828de7f8
	if !ctx.cr[0].eq {
	pc = 0x828DE7F8; continue 'dispatch;
	}
	// 828DE814: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DE818: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DE81C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828DE820: 4BA17129  bl 0x822f5948
	ctx.lr = 0x828DE824;
	sub_822F5948(ctx, base);
	// 828DE824: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DE828: 4B8D92F1  bl 0x821b7b18
	ctx.lr = 0x828DE82C;
	sub_821B7B18(ctx, base);
	// 828DE82C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DE830: 419A0040  beq cr6, 0x828de870
	if ctx.cr[6].eq {
	pc = 0x828DE870; continue 'dispatch;
	}
	// 828DE834: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DE838: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DE83C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DE840: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DE844: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DE848: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DE84C: 4082FFE8  bne 0x828de834
	if !ctx.cr[0].eq {
	pc = 0x828DE834; continue 'dispatch;
	}
	// 828DE850: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DE854: 409A001C  bne cr6, 0x828de870
	if !ctx.cr[6].eq {
	pc = 0x828DE870; continue 'dispatch;
	}
	// 828DE858: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DE85C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DE860: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DE864: 4E800421  bctrl
	ctx.lr = 0x828DE868;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DE868: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DE86C: 4B93D4CD  bl 0x8221bd38
	ctx.lr = 0x828DE870;
	sub_8221BD38(ctx, base);
	// 828DE870: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE874: 4B8D92A5  bl 0x821b7b18
	ctx.lr = 0x828DE878;
	sub_821B7B18(ctx, base);
	// 828DE878: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828DE87C: 483CABD0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DE880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DE880 size=516
    let mut pc: u32 = 0x828DE880;
    'dispatch: loop {
        match pc {
            0x828DE880 => {
    //   block [0x828DE880..0x828DEA84)
	// 828DE880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DE884: 483CAB79  bl 0x82ca93fc
	ctx.lr = 0x828DE888;
	sub_82CA93D0(ctx, base);
	// 828DE888: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DE88C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DE890: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828DE894: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828DE898: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828DE89C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828DE8A0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE8A4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828DE8A8: 3BAADCD8  addi r29, r10, -0x2328
	ctx.r[29].s64 = ctx.r[10].s64 + -9000;
	// 828DE8AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DE8B0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DE8B4: 419A0008  beq cr6, 0x828de8bc
	if ctx.cr[6].eq {
	pc = 0x828DE8BC; continue 'dispatch;
	}
	// 828DE8B8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE8BC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DE8C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE8C4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE8C8: 4BAEFCF9  bl 0x823ce5c0
	ctx.lr = 0x828DE8CC;
	sub_823CE5C0(ctx, base);
	// 828DE8CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE8D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE8D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DE8D8: 4BAEF839  bl 0x823ce110
	ctx.lr = 0x828DE8DC;
	sub_823CE110(ctx, base);
	// 828DE8DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE8E0: 4B8D9239  bl 0x821b7b18
	ctx.lr = 0x828DE8E4;
	sub_821B7B18(ctx, base);
	// 828DE8E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828DE8E8: 4B940971  bl 0x8221f258
	ctx.lr = 0x828DE8EC;
	sub_8221F258(ctx, base);
	// 828DE8EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DE8F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DE8F4: 419A005C  beq cr6, 0x828de950
	if ctx.cr[6].eq {
	pc = 0x828DE950; continue 'dispatch;
	}
	// 828DE8F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828DE8FC: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828DE900: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DE904: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828DE908: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828DE90C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DE910: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828DE914: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828DE918: 4B911929  bl 0x821f0240
	ctx.lr = 0x828DE91C;
	sub_821F0240(ctx, base);
	// 828DE91C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828DE920: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828DE924: 4B940935  bl 0x8221f258
	ctx.lr = 0x828DE928;
	sub_8221F258(ctx, base);
	// 828DE928: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DE92C: 419A0028  beq cr6, 0x828de954
	if ctx.cr[6].eq {
	pc = 0x828DE954; continue 'dispatch;
	}
	// 828DE930: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828DE934: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828DE938: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DE93C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828DE940: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DE944: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DE948: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DE94C: 4800000C  b 0x828de958
	pc = 0x828DE958; continue 'dispatch;
	// 828DE950: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828DE954: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DE958: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE95C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828DE960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DE964: 419A0008  beq cr6, 0x828de96c
	if ctx.cr[6].eq {
	pc = 0x828DE96C; continue 'dispatch;
	}
	// 828DE968: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE96C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DE970: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DE974: 419A0078  beq cr6, 0x828de9ec
	if ctx.cr[6].eq {
	pc = 0x828DE9EC; continue 'dispatch;
	}
	// 828DE978: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE97C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828DE980: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DE984: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DE988: 4B94A781  bl 0x82229108
	ctx.lr = 0x828DE98C;
	sub_82229108(ctx, base);
	// 828DE98C: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DE990: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828DE994: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DE998: 3BCBEDF8  addi r30, r11, -0x1208
	ctx.r[30].s64 = ctx.r[11].s64 + -4616;
	// 828DE99C: 4B948EE5  bl 0x82227880
	ctx.lr = 0x828DE9A0;
	sub_82227880(ctx, base);
	// 828DE9A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DE9A4: 3D408248  lis r10, -0x7db8
	ctx.r[10].s64 = -2109210624;
	// 828DE9A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828DE9AC: 388A1200  addi r4, r10, 0x1200
	ctx.r[4].s64 = ctx.r[10].s64 + 4608;
	// 828DE9B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DE9B4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828DE9B8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828DE9BC: 4B8BC0C5  bl 0x8219aa80
	ctx.lr = 0x828DE9C0;
	sub_8219AA80(ctx, base);
	// 828DE9C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DE9C4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828DE9C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE9CC: 4BAEFA55  bl 0x823ce420
	ctx.lr = 0x828DE9D0;
	sub_823CE420(ctx, base);
	// 828DE9D0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DE9D4: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828DE9D8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DE9DC: 48145CED  bl 0x82a246c8
	ctx.lr = 0x828DE9E0;
	sub_82A246C8(ctx, base);
	// 828DE9E0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DE9E4: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828DE9E8: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828DE9EC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828DE9F0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DE9F4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828DE9F8: 419A0020  beq cr6, 0x828dea18
	if ctx.cr[6].eq {
	pc = 0x828DEA18; continue 'dispatch;
	}
	// 828DE9FC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DEA00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DEA04: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DEA08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828DEA0C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DEA10: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DEA14: 4082FFE8  bne 0x828de9fc
	if !ctx.cr[0].eq {
	pc = 0x828DE9FC; continue 'dispatch;
	}
	// 828DEA18: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DEA1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DEA20: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828DEA24: 4BA16F25  bl 0x822f5948
	ctx.lr = 0x828DEA28;
	sub_822F5948(ctx, base);
	// 828DEA28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DEA2C: 4B8D90ED  bl 0x821b7b18
	ctx.lr = 0x828DEA30;
	sub_821B7B18(ctx, base);
	// 828DEA30: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DEA34: 419A0040  beq cr6, 0x828dea74
	if ctx.cr[6].eq {
	pc = 0x828DEA74; continue 'dispatch;
	}
	// 828DEA38: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828DEA3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DEA40: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828DEA44: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DEA48: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DEA4C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DEA50: 4082FFE8  bne 0x828dea38
	if !ctx.cr[0].eq {
	pc = 0x828DEA38; continue 'dispatch;
	}
	// 828DEA54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DEA58: 409A001C  bne cr6, 0x828dea74
	if !ctx.cr[6].eq {
	pc = 0x828DEA74; continue 'dispatch;
	}
	// 828DEA5C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DEA60: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DEA64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DEA68: 4E800421  bctrl
	ctx.lr = 0x828DEA6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DEA6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DEA70: 4B93D2C9  bl 0x8221bd38
	ctx.lr = 0x828DEA74;
	sub_8221BD38(ctx, base);
	// 828DEA74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DEA78: 4B8D90A1  bl 0x821b7b18
	ctx.lr = 0x828DEA7C;
	sub_821B7B18(ctx, base);
	// 828DEA7C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828DEA80: 483CA9CC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DEA88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DEA88 size=56
    let mut pc: u32 = 0x828DEA88;
    'dispatch: loop {
        match pc {
            0x828DEA88 => {
    //   block [0x828DEA88..0x828DEAC0)
	// 828DEA88: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828DEA8C: 419A0018  beq cr6, 0x828deaa4
	if ctx.cr[6].eq {
	pc = 0x828DEAA4; continue 'dispatch;
	}
	// 828DEA90: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DEA94: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DEA98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DEA9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DEAA0: 409A0008  bne cr6, 0x828deaa8
	if !ctx.cr[6].eq {
	pc = 0x828DEAA8; continue 'dispatch;
	}
	// 828DEAA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DEAA8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DEAAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DEAB0: 419A0010  beq cr6, 0x828deac0
	if ctx.cr[6].eq {
		sub_828DEAC0(ctx, base);
		return;
	}
	// 828DEAB4: 8164003C  lwz r11, 0x3c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 828DEAB8: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828DEABC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DEAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DEAC0 size=8
    let mut pc: u32 = 0x828DEAC0;
    'dispatch: loop {
        match pc {
            0x828DEAC0 => {
    //   block [0x828DEAC0..0x828DEAC8)
	// 828DEAC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828DEAC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DEAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DEAC8 size=372
    let mut pc: u32 = 0x828DEAC8;
    'dispatch: loop {
        match pc {
            0x828DEAC8 => {
    //   block [0x828DEAC8..0x828DEC3C)
	// 828DEAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DEACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DEAD0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DEAD4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828DEAD8: 419A0018  beq cr6, 0x828deaf0
	if ctx.cr[6].eq {
	pc = 0x828DEAF0; continue 'dispatch;
	}
	// 828DEADC: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DEAE0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DEAE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DEAE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DEAEC: 409A0008  bne cr6, 0x828deaf4
	if !ctx.cr[6].eq {
	pc = 0x828DEAF4; continue 'dispatch;
	}
	// 828DEAF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DEAF4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DEAF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DEAFC: 419A012C  beq cr6, 0x828dec28
	if ctx.cr[6].eq {
	pc = 0x828DEC28; continue 'dispatch;
	}
	// 828DEB00: 8144003C  lwz r10, 0x3c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 828DEB04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DEB08: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828DEB0C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828DEB10: 419A00E8  beq cr6, 0x828debf8
	if ctx.cr[6].eq {
	pc = 0x828DEBF8; continue 'dispatch;
	}
	// 828DEB14: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828DEB18: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DEB1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DEB20: 419A001C  beq cr6, 0x828deb3c
	if ctx.cr[6].eq {
	pc = 0x828DEB3C; continue 'dispatch;
	}
	// 828DEB24: 896B00C5  lbz r11, 0xc5(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(197 as u32) ) } as u64;
	// 828DEB28: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828DEB2C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828DEB30: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DEB34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DEB38: 480000C4  b 0x828debfc
	pc = 0x828DEBFC; continue 'dispatch;
	// 828DEB3C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828DEB40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DEB44: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DEB48: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828DEB4C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828DEB50: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DEB54: 40810054  ble 0x828deba8
	if !ctx.cr[0].gt {
	pc = 0x828DEBA8; continue 'dispatch;
	}
	// 828DEB58: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828DEB5C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828DEB60: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828DEB64: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DEB68: 2F0700C5  cmpwi cr6, r7, 0xc5
	ctx.cr[6].compare_i32(ctx.r[7].s32, 197, &mut ctx.xer);
	// 828DEB6C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828DEB70: 41980008  blt cr6, 0x828deb78
	if ctx.cr[6].lt {
	pc = 0x828DEB78; continue 'dispatch;
	}
	// 828DEB74: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828DEB78: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828DEB7C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828DEB80: 419A0014  beq cr6, 0x828deb94
	if ctx.cr[6].eq {
	pc = 0x828DEB94; continue 'dispatch;
	}
	// 828DEB84: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828DEB88: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828DEB8C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DEB90: 4800000C  b 0x828deb9c
	pc = 0x828DEB9C; continue 'dispatch;
	// 828DEB94: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828DEB98: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828DEB9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DEBA0: 4199FFB8  bgt cr6, 0x828deb58
	if ctx.cr[6].gt {
	pc = 0x828DEB58; continue 'dispatch;
	}
	// 828DEBA4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DEBA8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828DEBAC: 419A003C  beq cr6, 0x828debe8
	if ctx.cr[6].eq {
	pc = 0x828DEBE8; continue 'dispatch;
	}
	// 828DEBB0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DEBB4: 2F0B00C5  cmpwi cr6, r11, 0xc5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 197, &mut ctx.xer);
	// 828DEBB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DEBBC: 41990008  bgt cr6, 0x828debc4
	if ctx.cr[6].gt {
	pc = 0x828DEBC4; continue 'dispatch;
	}
	// 828DEBC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DEBC4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DEBC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DEBCC: 409A001C  bne cr6, 0x828debe8
	if !ctx.cr[6].eq {
	pc = 0x828DEBE8; continue 'dispatch;
	}
	// 828DEBD0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828DEBD4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DEBD8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828DEBDC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DEBE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DEBE4: 48000018  b 0x828debfc
	pc = 0x828DEBFC; continue 'dispatch;
	// 828DEBE8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828DEBEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DEBF0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DEBF4: 48000008  b 0x828debfc
	pc = 0x828DEBFC; continue 'dispatch;
	// 828DEBF8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DEBFC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828DEC00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DEC04: 419A0024  beq cr6, 0x828dec28
	if ctx.cr[6].eq {
	pc = 0x828DEC28; continue 'dispatch;
	}
	// 828DEC08: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DEC0C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828DEC10: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828DEC14: 4E800421  bctrl
	ctx.lr = 0x828DEC18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DEC18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DEC1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DEC20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DEC24: 4E800020  blr
	return;
	// 828DEC28: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828DEC2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DEC30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DEC34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DEC38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DEC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DEC40 size=440
    let mut pc: u32 = 0x828DEC40;
    'dispatch: loop {
        match pc {
            0x828DEC40 => {
    //   block [0x828DEC40..0x828DEDF8)
	// 828DEC40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DEC44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DEC48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DEC4C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DEC50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DEC54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828DEC58: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828DEC5C: 419A0018  beq cr6, 0x828dec74
	if ctx.cr[6].eq {
	pc = 0x828DEC74; continue 'dispatch;
	}
	// 828DEC60: 89650090  lbz r11, 0x90(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DEC64: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DEC68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DEC6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DEC70: 409A0008  bne cr6, 0x828dec78
	if !ctx.cr[6].eq {
	pc = 0x828DEC78; continue 'dispatch;
	}
	// 828DEC74: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DEC78: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DEC7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DEC80: 419A0138  beq cr6, 0x828dedb8
	if ctx.cr[6].eq {
	pc = 0x828DEDB8; continue 'dispatch;
	}
	// 828DEC84: 8145003C  lwz r10, 0x3c(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(60 as u32) ) } as u64;
	// 828DEC88: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DEC8C: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828DEC90: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828DEC94: 419A00E8  beq cr6, 0x828ded7c
	if ctx.cr[6].eq {
	pc = 0x828DED7C; continue 'dispatch;
	}
	// 828DEC98: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 828DEC9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DECA0: 419A0020  beq cr6, 0x828decc0
	if ctx.cr[6].eq {
	pc = 0x828DECC0; continue 'dispatch;
	}
	// 828DECA4: 894B00C5  lbz r10, 0xc5(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(197 as u32) ) } as u64;
	// 828DECA8: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DECAC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828DECB0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828DECB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DECB8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DECBC: 480000C4  b 0x828ded80
	pc = 0x828DED80; continue 'dispatch;
	// 828DECC0: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DECC4: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 828DECC8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828DECCC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828DECD0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DECD4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DECD8: 40810054  ble 0x828ded2c
	if !ctx.cr[0].gt {
	pc = 0x828DED2C; continue 'dispatch;
	}
	// 828DECDC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828DECE0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828DECE4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828DECE8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DECEC: 2F0700C5  cmpwi cr6, r7, 0xc5
	ctx.cr[6].compare_i32(ctx.r[7].s32, 197, &mut ctx.xer);
	// 828DECF0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828DECF4: 41980008  blt cr6, 0x828decfc
	if ctx.cr[6].lt {
	pc = 0x828DECFC; continue 'dispatch;
	}
	// 828DECF8: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828DECFC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828DED00: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828DED04: 419A0014  beq cr6, 0x828ded18
	if ctx.cr[6].eq {
	pc = 0x828DED18; continue 'dispatch;
	}
	// 828DED08: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828DED0C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828DED10: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DED14: 4800000C  b 0x828ded20
	pc = 0x828DED20; continue 'dispatch;
	// 828DED18: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828DED1C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828DED20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DED24: 4199FFB8  bgt cr6, 0x828decdc
	if ctx.cr[6].gt {
	pc = 0x828DECDC; continue 'dispatch;
	}
	// 828DED28: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DED2C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828DED30: 419A003C  beq cr6, 0x828ded6c
	if ctx.cr[6].eq {
	pc = 0x828DED6C; continue 'dispatch;
	}
	// 828DED34: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DED38: 2F0B00C5  cmpwi cr6, r11, 0xc5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 197, &mut ctx.xer);
	// 828DED3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DED40: 41990008  bgt cr6, 0x828ded48
	if ctx.cr[6].gt {
	pc = 0x828DED48; continue 'dispatch;
	}
	// 828DED44: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DED48: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DED4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DED50: 409A001C  bne cr6, 0x828ded6c
	if !ctx.cr[6].eq {
	pc = 0x828DED6C; continue 'dispatch;
	}
	// 828DED54: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828DED58: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DED5C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828DED60: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DED64: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DED68: 48000018  b 0x828ded80
	pc = 0x828DED80; continue 'dispatch;
	// 828DED6C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828DED70: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DED74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DED78: 48000008  b 0x828ded80
	pc = 0x828DED80; continue 'dispatch;
	// 828DED7C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828DED80: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828DED84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DED88: 419A0030  beq cr6, 0x828dedb8
	if ctx.cr[6].eq {
	pc = 0x828DEDB8; continue 'dispatch;
	}
	// 828DED8C: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DED90: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828DED94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DED98: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828DED9C: 4E800421  bctrl
	ctx.lr = 0x828DEDA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DEDA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DEDA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DEDA8: 4B911499  bl 0x821f0240
	ctx.lr = 0x828DEDAC;
	sub_821F0240(ctx, base);
	// 828DEDAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DEDB0: 4B936029  bl 0x82214dd8
	ctx.lr = 0x828DEDB4;
	sub_82214DD8(ctx, base);
	// 828DEDB4: 4800002C  b 0x828dede0
	pc = 0x828DEDE0; continue 'dispatch;
	// 828DEDB8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828DEDBC: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828DEDC0: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	// 828DEDC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DEDC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DEDCC: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DEDD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DEDD4: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DEDD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DEDDC: 4082FFE8  bne 0x828dedc4
	if !ctx.cr[0].eq {
	pc = 0x828DEDC4; continue 'dispatch;
	}
	// 828DEDE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DEDE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DEDE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DEDEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DEDF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DEDF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DEDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DEDF8 size=464
    let mut pc: u32 = 0x828DEDF8;
    'dispatch: loop {
        match pc {
            0x828DEDF8 => {
    //   block [0x828DEDF8..0x828DEFC8)
	// 828DEDF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DEDFC: 483CA611  bl 0x82ca940c
	ctx.lr = 0x828DEE00;
	sub_82CA93D0(ctx, base);
	// 828DEE00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DEE04: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DEE08: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DEE0C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DEE10: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828DEE14: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828DEE18: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 828DEE1C: 2F080008  cmpwi cr6, r8, 8
	ctx.cr[6].compare_i32(ctx.r[8].s32, 8, &mut ctx.xer);
	// 828DEE20: 4198019C  blt cr6, 0x828defbc
	if ctx.cr[6].lt {
	pc = 0x828DEFBC; continue 'dispatch;
	}
	// 828DEE24: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828DEE28: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828DEE2C: 38AB79B0  addi r5, r11, 0x79b0
	ctx.r[5].s64 = ctx.r[11].s64 + 31152;
	// 828DEE30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DEE34: 4B949195  bl 0x82227fc8
	ctx.lr = 0x828DEE38;
	sub_82227FC8(ctx, base);
	// 828DEE38: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828DEE3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DEE40: 419A017C  beq cr6, 0x828defbc
	if ctx.cr[6].eq {
	pc = 0x828DEFBC; continue 'dispatch;
	}
	// 828DEE44: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828DEE48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DEE4C: 4B9492AD  bl 0x822280f8
	ctx.lr = 0x828DEE50;
	sub_822280F8(ctx, base);
	// 828DEE50: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DEE54: 4B94870D  bl 0x82227560
	ctx.lr = 0x828DEE58;
	sub_82227560(ctx, base);
	// 828DEE58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DEE5C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828DEE60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DEE64: 4B901525  bl 0x821e0388
	ctx.lr = 0x828DEE68;
	sub_821E0388(ctx, base);
	// 828DEE68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DEE6C: 419A0018  beq cr6, 0x828dee84
	if ctx.cr[6].eq {
	pc = 0x828DEE84; continue 'dispatch;
	}
	// 828DEE70: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DEE74: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DEE78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DEE7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DEE80: 409A0008  bne cr6, 0x828dee88
	if !ctx.cr[6].eq {
	pc = 0x828DEE88; continue 'dispatch;
	}
	// 828DEE84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DEE88: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DEE8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DEE90: 419A012C  beq cr6, 0x828defbc
	if ctx.cr[6].eq {
	pc = 0x828DEFBC; continue 'dispatch;
	}
	// 828DEE94: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828DEE98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DEE9C: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828DEEA0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828DEEA4: 419A00EC  beq cr6, 0x828def90
	if ctx.cr[6].eq {
	pc = 0x828DEF90; continue 'dispatch;
	}
	// 828DEEA8: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 828DEEAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DEEB0: 419A0020  beq cr6, 0x828deed0
	if ctx.cr[6].eq {
	pc = 0x828DEED0; continue 'dispatch;
	}
	// 828DEEB4: 894B00C5  lbz r10, 0xc5(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(197 as u32) ) } as u64;
	// 828DEEB8: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DEEBC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828DEEC0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828DEEC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DEEC8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DEECC: 480000C8  b 0x828def94
	pc = 0x828DEF94; continue 'dispatch;
	// 828DEED0: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DEED4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DEED8: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828DEEDC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828DEEE0: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828DEEE4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DEEE8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DEEEC: 40810054  ble 0x828def40
	if !ctx.cr[0].gt {
	pc = 0x828DEF40; continue 'dispatch;
	}
	// 828DEEF0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828DEEF4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828DEEF8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828DEEFC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DEF00: 2F0700C5  cmpwi cr6, r7, 0xc5
	ctx.cr[6].compare_i32(ctx.r[7].s32, 197, &mut ctx.xer);
	// 828DEF04: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828DEF08: 41980008  blt cr6, 0x828def10
	if ctx.cr[6].lt {
	pc = 0x828DEF10; continue 'dispatch;
	}
	// 828DEF0C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828DEF10: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828DEF14: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828DEF18: 419A0014  beq cr6, 0x828def2c
	if ctx.cr[6].eq {
	pc = 0x828DEF2C; continue 'dispatch;
	}
	// 828DEF1C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828DEF20: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828DEF24: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DEF28: 4800000C  b 0x828def34
	pc = 0x828DEF34; continue 'dispatch;
	// 828DEF2C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828DEF30: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828DEF34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DEF38: 4199FFB8  bgt cr6, 0x828deef0
	if ctx.cr[6].gt {
	pc = 0x828DEEF0; continue 'dispatch;
	}
	// 828DEF3C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DEF40: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828DEF44: 419A003C  beq cr6, 0x828def80
	if ctx.cr[6].eq {
	pc = 0x828DEF80; continue 'dispatch;
	}
	// 828DEF48: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DEF4C: 2F0B00C5  cmpwi cr6, r11, 0xc5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 197, &mut ctx.xer);
	// 828DEF50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DEF54: 41990008  bgt cr6, 0x828def5c
	if ctx.cr[6].gt {
	pc = 0x828DEF5C; continue 'dispatch;
	}
	// 828DEF58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DEF5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DEF60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DEF64: 409A001C  bne cr6, 0x828def80
	if !ctx.cr[6].eq {
	pc = 0x828DEF80; continue 'dispatch;
	}
	// 828DEF68: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828DEF6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DEF70: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828DEF74: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DEF78: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DEF7C: 48000018  b 0x828def94
	pc = 0x828DEF94; continue 'dispatch;
	// 828DEF80: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828DEF84: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DEF88: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DEF8C: 48000008  b 0x828def94
	pc = 0x828DEF94; continue 'dispatch;
	// 828DEF90: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DEF94: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828DEF98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DEF9C: 419A0020  beq cr6, 0x828defbc
	if ctx.cr[6].eq {
	pc = 0x828DEFBC; continue 'dispatch;
	}
	// 828DEFA0: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DEFA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DEFA8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828DEFAC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828DEFB0: 4E800421  bctrl
	ctx.lr = 0x828DEFB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DEFB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DEFB8: 483CA4A4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828DEFBC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828DEFC0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DEFC4: 483CA498  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DEFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DEFC8 size=108
    let mut pc: u32 = 0x828DEFC8;
    'dispatch: loop {
        match pc {
            0x828DEFC8 => {
    //   block [0x828DEFC8..0x828DF034)
	// 828DEFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DEFCC: 483CA441  bl 0x82ca940c
	ctx.lr = 0x828DEFD0;
	sub_82CA93D0(ctx, base);
	// 828DEFD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DEFD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DEFD8: 38600078  li r3, 0x78
	ctx.r[3].s64 = 120;
	// 828DEFDC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828DEFE0: 4B940279  bl 0x8221f258
	ctx.lr = 0x828DEFE4;
	sub_8221F258(ctx, base);
	// 828DEFE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DEFE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DEFEC: 419A0020  beq cr6, 0x828df00c
	if ctx.cr[6].eq {
	pc = 0x828DF00C; continue 'dispatch;
	}
	// 828DEFF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DEFF4: 4BB2ACFD  bl 0x82409cf0
	ctx.lr = 0x828DEFF8;
	sub_82409CF0(ctx, base);
	// 828DEFF8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828DEFFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DF000: 394B3DF8  addi r10, r11, 0x3df8
	ctx.r[10].s64 = ctx.r[11].s64 + 15864;
	// 828DF004: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DF008: 48000008  b 0x828df010
	pc = 0x828DF010; continue 'dispatch;
	// 828DF00C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828DF010: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DF014: 4B9E0F05  bl 0x822bff18
	ctx.lr = 0x828DF018;
	sub_822BFF18(ctx, base);
	// 828DF018: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF01C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DF020: 419A0008  beq cr6, 0x828df028
	if ctx.cr[6].eq {
	pc = 0x828DF028; continue 'dispatch;
	}
	// 828DF024: 4B8A21FD  bl 0x82181220
	ctx.lr = 0x828DF028;
	sub_82181220(ctx, base);
	// 828DF028: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DF02C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DF030: 483CA42C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DF038 size=8
    let mut pc: u32 = 0x828DF038;
    'dispatch: loop {
        match pc {
            0x828DF038 => {
    //   block [0x828DF038..0x828DF040)
	// 828DF038: 386000C7  li r3, 0xc7
	ctx.r[3].s64 = 199;
	// 828DF03C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DF040 size=60
    let mut pc: u32 = 0x828DF040;
    'dispatch: loop {
        match pc {
            0x828DF040 => {
    //   block [0x828DF040..0x828DF07C)
	// 828DF040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DF048: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DF04C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DF050: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828DF054: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DF058: 388B9C78  addi r4, r11, -0x6388
	ctx.r[4].s64 = ctx.r[11].s64 + -25480;
	// 828DF05C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DF060: 4B94DE71  bl 0x8222ced0
	ctx.lr = 0x828DF064;
	sub_8222CED0(ctx, base);
	// 828DF064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DF068: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DF06C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DF070: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DF074: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DF078: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DF080 size=68
    let mut pc: u32 = 0x828DF080;
    'dispatch: loop {
        match pc {
            0x828DF080 => {
    //   block [0x828DF080..0x828DF0C4)
	// 828DF080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DF088: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DF08C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DF090: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 828DF094: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828DF098: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DF09C: 4BF6C795  bl 0x8284b830
	ctx.lr = 0x828DF0A0;
	sub_8284B830(ctx, base);
	// 828DF0A0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828DF0A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DF0A8: 394B3DF8  addi r10, r11, 0x3df8
	ctx.r[10].s64 = ctx.r[11].s64 + 15864;
	// 828DF0AC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DF0B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DF0B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DF0B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DF0BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DF0C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DF0C8 size=668
    let mut pc: u32 = 0x828DF0C8;
    'dispatch: loop {
        match pc {
            0x828DF0C8 => {
    //   block [0x828DF0C8..0x828DF364)
	// 828DF0C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF0CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DF0D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DF0D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DF0D8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828DF0DC: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DF368 size=336
    let mut pc: u32 = 0x828DF368;
    'dispatch: loop {
        match pc {
            0x828DF368 => {
    //   block [0x828DF368..0x828DF4B8)
	// 828DF368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF36C: 483CA0A1  bl 0x82ca940c
	ctx.lr = 0x828DF370;
	sub_82CA93D0(ctx, base);
	// 828DF370: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DF374: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828DF378: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DF37C: 3BAB3CF8  addi r29, r11, 0x3cf8
	ctx.r[29].s64 = ctx.r[11].s64 + 15608;
	// 828DF380: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DF384: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF388: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DF38C: 4B94DB45  bl 0x8222ced0
	ctx.lr = 0x828DF390;
	sub_8222CED0(ctx, base);
	// 828DF390: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DF394: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DF398: 480011C9  bl 0x828e0560
	ctx.lr = 0x828DF39C;
	sub_828E0560(ctx, base);
	// 828DF39C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF3A0: 4B935A39  bl 0x82214dd8
	ctx.lr = 0x828DF3A4;
	sub_82214DD8(ctx, base);
	// 828DF3A4: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828DF3A8: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828DF3AC: 390AF840  addi r8, r10, -0x7c0
	ctx.r[8].s64 = ctx.r[10].s64 + -1984;
	// 828DF3B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DF3B4: 38893D04  addi r4, r9, 0x3d04
	ctx.r[4].s64 = ctx.r[9].s64 + 15620;
	// 828DF3B8: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 828DF3BC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DF3C0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828DF3C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DF3C8: 4B94DB09  bl 0x8222ced0
	ctx.lr = 0x828DF3CC;
	sub_8222CED0(ctx, base);
	// 828DF3CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DF3D0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DF3D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF3D8: 4B94DAF9  bl 0x8222ced0
	ctx.lr = 0x828DF3DC;
	sub_8222CED0(ctx, base);
	// 828DF3DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DF3E0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828DF3E4: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828DF3E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DF3EC: 480013BD  bl 0x828e07a8
	ctx.lr = 0x828DF3F0;
	sub_828E07A8(ctx, base);
	// 828DF3F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF3F4: 4B9359E5  bl 0x82214dd8
	ctx.lr = 0x828DF3F8;
	sub_82214DD8(ctx, base);
	// 828DF3F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DF3FC: 4B9359DD  bl 0x82214dd8
	ctx.lr = 0x828DF400;
	sub_82214DD8(ctx, base);
	// 828DF400: 3CE0828E  lis r7, -0x7d72
	ctx.r[7].s64 = -2104623104;
	// 828DF404: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828DF408: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828DF40C: 3867F898  addi r3, r7, -0x768
	ctx.r[3].s64 = ctx.r[7].s64 + -1896;
	// 828DF410: 38863D18  addi r4, r6, 0x3d18
	ctx.r[4].s64 = ctx.r[6].s64 + 15640;
	// 828DF414: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 828DF418: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DF41C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF420: 4B94DAB1  bl 0x8222ced0
	ctx.lr = 0x828DF424;
	sub_8222CED0(ctx, base);
	// 828DF424: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DF428: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DF42C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DF430: 4B94DAA1  bl 0x8222ced0
	ctx.lr = 0x828DF434;
	sub_8222CED0(ctx, base);
	// 828DF434: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DF438: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DF43C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828DF440: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828DF444: 48001575  bl 0x828e09b8
	ctx.lr = 0x828DF448;
	sub_828E09B8(ctx, base);
	// 828DF448: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DF44C: 4B93598D  bl 0x82214dd8
	ctx.lr = 0x828DF450;
	sub_82214DD8(ctx, base);
	// 828DF450: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF454: 4B935985  bl 0x82214dd8
	ctx.lr = 0x828DF458;
	sub_82214DD8(ctx, base);
	// 828DF458: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DF45C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828DF460: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828DF464: 392BF680  addi r9, r11, -0x980
	ctx.r[9].s64 = ctx.r[11].s64 + -2432;
	// 828DF468: 388A3D30  addi r4, r10, 0x3d30
	ctx.r[4].s64 = ctx.r[10].s64 + 15664;
	// 828DF46C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DF470: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 828DF474: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF478: 4B94DA59  bl 0x8222ced0
	ctx.lr = 0x828DF47C;
	sub_8222CED0(ctx, base);
	// 828DF47C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DF480: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828DF484: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DF488: 4B94DA49  bl 0x8222ced0
	ctx.lr = 0x828DF48C;
	sub_8222CED0(ctx, base);
	// 828DF48C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DF490: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828DF494: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828DF498: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DF49C: 4800172D  bl 0x828e0bc8
	ctx.lr = 0x828DF4A0;
	sub_828E0BC8(ctx, base);
	// 828DF4A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DF4A4: 4B935935  bl 0x82214dd8
	ctx.lr = 0x828DF4A8;
	sub_82214DD8(ctx, base);
	// 828DF4A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF4AC: 4B93592D  bl 0x82214dd8
	ctx.lr = 0x828DF4B0;
	sub_82214DD8(ctx, base);
	// 828DF4B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DF4B4: 483C9FA8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DF4B8 size=132
    let mut pc: u32 = 0x828DF4B8;
    'dispatch: loop {
        match pc {
            0x828DF4B8 => {
    //   block [0x828DF4B8..0x828DF53C)
	// 828DF4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF4BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DF4C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DF4C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DF4C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DF4CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DF4D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DF4D4: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 828DF4D8: 4B9BB379  bl 0x8229a850
	ctx.lr = 0x828DF4DC;
	sub_8229A850(ctx, base);
	// 828DF4DC: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828DF4E0: 48138881  bl 0x82a17d60
	ctx.lr = 0x828DF4E4;
	sub_82A17D60(ctx, base);
	// 828DF4E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DF4E8: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 828DF4EC: 409A0008  bne cr6, 0x828df4f4
	if !ctx.cr[6].eq {
	pc = 0x828DF4F4; continue 'dispatch;
	}
	// 828DF4F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DF4F4: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 828DF4F8: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828DF4FC: 390ADE04  addi r8, r10, -0x21fc
	ctx.r[8].s64 = ctx.r[10].s64 + -8700;
	// 828DF500: 38E92850  addi r7, r9, 0x2850
	ctx.r[7].s64 = ctx.r[9].s64 + 10320;
	// 828DF504: 57C607FE  clrlwi r6, r30, 0x1f
	ctx.r[6].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828DF508: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828DF50C: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828DF510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DF514: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 828DF518: 419A000C  beq cr6, 0x828df524
	if ctx.cr[6].eq {
	pc = 0x828DF524; continue 'dispatch;
	}
	// 828DF51C: 4B93C81D  bl 0x8221bd38
	ctx.lr = 0x828DF520;
	sub_8221BD38(ctx, base);
	// 828DF520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DF524: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DF528: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DF52C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DF530: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DF534: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DF538: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DF540 size=268
    let mut pc: u32 = 0x828DF540;
    'dispatch: loop {
        match pc {
            0x828DF540 => {
    //   block [0x828DF540..0x828DF64C)
	// 828DF540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF544: 483C9EC5  bl 0x82ca9408
	ctx.lr = 0x828DF548;
	sub_82CA93D0(ctx, base);
	// 828DF548: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DF54C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828DF550: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828DF554: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828DF558: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DF55C: 386B3D3C  addi r3, r11, 0x3d3c
	ctx.r[3].s64 = ctx.r[11].s64 + 15676;
	// 828DF560: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828DF564: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 828DF568: 4B9147F1  bl 0x821f3d58
	ctx.lr = 0x828DF56C;
	sub_821F3D58(ctx, base);
	// 828DF56C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DF570: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DF574: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828DF578: 48120E39  bl 0x82a003b0
	ctx.lr = 0x828DF57C;
	sub_82A003B0(ctx, base);
	// 828DF57C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828DF580: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828DF584: 386A3D50  addi r3, r10, 0x3d50
	ctx.r[3].s64 = ctx.r[10].s64 + 15696;
	// 828DF588: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828DF58C: 3BDF0029  addi r30, r31, 0x29
	ctx.r[30].s64 = ctx.r[31].s64 + 41;
	// 828DF590: 4B9147C9  bl 0x821f3d58
	ctx.lr = 0x828DF594;
	sub_821F3D58(ctx, base);
	// 828DF594: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DF598: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DF59C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828DF5A0: 48120E11  bl 0x82a003b0
	ctx.lr = 0x828DF5A4;
	sub_82A003B0(ctx, base);
	// 828DF5A4: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828DF5A8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DF5AC: 38893D5C  addi r4, r9, 0x3d5c
	ctx.r[4].s64 = ctx.r[9].s64 + 15708;
	// 828DF5B0: 38BF002C  addi r5, r31, 0x2c
	ctx.r[5].s64 = ctx.r[31].s64 + 44;
	// 828DF5B4: 4BACDE3D  bl 0x823ad3f0
	ctx.lr = 0x828DF5B8;
	sub_823AD3F0(ctx, base);
	// 828DF5B8: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828DF5BC: 3BDF0030  addi r30, r31, 0x30
	ctx.r[30].s64 = ctx.r[31].s64 + 48;
	// 828DF5C0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DF5C4: 38883D7C  addi r4, r8, 0x3d7c
	ctx.r[4].s64 = ctx.r[8].s64 + 15740;
	// 828DF5C8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828DF5CC: 4BACDE25  bl 0x823ad3f0
	ctx.lr = 0x828DF5D0;
	sub_823AD3F0(ctx, base);
	// 828DF5D0: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 828DF5D4: 3BBF0034  addi r29, r31, 0x34
	ctx.r[29].s64 = ctx.r[31].s64 + 52;
	// 828DF5D8: 38873D94  addi r4, r7, 0x3d94
	ctx.r[4].s64 = ctx.r[7].s64 + 15764;
	// 828DF5DC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828DF5E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DF5E4: 4BACDE0D  bl 0x823ad3f0
	ctx.lr = 0x828DF5E8;
	sub_823AD3F0(ctx, base);
	// 828DF5E8: 88DF0028  lbz r6, 0x28(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 828DF5EC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 828DF5F0: 409A0034  bne cr6, 0x828df624
	if !ctx.cr[6].eq {
	pc = 0x828DF624; continue 'dispatch;
	}
	// 828DF5F4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828DF5F8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DF5FC: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 828DF600: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF604: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828DF608: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828DF60C: 812A0084  lwz r9, 0x84(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(132 as u32) ) } as u64;
	// 828DF610: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF614: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828DF618: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DF61C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828DF620: 4BB94281  bl 0x824738a0
	ctx.lr = 0x828DF624;
	sub_824738A0(ctx, base);
	// 828DF624: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828DF628: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828DF62C: C19D0000  lfs f12, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828DF630: C00BCB94  lfs f0, -0x346c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13420 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DF634: ED6D0032  fmuls f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828DF638: D17E0000  stfs f11, 0(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828DF63C: ED4C0032  fmuls f10, f12, f0
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 828DF640: D15D0000  stfs f10, 0(r29)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828DF644: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828DF648: 483C9E10  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DF650 size=32
    let mut pc: u32 = 0x828DF650;
    'dispatch: loop {
        match pc {
            0x828DF650 => {
    //   block [0x828DF650..0x828DF670)
	// 828DF650: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DF654: 38A3000C  addi r5, r3, 0xc
	ctx.r[5].s64 = ctx.r[3].s64 + 12;
	// 828DF658: 409A0008  bne cr6, 0x828df660
	if !ctx.cr[6].eq {
	pc = 0x828DF660; continue 'dispatch;
	}
	// 828DF65C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828DF660: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DF664: 3883001C  addi r4, r3, 0x1c
	ctx.r[4].s64 = ctx.r[3].s64 + 28;
	// 828DF668: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828DF66C: 4B9BF454  b 0x8229eac0
	sub_8229EAC0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DF670 size=16
    let mut pc: u32 = 0x828DF670;
    'dispatch: loop {
        match pc {
            0x828DF670 => {
    //   block [0x828DF670..0x828DF680)
	// 828DF670: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DF674: 3883001C  addi r4, r3, 0x1c
	ctx.r[4].s64 = ctx.r[3].s64 + 28;
	// 828DF678: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828DF67C: 4B9BF2EC  b 0x8229e968
	sub_8229E968(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DF680 size=448
    let mut pc: u32 = 0x828DF680;
    'dispatch: loop {
        match pc {
            0x828DF680 => {
    //   block [0x828DF680..0x828DF840)
	// 828DF680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DF688: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DF68C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DF690: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DF694: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DF698: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DF69C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DF6A0: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828DF6A4: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 828DF6A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828DF6AC: 419A00F4  beq cr6, 0x828df7a0
	if ctx.cr[6].eq {
	pc = 0x828DF7A0; continue 'dispatch;
	}
	// 828DF6B0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828DF6B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828DF6B8: 419A0024  beq cr6, 0x828df6dc
	if ctx.cr[6].eq {
	pc = 0x828DF6DC; continue 'dispatch;
	}
	// 828DF6BC: 894A0015  lbz r10, 0x15(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 828DF6C0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DF6C4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828DF6C8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828DF6CC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DF6D0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828DF6D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DF6D8: 480000CC  b 0x828df7a4
	pc = 0x828DF7A4; continue 'dispatch;
	// 828DF6DC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DF6E0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828DF6E4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828DF6E8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828DF6EC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DF6F0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DF6F4: 40810054  ble 0x828df748
	if !ctx.cr[0].gt {
	pc = 0x828DF748; continue 'dispatch;
	}
	// 828DF6F8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828DF6FC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828DF700: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828DF704: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF708: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 828DF70C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828DF710: 41980008  blt cr6, 0x828df718
	if ctx.cr[6].lt {
	pc = 0x828DF718; continue 'dispatch;
	}
	// 828DF714: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828DF718: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828DF71C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828DF720: 419A0014  beq cr6, 0x828df734
	if ctx.cr[6].eq {
	pc = 0x828DF734; continue 'dispatch;
	}
	// 828DF724: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828DF728: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828DF72C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828DF730: 4800000C  b 0x828df73c
	pc = 0x828DF73C; continue 'dispatch;
	// 828DF734: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828DF738: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828DF73C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DF740: 4199FFB8  bgt cr6, 0x828df6f8
	if ctx.cr[6].gt {
	pc = 0x828DF6F8; continue 'dispatch;
	}
	// 828DF744: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828DF748: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828DF74C: 419A0040  beq cr6, 0x828df78c
	if ctx.cr[6].eq {
	pc = 0x828DF78C; continue 'dispatch;
	}
	// 828DF750: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF754: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 828DF758: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DF75C: 41990008  bgt cr6, 0x828df764
	if ctx.cr[6].gt {
	pc = 0x828DF764; continue 'dispatch;
	}
	// 828DF760: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828DF764: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DF768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DF76C: 409A0020  bne cr6, 0x828df78c
	if !ctx.cr[6].eq {
	pc = 0x828DF78C; continue 'dispatch;
	}
	// 828DF770: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828DF774: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828DF778: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DF77C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DF780: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828DF784: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DF788: 4800001C  b 0x828df7a4
	pc = 0x828DF7A4; continue 'dispatch;
	// 828DF78C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828DF790: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DF794: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828DF798: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DF79C: 48000008  b 0x828df7a4
	pc = 0x828DF7A4; continue 'dispatch;
	// 828DF7A0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828DF7A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828DF7A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DF7AC: 419A0070  beq cr6, 0x828df81c
	if ctx.cr[6].eq {
	pc = 0x828DF81C; continue 'dispatch;
	}
	// 828DF7B0: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828DF7B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DF7B8: 4B91FE11  bl 0x821ff5c8
	ctx.lr = 0x828DF7BC;
	sub_821FF5C8(ctx, base);
	// 828DF7BC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828DF7C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DF7C4: 419A0058  beq cr6, 0x828df81c
	if ctx.cr[6].eq {
	pc = 0x828DF81C; continue 'dispatch;
	}
	// 828DF7C8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828DF7CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DF7D0: 419A000C  beq cr6, 0x828df7dc
	if ctx.cr[6].eq {
	pc = 0x828DF7DC; continue 'dispatch;
	}
	// 828DF7D4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828DF7D8: 4800000C  b 0x828df7e4
	pc = 0x828DF7E4; continue 'dispatch;
	// 828DF7DC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828DF7E0: 396B5E78  addi r11, r11, 0x5e78
	ctx.r[11].s64 = ctx.r[11].s64 + 24184;
	// 828DF7E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF7E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DF7EC: 409A0010  bne cr6, 0x828df7fc
	if !ctx.cr[6].eq {
	pc = 0x828DF7FC; continue 'dispatch;
	}
	// 828DF7F0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DF7F4: 386BFFDF  addi r3, r11, -0x21
	ctx.r[3].s64 = ctx.r[11].s64 + -33;
	// 828DF7F8: 48000008  b 0x828df800
	pc = 0x828DF800; continue 'dispatch;
	// 828DF7FC: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF800: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828DF804: 388B3DB0  addi r4, r11, 0x3db0
	ctx.r[4].s64 = ctx.r[11].s64 + 15792;
	// 828DF808: 483CD349  bl 0x82cacb50
	ctx.lr = 0x828DF80C;
	sub_82CACB50(ctx, base);
	// 828DF80C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 828DF810: 419A000C  beq cr6, 0x828df81c
	if ctx.cr[6].eq {
	pc = 0x828DF81C; continue 'dispatch;
	}
	// 828DF814: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828DF818: 48000010  b 0x828df828
	pc = 0x828DF828; continue 'dispatch;
	// 828DF81C: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828DF820: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828DF824: 5543DFFE  rlwinm r3, r10, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828DF828: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DF82C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DF830: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DF834: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DF838: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DF83C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DF840 size=88
    let mut pc: u32 = 0x828DF840;
    'dispatch: loop {
        match pc {
            0x828DF840 => {
    //   block [0x828DF840..0x828DF898)
	// 828DF840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DF848: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DF84C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DF850: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828DF854: 38830010  addi r4, r3, 0x10
	ctx.r[4].s64 = ctx.r[3].s64 + 16;
	// 828DF858: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DF85C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF860: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828DF864: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828DF868: 812A0084  lwz r9, 0x84(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(132 as u32) ) } as u64;
	// 828DF86C: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF870: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 828DF874: 93E90000  stw r31, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828DF878: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828DF87C: 4BB94025  bl 0x824738a0
	ctx.lr = 0x828DF880;
	sub_824738A0(ctx, base);
	// 828DF880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DF884: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DF888: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DF88C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DF890: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DF894: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DF898 size=44
    let mut pc: u32 = 0x828DF898;
    'dispatch: loop {
        match pc {
            0x828DF898 => {
    //   block [0x828DF898..0x828DF8C4)
	// 828DF898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF89C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DF8A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DF8A4: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828DF8A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DF8AC: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828DF8B0: 4BB6AA09  bl 0x8244a2b8
	ctx.lr = 0x828DF8B4;
	sub_8244A2B8(ctx, base);
	// 828DF8B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DF8B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DF8BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DF8C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DF8C8 size=3140
    let mut pc: u32 = 0x828DF8C8;
    'dispatch: loop {
        match pc {
            0x828DF8C8 => {
    //   block [0x828DF8C8..0x828E050C)
	// 828DF8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF8CC: 483C9B35  bl 0x82ca9400
	ctx.lr = 0x828DF8D0;
	sub_82CA93D0(ctx, base);
	// 828DF8D0: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 828DF8D4: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 828DF8D8: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 828DF8DC: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E0510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E0510 size=80
    let mut pc: u32 = 0x828E0510;
    'dispatch: loop {
        match pc {
            0x828E0510 => {
    //   block [0x828E0510..0x828E0560)
	// 828E0510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E0514: 483C8EF9  bl 0x82ca940c
	ctx.lr = 0x828E0518;
	sub_82CA93D0(ctx, base);
	// 828E0518: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E051C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828E0520: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E0524: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E0528: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E052C: 388B3DE0  addi r4, r11, 0x3de0
	ctx.r[4].s64 = ctx.r[11].s64 + 15840;
	// 828E0530: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E0534: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828E0538: 4B94C999  bl 0x8222ced0
	ctx.lr = 0x828E053C;
	sub_8222CED0(ctx, base);
	// 828E053C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828E0540: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828E0544: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E0548: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828E054C: 4BF0856D  bl 0x827e8ab8
	ctx.lr = 0x828E0550;
	sub_827E8AB8(ctx, base);
	// 828E0550: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E0554: 4B934885  bl 0x82214dd8
	ctx.lr = 0x828E0558;
	sub_82214DD8(ctx, base);
	// 828E0558: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E055C: 483C8F00  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E0560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E0560 size=584
    let mut pc: u32 = 0x828E0560;
    'dispatch: loop {
        match pc {
            0x828E0560 => {
    //   block [0x828E0560..0x828E07A8)
	// 828E0560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E0564: 483C8E9D  bl 0x82ca9400
	ctx.lr = 0x828E0568;
	sub_82CA93D0(ctx, base);
	// 828E0568: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E056C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0570: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828E0574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E0578: 409A0010  bne cr6, 0x828e0588
	if !ctx.cr[6].eq {
	pc = 0x828E0588; continue 'dispatch;
	}
	// 828E057C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E0580: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828E0584: 48000008  b 0x828e058c
	pc = 0x828E058C; continue 'dispatch;
	// 828E0588: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E058C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0590: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E0594: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0598: 4BAEE029  bl 0x823ce5c0
	ctx.lr = 0x828E059C;
	sub_823CE5C0(ctx, base);
	// 828E059C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E05A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E05A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E05A8: 4BAEDC59  bl 0x823ce200
	ctx.lr = 0x828E05AC;
	sub_823CE200(ctx, base);
	// 828E05AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E05B0: 4B8D7569  bl 0x821b7b18
	ctx.lr = 0x828E05B4;
	sub_821B7B18(ctx, base);
	// 828E05B4: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828E05B8: 4B93ECA1  bl 0x8221f258
	ctx.lr = 0x828E05BC;
	sub_8221F258(ctx, base);
	// 828E05BC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E05C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E05C4: 419A0040  beq cr6, 0x828e0604
	if ctx.cr[6].eq {
	pc = 0x828E0604; continue 'dispatch;
	}
	// 828E05C8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828E05CC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828E05D0: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828E05D4: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828E05D8: 4B93EC81  bl 0x8221f258
	ctx.lr = 0x828E05DC;
	sub_8221F258(ctx, base);
	// 828E05DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E05E0: 419A0028  beq cr6, 0x828e0608
	if ctx.cr[6].eq {
	pc = 0x828E0608; continue 'dispatch;
	}
	// 828E05E4: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828E05E8: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828E05EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E05F0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828E05F4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828E05F8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E05FC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E0600: 4800000C  b 0x828e060c
	pc = 0x828E060C; continue 'dispatch;
	// 828E0604: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E0608: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828E060C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E0610: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E0614: 419A00FC  beq cr6, 0x828e0710
	if ctx.cr[6].eq {
	pc = 0x828E0710; continue 'dispatch;
	}
	// 828E0618: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E061C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828E0620: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0624: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828E0628: 4B948AE1  bl 0x82229108
	ctx.lr = 0x828E062C;
	sub_82229108(ctx, base);
	// 828E062C: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828E0630: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828E0634: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828E0638: 3BCB0F20  addi r30, r11, 0xf20
	ctx.r[30].s64 = ctx.r[11].s64 + 3872;
	// 828E063C: 4B947245  bl 0x82227880
	ctx.lr = 0x828E0640;
	sub_82227880(ctx, base);
	// 828E0640: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E0644: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828E0648: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E064C: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828E0650: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828E0654: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828E0658: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828E065C: 4B8BA425  bl 0x8219aa80
	ctx.lr = 0x828E0660;
	sub_8219AA80(ctx, base);
	// 828E0660: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828E0664: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828E0668: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828E066C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E0670: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828E0674: 4BAEDDAD  bl 0x823ce420
	ctx.lr = 0x828E0678;
	sub_823CE420(ctx, base);
	// 828E0678: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828E067C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828E0680: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828E0684: 48144045  bl 0x82a246c8
	ctx.lr = 0x828E0688;
	sub_82A246C8(ctx, base);
	// 828E0688: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E068C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828E0690: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828E0694: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828E0698: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E069C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E06A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E06A4: 4B948A65  bl 0x82229108
	ctx.lr = 0x828E06A8;
	sub_82229108(ctx, base);
	// 828E06A8: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828E06AC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828E06B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E06B4: 3BEBF038  addi r31, r11, -0xfc8
	ctx.r[31].s64 = ctx.r[11].s64 + -4040;
	// 828E06B8: 4B9471C9  bl 0x82227880
	ctx.lr = 0x828E06BC;
	sub_82227880(ctx, base);
	// 828E06BC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828E06C0: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828E06C4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E06C8: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828E06CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E06D0: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828E06D4: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828E06D8: 4B8BA3A9  bl 0x8219aa80
	ctx.lr = 0x828E06DC;
	sub_8219AA80(ctx, base);
	// 828E06DC: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828E06E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E06E4: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828E06E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E06EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E06F0: 4BAEDD31  bl 0x823ce420
	ctx.lr = 0x828E06F4;
	sub_823CE420(ctx, base);
	// 828E06F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E06F8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828E06FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E0700: 48143FC9  bl 0x82a246c8
	ctx.lr = 0x828E0704;
	sub_82A246C8(ctx, base);
	// 828E0704: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E0708: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828E070C: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828E0710: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828E0714: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828E0718: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828E071C: 419A0020  beq cr6, 0x828e073c
	if ctx.cr[6].eq {
	pc = 0x828E073C; continue 'dispatch;
	}
	// 828E0720: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E0724: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E0728: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E072C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828E0730: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E0734: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E0738: 4082FFE8  bne 0x828e0720
	if !ctx.cr[0].eq {
	pc = 0x828E0720; continue 'dispatch;
	}
	// 828E073C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0740: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828E0744: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828E0748: 4BA15201  bl 0x822f5948
	ctx.lr = 0x828E074C;
	sub_822F5948(ctx, base);
	// 828E074C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E0750: 4B8D73C9  bl 0x821b7b18
	ctx.lr = 0x828E0754;
	sub_821B7B18(ctx, base);
	// 828E0754: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828E0758: 419A0040  beq cr6, 0x828e0798
	if ctx.cr[6].eq {
	pc = 0x828E0798; continue 'dispatch;
	}
	// 828E075C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E0760: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E0764: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E0768: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E076C: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E0770: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E0774: 4082FFE8  bne 0x828e075c
	if !ctx.cr[0].eq {
	pc = 0x828E075C; continue 'dispatch;
	}
	// 828E0778: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E077C: 409A001C  bne cr6, 0x828e0798
	if !ctx.cr[6].eq {
	pc = 0x828E0798; continue 'dispatch;
	}
	// 828E0780: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E0784: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0788: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E078C: 4E800421  bctrl
	ctx.lr = 0x828E0790;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0790: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828E0794: 4B93B5A5  bl 0x8221bd38
	ctx.lr = 0x828E0798;
	sub_8221BD38(ctx, base);
	// 828E0798: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E079C: 4B8D737D  bl 0x821b7b18
	ctx.lr = 0x828E07A0;
	sub_821B7B18(ctx, base);
	// 828E07A0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E07A4: 483C8CAC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E07A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E07A8 size=528
    let mut pc: u32 = 0x828E07A8;
    'dispatch: loop {
        match pc {
            0x828E07A8 => {
    //   block [0x828E07A8..0x828E09B8)
	// 828E07A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E07AC: 483C8C51  bl 0x82ca93fc
	ctx.lr = 0x828E07B0;
	sub_82CA93D0(ctx, base);
	// 828E07B0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E07B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E07B8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E07BC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828E07C0: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828E07C4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828E07C8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E07CC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828E07D0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828E07D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E07D8: 419A0008  beq cr6, 0x828e07e0
	if ctx.cr[6].eq {
	pc = 0x828E07E0; continue 'dispatch;
	}
	// 828E07DC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E07E0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E07E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E07E8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E07EC: 4BAEDDD5  bl 0x823ce5c0
	ctx.lr = 0x828E07F0;
	sub_823CE5C0(ctx, base);
	// 828E07F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E07F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E07F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E07FC: 4BAED915  bl 0x823ce110
	ctx.lr = 0x828E0800;
	sub_823CE110(ctx, base);
	// 828E0800: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E0804: 4B8D7315  bl 0x821b7b18
	ctx.lr = 0x828E0808;
	sub_821B7B18(ctx, base);
	// 828E0808: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828E080C: 4B93EA4D  bl 0x8221f258
	ctx.lr = 0x828E0810;
	sub_8221F258(ctx, base);
	// 828E0810: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E0814: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E0818: 419A006C  beq cr6, 0x828e0884
	if ctx.cr[6].eq {
	pc = 0x828E0884; continue 'dispatch;
	}
	// 828E081C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828E0820: FBBF0008  std r29, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 828E0824: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E0828: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828E082C: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 828E0830: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E0834: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828E0838: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E083C: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E0840: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 828E0844: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828E0848: F8FF0010  std r7, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u64 ) };
	// 828E084C: 4B90F9F5  bl 0x821f0240
	ctx.lr = 0x828E0850;
	sub_821F0240(ctx, base);
	// 828E0850: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828E0854: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828E0858: 4B93EA01  bl 0x8221f258
	ctx.lr = 0x828E085C;
	sub_8221F258(ctx, base);
	// 828E085C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E0860: 419A0028  beq cr6, 0x828e0888
	if ctx.cr[6].eq {
	pc = 0x828E0888; continue 'dispatch;
	}
	// 828E0864: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828E0868: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828E086C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E0870: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828E0874: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828E0878: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E087C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E0880: 4800000C  b 0x828e088c
	pc = 0x828E088C; continue 'dispatch;
	// 828E0884: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828E0888: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E088C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0890: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828E0894: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E0898: 419A0008  beq cr6, 0x828e08a0
	if ctx.cr[6].eq {
	pc = 0x828E08A0; continue 'dispatch;
	}
	// 828E089C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E08A0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E08A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E08A8: 419A0078  beq cr6, 0x828e0920
	if ctx.cr[6].eq {
	pc = 0x828E0920; continue 'dispatch;
	}
	// 828E08AC: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E08B0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828E08B4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E08B8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E08BC: 4B94884D  bl 0x82229108
	ctx.lr = 0x828E08C0;
	sub_82229108(ctx, base);
	// 828E08C0: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828E08C4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828E08C8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E08CC: 3BCB0F60  addi r30, r11, 0xf60
	ctx.r[30].s64 = ctx.r[11].s64 + 3936;
	// 828E08D0: 4B946FB1  bl 0x82227880
	ctx.lr = 0x828E08D4;
	sub_82227880(ctx, base);
	// 828E08D4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E08D8: 3D408295  lis r10, -0x7d6b
	ctx.r[10].s64 = -2104164352;
	// 828E08DC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E08E0: 388AC430  addi r4, r10, -0x3bd0
	ctx.r[4].s64 = ctx.r[10].s64 + -15312;
	// 828E08E4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E08E8: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828E08EC: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828E08F0: 4B8BA191  bl 0x8219aa80
	ctx.lr = 0x828E08F4;
	sub_8219AA80(ctx, base);
	// 828E08F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E08F8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828E08FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E0900: 4BAEDB21  bl 0x823ce420
	ctx.lr = 0x828E0904;
	sub_823CE420(ctx, base);
	// 828E0904: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E0908: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828E090C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E0910: 48143DB9  bl 0x82a246c8
	ctx.lr = 0x828E0914;
	sub_82A246C8(ctx, base);
	// 828E0914: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E0918: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828E091C: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828E0920: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828E0924: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E0928: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828E092C: 419A0020  beq cr6, 0x828e094c
	if ctx.cr[6].eq {
	pc = 0x828E094C; continue 'dispatch;
	}
	// 828E0930: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E0934: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E0938: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E093C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828E0940: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E0944: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E0948: 4082FFE8  bne 0x828e0930
	if !ctx.cr[0].eq {
	pc = 0x828E0930; continue 'dispatch;
	}
	// 828E094C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0950: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E0954: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828E0958: 4BA14FF1  bl 0x822f5948
	ctx.lr = 0x828E095C;
	sub_822F5948(ctx, base);
	// 828E095C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E0960: 4B8D71B9  bl 0x821b7b18
	ctx.lr = 0x828E0964;
	sub_821B7B18(ctx, base);
	// 828E0964: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E0968: 419A0040  beq cr6, 0x828e09a8
	if ctx.cr[6].eq {
	pc = 0x828E09A8; continue 'dispatch;
	}
	// 828E096C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E0970: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E0974: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E0978: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E097C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E0980: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E0984: 4082FFE8  bne 0x828e096c
	if !ctx.cr[0].eq {
	pc = 0x828E096C; continue 'dispatch;
	}
	// 828E0988: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E098C: 409A001C  bne cr6, 0x828e09a8
	if !ctx.cr[6].eq {
	pc = 0x828E09A8; continue 'dispatch;
	}
	// 828E0990: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E0994: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0998: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E099C: 4E800421  bctrl
	ctx.lr = 0x828E09A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E09A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E09A4: 4B93B395  bl 0x8221bd38
	ctx.lr = 0x828E09A8;
	sub_8221BD38(ctx, base);
	// 828E09A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E09AC: 4B8D716D  bl 0x821b7b18
	ctx.lr = 0x828E09B0;
	sub_821B7B18(ctx, base);
	// 828E09B0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828E09B4: 483C8A98  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E09B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E09B8 size=528
    let mut pc: u32 = 0x828E09B8;
    'dispatch: loop {
        match pc {
            0x828E09B8 => {
    //   block [0x828E09B8..0x828E0BC8)
	// 828E09B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E09BC: 483C8A41  bl 0x82ca93fc
	ctx.lr = 0x828E09C0;
	sub_82CA93D0(ctx, base);
	// 828E09C0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E09C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E09C8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E09CC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828E09D0: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828E09D4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828E09D8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E09DC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828E09E0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828E09E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E09E8: 419A0008  beq cr6, 0x828e09f0
	if ctx.cr[6].eq {
	pc = 0x828E09F0; continue 'dispatch;
	}
	// 828E09EC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E09F0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E09F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E09F8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E09FC: 4BAEDBC5  bl 0x823ce5c0
	ctx.lr = 0x828E0A00;
	sub_823CE5C0(ctx, base);
	// 828E0A00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E0A04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E0A08: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E0A0C: 4BAED705  bl 0x823ce110
	ctx.lr = 0x828E0A10;
	sub_823CE110(ctx, base);
	// 828E0A10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E0A14: 4B8D7105  bl 0x821b7b18
	ctx.lr = 0x828E0A18;
	sub_821B7B18(ctx, base);
	// 828E0A18: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828E0A1C: 4B93E83D  bl 0x8221f258
	ctx.lr = 0x828E0A20;
	sub_8221F258(ctx, base);
	// 828E0A20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E0A24: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E0A28: 419A006C  beq cr6, 0x828e0a94
	if ctx.cr[6].eq {
	pc = 0x828E0A94; continue 'dispatch;
	}
	// 828E0A2C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828E0A30: FBBF0008  std r29, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 828E0A34: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E0A38: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828E0A3C: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 828E0A40: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E0A44: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828E0A48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E0A4C: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E0A50: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 828E0A54: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828E0A58: F8FF0010  std r7, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u64 ) };
	// 828E0A5C: 4B90F7E5  bl 0x821f0240
	ctx.lr = 0x828E0A60;
	sub_821F0240(ctx, base);
	// 828E0A60: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828E0A64: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828E0A68: 4B93E7F1  bl 0x8221f258
	ctx.lr = 0x828E0A6C;
	sub_8221F258(ctx, base);
	// 828E0A6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E0A70: 419A0028  beq cr6, 0x828e0a98
	if ctx.cr[6].eq {
	pc = 0x828E0A98; continue 'dispatch;
	}
	// 828E0A74: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828E0A78: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828E0A7C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E0A80: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828E0A84: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828E0A88: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E0A8C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E0A90: 4800000C  b 0x828e0a9c
	pc = 0x828E0A9C; continue 'dispatch;
	// 828E0A94: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828E0A98: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E0A9C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0AA0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828E0AA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E0AA8: 419A0008  beq cr6, 0x828e0ab0
	if ctx.cr[6].eq {
	pc = 0x828E0AB0; continue 'dispatch;
	}
	// 828E0AAC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0AB0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E0AB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E0AB8: 419A0078  beq cr6, 0x828e0b30
	if ctx.cr[6].eq {
	pc = 0x828E0B30; continue 'dispatch;
	}
	// 828E0ABC: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0AC0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828E0AC4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0AC8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E0ACC: 4B94863D  bl 0x82229108
	ctx.lr = 0x828E0AD0;
	sub_82229108(ctx, base);
	// 828E0AD0: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828E0AD4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828E0AD8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E0ADC: 3BCB10D8  addi r30, r11, 0x10d8
	ctx.r[30].s64 = ctx.r[11].s64 + 4312;
	// 828E0AE0: 4B946DA1  bl 0x82227880
	ctx.lr = 0x828E0AE4;
	sub_82227880(ctx, base);
	// 828E0AE4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E0AE8: 3D40825F  lis r10, -0x7da1
	ctx.r[10].s64 = -2107703296;
	// 828E0AEC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E0AF0: 388A8BA8  addi r4, r10, -0x7458
	ctx.r[4].s64 = ctx.r[10].s64 + -29784;
	// 828E0AF4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E0AF8: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828E0AFC: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828E0B00: 4B8B9F81  bl 0x8219aa80
	ctx.lr = 0x828E0B04;
	sub_8219AA80(ctx, base);
	// 828E0B04: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E0B08: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828E0B0C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E0B10: 4BAED911  bl 0x823ce420
	ctx.lr = 0x828E0B14;
	sub_823CE420(ctx, base);
	// 828E0B14: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E0B18: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828E0B1C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E0B20: 48143BA9  bl 0x82a246c8
	ctx.lr = 0x828E0B24;
	sub_82A246C8(ctx, base);
	// 828E0B24: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E0B28: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828E0B2C: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828E0B30: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828E0B34: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E0B38: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828E0B3C: 419A0020  beq cr6, 0x828e0b5c
	if ctx.cr[6].eq {
	pc = 0x828E0B5C; continue 'dispatch;
	}
	// 828E0B40: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E0B44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E0B48: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E0B4C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828E0B50: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E0B54: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E0B58: 4082FFE8  bne 0x828e0b40
	if !ctx.cr[0].eq {
	pc = 0x828E0B40; continue 'dispatch;
	}
	// 828E0B5C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0B60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E0B64: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828E0B68: 4BA14DE1  bl 0x822f5948
	ctx.lr = 0x828E0B6C;
	sub_822F5948(ctx, base);
	// 828E0B6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E0B70: 4B8D6FA9  bl 0x821b7b18
	ctx.lr = 0x828E0B74;
	sub_821B7B18(ctx, base);
	// 828E0B74: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E0B78: 419A0040  beq cr6, 0x828e0bb8
	if ctx.cr[6].eq {
	pc = 0x828E0BB8; continue 'dispatch;
	}
	// 828E0B7C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E0B80: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E0B84: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E0B88: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E0B8C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E0B90: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E0B94: 4082FFE8  bne 0x828e0b7c
	if !ctx.cr[0].eq {
	pc = 0x828E0B7C; continue 'dispatch;
	}
	// 828E0B98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E0B9C: 409A001C  bne cr6, 0x828e0bb8
	if !ctx.cr[6].eq {
	pc = 0x828E0BB8; continue 'dispatch;
	}
	// 828E0BA0: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E0BA4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0BA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0BAC: 4E800421  bctrl
	ctx.lr = 0x828E0BB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0BB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E0BB4: 4B93B185  bl 0x8221bd38
	ctx.lr = 0x828E0BB8;
	sub_8221BD38(ctx, base);
	// 828E0BB8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E0BBC: 4B8D6F5D  bl 0x821b7b18
	ctx.lr = 0x828E0BC0;
	sub_821B7B18(ctx, base);
	// 828E0BC0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828E0BC4: 483C8888  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E0BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E0BC8 size=528
    let mut pc: u32 = 0x828E0BC8;
    'dispatch: loop {
        match pc {
            0x828E0BC8 => {
    //   block [0x828E0BC8..0x828E0DD8)
	// 828E0BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E0BCC: 483C8831  bl 0x82ca93fc
	ctx.lr = 0x828E0BD0;
	sub_82CA93D0(ctx, base);
	// 828E0BD0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E0BD4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E0BD8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E0BDC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828E0BE0: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828E0BE4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828E0BE8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0BEC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828E0BF0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828E0BF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E0BF8: 419A0008  beq cr6, 0x828e0c00
	if ctx.cr[6].eq {
	pc = 0x828E0C00; continue 'dispatch;
	}
	// 828E0BFC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0C00: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0C04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E0C08: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0C0C: 4BAED9B5  bl 0x823ce5c0
	ctx.lr = 0x828E0C10;
	sub_823CE5C0(ctx, base);
	// 828E0C10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E0C14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E0C18: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E0C1C: 4BAED4F5  bl 0x823ce110
	ctx.lr = 0x828E0C20;
	sub_823CE110(ctx, base);
	// 828E0C20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E0C24: 4B8D6EF5  bl 0x821b7b18
	ctx.lr = 0x828E0C28;
	sub_821B7B18(ctx, base);
	// 828E0C28: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828E0C2C: 4B93E62D  bl 0x8221f258
	ctx.lr = 0x828E0C30;
	sub_8221F258(ctx, base);
	// 828E0C30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E0C34: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E0C38: 419A006C  beq cr6, 0x828e0ca4
	if ctx.cr[6].eq {
	pc = 0x828E0CA4; continue 'dispatch;
	}
	// 828E0C3C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828E0C40: FBBF0010  std r29, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u64 ) };
	// 828E0C44: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E0C48: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828E0C4C: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 828E0C50: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E0C54: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828E0C58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E0C5C: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E0C60: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 828E0C64: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828E0C68: F8FF0008  std r7, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 828E0C6C: 4B90F5D5  bl 0x821f0240
	ctx.lr = 0x828E0C70;
	sub_821F0240(ctx, base);
	// 828E0C70: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828E0C74: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828E0C78: 4B93E5E1  bl 0x8221f258
	ctx.lr = 0x828E0C7C;
	sub_8221F258(ctx, base);
	// 828E0C7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E0C80: 419A0028  beq cr6, 0x828e0ca8
	if ctx.cr[6].eq {
	pc = 0x828E0CA8; continue 'dispatch;
	}
	// 828E0C84: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828E0C88: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828E0C8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E0C90: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828E0C94: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828E0C98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E0C9C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E0CA0: 4800000C  b 0x828e0cac
	pc = 0x828E0CAC; continue 'dispatch;
	// 828E0CA4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828E0CA8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E0CAC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0CB0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828E0CB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E0CB8: 419A0008  beq cr6, 0x828e0cc0
	if ctx.cr[6].eq {
	pc = 0x828E0CC0; continue 'dispatch;
	}
	// 828E0CBC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0CC0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E0CC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E0CC8: 419A0078  beq cr6, 0x828e0d40
	if ctx.cr[6].eq {
	pc = 0x828E0D40; continue 'dispatch;
	}
	// 828E0CCC: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0CD0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828E0CD4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0CD8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E0CDC: 4B94842D  bl 0x82229108
	ctx.lr = 0x828E0CE0;
	sub_82229108(ctx, base);
	// 828E0CE0: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828E0CE4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828E0CE8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E0CEC: 3BCB1258  addi r30, r11, 0x1258
	ctx.r[30].s64 = ctx.r[11].s64 + 4696;
	// 828E0CF0: 4B946B91  bl 0x82227880
	ctx.lr = 0x828E0CF4;
	sub_82227880(ctx, base);
	// 828E0CF4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E0CF8: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828E0CFC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E0D00: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828E0D04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E0D08: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828E0D0C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828E0D10: 4B8B9D71  bl 0x8219aa80
	ctx.lr = 0x828E0D14;
	sub_8219AA80(ctx, base);
	// 828E0D14: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E0D18: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828E0D1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E0D20: 4BAED701  bl 0x823ce420
	ctx.lr = 0x828E0D24;
	sub_823CE420(ctx, base);
	// 828E0D24: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E0D28: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828E0D2C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E0D30: 48143999  bl 0x82a246c8
	ctx.lr = 0x828E0D34;
	sub_82A246C8(ctx, base);
	// 828E0D34: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E0D38: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828E0D3C: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828E0D40: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828E0D44: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E0D48: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828E0D4C: 419A0020  beq cr6, 0x828e0d6c
	if ctx.cr[6].eq {
	pc = 0x828E0D6C; continue 'dispatch;
	}
	// 828E0D50: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E0D54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E0D58: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E0D5C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828E0D60: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E0D64: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E0D68: 4082FFE8  bne 0x828e0d50
	if !ctx.cr[0].eq {
	pc = 0x828E0D50; continue 'dispatch;
	}
	// 828E0D6C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0D70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E0D74: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828E0D78: 4BA14BD1  bl 0x822f5948
	ctx.lr = 0x828E0D7C;
	sub_822F5948(ctx, base);
	// 828E0D7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E0D80: 4B8D6D99  bl 0x821b7b18
	ctx.lr = 0x828E0D84;
	sub_821B7B18(ctx, base);
	// 828E0D84: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E0D88: 419A0040  beq cr6, 0x828e0dc8
	if ctx.cr[6].eq {
	pc = 0x828E0DC8; continue 'dispatch;
	}
	// 828E0D8C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E0D90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E0D94: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E0D98: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E0D9C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E0DA0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E0DA4: 4082FFE8  bne 0x828e0d8c
	if !ctx.cr[0].eq {
	pc = 0x828E0D8C; continue 'dispatch;
	}
	// 828E0DA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E0DAC: 409A001C  bne cr6, 0x828e0dc8
	if !ctx.cr[6].eq {
	pc = 0x828E0DC8; continue 'dispatch;
	}
	// 828E0DB0: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E0DB4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0DB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0DBC: 4E800421  bctrl
	ctx.lr = 0x828E0DC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0DC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E0DC4: 4B93AF75  bl 0x8221bd38
	ctx.lr = 0x828E0DC8;
	sub_8221BD38(ctx, base);
	// 828E0DC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E0DCC: 4B8D6D4D  bl 0x821b7b18
	ctx.lr = 0x828E0DD0;
	sub_821B7B18(ctx, base);
	// 828E0DD0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828E0DD4: 483C8678  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E0DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E0DD8 size=324
    let mut pc: u32 = 0x828E0DD8;
    'dispatch: loop {
        match pc {
            0x828E0DD8 => {
    //   block [0x828E0DD8..0x828E0F1C)
	// 828E0DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E0DDC: 483C8625  bl 0x82ca9400
	ctx.lr = 0x828E0DE0;
	sub_82CA93D0(ctx, base);
	// 828E0DE0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E0DE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E0DE8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828E0DEC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828E0DF0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828E0DF4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0DF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E0DFC: 419A0114  beq cr6, 0x828e0f10
	if ctx.cr[6].eq {
	pc = 0x828E0F10; continue 'dispatch;
	}
	// 828E0E00: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0E04: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 828E0E08: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828E0E0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0E10: 388BEE10  addi r4, r11, -0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + -4592;
	// 828E0E14: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E0E18: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E0E1C: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 828E0E20: 7D1A1E70  srawi r26, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 828E0E24: 4B8B9C5D  bl 0x8219aa80
	ctx.lr = 0x828E0E28;
	sub_8219AA80(ctx, base);
	// 828E0E28: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0E2C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828E0E30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0E34: 80A70008  lwz r5, 8(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E0E38: 4B9482D1  bl 0x82229108
	ctx.lr = 0x828E0E3C;
	sub_82229108(ctx, base);
	// 828E0E3C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0E40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E0E44: 419A0014  beq cr6, 0x828e0e58
	if ctx.cr[6].eq {
	pc = 0x828E0E58; continue 'dispatch;
	}
	// 828E0E48: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828E0E4C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0E50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0E54: 4B9482B5  bl 0x82229108
	ctx.lr = 0x828E0E58;
	sub_82229108(ctx, base);
	// 828E0E58: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E0E5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0E60: 4BAC2161  bl 0x823a2fc0
	ctx.lr = 0x828E0E64;
	sub_823A2FC0(ctx, base);
	// 828E0E64: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E0E68: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 828E0E6C: 80DF0020  lwz r6, 0x20(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828E0E70: 394BFFE8  addi r10, r11, -0x18
	ctx.r[10].s64 = ctx.r[11].s64 + -24;
	// 828E0E74: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 828E0E78: 396BFFE0  addi r11, r11, -0x20
	ctx.r[11].s64 = ctx.r[11].s64 + -32;
	// 828E0E7C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828E0E80: 3D0082A2  lis r8, -0x7d5e
	ctx.r[8].s64 = -2103312384;
	// 828E0E84: 7CE65850  subf r7, r6, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 828E0E88: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828E0E8C: 38884808  addi r4, r8, 0x4808
	ctx.r[4].s64 = ctx.r[8].s64 + 18440;
	// 828E0E90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0E94: 7CC65050  subf r6, r6, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[6].s64;
	// 828E0E98: 4B8B99A9  bl 0x8219a840
	ctx.lr = 0x828E0E9C;
	sub_8219A840(ctx, base);
	// 828E0E9C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 828E0EA0: 409A0048  bne cr6, 0x828e0ee8
	if !ctx.cr[6].eq {
	pc = 0x828E0EE8; continue 'dispatch;
	}
	// 828E0EA4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E0EA8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828E0EAC: 392A9700  addi r9, r10, -0x6900
	ctx.r[9].s64 = ctx.r[10].s64 + -26880;
	// 828E0EB0: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 828E0EB4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828E0EB8: 419A004C  beq cr6, 0x828e0f04
	if ctx.cr[6].eq {
	pc = 0x828E0F04; continue 'dispatch;
	}
	// 828E0EBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0EC0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828E0EC4: 409A0040  bne cr6, 0x828e0f04
	if !ctx.cr[6].eq {
	pc = 0x828E0F04; continue 'dispatch;
	}
	// 828E0EC8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828E0ECC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E0ED0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E0ED4: 9B6B0000  stb r27, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u8 ) };
	// 828E0ED8: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E0EDC: 4BA20FBD  bl 0x82301e98
	ctx.lr = 0x828E0EE0;
	sub_82301E98(ctx, base);
	// 828E0EE0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828E0EE4: 48000020  b 0x828e0f04
	pc = 0x828E0F04; continue 'dispatch;
	// 828E0EE8: 4831B921  bl 0x82bfc808
	ctx.lr = 0x828E0EEC;
	sub_82BFC808(ctx, base);
	// 828E0EEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E0EF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E0EF4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E0EF8: 4B94BFD9  bl 0x8222ced0
	ctx.lr = 0x828E0EFC;
	sub_8222CED0(ctx, base);
	// 828E0EFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E0F00: 4B933ED9  bl 0x82214dd8
	ctx.lr = 0x828E0F04;
	sub_82214DD8(ctx, base);
	// 828E0F04: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828E0F08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0F0C: 482EADFD  bl 0x82bcbd08
	ctx.lr = 0x828E0F10;
	sub_82BCBD08(ctx, base);
	// 828E0F10: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E0F14: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E0F18: 483C8538  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E0F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E0F20 size=56
    let mut pc: u32 = 0x828E0F20;
    'dispatch: loop {
        match pc {
            0x828E0F20 => {
    //   block [0x828E0F20..0x828E0F58)
	// 828E0F20: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828E0F24: 419A0018  beq cr6, 0x828e0f3c
	if ctx.cr[6].eq {
	pc = 0x828E0F3C; continue 'dispatch;
	}
	// 828E0F28: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E0F2C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E0F30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E0F34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E0F38: 409A0008  bne cr6, 0x828e0f40
	if !ctx.cr[6].eq {
	pc = 0x828E0F40; continue 'dispatch;
	}
	// 828E0F3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E0F40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E0F44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E0F48: 419A0010  beq cr6, 0x828e0f58
	if ctx.cr[6].eq {
		sub_828E0F58(ctx, base);
		return;
	}
	// 828E0F4C: 8164003C  lwz r11, 0x3c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 828E0F50: 5563CFFE  rlwinm r3, r11, 0x19, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 828E0F54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E0F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E0F58 size=8
    let mut pc: u32 = 0x828E0F58;
    'dispatch: loop {
        match pc {
            0x828E0F58 => {
    //   block [0x828E0F58..0x828E0F60)
	// 828E0F58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E0F5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E0F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E0F60 size=376
    let mut pc: u32 = 0x828E0F60;
    'dispatch: loop {
        match pc {
            0x828E0F60 => {
    //   block [0x828E0F60..0x828E10D8)
	// 828E0F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E0F64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E0F68: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E0F6C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828E0F70: 419A0018  beq cr6, 0x828e0f88
	if ctx.cr[6].eq {
	pc = 0x828E0F88; continue 'dispatch;
	}
	// 828E0F74: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E0F78: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E0F7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E0F80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E0F84: 409A0008  bne cr6, 0x828e0f8c
	if !ctx.cr[6].eq {
	pc = 0x828E0F8C; continue 'dispatch;
	}
	// 828E0F88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E0F8C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E0F90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E0F94: 419A0130  beq cr6, 0x828e10c4
	if ctx.cr[6].eq {
	pc = 0x828E10C4; continue 'dispatch;
	}
	// 828E0F98: 8144003C  lwz r10, 0x3c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 828E0F9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E0FA0: 5549CFFE  rlwinm r9, r10, 0x19, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 828E0FA4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E0FA8: 419A00E8  beq cr6, 0x828e1090
	if ctx.cr[6].eq {
	pc = 0x828E1090; continue 'dispatch;
	}
	// 828E0FAC: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E0FB0: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E0FB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E0FB8: 419A001C  beq cr6, 0x828e0fd4
	if ctx.cr[6].eq {
	pc = 0x828E0FD4; continue 'dispatch;
	}
	// 828E0FBC: 896B00C7  lbz r11, 0xc7(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(199 as u32) ) } as u64;
	// 828E0FC0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828E0FC4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E0FC8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0FCC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E0FD0: 480000C4  b 0x828e1094
	pc = 0x828E1094; continue 'dispatch;
	// 828E0FD4: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E0FD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E0FDC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E0FE0: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E0FE4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E0FE8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E0FEC: 40810054  ble 0x828e1040
	if !ctx.cr[0].gt {
	pc = 0x828E1040; continue 'dispatch;
	}
	// 828E0FF0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E0FF4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E0FF8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E0FFC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1000: 2F0700C7  cmpwi cr6, r7, 0xc7
	ctx.cr[6].compare_i32(ctx.r[7].s32, 199, &mut ctx.xer);
	// 828E1004: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E1008: 41980008  blt cr6, 0x828e1010
	if ctx.cr[6].lt {
	pc = 0x828E1010; continue 'dispatch;
	}
	// 828E100C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828E1010: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E1014: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E1018: 419A0014  beq cr6, 0x828e102c
	if ctx.cr[6].eq {
	pc = 0x828E102C; continue 'dispatch;
	}
	// 828E101C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E1020: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E1024: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E1028: 4800000C  b 0x828e1034
	pc = 0x828E1034; continue 'dispatch;
	// 828E102C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E1030: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E1034: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E1038: 4199FFB8  bgt cr6, 0x828e0ff0
	if ctx.cr[6].gt {
	pc = 0x828E0FF0; continue 'dispatch;
	}
	// 828E103C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E1040: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E1044: 419A003C  beq cr6, 0x828e1080
	if ctx.cr[6].eq {
	pc = 0x828E1080; continue 'dispatch;
	}
	// 828E1048: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E104C: 2F0B00C7  cmpwi cr6, r11, 0xc7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 199, &mut ctx.xer);
	// 828E1050: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E1054: 41990008  bgt cr6, 0x828e105c
	if ctx.cr[6].gt {
	pc = 0x828E105C; continue 'dispatch;
	}
	// 828E1058: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E105C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E1060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E1064: 409A001C  bne cr6, 0x828e1080
	if !ctx.cr[6].eq {
	pc = 0x828E1080; continue 'dispatch;
	}
	// 828E1068: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E106C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E1070: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E1074: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E1078: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E107C: 48000018  b 0x828e1094
	pc = 0x828E1094; continue 'dispatch;
	// 828E1080: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E1084: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E1088: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E108C: 48000008  b 0x828e1094
	pc = 0x828E1094; continue 'dispatch;
	// 828E1090: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E1094: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E1098: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E109C: 419A0028  beq cr6, 0x828e10c4
	if ctx.cr[6].eq {
	pc = 0x828E10C4; continue 'dispatch;
	}
	// 828E10A0: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E10A4: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E10A8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E10AC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828E10B0: 4E800421  bctrl
	ctx.lr = 0x828E10B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E10B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E10B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E10BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E10C0: 4E800020  blr
	return;
	// 828E10C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E10C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E10CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E10D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E10D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E10D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E10D8 size=380
    let mut pc: u32 = 0x828E10D8;
    'dispatch: loop {
        match pc {
            0x828E10D8 => {
    //   block [0x828E10D8..0x828E1254)
	// 828E10D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E10DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E10E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E10E4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828E10E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E10EC: 419A0018  beq cr6, 0x828e1104
	if ctx.cr[6].eq {
	pc = 0x828E1104; continue 'dispatch;
	}
	// 828E10F0: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E10F4: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828E10F8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E10FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E1100: 409A0008  bne cr6, 0x828e1108
	if !ctx.cr[6].eq {
	pc = 0x828E1108; continue 'dispatch;
	}
	// 828E1104: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E1108: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E110C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E1110: 419A0134  beq cr6, 0x828e1244
	if ctx.cr[6].eq {
	pc = 0x828E1244; continue 'dispatch;
	}
	// 828E1114: 812B003C  lwz r9, 0x3c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828E1118: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E111C: 5528CFFE  rlwinm r8, r9, 0x19, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000007Fu64;
	// 828E1120: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828E1124: 419A00F8  beq cr6, 0x828e121c
	if ctx.cr[6].eq {
	pc = 0x828E121C; continue 'dispatch;
	}
	// 828E1128: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E112C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E1130: 419A0024  beq cr6, 0x828e1154
	if ctx.cr[6].eq {
	pc = 0x828E1154; continue 'dispatch;
	}
	// 828E1134: 892A00C7  lbz r9, 0xc7(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(199 as u32) ) } as u64;
	// 828E1138: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E113C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828E1140: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E1144: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1148: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828E114C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E1150: 480000D0  b 0x828e1220
	pc = 0x828E1220; continue 'dispatch;
	// 828E1154: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E1158: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828E115C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E1160: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828E1164: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E1168: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E116C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E1170: 40810054  ble 0x828e11c4
	if !ctx.cr[0].gt {
	pc = 0x828E11C4; continue 'dispatch;
	}
	// 828E1174: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E1178: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E117C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E1180: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1184: 2F0700C7  cmpwi cr6, r7, 0xc7
	ctx.cr[6].compare_i32(ctx.r[7].s32, 199, &mut ctx.xer);
	// 828E1188: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E118C: 41980008  blt cr6, 0x828e1194
	if ctx.cr[6].lt {
	pc = 0x828E1194; continue 'dispatch;
	}
	// 828E1190: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828E1194: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E1198: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E119C: 419A0014  beq cr6, 0x828e11b0
	if ctx.cr[6].eq {
	pc = 0x828E11B0; continue 'dispatch;
	}
	// 828E11A0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E11A4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E11A8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E11AC: 4800000C  b 0x828e11b8
	pc = 0x828E11B8; continue 'dispatch;
	// 828E11B0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E11B4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E11B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E11BC: 4199FFB8  bgt cr6, 0x828e1174
	if ctx.cr[6].gt {
	pc = 0x828E1174; continue 'dispatch;
	}
	// 828E11C0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E11C4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E11C8: 419A0040  beq cr6, 0x828e1208
	if ctx.cr[6].eq {
	pc = 0x828E1208; continue 'dispatch;
	}
	// 828E11CC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E11D0: 2F0B00C7  cmpwi cr6, r11, 0xc7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 199, &mut ctx.xer);
	// 828E11D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E11D8: 41990008  bgt cr6, 0x828e11e0
	if ctx.cr[6].gt {
	pc = 0x828E11E0; continue 'dispatch;
	}
	// 828E11DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E11E0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E11E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E11E8: 409A0020  bne cr6, 0x828e1208
	if !ctx.cr[6].eq {
	pc = 0x828E1208; continue 'dispatch;
	}
	// 828E11EC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E11F0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E11F4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E11F8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E11FC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828E1200: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E1204: 4800001C  b 0x828e1220
	pc = 0x828E1220; continue 'dispatch;
	// 828E1208: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E120C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1210: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828E1214: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E1218: 48000008  b 0x828e1220
	pc = 0x828E1220; continue 'dispatch;
	// 828E121C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E1220: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E1224: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E1228: 419A001C  beq cr6, 0x828e1244
	if ctx.cr[6].eq {
	pc = 0x828E1244; continue 'dispatch;
	}
	// 828E122C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E1230: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828E1234: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E1238: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E123C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828E1240: 4E800421  bctrl
	ctx.lr = 0x828E1244;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E1244: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E1248: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E124C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E1250: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E1258 size=376
    let mut pc: u32 = 0x828E1258;
    'dispatch: loop {
        match pc {
            0x828E1258 => {
    //   block [0x828E1258..0x828E13D0)
	// 828E1258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E125C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E1260: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E1264: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828E1268: 419A0018  beq cr6, 0x828e1280
	if ctx.cr[6].eq {
	pc = 0x828E1280; continue 'dispatch;
	}
	// 828E126C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E1270: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E1274: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E1278: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E127C: 409A0008  bne cr6, 0x828e1284
	if !ctx.cr[6].eq {
	pc = 0x828E1284; continue 'dispatch;
	}
	// 828E1280: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E1284: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E1288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E128C: 419A0130  beq cr6, 0x828e13bc
	if ctx.cr[6].eq {
	pc = 0x828E13BC; continue 'dispatch;
	}
	// 828E1290: 8144003C  lwz r10, 0x3c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 828E1294: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E1298: 5549CFFE  rlwinm r9, r10, 0x19, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 828E129C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E12A0: 419A00E8  beq cr6, 0x828e1388
	if ctx.cr[6].eq {
	pc = 0x828E1388; continue 'dispatch;
	}
	// 828E12A4: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E12A8: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E12AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E12B0: 419A001C  beq cr6, 0x828e12cc
	if ctx.cr[6].eq {
	pc = 0x828E12CC; continue 'dispatch;
	}
	// 828E12B4: 896B00C7  lbz r11, 0xc7(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(199 as u32) ) } as u64;
	// 828E12B8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828E12BC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E12C0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E12C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E12C8: 480000C4  b 0x828e138c
	pc = 0x828E138C; continue 'dispatch;
	// 828E12CC: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E12D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E12D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E12D8: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E12DC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E12E0: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E12E4: 40810054  ble 0x828e1338
	if !ctx.cr[0].gt {
	pc = 0x828E1338; continue 'dispatch;
	}
	// 828E12E8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E12EC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E12F0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E12F4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E12F8: 2F0700C7  cmpwi cr6, r7, 0xc7
	ctx.cr[6].compare_i32(ctx.r[7].s32, 199, &mut ctx.xer);
	// 828E12FC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E1300: 41980008  blt cr6, 0x828e1308
	if ctx.cr[6].lt {
	pc = 0x828E1308; continue 'dispatch;
	}
	// 828E1304: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828E1308: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E130C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E1310: 419A0014  beq cr6, 0x828e1324
	if ctx.cr[6].eq {
	pc = 0x828E1324; continue 'dispatch;
	}
	// 828E1314: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E1318: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E131C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E1320: 4800000C  b 0x828e132c
	pc = 0x828E132C; continue 'dispatch;
	// 828E1324: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E1328: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E132C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E1330: 4199FFB8  bgt cr6, 0x828e12e8
	if ctx.cr[6].gt {
	pc = 0x828E12E8; continue 'dispatch;
	}
	// 828E1334: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E1338: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E133C: 419A003C  beq cr6, 0x828e1378
	if ctx.cr[6].eq {
	pc = 0x828E1378; continue 'dispatch;
	}
	// 828E1340: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1344: 2F0B00C7  cmpwi cr6, r11, 0xc7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 199, &mut ctx.xer);
	// 828E1348: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E134C: 41990008  bgt cr6, 0x828e1354
	if ctx.cr[6].gt {
	pc = 0x828E1354; continue 'dispatch;
	}
	// 828E1350: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E1354: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E1358: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E135C: 409A001C  bne cr6, 0x828e1378
	if !ctx.cr[6].eq {
	pc = 0x828E1378; continue 'dispatch;
	}
	// 828E1360: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E1364: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E1368: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E136C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E1370: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1374: 48000018  b 0x828e138c
	pc = 0x828E138C; continue 'dispatch;
	// 828E1378: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E137C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E1380: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1384: 48000008  b 0x828e138c
	pc = 0x828E138C; continue 'dispatch;
	// 828E1388: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E138C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E1390: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E1394: 419A0028  beq cr6, 0x828e13bc
	if ctx.cr[6].eq {
	pc = 0x828E13BC; continue 'dispatch;
	}
	// 828E1398: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 828E139C: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828E13A0: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E13A4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828E13A8: 4E800421  bctrl
	ctx.lr = 0x828E13AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E13AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E13B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E13B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E13B8: 4E800020  blr
	return;
	// 828E13BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E13C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E13C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E13C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E13CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E13D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E13D0 size=8
    let mut pc: u32 = 0x828E13D0;
    'dispatch: loop {
        match pc {
            0x828E13D0 => {
    //   block [0x828E13D0..0x828E13D8)
	// 828E13D0: 3863FFF4  addi r3, r3, -0xc
	ctx.r[3].s64 = ctx.r[3].s64 + -12;
	// 828E13D4: 4BFFE0E4  b 0x828df4b8
	sub_828DF4B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E13D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E13D8 size=672
    let mut pc: u32 = 0x828E13D8;
    'dispatch: loop {
        match pc {
            0x828E13D8 => {
    //   block [0x828E13D8..0x828E1678)
	// 828E13D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E13DC: 483C802D  bl 0x82ca9408
	ctx.lr = 0x828E13E0;
	sub_82CA93D0(ctx, base);
	// 828E13E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E13E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E13E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E13EC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828E13F0: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 828E13F4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E13F8: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828E13FC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828E1400: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828E1404: 4B933495  bl 0x82214898
	ctx.lr = 0x828E1408;
	sub_82214898(ctx, base);
	// 828E1408: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 828E140C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E1410: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 828E1414: 3866D5C8  addi r3, r6, -0x2a38
	ctx.r[3].s64 = ctx.r[6].s64 + -10808;
	// 828E1418: 93DD0008  stw r30, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 828E141C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 828E1420: 93DD000C  stw r30, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 828E1424: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 828E1428: 38E99160  addi r7, r9, -0x6ea0
	ctx.r[7].s64 = ctx.r[9].s64 + -28320;
	// 828E142C: C1A6D5C8  lfs f13, -0x2a38(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E1430: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828E1434: C003BEC8  lfs f0, -0x4138(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-16696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E1438: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E143C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E1678 size=464
    let mut pc: u32 = 0x828E1678;
    'dispatch: loop {
        match pc {
            0x828E1678 => {
    //   block [0x828E1678..0x828E1848)
	// 828E1678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E167C: 483C7D91  bl 0x82ca940c
	ctx.lr = 0x828E1680;
	sub_82CA93D0(ctx, base);
	// 828E1680: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E1684: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828E1688: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E168C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1690: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828E1694: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E169C: 419A0034  beq cr6, 0x828e16d0
	if ctx.cr[6].eq {
	pc = 0x828E16D0; continue 'dispatch;
	}
	// 828E16A0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E16A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E16A8: 419A0084  beq cr6, 0x828e172c
	if ctx.cr[6].eq {
	pc = 0x828E172C; continue 'dispatch;
	}
	// 828E16AC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828E16B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E16B4: 419A001C  beq cr6, 0x828e16d0
	if ctx.cr[6].eq {
	pc = 0x828E16D0; continue 'dispatch;
	}
	// 828E16B8: 4B892781  bl 0x82173e38
	ctx.lr = 0x828E16BC;
	sub_82173E38(ctx, base);
	// 828E16BC: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E16C0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E16C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E16C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E16CC: 409A0008  bne cr6, 0x828e16d4
	if !ctx.cr[6].eq {
	pc = 0x828E16D4; continue 'dispatch;
	}
	// 828E16D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E16D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E16D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E16DC: 419A0164  beq cr6, 0x828e1840
	if ctx.cr[6].eq {
	pc = 0x828E1840; continue 'dispatch;
	}
	// 828E16E0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E16E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E16E8: 40990158  ble cr6, 0x828e1840
	if !ctx.cr[6].gt {
	pc = 0x828E1840; continue 'dispatch;
	}
	// 828E16EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E16F0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E16F4: 4B892745  bl 0x82173e38
	ctx.lr = 0x828E16F8;
	sub_82173E38(ctx, base);
	// 828E16F8: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E16FC: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 828E1700: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E1704: 419A00E4  beq cr6, 0x828e17e8
	if ctx.cr[6].eq {
	pc = 0x828E17E8; continue 'dispatch;
	}
	// 828E1708: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E170C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E1710: 419A0028  beq cr6, 0x828e1738
	if ctx.cr[6].eq {
	pc = 0x828E1738; continue 'dispatch;
	}
	// 828E1714: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 828E1718: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E171C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E1720: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E1724: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1728: 480000C0  b 0x828e17e8
	pc = 0x828E17E8; continue 'dispatch;
	// 828E172C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1730: 4B8B2709  bl 0x82193e38
	ctx.lr = 0x828E1734;
	sub_82193E38(ctx, base);
	// 828E1734: 4BFFFF9C  b 0x828e16d0
	pc = 0x828E16D0; continue 'dispatch;
	// 828E1738: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E173C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E1740: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E1744: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E1748: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E174C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E1750: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E1754: 40810054  ble 0x828e17a8
	if !ctx.cr[0].gt {
	pc = 0x828E17A8; continue 'dispatch;
	}
	// 828E1758: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E175C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E1760: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E1764: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1768: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 828E176C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E1770: 41980008  blt cr6, 0x828e1778
	if ctx.cr[6].lt {
	pc = 0x828E1778; continue 'dispatch;
	}
	// 828E1774: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828E1778: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E177C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E1780: 419A0014  beq cr6, 0x828e1794
	if ctx.cr[6].eq {
	pc = 0x828E1794; continue 'dispatch;
	}
	// 828E1784: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E1788: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E178C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E1790: 4800000C  b 0x828e179c
	pc = 0x828E179C; continue 'dispatch;
	// 828E1794: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E1798: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E179C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E17A0: 4199FFB8  bgt cr6, 0x828e1758
	if ctx.cr[6].gt {
	pc = 0x828E1758; continue 'dispatch;
	}
	// 828E17A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E17A8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E17AC: 419A0034  beq cr6, 0x828e17e0
	if ctx.cr[6].eq {
	pc = 0x828E17E0; continue 'dispatch;
	}
	// 828E17B0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E17B4: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 828E17B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E17BC: 41990008  bgt cr6, 0x828e17c4
	if ctx.cr[6].gt {
	pc = 0x828E17C4; continue 'dispatch;
	}
	// 828E17C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E17C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E17C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E17CC: 409A0014  bne cr6, 0x828e17e0
	if !ctx.cr[6].eq {
	pc = 0x828E17E0; continue 'dispatch;
	}
	// 828E17D0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E17D4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E17D8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E17DC: 48000008  b 0x828e17e4
	pc = 0x828E17E4; continue 'dispatch;
	// 828E17E0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E17E4: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E17E8: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 828E17EC: 4B93DA6D  bl 0x8221f258
	ctx.lr = 0x828E17F0;
	sub_8221F258(ctx, base);
	// 828E17F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E17F4: 419A0024  beq cr6, 0x828e1818
	if ctx.cr[6].eq {
	pc = 0x828E1818; continue 'dispatch;
	}
	// 828E17F8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828E17FC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E1800: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828E1804: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E1808: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E180C: 4B9A2425  bl 0x82283c30
	ctx.lr = 0x828E1810;
	sub_82283C30(ctx, base);
	// 828E1810: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E1814: 48000008  b 0x828e181c
	pc = 0x828E181C; continue 'dispatch;
	// 828E1818: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E181C: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E1820: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E1824: 419A0018  beq cr6, 0x828e183c
	if ctx.cr[6].eq {
	pc = 0x828E183C; continue 'dispatch;
	}
	// 828E1828: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E182C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E1830: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1834: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828E1838: 4E800421  bctrl
	ctx.lr = 0x828E183C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E183C: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828E1840: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E1844: 483C7C18  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E1848 size=188
    let mut pc: u32 = 0x828E1848;
    'dispatch: loop {
        match pc {
            0x828E1848 => {
    //   block [0x828E1848..0x828E1904)
	// 828E1848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E184C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E1850: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E1854: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 828E1858: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828E185C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E1860: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E1864: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 828E1868: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E186C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1870: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828E1874: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828E1878: 4E800421  bctrl
	ctx.lr = 0x828E187C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E187C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 828E1880: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828E1884: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E1888: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828E188C: C3E99484  lfs f31, -0x6b7c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E1890: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E1894: 4B913505  bl 0x821f4d98
	ctx.lr = 0x828E1898;
	sub_821F4D98(ctx, base);
	// 828E1898: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 828E189C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828E18A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E18A4: C0289A80  lfs f1, -0x6580(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E18A8: 4B95A0F9  bl 0x8223b9a0
	ctx.lr = 0x828E18AC;
	sub_8223B9A0(ctx, base);
	// 828E18AC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828E18B0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E18B4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828E18B8: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828E18BC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E18C0: E8C70000  ld r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 828E18C4: E8A70008  ld r5, 8(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 828E18C8: F8DF0020  std r6, 0x20(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[6].u64 ) };
	// 828E18CC: F8BF0028  std r5, 0x28(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[5].u64 ) };
	// 828E18D0: 4B9134C9  bl 0x821f4d98
	ctx.lr = 0x828E18D4;
	sub_821F4D98(ctx, base);
	// 828E18D4: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 828E18D8: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E18DC: D3DF0030  stfs f30, 0x30(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E1908 size=544
    let mut pc: u32 = 0x828E1908;
    'dispatch: loop {
        match pc {
            0x828E1908 => {
    //   block [0x828E1908..0x828E1B28)
	// 828E1908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E190C: 483C7AE1  bl 0x82ca93ec
	ctx.lr = 0x828E1910;
	sub_82CA93D0(ctx, base);
	// 828E1910: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 828E1914: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E1918: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828E191C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828E1920: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 828E1924: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828E1928: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E192C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E1930: 817A000C  lwz r11, 0xc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E1934: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 828E1938: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E193C: 4B91E9A5  bl 0x822002e0
	ctx.lr = 0x828E1940;
	sub_822002E0(ctx, base);
	// 828E1940: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E1944: 82E10050  lwz r23, 0x50(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E1948: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E194C: 419A00C8  beq cr6, 0x828e1a14
	if ctx.cr[6].eq {
	pc = 0x828E1A14; continue 'dispatch;
	}
	// 828E1950: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 828E1954: 38970024  addi r4, r23, 0x24
	ctx.r[4].s64 = ctx.r[23].s64 + 36;
	// 828E1958: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 828E195C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E1960: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 828E1964: 4B90E98D  bl 0x821f02f0
	ctx.lr = 0x828E1968;
	sub_821F02F0(ctx, base);
	// 828E1968: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 828E196C: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 828E1970: 83210064  lwz r25, 0x64(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E1974: 83010068  lwz r24, 0x68(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828E1978: 7D59C050  subf r10, r25, r24
	ctx.r[10].s64 = ctx.r[24].s64 - ctx.r[25].s64;
	// 828E197C: 7FAA5BD7  divw. r29, r10, r11
	ctx.r[29].s32 = ctx.r[10].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828E1980: 41820074  beq 0x828e19f4
	if ctx.cr[0].eq {
	pc = 0x828E19F4; continue 'dispatch;
	}
	// 828E1984: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E1988: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 828E198C: 3B8BFFDF  addi r28, r11, -0x21
	ctx.r[28].s64 = ctx.r[11].s64 + -33;
	// 828E1990: C3FF0000  lfs f31, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E1994: C01A0030  lfs f0, 0x30(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E1998: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828E199C: 40990048  ble cr6, 0x828e19e4
	if !ctx.cr[6].gt {
	pc = 0x828E19E4; continue 'dispatch;
	}
	// 828E19A0: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E19A4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828E19A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E19AC: 419A000C  beq cr6, 0x828e19b8
	if ctx.cr[6].eq {
	pc = 0x828E19B8; continue 'dispatch;
	}
	// 828E19B0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E19B4: 409A000C  bne cr6, 0x828e19c0
	if !ctx.cr[6].eq {
	pc = 0x828E19C0; continue 'dispatch;
	}
	// 828E19B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E19BC: 48000008  b 0x828e19c4
	pc = 0x828E19C4; continue 'dispatch;
	// 828E19C0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E19C4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E19C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828E19CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E19D0: 419A0008  beq cr6, 0x828e19d8
	if ctx.cr[6].eq {
	pc = 0x828E19D8; continue 'dispatch;
	}
	// 828E19D4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E19D8: 483C8719  bl 0x82caa0f0
	ctx.lr = 0x828E19DC;
	sub_82CAA0F0(ctx, base);
	// 828E19DC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 828E19E0: 419A008C  beq cr6, 0x828e1a6c
	if ctx.cr[6].eq {
	pc = 0x828E1A6C; continue 'dispatch;
	}
	// 828E19E4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828E19E8: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 828E19EC: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828E19F0: 4198FFA0  blt cr6, 0x828e1990
	if ctx.cr[6].lt {
	pc = 0x828E1990; continue 'dispatch;
	}
	// 828E19F4: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 828E19F8: 419A001C  beq cr6, 0x828e1a14
	if ctx.cr[6].eq {
	pc = 0x828E1A14; continue 'dispatch;
	}
	// 828E19FC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828E1A00: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828E1A04: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828E1A08: 4BC85009  bl 0x82566a10
	ctx.lr = 0x828E1A0C;
	sub_82566A10(ctx, base);
	// 828E1A0C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828E1A10: 4B93A329  bl 0x8221bd38
	ctx.lr = 0x828E1A14;
	sub_8221BD38(ctx, base);
	// 828E1A14: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 828E1A18: 419A0044  beq cr6, 0x828e1a5c
	if ctx.cr[6].eq {
	pc = 0x828E1A5C; continue 'dispatch;
	}
	// 828E1A1C: 39770004  addi r11, r23, 4
	ctx.r[11].s64 = ctx.r[23].s64 + 4;
	// 828E1A20: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E1A24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E1A28: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E1A2C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828E1A30: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E1A34: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E1A38: 4082FFE8  bne 0x828e1a20
	if !ctx.cr[0].eq {
	pc = 0x828E1A20; continue 'dispatch;
	}
	// 828E1A3C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828E1A40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E1A44: 409A0018  bne cr6, 0x828e1a5c
	if !ctx.cr[6].eq {
	pc = 0x828E1A5C; continue 'dispatch;
	}
	// 828E1A48: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1A4C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828E1A50: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1A54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828E1A58: 4E800421  bctrl
	ctx.lr = 0x828E1A5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E1A5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E1A60: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828E1A64: CBE1FF98  lfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 828E1A68: 483C79D4  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
	// 828E1A6C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828E1A70: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E1A74: 4BFFFDD5  bl 0x828e1848
	ctx.lr = 0x828E1A78;
	sub_828E1848(ctx, base);
	// 828E1A78: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E1A7C: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 828E1A80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E1A84: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828E1A88: 419A0008  beq cr6, 0x828e1a90
	if ctx.cr[6].eq {
	pc = 0x828E1A90; continue 'dispatch;
	}
	// 828E1A8C: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1A90: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1A94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E1A98: 409A000C  bne cr6, 0x828e1aa4
	if !ctx.cr[6].eq {
	pc = 0x828E1AA4; continue 'dispatch;
	}
	// 828E1A9C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828E1AA0: 48000008  b 0x828e1aa8
	pc = 0x828E1AA8; continue 'dispatch;
	// 828E1AA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1AA8: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 828E1AAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E1AB0: 4B9022E1  bl 0x821e3d90
	ctx.lr = 0x828E1AB4;
	sub_821E3D90(ctx, base);
	// 828E1AB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E1AB8: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 828E1ABC: 4B9836E5  bl 0x822651a0
	ctx.lr = 0x828E1AC0;
	sub_822651A0(ctx, base);
	// 828E1AC0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E1AC4: 4B933315  bl 0x82214dd8
	ctx.lr = 0x828E1AC8;
	sub_82214DD8(ctx, base);
	// 828E1AC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E1ACC: 4810DC0D  bl 0x829ef6d8
	ctx.lr = 0x828E1AD0;
	sub_829EF6D8(ctx, base);
	// 828E1AD0: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 828E1AD4: 419A0044  beq cr6, 0x828e1b18
	if ctx.cr[6].eq {
	pc = 0x828E1B18; continue 'dispatch;
	}
	// 828E1AD8: 39770004  addi r11, r23, 4
	ctx.r[11].s64 = ctx.r[23].s64 + 4;
	// 828E1ADC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E1AE0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E1AE4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E1AE8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828E1AEC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E1AF0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E1AF4: 4082FFE8  bne 0x828e1adc
	if !ctx.cr[0].eq {
	pc = 0x828E1ADC; continue 'dispatch;
	}
	// 828E1AF8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828E1AFC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E1B00: 409A0018  bne cr6, 0x828e1b18
	if !ctx.cr[6].eq {
	pc = 0x828E1B18; continue 'dispatch;
	}
	// 828E1B04: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1B08: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828E1B0C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1B10: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828E1B14: 4E800421  bctrl
	ctx.lr = 0x828E1B18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E1B18: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828E1B1C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828E1B20: CBE1FF98  lfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 828E1B24: 483C7918  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E1B28 size=1188
    let mut pc: u32 = 0x828E1B28;
    'dispatch: loop {
        match pc {
            0x828E1B28 => {
    //   block [0x828E1B28..0x828E1FCC)
	// 828E1B28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E1B2C: 483C78CD  bl 0x82ca93f8
	ctx.lr = 0x828E1B30;
	sub_82CA93D0(ctx, base);
	// 828E1B30: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E1B34: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E1B38: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828E1B3C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 828E1B40: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E1B44: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1B48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E1B4C: 419A0034  beq cr6, 0x828e1b80
	if ctx.cr[6].eq {
	pc = 0x828E1B80; continue 'dispatch;
	}
	// 828E1B50: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1B54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E1B58: 419A0084  beq cr6, 0x828e1bdc
	if ctx.cr[6].eq {
	pc = 0x828E1BDC; continue 'dispatch;
	}
	// 828E1B5C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828E1B60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E1B64: 419A001C  beq cr6, 0x828e1b80
	if ctx.cr[6].eq {
	pc = 0x828E1B80; continue 'dispatch;
	}
	// 828E1B68: 4B8922D1  bl 0x82173e38
	ctx.lr = 0x828E1B6C;
	sub_82173E38(ctx, base);
	// 828E1B6C: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E1B70: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E1B74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E1B78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E1B7C: 409A0008  bne cr6, 0x828e1b84
	if !ctx.cr[6].eq {
	pc = 0x828E1B84; continue 'dispatch;
	}
	// 828E1B80: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828E1B84: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E1B88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E1B8C: 419A0434  beq cr6, 0x828e1fc0
	if ctx.cr[6].eq {
	pc = 0x828E1FC0; continue 'dispatch;
	}
	// 828E1B90: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E1B94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E1B98: 419A0428  beq cr6, 0x828e1fc0
	if ctx.cr[6].eq {
	pc = 0x828E1FC0; continue 'dispatch;
	}
	// 828E1B9C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828E1BA0: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 828E1BA4: 4B892295  bl 0x82173e38
	ctx.lr = 0x828E1BA8;
	sub_82173E38(ctx, base);
	// 828E1BA8: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E1BAC: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828E1BB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E1BB4: 419A00E4  beq cr6, 0x828e1c98
	if ctx.cr[6].eq {
	pc = 0x828E1C98; continue 'dispatch;
	}
	// 828E1BB8: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E1BBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E1BC0: 419A0028  beq cr6, 0x828e1be8
	if ctx.cr[6].eq {
	pc = 0x828E1BE8; continue 'dispatch;
	}
	// 828E1BC4: 894B0003  lbz r10, 3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 828E1BC8: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E1BCC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E1BD0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E1BD4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1BD8: 480000BC  b 0x828e1c94
	pc = 0x828E1C94; continue 'dispatch;
	// 828E1BDC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828E1BE0: 4B8B2259  bl 0x82193e38
	ctx.lr = 0x828E1BE4;
	sub_82193E38(ctx, base);
	// 828E1BE4: 4BFFFF9C  b 0x828e1b80
	pc = 0x828E1B80; continue 'dispatch;
	// 828E1BE8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E1BEC: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E1BF0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828E1BF4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E1BF8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E1BFC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E1C00: 40810054  ble 0x828e1c54
	if !ctx.cr[0].gt {
	pc = 0x828E1C54; continue 'dispatch;
	}
	// 828E1C04: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E1C08: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E1C0C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E1C10: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1C14: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828E1C18: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E1C1C: 41980008  blt cr6, 0x828e1c24
	if ctx.cr[6].lt {
	pc = 0x828E1C24; continue 'dispatch;
	}
	// 828E1C20: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828E1C24: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E1C28: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E1C2C: 419A0014  beq cr6, 0x828e1c40
	if ctx.cr[6].eq {
	pc = 0x828E1C40; continue 'dispatch;
	}
	// 828E1C30: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E1C34: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E1C38: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E1C3C: 4800000C  b 0x828e1c48
	pc = 0x828E1C48; continue 'dispatch;
	// 828E1C40: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E1C44: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E1C48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E1C4C: 4199FFB8  bgt cr6, 0x828e1c04
	if ctx.cr[6].gt {
	pc = 0x828E1C04; continue 'dispatch;
	}
	// 828E1C50: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E1C54: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E1C58: 419A0034  beq cr6, 0x828e1c8c
	if ctx.cr[6].eq {
	pc = 0x828E1C8C; continue 'dispatch;
	}
	// 828E1C5C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1C60: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828E1C64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E1C68: 41990008  bgt cr6, 0x828e1c70
	if ctx.cr[6].gt {
	pc = 0x828E1C70; continue 'dispatch;
	}
	// 828E1C6C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828E1C70: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E1C74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E1C78: 409A0014  bne cr6, 0x828e1c8c
	if !ctx.cr[6].eq {
	pc = 0x828E1C8C; continue 'dispatch;
	}
	// 828E1C7C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E1C80: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828E1C84: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E1C88: 48000008  b 0x828e1c90
	pc = 0x828E1C90; continue 'dispatch;
	// 828E1C8C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E1C90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1C94: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828E1C98: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828E1C9C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 828E1CA0: 4B892199  bl 0x82173e38
	ctx.lr = 0x828E1CA4;
	sub_82173E38(ctx, base);
	// 828E1CA4: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E1CA8: 556AD7FE  rlwinm r10, r11, 0x1a, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 828E1CAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E1CB0: 419A00D8  beq cr6, 0x828e1d88
	if ctx.cr[6].eq {
	pc = 0x828E1D88; continue 'dispatch;
	}
	// 828E1CB4: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E1CB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E1CBC: 419A001C  beq cr6, 0x828e1cd8
	if ctx.cr[6].eq {
	pc = 0x828E1CD8; continue 'dispatch;
	}
	// 828E1CC0: 894B0006  lbz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 828E1CC4: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E1CC8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E1CCC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E1CD0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1CD4: 480000B0  b 0x828e1d84
	pc = 0x828E1D84; continue 'dispatch;
	// 828E1CD8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E1CDC: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E1CE0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828E1CE4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E1CE8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E1CEC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E1CF0: 40810054  ble 0x828e1d44
	if !ctx.cr[0].gt {
	pc = 0x828E1D44; continue 'dispatch;
	}
	// 828E1CF4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E1CF8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E1CFC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E1D00: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1D04: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 828E1D08: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E1D0C: 41980008  blt cr6, 0x828e1d14
	if ctx.cr[6].lt {
	pc = 0x828E1D14; continue 'dispatch;
	}
	// 828E1D10: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828E1D14: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E1D18: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E1D1C: 419A0014  beq cr6, 0x828e1d30
	if ctx.cr[6].eq {
	pc = 0x828E1D30; continue 'dispatch;
	}
	// 828E1D20: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E1D24: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E1D28: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E1D2C: 4800000C  b 0x828e1d38
	pc = 0x828E1D38; continue 'dispatch;
	// 828E1D30: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E1D34: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E1D38: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E1D3C: 4199FFB8  bgt cr6, 0x828e1cf4
	if ctx.cr[6].gt {
	pc = 0x828E1CF4; continue 'dispatch;
	}
	// 828E1D40: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E1D44: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E1D48: 419A0034  beq cr6, 0x828e1d7c
	if ctx.cr[6].eq {
	pc = 0x828E1D7C; continue 'dispatch;
	}
	// 828E1D4C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1D50: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 828E1D54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E1D58: 41990008  bgt cr6, 0x828e1d60
	if ctx.cr[6].gt {
	pc = 0x828E1D60; continue 'dispatch;
	}
	// 828E1D5C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828E1D60: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E1D64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E1D68: 409A0014  bne cr6, 0x828e1d7c
	if !ctx.cr[6].eq {
	pc = 0x828E1D7C; continue 'dispatch;
	}
	// 828E1D6C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E1D70: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828E1D74: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E1D78: 48000008  b 0x828e1d80
	pc = 0x828E1D80; continue 'dispatch;
	// 828E1D7C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E1D80: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1D84: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828E1D88: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828E1D8C: 809C0008  lwz r4, 8(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E1D90: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E1D94: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828E1D98: 394B92D4  addi r10, r11, -0x6d2c
	ctx.r[10].s64 = ctx.r[11].s64 + -27948;
	// 828E1D9C: C00B92D4  lfs f0, -0x6d2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E1DA0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828E1DA4: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E1DA8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828E1DAC: 833E0098  lwz r25, 0x98(r30)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 828E1DB0: 831E0094  lwz r24, 0x94(r30)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 828E1DB4: 4B97DDAD  bl 0x8225fb60
	ctx.lr = 0x828E1DB8;
	sub_8225FB60(ctx, base);
	// 828E1DB8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E1DBC: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 828E1DC0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1DC4: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 828E1DC8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E1DCC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828E1DD0: 482914A1  bl 0x82b73270
	ctx.lr = 0x828E1DD4;
	sub_82B73270(ctx, base);
	// 828E1DD4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E1DD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E1DDC: 419A0048  beq cr6, 0x828e1e24
	if ctx.cr[6].eq {
	pc = 0x828E1E24; continue 'dispatch;
	}
	// 828E1DE0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E1DE4: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 828E1DE8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E1DEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E1DF0: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E1DF4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828E1DF8: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E1DFC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E1E00: 4082FFE8  bne 0x828e1de8
	if !ctx.cr[0].eq {
	pc = 0x828E1DE8; continue 'dispatch;
	}
	// 828E1E04: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828E1E08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E1E0C: 409A0014  bne cr6, 0x828e1e20
	if !ctx.cr[6].eq {
	pc = 0x828E1E20; continue 'dispatch;
	}
	// 828E1E10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1E14: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1E18: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828E1E1C: 4E800421  bctrl
	ctx.lr = 0x828E1E20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E1E20: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828E1E24: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828E1E28: 4B892011  bl 0x82173e38
	ctx.lr = 0x828E1E2C;
	sub_82173E38(ctx, base);
	// 828E1E2C: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E1E30: 556A7FFE  rlwinm r10, r11, 0xf, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0001FFFFu64;
	// 828E1E34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E1E38: 419A00F4  beq cr6, 0x828e1f2c
	if ctx.cr[6].eq {
	pc = 0x828E1F2C; continue 'dispatch;
	}
	// 828E1E3C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E1E40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E1E44: 419A0024  beq cr6, 0x828e1e68
	if ctx.cr[6].eq {
	pc = 0x828E1E68; continue 'dispatch;
	}
	// 828E1E48: 894B0011  lbz r10, 0x11(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 828E1E4C: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E1E50: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E1E54: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E1E58: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1E5C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E1E60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E1E64: 480000CC  b 0x828e1f30
	pc = 0x828E1F30; continue 'dispatch;
	// 828E1E68: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E1E6C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E1E70: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828E1E74: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E1E78: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828E1E7C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E1E80: 40810054  ble 0x828e1ed4
	if !ctx.cr[0].gt {
	pc = 0x828E1ED4; continue 'dispatch;
	}
	// 828E1E84: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E1E88: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E1E8C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E1E90: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1E94: 2F070011  cmpwi cr6, r7, 0x11
	ctx.cr[6].compare_i32(ctx.r[7].s32, 17, &mut ctx.xer);
	// 828E1E98: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E1E9C: 41980008  blt cr6, 0x828e1ea4
	if ctx.cr[6].lt {
	pc = 0x828E1EA4; continue 'dispatch;
	}
	// 828E1EA0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828E1EA4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E1EA8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E1EAC: 419A0014  beq cr6, 0x828e1ec0
	if ctx.cr[6].eq {
	pc = 0x828E1EC0; continue 'dispatch;
	}
	// 828E1EB0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E1EB4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E1EB8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E1EBC: 4800000C  b 0x828e1ec8
	pc = 0x828E1EC8; continue 'dispatch;
	// 828E1EC0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E1EC4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E1EC8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E1ECC: 4199FFB8  bgt cr6, 0x828e1e84
	if ctx.cr[6].gt {
	pc = 0x828E1E84; continue 'dispatch;
	}
	// 828E1ED0: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828E1ED4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E1ED8: 419A0040  beq cr6, 0x828e1f18
	if ctx.cr[6].eq {
	pc = 0x828E1F18; continue 'dispatch;
	}
	// 828E1EDC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1EE0: 2F0B0011  cmpwi cr6, r11, 0x11
	ctx.cr[6].compare_i32(ctx.r[11].s32, 17, &mut ctx.xer);
	// 828E1EE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E1EE8: 41990008  bgt cr6, 0x828e1ef0
	if ctx.cr[6].gt {
	pc = 0x828E1EF0; continue 'dispatch;
	}
	// 828E1EEC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828E1EF0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E1EF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E1EF8: 409A0020  bne cr6, 0x828e1f18
	if !ctx.cr[6].eq {
	pc = 0x828E1F18; continue 'dispatch;
	}
	// 828E1EFC: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828E1F00: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828E1F04: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E1F08: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1F0C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E1F10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E1F14: 4800001C  b 0x828e1f30
	pc = 0x828E1F30; continue 'dispatch;
	// 828E1F18: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E1F1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1F20: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E1F24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E1F28: 48000008  b 0x828e1f30
	pc = 0x828E1F30; continue 'dispatch;
	// 828E1F2C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828E1F30: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E1F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E1F38: 419A0058  beq cr6, 0x828e1f90
	if ctx.cr[6].eq {
	pc = 0x828E1F90; continue 'dispatch;
	}
	// 828E1F3C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828E1F40: C03D006C  lfs f1, 0x6c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E1F44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E1F48: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828E1F4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E1F50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1F54: 4B959F05  bl 0x8223be58
	ctx.lr = 0x828E1F58;
	sub_8223BE58(ctx, base);
	// 828E1F58: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E1F5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E1F60: 419A0030  beq cr6, 0x828e1f90
	if ctx.cr[6].eq {
	pc = 0x828E1F90; continue 'dispatch;
	}
	// 828E1F64: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 828E1F68: E89C0020  ld r4, 0x20(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) };
	// 828E1F6C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E1F70: E8BC0028  ld r5, 0x28(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828E1FD0 size=120
    let mut pc: u32 = 0x828E1FD0;
    'dispatch: loop {
        match pc {
            0x828E1FD0 => {
    //   block [0x828E1FD0..0x828E2048)
	// 828E1FD0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828E1FD4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1FD8: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 828E1FDC: ECE10072  fmuls f7, f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[7].f64 = (((ctx.f[1].f64 * ctx.f[1].f64) as f32) as f64);
	// 828E1FE0: 396B94CC  addi r11, r11, -0x6b34
	ctx.r[11].s64 = ctx.r[11].s64 + -27444;
	// 828E1FE4: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 828E1FE8: C9A99660  lfd f13, -0x69a0(r9)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(-27040 as u32) ) };
	// 828E1FEC: 810B6C54  lwz r8, 0x6c54(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27732 as u32) ) } as u64;
	// 828E1FF0: C16BFFB8  lfs f11, -0x48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-72 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828E1FF4: 80EB6C58  lwz r7, 0x6c58(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27736 as u32) ) } as u64;
	// 828E1FF8: C0CBFFC4  lfs f6, -0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-60 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 828E1FFC: C0AB40FC  lfs f5, 0x40fc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16636 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 828E2000: 9101FFF0  stw r8, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[8].u32 ) };
	// 828E2004: 90E1FFF4  stw r7, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[7].u32 ) };
	// 828E2008: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E200C: FC006824  fdiv f0, f0, f13
	ctx.f[0].f64 = ctx.f[0].f64 / ctx.f[13].f64;
	// 828E2010: FDA00072  fmul f13, f0, f1
	ctx.f[13].f64 = ctx.f[0].f64 * ctx.f[1].f64;
	// 828E2014: FC806818  frsp f4, f13
	ctx.f[4].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828E2018: 419800D4  blt cr6, 0x828e20ec
	if ctx.cr[6].lt {
		sub_828E20EC(ctx, base);
		return;
	}
	// 828E201C: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 828E2020: 409A00F8  bne cr6, 0x828e2118
	if !ctx.cr[6].eq {
		sub_828E20EC(ctx, base);
		return;
	}
	// 828E2024: C1030014  lfs f8, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828E2028: FDA05890  fmr f13, f11
	ctx.f[13].f64 = ctx.f[11].f64;
	// 828E202C: FF085800  fcmpu cr6, f8, f11
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[11].f64);
	// 828E2030: 4099009C  ble cr6, 0x828e20cc
	if !ctx.cr[6].gt {
		sub_828E20B4(ctx, base);
		return;
	}
	// 828E2034: C1230008  lfs f9, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828E2038: FF095800  fcmpu cr6, f9, f11
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[11].f64);
	// 828E203C: 4099000C  ble cr6, 0x828e2048
	if !ctx.cr[6].gt {
		sub_828E2048(ctx, base);
		return;
	}
	// 828E2040: FD403090  fmr f10, f6
	ctx.f[10].f64 = ctx.f[6].f64;
	// 828E2044: 48000008  b 0x828e204c
	sub_828E2048(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828E2048 size=44
    let mut pc: u32 = 0x828E2048;
    'dispatch: loop {
        match pc {
            0x828E2048 => {
    //   block [0x828E2048..0x828E2074)
	// 828E2048: FD402890  fmr f10, f5
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = ctx.f[5].f64;
	// 828E204C: 89430020  lbz r10, 0x20(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 828E2050: C0030010  lfs f0, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E2054: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E2058: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E205C: 409A0018  bne cr6, 0x828e2074
	if !ctx.cr[6].eq {
		sub_828E2074(ctx, base);
		return;
	}
	// 828E2060: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828E2064: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 828E2068: 4099004C  ble cr6, 0x828e20b4
	if !ctx.cr[6].gt {
		sub_828E20B4(ctx, base);
		return;
	}
	// 828E206C: FC003090  fmr f0, f6
	ctx.f[0].f64 = ctx.f[6].f64;
	// 828E2070: 48000048  b 0x828e20b8
	sub_828E20B4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2074(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828E2074 size=64
    let mut pc: u32 = 0x828E2074;
    'dispatch: loop {
        match pc {
            0x828E2074 => {
    //   block [0x828E2074..0x828E20B4)
	// 828E2074: EC006828  fsubs f0, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828E2078: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828E207C: C18A9044  lfs f12, -0x6fbc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28604 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828E2080: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 828E2084: 40980008  bge cr6, 0x828e208c
	if !ctx.cr[6].lt {
	pc = 0x828E208C; continue 'dispatch;
	}
	// 828E2088: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 828E208C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828E2090: C1AA9040  lfs f13, -0x6fc0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28608 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E2094: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828E2098: 40990008  ble cr6, 0x828e20a0
	if !ctx.cr[6].gt {
	pc = 0x828E20A0; continue 'dispatch;
	}
	// 828E209C: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 828E20A0: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 828E20A4: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 828E20A8: 4099000C  ble cr6, 0x828e20b4
	if !ctx.cr[6].gt {
		sub_828E20B4(ctx, base);
		return;
	}
	// 828E20AC: FC003090  fmr f0, f6
	ctx.f[0].f64 = ctx.f[6].f64;
	// 828E20B0: 48000008  b 0x828e20b8
	sub_828E20B4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E20B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828E20B4 size=56
    let mut pc: u32 = 0x828E20B4;
    'dispatch: loop {
        match pc {
            0x828E20B4 => {
    //   block [0x828E20B4..0x828E20EC)
	// 828E20B4: FC002890  fmr f0, f5
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[5].f64;
	// 828E20B8: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 828E20BC: 419A0010  beq cr6, 0x828e20cc
	if ctx.cr[6].eq {
	pc = 0x828E20CC; continue 'dispatch;
	}
	// 828E20C0: EC090232  fmuls f0, f9, f8
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[8].f64) as f32) as f64);
	// 828E20C4: ED8049FC  fnmsubs f12, f0, f7, f9
	ctx.f[12].f64 = -(((ctx.f[0].f64 * ctx.f[7].f64 - ctx.f[9].f64) as f32) as f64);
	// 828E20C8: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828E20CC: C003001C  lfs f0, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E20D0: ED800824  fdivs f12, f0, f1
	ctx.f[12].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 828E20D4: C1430008  lfs f10, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828E20D8: ED2C0372  fmuls f9, f12, f13
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 828E20DC: D123000C  stfs f9, 0xc(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828E20E0: ED09513A  fmadds f8, f9, f4, f10
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[4].f64 + ctx.f[10].f64) as f32) as f64);
	// 828E20E4: D1030008  stfs f8, 8(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828E20E8: 48000030  b 0x828e2118
	sub_828E20EC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E20EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828E20EC size=112
    let mut pc: u32 = 0x828E20EC;
    'dispatch: loop {
        match pc {
            0x828E20EC => {
    //   block [0x828E20EC..0x828E215C)
	// 828E20EC: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 828E20F0: 409A0018  bne cr6, 0x828e2108
	if !ctx.cr[6].eq {
	pc = 0x828E2108; continue 'dispatch;
	}
	// 828E20F4: C0030008  lfs f0, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E20F8: C1A30014  lfs f13, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E20FC: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828E2100: ED4C01FC  fnmsubs f10, f12, f7, f0
	ctx.f[10].f64 = -(((ctx.f[12].f64 * ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 828E2104: D1430008  stfs f10, 8(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828E2108: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E210C: C1A3000C  lfs f13, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E2110: ED8D013A  fmadds f12, f13, f4, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[4].f64 + ctx.f[0].f64) as f32) as f64);
	// 828E2114: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828E2118: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E211C: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 828E2120: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E2124: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828E2128: 4199000C  bgt cr6, 0x828e2134
	if ctx.cr[6].gt {
	pc = 0x828E2134; continue 'dispatch;
	}
	// 828E212C: D1630008  stfs f11, 8(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828E2130: FC005890  fmr f0, f11
	ctx.f[0].f64 = ctx.f[11].f64;
	// 828E2134: C1A30018  lfs f13, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E2138: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 828E213C: 4198002C  blt cr6, 0x828e2168
	if ctx.cr[6].lt {
		sub_828E215C(ctx, base);
		return;
	}
	// 828E2140: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828E2144: 40990024  ble cr6, 0x828e2168
	if !ctx.cr[6].gt {
		sub_828E215C(ctx, base);
		return;
	}
	// 828E2148: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E214C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 828E2150: 4099000C  ble cr6, 0x828e215c
	if !ctx.cr[6].gt {
		sub_828E215C(ctx, base);
		return;
	}
	// 828E2154: FC003090  fmr f0, f6
	ctx.f[0].f64 = ctx.f[6].f64;
	// 828E2158: 48000008  b 0x828e2160
	sub_828E215C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E215C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828E215C size=32
    let mut pc: u32 = 0x828E215C;
    'dispatch: loop {
        match pc {
            0x828E215C => {
    //   block [0x828E215C..0x828E217C)
	// 828E215C: FC002890  fmr f0, f5
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[5].f64;
	// 828E2160: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828E2164: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828E2168: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E216C: C1A30008  lfs f13, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E2170: ED84037A  fmadds f12, f4, f13, f0
	ctx.f[12].f64 = (((ctx.f[4].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 828E2174: D1830004  stfs f12, 4(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828E2178: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828E2180 size=192
    let mut pc: u32 = 0x828E2180;
    'dispatch: loop {
        match pc {
            0x828E2180 => {
    //   block [0x828E2180..0x828E2240)
	// 828E2180: 89630020  lbz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 828E2184: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E2188: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E218C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2190: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828E2194: 419A00AC  beq cr6, 0x828e2240
	if ctx.cr[6].eq {
		sub_828E2240(ctx, base);
		return;
	}
	// 828E2198: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828E219C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828E21A0: 396BB480  addi r11, r11, -0x4b80
	ctx.r[11].s64 = ctx.r[11].s64 + -19328;
	// 828E21A4: 54C9063E  clrlwi r9, r6, 0x18
	ctx.r[9].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 828E21A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E21AC: C16A9044  lfs f11, -0x6fbc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28604 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828E21B0: C18BE004  lfs f12, -0x1ffc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8188 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828E21B4: 419A0024  beq cr6, 0x828e21d8
	if ctx.cr[6].eq {
	pc = 0x828E21D8; continue 'dispatch;
	}
	// 828E21B8: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 828E21BC: 40980008  bge cr6, 0x828e21c4
	if !ctx.cr[6].lt {
	pc = 0x828E21C4; continue 'dispatch;
	}
	// 828E21C0: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 828E21C4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828E21C8: C1AA9040  lfs f13, -0x6fc0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28608 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E21CC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828E21D0: 40990008  ble cr6, 0x828e21d8
	if !ctx.cr[6].gt {
	pc = 0x828E21D8; continue 'dispatch;
	}
	// 828E21D4: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 828E21D8: FF026000  fcmpu cr6, f2, f12
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[12].f64);
	// 828E21DC: 419A0044  beq cr6, 0x828e2220
	if ctx.cr[6].eq {
	pc = 0x828E2220; continue 'dispatch;
	}
	// 828E21E0: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 828E21E4: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 828E21E8: 5549DF7A  rlwinm r9, r10, 0x1b, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828E21EC: C1ABE010  lfs f13, -0x1ff0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E21F0: 5548F77A  rlwinm r8, r10, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 828E21F4: C18B2148  lfs f12, 0x2148(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8520 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828E21F8: 3CE08210  lis r7, -0x7df0
	ctx.r[7].s64 = -2112880640;
	// 828E21FC: 7D264378  or r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 828E2200: 38A70E68  addi r5, r7, 0xe68
	ctx.r[5].s64 = ctx.r[7].s64 + 3688;
	// 828E2204: 7D45342E  lfsx f10, r5, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828E2208: FD2A636E  fsel f9, f10, f13, f12
	ctx.f[9].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[12].f64 };
	// 828E220C: FF024800  fcmpu cr6, f2, f9
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[9].f64);
	// 828E2210: 419A0010  beq cr6, 0x828e2220
	if ctx.cr[6].eq {
	pc = 0x828E2220; continue 'dispatch;
	}
	// 828E2214: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 828E2218: EDAB0028  fsubs f13, f11, f0
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 828E221C: EC0D00B2  fmuls f0, f13, f2
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[2].f64) as f32) as f64);
	// 828E2220: C1A30008  lfs f13, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E2224: ED810072  fmuls f12, f1, f1
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[1].f64) as f32) as f64);
	// 828E2228: ED6D007C  fnmsubs f11, f13, f1, f0
	ctx.f[11].f64 = -(((ctx.f[13].f64 * ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 828E222C: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E2230: ED4B0032  fmuls f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 828E2234: ED2A6024  fdivs f9, f10, f12
	ctx.f[9].f64 = ((ctx.f[10].f64 / ctx.f[12].f64) as f32) as f64;
	// 828E2238: D123000C  stfs f9, 0xc(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828E223C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828E2240 size=36
    let mut pc: u32 = 0x828E2240;
    'dispatch: loop {
        match pc {
            0x828E2240 => {
    //   block [0x828E2240..0x828E2264)
	// 828E2240: ED606828  fsubs f11, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828E2244: C1430008  lfs f10, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828E2248: C00BB480  lfs f0, -0x4b80(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E224C: ED810072  fmuls f12, f1, f1
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[1].f64) as f32) as f64);
	// 828E2250: ED2A587C  fnmsubs f9, f10, f1, f11
	ctx.f[9].f64 = -(((ctx.f[10].f64 * ctx.f[1].f64 - ctx.f[11].f64) as f32) as f64);
	// 828E2254: ED090032  fmuls f8, f9, f0
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 828E2258: ECE86024  fdivs f7, f8, f12
	ctx.f[7].f64 = ((ctx.f[8].f64 / ctx.f[12].f64) as f32) as f64;
	// 828E225C: D0E3000C  stfs f7, 0xc(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828E2260: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E2268 size=92
    let mut pc: u32 = 0x828E2268;
    'dispatch: loop {
        match pc {
            0x828E2268 => {
    //   block [0x828E2268..0x828E22C4)
	// 828E2268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E226C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E2270: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E2274: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E2278: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E227C: 3FC0820A  lis r30, -0x7df6
	ctx.r[30].s64 = -2113273856;
	// 828E2280: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E2284: 395E92CC  addi r10, r30, -0x6d34
	ctx.r[10].s64 = ctx.r[30].s64 + -27956;
	// 828E2288: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E228C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E2290: C00A21A0  lfs f0, 0x21a0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8608 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E2294: C1AA42FC  lfs f13, 0x42fc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E2298: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828E229C: D1BF0058  stfs f13, 0x58(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828E22A0: 48000029  bl 0x828e22c8
	ctx.lr = 0x828E22A4;
	sub_828E22C8(ctx, base);
	// 828E22A4: C01E92CC  lfs f0, -0x6d34(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27956 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E22A8: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828E22AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E22B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E22B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E22B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E22BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E22C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E22C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828E22C8 size=292
    let mut pc: u32 = 0x828E22C8;
    'dispatch: loop {
        match pc {
            0x828E22C8 => {
    //   block [0x828E22C8..0x828E23EC)
	// 828E22C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E22CC: 483C7135  bl 0x82ca9400
	ctx.lr = 0x828E22D0;
	sub_82CA93D0(ctx, base);
	// 828E22D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828E22D4: 3941FFA0  addi r10, r1, -0x60
	ctx.r[10].s64 = ctx.r[1].s64 + -96;
	// 828E22D8: 3921FFA4  addi r9, r1, -0x5c
	ctx.r[9].s64 = ctx.r[1].s64 + -92;
	// 828E22DC: 3901FFA8  addi r8, r1, -0x58
	ctx.r[8].s64 = ctx.r[1].s64 + -88;
	// 828E22E0: 38E1FFAC  addi r7, r1, -0x54
	ctx.r[7].s64 = ctx.r[1].s64 + -84;
	// 828E22E4: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E22E8: 3BA1FFC0  addi r29, r1, -0x40
	ctx.r[29].s64 = ctx.r[1].s64 + -64;
	// 828E22EC: D001FFA0  stfs f0, -0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), tmp.u32 ) };
	// 828E22F0: 3B81FFC4  addi r28, r1, -0x3c
	ctx.r[28].s64 = ctx.r[1].s64 + -60;
	// 828E22F4: D001FFA4  stfs f0, -0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-92 as u32), tmp.u32 ) };
	// 828E22F8: 38C1FFB0  addi r6, r1, -0x50
	ctx.r[6].s64 = ctx.r[1].s64 + -80;
	// 828E22FC: D001FFA8  stfs f0, -0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), tmp.u32 ) };
	// 828E2300: 3BE1FFB8  addi r31, r1, -0x48
	ctx.r[31].s64 = ctx.r[1].s64 + -72;
	// 828E2304: D001FFAC  stfs f0, -0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-84 as u32), tmp.u32 ) };
	// 828E2308: 3BC1FFBC  addi r30, r1, -0x44
	ctx.r[30].s64 = ctx.r[1].s64 + -68;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E23F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E23F0 size=568
    let mut pc: u32 = 0x828E23F0;
    'dispatch: loop {
        match pc {
            0x828E23F0 => {
    //   block [0x828E23F0..0x828E2628)
	// 828E23F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E23F4: 483C700D  bl 0x82ca9400
	ctx.lr = 0x828E23F8;
	sub_82CA93D0(ctx, base);
	// 828E23F8: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 828E23FC: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 828E2400: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E2404: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828E2408: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828E240C: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 828E2410: 3BAA9484  addi r29, r10, -0x6b7c
	ctx.r[29].s64 = ctx.r[10].s64 + -27516;
	// 828E2414: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E2418: 3F40820A  lis r26, -0x7df6
	ctx.r[26].s64 = -2113273856;
	// 828E241C: C9A99660  lfd f13, -0x69a0(r9)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(-27040 as u32) ) };
	// 828E2420: 811D6C9C  lwz r8, 0x6c9c(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27804 as u32) ) } as u64;
	// 828E2424: 80FD6CA0  lwz r7, 0x6ca0(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27808 as u32) ) } as u64;
	// 828E2428: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E242C: EFDF07F2  fmuls f30, f31, f31
	ctx.f[30].f64 = (((ctx.f[31].f64 * ctx.f[31].f64) as f32) as f64);
	// 828E2430: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828E2434: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 828E2438: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 828E243C: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 828E2440: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828E2444: FC006824  fdiv f0, f0, f13
	ctx.f[0].f64 = ctx.f[0].f64 / ctx.f[13].f64;
	// 828E2448: FDA007F2  fmul f13, f0, f31
	ctx.f[13].f64 = ctx.f[0].f64 * ctx.f[31].f64;
	// 828E244C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828E2450: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828E2454: 419800E8  blt cr6, 0x828e253c
	if ctx.cr[6].lt {
	pc = 0x828E253C; continue 'dispatch;
	}
	// 828E2458: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 828E245C: 409A0140  bne cr6, 0x828e259c
	if !ctx.cr[6].eq {
	pc = 0x828E259C; continue 'dispatch;
	}
	// 828E2460: 397F0050  addi r11, r31, 0x50
	ctx.r[11].s64 = ctx.r[31].s64 + 80;
	// 828E2464: C03A9A80  lfs f1, -0x6580(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E2468: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
	// 828E246C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828E2470: 3B9F0040  addi r28, r31, 0x40
	ctx.r[28].s64 = ctx.r[31].s64 + 64;
	// 828E2474: 3B7F0010  addi r27, r31, 0x10
	ctx.r[27].s64 = ctx.r[31].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828E2628 size=136
    let mut pc: u32 = 0x828E2628;
    'dispatch: loop {
        match pc {
            0x828E2628 => {
    //   block [0x828E2628..0x828E26B0)
	// 828E2628: 39410034  addi r10, r1, 0x34
	ctx.r[10].s64 = ctx.r[1].s64 + 52;
	// 828E262C: D0210034  stfs f1, 0x34(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 828E2630: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 828E2634: EC010072  fmuls f0, f1, f1
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[1].f64) as f32) as f64);
	// 828E2638: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 828E263C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828E2640: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E26B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E26B0 size=2504
    let mut pc: u32 = 0x828E26B0;
    'dispatch: loop {
        match pc {
            0x828E26B0 => {
    //   block [0x828E26B0..0x828E3078)
	// 828E26B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E26B4: 483C6D45  bl 0x82ca93f8
	ctx.lr = 0x828E26B8;
	sub_82CA93D0(ctx, base);
	// 828E26B8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E26BC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E26C0: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 828E26C4: 7F18E040  cmplw cr6, r24, r28
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828E26C8: 419A0718  beq cr6, 0x828e2de0
	if ctx.cr[6].eq {
	pc = 0x828E2DE0; continue 'dispatch;
	}
	// 828E26CC: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 828E26D0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828E26D4: 817C0028  lwz r11, 0x28(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 828E26D8: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
	// 828E26DC: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828E26E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E26E4: 419A00F4  beq cr6, 0x828e27d8
	if ctx.cr[6].eq {
	pc = 0x828E27D8; continue 'dispatch;
	}
	// 828E26E8: 817C008C  lwz r11, 0x8c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E26EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E26F0: 419A0024  beq cr6, 0x828e2714
	if ctx.cr[6].eq {
	pc = 0x828E2714; continue 'dispatch;
	}
	// 828E26F4: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828E26F8: 817C0048  lwz r11, 0x48(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E26FC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E2700: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E2704: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E2708: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 828E270C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E2710: 480000CC  b 0x828e27dc
	pc = 0x828E27DC; continue 'dispatch;
	// 828E2714: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E2718: 80DC004C  lwz r6, 0x4c(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E271C: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 828E2720: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E2724: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E2728: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E272C: 40810054  ble 0x828e2780
	if !ctx.cr[0].gt {
	pc = 0x828E2780; continue 'dispatch;
	}
	// 828E2730: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E2734: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E2738: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E273C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2740: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 828E2744: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E2748: 41980008  blt cr6, 0x828e2750
	if ctx.cr[6].lt {
	pc = 0x828E2750; continue 'dispatch;
	}
	// 828E274C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828E2750: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E2754: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E2758: 419A0014  beq cr6, 0x828e276c
	if ctx.cr[6].eq {
	pc = 0x828E276C; continue 'dispatch;
	}
	// 828E275C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E2760: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E2764: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E2768: 4800000C  b 0x828e2774
	pc = 0x828E2774; continue 'dispatch;
	// 828E276C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E2770: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E2774: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2778: 4199FFB8  bgt cr6, 0x828e2730
	if ctx.cr[6].gt {
	pc = 0x828E2730; continue 'dispatch;
	}
	// 828E277C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E2780: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E2784: 419A0040  beq cr6, 0x828e27c4
	if ctx.cr[6].eq {
	pc = 0x828E27C4; continue 'dispatch;
	}
	// 828E2788: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E278C: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 828E2790: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E2794: 41990008  bgt cr6, 0x828e279c
	if ctx.cr[6].gt {
	pc = 0x828E279C; continue 'dispatch;
	}
	// 828E2798: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828E279C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E27A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E27A4: 409A0020  bne cr6, 0x828e27c4
	if !ctx.cr[6].eq {
	pc = 0x828E27C4; continue 'dispatch;
	}
	// 828E27A8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E27AC: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 828E27B0: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828E27B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E27B8: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 828E27BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E27C0: 4800001C  b 0x828e27dc
	pc = 0x828E27DC; continue 'dispatch;
	// 828E27C4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E27C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E27CC: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 828E27D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E27D4: 48000008  b 0x828e27dc
	pc = 0x828E27DC; continue 'dispatch;
	// 828E27D8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828E27DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E27E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E27E4: 419A01A0  beq cr6, 0x828e2984
	if ctx.cr[6].eq {
	pc = 0x828E2984; continue 'dispatch;
	}
	// 828E27E8: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828E27EC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828E27F0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E27F4: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E27F8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E27FC: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2800: 4B94FF79  bl 0x82232778
	ctx.lr = 0x828E2804;
	sub_82232778(ctx, base);
	// 828E2804: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E2808: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828E280C: 409A05D4  bne cr6, 0x828e2de0
	if !ctx.cr[6].eq {
	pc = 0x828E2DE0; continue 'dispatch;
	}
	// 828E2810: 81780030  lwz r11, 0x30(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(48 as u32) ) } as u64;
	// 828E2814: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828E2818: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E281C: 409A05C4  bne cr6, 0x828e2de0
	if !ctx.cr[6].eq {
	pc = 0x828E2DE0; continue 'dispatch;
	}
	// 828E2820: 8158003C  lwz r10, 0x3c(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(60 as u32) ) } as u64;
	// 828E2824: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828E2828: 55498FFE  rlwinm r9, r10, 0x11, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00007FFFu64;
	// 828E282C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E2830: 419A00E8  beq cr6, 0x828e2918
	if ctx.cr[6].eq {
	pc = 0x828E2918; continue 'dispatch;
	}
	// 828E2834: 8178008C  lwz r11, 0x8c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E2838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E283C: 419A0020  beq cr6, 0x828e285c
	if ctx.cr[6].eq {
	pc = 0x828E285C; continue 'dispatch;
	}
	// 828E2840: 894B00CF  lbz r10, 0xcf(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(207 as u32) ) } as u64;
	// 828E2844: 81780048  lwz r11, 0x48(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E2848: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E284C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E2850: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E2854: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E2858: 480000C4  b 0x828e291c
	pc = 0x828E291C; continue 'dispatch;
	// 828E285C: 81580048  lwz r10, 0x48(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E2860: 80D8004C  lwz r6, 0x4c(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E2864: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 828E2868: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E286C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828E2870: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2874: 40810054  ble 0x828e28c8
	if !ctx.cr[0].gt {
	pc = 0x828E28C8; continue 'dispatch;
	}
	// 828E2878: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E287C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E2880: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E2884: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2888: 2F0700CF  cmpwi cr6, r7, 0xcf
	ctx.cr[6].compare_i32(ctx.r[7].s32, 207, &mut ctx.xer);
	// 828E288C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E2890: 41980008  blt cr6, 0x828e2898
	if ctx.cr[6].lt {
	pc = 0x828E2898; continue 'dispatch;
	}
	// 828E2894: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828E2898: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E289C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E28A0: 419A0014  beq cr6, 0x828e28b4
	if ctx.cr[6].eq {
	pc = 0x828E28B4; continue 'dispatch;
	}
	// 828E28A4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E28A8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E28AC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E28B0: 4800000C  b 0x828e28bc
	pc = 0x828E28BC; continue 'dispatch;
	// 828E28B4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E28B8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E28BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E28C0: 4199FFB8  bgt cr6, 0x828e2878
	if ctx.cr[6].gt {
	pc = 0x828E2878; continue 'dispatch;
	}
	// 828E28C4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828E28C8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E28CC: 419A003C  beq cr6, 0x828e2908
	if ctx.cr[6].eq {
	pc = 0x828E2908; continue 'dispatch;
	}
	// 828E28D0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E28D4: 2F0B00CF  cmpwi cr6, r11, 0xcf
	ctx.cr[6].compare_i32(ctx.r[11].s32, 207, &mut ctx.xer);
	// 828E28D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E28DC: 41990008  bgt cr6, 0x828e28e4
	if ctx.cr[6].gt {
	pc = 0x828E28E4; continue 'dispatch;
	}
	// 828E28E0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828E28E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E28E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E28EC: 409A001C  bne cr6, 0x828e2908
	if !ctx.cr[6].eq {
	pc = 0x828E2908; continue 'dispatch;
	}
	// 828E28F0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828E28F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E28F8: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 828E28FC: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828E2900: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E2904: 48000018  b 0x828e291c
	pc = 0x828E291C; continue 'dispatch;
	// 828E2908: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E290C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E2910: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E2914: 48000008  b 0x828e291c
	pc = 0x828E291C; continue 'dispatch;
	// 828E2918: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 828E291C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E2920: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E2924: 419A0060  beq cr6, 0x828e2984
	if ctx.cr[6].eq {
	pc = 0x828E2984; continue 'dispatch;
	}
	// 828E2928: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E292C: 4800FD15  bl 0x828f2640
	ctx.lr = 0x828E2930;
	sub_828F2640(ctx, base);
	// 828E2930: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E2934: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828E2938: 419A0018  beq cr6, 0x828e2950
	if ctx.cr[6].eq {
	pc = 0x828E2950; continue 'dispatch;
	}
	// 828E293C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E2940: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E2944: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E2948: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E294C: 409A0008  bne cr6, 0x828e2954
	if !ctx.cr[6].eq {
	pc = 0x828E2954; continue 'dispatch;
	}
	// 828E2950: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828E2954: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E2958: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E295C: 419A0028  beq cr6, 0x828e2984
	if ctx.cr[6].eq {
	pc = 0x828E2984; continue 'dispatch;
	}
	// 828E2960: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828E2964: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E2968: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E296C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E2970: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2974: 4B94FE05  bl 0x82232778
	ctx.lr = 0x828E2978;
	sub_82232778(ctx, base);
	// 828E2978: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E297C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828E2980: 409A0460  bne cr6, 0x828e2de0
	if !ctx.cr[6].eq {
	pc = 0x828E2DE0; continue 'dispatch;
	}
	// 828E2984: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828E2988: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 828E298C: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 828E2990: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E2994: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E2998: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E299C: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E29A0: 4B949819  bl 0x8222c1b8
	ctx.lr = 0x828E29A4;
	sub_8222C1B8(ctx, base);
	// 828E29A4: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828E29A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E29AC: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E29B0: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E29B4: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E29B8: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E29BC: 480030BD  bl 0x828e5a78
	ctx.lr = 0x828E29C0;
	sub_828E5A78(ctx, base);
	// 828E29C0: 7F1CF040  cmplw cr6, r28, r30
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828E29C4: 409A0008  bne cr6, 0x828e29cc
	if !ctx.cr[6].eq {
	pc = 0x828E29CC; continue 'dispatch;
	}
	// 828E29C8: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 828E29CC: 7F18F040  cmplw cr6, r24, r30
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828E29D0: 409A0008  bne cr6, 0x828e29d8
	if !ctx.cr[6].eq {
	pc = 0x828E29D8; continue 'dispatch;
	}
	// 828E29D4: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 828E29D8: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828E29DC: 409A0008  bne cr6, 0x828e29e4
	if !ctx.cr[6].eq {
	pc = 0x828E29E4; continue 'dispatch;
	}
	// 828E29E0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828E29E4: 7F181840  cmplw cr6, r24, r3
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828E29E8: 409A0008  bne cr6, 0x828e29f0
	if !ctx.cr[6].eq {
	pc = 0x828E29F0; continue 'dispatch;
	}
	// 828E29EC: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828E29F0: 57A5063E  clrlwi r5, r29, 0x18
	ctx.r[5].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828E29F4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828E29F8: 419A014C  beq cr6, 0x828e2b44
	if ctx.cr[6].eq {
	pc = 0x828E2B44; continue 'dispatch;
	}
	// 828E29FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E2A00: 419A0018  beq cr6, 0x828e2a18
	if ctx.cr[6].eq {
	pc = 0x828E2A18; continue 'dispatch;
	}
	// 828E2A04: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E2A08: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E2A0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E2A10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E2A14: 409A0008  bne cr6, 0x828e2a1c
	if !ctx.cr[6].eq {
	pc = 0x828E2A1C; continue 'dispatch;
	}
	// 828E2A18: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828E2A1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E2A20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2A24: 419A0120  beq cr6, 0x828e2b44
	if ctx.cr[6].eq {
	pc = 0x828E2B44; continue 'dispatch;
	}
	// 828E2A28: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 828E2A2C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828E2A30: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 828E2A34: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E2A38: 419A00E8  beq cr6, 0x828e2b20
	if ctx.cr[6].eq {
	pc = 0x828E2B20; continue 'dispatch;
	}
	// 828E2A3C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E2A40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2A44: 419A0020  beq cr6, 0x828e2a64
	if ctx.cr[6].eq {
	pc = 0x828E2A64; continue 'dispatch;
	}
	// 828E2A48: 894B005B  lbz r10, 0x5b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(91 as u32) ) } as u64;
	// 828E2A4C: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E2A50: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E2A54: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E2A58: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E2A5C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E2A60: 480000C4  b 0x828e2b24
	pc = 0x828E2B24; continue 'dispatch;
	// 828E2A64: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E2A68: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E2A6C: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 828E2A70: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E2A74: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828E2A78: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2A7C: 40810054  ble 0x828e2ad0
	if !ctx.cr[0].gt {
	pc = 0x828E2AD0; continue 'dispatch;
	}
	// 828E2A80: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E2A84: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E2A88: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E2A8C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2A90: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 828E2A94: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E2A98: 41980008  blt cr6, 0x828e2aa0
	if ctx.cr[6].lt {
	pc = 0x828E2AA0; continue 'dispatch;
	}
	// 828E2A9C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828E2AA0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E2AA4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E2AA8: 419A0014  beq cr6, 0x828e2abc
	if ctx.cr[6].eq {
	pc = 0x828E2ABC; continue 'dispatch;
	}
	// 828E2AAC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E2AB0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E2AB4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E2AB8: 4800000C  b 0x828e2ac4
	pc = 0x828E2AC4; continue 'dispatch;
	// 828E2ABC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E2AC0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E2AC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2AC8: 4199FFB8  bgt cr6, 0x828e2a80
	if ctx.cr[6].gt {
	pc = 0x828E2A80; continue 'dispatch;
	}
	// 828E2ACC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828E2AD0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E2AD4: 419A003C  beq cr6, 0x828e2b10
	if ctx.cr[6].eq {
	pc = 0x828E2B10; continue 'dispatch;
	}
	// 828E2AD8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2ADC: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 828E2AE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E2AE4: 41990008  bgt cr6, 0x828e2aec
	if ctx.cr[6].gt {
	pc = 0x828E2AEC; continue 'dispatch;
	}
	// 828E2AE8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828E2AEC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E2AF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2AF4: 409A001C  bne cr6, 0x828e2b10
	if !ctx.cr[6].eq {
	pc = 0x828E2B10; continue 'dispatch;
	}
	// 828E2AF8: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828E2AFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E2B00: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 828E2B04: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828E2B08: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E2B0C: 48000018  b 0x828e2b24
	pc = 0x828E2B24; continue 'dispatch;
	// 828E2B10: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E2B14: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E2B18: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E2B1C: 48000008  b 0x828e2b24
	pc = 0x828E2B24; continue 'dispatch;
	// 828E2B20: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 828E2B24: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E2B28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E2B2C: 419A0018  beq cr6, 0x828e2b44
	if ctx.cr[6].eq {
	pc = 0x828E2B44; continue 'dispatch;
	}
	// 828E2B30: 896B011C  lbz r11, 0x11c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) } as u64;
	// 828E2B34: 556A073E  clrlwi r10, r11, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 828E2B38: 554A07FA  rlwinm r10, r10, 0, 0x1f, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828E2B3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E2B40: 409A02A0  bne cr6, 0x828e2de0
	if !ctx.cr[6].eq {
	pc = 0x828E2DE0; continue 'dispatch;
	}
	// 828E2B44: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 828E2B48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2B4C: 419A000C  beq cr6, 0x828e2b58
	if ctx.cr[6].eq {
	pc = 0x828E2B58; continue 'dispatch;
	}
	// 828E2B50: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828E2B54: 409A028C  bne cr6, 0x828e2de0
	if !ctx.cr[6].eq {
	pc = 0x828E2DE0; continue 'dispatch;
	}
	// 828E2B58: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E2B5C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828E2B60: 4B9E37B9  bl 0x822c6318
	ctx.lr = 0x828E2B64;
	sub_822C6318(ctx, base);
	// 828E2B64: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E2B68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2B6C: 419A0274  beq cr6, 0x828e2de0
	if ctx.cr[6].eq {
	pc = 0x828E2DE0; continue 'dispatch;
	}
	// 828E2B70: 81780034  lwz r11, 0x34(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(52 as u32) ) } as u64;
	// 828E2B74: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828E2B78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E2B7C: 409A04F0  bne cr6, 0x828e306c
	if !ctx.cr[6].eq {
	pc = 0x828E306C; continue 'dispatch;
	}
	// 828E2B80: 817C0040  lwz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 828E2B84: 556A3FFE  rlwinm r10, r11, 7, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x01FFFFFFu64;
	// 828E2B88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E2B8C: 409A04E0  bne cr6, 0x828e306c
	if !ctx.cr[6].eq {
	pc = 0x828E306C; continue 'dispatch;
	}
	// 828E2B90: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 828E2B94: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828E2B98: 419A0018  beq cr6, 0x828e2bb0
	if ctx.cr[6].eq {
	pc = 0x828E2BB0; continue 'dispatch;
	}
	// 828E2B9C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E2BA0: 4B90B7A9  bl 0x821ee348
	ctx.lr = 0x828E2BA4;
	sub_821EE348(ctx, base);
	// 828E2BA4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E2BA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2BAC: 419A04C0  beq cr6, 0x828e306c
	if ctx.cr[6].eq {
	pc = 0x828E306C; continue 'dispatch;
	}
	// 828E2BB0: 817C0024  lwz r11, 0x24(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E2BB4: 556A67FE  rlwinm r10, r11, 0xc, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000FFFFFu64;
	// 828E2BB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E2BBC: 419A00F0  beq cr6, 0x828e2cac
	if ctx.cr[6].eq {
	pc = 0x828E2CAC; continue 'dispatch;
	}
	// 828E2BC0: 817C008C  lwz r11, 0x8c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E2BC4: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E2BC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2BCC: 419A0020  beq cr6, 0x828e2bec
	if ctx.cr[6].eq {
	pc = 0x828E2BEC; continue 'dispatch;
	}
	// 828E2BD0: 896B0014  lbz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828E2BD4: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828E2BD8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E2BDC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E2BE0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E2BE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E2BE8: 480000C8  b 0x828e2cb0
	pc = 0x828E2CB0; continue 'dispatch;
	// 828E2BEC: 80DC004C  lwz r6, 0x4c(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E2BF0: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 828E2BF4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E2BF8: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828E2BFC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2C00: 40810054  ble 0x828e2c54
	if !ctx.cr[0].gt {
	pc = 0x828E2C54; continue 'dispatch;
	}
	// 828E2C04: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E2C08: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E2C0C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828E2C10: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2C14: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 828E2C18: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E2C1C: 41980008  blt cr6, 0x828e2c24
	if ctx.cr[6].lt {
	pc = 0x828E2C24; continue 'dispatch;
	}
	// 828E2C20: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828E2C24: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E2C28: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E2C2C: 419A0014  beq cr6, 0x828e2c40
	if ctx.cr[6].eq {
	pc = 0x828E2C40; continue 'dispatch;
	}
	// 828E2C30: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E2C34: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E2C38: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E2C3C: 4800000C  b 0x828e2c48
	pc = 0x828E2C48; continue 'dispatch;
	// 828E2C40: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E2C44: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E2C48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2C4C: 4199FFB8  bgt cr6, 0x828e2c04
	if ctx.cr[6].gt {
	pc = 0x828E2C04; continue 'dispatch;
	}
	// 828E2C50: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828E2C54: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E2C58: 419A0040  beq cr6, 0x828e2c98
	if ctx.cr[6].eq {
	pc = 0x828E2C98; continue 'dispatch;
	}
	// 828E2C5C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2C60: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 828E2C64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E2C68: 41990008  bgt cr6, 0x828e2c70
	if ctx.cr[6].gt {
	pc = 0x828E2C70; continue 'dispatch;
	}
	// 828E2C6C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828E2C70: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E2C74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2C78: 409A0020  bne cr6, 0x828e2c98
	if !ctx.cr[6].eq {
	pc = 0x828E2C98; continue 'dispatch;
	}
	// 828E2C7C: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828E2C80: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 828E2C84: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828E2C88: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E2C8C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E2C90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E2C94: 4800001C  b 0x828e2cb0
	pc = 0x828E2CB0; continue 'dispatch;
	// 828E2C98: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E2C9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E2CA0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E2CA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E2CA8: 48000008  b 0x828e2cb0
	pc = 0x828E2CB0; continue 'dispatch;
	// 828E2CAC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828E2CB0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E2CB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2CB8: 419A0010  beq cr6, 0x828e2cc8
	if ctx.cr[6].eq {
	pc = 0x828E2CC8; continue 'dispatch;
	}
	// 828E2CBC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 828E2CC0: 2F0B000E  cmpwi cr6, r11, 0xe
	ctx.cr[6].compare_i32(ctx.r[11].s32, 14, &mut ctx.xer);
	// 828E2CC4: 419A03A8  beq cr6, 0x828e306c
	if ctx.cr[6].eq {
	pc = 0x828E306C; continue 'dispatch;
	}
	// 828E2CC8: 817C003C  lwz r11, 0x3c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) } as u64;
	// 828E2CCC: 556A8FFE  rlwinm r10, r11, 0x11, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00007FFFu64;
	// 828E2CD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E2CD4: 419A0118  beq cr6, 0x828e2dec
	if ctx.cr[6].eq {
	pc = 0x828E2DEC; continue 'dispatch;
	}
	// 828E2CD8: 817C008C  lwz r11, 0x8c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E2CDC: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E2CE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2CE4: 419A0018  beq cr6, 0x828e2cfc
	if ctx.cr[6].eq {
	pc = 0x828E2CFC; continue 'dispatch;
	}
	// 828E2CE8: 896B00CF  lbz r11, 0xcf(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(207 as u32) ) } as u64;
	// 828E2CEC: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828E2CF0: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E2CF4: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E2CF8: 480000AC  b 0x828e2da4
	pc = 0x828E2DA4; continue 'dispatch;
	// 828E2CFC: 80DC004C  lwz r6, 0x4c(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E2D00: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 828E2D04: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E2D08: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 828E2D0C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2D10: 40810054  ble 0x828e2d64
	if !ctx.cr[0].gt {
	pc = 0x828E2D64; continue 'dispatch;
	}
	// 828E2D14: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E2D18: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E2D1C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828E2D20: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2D24: 2F0700CF  cmpwi cr6, r7, 0xcf
	ctx.cr[6].compare_i32(ctx.r[7].s32, 207, &mut ctx.xer);
	// 828E2D28: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E2D2C: 41980008  blt cr6, 0x828e2d34
	if ctx.cr[6].lt {
	pc = 0x828E2D34; continue 'dispatch;
	}
	// 828E2D30: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828E2D34: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E2D38: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E2D3C: 419A0014  beq cr6, 0x828e2d50
	if ctx.cr[6].eq {
	pc = 0x828E2D50; continue 'dispatch;
	}
	// 828E2D40: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E2D44: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E2D48: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E2D4C: 4800000C  b 0x828e2d58
	pc = 0x828E2D58; continue 'dispatch;
	// 828E2D50: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E2D54: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E2D58: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2D5C: 4199FFB8  bgt cr6, 0x828e2d14
	if ctx.cr[6].gt {
	pc = 0x828E2D14; continue 'dispatch;
	}
	// 828E2D60: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 828E2D64: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E2D68: 419A0034  beq cr6, 0x828e2d9c
	if ctx.cr[6].eq {
	pc = 0x828E2D9C; continue 'dispatch;
	}
	// 828E2D6C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2D70: 2F0B00CF  cmpwi cr6, r11, 0xcf
	ctx.cr[6].compare_i32(ctx.r[11].s32, 207, &mut ctx.xer);
	// 828E2D74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E2D78: 41990008  bgt cr6, 0x828e2d80
	if ctx.cr[6].gt {
	pc = 0x828E2D80; continue 'dispatch;
	}
	// 828E2D7C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828E2D80: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E2D84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2D88: 409A0014  bne cr6, 0x828e2d9c
	if !ctx.cr[6].eq {
	pc = 0x828E2D9C; continue 'dispatch;
	}
	// 828E2D8C: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828E2D90: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 828E2D94: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828E2D98: 48000008  b 0x828e2da0
	pc = 0x828E2DA0; continue 'dispatch;
	// 828E2D9C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E2DA0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E2DA4: 4800F89D  bl 0x828f2640
	ctx.lr = 0x828E2DA8;
	sub_828F2640(ctx, base);
	// 828E2DA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E2DAC: 419A0018  beq cr6, 0x828e2dc4
	if ctx.cr[6].eq {
	pc = 0x828E2DC4; continue 'dispatch;
	}
	// 828E2DB0: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E2DB4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E2DB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E2DBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E2DC0: 409A0008  bne cr6, 0x828e2dc8
	if !ctx.cr[6].eq {
	pc = 0x828E2DC8; continue 'dispatch;
	}
	// 828E2DC4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828E2DC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E2DCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2DD0: 419A0010  beq cr6, 0x828e2de0
	if ctx.cr[6].eq {
	pc = 0x828E2DE0; continue 'dispatch;
	}
	// 828E2DD4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E2DD8: 7F181840  cmplw cr6, r24, r3
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828E2DDC: 409AF8F8  bne cr6, 0x828e26d4
	if !ctx.cr[6].eq {
	pc = 0x828E26D4; continue 'dispatch;
	}
	// 828E2DE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E2DE4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828E2DE8: 483C6660  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 828E2DEC: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828E2DF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2DF4: 419A0150  beq cr6, 0x828e2f44
	if ctx.cr[6].eq {
	pc = 0x828E2F44; continue 'dispatch;
	}
	// 828E2DF8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828E2DFC: 419A0018  beq cr6, 0x828e2e14
	if ctx.cr[6].eq {
	pc = 0x828E2E14; continue 'dispatch;
	}
	// 828E2E00: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E2E04: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E2E08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E2E0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E2E10: 409A0008  bne cr6, 0x828e2e18
	if !ctx.cr[6].eq {
	pc = 0x828E2E18; continue 'dispatch;
	}
	// 828E2E14: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828E2E18: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E2E1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2E20: 419A0124  beq cr6, 0x828e2f44
	if ctx.cr[6].eq {
	pc = 0x828E2F44; continue 'dispatch;
	}
	// 828E2E24: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 828E2E28: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828E2E2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E2E30: 419A00F0  beq cr6, 0x828e2f20
	if ctx.cr[6].eq {
	pc = 0x828E2F20; continue 'dispatch;
	}
	// 828E2E34: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E2E38: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E2E3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2E40: 419A0020  beq cr6, 0x828e2e60
	if ctx.cr[6].eq {
	pc = 0x828E2E60; continue 'dispatch;
	}
	// 828E2E44: 896B0021  lbz r11, 0x21(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828E2E48: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828E2E4C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E2E50: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E2E54: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 828E2E58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E2E5C: 480000C8  b 0x828e2f24
	pc = 0x828E2F24; continue 'dispatch;
	// 828E2E60: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E2E64: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 828E2E68: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E2E6C: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 828E2E70: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2E74: 40810054  ble 0x828e2ec8
	if !ctx.cr[0].gt {
	pc = 0x828E2EC8; continue 'dispatch;
	}
	// 828E2E78: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E2E7C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E2E80: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828E2E84: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2E88: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 828E2E8C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E2E90: 41980008  blt cr6, 0x828e2e98
	if ctx.cr[6].lt {
	pc = 0x828E2E98; continue 'dispatch;
	}
	// 828E2E94: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828E2E98: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E2E9C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E2EA0: 419A0014  beq cr6, 0x828e2eb4
	if ctx.cr[6].eq {
	pc = 0x828E2EB4; continue 'dispatch;
	}
	// 828E2EA4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E2EA8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E2EAC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E2EB0: 4800000C  b 0x828e2ebc
	pc = 0x828E2EBC; continue 'dispatch;
	// 828E2EB4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E2EB8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E2EBC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2EC0: 4199FFB8  bgt cr6, 0x828e2e78
	if ctx.cr[6].gt {
	pc = 0x828E2E78; continue 'dispatch;
	}
	// 828E2EC4: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 828E2EC8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E2ECC: 419A0040  beq cr6, 0x828e2f0c
	if ctx.cr[6].eq {
	pc = 0x828E2F0C; continue 'dispatch;
	}
	// 828E2ED0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2ED4: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 828E2ED8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E2EDC: 41990008  bgt cr6, 0x828e2ee4
	if ctx.cr[6].gt {
	pc = 0x828E2EE4; continue 'dispatch;
	}
	// 828E2EE0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828E2EE4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E2EE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2EEC: 409A0020  bne cr6, 0x828e2f0c
	if !ctx.cr[6].eq {
	pc = 0x828E2F0C; continue 'dispatch;
	}
	// 828E2EF0: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828E2EF4: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 828E2EF8: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828E2EFC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E2F00: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 828E2F04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E2F08: 4800001C  b 0x828e2f24
	pc = 0x828E2F24; continue 'dispatch;
	// 828E2F0C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E2F10: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E2F14: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 828E2F18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E2F1C: 48000008  b 0x828e2f24
	pc = 0x828E2F24; continue 'dispatch;
	// 828E2F20: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828E2F24: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E2F28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2F2C: 419A0018  beq cr6, 0x828e2f44
	if ctx.cr[6].eq {
	pc = 0x828E2F44; continue 'dispatch;
	}
	// 828E2F30: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E2F34: 4B90B415  bl 0x821ee348
	ctx.lr = 0x828E2F38;
	sub_821EE348(ctx, base);
	// 828E2F38: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E2F3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2F40: 419A012C  beq cr6, 0x828e306c
	if ctx.cr[6].eq {
	pc = 0x828E306C; continue 'dispatch;
	}
	// 828E2F44: 81780034  lwz r11, 0x34(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(52 as u32) ) } as u64;
	// 828E2F48: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828E2F4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E2F50: 419A011C  beq cr6, 0x828e306c
	if ctx.cr[6].eq {
	pc = 0x828E306C; continue 'dispatch;
	}
	// 828E2F54: 815C0034  lwz r10, 0x34(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) } as u64;
	// 828E2F58: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828E2F5C: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828E2F60: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E2F64: 419A00E4  beq cr6, 0x828e3048
	if ctx.cr[6].eq {
	pc = 0x828E3048; continue 'dispatch;
	}
	// 828E2F68: 817C008C  lwz r11, 0x8c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E2F6C: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E2F70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2F74: 419A001C  beq cr6, 0x828e2f90
	if ctx.cr[6].eq {
	pc = 0x828E2F90; continue 'dispatch;
	}
	// 828E2F78: 896B0085  lbz r11, 0x85(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(133 as u32) ) } as u64;
	// 828E2F7C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828E2F80: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E2F84: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E2F88: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E2F8C: 480000C0  b 0x828e304c
	pc = 0x828E304C; continue 'dispatch;
	// 828E2F90: 80DC004C  lwz r6, 0x4c(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E2F94: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 828E2F98: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E2F9C: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 828E2FA0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2FA4: 40810054  ble 0x828e2ff8
	if !ctx.cr[0].gt {
	pc = 0x828E2FF8; continue 'dispatch;
	}
	// 828E2FA8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E2FAC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E2FB0: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828E2FB4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2FB8: 2F070085  cmpwi cr6, r7, 0x85
	ctx.cr[6].compare_i32(ctx.r[7].s32, 133, &mut ctx.xer);
	// 828E2FBC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E2FC0: 41980008  blt cr6, 0x828e2fc8
	if ctx.cr[6].lt {
	pc = 0x828E2FC8; continue 'dispatch;
	}
	// 828E2FC4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828E2FC8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E2FCC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E2FD0: 419A0014  beq cr6, 0x828e2fe4
	if ctx.cr[6].eq {
	pc = 0x828E2FE4; continue 'dispatch;
	}
	// 828E2FD4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E2FD8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E2FDC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E2FE0: 4800000C  b 0x828e2fec
	pc = 0x828E2FEC; continue 'dispatch;
	// 828E2FE4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E2FE8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E2FEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2FF0: 4199FFB8  bgt cr6, 0x828e2fa8
	if ctx.cr[6].gt {
	pc = 0x828E2FA8; continue 'dispatch;
	}
	// 828E2FF4: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 828E2FF8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E2FFC: 419A003C  beq cr6, 0x828e3038
	if ctx.cr[6].eq {
	pc = 0x828E3038; continue 'dispatch;
	}
	// 828E3000: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3004: 2F0B0085  cmpwi cr6, r11, 0x85
	ctx.cr[6].compare_i32(ctx.r[11].s32, 133, &mut ctx.xer);
	// 828E3008: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E300C: 41990008  bgt cr6, 0x828e3014
	if ctx.cr[6].gt {
	pc = 0x828E3014; continue 'dispatch;
	}
	// 828E3010: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828E3014: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E3018: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E301C: 409A001C  bne cr6, 0x828e3038
	if !ctx.cr[6].eq {
	pc = 0x828E3038; continue 'dispatch;
	}
	// 828E3020: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828E3024: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E3028: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 828E302C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828E3030: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3034: 48000018  b 0x828e304c
	pc = 0x828E304C; continue 'dispatch;
	// 828E3038: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E303C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E3040: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3044: 48000008  b 0x828e304c
	pc = 0x828E304C; continue 'dispatch;
	// 828E3048: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 828E304C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E3050: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E3054: 419A0018  beq cr6, 0x828e306c
	if ctx.cr[6].eq {
	pc = 0x828E306C; continue 'dispatch;
	}
	// 828E3058: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828E305C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E3060: 4B920F39  bl 0x82203f98
	ctx.lr = 0x828E3064;
	sub_82203F98(ctx, base);
	// 828E3064: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 828E3068: 409AFD78  bne cr6, 0x828e2de0
	if !ctx.cr[6].eq {
	pc = 0x828E2DE0; continue 'dispatch;
	}
	// 828E306C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828E3070: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828E3074: 483C63D4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E3078 size=332
    let mut pc: u32 = 0x828E3078;
    'dispatch: loop {
        match pc {
            0x828E3078 => {
    //   block [0x828E3078..0x828E31C4)
	// 828E3078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E307C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E3080: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E3084: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E3088: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E308C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E3090: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 828E3094: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E3098: 419A00F4  beq cr6, 0x828e318c
	if ctx.cr[6].eq {
	pc = 0x828E318C; continue 'dispatch;
	}
	// 828E309C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E30A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E30A4: 419A0024  beq cr6, 0x828e30c8
	if ctx.cr[6].eq {
	pc = 0x828E30C8; continue 'dispatch;
	}
	// 828E30A8: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 828E30AC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E30B0: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828E30B4: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E30B8: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E30BC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E30C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E30C4: 480000CC  b 0x828e3190
	pc = 0x828E3190; continue 'dispatch;
	// 828E30C8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E30CC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E30D0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828E30D4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E30D8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E30DC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E30E0: 40810054  ble 0x828e3134
	if !ctx.cr[0].gt {
	pc = 0x828E3134; continue 'dispatch;
	}
	// 828E30E4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E30E8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E30EC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E30F0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E30F4: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 828E30F8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E30FC: 41980008  blt cr6, 0x828e3104
	if ctx.cr[6].lt {
	pc = 0x828E3104; continue 'dispatch;
	}
	// 828E3100: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828E3104: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E3108: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E310C: 419A0014  beq cr6, 0x828e3120
	if ctx.cr[6].eq {
	pc = 0x828E3120; continue 'dispatch;
	}
	// 828E3110: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E3114: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E3118: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E311C: 4800000C  b 0x828e3128
	pc = 0x828E3128; continue 'dispatch;
	// 828E3120: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E3124: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E3128: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E312C: 4199FFB8  bgt cr6, 0x828e30e4
	if ctx.cr[6].gt {
	pc = 0x828E30E4; continue 'dispatch;
	}
	// 828E3130: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E3134: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E3138: 419A0040  beq cr6, 0x828e3178
	if ctx.cr[6].eq {
	pc = 0x828E3178; continue 'dispatch;
	}
	// 828E313C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3140: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 828E3144: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E3148: 41990008  bgt cr6, 0x828e3150
	if ctx.cr[6].gt {
	pc = 0x828E3150; continue 'dispatch;
	}
	// 828E314C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E3150: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E3154: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3158: 409A0020  bne cr6, 0x828e3178
	if !ctx.cr[6].eq {
	pc = 0x828E3178; continue 'dispatch;
	}
	// 828E315C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E3160: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E3164: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E3168: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E316C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E3170: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E3174: 4800001C  b 0x828e3190
	pc = 0x828E3190; continue 'dispatch;
	// 828E3178: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E317C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3180: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E3184: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E3188: 48000008  b 0x828e3190
	pc = 0x828E3190; continue 'dispatch;
	// 828E318C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E3190: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E3194: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3198: 419A0018  beq cr6, 0x828e31b0
	if ctx.cr[6].eq {
	pc = 0x828E31B0; continue 'dispatch;
	}
	// 828E319C: 4BB3EB8D  bl 0x82421d28
	ctx.lr = 0x828E31A0;
	sub_82421D28(ctx, base);
	// 828E31A0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E31A4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828E31A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E31AC: 409A0008  bne cr6, 0x828e31b4
	if !ctx.cr[6].eq {
	pc = 0x828E31B4; continue 'dispatch;
	}
	// 828E31B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E31B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E31B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E31BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E31C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


