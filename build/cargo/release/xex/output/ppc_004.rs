pub fn sub_821C6860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C6860 size=136
    let mut pc: u32 = 0x821C6860;
    'dispatch: loop {
        match pc {
            0x821C6860 => {
    //   block [0x821C6860..0x821C68E8)
	// 821C6860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C6864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C6868: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C686C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C6870: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821C6874: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821C6878: 480AF619  bl 0x82275e90
	ctx.lr = 0x821C687C;
	sub_82275E90(ctx, base);
	// 821C687C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C6880: 419A0050  beq cr6, 0x821c68d0
	if ctx.cr[6].eq {
	pc = 0x821C68D0; continue 'dispatch;
	}
	// 821C6884: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C6888: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821C688C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821C6890: 419A0028  beq cr6, 0x821c68b8
	if ctx.cr[6].eq {
	pc = 0x821C68B8; continue 'dispatch;
	}
	// 821C6894: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821C6898: 409A0020  bne cr6, 0x821c68b8
	if !ctx.cr[6].eq {
	pc = 0x821C68B8; continue 'dispatch;
	}
	// 821C689C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C68A0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C68A4: 816BE454  lwz r11, -0x1bac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 821C68A8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C68AC: 409A000C  bne cr6, 0x821c68b8
	if !ctx.cr[6].eq {
	pc = 0x821C68B8; continue 'dispatch;
	}
	// 821C68B0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C68B4: 394BE460  addi r10, r11, -0x1ba0
	ctx.r[10].s64 = ctx.r[11].s64 + -7072;
	// 821C68B8: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C68BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C68C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C68C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C68C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C68CC: 4E800020  blr
	return;
	// 821C68D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C68D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C68D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C68DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C68E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C68E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C68E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C68E8 size=1200
    let mut pc: u32 = 0x821C68E8;
    'dispatch: loop {
        match pc {
            0x821C68E8 => {
    //   block [0x821C68E8..0x821C6D98)
	// 821C68E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C68EC: 48AE2B1D  bl 0x82ca9408
	ctx.lr = 0x821C68F0;
	sub_82CA93D0(ctx, base);
	// 821C68F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C68F4: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821C68F8: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821C68FC: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 821C6900: 3BEA2390  addi r31, r10, 0x2390
	ctx.r[31].s64 = ctx.r[10].s64 + 9104;
	// 821C6904: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821C6908: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 821C690C: 3BA90DB8  addi r29, r9, 0xdb8
	ctx.r[29].s64 = ctx.r[9].s64 + 3512;
	// 821C6910: 894B00D5  lbz r10, 0xd5(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(213 as u32) ) } as u64;
	// 821C6914: 812B00C4  lwz r9, 0xc4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 821C6918: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s64 = ctx.r[10].s64 * 8200;
	// 821C691C: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821C6920: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 821C6924: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C6928: 419A0084  beq cr6, 0x821c69ac
	if ctx.cr[6].eq {
	pc = 0x821C69AC; continue 'dispatch;
	}
	// 821C692C: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C6930: 810B00C8  lwz r8, 0xc8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 821C6934: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C6938: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C693C: 409A003C  bne cr6, 0x821c6978
	if !ctx.cr[6].eq {
	pc = 0x821C6978; continue 'dispatch;
	}
	// 821C6940: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6944: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C6948: 38CB00C0  addi r6, r11, 0xc0
	ctx.r[6].s64 = ctx.r[11].s64 + 192;
	// 821C694C: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C6950: 912B00C8  stw r9, 0xc8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(200 as u32), ctx.r[9].u32 ) };
	// 821C6954: 7CC5512E  stwx r6, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 821C6958: 812B00C4  lwz r9, 0xc4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 821C695C: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6960: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6964: 7CE85214  add r7, r8, r10
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C6968: 91270004  stw r9, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C696C: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6970: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821C6974: 90CA2004  stw r6, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	// 821C6978: 894B00D4  lbz r10, 0xd4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 821C697C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821C6980: 912B00C4  stw r9, 0xc4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(196 as u32), ctx.r[9].u32 ) };
	// 821C6984: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6988: 409A0024  bne cr6, 0x821c69ac
	if !ctx.cr[6].eq {
	pc = 0x821C69AC; continue 'dispatch;
	}
	// 821C698C: 815E0DB0  lwz r10, 0xdb0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821C6990: 390B00C0  addi r8, r11, 0xc0
	ctx.r[8].s64 = ctx.r[11].s64 + 192;
	// 821C6994: 992B00D4  stb r9, 0xd4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[9].u8 ) };
	// 821C6998: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821C699C: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 821C69A0: 90DE0DB0  stw r6, 0xdb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821C69A4: 7D07E92E  stwx r8, r7, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[29].u32), ctx.r[8].u32) };
	// 821C69A8: 48000008  b 0x821c69b0
	pc = 0x821C69B0; continue 'dispatch;
	// 821C69AC: 80DE0DB0  lwz r6, 0xdb0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821C69B0: 894B00ED  lbz r10, 0xed(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(237 as u32) ) } as u64;
	// 821C69B4: 812B00DC  lwz r9, 0xdc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(220 as u32) ) } as u64;
	// 821C69B8: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s64 = ctx.r[10].s64 * 8200;
	// 821C69BC: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821C69C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C69C4: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C69C8: 419A0080  beq cr6, 0x821c6a48
	if ctx.cr[6].eq {
	pc = 0x821C6A48; continue 'dispatch;
	}
	// 821C69CC: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C69D0: 810B00E0  lwz r8, 0xe0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(224 as u32) ) } as u64;
	// 821C69D4: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C69D8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C69DC: 409A003C  bne cr6, 0x821c6a18
	if !ctx.cr[6].eq {
	pc = 0x821C6A18; continue 'dispatch;
	}
	// 821C69E0: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C69E4: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C69E8: 38AB00D8  addi r5, r11, 0xd8
	ctx.r[5].s64 = ctx.r[11].s64 + 216;
	// 821C69EC: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C69F0: 912B00E0  stw r9, 0xe0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(224 as u32), ctx.r[9].u32 ) };
	// 821C69F4: 7CA8512E  stwx r5, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 821C69F8: 812B00DC  lwz r9, 0xdc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(220 as u32) ) } as u64;
	// 821C69FC: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6A00: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6A04: 7CA85214  add r5, r8, r10
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C6A08: 91250004  stw r9, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C6A0C: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6A10: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821C6A14: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	// 821C6A18: 894B00EC  lbz r10, 0xec(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(236 as u32) ) } as u64;
	// 821C6A1C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821C6A20: 912B00DC  stw r9, 0xdc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(220 as u32), ctx.r[9].u32 ) };
	// 821C6A24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6A28: 409A0020  bne cr6, 0x821c6a48
	if !ctx.cr[6].eq {
	pc = 0x821C6A48; continue 'dispatch;
	}
	// 821C6A2C: 54C9103A  slwi r9, r6, 2
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C6A30: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C6A34: 390B00D8  addi r8, r11, 0xd8
	ctx.r[8].s64 = ctx.r[11].s64 + 216;
	// 821C6A38: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821C6A3C: 994B00EC  stb r10, 0xec(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(236 as u32), ctx.r[10].u8 ) };
	// 821C6A40: 90DE0DB0  stw r6, 0xdb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821C6A44: 7D09E92E  stwx r8, r9, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32), ctx.r[8].u32) };
	// 821C6A48: 3D008331  lis r8, -0x7ccf
	ctx.r[8].s64 = -2093940736;
	// 821C6A4C: 894B0105  lbz r10, 0x105(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(261 as u32) ) } as u64;
	// 821C6A50: 812B00F4  lwz r9, 0xf4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 821C6A54: 38A8701C  addi r5, r8, 0x701c
	ctx.r[5].s64 = ctx.r[8].s64 + 28700;
	// 821C6A58: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s64 = ctx.r[10].s64 * 8200;
	// 821C6A5C: 80E50010  lwz r7, 0x10(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C6A60: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821C6A64: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821C6A68: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C6A6C: 419A007C  beq cr6, 0x821c6ae8
	if ctx.cr[6].eq {
	pc = 0x821C6AE8; continue 'dispatch;
	}
	// 821C6A70: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C6A74: 810B00F8  lwz r8, 0xf8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) } as u64;
	// 821C6A78: 7D3C4038  and r28, r9, r8
	ctx.r[28].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C6A7C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821C6A80: 409A003C  bne cr6, 0x821c6abc
	if !ctx.cr[6].eq {
	pc = 0x821C6ABC; continue 'dispatch;
	}
	// 821C6A84: 838A2004  lwz r28, 0x2004(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6A88: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C6A8C: 390B00F0  addi r8, r11, 0xf0
	ctx.r[8].s64 = ctx.r[11].s64 + 240;
	// 821C6A90: 579C1838  slwi r28, r28, 3
	ctx.r[28].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 821C6A94: 912B00F8  stw r9, 0xf8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(248 as u32), ctx.r[9].u32 ) };
	// 821C6A98: 7D1C512E  stwx r8, r28, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821C6A9C: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6AA0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6AA4: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C6AA8: 812B00F4  lwz r9, 0xf4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 821C6AAC: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C6AB0: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6AB4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821C6AB8: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	// 821C6ABC: 894B0104  lbz r10, 0x104(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 821C6AC0: 90EB00F4  stw r7, 0xf4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(244 as u32), ctx.r[7].u32 ) };
	// 821C6AC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6AC8: 409A0020  bne cr6, 0x821c6ae8
	if !ctx.cr[6].eq {
	pc = 0x821C6AE8; continue 'dispatch;
	}
	// 821C6ACC: 54C9103A  slwi r9, r6, 2
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C6AD0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C6AD4: 390B00F0  addi r8, r11, 0xf0
	ctx.r[8].s64 = ctx.r[11].s64 + 240;
	// 821C6AD8: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821C6ADC: 994B0104  stb r10, 0x104(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(260 as u32), ctx.r[10].u8 ) };
	// 821C6AE0: 90DE0DB0  stw r6, 0xdb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821C6AE4: 7D09E92E  stwx r8, r9, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32), ctx.r[8].u32) };
	// 821C6AE8: 894B011D  lbz r10, 0x11d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(285 as u32) ) } as u64;
	// 821C6AEC: 80E50014  lwz r7, 0x14(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C6AF0: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s64 = ctx.r[10].s64 * 8200;
	// 821C6AF4: 812B010C  lwz r9, 0x10c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 821C6AF8: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821C6AFC: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821C6B00: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C6B04: 419A007C  beq cr6, 0x821c6b80
	if ctx.cr[6].eq {
	pc = 0x821C6B80; continue 'dispatch;
	}
	// 821C6B08: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C6B0C: 810B0110  lwz r8, 0x110(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) } as u64;
	// 821C6B10: 7D254038  and r5, r9, r8
	ctx.r[5].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C6B14: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821C6B18: 409A003C  bne cr6, 0x821c6b54
	if !ctx.cr[6].eq {
	pc = 0x821C6B54; continue 'dispatch;
	}
	// 821C6B1C: 80AA2004  lwz r5, 0x2004(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6B20: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C6B24: 390B0108  addi r8, r11, 0x108
	ctx.r[8].s64 = ctx.r[11].s64 + 264;
	// 821C6B28: 54A51838  slwi r5, r5, 3
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C6B2C: 912B0110  stw r9, 0x110(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), ctx.r[9].u32 ) };
	// 821C6B30: 7D05512E  stwx r8, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821C6B34: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6B38: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6B3C: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C6B40: 812B010C  lwz r9, 0x10c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 821C6B44: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C6B48: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6B4C: 38A90001  addi r5, r9, 1
	ctx.r[5].s64 = ctx.r[9].s64 + 1;
	// 821C6B50: 90AA2004  stw r5, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	// 821C6B54: 894B011C  lbz r10, 0x11c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) } as u64;
	// 821C6B58: 90EB010C  stw r7, 0x10c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(268 as u32), ctx.r[7].u32 ) };
	// 821C6B5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6B60: 409A0020  bne cr6, 0x821c6b80
	if !ctx.cr[6].eq {
	pc = 0x821C6B80; continue 'dispatch;
	}
	// 821C6B64: 54C9103A  slwi r9, r6, 2
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C6B68: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C6B6C: 390B0108  addi r8, r11, 0x108
	ctx.r[8].s64 = ctx.r[11].s64 + 264;
	// 821C6B70: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821C6B74: 994B011C  stb r10, 0x11c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(284 as u32), ctx.r[10].u8 ) };
	// 821C6B78: 90DE0DB0  stw r6, 0xdb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821C6B7C: 7D09E92E  stwx r8, r9, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32), ctx.r[8].u32) };
	// 821C6B80: 894B00BD  lbz r10, 0xbd(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(189 as u32) ) } as u64;
	// 821C6B84: 812B00AC  lwz r9, 0xac(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 821C6B88: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s64 = ctx.r[10].s64 * 8200;
	// 821C6B8C: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821C6B90: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 821C6B94: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C6B98: 419A0080  beq cr6, 0x821c6c18
	if ctx.cr[6].eq {
	pc = 0x821C6C18; continue 'dispatch;
	}
	// 821C6B9C: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C6BA0: 810B00B0  lwz r8, 0xb0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) } as u64;
	// 821C6BA4: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C6BA8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C6BAC: 409A003C  bne cr6, 0x821c6be8
	if !ctx.cr[6].eq {
	pc = 0x821C6BE8; continue 'dispatch;
	}
	// 821C6BB0: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6BB4: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C6BB8: 38AB00A8  addi r5, r11, 0xa8
	ctx.r[5].s64 = ctx.r[11].s64 + 168;
	// 821C6BBC: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6BC0: 912B00B0  stw r9, 0xb0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), ctx.r[9].u32 ) };
	// 821C6BC4: 7CA8512E  stwx r5, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 821C6BC8: 812B00AC  lwz r9, 0xac(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 821C6BCC: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6BD0: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6BD4: 7CA85214  add r5, r8, r10
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C6BD8: 91250004  stw r9, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C6BDC: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6BE0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821C6BE4: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	// 821C6BE8: 894B00BC  lbz r10, 0xbc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821C6BEC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821C6BF0: 912B00AC  stw r9, 0xac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(172 as u32), ctx.r[9].u32 ) };
	// 821C6BF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6BF8: 409A0020  bne cr6, 0x821c6c18
	if !ctx.cr[6].eq {
	pc = 0x821C6C18; continue 'dispatch;
	}
	// 821C6BFC: 54C9103A  slwi r9, r6, 2
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C6C00: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C6C04: 390B00A8  addi r8, r11, 0xa8
	ctx.r[8].s64 = ctx.r[11].s64 + 168;
	// 821C6C08: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821C6C0C: 994B00BC  stb r10, 0xbc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(188 as u32), ctx.r[10].u8 ) };
	// 821C6C10: 90DE0DB0  stw r6, 0xdb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821C6C14: 7D09E92E  stwx r8, r9, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32), ctx.r[8].u32) };
	// 821C6C18: 894B0045  lbz r10, 0x45(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(69 as u32) ) } as u64;
	// 821C6C1C: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C6C20: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s64 = ctx.r[10].s64 * 8200;
	// 821C6C24: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821C6C28: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C6C2C: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C6C30: 419A0080  beq cr6, 0x821c6cb0
	if ctx.cr[6].eq {
	pc = 0x821C6CB0; continue 'dispatch;
	}
	// 821C6C34: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C6C38: 810B0038  lwz r8, 0x38(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821C6C3C: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C6C40: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C6C44: 409A003C  bne cr6, 0x821c6c80
	if !ctx.cr[6].eq {
	pc = 0x821C6C80; continue 'dispatch;
	}
	// 821C6C48: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6C4C: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C6C50: 38AB0030  addi r5, r11, 0x30
	ctx.r[5].s64 = ctx.r[11].s64 + 48;
	// 821C6C54: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6C58: 912B0038  stw r9, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 821C6C5C: 7CA8512E  stwx r5, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 821C6C60: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6C64: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C6C68: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6C6C: 7CA85214  add r5, r8, r10
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C6C70: 91250004  stw r9, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C6C74: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6C78: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821C6C7C: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	// 821C6C80: 894B0044  lbz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821C6C84: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821C6C88: 912B0034  stw r9, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[9].u32 ) };
	// 821C6C8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6C90: 409A0020  bne cr6, 0x821c6cb0
	if !ctx.cr[6].eq {
	pc = 0x821C6CB0; continue 'dispatch;
	}
	// 821C6C94: 54C9103A  slwi r9, r6, 2
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C6C98: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C6C9C: 390B0030  addi r8, r11, 0x30
	ctx.r[8].s64 = ctx.r[11].s64 + 48;
	// 821C6CA0: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821C6CA4: 994B0044  stb r10, 0x44(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 821C6CA8: 90DE0DB0  stw r6, 0xdb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821C6CAC: 7D09E92E  stwx r8, r9, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32), ctx.r[8].u32) };
	// 821C6CB0: 3D008331  lis r8, -0x7ccf
	ctx.r[8].s64 = -2093940736;
	// 821C6CB4: 88EB008D  lbz r7, 0x8d(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(141 as u32) ) } as u64;
	// 821C6CB8: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C6CBC: 38A87064  addi r5, r8, 0x7064
	ctx.r[5].s64 = ctx.r[8].s64 + 28772;
	// 821C6CC0: 1D472008  mulli r10, r7, 0x2008
	ctx.r[10].s64 = ctx.r[7].s64 * 8200;
	// 821C6CC4: 80E50008  lwz r7, 8(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C6CC8: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821C6CCC: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821C6CD0: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C6CD4: 419A007C  beq cr6, 0x821c6d50
	if ctx.cr[6].eq {
	pc = 0x821C6D50; continue 'dispatch;
	}
	// 821C6CD8: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C6CDC: 810B0080  lwz r8, 0x80(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821C6CE0: 7D254038  and r5, r9, r8
	ctx.r[5].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C6CE4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821C6CE8: 409A003C  bne cr6, 0x821c6d24
	if !ctx.cr[6].eq {
	pc = 0x821C6D24; continue 'dispatch;
	}
	// 821C6CEC: 80AA2004  lwz r5, 0x2004(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6CF0: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C6CF4: 390B0078  addi r8, r11, 0x78
	ctx.r[8].s64 = ctx.r[11].s64 + 120;
	// 821C6CF8: 54A51838  slwi r5, r5, 3
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C6CFC: 912B0080  stw r9, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 821C6D00: 7D05512E  stwx r8, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821C6D04: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6D08: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6D0C: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C6D10: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C6D14: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C6D18: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6D1C: 38A90001  addi r5, r9, 1
	ctx.r[5].s64 = ctx.r[9].s64 + 1;
	// 821C6D20: 90AA2004  stw r5, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	// 821C6D24: 894B008C  lbz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C6D28: 90EB007C  stw r7, 0x7c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 821C6D2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6D30: 409A0020  bne cr6, 0x821c6d50
	if !ctx.cr[6].eq {
	pc = 0x821C6D50; continue 'dispatch;
	}
	// 821C6D34: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6D38: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C6D3C: 38EB0078  addi r7, r11, 0x78
	ctx.r[7].s64 = ctx.r[11].s64 + 120;
	// 821C6D40: 39260001  addi r9, r6, 1
	ctx.r[9].s64 = ctx.r[6].s64 + 1;
	// 821C6D44: 994B008C  stb r10, 0x8c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[10].u8 ) };
	// 821C6D48: 913E0DB0  stw r9, 0xdb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3504 as u32), ctx.r[9].u32 ) };
	// 821C6D4C: 7CE8E92E  stwx r7, r8, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[29].u32), ctx.r[7].u32) };
	// 821C6D50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C6D54: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C6D58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C6D5C: 4E800421  bctrl
	ctx.lr = 0x821C6D60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C6D60: 3D20834C  lis r9, -0x7cb4
	ctx.r[9].s64 = -2092171264;
	// 821C6D64: 3D008336  lis r8, -0x7cca
	ctx.r[8].s64 = -2093613056;
	// 821C6D68: 38E9DF40  addi r7, r9, -0x20c0
	ctx.r[7].s64 = ctx.r[9].s64 + -8384;
	// 821C6D6C: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 821C6D70: 81680364  lwz r11, 0x364(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C6D74: 8147003C  lwz r10, 0x3c(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(60 as u32) ) } as u64;
	// 821C6D78: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 821C6D7C: 914B2E2C  stw r10, 0x2e2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(11820 as u32), ctx.r[10].u32 ) };
	// 821C6D80: 914670B8  stw r10, 0x70b8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28856 as u32), ctx.r[10].u32 ) };
	// 821C6D84: E8850010  ld r4, 0x10(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	// 821C6D88: 64830008  oris r3, r4, 8
	ctx.r[3].u64 = ctx.r[4].u64 | 524288;
	// 821C6D8C: F8650010  std r3, 0x10(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[3].u64 ) };
	// 821C6D90: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821C6D94: 48AE26C4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C6D98 size=20
    let mut pc: u32 = 0x821C6D98;
    'dispatch: loop {
        match pc {
            0x821C6D98 => {
    //   block [0x821C6D98..0x821C6DAC)
	// 821C6D98: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C6D9C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821C6DA0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821C6DA4: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 821C6DA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C6DB0 size=172
    let mut pc: u32 = 0x821C6DB0;
    'dispatch: loop {
        match pc {
            0x821C6DB0 => {
    //   block [0x821C6DB0..0x821C6E5C)
	// 821C6DB0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821C6DB4: 419A0018  beq cr6, 0x821c6dcc
	if ctx.cr[6].eq {
	pc = 0x821C6DCC; continue 'dispatch;
	}
	// 821C6DB8: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C6DBC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821C6DC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C6DC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6DC8: 409A0008  bne cr6, 0x821c6dd0
	if !ctx.cr[6].eq {
	pc = 0x821C6DD0; continue 'dispatch;
	}
	// 821C6DCC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C6DD0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C6DD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C6DD8: 419A008C  beq cr6, 0x821c6e64
	if ctx.cr[6].eq {
		sub_821C6E64(ctx, base);
		return;
	}
	// 821C6DDC: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C6DE0: 39030010  addi r8, r3, 0x10
	ctx.r[8].s64 = ctx.r[3].s64 + 16;
	// 821C6DE4: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 821C6DE8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C6DEC: 7F084040  cmplw cr6, r8, r8
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821C6DF0: 419A0008  beq cr6, 0x821c6df8
	if ctx.cr[6].eq {
	pc = 0x821C6DF8; continue 'dispatch;
	}
	// 821C6DF4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C6DF8: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821C6DFC: 419A0068  beq cr6, 0x821c6e64
	if ctx.cr[6].eq {
		sub_821C6E64(ctx, base);
		return;
	}
	// 821C6E00: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C6E04: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C6E08: 409A0008  bne cr6, 0x821c6e10
	if !ctx.cr[6].eq {
	pc = 0x821C6E10; continue 'dispatch;
	}
	// 821C6E0C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C6E10: E94B0008  ld r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821C6E14: 80C40014  lwz r6, 0x14(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C6E18: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 821C6E1C: 80A1FFF0  lwz r5, -0x10(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 821C6E20: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C6E24: 409A0018  bne cr6, 0x821c6e3c
	if !ctx.cr[6].eq {
	pc = 0x821C6E3C; continue 'dispatch;
	}
	// 821C6E28: 81440018  lwz r10, 0x18(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 821C6E2C: 80C1FFF4  lwz r6, -0xc(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821C6E30: 7F065040  cmplw cr6, r6, r10
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C6E34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C6E38: 419A0008  beq cr6, 0x821c6e40
	if ctx.cr[6].eq {
	pc = 0x821C6E40; continue 'dispatch;
	}
	// 821C6E3C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C6E40: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C6E44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6E48: 409A0014  bne cr6, 0x821c6e5c
	if !ctx.cr[6].eq {
		sub_821C6E5C(ctx, base);
		return;
	}
	// 821C6E4C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C6E50: 409AFF98  bne cr6, 0x821c6de8
	if !ctx.cr[6].eq {
	pc = 0x821C6DE8; continue 'dispatch;
	}
	// 821C6E54: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C6E58: 4BFFFF90  b 0x821c6de8
	pc = 0x821C6DE8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6E5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C6E5C size=8
    let mut pc: u32 = 0x821C6E5C;
    'dispatch: loop {
        match pc {
            0x821C6E5C => {
    //   block [0x821C6E5C..0x821C6E64)
	// 821C6E5C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C6E60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6E64(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C6E64 size=8
    let mut pc: u32 = 0x821C6E64;
    'dispatch: loop {
        match pc {
            0x821C6E64 => {
    //   block [0x821C6E64..0x821C6E6C)
	// 821C6E64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C6E68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C6E70 size=236
    let mut pc: u32 = 0x821C6E70;
    'dispatch: loop {
        match pc {
            0x821C6E70 => {
    //   block [0x821C6E70..0x821C6F5C)
	// 821C6E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C6E74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C6E78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C6E7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C6E80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C6E84: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821C6E88: 409A0020  bne cr6, 0x821c6ea8
	if !ctx.cr[6].eq {
	pc = 0x821C6EA8; continue 'dispatch;
	}
	// 821C6E8C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C6E90: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C6E94: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821C6E98: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C6E9C: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 821C6EA0: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821C6EA4: 4800002C  b 0x821c6ed0
	pc = 0x821C6ED0; continue 'dispatch;
	// 821C6EA8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821C6EAC: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C6EB0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C6EB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6EB8: 409AFFF4  bne cr6, 0x821c6eac
	if !ctx.cr[6].eq {
	pc = 0x821C6EAC; continue 'dispatch;
	}
	// 821C6EBC: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 821C6EC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C6EC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C6EC8: 5565003E  slwi r5, r11, 0
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C6ECC: 4885D60D  bl 0x82a244d8
	ctx.lr = 0x821C6ED0;
	sub_82A244D8(ctx, base);
	// 821C6ED0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C6ED4: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 821C6ED8: 806BFFF0  lwz r3, -0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 821C6EDC: 480615FD  bl 0x822284d8
	ctx.lr = 0x821C6EE0;
	sub_822284D8(ctx, base);
	// 821C6EE0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C6EE4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821C6EE8: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C6EEC: 392A9700  addi r9, r10, -0x6900
	ctx.r[9].s64 = ctx.r[10].s64 + -26880;
	// 821C6EF0: 910BFFF8  stw r8, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[8].u32 ) };
	// 821C6EF4: 80E30004  lwz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C6EF8: 90EBFFFC  stw r7, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[7].u32 ) };
	// 821C6EFC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C6F00: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 821C6F04: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C6F08: 419A0030  beq cr6, 0x821c6f38
	if ctx.cr[6].eq {
	pc = 0x821C6F38; continue 'dispatch;
	}
	// 821C6F0C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C6F10: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821C6F14: 409A0024  bne cr6, 0x821c6f38
	if !ctx.cr[6].eq {
	pc = 0x821C6F38; continue 'dispatch;
	}
	// 821C6F18: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 821C6F1C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C6F20: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821C6F24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C6F28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C6F2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C6F30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C6F34: 4E800020  blr
	return;
	// 821C6F38: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 821C6F3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C6F40: 48019449  bl 0x821e0388
	ctx.lr = 0x821C6F44;
	sub_821E0388(ctx, base);
	// 821C6F44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C6F48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C6F4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C6F50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C6F54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C6F58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821C6F60 size=28
    let mut pc: u32 = 0x821C6F60;
    'dispatch: loop {
        match pc {
            0x821C6F60 => {
    //   block [0x821C6F60..0x821C6F7C)
	// 821C6F60: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C6F64: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821C6F68: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C6F6C: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821C6F70: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C6F74: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821C6F78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C6F80 size=224
    let mut pc: u32 = 0x821C6F80;
    'dispatch: loop {
        match pc {
            0x821C6F80 => {
    //   block [0x821C6F80..0x821C7060)
	// 821C6F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C6F84: 48AE2485  bl 0x82ca9408
	ctx.lr = 0x821C6F88;
	sub_82CA93D0(ctx, base);
	// 821C6F88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C6F8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C6F90: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821C6F94: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821C6F98: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C6F9C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821C6FA0: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C6FA4: 393F0020  addi r9, r31, 0x20
	ctx.r[9].s64 = ctx.r[31].s64 + 32;
	// 821C6FA8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821C6FAC: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 821C6FB0: E91E0020  ld r8, 0x20(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	// 821C6FB4: F91F0020  std r8, 0x20(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[8].u64 ) };
	// 821C6FB8: E8FE0028  ld r7, 0x28(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	// 821C6FBC: F8FF0028  std r7, 0x28(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[7].u64 ) };
	// 821C6FC0: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 821C6FC4: 40990094  ble cr6, 0x821c7058
	if !ctx.cr[6].gt {
	pc = 0x821C7058; continue 'dispatch;
	}
	// 821C6FC8: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 821C6FCC: 4883E025  bl 0x82a04ff0
	ctx.lr = 0x821C6FD0;
	sub_82A04FF0(ctx, base);
	// 821C6FD0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821C6FD4: 419A006C  beq cr6, 0x821c7040
	if ctx.cr[6].eq {
	pc = 0x821C7040; continue 'dispatch;
	}
	// 821C6FD8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821C6FDC: 419A007C  beq cr6, 0x821c7058
	if ctx.cr[6].eq {
	pc = 0x821C7058; continue 'dispatch;
	}
	// 821C6FE0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821C6FE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821C6FE8: 811C0004  lwz r8, 4(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C6FEC: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 821C6FF0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C6FF4: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C6FF8: 7CEB2A14  add r7, r11, r5
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 821C6FFC: 7D68302E  lwzx r11, r8, r6
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821C7000: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C7004: 7C8B4214  add r4, r11, r8
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 821C7008: 548B2036  slwi r11, r4, 4
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C700C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821C7010: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C7014: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821C7018: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821C701C: F9470000  std r10, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 821C7020: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 821C7024: 4200FFF0  bdnz 0x821c7014
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821C7014; continue 'dispatch;
	}
	// 821C7028: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821C702C: 38C60008  addi r6, r6, 8
	ctx.r[6].s64 = ctx.r[6].s64 + 8;
	// 821C7030: 38A50030  addi r5, r5, 0x30
	ctx.r[5].s64 = ctx.r[5].s64 + 48;
	// 821C7034: 4082FFB4  bne 0x821c6fe8
	if !ctx.cr[0].eq {
	pc = 0x821C6FE8; continue 'dispatch;
	}
	// 821C7038: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821C703C: 48AE241C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821C7040: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C7044: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7048: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C704C: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821C7050: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C7054: 48041445  bl 0x82208498
	ctx.lr = 0x821C7058;
	sub_82208498(ctx, base);
	// 821C7058: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821C705C: 48AE23FC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7060 size=280
    let mut pc: u32 = 0x821C7060;
    'dispatch: loop {
        match pc {
            0x821C7060 => {
    //   block [0x821C7060..0x821C7178)
	// 821C7060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7064: 48AE239D  bl 0x82ca9400
	ctx.lr = 0x821C7068;
	sub_82CA93D0(ctx, base);
	// 821C7068: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C706C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821C7070: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821C7074: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821C7078: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821C707C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 821C7080: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 821C7084: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821C7088: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C708C: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821C7090: 419A0020  beq cr6, 0x821c70b0
	if ctx.cr[6].eq {
	pc = 0x821C70B0; continue 'dispatch;
	}
	// 821C7094: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C7098: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 821C709C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821C70A0: 4198FFE8  blt cr6, 0x821c7088
	if ctx.cr[6].lt {
	pc = 0x821C7088; continue 'dispatch;
	}
	// 821C70A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C70A8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821C70AC: 48AE23A4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 821C70B0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C70B4: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821C70B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C70BC: 409A0074  bne cr6, 0x821c7130
	if !ctx.cr[6].eq {
	pc = 0x821C7130; continue 'dispatch;
	}
	// 821C70C0: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 821C70C4: 48058195  bl 0x8221f258
	ctx.lr = 0x821C70C8;
	sub_8221F258(ctx, base);
	// 821C70C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C70CC: 419A005C  beq cr6, 0x821c7128
	if ctx.cr[6].eq {
	pc = 0x821C7128; continue 'dispatch;
	}
	// 821C70D0: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 821C70D4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821C70D8: 392BFF08  addi r9, r11, -0xf8
	ctx.r[9].s64 = ctx.r[11].s64 + -248;
	// 821C70DC: 390A9160  addi r8, r10, -0x6ea0
	ctx.r[8].s64 = ctx.r[10].s64 + -28320;
	// 821C70E0: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821C70E4: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821C70E8: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821C70EC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821C70F0: 93C3000C  stw r30, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 821C70F4: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 821C70F8: 93C30010  stw r30, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 821C70FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821C7100: 93C30014  stw r30, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7178 size=264
    let mut pc: u32 = 0x821C7178;
    'dispatch: loop {
        match pc {
            0x821C7178 => {
    //   block [0x821C7178..0x821C7280)
	// 821C7178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C717C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C7180: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C7184: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C7188: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C718C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C7190: 817E0170  lwz r11, 0x170(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(368 as u32) ) } as u64;
	// 821C7194: 83EB0038  lwz r31, 0x38(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821C7198: 895F0038  lbz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821C719C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C71A0: 419A00C8  beq cr6, 0x821c7268
	if ctx.cr[6].eq {
	pc = 0x821C7268; continue 'dispatch;
	}
	// 821C71A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821C71A8: 809E00E8  lwz r4, 0xe8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) } as u64;
	// 821C71AC: 4906AAED  bl 0x83231c98
	ctx.lr = 0x821C71B0;
	sub_83231C98(ctx, base);
	// 821C71B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C71B4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821C71B8: E8A30000  ld r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821C71BC: 38EB9060  addi r7, r11, -0x6fa0
	ctx.r[7].s64 = ctx.r[11].s64 + -28576;
	// 821C71C0: E8630008  ld r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 821C71C4: 38C99160  addi r6, r9, -0x6ea0
	ctx.r[6].s64 = ctx.r[9].s64 + -28320;
	// 821C71C8: 817E0168  lwz r11, 0x168(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(360 as u32) ) } as u64;
	// 821C71CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821C71D0: E95F0040  ld r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	// 821C71D4: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821C71D8: E91F0048  ld r8, 0x48(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	// 821C71DC: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7280 size=392
    let mut pc: u32 = 0x821C7280;
    'dispatch: loop {
        match pc {
            0x821C7280 => {
    //   block [0x821C7280..0x821C7408)
	// 821C7280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C7288: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C728C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C7290: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C7294: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821C7298: 419A0018  beq cr6, 0x821c72b0
	if ctx.cr[6].eq {
	pc = 0x821C72B0; continue 'dispatch;
	}
	// 821C729C: 89650090  lbz r11, 0x90(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C72A0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821C72A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C72A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C72AC: 409A0008  bne cr6, 0x821c72b4
	if !ctx.cr[6].eq {
	pc = 0x821C72B4; continue 'dispatch;
	}
	// 821C72B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C72B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C72B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C72BC: 419A0134  beq cr6, 0x821c73f0
	if ctx.cr[6].eq {
	pc = 0x821C73F0; continue 'dispatch;
	}
	// 821C72C0: 81450028  lwz r10, 0x28(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) } as u64;
	// 821C72C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C72C8: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 821C72CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C72D0: 419A00EC  beq cr6, 0x821c73bc
	if ctx.cr[6].eq {
	pc = 0x821C73BC; continue 'dispatch;
	}
	// 821C72D4: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C72D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C72DC: 419A0020  beq cr6, 0x821c72fc
	if ctx.cr[6].eq {
	pc = 0x821C72FC; continue 'dispatch;
	}
	// 821C72E0: 894B0022  lbz r10, 0x22(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(34 as u32) ) } as u64;
	// 821C72E4: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C72E8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821C72EC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C72F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C72F4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C72F8: 480000C8  b 0x821c73c0
	pc = 0x821C73C0; continue 'dispatch;
	// 821C72FC: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C7300: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C7304: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C7308: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821C730C: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C7310: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C7314: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C7318: 40810054  ble 0x821c736c
	if !ctx.cr[0].gt {
	pc = 0x821C736C; continue 'dispatch;
	}
	// 821C731C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C7320: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C7324: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C7328: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C732C: 2F070022  cmpwi cr6, r7, 0x22
	ctx.cr[6].compare_i32(ctx.r[7].s32, 34, &mut ctx.xer);
	// 821C7330: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C7334: 41980008  blt cr6, 0x821c733c
	if ctx.cr[6].lt {
	pc = 0x821C733C; continue 'dispatch;
	}
	// 821C7338: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821C733C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C7340: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C7344: 419A0014  beq cr6, 0x821c7358
	if ctx.cr[6].eq {
	pc = 0x821C7358; continue 'dispatch;
	}
	// 821C7348: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C734C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C7350: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C7354: 4800000C  b 0x821c7360
	pc = 0x821C7360; continue 'dispatch;
	// 821C7358: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C735C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821C7360: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C7364: 4199FFB8  bgt cr6, 0x821c731c
	if ctx.cr[6].gt {
	pc = 0x821C731C; continue 'dispatch;
	}
	// 821C7368: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C736C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C7370: 419A003C  beq cr6, 0x821c73ac
	if ctx.cr[6].eq {
	pc = 0x821C73AC; continue 'dispatch;
	}
	// 821C7374: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7378: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 821C737C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C7380: 41990008  bgt cr6, 0x821c7388
	if ctx.cr[6].gt {
	pc = 0x821C7388; continue 'dispatch;
	}
	// 821C7384: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C7388: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C738C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7390: 409A001C  bne cr6, 0x821c73ac
	if !ctx.cr[6].eq {
	pc = 0x821C73AC; continue 'dispatch;
	}
	// 821C7394: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C7398: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C739C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C73A0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C73A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C73A8: 48000018  b 0x821c73c0
	pc = 0x821C73C0; continue 'dispatch;
	// 821C73AC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C73B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C73B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C73B8: 48000008  b 0x821c73c0
	pc = 0x821C73C0; continue 'dispatch;
	// 821C73BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C73C0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C73C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C73C8: 419A0028  beq cr6, 0x821c73f0
	if ctx.cr[6].eq {
	pc = 0x821C73F0; continue 'dispatch;
	}
	// 821C73CC: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C73D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C73D4: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C73D8: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C73DC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821C73E0: 4E800421  bctrl
	ctx.lr = 0x821C73E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C73E4: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7408 size=132
    let mut pc: u32 = 0x821C7408;
    'dispatch: loop {
        match pc {
            0x821C7408 => {
    //   block [0x821C7408..0x821C748C)
	// 821C7408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C740C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C7410: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C7414: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C7418: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C741C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C7420: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 821C7424: 3BCAFFDF  addi r30, r10, -0x21
	ctx.r[30].s64 = ctx.r[10].s64 + -33;
	// 821C7428: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C742C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C7430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7434: 419A0008  beq cr6, 0x821c743c
	if ctx.cr[6].eq {
	pc = 0x821C743C; continue 'dispatch;
	}
	// 821C7438: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C743C: 7C840774  extsb r4, r4
	ctx.r[4].s64 = ctx.r[4].s8 as i64;
	// 821C7440: 48AE2DD1  bl 0x82caa210
	ctx.lr = 0x821C7444;
	sub_82CAA210(ctx, base);
	// 821C7444: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C7448: 419A0028  beq cr6, 0x821c7470
	if ctx.cr[6].eq {
	pc = 0x821C7470; continue 'dispatch;
	}
	// 821C744C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7450: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7454: 409A0010  bne cr6, 0x821c7464
	if !ctx.cr[6].eq {
	pc = 0x821C7464; continue 'dispatch;
	}
	// 821C7458: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821C745C: 7C6B1850  subf r3, r11, r3
	ctx.r[3].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821C7460: 48000014  b 0x821c7474
	pc = 0x821C7474; continue 'dispatch;
	// 821C7464: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7468: 7C6B1850  subf r3, r11, r3
	ctx.r[3].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821C746C: 48000008  b 0x821c7474
	pc = 0x821C7474; continue 'dispatch;
	// 821C7470: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 821C7474: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C7478: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C747C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C7480: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C7484: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C7488: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7490 size=248
    let mut pc: u32 = 0x821C7490;
    'dispatch: loop {
        match pc {
            0x821C7490 => {
    //   block [0x821C7490..0x821C7588)
	// 821C7490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C7498: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C749C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C74A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C74A4: 89630020  lbz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C74A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C74AC: 419A00C0  beq cr6, 0x821c756c
	if ctx.cr[6].eq {
	pc = 0x821C756C; continue 'dispatch;
	}
	// 821C74B0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C74B4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C74B8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C74BC: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821C74C0: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C74C4: 81680068  lwz r11, 0x68(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(104 as u32) ) } as u64;
	// 821C74C8: 88EB004B  lbz r7, 0x4b(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(75 as u32) ) } as u64;
	// 821C74CC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C74D0: 419A000C  beq cr6, 0x821c74dc
	if ctx.cr[6].eq {
	pc = 0x821C74DC; continue 'dispatch;
	}
	// 821C74D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C74D8: 48000008  b 0x821c74e0
	pc = 0x821C74E0; continue 'dispatch;
	// 821C74DC: 896B0049  lbz r11, 0x49(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(73 as u32) ) } as u64;
	// 821C74E0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C74E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C74E8: 419A0084  beq cr6, 0x821c756c
	if ctx.cr[6].eq {
	pc = 0x821C756C; continue 'dispatch;
	}
	// 821C74EC: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C74F0: 3BC3000C  addi r30, r3, 0xc
	ctx.r[30].s64 = ctx.r[3].s64 + 12;
	// 821C74F4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C74F8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C74FC: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821C7500: 419A0008  beq cr6, 0x821c7508
	if ctx.cr[6].eq {
	pc = 0x821C7508; continue 'dispatch;
	}
	// 821C7504: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C7508: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C750C: 419A0060  beq cr6, 0x821c756c
	if ctx.cr[6].eq {
	pc = 0x821C756C; continue 'dispatch;
	}
	// 821C7510: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7514: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C7518: 409A0008  bne cr6, 0x821c7520
	if !ctx.cr[6].eq {
	pc = 0x821C7520; continue 'dispatch;
	}
	// 821C751C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C7520: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7524: 8963000D  lbz r11, 0xd(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 821C7528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C752C: 409A0020  bne cr6, 0x821c754c
	if !ctx.cr[6].eq {
	pc = 0x821C754C; continue 'dispatch;
	}
	// 821C7530: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7534: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7538: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C753C: 4E800421  bctrl
	ctx.lr = 0x821C7540;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C7540: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C7544: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C7548: 409A001C  bne cr6, 0x821c7564
	if !ctx.cr[6].eq {
	pc = 0x821C7564; continue 'dispatch;
	}
	// 821C754C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7550: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C7554: 409A0008  bne cr6, 0x821c755c
	if !ctx.cr[6].eq {
	pc = 0x821C755C; continue 'dispatch;
	}
	// 821C7558: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C755C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7560: 4BFFFF98  b 0x821c74f8
	pc = 0x821C74F8; continue 'dispatch;
	// 821C7564: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C7568: 48000008  b 0x821c7570
	pc = 0x821C7570; continue 'dispatch;
	// 821C756C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C7570: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C7574: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C7578: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C757C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C7580: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C7584: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7588 size=504
    let mut pc: u32 = 0x821C7588;
    'dispatch: loop {
        match pc {
            0x821C7588 => {
    //   block [0x821C7588..0x821C7780)
	// 821C7588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C758C: 48AE1E81  bl 0x82ca940c
	ctx.lr = 0x821C7590;
	sub_82CA93D0(ctx, base);
	// 821C7590: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C7594: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C7598: 4BFFFEF9  bl 0x821c7490
	ctx.lr = 0x821C759C;
	sub_821C7490(ctx, base);
	// 821C759C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C75A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C75A4: 419A01D0  beq cr6, 0x821c7774
	if ctx.cr[6].eq {
	pc = 0x821C7774; continue 'dispatch;
	}
	// 821C75A8: 897E0020  lbz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C75AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C75B0: 419A01C4  beq cr6, 0x821c7774
	if ctx.cr[6].eq {
	pc = 0x821C7774; continue 'dispatch;
	}
	// 821C75B4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C75B8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C75BC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C75C0: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821C75C4: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C75C8: 816A0068  lwz r11, 0x68(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(104 as u32) ) } as u64;
	// 821C75CC: 890B004B  lbz r8, 0x4b(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(75 as u32) ) } as u64;
	// 821C75D0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821C75D4: 419A000C  beq cr6, 0x821c75e0
	if ctx.cr[6].eq {
	pc = 0x821C75E0; continue 'dispatch;
	}
	// 821C75D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C75DC: 48000008  b 0x821c75e4
	pc = 0x821C75E4; continue 'dispatch;
	// 821C75E0: 896B0049  lbz r11, 0x49(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(73 as u32) ) } as u64;
	// 821C75E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C75E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C75EC: 419A0188  beq cr6, 0x821c7774
	if ctx.cr[6].eq {
	pc = 0x821C7774; continue 'dispatch;
	}
	// 821C75F0: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C75F4: 48064BC5  bl 0x8222c1b8
	ctx.lr = 0x821C75F8;
	sub_8222C1B8(ctx, base);
	// 821C75F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C75FC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821C7600: 419A0018  beq cr6, 0x821c7618
	if ctx.cr[6].eq {
	pc = 0x821C7618; continue 'dispatch;
	}
	// 821C7604: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C7608: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821C760C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C7610: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C7614: 409A0008  bne cr6, 0x821c761c
	if !ctx.cr[6].eq {
	pc = 0x821C761C; continue 'dispatch;
	}
	// 821C7618: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C761C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C7620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7624: 419A0150  beq cr6, 0x821c7774
	if ctx.cr[6].eq {
	pc = 0x821C7774; continue 'dispatch;
	}
	// 821C7628: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C762C: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7630: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821C7634: 806B0020  lwz r3, 0x20(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C7638: 480FFD21  bl 0x822c7358
	ctx.lr = 0x821C763C;
	sub_822C7358(ctx, base);
	// 821C763C: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821C7640: 419A0134  beq cr6, 0x821c7774
	if ctx.cr[6].eq {
	pc = 0x821C7774; continue 'dispatch;
	}
	// 821C7644: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C7648: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C764C: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821C7650: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C7654: 419A00EC  beq cr6, 0x821c7740
	if ctx.cr[6].eq {
	pc = 0x821C7740; continue 'dispatch;
	}
	// 821C7658: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C765C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7660: 419A0020  beq cr6, 0x821c7680
	if ctx.cr[6].eq {
	pc = 0x821C7680; continue 'dispatch;
	}
	// 821C7664: 894B0085  lbz r10, 0x85(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(133 as u32) ) } as u64;
	// 821C7668: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C766C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821C7670: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C7674: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C7678: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C767C: 480000C8  b 0x821c7744
	pc = 0x821C7744; continue 'dispatch;
	// 821C7680: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C7684: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C7688: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C768C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821C7690: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C7694: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C7698: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C769C: 40810054  ble 0x821c76f0
	if !ctx.cr[0].gt {
	pc = 0x821C76F0; continue 'dispatch;
	}
	// 821C76A0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C76A4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C76A8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C76AC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C76B0: 2F070085  cmpwi cr6, r7, 0x85
	ctx.cr[6].compare_i32(ctx.r[7].s32, 133, &mut ctx.xer);
	// 821C76B4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C76B8: 41980008  blt cr6, 0x821c76c0
	if ctx.cr[6].lt {
	pc = 0x821C76C0; continue 'dispatch;
	}
	// 821C76BC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821C76C0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C76C4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C76C8: 419A0014  beq cr6, 0x821c76dc
	if ctx.cr[6].eq {
	pc = 0x821C76DC; continue 'dispatch;
	}
	// 821C76CC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C76D0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C76D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C76D8: 4800000C  b 0x821c76e4
	pc = 0x821C76E4; continue 'dispatch;
	// 821C76DC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C76E0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821C76E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C76E8: 4199FFB8  bgt cr6, 0x821c76a0
	if ctx.cr[6].gt {
	pc = 0x821C76A0; continue 'dispatch;
	}
	// 821C76EC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C76F0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C76F4: 419A003C  beq cr6, 0x821c7730
	if ctx.cr[6].eq {
	pc = 0x821C7730; continue 'dispatch;
	}
	// 821C76F8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C76FC: 2F0B0085  cmpwi cr6, r11, 0x85
	ctx.cr[6].compare_i32(ctx.r[11].s32, 133, &mut ctx.xer);
	// 821C7700: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C7704: 41990008  bgt cr6, 0x821c770c
	if ctx.cr[6].gt {
	pc = 0x821C770C; continue 'dispatch;
	}
	// 821C7708: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C770C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C7710: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7714: 409A001C  bne cr6, 0x821c7730
	if !ctx.cr[6].eq {
	pc = 0x821C7730; continue 'dispatch;
	}
	// 821C7718: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C771C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C7720: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C7724: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C7728: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C772C: 48000018  b 0x821c7744
	pc = 0x821C7744; continue 'dispatch;
	// 821C7730: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C7734: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C7738: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C773C: 48000008  b 0x821c7744
	pc = 0x821C7744; continue 'dispatch;
	// 821C7740: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C7744: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C7748: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C774C: 419A0028  beq cr6, 0x821c7774
	if ctx.cr[6].eq {
	pc = 0x821C7774; continue 'dispatch;
	}
	// 821C7750: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C7754: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7758: 4803C841  bl 0x82203f98
	ctx.lr = 0x821C775C;
	sub_82203F98(ctx, base);
	// 821C775C: 3963FFFC  addi r11, r3, -4
	ctx.r[11].s64 = ctx.r[3].s64 + -4;
	// 821C7760: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821C7764: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821C7768: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 821C776C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821C7770: 48AE1CEC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821C7774: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C7778: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821C777C: 48AE1CE0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7780 size=644
    let mut pc: u32 = 0x821C7780;
    'dispatch: loop {
        match pc {
            0x821C7780 => {
    //   block [0x821C7780..0x821C7A04)
	// 821C7780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7784: 48AE1C85  bl 0x82ca9408
	ctx.lr = 0x821C7788;
	sub_82CA93D0(ctx, base);
	// 821C7788: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C778C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C7790: 4BFFFDF9  bl 0x821c7588
	ctx.lr = 0x821C7794;
	sub_821C7588(ctx, base);
	// 821C7794: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C7798: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C779C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C77A0: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C77A4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C77A8: 83C900A8  lwz r30, 0xa8(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(168 as u32) ) } as u64;
	// 821C77AC: 419A00DC  beq cr6, 0x821c7888
	if ctx.cr[6].eq {
	pc = 0x821C7888; continue 'dispatch;
	}
	// 821C77B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C77B4: 48415C15  bl 0x825dd3c8
	ctx.lr = 0x821C77B8;
	sub_825DD3C8(ctx, base);
	// 821C77B8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C77BC: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C77C0: 7D690034  cntlzw r9, r11
	ctx.r[9].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821C77C4: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 821C77C8: 690B0001  xori r11, r8, 1
	ctx.r[11].u64 = ctx.r[8].u64 ^ 1;
	// 821C77CC: 396B0032  addi r11, r11, 0x32
	ctx.r[11].s64 = ctx.r[11].s64 + 50;
	// 821C77D0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821C77D4: 419A00C8  beq cr6, 0x821c789c
	if ctx.cr[6].eq {
	pc = 0x821C789C; continue 'dispatch;
	}
	// 821C77D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C77DC: 48415BED  bl 0x825dd3c8
	ctx.lr = 0x821C77E0;
	sub_825DD3C8(ctx, base);
	// 821C77E0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C77E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C77E8: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821C77EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C77F0: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821C77F4: 692B0001  xori r11, r9, 1
	ctx.r[11].u64 = ctx.r[9].u64 ^ 1;
	// 821C77F8: 396B0032  addi r11, r11, 0x32
	ctx.r[11].s64 = ctx.r[11].s64 + 50;
	// 821C77FC: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821C7800: 48417671  bl 0x825dee70
	ctx.lr = 0x821C7804;
	sub_825DEE70(ctx, base);
	// 821C7804: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821C7808: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 821C780C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C7810: 38870AF8  addi r4, r7, 0xaf8
	ctx.r[4].s64 = ctx.r[7].s64 + 2808;
	// 821C7814: 81686B08  lwz r11, 0x6b08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821C7818: 80CB0020  lwz r6, 0x20(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C781C: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7820: 8386001C  lwz r28, 0x1c(r6)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C7824: 4810EBE5  bl 0x822d6408
	ctx.lr = 0x821C7828;
	sub_822D6408(ctx, base);
	// 821C7828: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821C782C: 80FF001C  lwz r7, 0x1c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C7830: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821C7834: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 821C7838: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821C783C: 48215E75  bl 0x823dd6b0
	ctx.lr = 0x821C7840;
	sub_823DD6B0(ctx, base);
	// 821C7840: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C7844: 4BFFEFB5  bl 0x821c67f8
	ctx.lr = 0x821C7848;
	sub_821C67F8(ctx, base);
	// 821C7848: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 821C784C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821C7850: 38840CA0  addi r4, r4, 0xca0
	ctx.r[4].s64 = ctx.r[4].s64 + 3232;
	// 821C7854: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C7858: 48065679  bl 0x8222ced0
	ctx.lr = 0x821C785C;
	sub_8222CED0(ctx, base);
	// 821C785C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 821C7860: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821C7864: 80FF001C  lwz r7, 0x1c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C7868: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821C786C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821C7870: 48215CA9  bl 0x823dd518
	ctx.lr = 0x821C7874;
	sub_823DD518(ctx, base);
	// 821C7874: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C7878: 4804D561  bl 0x82214dd8
	ctx.lr = 0x821C787C;
	sub_82214DD8(ctx, base);
	// 821C787C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C7880: 4804D559  bl 0x82214dd8
	ctx.lr = 0x821C7884;
	sub_82214DD8(ctx, base);
	// 821C7884: 48000018  b 0x821c789c
	pc = 0x821C789C; continue 'dispatch;
	// 821C7888: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C788C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C7890: 419A000C  beq cr6, 0x821c789c
	if ctx.cr[6].eq {
	pc = 0x821C789C; continue 'dispatch;
	}
	// 821C7894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C7898: 48415601  bl 0x825dce98
	ctx.lr = 0x821C789C;
	sub_825DCE98(ctx, base);
	// 821C789C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C78A0: 4BFFFBF1  bl 0x821c7490
	ctx.lr = 0x821C78A4;
	sub_821C7490(ctx, base);
	// 821C78A4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C78A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C78AC: 419A0150  beq cr6, 0x821c79fc
	if ctx.cr[6].eq {
	pc = 0x821C79FC; continue 'dispatch;
	}
	// 821C78B0: 388000E2  li r4, 0xe2
	ctx.r[4].s64 = 226;
	// 821C78B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C78B8: 48288FB9  bl 0x82450870
	ctx.lr = 0x821C78BC;
	sub_82450870(ctx, base);
	// 821C78BC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C78C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C78C4: 409A0138  bne cr6, 0x821c79fc
	if !ctx.cr[6].eq {
	pc = 0x821C79FC; continue 'dispatch;
	}
	// 821C78C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C78CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C78D0: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821C78D4: 55494FFE  rlwinm r9, r10, 9, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x007FFFFFu64;
	// 821C78D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C78DC: 419A00F4  beq cr6, 0x821c79d0
	if ctx.cr[6].eq {
	pc = 0x821C79D0; continue 'dispatch;
	}
	// 821C78E0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C78E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C78E8: 419A0024  beq cr6, 0x821c790c
	if ctx.cr[6].eq {
	pc = 0x821C790C; continue 'dispatch;
	}
	// 821C78EC: 894A0017  lbz r10, 0x17(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(23 as u32) ) } as u64;
	// 821C78F0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C78F4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821C78F8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C78FC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7900: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C7904: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C7908: 480000CC  b 0x821c79d4
	pc = 0x821C79D4; continue 'dispatch;
	// 821C790C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C7910: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C7914: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 821C7918: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C791C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821C7920: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C7924: 40810054  ble 0x821c7978
	if !ctx.cr[0].gt {
	pc = 0x821C7978; continue 'dispatch;
	}
	// 821C7928: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C792C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C7930: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C7934: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7938: 2F070017  cmpwi cr6, r7, 0x17
	ctx.cr[6].compare_i32(ctx.r[7].s32, 23, &mut ctx.xer);
	// 821C793C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C7940: 41980008  blt cr6, 0x821c7948
	if ctx.cr[6].lt {
	pc = 0x821C7948; continue 'dispatch;
	}
	// 821C7944: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821C7948: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C794C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C7950: 419A0014  beq cr6, 0x821c7964
	if ctx.cr[6].eq {
	pc = 0x821C7964; continue 'dispatch;
	}
	// 821C7954: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C7958: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C795C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C7960: 4800000C  b 0x821c796c
	pc = 0x821C796C; continue 'dispatch;
	// 821C7964: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C7968: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821C796C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C7970: 4199FFB8  bgt cr6, 0x821c7928
	if ctx.cr[6].gt {
	pc = 0x821C7928; continue 'dispatch;
	}
	// 821C7974: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821C7978: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C797C: 419A0040  beq cr6, 0x821c79bc
	if ctx.cr[6].eq {
	pc = 0x821C79BC; continue 'dispatch;
	}
	// 821C7980: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7984: 2F0B0017  cmpwi cr6, r11, 0x17
	ctx.cr[6].compare_i32(ctx.r[11].s32, 23, &mut ctx.xer);
	// 821C7988: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C798C: 41990008  bgt cr6, 0x821c7994
	if ctx.cr[6].gt {
	pc = 0x821C7994; continue 'dispatch;
	}
	// 821C7990: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821C7994: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C7998: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C799C: 409A0020  bne cr6, 0x821c79bc
	if !ctx.cr[6].eq {
	pc = 0x821C79BC; continue 'dispatch;
	}
	// 821C79A0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821C79A4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821C79A8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821C79AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C79B0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C79B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C79B8: 4800001C  b 0x821c79d4
	pc = 0x821C79D4; continue 'dispatch;
	// 821C79BC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C79C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C79C4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C79C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C79CC: 48000008  b 0x821c79d4
	pc = 0x821C79D4; continue 'dispatch;
	// 821C79D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821C79D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C79D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C79DC: 419A0020  beq cr6, 0x821c79fc
	if ctx.cr[6].eq {
	pc = 0x821C79FC; continue 'dispatch;
	}
	// 821C79E0: 480CD6D1  bl 0x822950b0
	ctx.lr = 0x821C79E4;
	sub_822950B0(ctx, base);
	// 821C79E4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C79E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C79EC: 419A0010  beq cr6, 0x821c79fc
	if ctx.cr[6].eq {
	pc = 0x821C79FC; continue 'dispatch;
	}
	// 821C79F0: 388000E2  li r4, 0xe2
	ctx.r[4].s64 = 226;
	// 821C79F4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C79F8: 4BFED869  bl 0x821b5260
	ctx.lr = 0x821C79FC;
	sub_821B5260(ctx, base);
	// 821C79FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821C7A00: 48AE1A58  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C7A08 size=244
    let mut pc: u32 = 0x821C7A08;
    'dispatch: loop {
        match pc {
            0x821C7A08 => {
    //   block [0x821C7A08..0x821C7AFC)
	// 821C7A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7A0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C7A10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C7A14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C7A18: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C7A1C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821C7A20: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C7A24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821C7A28: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7A2C: C0230020  lfs f1, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C7A30: 480109E9  bl 0x821d8418
	ctx.lr = 0x821C7A34;
	sub_821D8418(ctx, base);
	// 821C7A34: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 821C7A38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821C7A3C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821C7A40: 48053151  bl 0x8221ab90
	ctx.lr = 0x821C7A44;
	sub_8221AB90(ctx, base);
	// 821C7A44: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C7A48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7A4C: 409A002C  bne cr6, 0x821c7a78
	if !ctx.cr[6].eq {
	pc = 0x821C7A78; continue 'dispatch;
	}
	// 821C7A50: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 821C7A54: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 821C7A58: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821C7A5C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821C7A60: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821C7A64: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821C7A68: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821C7A6C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C7A70: 4200FFF0  bdnz 0x821c7a60
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821C7A60; continue 'dispatch;
	}
	// 821C7A74: 4800006C  b 0x821c7ae0
	pc = 0x821C7AE0; continue 'dispatch;
	// 821C7A78: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C7A7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821C7A80: C0230020  lfs f1, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C7A84: 48010995  bl 0x821d8418
	ctx.lr = 0x821C7A88;
	sub_821D8418(ctx, base);
	// 821C7A88: 38BF0060  addi r5, r31, 0x60
	ctx.r[5].s64 = ctx.r[31].s64 + 96;
	// 821C7A8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821C7A90: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 821C7A94: 480530FD  bl 0x8221ab90
	ctx.lr = 0x821C7A98;
	sub_8221AB90(ctx, base);
	// 821C7A98: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 821C7A9C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 821C7AA0: C03F00A8  lfs f1, 0xa8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C7AA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C7AA8: 486C7961  bl 0x8288f408
	ctx.lr = 0x821C7AAC;
	sub_8288F408(ctx, base);
	// 821C7AAC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C7AB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C7AB4: C02B9054  lfs f1, -0x6fac(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28588 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C7AB8: 480ADE41  bl 0x822758f8
	ctx.lr = 0x821C7ABC;
	sub_822758F8(ctx, base);
	// 821C7ABC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821C7AC0: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 821C7AC4: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821C7AC8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821C7ACC: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821C7AD0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821C7AD4: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821C7AD8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C7ADC: 4200FFF0  bdnz 0x821c7acc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821C7ACC; continue 'dispatch;
	}
	// 821C7AE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C7AE4: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 821C7AE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C7AEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C7AF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C7AF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C7AF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821C7B00 size=92
    let mut pc: u32 = 0x821C7B00;
    'dispatch: loop {
        match pc {
            0x821C7B00 => {
    //   block [0x821C7B00..0x821C7B5C)
	// 821C7B00: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821C7B04: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821C7B08: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 821C7B0C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C7B10: 81696AB8  lwz r11, 0x6ab8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C7B14: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7B18: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C7B1C: 80A60058  lwz r5, 0x58(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(88 as u32) ) } as u64;
	// 821C7B20: 80850004  lwz r4, 4(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7B24: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C7B28: 816B0454  lwz r11, 0x454(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1108 as u32) ) } as u64;
	// 821C7B2C: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821C7B30: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 821C7B34: 7D2707B4  extsw r7, r9
	ctx.r[7].s64 = ctx.r[9].s32 as i64;
	// 821C7B38: F8E1FFF0  std r7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[7].u64 ) };
	// 821C7B3C: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C7B40: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821C7B44: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821C7B48: D1880000  stfs f12, 0(r8)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821C7B4C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7B50: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 821C7B54: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 821C7B58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C7B60 size=252
    let mut pc: u32 = 0x821C7B60;
    'dispatch: loop {
        match pc {
            0x821C7B60 => {
    //   block [0x821C7B60..0x821C7C5C)
	// 821C7B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7B64: 48AE18A9  bl 0x82ca940c
	ctx.lr = 0x821C7B68;
	sub_82CA93D0(ctx, base);
	// 821C7B68: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821C7B6C: 38E30114  addi r7, r3, 0x114
	ctx.r[7].s64 = ctx.r[3].s64 + 276;
	// 821C7B70: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 821C7B74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C7B78: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 821C7B7C: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 821C7B80: 8167000C  lwz r11, 0xc(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C7B84: 81470010  lwz r10, 0x10(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C7B88: 80A99650  lwz r5, -0x69b0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 821C7B8C: 7CCA5A14  add r6, r10, r11
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C7B90: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C7B94: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821C7B98: D9A1FFD0  stfd f13, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[13].u64 ) };
	// 821C7B9C: 83E1FFD4  lwz r31, -0x2c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-44 as u32) ) } as u64;
	// 821C7BA0: 40990008  ble cr6, 0x821c7ba8
	if !ctx.cr[6].gt {
	pc = 0x821C7BA8; continue 'dispatch;
	}
	// 821C7BA4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C7BA8: 83A7000C  lwz r29, 0xc(r7)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C7BAC: 81470010  lwz r10, 0x10(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C7BB0: 7FCAEA14  add r30, r10, r29
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 821C7BB4: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821C7BB8: 40990008  ble cr6, 0x821c7bc0
	if !ctx.cr[6].gt {
	pc = 0x821C7BC0; continue 'dispatch;
	}
	// 821C7BBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C7BC0: 7F073840  cmplw cr6, r7, r7
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821C7BC4: 419A0008  beq cr6, 0x821c7bcc
	if ctx.cr[6].eq {
	pc = 0x821C7BCC; continue 'dispatch;
	}
	// 821C7BC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C7BCC: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821C7BD0: 419A0088  beq cr6, 0x821c7c58
	if ctx.cr[6].eq {
	pc = 0x821C7C58; continue 'dispatch;
	}
	// 821C7BD4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821C7BD8: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C7BDC: 41980008  blt cr6, 0x821c7be4
	if ctx.cr[6].lt {
	pc = 0x821C7BE4; continue 'dispatch;
	}
	// 821C7BE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C7BE4: 81270008  lwz r9, 8(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7BE8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C7BEC: 41990008  bgt cr6, 0x821c7bf4
	if ctx.cr[6].gt {
	pc = 0x821C7BF4; continue 'dispatch;
	}
	// 821C7BF0: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C7BF4: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7BF8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C7BFC: 7D4A402E  lwzx r10, r10, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821C7C00: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 821C7C04: 7F0A2000  cmpw cr6, r10, r4
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[4].s32, &mut ctx.xer);
	// 821C7C08: 409A003C  bne cr6, 0x821c7c44
	if !ctx.cr[6].eq {
	pc = 0x821C7C44; continue 'dispatch;
	}
	// 821C7C0C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821C7C10: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C7C14: 41980008  blt cr6, 0x821c7c1c
	if ctx.cr[6].lt {
	pc = 0x821C7C1C; continue 'dispatch;
	}
	// 821C7C18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C7C1C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C7C20: 41990008  bgt cr6, 0x821c7c28
	if ctx.cr[6].gt {
	pc = 0x821C7C28; continue 'dispatch;
	}
	// 821C7C24: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C7C28: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C7C2C: 7D2A402E  lwzx r9, r10, r8
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821C7C30: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7C34: 7D0AFA14  add r8, r10, r31
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821C7C38: 7F082800  cmpw cr6, r8, r5
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[5].s32, &mut ctx.xer);
	// 821C7C3C: 40990008  ble cr6, 0x821c7c44
	if !ctx.cr[6].gt {
	pc = 0x821C7C44; continue 'dispatch;
	}
	// 821C7C40: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 821C7C44: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C7C48: 41980008  blt cr6, 0x821c7c50
	if ctx.cr[6].lt {
	pc = 0x821C7C50; continue 'dispatch;
	}
	// 821C7C4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C7C50: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C7C54: 4BFFFF60  b 0x821c7bb4
	pc = 0x821C7BB4; continue 'dispatch;
	// 821C7C58: 48AE1804  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7C60 size=128
    let mut pc: u32 = 0x821C7C60;
    'dispatch: loop {
        match pc {
            0x821C7C60 => {
    //   block [0x821C7C60..0x821C7CE0)
	// 821C7C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7C64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C7C68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C7C6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C7C70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C7C74: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C7C78: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C7C7C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C7C80: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C7C84: 806A0080  lwz r3, 0x80(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 821C7C88: 480AD259  bl 0x82274ee0
	ctx.lr = 0x821C7C8C;
	sub_82274EE0(ctx, base);
	// 821C7C8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C7C90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821C7C94: 419A0030  beq cr6, 0x821c7cc4
	if ctx.cr[6].eq {
	pc = 0x821C7CC4; continue 'dispatch;
	}
	// 821C7C98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7C9C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7CA0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C7CA4: 4E800421  bctrl
	ctx.lr = 0x821C7CA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C7CA8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C7CAC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C7CB0: 419A0014  beq cr6, 0x821c7cc4
	if ctx.cr[6].eq {
	pc = 0x821C7CC4; continue 'dispatch;
	}
	// 821C7CB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C7CB8: 809E0024  lwz r4, 0x24(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 821C7CBC: 480D487D  bl 0x8229c538
	ctx.lr = 0x821C7CC0;
	sub_8229C538(ctx, base);
	// 821C7CC0: 48000008  b 0x821c7cc8
	pc = 0x821C7CC8; continue 'dispatch;
	// 821C7CC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C7CC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C7CCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C7CD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C7CD4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C7CD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C7CDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C7CE0 size=72
    let mut pc: u32 = 0x821C7CE0;
    'dispatch: loop {
        match pc {
            0x821C7CE0 => {
    //   block [0x821C7CE0..0x821C7D28)
	// 821C7CE0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C7CE4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C7CE8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C7CEC: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C7CF0: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C7CF4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C7CF8: 419A0014  beq cr6, 0x821c7d0c
	if ctx.cr[6].eq {
	pc = 0x821C7D0C; continue 'dispatch;
	}
	// 821C7CFC: 896B0035  lbz r11, 0x35(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(53 as u32) ) } as u64;
	// 821C7D00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7D04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C7D08: 409A0008  bne cr6, 0x821c7d10
	if !ctx.cr[6].eq {
	pc = 0x821C7D10; continue 'dispatch;
	}
	// 821C7D0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C7D10: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C7D14: 806A009C  lwz r3, 0x9c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 821C7D18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7D1C: 419A000C  beq cr6, 0x821c7d28
	if ctx.cr[6].eq {
		sub_821C7D28(ctx, base);
		return;
	}
	// 821C7D20: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C7D24: 4809C50C  b 0x82264230
	sub_82264230(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C7D28 size=8
    let mut pc: u32 = 0x821C7D28;
    'dispatch: loop {
        match pc {
            0x821C7D28 => {
    //   block [0x821C7D28..0x821C7D30)
	// 821C7D28: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821C7D2C: 4809C504  b 0x82264230
	sub_82264230(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7D30 size=140
    let mut pc: u32 = 0x821C7D30;
    'dispatch: loop {
        match pc {
            0x821C7D30 => {
    //   block [0x821C7D30..0x821C7DBC)
	// 821C7D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7D34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C7D38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C7D3C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821C7D40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C7D44: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 821C7D48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C7D4C: 480707D5  bl 0x82238520
	ctx.lr = 0x821C7D50;
	sub_82238520(ctx, base);
	// 821C7D50: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C7D54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7D58: 419A0048  beq cr6, 0x821c7da0
	if ctx.cr[6].eq {
	pc = 0x821C7DA0; continue 'dispatch;
	}
	// 821C7D5C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C7D60: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 821C7D64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C7D68: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 821C7D6C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821C7D70: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C7D74: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821C7D78: FFE06818  frsp f31, f13
	ctx.f[31].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821C7D7C: 48319E95  bl 0x824e1c10
	ctx.lr = 0x821C7D80;
	sub_824E1C10(ctx, base);
	// 821C7D80: ED81F82A  fadds f12, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 821C7D84: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 821C7D88: D9610050  stfd f11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[11].u64 ) };
	// 821C7D8C: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C7D90: 7D28FE70  srawi r8, r9, 0x1f
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 31) as i64;
	// 821C7D94: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821C7D98: 7C674850  subf r3, r7, r9
	ctx.r[3].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 821C7D9C: 48000008  b 0x821c7da4
	pc = 0x821C7DA4; continue 'dispatch;
	// 821C7DA0: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C7DA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C7DA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C7DAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C7DB0: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C7DB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C7DB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7DC0 size=88
    let mut pc: u32 = 0x821C7DC0;
    'dispatch: loop {
        match pc {
            0x821C7DC0 => {
    //   block [0x821C7DC0..0x821C7E18)
	// 821C7DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7DC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C7DC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C7DCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C7DD0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7DD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C7DD8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821C7DDC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7DE0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C7DE4: 4E800421  bctrl
	ctx.lr = 0x821C7DE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C7DE8: 2F030008  cmpwi cr6, r3, 8
	ctx.cr[6].compare_i32(ctx.r[3].s32, 8, &mut ctx.xer);
	// 821C7DEC: 409A0018  bne cr6, 0x821c7e04
	if !ctx.cr[6].eq {
	pc = 0x821C7E04; continue 'dispatch;
	}
	// 821C7DF0: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 821C7DF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7DF8: 419A000C  beq cr6, 0x821c7e04
	if ctx.cr[6].eq {
	pc = 0x821C7E04; continue 'dispatch;
	}
	// 821C7DFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C7E00: 4877B339  bl 0x82943138
	ctx.lr = 0x821C7E04;
	sub_82943138(ctx, base);
	// 821C7E04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C7E08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C7E0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C7E10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C7E14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7E18 size=112
    let mut pc: u32 = 0x821C7E18;
    'dispatch: loop {
        match pc {
            0x821C7E18 => {
    //   block [0x821C7E18..0x821C7E88)
	// 821C7E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7E1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C7E20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C7E24: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C7E28: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C7E2C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C7E30: 812A0080  lwz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 821C7E34: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7E38: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7E3C: 54EA003E  slwi r10, r7, 0
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C7E40: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7E44: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C7E48: 409A000C  bne cr6, 0x821c7e54
	if !ctx.cr[6].eq {
	pc = 0x821C7E54; continue 'dispatch;
	}
	// 821C7E4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C7E50: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C7E54: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7E58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7E5C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7E60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C7E64: 4E800421  bctrl
	ctx.lr = 0x821C7E68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C7E68: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C7E6C: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821C7E70: 5507DFFE  rlwinm r7, r8, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 821C7E74: 68E30001  xori r3, r7, 1
	ctx.r[3].u64 = ctx.r[7].u64 ^ 1;
	// 821C7E78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C7E7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C7E80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C7E84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C7E88 size=316
    let mut pc: u32 = 0x821C7E88;
    'dispatch: loop {
        match pc {
            0x821C7E88 => {
    //   block [0x821C7E88..0x821C7FC4)
	// 821C7E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7E8C: 48AE1575  bl 0x82ca9400
	ctx.lr = 0x821C7E90;
	sub_82CA93D0(ctx, base);
	// 821C7E90: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821C7E94: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C7E98: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821C7E9C: 39400080  li r10, 0x80
	ctx.r[10].s64 = 128;
	// 821C7EA0: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821C7EA4: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821C7EA8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821C7EAC: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7EB0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821C7EB4: C0089A80  lfs f0, -0x6580(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C7EB8: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C7EBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C7FC8 size=324
    let mut pc: u32 = 0x821C7FC8;
    'dispatch: loop {
        match pc {
            0x821C7FC8 => {
    //   block [0x821C7FC8..0x821C810C)
	// 821C7FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7FCC: 48AE143D  bl 0x82ca9408
	ctx.lr = 0x821C7FD0;
	sub_82CA93D0(ctx, base);
	// 821C7FD0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C7FD4: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 821C7FD8: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 821C7FDC: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 821C7FE0: 3CE0820F  lis r7, -0x7df1
	ctx.r[7].s64 = -2112946176;
	// 821C7FE4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821C7FE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C7FEC: 38A96B68  addi r5, r9, 0x6b68
	ctx.r[5].s64 = ctx.r[9].s64 + 27496;
	// 821C7FF0: 38CA6B58  addi r6, r10, 0x6b58
	ctx.r[6].s64 = ctx.r[10].s64 + 27480;
	// 821C7FF4: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 821C7FF8: 38886B74  addi r4, r8, 0x6b74
	ctx.r[4].s64 = ctx.r[8].s64 + 27508;
	// 821C7FFC: 90A10098  stw r5, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[5].u32 ) };
	// 821C8000: 38676B78  addi r3, r7, 0x6b78
	ctx.r[3].s64 = ctx.r[7].s64 + 27512;
	// 821C8004: 90C10090  stw r6, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[6].u32 ) };
	// 821C8008: 908100A0  stw r4, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u32 ) };
	// 821C800C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821C8010: 906100AC  stw r3, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[3].u32 ) };
	// 821C8014: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821C8018: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 821C801C: 392AA978  addi r9, r10, -0x5688
	ctx.r[9].s64 = ctx.r[10].s64 + -22152;
	// 821C8020: 916100A8  stw r11, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 821C8024: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C8028: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C802C: 48032BA5  bl 0x821fabd0
	ctx.lr = 0x821C8030;
	sub_821FABD0(ctx, base);
	// 821C8030: 81010078  lwz r8, 0x78(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 821C8034: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821C8038: 80E1007C  lwz r7, 0x7c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C803C: 7D060E70  srawi r6, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[8].s32 >> 1) as i64;
	// 821C8040: 3BEBAA38  addi r31, r11, -0x55c8
	ctx.r[31].s64 = ctx.r[11].s64 + -21960;
	// 821C8044: 7CA60194  addze r5, r6
	tmp.s64 = ctx.r[6].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[6].u32);
	ctx.r[5].s64 = tmp.s64;
	// 821C8048: 7CEB0E70  srawi r11, r7, 1
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 1) as i64;
	// 821C804C: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 821C8050: 90A10058  stw r5, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 821C8054: 7D4B0194  addze r10, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[10].s64 = tmp.s64;
	// 821C8058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C805C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C8060: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821C8064: 839EF9C0  lwz r28, -0x640(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821C8068: 480BF679  bl 0x822876e0
	ctx.lr = 0x821C806C;
	sub_822876E0(ctx, base);
	// 821C806C: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8070: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 821C8074: 2F060061  cmpwi cr6, r6, 0x61
	ctx.cr[6].compare_i32(ctx.r[6].s32, 97, &mut ctx.xer);
	// 821C8078: 409A0008  bne cr6, 0x821c8080
	if !ctx.cr[6].eq {
	pc = 0x821C8080; continue 'dispatch;
	}
	// 821C807C: 38E0003A  li r7, 0x3a
	ctx.r[7].s64 = 58;
	// 821C8080: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821C8084: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821C8088: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821C808C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 821C8090: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821C8094: 48033CFD  bl 0x821fbd90
	ctx.lr = 0x821C8098;
	sub_821FBD90(ctx, base);
	// 821C8098: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821C809C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821C80A0: 48033B49  bl 0x821fbbe8
	ctx.lr = 0x821C80A4;
	sub_821FBBE8(ctx, base);
	// 821C80A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821C80A8: 48033EE9  bl 0x821fbf90
	ctx.lr = 0x821C80AC;
	sub_821FBF90(ctx, base);
	// 821C80AC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C80B0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821C80B4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821C80B8: 38EAA990  addi r7, r10, -0x5670
	ctx.r[7].s64 = ctx.r[10].s64 + -22128;
	// 821C80BC: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 821C80C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821C80C4: 806BF7E8  lwz r3, -0x818(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2072 as u32) ) } as u64;
	// 821C80C8: 480C2BF1  bl 0x8228acb8
	ctx.lr = 0x821C80CC;
	sub_8228ACB8(ctx, base);
	// 821C80CC: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821C80D0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821C80D4: 807EF9C0  lwz r3, -0x640(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821C80D8: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821C80DC: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 821C80E0: 81696E5C  lwz r11, 0x6e5c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28252 as u32) ) } as u64;
	// 821C80E4: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821C80E8: 20C70000  subfic r6, r7, 0
	ctx.xer.ca = ctx.r[7].u32 <= 0 as u32;
	ctx.r[6].s64 = (0 as i64) - ctx.r[7].s64;
	// 821C80EC: 7CA63110  subfe r5, r6, r6
	let x = (!ctx.r[6].u32);
	let y = ctx.r[6].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[5].u32 = res;
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821C80F0: 54AB07FE  clrlwi r11, r5, 0x1f
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x00000001u64;
	// 821C80F4: 99686E23  stb r11, 0x6e23(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(28195 as u32), ctx.r[11].u8 ) };
	// 821C80F8: 4806EF29  bl 0x82237020
	ctx.lr = 0x821C80FC;
	sub_82237020(ctx, base);
	// 821C80FC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821C8100: 48033E91  bl 0x821fbf90
	ctx.lr = 0x821C8104;
	sub_821FBF90(ctx, base);
	// 821C8104: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821C8108: 48AE1350  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C8110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C8110 size=200
    let mut pc: u32 = 0x821C8110;
    'dispatch: loop {
        match pc {
            0x821C8110 => {
    //   block [0x821C8110..0x821C81D8)
	// 821C8110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C8114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C8118: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C811C: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 821C8120: 546B083C  slwi r11, r3, 1
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C8124: 392ADED4  addi r9, r10, -0x212c
	ctx.r[9].s64 = ctx.r[10].s64 + -8492;
	// 821C8128: 7D035A14  add r8, r3, r11
	ctx.r[8].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 821C812C: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 821C8130: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C8134: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 821C8138: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 821C813C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8140: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C8144: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8148: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C814C: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 821C8150: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C8154: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821C8158: 41990008  bgt cr6, 0x821c8160
	if ctx.cr[6].gt {
	pc = 0x821C8160; continue 'dispatch;
	}
	// 821C815C: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 821C8160: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8164: 2F060001  cmpwi cr6, r6, 1
	ctx.cr[6].compare_i32(ctx.r[6].s32, 1, &mut ctx.xer);
	// 821C8168: 41980060  blt cr6, 0x821c81c8
	if ctx.cr[6].lt {
	pc = 0x821C81C8; continue 'dispatch;
	}
	// 821C816C: 7D6A1670  srawi r10, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 821C8170: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821C8174: 7CEA0194  addze r7, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[7].s64 = tmp.s64;
	// 821C8178: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821C817C: 792AFFE6  rldicr r10, r9, 0x3f, 0x3f
	ctx.r[10].u64 = (ctx.r[9].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821C8180: 7CE407B4  extsw r4, r7
	ctx.r[4].s64 = ctx.r[7].s32 as i64;
	// 821C8184: 7D432436  srd r3, r10, r4
	if (ctx.r[4].u8 & 0x40) != 0 {
		ctx.r[3].u64 = 0;
	} else {
		ctx.r[3].u64 = (ctx.r[10].u64) >> ((ctx.r[4].u8 & 0x3F) as u32);
	}
	// 821C8188: E9281760  ld r9, 0x1760(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(5984 as u32) ) };
	// 821C818C: 7C694838  and r9, r3, r9
	ctx.r[9].u64 = ctx.r[3].u64 & ctx.r[9].u64;
	// 821C8190: 2B290000  cmpldi cr6, r9, 0
	ctx.cr[6].compare_u64(ctx.r[9].u64, 0, &mut ctx.xer);
	// 821C8194: 419A0034  beq cr6, 0x821c81c8
	if ctx.cr[6].eq {
	pc = 0x821C81C8; continue 'dispatch;
	}
	// 821C8198: 7D265A14  add r9, r6, r11
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 821C819C: 5568F0BE  srwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C81A0: 38E9FFFF  addi r7, r9, -1
	ctx.r[7].s64 = ctx.r[9].s64 + -1;
	// 821C81A4: 3C808336  lis r4, -0x7cca
	ctx.r[4].s64 = -2093613056;
	// 821C81A8: 54E3F0BE  srwi r3, r7, 2
	ctx.r[3].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821C81AC: 7D281850  subf r9, r8, r3
	ctx.r[9].s64 = ctx.r[3].s64 - ctx.r[8].s64;
	// 821C81B0: 79270020  clrldi r7, r9, 0x20
	ctx.r[7].u64 = ctx.r[9].u64 & 0x00000000FFFFFFFFu64;
	// 821C81B4: 80640364  lwz r3, 0x364(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C81B8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821C81BC: 7D4B3E34  srad r11, r10, r7
	tmp.u64 = (ctx.r[7].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[10].s64 < 0) && ((ctx.r[10].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[11].s64 = ctx.r[10].s64 >> tmp.u64;
	// 821C81C0: 7D674436  srd r7, r11, r8
	if (ctx.r[8].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[11].u64) >> ((ctx.r[8].u8 & 0x3F) as u32);
	}
	// 821C81C4: 480526BD  bl 0x8221a880
	ctx.lr = 0x821C81C8;
	sub_8221A880(ctx, base);
	// 821C81C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C81CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C81D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C81D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C81D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C81D8 size=2424
    let mut pc: u32 = 0x821C81D8;
    'dispatch: loop {
        match pc {
            0x821C81D8 => {
    //   block [0x821C81D8..0x821C8B50)
	// 821C81D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C81DC: 48AE1211  bl 0x82ca93ec
	ctx.lr = 0x821C81E0;
	sub_82CA93D0(ctx, base);
	// 821C81E0: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C81E4: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821C81E8: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 821C81EC: 3B8B2390  addi r28, r11, 0x2390
	ctx.r[28].s64 = ctx.r[11].s64 + 9104;
	// 821C81F0: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821C81F4: 9AC10058  stb r22, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[22].u8 ) };
	// 821C81F8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821C81FC: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 821C8200: 397C2004  addi r11, r28, 0x2004
	ctx.r[11].s64 = ctx.r[28].s64 + 8196;
	// 821C8204: 392A7E70  addi r9, r10, 0x7e70
	ctx.r[9].s64 = ctx.r[10].s64 + 32368;
	// 821C8208: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C820C: 391C6014  addi r8, r28, 0x6014
	ctx.r[8].s64 = ctx.r[28].s64 + 24596;
	// 821C8210: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C8214: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C8218: 9127DFFC  stw r9, -0x2004(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-8196 as u32), ctx.r[9].u32 ) };
	// 821C821C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8220: 80CBFFFC  lwz r6, -4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821C8224: 54C4083C  slwi r4, r6, 1
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821C8228: 38AA0001  addi r5, r10, 1
	ctx.r[5].s64 = ctx.r[10].s64 + 1;
	// 821C822C: 908BFFFC  stw r4, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[4].u32 ) };
	// 821C8230: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 821C8234: 396B2008  addi r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + 8200;
	// 821C8238: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821C823C: 4198FFCC  blt cr6, 0x821c8208
	if ctx.cr[6].lt {
	pc = 0x821C8208; continue 'dispatch;
	}
	// 821C8240: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821C8244: 807B00C0  lwz r3, 0xc0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 821C8248: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821C824C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C8250: 480568A1  bl 0x8221eaf0
	ctx.lr = 0x821C8254;
	sub_8221EAF0(ctx, base);
	// 821C8254: 817B00C0  lwz r11, 0xc0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 821C8258: 3D407FFF  lis r10, 0x7fff
	ctx.r[10].s64 = 2147418112;
	// 821C825C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 821C8260: 6149FFFF  ori r9, r10, 0xffff
	ctx.r[9].u64 = ctx.r[10].u64 | 65535;
	// 821C8264: 810B0054  lwz r8, 0x54(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C8268: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821C826C: 419A08D4  beq cr6, 0x821c8b40
	if ctx.cr[6].eq {
	pc = 0x821C8B40; continue 'dispatch;
	}
	// 821C8270: 3D40834F  lis r10, -0x7cb1
	ctx.r[10].s64 = -2091974656;
	// 821C8274: 816A6EC0  lwz r11, 0x6ec0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28352 as u32) ) } as u64;
	// 821C8278: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821C827C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C8280: 409A000C  bne cr6, 0x821c828c
	if !ctx.cr[6].eq {
	pc = 0x821C828C; continue 'dispatch;
	}
	// 821C8284: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821C8288: 916A6EC0  stw r11, 0x6ec0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28352 as u32), ctx.r[11].u32 ) };
	// 821C828C: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8290: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821C8294: C82B02E8  lfd f1, 0x2e8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(744 as u32) ) };
	// 821C8298: 488B9FE1  bl 0x82a82278
	ctx.lr = 0x821C829C;
	sub_82A82278(ctx, base);
	// 821C829C: 386000BC  li r3, 0xbc
	ctx.r[3].s64 = 188;
	// 821C82A0: 48063F71  bl 0x8222c210
	ctx.lr = 0x821C82A4;
	sub_8222C210(ctx, base);
	// 821C82A4: 386000BD  li r3, 0xbd
	ctx.r[3].s64 = 189;
	// 821C82A8: 48040869  bl 0x82208b10
	ctx.lr = 0x821C82AC;
	sub_82208B10(ctx, base);
	// 821C82AC: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 821C82B0: 3EE08336  lis r23, -0x7cca
	ctx.r[23].s64 = -2093613056;
	// 821C82B4: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821C82B8: 392ADF40  addi r9, r10, -0x20c0
	ctx.r[9].s64 = ctx.r[10].s64 + -8384;
	// 821C82BC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821C82C0: 3BEB63A0  addi r31, r11, 0x63a0
	ctx.r[31].s64 = ctx.r[11].s64 + 25504;
	// 821C82C4: 3B2A0DB8  addi r25, r10, 0xdb8
	ctx.r[25].s64 = ctx.r[10].s64 + 3512;
	// 821C82C8: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821C82CC: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 821C82D0: 81770364  lwz r11, 0x364(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C82D4: 81490014  lwz r10, 0x14(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C82D8: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 821C82DC: 914B2E2C  stw r10, 0x2e2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(11820 as u32), ctx.r[10].u32 ) };
	// 821C82E0: E8C70010  ld r6, 0x10(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) };
	// 821C82E4: 64C50008  oris r5, r6, 8
	ctx.r[5].u64 = ctx.r[6].u64 | 524288;
	// 821C82E8: F8A70010  std r5, 0x10(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(16 as u32), ctx.r[5].u64 ) };
	// 821C82EC: 889B0100  lbz r4, 0x100(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(256 as u32) ) } as u64;
	// 821C82F0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821C82F4: 914870B8  stw r10, 0x70b8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28856 as u32), ctx.r[10].u32 ) };
	// 821C82F8: 419A00B8  beq cr6, 0x821c83b0
	if ctx.cr[6].eq {
	pc = 0x821C83B0; continue 'dispatch;
	}
	// 821C82FC: 897B0101  lbz r11, 0x101(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(257 as u32) ) } as u64;
	// 821C8300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C8304: 419A00AC  beq cr6, 0x821c83b0
	if ctx.cr[6].eq {
	pc = 0x821C83B0; continue 'dispatch;
	}
	// 821C8308: 3D208331  lis r9, -0x7ccf
	ctx.r[9].s64 = -2093940736;
	// 821C830C: 891F0105  lbz r8, 0x105(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(261 as u32) ) } as u64;
	// 821C8310: 815F00F4  lwz r10, 0xf4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 821C8314: 38E9701C  addi r7, r9, 0x701c
	ctx.r[7].s64 = ctx.r[9].s64 + 28700;
	// 821C8318: 1D682008  mulli r11, r8, 0x2008
	ctx.r[11].s64 = ctx.r[8].s64 * 8200;
	// 821C831C: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8320: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821C8324: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821C8328: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821C832C: 419A0084  beq cr6, 0x821c83b0
	if ctx.cr[6].eq {
	pc = 0x821C83B0; continue 'dispatch;
	}
	// 821C8330: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C8334: 813F00F8  lwz r9, 0xf8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 821C8338: 7D275038  and r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	// 821C833C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C8340: 409A003C  bne cr6, 0x821c837c
	if !ctx.cr[6].eq {
	pc = 0x821C837C; continue 'dispatch;
	}
	// 821C8344: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8348: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 821C834C: 38DF00F0  addi r6, r31, 0xf0
	ctx.r[6].s64 = ctx.r[31].s64 + 240;
	// 821C8350: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C8354: 915F00F8  stw r10, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[10].u32 ) };
	// 821C8358: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821C835C: 815F00F4  lwz r10, 0xf4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 821C8360: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8364: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C8368: 7C695A14  add r3, r9, r11
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821C836C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821C8370: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8374: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821C8378: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	// 821C837C: 897F0104  lbz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 821C8380: 911F00F4  stw r8, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[8].u32 ) };
	// 821C8384: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C8388: 409A0028  bne cr6, 0x821c83b0
	if !ctx.cr[6].eq {
	pc = 0x821C83B0; continue 'dispatch;
	}
	// 821C838C: 817A0DB0  lwz r11, 0xdb0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821C8390: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	// 821C8394: 393F00F0  addi r9, r31, 0xf0
	ctx.r[9].s64 = ctx.r[31].s64 + 240;
	// 821C8398: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C839C: 995F0104  stb r10, 0x104(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[10].u8 ) };
	// 821C83A0: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 821C83A4: 907A0DB0  stw r3, 0xdb0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(3504 as u32), ctx.r[3].u32 ) };
	// 821C83A8: 7D28C92E  stwx r9, r8, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[25].u32), ctx.r[9].u32) };
	// 821C83AC: 48000008  b 0x821c83b4
	pc = 0x821C83B4; continue 'dispatch;
	// 821C83B0: 807A0DB0  lwz r3, 0xdb0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821C83B4: 893B0100  lbz r9, 0x100(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(256 as u32) ) } as u64;
	// 821C83B8: 891F00BD  lbz r8, 0xbd(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(189 as u32) ) } as u64;
	// 821C83BC: 7D270034  cntlzw r7, r9
	ctx.r[7].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821C83C0: 815F00AC  lwz r10, 0xac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 821C83C4: 1D682008  mulli r11, r8, 0x2008
	ctx.r[11].s64 = ctx.r[8].s64 * 8200;
	// 821C83C8: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 821C83CC: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821C83D0: 68C80001  xori r8, r6, 1
	ctx.r[8].u64 = ctx.r[6].u64 ^ 1;
	// 821C83D4: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821C83D8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821C83DC: 419A007C  beq cr6, 0x821c8458
	if ctx.cr[6].eq {
	pc = 0x821C8458; continue 'dispatch;
	}
	// 821C83E0: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C83E4: 813F00B0  lwz r9, 0xb0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821C83E8: 7D275038  and r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	// 821C83EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C83F0: 409A003C  bne cr6, 0x821c842c
	if !ctx.cr[6].eq {
	pc = 0x821C842C; continue 'dispatch;
	}
	// 821C83F4: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C83F8: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 821C83FC: 38DF00A8  addi r6, r31, 0xa8
	ctx.r[6].s64 = ctx.r[31].s64 + 168;
	// 821C8400: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C8404: 915F00B0  stw r10, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 821C8408: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821C840C: 815F00AC  lwz r10, 0xac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 821C8410: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8414: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C8418: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821C841C: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821C8420: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8424: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 821C8428: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	// 821C842C: 897F00BC  lbz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 821C8430: 911F00AC  stw r8, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[8].u32 ) };
	// 821C8434: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C8438: 409A0020  bne cr6, 0x821c8458
	if !ctx.cr[6].eq {
	pc = 0x821C8458; continue 'dispatch;
	}
	// 821C843C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C8440: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 821C8444: 393F00A8  addi r9, r31, 0xa8
	ctx.r[9].s64 = ctx.r[31].s64 + 168;
	// 821C8448: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 821C844C: 997F00BC  stb r11, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[11].u8 ) };
	// 821C8450: 907A0DB0  stw r3, 0xdb0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(3504 as u32), ctx.r[3].u32 ) };
	// 821C8454: 7D2AC92E  stwx r9, r10, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[25].u32), ctx.r[9].u32) };
	// 821C8458: 891F0045  lbz r8, 0x45(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(69 as u32) ) } as u64;
	// 821C845C: 893B0100  lbz r9, 0x100(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(256 as u32) ) } as u64;
	// 821C8460: 1D682008  mulli r11, r8, 0x2008
	ctx.r[11].s64 = ctx.r[8].s64 * 8200;
	// 821C8464: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C8468: 7D270034  cntlzw r7, r9
	ctx.r[7].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821C846C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821C8470: 54E8DFFE  rlwinm r8, r7, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 821C8474: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821C8478: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821C847C: 419A007C  beq cr6, 0x821c84f8
	if ctx.cr[6].eq {
	pc = 0x821C84F8; continue 'dispatch;
	}
	// 821C8480: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C8484: 813F0038  lwz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821C8488: 7D275038  and r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	// 821C848C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C8490: 409A003C  bne cr6, 0x821c84cc
	if !ctx.cr[6].eq {
	pc = 0x821C84CC; continue 'dispatch;
	}
	// 821C8494: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8498: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 821C849C: 38DF0030  addi r6, r31, 0x30
	ctx.r[6].s64 = ctx.r[31].s64 + 48;
	// 821C84A0: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C84A4: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 821C84A8: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821C84AC: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C84B0: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C84B4: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C84B8: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821C84BC: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821C84C0: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C84C4: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 821C84C8: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	// 821C84CC: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 821C84D0: 911F0034  stw r8, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[8].u32 ) };
	// 821C84D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C84D8: 409A0020  bne cr6, 0x821c84f8
	if !ctx.cr[6].eq {
	pc = 0x821C84F8; continue 'dispatch;
	}
	// 821C84DC: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C84E0: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 821C84E4: 393F0030  addi r9, r31, 0x30
	ctx.r[9].s64 = ctx.r[31].s64 + 48;
	// 821C84E8: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 821C84EC: 997F0044  stb r11, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 821C84F0: 907A0DB0  stw r3, 0xdb0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(3504 as u32), ctx.r[3].u32 ) };
	// 821C84F4: 7D2AC92E  stwx r9, r10, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[25].u32), ctx.r[9].u32) };
	// 821C84F8: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821C84FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C8500: 392BDED4  addi r9, r11, -0x212c
	ctx.r[9].s64 = ctx.r[11].s64 + -8492;
	// 821C8504: 795DFFE6  rldicr r29, r10, 0x3f, 0x3f
	ctx.r[29].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821C8508: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C850C: 83CB0300  lwz r30, 0x300(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(768 as u32) ) } as u64;
	// 821C8510: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 821C8514: 419A016C  beq cr6, 0x821c8680
	if ctx.cr[6].eq {
	pc = 0x821C8680; continue 'dispatch;
	}
	// 821C8518: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821C851C: 41980024  blt cr6, 0x821c8540
	if ctx.cr[6].lt {
	pc = 0x821C8540; continue 'dispatch;
	}
	// 821C8520: 397E0020  addi r11, r30, 0x20
	ctx.r[11].s64 = ctx.r[30].s64 + 32;
	// 821C8524: 80770364  lwz r3, 0x364(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C8528: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821C852C: 80B80004  lwz r5, 4(r24)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8530: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821C8534: 7FA65436  srd r6, r29, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[29].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821C8538: 4BFEE9A9  bl 0x821b6ee0
	ctx.lr = 0x821C853C;
	sub_821B6EE0(ctx, base);
	// 821C853C: 807A0DB0  lwz r3, 0xdb0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821C8540: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C8544: 395F0AB0  addi r10, r31, 0xab0
	ctx.r[10].s64 = ctx.r[31].s64 + 2736;
	// 821C8548: 7D3E5A14  add r9, r30, r11
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821C854C: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821C8550: 55271838  slwi r7, r9, 3
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821C8554: 390B6F38  addi r8, r11, 0x6f38
	ctx.r[8].s64 = ctx.r[11].s64 + 28472;
	// 821C8558: 7D675214  add r11, r7, r10
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 821C855C: 81280008  lwz r9, 8(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C8560: 88CB0015  lbz r6, 0x15(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821C8564: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8568: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 821C856C: 1D462008  mulli r10, r6, 0x2008
	ctx.r[10].s64 = ctx.r[6].s64 * 8200;
	// 821C8570: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 821C8574: 7F054840  cmplw cr6, r5, r9
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C8578: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C857C: 419A0074  beq cr6, 0x821c85f0
	if ctx.cr[6].eq {
	pc = 0x821C85F0; continue 'dispatch;
	}
	// 821C8580: 80CA2000  lwz r6, 0x2000(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C8584: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C8588: 7CBE3038  and r30, r5, r6
	ctx.r[30].u64 = ctx.r[5].u64 & ctx.r[6].u64;
	// 821C858C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821C8590: 409A003C  bne cr6, 0x821c85cc
	if !ctx.cr[6].eq {
	pc = 0x821C85CC; continue 'dispatch;
	}
	// 821C8594: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8598: 7CA63378  or r6, r5, r6
	ctx.r[6].u64 = ctx.r[5].u64 | ctx.r[6].u64;
	// 821C859C: 55251838  slwi r5, r9, 3
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C85A0: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 821C85A4: 7D65512E  stwx r11, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821C85A8: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C85AC: 80AA2004  lwz r5, 0x2004(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C85B0: 54A91838  slwi r9, r5, 3
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C85B4: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821C85B8: 90C90004  stw r6, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821C85BC: 81280008  lwz r9, 8(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C85C0: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C85C4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821C85C8: 910A2004  stw r8, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	// 821C85CC: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C85D0: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 821C85D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C85D8: 409A0018  bne cr6, 0x821c85f0
	if !ctx.cr[6].eq {
	pc = 0x821C85F0; continue 'dispatch;
	}
	// 821C85DC: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C85E0: 9ACB0014  stb r22, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[22].u8 ) };
	// 821C85E4: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 821C85E8: 907A0DB0  stw r3, 0xdb0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(3504 as u32), ctx.r[3].u32 ) };
	// 821C85EC: 7D6AC92E  stwx r11, r10, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[25].u32), ctx.r[11].u32) };
	// 821C85F0: 397F0C90  addi r11, r31, 0xc90
	ctx.r[11].s64 = ctx.r[31].s64 + 3216;
	// 821C85F4: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 821C85F8: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821C85FC: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8600: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s64 = ctx.r[10].s64 * 8200;
	// 821C8604: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 821C8608: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C860C: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C8610: 419A0070  beq cr6, 0x821c8680
	if ctx.cr[6].eq {
	pc = 0x821C8680; continue 'dispatch;
	}
	// 821C8614: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C8618: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C861C: 7CE64038  and r6, r7, r8
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 821C8620: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821C8624: 409A0038  bne cr6, 0x821c865c
	if !ctx.cr[6].eq {
	pc = 0x821C865C; continue 'dispatch;
	}
	// 821C8628: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C862C: 7CE54378  or r5, r7, r8
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 821C8630: 54C41838  slwi r4, r6, 3
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821C8634: 90AB0008  stw r5, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 821C8638: 7D64512E  stwx r11, r4, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821C863C: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8640: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C8644: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8648: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C864C: 90E60004  stw r7, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821C8650: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8654: 38A80001  addi r5, r8, 1
	ctx.r[5].s64 = ctx.r[8].s64 + 1;
	// 821C8658: 90AA2004  stw r5, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	// 821C865C: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C8660: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C8664: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C8668: 409A0018  bne cr6, 0x821c8680
	if !ctx.cr[6].eq {
	pc = 0x821C8680; continue 'dispatch;
	}
	// 821C866C: 5469103A  slwi r9, r3, 2
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C8670: 9ACB0014  stb r22, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[22].u8 ) };
	// 821C8674: 39430001  addi r10, r3, 1
	ctx.r[10].s64 = ctx.r[3].s64 + 1;
	// 821C8678: 915A0DB0  stw r10, 0xdb0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821C867C: 7D69C92E  stwx r11, r9, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[25].u32), ctx.r[11].u32) };
	// 821C8680: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C8684: E96B1760  ld r11, 0x1760(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(5984 as u32) ) };
	// 821C8688: 796A0004  rldicr r10, r11, 0, 0
	ctx.r[10].u64 = (ctx.r[11].u64).rotate_left(0) & 0x8000000000000000;
	// 821C868C: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 821C8690: 419A001C  beq cr6, 0x821c86ac
	if ctx.cr[6].eq {
	pc = 0x821C86AC; continue 'dispatch;
	}
	// 821C8694: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821C8698: 80770364  lwz r3, 0x364(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C869C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821C86A0: 38B506B0  addi r5, r21, 0x6b0
	ctx.r[5].s64 = ctx.r[21].s64 + 1712;
	// 821C86A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C86A8: 480521D9  bl 0x8221a880
	ctx.lr = 0x821C86AC;
	sub_8221A880(ctx, base);
	// 821C86AC: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C86B0: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 821C86B4: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821C86B8: 396B0150  addi r11, r11, 0x150
	ctx.r[11].s64 = ctx.r[11].s64 + 336;
	// 821C86BC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821C86C0: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821C86C4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821C86C8: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821C86CC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C86D0: 4200FFF0  bdnz 0x821c86c0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821C86C0; continue 'dispatch;
	}
	// 821C86D4: 396000A0  li r11, 0xa0
	ctx.r[11].s64 = 160;
	// 821C86D8: 39410100  addi r10, r1, 0x100
	ctx.r[10].s64 = ctx.r[1].s64 + 256;
	// 821C86DC: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 821C86E0: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C8B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C8B50 size=208
    let mut pc: u32 = 0x821C8B50;
    'dispatch: loop {
        match pc {
            0x821C8B50 => {
    //   block [0x821C8B50..0x821C8C20)
	// 821C8B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C8B54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C8B58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C8B5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C8B60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C8B64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821C8B68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C8B6C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821C8B70: 419A0094  beq cr6, 0x821c8c04
	if ctx.cr[6].eq {
	pc = 0x821C8C04; continue 'dispatch;
	}
	// 821C8B74: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8B78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C8B7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8B80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821C8B84: 4E800421  bctrl
	ctx.lr = 0x821C8B88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C8B88: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821C8B8C: 396B581C  addi r11, r11, 0x581c
	ctx.r[11].s64 = ctx.r[11].s64 + 22556;
	// 821C8B90: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821C8B94: 419A0044  beq cr6, 0x821c8bd8
	if ctx.cr[6].eq {
	pc = 0x821C8BD8; continue 'dispatch;
	}
	// 821C8B98: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 821C8B9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821C8BA0: 4082FFF0  bne 0x821c8b90
	if !ctx.cr[0].eq {
	pc = 0x821C8B90; continue 'dispatch;
	}
	// 821C8BA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C8BA8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C8BAC: 41820058  beq 0x821c8c04
	if ctx.cr[0].eq {
	pc = 0x821C8C04; continue 'dispatch;
	}
	// 821C8BB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8BB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C8BB8: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 821C8BBC: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821C8BC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821C8BC4: 4E800421  bctrl
	ctx.lr = 0x821C8BC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C8BC8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821C8BCC: 40820014  bne 0x821c8be0
	if !ctx.cr[0].eq {
	pc = 0x821C8BE0; continue 'dispatch;
	}
	// 821C8BD0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C8BD4: 48000034  b 0x821c8c08
	pc = 0x821C8C08; continue 'dispatch;
	// 821C8BD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C8BDC: 4BFFFFCC  b 0x821c8ba8
	pc = 0x821C8BA8; continue 'dispatch;
	// 821C8BE0: 809F006C  lwz r4, 0x6c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 821C8BE4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8BE8: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821C8BEC: 419AFFE4  beq cr6, 0x821c8bd0
	if ctx.cr[6].eq {
	pc = 0x821C8BD0; continue 'dispatch;
	}
	// 821C8BF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8BF4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C8BF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821C8BFC: 4E800421  bctrl
	ctx.lr = 0x821C8C00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C8C00: 4BFFFFD0  b 0x821c8bd0
	pc = 0x821C8BD0; continue 'dispatch;
	// 821C8C04: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C8C08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C8C0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C8C10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C8C14: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C8C18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C8C1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C8C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C8C20 size=564
    let mut pc: u32 = 0x821C8C20;
    'dispatch: loop {
        match pc {
            0x821C8C20 => {
    //   block [0x821C8C20..0x821C8E54)
	// 821C8C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C8C24: 48AE07E1  bl 0x82ca9404
	ctx.lr = 0x821C8C28;
	sub_82CA93D0(ctx, base);
	// 821C8C28: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C8C2C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821C8C30: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821C8C34: 386000A5  li r3, 0xa5
	ctx.r[3].s64 = 165;
	// 821C8C38: 897C00D8  lbz r11, 0xd8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(216 as u32) ) } as u64;
	// 821C8C3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C8C40: 419A0010  beq cr6, 0x821c8c50
	if ctx.cr[6].eq {
	pc = 0x821C8C50; continue 'dispatch;
	}
	// 821C8C44: 480635CD  bl 0x8222c210
	ctx.lr = 0x821C8C48;
	sub_8222C210(ctx, base);
	// 821C8C48: 386000A7  li r3, 0xa7
	ctx.r[3].s64 = 167;
	// 821C8C4C: 4800000C  b 0x821c8c58
	pc = 0x821C8C58; continue 'dispatch;
	// 821C8C50: 480635C1  bl 0x8222c210
	ctx.lr = 0x821C8C54;
	sub_8222C210(ctx, base);
	// 821C8C54: 386000A6  li r3, 0xa6
	ctx.r[3].s64 = 166;
	// 821C8C58: 4803FEB9  bl 0x82208b10
	ctx.lr = 0x821C8C5C;
	sub_82208B10(ctx, base);
	// 821C8C5C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C8C60: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C8C64: 3FA08336  lis r29, -0x7cca
	ctx.r[29].s64 = -2093613056;
	// 821C8C68: 795EFFE6  rldicr r30, r10, 0x3f, 0x3f
	ctx.r[30].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821C8C6C: E96B1760  ld r11, 0x1760(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(5984 as u32) ) };
	// 821C8C70: 79690004  rldicr r9, r11, 0, 0
	ctx.r[9].u64 = (ctx.r[11].u64).rotate_left(0) & 0x8000000000000000;
	// 821C8C74: 2B290000  cmpldi cr6, r9, 0
	ctx.cr[6].compare_u64(ctx.r[9].u64, 0, &mut ctx.xer);
	// 821C8C78: 419A001C  beq cr6, 0x821c8c94
	if ctx.cr[6].eq {
	pc = 0x821C8C94; continue 'dispatch;
	}
	// 821C8C7C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821C8C80: 807D0364  lwz r3, 0x364(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C8C84: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821C8C88: 38BF06B0  addi r5, r31, 0x6b0
	ctx.r[5].s64 = ctx.r[31].s64 + 1712;
	// 821C8C8C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C8C90: 48051BF1  bl 0x8221a880
	ctx.lr = 0x821C8C94;
	sub_8221A880(ctx, base);
	// 821C8C94: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821C8C98: 389C00D0  addi r4, r28, 0xd0
	ctx.r[4].s64 = ctx.r[28].s64 + 208;
	// 821C8C9C: 394BDED4  addi r10, r11, -0x212c
	ctx.r[10].s64 = ctx.r[11].s64 + -8492;
	// 821C8CA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C8CA4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8CA8: 83EB0BD0  lwz r31, 0xbd0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3024 as u32) ) } as u64;
	// 821C8CAC: 48003EE5  bl 0x821ccb90
	ctx.lr = 0x821C8CB0;
	sub_821CCB90(ctx, base);
	// 821C8CB0: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821C8CB4: 41980024  blt cr6, 0x821c8cd8
	if ctx.cr[6].lt {
	pc = 0x821C8CD8; continue 'dispatch;
	}
	// 821C8CB8: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 821C8CBC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8CC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C8CC4: 807D0364  lwz r3, 0x364(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C8CC8: 79690020  clrldi r9, r11, 0x20
	ctx.r[9].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821C8CCC: 7FC64C36  srd r6, r30, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[30].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 821C8CD0: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8CD4: 4BFEE20D  bl 0x821b6ee0
	ctx.lr = 0x821C8CD8;
	sub_821B6EE0(ctx, base);
	// 821C8CD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C8CDC: 4BFEEE3D  bl 0x821b7b18
	ctx.lr = 0x821C8CE0;
	sub_821B7B18(ctx, base);
	// 821C8CE0: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C8CE4: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821C8CE8: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 821C8CEC: 38EA63A0  addi r7, r10, 0x63a0
	ctx.r[7].s64 = ctx.r[10].s64 + 25504;
	// 821C8CF0: 55661838  slwi r6, r11, 3
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821C8CF4: 39671050  addi r11, r7, 0x1050
	ctx.r[11].s64 = ctx.r[7].s64 + 4176;
	// 821C8CF8: 3D408331  lis r10, -0x7ccf
	ctx.r[10].s64 = -2093940736;
	// 821C8CFC: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 821C8D00: 390A6FC0  addi r8, r10, 0x6fc0
	ctx.r[8].s64 = ctx.r[10].s64 + 28608;
	// 821C8D04: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821C8D08: 3D20834B  lis r9, -0x7cb5
	ctx.r[9].s64 = -2092236800;
	// 821C8D0C: 3BAA0DB8  addi r29, r10, 0xdb8
	ctx.r[29].s64 = ctx.r[10].s64 + 3512;
	// 821C8D10: 38A92390  addi r5, r9, 0x2390
	ctx.r[5].s64 = ctx.r[9].s64 + 9104;
	// 821C8D14: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8D18: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821C8D1C: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 821C8D20: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821C8D24: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8D28: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s64 = ctx.r[10].s64 * 8200;
	// 821C8D2C: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 821C8D30: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 821C8D34: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C8D38: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C8D3C: 419A007C  beq cr6, 0x821c8db8
	if ctx.cr[6].eq {
	pc = 0x821C8DB8; continue 'dispatch;
	}
	// 821C8D40: 808A2000  lwz r4, 0x2000(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C8D44: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C8D48: 7C7B2038  and r27, r3, r4
	ctx.r[27].u64 = ctx.r[3].u64 & ctx.r[4].u64;
	// 821C8D4C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821C8D50: 409A003C  bne cr6, 0x821c8d8c
	if !ctx.cr[6].eq {
	pc = 0x821C8D8C; continue 'dispatch;
	}
	// 821C8D54: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8D58: 7C642378  or r4, r3, r4
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[4].u64;
	// 821C8D5C: 55231838  slwi r3, r9, 3
	ctx.r[3].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821C8D60: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 821C8D64: 7D63512E  stwx r11, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821C8D68: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8D6C: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8D70: 54691838  slwi r9, r3, 3
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C8D74: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821C8D78: 90890004  stw r4, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 821C8D7C: 808A2004  lwz r4, 0x2004(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8D80: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 821C8D84: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8D88: 908A2004  stw r4, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[4].u32 ) };
	// 821C8D8C: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C8D90: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821C8D94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C8D98: 409A0020  bne cr6, 0x821c8db8
	if !ctx.cr[6].eq {
	pc = 0x821C8DB8; continue 'dispatch;
	}
	// 821C8D9C: 815E0DB0  lwz r10, 0xdb0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821C8DA0: 9B8B0014  stb r28, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[28].u8 ) };
	// 821C8DA4: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C8DA8: 388A0001  addi r4, r10, 1
	ctx.r[4].s64 = ctx.r[10].s64 + 1;
	// 821C8DAC: 909E0DB0  stw r4, 0xdb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 821C8DB0: 7D68E92E  stwx r11, r8, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[29].u32), ctx.r[11].u32) };
	// 821C8DB4: 48000008  b 0x821c8dbc
	pc = 0x821C8DBC; continue 'dispatch;
	// 821C8DB8: 809E0DB0  lwz r4, 0xdb0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821C8DBC: 39671230  addi r11, r7, 0x1230
	ctx.r[11].s64 = ctx.r[7].s64 + 4656;
	// 821C8DC0: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 821C8DC4: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821C8DC8: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8DCC: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s64 = ctx.r[10].s64 * 8200;
	// 821C8DD0: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 821C8DD4: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C8DD8: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C8DDC: 419A0070  beq cr6, 0x821c8e4c
	if ctx.cr[6].eq {
	pc = 0x821C8E4C; continue 'dispatch;
	}
	// 821C8DE0: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C8DE4: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C8DE8: 7CE64038  and r6, r7, r8
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 821C8DEC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821C8DF0: 409A0038  bne cr6, 0x821c8e28
	if !ctx.cr[6].eq {
	pc = 0x821C8E28; continue 'dispatch;
	}
	// 821C8DF4: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8DF8: 7CE54378  or r5, r7, r8
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 821C8DFC: 54C31838  slwi r3, r6, 3
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821C8E00: 90AB0008  stw r5, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 821C8E04: 7D63512E  stwx r11, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821C8E08: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8E0C: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8E10: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C8E14: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C8E18: 90E60004  stw r7, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821C8E1C: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8E20: 38A80001  addi r5, r8, 1
	ctx.r[5].s64 = ctx.r[8].s64 + 1;
	// 821C8E24: 90AA2004  stw r5, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	// 821C8E28: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C8E2C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C8E30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C8E34: 409A0018  bne cr6, 0x821c8e4c
	if !ctx.cr[6].eq {
	pc = 0x821C8E4C; continue 'dispatch;
	}
	// 821C8E38: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C8E3C: 9B8B0014  stb r28, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[28].u8 ) };
	// 821C8E40: 39440001  addi r10, r4, 1
	ctx.r[10].s64 = ctx.r[4].s64 + 1;
	// 821C8E44: 915E0DB0  stw r10, 0xdb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821C8E48: 7D69E92E  stwx r11, r9, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32), ctx.r[11].u32) };
	// 821C8E4C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821C8E50: 48AE0604  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C8E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C8E58 size=68
    let mut pc: u32 = 0x821C8E58;
    'dispatch: loop {
        match pc {
            0x821C8E58 => {
    //   block [0x821C8E58..0x821C8E9C)
	// 821C8E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C8E5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C8E60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C8E64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C8E68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821C8E6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C8E70: 480B2321  bl 0x8227b190
	ctx.lr = 0x821C8E74;
	sub_8227B190(ctx, base);
	// 821C8E74: 817F06FC  lwz r11, 0x6fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821C8E78: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821C8E7C: 409A000C  bne cr6, 0x821c8e88
	if !ctx.cr[6].eq {
	pc = 0x821C8E88; continue 'dispatch;
	}
	// 821C8E80: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8E84: 48000225  bl 0x821c90a8
	ctx.lr = 0x821C8E88;
	sub_821C90A8(ctx, base);
	// 821C8E88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C8E8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C8E90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C8E94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C8E98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C8EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C8EA0 size=268
    let mut pc: u32 = 0x821C8EA0;
    'dispatch: loop {
        match pc {
            0x821C8EA0 => {
    //   block [0x821C8EA0..0x821C8FAC)
	// 821C8EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C8EA4: 48AE0569  bl 0x82ca940c
	ctx.lr = 0x821C8EA8;
	sub_82CA93D0(ctx, base);
	// 821C8EA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C8EAC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C8EB0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C8EB4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C8EB8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C8EBC: 812A0080  lwz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 821C8EC0: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8EC4: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8EC8: 54EA003E  slwi r10, r7, 0
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C8ECC: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8ED0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C8ED4: 409A000C  bne cr6, 0x821c8ee0
	if !ctx.cr[6].eq {
	pc = 0x821C8EE0; continue 'dispatch;
	}
	// 821C8ED8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C8EDC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C8EE0: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C8EE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C8EE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8EEC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8EF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C8EF4: 4E800421  bctrl
	ctx.lr = 0x821C8EF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C8EF8: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 821C8EFC: 419A0024  beq cr6, 0x821c8f20
	if ctx.cr[6].eq {
	pc = 0x821C8F20; continue 'dispatch;
	}
	// 821C8F00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8F04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C8F08: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8F0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C8F10: 4E800421  bctrl
	ctx.lr = 0x821C8F14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C8F14: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 821C8F18: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821C8F1C: 409A0008  bne cr6, 0x821c8f24
	if !ctx.cr[6].eq {
	pc = 0x821C8F24; continue 'dispatch;
	}
	// 821C8F20: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 821C8F24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8F28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C8F2C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8F30: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C8F34: 4E800421  bctrl
	ctx.lr = 0x821C8F38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C8F38: 3923FFFC  addi r9, r3, -4
	ctx.r[9].s64 = ctx.r[3].s64 + -4;
	// 821C8F3C: 57A8063E  clrlwi r8, r29, 0x18
	ctx.r[8].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 821C8F40: 7D270034  cntlzw r7, r9
	ctx.r[7].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821C8F44: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821C8F48: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 821C8F4C: 68CB0001  xori r11, r6, 1
	ctx.r[11].u64 = ctx.r[6].u64 ^ 1;
	// 821C8F50: 409A0054  bne cr6, 0x821c8fa4
	if !ctx.cr[6].eq {
	pc = 0x821C8FA4; continue 'dispatch;
	}
	// 821C8F54: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C8F58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C8F5C: 419A0048  beq cr6, 0x821c8fa4
	if ctx.cr[6].eq {
	pc = 0x821C8FA4; continue 'dispatch;
	}
	// 821C8F60: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C8F64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C8F68: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C8F6C: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821C8F70: 480F8DB9  bl 0x822c1d28
	ctx.lr = 0x821C8F74;
	sub_822C1D28(ctx, base);
	// 821C8F74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C8F78: 4BFBCC49  bl 0x82185bc0
	ctx.lr = 0x821C8F7C;
	sub_82185BC0(ctx, base);
	// 821C8F7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C8F80: 480F8EE1  bl 0x822c1e60
	ctx.lr = 0x821C8F84;
	sub_822C1E60(ctx, base);
	// 821C8F84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C8F88: 4BFBCD69  bl 0x82185cf0
	ctx.lr = 0x821C8F8C;
	sub_82185CF0(ctx, base);
	// 821C8F8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C8F90: 480F8C61  bl 0x822c1bf0
	ctx.lr = 0x821C8F94;
	sub_822C1BF0(ctx, base);
	// 821C8F94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C8F98: 4BFBCFF1  bl 0x82185f88
	ctx.lr = 0x821C8F9C;
	sub_82185F88(ctx, base);
	// 821C8F9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C8FA0: 480F8999  bl 0x822c1938
	ctx.lr = 0x821C8FA4;
	sub_822C1938(ctx, base);
	// 821C8FA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C8FA8: 48AE04B4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C8FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C8FB0 size=244
    let mut pc: u32 = 0x821C8FB0;
    'dispatch: loop {
        match pc {
            0x821C8FB0 => {
    //   block [0x821C8FB0..0x821C90A4)
	// 821C8FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C8FB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C8FB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C8FBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C8FC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C8FC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C8FC8: 4BFC3CB9  bl 0x8218cc80
	ctx.lr = 0x821C8FCC;
	sub_8218CC80(ctx, base);
	// 821C8FCC: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 821C8FD0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8FD4: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8FD8: 48068A51  bl 0x82231a28
	ctx.lr = 0x821C8FDC;
	sub_82231A28(ctx, base);
	// 821C8FDC: 813F0058  lwz r9, 0x58(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 821C8FE0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8FE4: 386B00B4  addi r3, r11, 0xb4
	ctx.r[3].s64 = ctx.r[11].s64 + 180;
	// 821C8FE8: 485D7E31  bl 0x827a0e18
	ctx.lr = 0x821C8FEC;
	sub_827A0E18(ctx, base);
	// 821C8FEC: 807F008C  lwz r3, 0x8c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C8FF0: 4BFCCF21  bl 0x82195f10
	ctx.lr = 0x821C8FF4;
	sub_82195F10(ctx, base);
	// 821C8FF4: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 821C8FF8: 807EE9EC  lwz r3, -0x1614(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-5652 as u32) ) } as u64;
	// 821C8FFC: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C9000: 80E80018  lwz r7, 0x18(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 821C9004: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821C9008: 4E800421  bctrl
	ctx.lr = 0x821C900C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C900C: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 821C9010: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821C9014: 809F009C  lwz r4, 0x9c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 821C9018: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C901C: C0259490  lfs f1, -0x6b70(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C9020: 48003EB9  bl 0x821cced8
	ctx.lr = 0x821C9024;
	sub_821CCED8(ctx, base);
	// 821C9024: 809F0080  lwz r4, 0x80(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 821C9028: 80640004  lwz r3, 4(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C902C: 4BFAD295  bl 0x821762c0
	ctx.lr = 0x821C9030;
	sub_821762C0(ctx, base);
	// 821C9030: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 821C9034: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C9038: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 821C903C: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 821C9040: 995F0108  stb r10, 0x108(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[10].u8 ) };
	// 821C9044: 913F00FC  stw r9, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[9].u32 ) };
	// 821C9048: 482835F1  bl 0x8244c638
	ctx.lr = 0x821C904C;
	sub_8244C638(ctx, base);
	// 821C904C: 807F009C  lwz r3, 0x9c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 821C9050: 4BFC1531  bl 0x8218a580
	ctx.lr = 0x821C9054;
	sub_8218A580(ctx, base);
	// 821C9054: 811F00A4  lwz r8, 0xa4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 821C9058: 80680004  lwz r3, 4(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C905C: 4BFBB965  bl 0x821849c0
	ctx.lr = 0x821C9060;
	sub_821849C0(ctx, base);
	// 821C9060: 80FF00A8  lwz r7, 0xa8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 821C9064: 80670004  lwz r3, 4(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C9068: 480B2F29  bl 0x8227bf90
	ctx.lr = 0x821C906C;
	sub_8227BF90(ctx, base);
	// 821C906C: 807EE9EC  lwz r3, -0x1614(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-5652 as u32) ) } as u64;
	// 821C9070: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C9074: 80A6001C  lwz r5, 0x1c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C9078: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 821C907C: 4E800421  bctrl
	ctx.lr = 0x821C9080;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C9080: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C9084: 807F00AC  lwz r3, 0xac(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 821C9088: 4BFCC619  bl 0x821956a0
	ctx.lr = 0x821C908C;
	sub_821956A0(ctx, base);
	// 821C908C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C9090: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C9094: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C9098: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C909C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C90A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C90A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C90A8 size=288
    let mut pc: u32 = 0x821C90A8;
    'dispatch: loop {
        match pc {
            0x821C90A8 => {
    //   block [0x821C90A8..0x821C91C8)
	// 821C90A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C90AC: 48AE0359  bl 0x82ca9404
	ctx.lr = 0x821C90B0;
	sub_82CA93D0(ctx, base);
	// 821C90B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C90B4: 3F608336  lis r27, -0x7cca
	ctx.r[27].s64 = -2093613056;
	// 821C90B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821C90BC: 817BF94C  lwz r11, -0x6b4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-1716 as u32) ) } as u64;
	// 821C90C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C90C4: 409A00F4  bne cr6, 0x821c91b8
	if !ctx.cr[6].eq {
	pc = 0x821C91B8; continue 'dispatch;
	}
	// 821C90C8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C90CC: 3B8B4FF8  addi r28, r11, 0x4ff8
	ctx.r[28].s64 = ctx.r[11].s64 + 20472;
	// 821C90D0: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C90D4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C90D8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C90DC: 4099000C  ble cr6, 0x821c90e8
	if !ctx.cr[6].gt {
	pc = 0x821C90E8; continue 'dispatch;
	}
	// 821C90E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C90E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C90E8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821C90EC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821C90F0: 419A0034  beq cr6, 0x821c9124
	if ctx.cr[6].eq {
	pc = 0x821C9124; continue 'dispatch;
	}
	// 821C90F4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C90F8: 41980008  blt cr6, 0x821c9100
	if ctx.cr[6].lt {
	pc = 0x821C9100; continue 'dispatch;
	}
	// 821C90FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C9100: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821C9104: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C9108: 48966699  bl 0x82b2f7a0
	ctx.lr = 0x821C910C;
	sub_82B2F7A0(ctx, base);
	// 821C910C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C9110: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C9114: 41980008  blt cr6, 0x821c911c
	if ctx.cr[6].lt {
	pc = 0x821C911C; continue 'dispatch;
	}
	// 821C9118: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C911C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821C9120: 4BFFFFCC  b 0x821c90ec
	pc = 0x821C90EC; continue 'dispatch;
	// 821C9124: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C9128: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C912C: 40990008  ble cr6, 0x821c9134
	if !ctx.cr[6].gt {
	pc = 0x821C9134; continue 'dispatch;
	}
	// 821C9130: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C9134: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 821C9138: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C913C: 40990008  ble cr6, 0x821c9144
	if !ctx.cr[6].gt {
	pc = 0x821C9144; continue 'dispatch;
	}
	// 821C9140: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C9144: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821C9148: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821C914C: 419A0068  beq cr6, 0x821c91b4
	if ctx.cr[6].eq {
	pc = 0x821C91B4; continue 'dispatch;
	}
	// 821C9150: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C9154: 41980008  blt cr6, 0x821c915c
	if ctx.cr[6].lt {
	pc = 0x821C915C; continue 'dispatch;
	}
	// 821C9158: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C915C: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C9160: 815F00DC  lwz r10, 0xdc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 821C9164: 813F00D8  lwz r9, 0xd8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 821C9168: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821C916C: 5507003A  rlwinm r7, r8, 0, 0, 0x1d
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821C9170: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821C9174: 419A002C  beq cr6, 0x821c91a0
	if ctx.cr[6].eq {
	pc = 0x821C91A0; continue 'dispatch;
	}
	// 821C9178: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 821C917C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C9180: 419A000C  beq cr6, 0x821c918c
	if ctx.cr[6].eq {
	pc = 0x821C918C; continue 'dispatch;
	}
	// 821C9184: 489707E5  bl 0x82b39968
	ctx.lr = 0x821C9188;
	sub_82B39968(ctx, base);
	// 821C9188: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C918C: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 821C9190: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C9194: 419A000C  beq cr6, 0x821c91a0
	if ctx.cr[6].eq {
	pc = 0x821C91A0; continue 'dispatch;
	}
	// 821C9198: 489707D1  bl 0x82b39968
	ctx.lr = 0x821C919C;
	sub_82B39968(ctx, base);
	// 821C919C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C91A0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C91A4: 41980008  blt cr6, 0x821c91ac
	if ctx.cr[6].lt {
	pc = 0x821C91AC; continue 'dispatch;
	}
	// 821C91A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C91AC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821C91B0: 4BFFFF98  b 0x821c9148
	pc = 0x821C9148; continue 'dispatch;
	// 821C91B4: 817BF94C  lwz r11, -0x6b4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-1716 as u32) ) } as u64;
	// 821C91B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C91BC: 917BF94C  stw r11, -0x6b4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(-1716 as u32), ctx.r[11].u32 ) };
	// 821C91C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821C91C4: 48AE0290  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C91C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C91C8 size=56
    let mut pc: u32 = 0x821C91C8;
    'dispatch: loop {
        match pc {
            0x821C91C8 => {
    //   block [0x821C91C8..0x821C9200)
	// 821C91C8: 81633098  lwz r11, 0x3098(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12440 as u32) ) } as u64;
	// 821C91CC: 90832E54  stw r4, 0x2e54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(11860 as u32), ctx.r[4].u32 ) };
	// 821C91D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C91D4: 409A0008  bne cr6, 0x821c91dc
	if !ctx.cr[6].eq {
	pc = 0x821C91DC; continue 'dispatch;
	}
	// 821C91D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C91DC: 816328DC  lwz r11, 0x28dc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(10460 as u32) ) } as u64;
	// 821C91E0: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821C91E4: 51640036  rlwimi r4, r11, 0, 0, 0x1b
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(0) as u64) & 0x00000000FFFFFFF0) | (ctx.r[4].u64 & 0xFFFFFFFF0000000F);
	// 821C91E8: 798C2FE6  rldicr r12, r12, 0x25, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(37) & 0xFFFFFFFFFFFFFFFF;
	// 821C91EC: 908328DC  stw r4, 0x28dc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10460 as u32), ctx.r[4].u32 ) };
	// 821C91F0: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 821C91F4: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821C91F8: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821C91FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C9200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C9200 size=152
    let mut pc: u32 = 0x821C9200;
    'dispatch: loop {
        match pc {
            0x821C9200 => {
    //   block [0x821C9200..0x821C9298)
	// 821C9200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C9204: 48AE0205  bl 0x82ca9408
	ctx.lr = 0x821C9208;
	sub_82CA93D0(ctx, base);
	// 821C9208: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C920C: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C9210: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821C9214: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 821C9218: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821C921C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C9220: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821C9224: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 821C9228: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C922C: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C9230: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C9234: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821C9238: 419A0008  beq cr6, 0x821c9240
	if ctx.cr[6].eq {
	pc = 0x821C9240; continue 'dispatch;
	}
	// 821C923C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C9240: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C9244: 419A004C  beq cr6, 0x821c9290
	if ctx.cr[6].eq {
	pc = 0x821C9290; continue 'dispatch;
	}
	// 821C9248: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C924C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C9250: 409A0008  bne cr6, 0x821c9258
	if !ctx.cr[6].eq {
	pc = 0x821C9258; continue 'dispatch;
	}
	// 821C9254: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C9258: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821C925C: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 821C9260: 7F0AE000  cmpw cr6, r10, r28
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[28].s32, &mut ctx.xer);
	// 821C9264: 4099002C  ble cr6, 0x821c9290
	if !ctx.cr[6].gt {
	pc = 0x821C9290; continue 'dispatch;
	}
	// 821C9268: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821C926C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821C9270: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821C9274: 489804DD  bl 0x82b49750
	ctx.lr = 0x821C9278;
	sub_82B49750(ctx, base);
	// 821C9278: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C927C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C9280: 409A0008  bne cr6, 0x821c9288
	if !ctx.cr[6].eq {
	pc = 0x821C9288; continue 'dispatch;
	}
	// 821C9284: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C9288: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C928C: 4BFFFFA4  b 0x821c9230
	pc = 0x821C9230; continue 'dispatch;
	// 821C9290: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821C9294: 48AE01C4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C9298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C9298 size=360
    let mut pc: u32 = 0x821C9298;
    'dispatch: loop {
        match pc {
            0x821C9298 => {
    //   block [0x821C9298..0x821C9400)
	// 821C9298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C929C: 48AE016D  bl 0x82ca9408
	ctx.lr = 0x821C92A0;
	sub_82CA93D0(ctx, base);
	// 821C92A0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C92A4: 3FA08336  lis r29, -0x7cca
	ctx.r[29].s64 = -2093613056;
	// 821C92A8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821C92AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821C92B0: 817DF028  lwz r11, -0xfd8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4056 as u32) ) } as u64;
	// 821C92B4: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 821C92B8: 4098013C  bge cr6, 0x821c93f4
	if !ctx.cr[6].lt {
	pc = 0x821C93F4; continue 'dispatch;
	}
	// 821C92BC: 809E007C  lwz r4, 0x7c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C92C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821C92C4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C92C8: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821C92CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C92D0: 4E800421  bctrl
	ctx.lr = 0x821C92D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C92D4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C92D8: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821C92DC: 809E007C  lwz r4, 0x7c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C92E0: 3BEBCB94  addi r31, r11, -0x346c
	ctx.r[31].s64 = ctx.r[11].s64 + -13420;
	// 821C92E4: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 821C92E8: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 821C92EC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821C92F0: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821C92F4: C01FC8F0  lfs f0, -0x3710(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-14096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C92F8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C9400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C9400 size=384
    let mut pc: u32 = 0x821C9400;
    'dispatch: loop {
        match pc {
            0x821C9400 => {
    //   block [0x821C9400..0x821C9580)
	// 821C9400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C9404: 48AE0009  bl 0x82ca940c
	ctx.lr = 0x821C9408;
	sub_82CA93D0(ctx, base);
	// 821C9408: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C940C: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821C9410: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821C9414: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821C9418: 892B5E6F  lbz r9, 0x5e6f(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24175 as u32) ) } as u64;
	// 821C941C: C00A9490  lfs f0, -0x6b70(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C9420: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821C9424: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C9428: 419A0020  beq cr6, 0x821c9448
	if ctx.cr[6].eq {
	pc = 0x821C9448; continue 'dispatch;
	}
	// 821C942C: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C9430: 39400060  li r10, 0x60
	ctx.r[10].s64 = 96;
	// 821C9434: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C9580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C9580 size=196
    let mut pc: u32 = 0x821C9580;
    'dispatch: loop {
        match pc {
            0x821C9580 => {
    //   block [0x821C9580..0x821C9644)
	// 821C9580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C9584: 48ADFE81  bl 0x82ca9404
	ctx.lr = 0x821C9588;
	sub_82CA93D0(ctx, base);
	// 821C9588: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C958C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 821C9590: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C9594: 4805EB65  bl 0x822280f8
	ctx.lr = 0x821C9598;
	sub_822280F8(ctx, base);
	// 821C9598: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821C959C: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 821C95A0: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821C95A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C95A8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C95AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C95B0: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 821C95B4: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 821C95B8: 83C80004  lwz r30, 4(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C95BC: 83A80000  lwz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C95C0: 4805EB39  bl 0x822280f8
	ctx.lr = 0x821C95C4;
	sub_822280F8(ctx, base);
	// 821C95C4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C95C8: 4805DF99  bl 0x82227560
	ctx.lr = 0x821C95CC;
	sub_82227560(ctx, base);
	// 821C95CC: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 821C95D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C95D4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821C95D8: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C95DC: 481388BD  bl 0x82301e98
	ctx.lr = 0x821C95E0;
	sub_82301E98(ctx, base);
	// 821C95E0: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 821C95E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C95E8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821C95EC: 88610051  lbz r3, 0x51(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 821C95F0: 481388A9  bl 0x82301e98
	ctx.lr = 0x821C95F4;
	sub_82301E98(ctx, base);
	// 821C95F4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821C95F8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821C95FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821C9600: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 821C9604: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 821C9608: 4E800421  bctrl
	ctx.lr = 0x821C960C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C960C: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C9610: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C9614: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821C9618: 7CE40034  cntlzw r4, r7
	ctx.r[4].u64 = if ctx.r[7].u32 == 0 { 32 } else { ctx.r[7].u32.leading_zeros() as u64 };
	// 821C961C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C9620: 548BDFFE  rlwinm r11, r4, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 821C9624: 696A0001  xori r10, r11, 1
	ctx.r[10].u64 = ctx.r[11].u64 ^ 1;
	// 821C9628: 90A60004  stw r5, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 821C962C: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821C9630: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C9634: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 821C9638: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821C963C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821C9640: 48ADFE14  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C9648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C9648 size=12
    let mut pc: u32 = 0x821C9648;
    'dispatch: loop {
        match pc {
            0x821C9648 => {
    //   block [0x821C9648..0x821C9654)
	// 821C9648: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C964C: 806B006C  lwz r3, 0x6c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 821C9650: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C9658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C9658 size=2052
    let mut pc: u32 = 0x821C9658;
    'dispatch: loop {
        match pc {
            0x821C9658 => {
    //   block [0x821C9658..0x821C9E5C)
	// 821C9658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C965C: 48ADFD99  bl 0x82ca93f4
	ctx.lr = 0x821C9660;
	sub_82CA93D0(ctx, base);
	// 821C9660: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 821C9664: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C9E60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C9E60 size=40
    let mut pc: u32 = 0x821C9E60;
    'dispatch: loop {
        match pc {
            0x821C9E60 => {
    //   block [0x821C9E60..0x821C9E88)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C9E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C9E88 size=192
    let mut pc: u32 = 0x821C9E88;
    'dispatch: loop {
        match pc {
            0x821C9E88 => {
    //   block [0x821C9E88..0x821C9F48)
	// 821C9E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C9E8C: 48ADF57D  bl 0x82ca9408
	ctx.lr = 0x821C9E90;
	sub_82CA93D0(ctx, base);
	// 821C9E90: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C9E94: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821C9E98: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821C9E9C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821C9EA0: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821C9EA4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821C9EA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C9EAC: 419A0094  beq cr6, 0x821c9f40
	if ctx.cr[6].eq {
	pc = 0x821C9F40; continue 'dispatch;
	}
	// 821C9EB0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821C9EB4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821C9EB8: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C9EBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821C9EC0: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 821C9EC4: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 821C9EC8: 4801BAA9  bl 0x821e5970
	ctx.lr = 0x821C9ECC;
	sub_821E5970(ctx, base);
	// 821C9ECC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C9ED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C9ED4: 419A004C  beq cr6, 0x821c9f20
	if ctx.cr[6].eq {
	pc = 0x821C9F20; continue 'dispatch;
	}
	// 821C9ED8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C9EDC: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 821C9EE0: 81260000  lwz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C9EE4: 39460004  addi r10, r6, 4
	ctx.r[10].s64 = ctx.r[6].s64 + 4;
	// 821C9EE8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C9EEC: 5529C23E  srwi r9, r9, 8
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C9EF0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C9EF4: 4098002C  bge cr6, 0x821c9f20
	if !ctx.cr[6].lt {
	pc = 0x821C9F20; continue 'dispatch;
	}
	// 821C9EF8: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C9EFC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C9F00: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C9F04: 7F08F040  cmplw cr6, r8, r30
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821C9F08: 409A0018  bne cr6, 0x821c9f20
	if !ctx.cr[6].eq {
	pc = 0x821C9F20; continue 'dispatch;
	}
	// 821C9F0C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C9F10: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821C9F14: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821C9F18: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C9F1C: 4198FFE4  blt cr6, 0x821c9f00
	if ctx.cr[6].lt {
	pc = 0x821C9F00; continue 'dispatch;
	}
	// 821C9F20: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821C9F24: 409A0018  bne cr6, 0x821c9f3c
	if !ctx.cr[6].eq {
	pc = 0x821C9F3C; continue 'dispatch;
	}
	// 821C9F28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821C9F2C: 4801B9AD  bl 0x821e58d8
	ctx.lr = 0x821C9F30;
	sub_821E58D8(ctx, base);
	// 821C9F30: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821C9F34: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821C9F38: 409AFF78  bne cr6, 0x821c9eb0
	if !ctx.cr[6].eq {
	pc = 0x821C9EB0; continue 'dispatch;
	}
	// 821C9F3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C9F40: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821C9F44: 48ADF514  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C9F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C9F48 size=228
    let mut pc: u32 = 0x821C9F48;
    'dispatch: loop {
        match pc {
            0x821C9F48 => {
    //   block [0x821C9F48..0x821CA02C)
	// 821C9F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C9F4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C9F50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C9F54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C9F58: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CA030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CA030 size=212
    let mut pc: u32 = 0x821CA030;
    'dispatch: loop {
        match pc {
            0x821CA030 => {
    //   block [0x821CA030..0x821CA104)
	// 821CA030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CA034: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821CA038: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CA03C: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 821CA040: 39800080  li r12, 0x80
	ctx.r[12].s64 = 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CA108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CA108 size=1248
    let mut pc: u32 = 0x821CA108;
    'dispatch: loop {
        match pc {
            0x821CA108 => {
    //   block [0x821CA108..0x821CA5E8)
	// 821CA108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CA10C: 48ADF2D5  bl 0x82ca93e0
	ctx.lr = 0x821CA110;
	sub_82CA93D0(ctx, base);
	// 821CA110: DBE1FF80  stfd f31, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 821CA114: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CA118: 7CB22B78  mr r18, r5
	ctx.r[18].u64 = ctx.r[5].u64;
	// 821CA11C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CA120: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 821CA124: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821CA128: 2B120000  cmplwi cr6, r18, 0
	ctx.cr[6].compare_u32(ctx.r[18].u32, 0 as u32, &mut ctx.xer);
	// 821CA12C: 409A0014  bne cr6, 0x821ca140
	if !ctx.cr[6].eq {
	pc = 0x821CA140; continue 'dispatch;
	}
	// 821CA130: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821CA134: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 821CA138: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 821CA13C: 48ADF2F4  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
	// 821CA140: 817500B0  lwz r11, 0xb0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(176 as u32) ) } as u64;
	// 821CA144: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CA148: 4099FFE8  ble cr6, 0x821ca130
	if !ctx.cr[6].gt {
	pc = 0x821CA130; continue 'dispatch;
	}
	// 821CA14C: 3FC08336  lis r30, -0x7cca
	ctx.r[30].s64 = -2093613056;
	// 821CA150: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821CA154: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 821CA158: 3A800008  li r20, 8
	ctx.r[20].s64 = 8;
	// 821CA15C: 393F06B0  addi r9, r31, 0x6b0
	ctx.r[9].s64 = ctx.r[31].s64 + 1712;
	// 821CA160: 817E0364  lwz r11, 0x364(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(868 as u32) ) } as u64;
	// 821CA164: 39010110  addi r8, r1, 0x110
	ctx.r[8].s64 = ctx.r[1].s64 + 272;
	// 821CA168: 814A10AC  lwz r10, 0x10ac(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4268 as u32) ) } as u64;
	// 821CA16C: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 821CA170: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 821CA174: 914B2E2C  stw r10, 0x2e2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(11820 as u32), ctx.r[10].u32 ) };
	// 821CA178: E8850010  ld r4, 0x10(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	// 821CA17C: 64830008  oris r3, r4, 8
	ctx.r[3].u64 = ctx.r[4].u64 | 524288;
	// 821CA180: 914670B8  stw r10, 0x70b8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28856 as u32), ctx.r[10].u32 ) };
	// 821CA184: F8650010  std r3, 0x10(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[3].u64 ) };
	// 821CA188: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821CA18C: E9690000  ld r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 821CA190: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 821CA194: F9680000  std r11, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821CA198: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 821CA19C: 4200FFF0  bdnz 0x821ca18c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821CA18C; continue 'dispatch;
	}
	// 821CA1A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CA1A4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821CA1A8: 388B0150  addi r4, r11, 0x150
	ctx.r[4].s64 = ctx.r[11].s64 + 336;
	// 821CA1AC: 480A6B25  bl 0x82270cd0
	ctx.lr = 0x821CA1B0;
	sub_82270CD0(ctx, base);
	// 821CA1B0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821CA1B4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 821CA1B8: 480A6B19  bl 0x82270cd0
	ctx.lr = 0x821CA1BC;
	sub_82270CD0(ctx, base);
	// 821CA1BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821CA1C0: 38600162  li r3, 0x162
	ctx.r[3].s64 = 354;
	// 821CA1C4: 4BFFDF4D  bl 0x821c8110
	ctx.lr = 0x821CA1C8;
	sub_821C8110(ctx, base);
	// 821CA1C8: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 821CA1CC: 39610110  addi r11, r1, 0x110
	ctx.r[11].s64 = ctx.r[1].s64 + 272;
	// 821CA1D0: 7E89A378  mr r9, r20
	ctx.r[9].u64 = ctx.r[20].u64;
	// 821CA1D4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821CA1D8: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821CA1DC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821CA1E0: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821CA1E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CA1E8: 4200FFF0  bdnz 0x821ca1d8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821CA1D8; continue 'dispatch;
	}
	// 821CA1EC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821CA1F0: E96B1760  ld r11, 0x1760(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(5984 as u32) ) };
	// 821CA1F4: 796A0004  rldicr r10, r11, 0, 0
	ctx.r[10].u64 = (ctx.r[11].u64).rotate_left(0) & 0x8000000000000000;
	// 821CA1F8: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 821CA1FC: 419A0020  beq cr6, 0x821ca21c
	if ctx.cr[6].eq {
	pc = 0x821CA21C; continue 'dispatch;
	}
	// 821CA200: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821CA204: 807E0364  lwz r3, 0x364(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(868 as u32) ) } as u64;
	// 821CA208: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821CA20C: 78E7FFE6  rldicr r7, r7, 0x3f, 0x3f
	ctx.r[7].u64 = (ctx.r[7].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821CA210: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 821CA214: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821CA218: 48050669  bl 0x8221a880
	ctx.lr = 0x821CA21C;
	sub_8221A880(ctx, base);
	// 821CA21C: 39600690  li r11, 0x690
	ctx.r[11].s64 = 1680;
	// 821CA220: 38600126  li r3, 0x126
	ctx.r[3].s64 = 294;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CA5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CA5E8 size=420
    let mut pc: u32 = 0x821CA5E8;
    'dispatch: loop {
        match pc {
            0x821CA5E8 => {
    //   block [0x821CA5E8..0x821CA78C)
	// 821CA5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CA5EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821CA5F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CA5F4: 816306FC  lwz r11, 0x6fc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821CA5F8: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 821CA5FC: 419A0180  beq cr6, 0x821ca77c
	if ctx.cr[6].eq {
	pc = 0x821CA77C; continue 'dispatch;
	}
	// 821CA600: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821CA604: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821CA608: 3CE08332  lis r7, -0x7cce
	ctx.r[7].s64 = -2093875200;
	// 821CA60C: 3CC08332  lis r6, -0x7cce
	ctx.r[6].s64 = -2093875200;
	// 821CA610: 3CA08332  lis r5, -0x7cce
	ctx.r[5].s64 = -2093875200;
	// 821CA614: 896B6E61  lbz r11, 0x6e61(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28257 as u32) ) } as u64;
	// 821CA618: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 821CA61C: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 821CA620: 99471626  stb r10, 0x1626(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(5670 as u32), ctx.r[10].u8 ) };
	// 821CA624: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CA628: 99261627  stb r9, 0x1627(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(5671 as u32), ctx.r[9].u8 ) };
	// 821CA62C: 99051628  stb r8, 0x1628(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(5672 as u32), ctx.r[8].u8 ) };
	// 821CA630: 409A014C  bne cr6, 0x821ca77c
	if !ctx.cr[6].eq {
	pc = 0x821CA77C; continue 'dispatch;
	}
	// 821CA634: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821CA638: 894B6E60  lbz r10, 0x6e60(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28256 as u32) ) } as u64;
	// 821CA63C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CA640: 419A013C  beq cr6, 0x821ca77c
	if ctx.cr[6].eq {
	pc = 0x821CA77C; continue 'dispatch;
	}
	// 821CA644: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821CA648: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 821CA64C: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821CA650: 396B2390  addi r11, r11, 0x2390
	ctx.r[11].s64 = ctx.r[11].s64 + 9104;
	// 821CA654: 38EA7E70  addi r7, r10, 0x7e70
	ctx.r[7].s64 = ctx.r[10].s64 + 32368;
	// 821CA658: 38CB2008  addi r6, r11, 0x2008
	ctx.r[6].s64 = ctx.r[11].s64 + 8200;
	// 821CA65C: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821CA660: 55451838  slwi r5, r10, 3
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821CA664: 7CE5592E  stwx r7, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 821CA668: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821CA66C: 810B2000  lwz r8, 0x2000(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821CA670: 814B400C  lwz r10, 0x400c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821CA674: 55451838  slwi r5, r10, 3
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821CA678: 39490001  addi r10, r9, 1
	ctx.r[10].s64 = ctx.r[9].s64 + 1;
	// 821CA67C: 5509083C  slwi r9, r8, 1
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CA680: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	// 821CA684: 912B2000  stw r9, 0x2000(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8192 as u32), ctx.r[9].u32 ) };
	// 821CA688: 7CE5312E  stwx r7, r5, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32), ctx.r[7].u32) };
	// 821CA68C: 814B400C  lwz r10, 0x400c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821CA690: 812B4008  lwz r9, 0x4008(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16392 as u32) ) } as u64;
	// 821CA694: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CA698: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821CA69C: 912B4008  stw r9, 0x4008(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16392 as u32), ctx.r[9].u32 ) };
	// 821CA6A0: 914B400C  stw r10, 0x400c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16396 as u32), ctx.r[10].u32 ) };
	// 821CA6A4: 80C4001C  lwz r6, 0x1c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CA6A8: 2F06FFFF  cmpwi cr6, r6, -1
	ctx.cr[6].compare_i32(ctx.r[6].s32, -1, &mut ctx.xer);
	// 821CA6AC: 419A00C8  beq cr6, 0x821ca774
	if ctx.cr[6].eq {
	pc = 0x821CA774; continue 'dispatch;
	}
	// 821CA6B0: 80840004  lwz r4, 4(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CA6B4: 816400F0  lwz r11, 0xf0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(240 as u32) ) } as u64;
	// 821CA6B8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821CA6BC: 419A0084  beq cr6, 0x821ca740
	if ctx.cr[6].eq {
	pc = 0x821CA740; continue 'dispatch;
	}
	// 821CA6C0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821CA6C4: 419A0044  beq cr6, 0x821ca708
	if ctx.cr[6].eq {
	pc = 0x821CA708; continue 'dispatch;
	}
	// 821CA6C8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821CA6CC: 409A00A8  bne cr6, 0x821ca774
	if !ctx.cr[6].eq {
	pc = 0x821CA774; continue 'dispatch;
	}
	// 821CA6D0: 816400B4  lwz r11, 0xb4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(180 as u32) ) } as u64;
	// 821CA6D4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CA6D8: 8145002C  lwz r10, 0x2c(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(44 as u32) ) } as u64;
	// 821CA6DC: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CA6E0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CA6E4: 419A001C  beq cr6, 0x821ca700
	if ctx.cr[6].eq {
	pc = 0x821CA700; continue 'dispatch;
	}
	// 821CA6E8: 48890131  bl 0x82a5a818
	ctx.lr = 0x821CA6EC;
	sub_82A5A818(ctx, base);
	// 821CA6EC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821CA6F0: 816A6E5C  lwz r11, 0x6e5c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28252 as u32) ) } as u64;
	// 821CA6F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821CA6F8: 916A6E5C  stw r11, 0x6e5c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28252 as u32), ctx.r[11].u32 ) };
	// 821CA6FC: 48000078  b 0x821ca774
	pc = 0x821CA774; continue 'dispatch;
	// 821CA700: 4888F6D1  bl 0x82a59dd0
	ctx.lr = 0x821CA704;
	sub_82A59DD0(ctx, base);
	// 821CA704: 48000070  b 0x821ca774
	pc = 0x821CA774; continue 'dispatch;
	// 821CA708: 816400B4  lwz r11, 0xb4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(180 as u32) ) } as u64;
	// 821CA70C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CA710: 81450040  lwz r10, 0x40(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(64 as u32) ) } as u64;
	// 821CA714: 892A0034  lbz r9, 0x34(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 821CA718: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CA71C: 419A001C  beq cr6, 0x821ca738
	if ctx.cr[6].eq {
	pc = 0x821CA738; continue 'dispatch;
	}
	// 821CA720: 4888F091  bl 0x82a597b0
	ctx.lr = 0x821CA724;
	sub_82A597B0(ctx, base);
	// 821CA724: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821CA728: 816A6E5C  lwz r11, 0x6e5c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28252 as u32) ) } as u64;
	// 821CA72C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821CA730: 916A6E5C  stw r11, 0x6e5c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28252 as u32), ctx.r[11].u32 ) };
	// 821CA734: 48000040  b 0x821ca774
	pc = 0x821CA774; continue 'dispatch;
	// 821CA738: 4BFE7EC1  bl 0x821b25f8
	ctx.lr = 0x821CA73C;
	sub_821B25F8(ctx, base);
	// 821CA73C: 48000038  b 0x821ca774
	pc = 0x821CA774; continue 'dispatch;
	// 821CA740: 816400B4  lwz r11, 0xb4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(180 as u32) ) } as u64;
	// 821CA744: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CA748: 81450030  lwz r10, 0x30(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(48 as u32) ) } as u64;
	// 821CA74C: 892A0034  lbz r9, 0x34(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 821CA750: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CA754: 419A001C  beq cr6, 0x821ca770
	if ctx.cr[6].eq {
	pc = 0x821CA770; continue 'dispatch;
	}
	// 821CA758: 4888EEC9  bl 0x82a59620
	ctx.lr = 0x821CA75C;
	sub_82A59620(ctx, base);
	// 821CA75C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821CA760: 816A6E5C  lwz r11, 0x6e5c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28252 as u32) ) } as u64;
	// 821CA764: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821CA768: 916A6E5C  stw r11, 0x6e5c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28252 as u32), ctx.r[11].u32 ) };
	// 821CA76C: 48000008  b 0x821ca774
	pc = 0x821CA774; continue 'dispatch;
	// 821CA770: 48000021  bl 0x821ca790
	ctx.lr = 0x821CA774;
	sub_821CA790(ctx, base);
	// 821CA774: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821CA778: 48054B69  bl 0x8221f2e0
	ctx.lr = 0x821CA77C;
	sub_8221F2E0(ctx, base);
	// 821CA77C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821CA780: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CA784: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CA788: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CA790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CA790 size=2504
    let mut pc: u32 = 0x821CA790;
    'dispatch: loop {
        match pc {
            0x821CA790 => {
    //   block [0x821CA790..0x821CB158)
	// 821CA790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CA794: 48ADEC61  bl 0x82ca93f4
	ctx.lr = 0x821CA798;
	sub_82CA93D0(ctx, base);
	// 821CA798: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CA79C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821CA7A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CA7A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821CA7A8: 3B8B9490  addi r28, r11, -0x6b70
	ctx.r[28].s64 = ctx.r[11].s64 + -27504;
	// 821CA7AC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821CA7B0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821CA7B4: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 821CA7B8: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 821CA7BC: 3B6B0024  addi r27, r11, 0x24
	ctx.r[27].s64 = ctx.r[11].s64 + 36;
	// 821CA7C0: C01CFFF4  lfs f0, -0xc(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CA7C4: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 821CA7C8: C1AB0030  lfs f13, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821CA7CC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821CA7D0: 41990008  bgt cr6, 0x821ca7d8
	if ctx.cr[6].gt {
	pc = 0x821CA7D8; continue 'dispatch;
	}
	// 821CA7D4: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 821CA7D8: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 821CA7DC: 394100F0  addi r10, r1, 0xf0
	ctx.r[10].s64 = ctx.r[1].s64 + 240;
	// 821CA7E0: 11A0038C  vspltisw v13, 0
	for i in 0..4 {
		ctx.v[13].u32[i] = 0;
	}
	// 821CA7E4: 39210100  addi r9, r1, 0x100
	ctx.r[9].s64 = ctx.r[1].s64 + 256;
	// 821CA7E8: 39010110  addi r8, r1, 0x110
	ctx.r[8].s64 = ctx.r[1].s64 + 272;
	// 821CA7EC: 93010120  stw r24, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[24].u32 ) };
	// 821CA7F0: 9B010124  stb r24, 0x124(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[24].u8 ) };
	// 821CA7F4: 388B0050  addi r4, r11, 0x50
	ctx.r[4].s64 = ctx.r[11].s64 + 80;
	// 821CA7F8: 1180030A  vcfux v12, v0, 0
	// vcfux/vcuxwfp128: ctx.v[12].f32[i] = ( ctx.v[0].u32[i] as f32 ) * (2.0f32).powi(0);
	for i in 0..4 { ctx.v[12].f32[i] = (ctx.v[0].u32[i] as f32) * (2.0f32).powi(0); }
	// 821CA7FC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CB158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CB158 size=72
    let mut pc: u32 = 0x821CB158;
    'dispatch: loop {
        match pc {
            0x821CB158 => {
    //   block [0x821CB158..0x821CB1A0)
	// 821CB158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CB15C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821CB160: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CB164: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821CB168: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 821CB16C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821CB170: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821CB174: 38E90F94  addi r7, r9, 0xf94
	ctx.r[7].s64 = ctx.r[9].s64 + 3988;
	// 821CB178: 99010054  stb r8, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u8 ) };
	// 821CB17C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821CB180: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CB1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CB1A0 size=652
    let mut pc: u32 = 0x821CB1A0;
    'dispatch: loop {
        match pc {
            0x821CB1A0 => {
    //   block [0x821CB1A0..0x821CB42C)
	// 821CB1A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CB1A4: 48ADE25D  bl 0x82ca9400
	ctx.lr = 0x821CB1A8;
	sub_82CA93D0(ctx, base);
	// 821CB1A8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CB1AC: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CB1B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CB1B4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CB1B8: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB1BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CB1C0: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 821CB1C4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821CB1C8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821CB1CC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821CB1D0: 419A0020  beq cr6, 0x821cb1f0
	if ctx.cr[6].eq {
	pc = 0x821CB1F0; continue 'dispatch;
	}
	// 821CB1D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821CB1D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CB1DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821CB1E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821CB1E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CB1E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CB1EC: 4082FFE8  bne 0x821cb1d4
	if !ctx.cr[0].eq {
	pc = 0x821CB1D4; continue 'dispatch;
	}
	// 821CB1F0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB1F4: 3B60000C  li r27, 0xc
	ctx.r[27].s64 = 12;
	// 821CB1F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CB1FC: 409A000C  bne cr6, 0x821cb208
	if !ctx.cr[6].eq {
	pc = 0x821CB208; continue 'dispatch;
	}
	// 821CB200: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821CB204: 48000010  b 0x821cb214
	pc = 0x821CB214; continue 'dispatch;
	// 821CB208: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CB20C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821CB210: 7D29DBD6  divw r9, r9, r27
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	// 821CB214: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CB218: 3D401555  lis r10, 0x1555
	ctx.r[10].s64 = 357892096;
	// 821CB21C: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821CB220: 614A5555  ori r10, r10, 0x5555
	ctx.r[10].u64 = ctx.r[10].u64 | 21845;
	// 821CB224: 7D68DBD6  divw r11, r8, r27
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[27].s32;
	// 821CB228: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821CB22C: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 821CB230: 40980018  bge cr6, 0x821cb248
	if !ctx.cr[6].lt {
	pc = 0x821CB248; continue 'dispatch;
	}
	// 821CB234: 4887C295  bl 0x82a474c8
	ctx.lr = 0x821CB238;
	sub_82A474C8(ctx, base);
	// 821CB238: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821CB23C: 4BFEC8DD  bl 0x821b7b18
	ctx.lr = 0x821CB240;
	sub_821B7B18(ctx, base);
	// 821CB240: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821CB244: 48ADE20C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 821CB248: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 821CB24C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CB250: 409800F8  bge cr6, 0x821cb348
	if !ctx.cr[6].lt {
	pc = 0x821CB348; continue 'dispatch;
	}
	// 821CB254: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CB258: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821CB25C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821CB260: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821CB264: 41980008  blt cr6, 0x821cb26c
	if ctx.cr[6].lt {
	pc = 0x821CB26C; continue 'dispatch;
	}
	// 821CB268: 7FAB4A14  add r29, r11, r9
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821CB26C: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CB270: 40980008  bge cr6, 0x821cb278
	if !ctx.cr[6].lt {
	pc = 0x821CB278; continue 'dispatch;
	}
	// 821CB274: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 821CB278: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821CB27C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB280: 48158131  bl 0x823233b0
	ctx.lr = 0x821CB284;
	sub_823233B0(ctx, base);
	// 821CB284: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821CB288: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821CB28C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB290: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821CB294: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821CB298: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB29C: 486E20A5  bl 0x828ad340
	ctx.lr = 0x821CB2A0;
	sub_828AD340(ctx, base);
	// 821CB2A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821CB2A4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821CB2A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821CB2AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB2B0: 483EEE81  bl 0x825ba130
	ctx.lr = 0x821CB2B4;
	sub_825BA130(ctx, base);
	// 821CB2B4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 821CB2B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821CB2BC: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CB2C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB2C4: 486E207D  bl 0x828ad340
	ctx.lr = 0x821CB2C8;
	sub_828AD340(ctx, base);
	// 821CB2C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB2CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CB2D0: 839F0008  lwz r28, 8(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CB2D4: 7D4BE050  subf r10, r11, r28
	ctx.r[10].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 821CB2D8: 7D4ADBD6  divw r10, r10, r27
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 821CB2DC: 3B4A0001  addi r26, r10, 1
	ctx.r[26].s64 = ctx.r[10].s64 + 1;
	// 821CB2E0: 419A002C  beq cr6, 0x821cb30c
	if ctx.cr[6].eq {
	pc = 0x821CB30C; continue 'dispatch;
	}
	// 821CB2E4: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 821CB2E8: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821CB2EC: 419A0018  beq cr6, 0x821cb304
	if ctx.cr[6].eq {
	pc = 0x821CB304; continue 'dispatch;
	}
	// 821CB2F0: 387B0004  addi r3, r27, 4
	ctx.r[3].s64 = ctx.r[27].s64 + 4;
	// 821CB2F4: 4BFEC825  bl 0x821b7b18
	ctx.lr = 0x821CB2F8;
	sub_821B7B18(ctx, base);
	// 821CB2F8: 3B7B000C  addi r27, r27, 0xc
	ctx.r[27].s64 = ctx.r[27].s64 + 12;
	// 821CB2FC: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821CB300: 409AFFF0  bne cr6, 0x821cb2f0
	if !ctx.cr[6].eq {
	pc = 0x821CB2F0; continue 'dispatch;
	}
	// 821CB304: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB308: 48050A31  bl 0x8221bd38
	ctx.lr = 0x821CB30C;
	sub_8221BD38(ctx, base);
	// 821CB30C: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CB310: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821CB314: 574A083C  slwi r10, r26, 1
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821CB318: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821CB31C: 7D5A5214  add r10, r26, r10
	ctx.r[10].u64 = ctx.r[26].u64 + ctx.r[10].u64;
	// 821CB320: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CB324: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821CB328: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821CB32C: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 821CB330: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 821CB334: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821CB338: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821CB33C: 4BFEC7DD  bl 0x821b7b18
	ctx.lr = 0x821CB340;
	sub_821B7B18(ctx, base);
	// 821CB340: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821CB344: 48ADE10C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 821CB348: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821CB34C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB350: 7D7C2850  subf r11, r28, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[28].s64;
	// 821CB354: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 821CB358: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 821CB35C: 40980040  bge cr6, 0x821cb39c
	if !ctx.cr[6].lt {
	pc = 0x821CB39C; continue 'dispatch;
	}
	// 821CB360: 38DC000C  addi r6, r28, 0xc
	ctx.r[6].s64 = ctx.r[28].s64 + 12;
	// 821CB364: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821CB368: 486E1FD9  bl 0x828ad340
	ctx.lr = 0x821CB36C;
	sub_828AD340(ctx, base);
	// 821CB36C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CB370: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821CB374: 7D7C2050  subf r11, r28, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[28].s64;
	// 821CB378: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB37C: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 821CB380: 20AA0001  subfic r5, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[5].s64 = (1 as i64) - ctx.r[10].s64;
	// 821CB384: 483EEDAD  bl 0x825ba130
	ctx.lr = 0x821CB388;
	sub_825BA130(ctx, base);
	// 821CB388: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CB38C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 821CB390: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821CB394: 388BFFF4  addi r4, r11, -0xc
	ctx.r[4].s64 = ctx.r[11].s64 + -12;
	// 821CB398: 48000078  b 0x821cb410
	pc = 0x821CB410; continue 'dispatch;
	// 821CB39C: 3BA5FFF4  addi r29, r5, -0xc
	ctx.r[29].s64 = ctx.r[5].s64 + -12;
	// 821CB3A0: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 821CB3A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821CB3A8: 486E1F99  bl 0x828ad340
	ctx.lr = 0x821CB3AC;
	sub_828AD340(ctx, base);
	// 821CB3AC: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 821CB3B0: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821CB3B4: 419A0058  beq cr6, 0x821cb40c
	if ctx.cr[6].eq {
	pc = 0x821CB40C; continue 'dispatch;
	}
	// 821CB3B8: 3BFD0010  addi r31, r29, 0x10
	ctx.r[31].s64 = ctx.r[29].s64 + 16;
	// 821CB3BC: 3BBDFFF4  addi r29, r29, -0xc
	ctx.r[29].s64 = ctx.r[29].s64 + -12;
	// 821CB3C0: 3BFFFFF4  addi r31, r31, -0xc
	ctx.r[31].s64 = ctx.r[31].s64 + -12;
	// 821CB3C4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CB3C8: 917FFFFC  stw r11, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 821CB3CC: 83DFFFF8  lwz r30, -8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CB3D0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB3D4: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821CB3D8: 837FFFF4  lwz r27, -0xc(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821CB3DC: 419A0028  beq cr6, 0x821cb404
	if ctx.cr[6].eq {
	pc = 0x821CB404; continue 'dispatch;
	}
	// 821CB3E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB3E4: 4BFEC735  bl 0x821b7b18
	ctx.lr = 0x821CB3E8;
	sub_821B7B18(ctx, base);
	// 821CB3E8: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 821CB3EC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821CB3F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821CB3F4: 419A0010  beq cr6, 0x821cb404
	if ctx.cr[6].eq {
	pc = 0x821CB404; continue 'dispatch;
	}
	// 821CB3F8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CB3FC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821CB400: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821CB404: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821CB408: 409AFFB4  bne cr6, 0x821cb3bc
	if !ctx.cr[6].eq {
	pc = 0x821CB3BC; continue 'dispatch;
	}
	// 821CB40C: 389C000C  addi r4, r28, 0xc
	ctx.r[4].s64 = ctx.r[28].s64 + 12;
	// 821CB410: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821CB414: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CB418: 486BD009  bl 0x82888420
	ctx.lr = 0x821CB41C;
	sub_82888420(ctx, base);
	// 821CB41C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821CB420: 4BFEC6F9  bl 0x821b7b18
	ctx.lr = 0x821CB424;
	sub_821B7B18(ctx, base);
	// 821CB424: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821CB428: 48ADE028  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CB430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CB430 size=100
    let mut pc: u32 = 0x821CB430;
    'dispatch: loop {
        match pc {
            0x821CB430 => {
    //   block [0x821CB430..0x821CB494)
	// 821CB430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CB434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821CB438: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821CB43C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CB440: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CB444: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821CB448: 392B25E4  addi r9, r11, 0x25e4
	ctx.r[9].s64 = ctx.r[11].s64 + 9700;
	// 821CB44C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB450: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821CB454: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 821CB458: 419A0020  beq cr6, 0x821cb478
	if ctx.cr[6].eq {
	pc = 0x821CB478; continue 'dispatch;
	}
	// 821CB45C: 4859573D  bl 0x82760b98
	ctx.lr = 0x821CB460;
	sub_82760B98(ctx, base);
	// 821CB460: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CB464: 419A0014  beq cr6, 0x821cb478
	if ctx.cr[6].eq {
	pc = 0x821CB478; continue 'dispatch;
	}
	// 821CB468: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB46C: 4801CEDD  bl 0x821e8348
	ctx.lr = 0x821CB470;
	sub_821E8348(ctx, base);
	// 821CB470: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821CB474: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821CB478: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB47C: 4859591D  bl 0x82760d98
	ctx.lr = 0x821CB480;
	sub_82760D98(ctx, base);
	// 821CB480: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821CB484: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CB488: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CB48C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821CB490: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CB498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CB498 size=320
    let mut pc: u32 = 0x821CB498;
    'dispatch: loop {
        match pc {
            0x821CB498 => {
    //   block [0x821CB498..0x821CB5D8)
	// 821CB498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CB49C: 48ADDF6D  bl 0x82ca9408
	ctx.lr = 0x821CB4A0;
	sub_82CA93D0(ctx, base);
	// 821CB4A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CB4A4: A1640052  lhz r11, 0x52(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(82 as u32) ) } as u64;
	// 821CB4A8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821CB4AC: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821CB4B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CB4B4: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 821CB4B8: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 821CB4BC: B1610050  sth r11, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CB5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CB5D8 size=372
    let mut pc: u32 = 0x821CB5D8;
    'dispatch: loop {
        match pc {
            0x821CB5D8 => {
    //   block [0x821CB5D8..0x821CB74C)
	// 821CB5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CB5DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821CB5E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CB5E4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821CB5E8: 419A0018  beq cr6, 0x821cb600
	if ctx.cr[6].eq {
	pc = 0x821CB600; continue 'dispatch;
	}
	// 821CB5EC: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821CB5F0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821CB5F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CB5F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CB5FC: 409A0008  bne cr6, 0x821cb604
	if !ctx.cr[6].eq {
	pc = 0x821CB604; continue 'dispatch;
	}
	// 821CB600: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821CB604: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CB608: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CB60C: 419A012C  beq cr6, 0x821cb738
	if ctx.cr[6].eq {
	pc = 0x821CB738; continue 'dispatch;
	}
	// 821CB610: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 821CB614: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821CB618: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 821CB61C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CB620: 419A00E8  beq cr6, 0x821cb708
	if ctx.cr[6].eq {
	pc = 0x821CB708; continue 'dispatch;
	}
	// 821CB624: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 821CB628: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CB62C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CB630: 419A001C  beq cr6, 0x821cb64c
	if ctx.cr[6].eq {
	pc = 0x821CB64C; continue 'dispatch;
	}
	// 821CB634: 896B0043  lbz r11, 0x43(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(67 as u32) ) } as u64;
	// 821CB638: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821CB63C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821CB640: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB644: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821CB648: 480000C4  b 0x821cb70c
	pc = 0x821CB70C; continue 'dispatch;
	// 821CB64C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 821CB650: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821CB654: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821CB658: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821CB65C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821CB660: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CB664: 40810054  ble 0x821cb6b8
	if !ctx.cr[0].gt {
	pc = 0x821CB6B8; continue 'dispatch;
	}
	// 821CB668: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821CB66C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821CB670: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821CB674: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CB678: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 821CB67C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821CB680: 41980008  blt cr6, 0x821cb688
	if ctx.cr[6].lt {
	pc = 0x821CB688; continue 'dispatch;
	}
	// 821CB684: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821CB688: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821CB68C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CB690: 419A0014  beq cr6, 0x821cb6a4
	if ctx.cr[6].eq {
	pc = 0x821CB6A4; continue 'dispatch;
	}
	// 821CB694: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821CB698: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CB69C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CB6A0: 4800000C  b 0x821cb6ac
	pc = 0x821CB6AC; continue 'dispatch;
	// 821CB6A4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821CB6A8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821CB6AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CB6B0: 4199FFB8  bgt cr6, 0x821cb668
	if ctx.cr[6].gt {
	pc = 0x821CB668; continue 'dispatch;
	}
	// 821CB6B4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821CB6B8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821CB6BC: 419A003C  beq cr6, 0x821cb6f8
	if ctx.cr[6].eq {
	pc = 0x821CB6F8; continue 'dispatch;
	}
	// 821CB6C0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CB6C4: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 821CB6C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CB6CC: 41990008  bgt cr6, 0x821cb6d4
	if ctx.cr[6].gt {
	pc = 0x821CB6D4; continue 'dispatch;
	}
	// 821CB6D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821CB6D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CB6D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CB6DC: 409A001C  bne cr6, 0x821cb6f8
	if !ctx.cr[6].eq {
	pc = 0x821CB6F8; continue 'dispatch;
	}
	// 821CB6E0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821CB6E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821CB6E8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821CB6EC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821CB6F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB6F4: 48000018  b 0x821cb70c
	pc = 0x821CB70C; continue 'dispatch;
	// 821CB6F8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821CB6FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821CB700: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB704: 48000008  b 0x821cb70c
	pc = 0x821CB70C; continue 'dispatch;
	// 821CB708: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821CB70C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821CB710: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CB714: 419A0024  beq cr6, 0x821cb738
	if ctx.cr[6].eq {
	pc = 0x821CB738; continue 'dispatch;
	}
	// 821CB718: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CB71C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821CB720: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CB724: 4E800421  bctrl
	ctx.lr = 0x821CB728;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CB728: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821CB72C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CB730: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CB734: 4E800020  blr
	return;
	// 821CB738: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821CB73C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821CB740: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CB744: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CB748: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CB750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CB750 size=576
    let mut pc: u32 = 0x821CB750;
    'dispatch: loop {
        match pc {
            0x821CB750 => {
    //   block [0x821CB750..0x821CB990)
	// 821CB750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CB754: 48ADDCB9  bl 0x82ca940c
	ctx.lr = 0x821CB758;
	sub_82CA93D0(ctx, base);
	// 821CB758: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CB75C: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821CB760: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CB764: 3D408331  lis r10, -0x7ccf
	ctx.r[10].s64 = -2093940736;
	// 821CB768: 812B711C  lwz r9, 0x711c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28956 as u32) ) } as u64;
	// 821CB76C: 2B090020  cmplwi cr6, r9, 0x20
	ctx.cr[6].compare_u32(ctx.r[9].u32, 32 as u32, &mut ctx.xer);
	// 821CB770: 409A0010  bne cr6, 0x821cb780
	if !ctx.cr[6].eq {
	pc = 0x821CB780; continue 'dispatch;
	}
	// 821CB774: 812A7120  lwz r9, 0x7120(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28960 as u32) ) } as u64;
	// 821CB778: 2B090060  cmplwi cr6, r9, 0x60
	ctx.cr[6].compare_u32(ctx.r[9].u32, 96 as u32, &mut ctx.xer);
	// 821CB77C: 419A002C  beq cr6, 0x821cb7a8
	if ctx.cr[6].eq {
	pc = 0x821CB7A8; continue 'dispatch;
	}
	// 821CB780: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 821CB784: 39000060  li r8, 0x60
	ctx.r[8].s64 = 96;
	// 821CB788: 912B711C  stw r9, 0x711c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28956 as u32), ctx.r[9].u32 ) };
	// 821CB78C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821CB790: 910A7120  stw r8, 0x7120(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28960 as u32), ctx.r[8].u32 ) };
	// 821CB794: 38C00060  li r6, 0x60
	ctx.r[6].s64 = 96;
	// 821CB798: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 821CB79C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821CB7A0: 806B0364  lwz r3, 0x364(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 821CB7A4: 4BFD15C5  bl 0x8219cd68
	ctx.lr = 0x821CB7A8;
	sub_8219CD68(ctx, base);
	// 821CB7A8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CB7AC: C02B9490  lfs f1, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821CB7B0: 4BFE61A9  bl 0x821b1958
	ctx.lr = 0x821CB7B4;
	sub_821B1958(ctx, base);
	// 821CB7B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB7B8: 480AEC89  bl 0x8227a440
	ctx.lr = 0x821CB7BC;
	sub_8227A440(ctx, base);
	// 821CB7BC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821CB7C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB7C4: 3BABA990  addi r29, r11, -0x5670
	ctx.r[29].s64 = ctx.r[11].s64 + -22128;
	// 821CB7C8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821CB7CC: 480AD76D  bl 0x82278f38
	ctx.lr = 0x821CB7D0;
	sub_82278F38(ctx, base);
	// 821CB7D0: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 821CB7D4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB7D8: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 821CB7DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CB7E0: 83DF06FC  lwz r30, 0x6fc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821CB7E4: 915F06FC  stw r10, 0x6fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1788 as u32), ctx.r[10].u32 ) };
	// 821CB7E8: 81690014  lwz r11, 0x14(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CB7EC: 388B0D54  addi r4, r11, 0xd54
	ctx.r[4].s64 = ctx.r[11].s64 + 3412;
	// 821CB7F0: 48028C91  bl 0x821f4480
	ctx.lr = 0x821CB7F4;
	sub_821F4480(ctx, base);
	// 821CB7F4: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821CB7F8: 81010074  lwz r8, 0x74(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821CB7FC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CB800: 419A0058  beq cr6, 0x821cb858
	if ctx.cr[6].eq {
	pc = 0x821CB858; continue 'dispatch;
	}
	// 821CB804: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CB808: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821CB80C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CB810: 419A0018  beq cr6, 0x821cb828
	if ctx.cr[6].eq {
	pc = 0x821CB828; continue 'dispatch;
	}
	// 821CB814: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CB818: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821CB81C: 7D0B1670  srawi r11, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821CB820: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CB824: 41980008  blt cr6, 0x821cb82c
	if ctx.cr[6].lt {
	pc = 0x821CB82C; continue 'dispatch;
	}
	// 821CB828: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CB82C: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CB830: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821CB834: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CB838: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821CB83C: 4809C01D  bl 0x82267858
	ctx.lr = 0x821CB840;
	sub_82267858(ctx, base);
	// 821CB840: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CB844: 48034535  bl 0x821ffd78
	ctx.lr = 0x821CB848;
	sub_821FFD78(ctx, base);
	// 821CB848: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821CB84C: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821CB850: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CB854: 409AFFB0  bne cr6, 0x821cb804
	if !ctx.cr[6].eq {
	pc = 0x821CB804; continue 'dispatch;
	}
	// 821CB858: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB85C: 38A0002F  li r5, 0x2f
	ctx.r[5].s64 = 47;
	// 821CB860: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CB864: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CB868: 388B0D54  addi r4, r11, 0xd54
	ctx.r[4].s64 = ctx.r[11].s64 + 3412;
	// 821CB86C: 48028C15  bl 0x821f4480
	ctx.lr = 0x821CB870;
	sub_821F4480(ctx, base);
	// 821CB870: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821CB874: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821CB878: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821CB87C: 419A0054  beq cr6, 0x821cb8d0
	if ctx.cr[6].eq {
	pc = 0x821CB8D0; continue 'dispatch;
	}
	// 821CB880: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CB884: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821CB888: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CB88C: 419A0018  beq cr6, 0x821cb8a4
	if ctx.cr[6].eq {
	pc = 0x821CB8A4; continue 'dispatch;
	}
	// 821CB890: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CB894: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821CB898: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821CB89C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CB8A0: 41980008  blt cr6, 0x821cb8a8
	if ctx.cr[6].lt {
	pc = 0x821CB8A8; continue 'dispatch;
	}
	// 821CB8A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CB8A8: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821CB8AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CB8B0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821CB8B4: 48098FB5  bl 0x82264868
	ctx.lr = 0x821CB8B8;
	sub_82264868(ctx, base);
	// 821CB8B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CB8BC: 480344BD  bl 0x821ffd78
	ctx.lr = 0x821CB8C0;
	sub_821FFD78(ctx, base);
	// 821CB8C0: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821CB8C4: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821CB8C8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821CB8CC: 409AFFB4  bne cr6, 0x821cb880
	if !ctx.cr[6].eq {
	pc = 0x821CB880; continue 'dispatch;
	}
	// 821CB8D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821CB8D4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821CB8D8: 388B2270  addi r4, r11, 0x2270
	ctx.r[4].s64 = ctx.r[11].s64 + 8816;
	// 821CB8DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821CB8E0: 480615F1  bl 0x8222ced0
	ctx.lr = 0x821CB8E4;
	sub_8222CED0(ctx, base);
	// 821CB8E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821CB8E8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821CB8EC: 480DFC1D  bl 0x822ab508
	ctx.lr = 0x821CB8F0;
	sub_822AB508(ctx, base);
	// 821CB8F0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821CB8F4: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 821CB8F8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821CB8FC: 480D6DBD  bl 0x822a26b8
	ctx.lr = 0x821CB900;
	sub_822A26B8(ctx, base);
	// 821CB900: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CB904: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821CB908: 48071699  bl 0x8223cfa0
	ctx.lr = 0x821CB90C;
	sub_8223CFA0(ctx, base);
	// 821CB90C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821CB910: 480D2189  bl 0x8229da98
	ctx.lr = 0x821CB914;
	sub_8229DA98(ctx, base);
	// 821CB914: 93DF06FC  stw r30, 0x6fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1788 as u32), ctx.r[30].u32 ) };
	// 821CB918: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821CB91C: 3BCBA9A8  addi r30, r11, -0x5658
	ctx.r[30].s64 = ctx.r[11].s64 + -22104;
	// 821CB920: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CB924: 48015ED5  bl 0x821e17f8
	ctx.lr = 0x821CB928;
	sub_821E17F8(ctx, base);
	// 821CB928: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821CB92C: 4809F74D  bl 0x8226b078
	ctx.lr = 0x821CB930;
	sub_8226B078(ctx, base);
	// 821CB930: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821CB934: 386AB158  addi r3, r10, -0x4ea8
	ctx.r[3].s64 = ctx.r[10].s64 + -20136;
	// 821CB938: 4BFE2419  bl 0x821add50
	ctx.lr = 0x821CB93C;
	sub_821ADD50(ctx, base);
	// 821CB93C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB940: 80690014  lwz r3, 0x14(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CB944: 480C3C0D  bl 0x8228f550
	ctx.lr = 0x821CB948;
	sub_8228F550(ctx, base);
	// 821CB948: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CB94C: 419A0010  beq cr6, 0x821cb95c
	if ctx.cr[6].eq {
	pc = 0x821CB95C; continue 'dispatch;
	}
	// 821CB950: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CB954: 38630090  addi r3, r3, 0x90
	ctx.r[3].s64 = ctx.r[3].s64 + 144;
	// 821CB958: 48008929  bl 0x821d4280
	ctx.lr = 0x821CB95C;
	sub_821D4280(ctx, base);
	// 821CB95C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CB960: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821CB964: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821CB968: 48066D79  bl 0x822326e0
	ctx.lr = 0x821CB96C;
	sub_822326E0(ctx, base);
	// 821CB96C: 48076865  bl 0x822421d0
	ctx.lr = 0x821CB970;
	sub_822421D0(ctx, base);
	// 821CB970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB974: 4BFFC655  bl 0x821c7fc8
	ctx.lr = 0x821CB978;
	sub_821C7FC8(ctx, base);
	// 821CB978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB97C: 480ABA05  bl 0x82277380
	ctx.lr = 0x821CB980;
	sub_82277380(ctx, base);
	// 821CB980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB984: 480F890D  bl 0x822c4290
	ctx.lr = 0x821CB988;
	sub_822C4290(ctx, base);
	// 821CB988: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 821CB98C: 48ADDAD0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CB990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CB990 size=2768
    let mut pc: u32 = 0x821CB990;
    'dispatch: loop {
        match pc {
            0x821CB990 => {
    //   block [0x821CB990..0x821CC460)
	// 821CB990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CB994: 48ADDA61  bl 0x82ca93f4
	ctx.lr = 0x821CB998;
	sub_82CA93D0(ctx, base);
	// 821CB998: DBA1FF98  stfd f29, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[29].u64 ) };
	// 821CB99C: DBC1FFA0  stfd f30, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 821CB9A0: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 821CB9A4: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CB9A8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821CB9AC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821CB9B0: 7F57D378  mr r23, r26
	ctx.r[23].u64 = ctx.r[26].u64;
	// 821CB9B4: 7F59D378  mr r25, r26
	ctx.r[25].u64 = ctx.r[26].u64;
	// 821CB9B8: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB9BC: 92E10068  stw r23, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[23].u32 ) };
	// 821CB9C0: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821CB9C4: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 821CB9C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CB9CC: 419A00D8  beq cr6, 0x821cbaa4
	if ctx.cr[6].eq {
	pc = 0x821CBAA4; continue 'dispatch;
	}
	// 821CB9D0: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821CB9D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CB9D8: 419A001C  beq cr6, 0x821cb9f4
	if ctx.cr[6].eq {
	pc = 0x821CB9F4; continue 'dispatch;
	}
	// 821CB9DC: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 821CB9E0: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CB9E4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821CB9E8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821CB9EC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB9F0: 480000B0  b 0x821cbaa0
	pc = 0x821CBAA0; continue 'dispatch;
	// 821CB9F4: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CB9F8: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821CB9FC: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 821CBA00: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821CBA04: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 821CBA08: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBA0C: 40810054  ble 0x821cba60
	if !ctx.cr[0].gt {
	pc = 0x821CBA60; continue 'dispatch;
	}
	// 821CBA10: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821CBA14: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821CBA18: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821CBA1C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBA20: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 821CBA24: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821CBA28: 41980008  blt cr6, 0x821cba30
	if ctx.cr[6].lt {
	pc = 0x821CBA30; continue 'dispatch;
	}
	// 821CBA2C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821CBA30: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821CBA34: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CBA38: 419A0014  beq cr6, 0x821cba4c
	if ctx.cr[6].eq {
	pc = 0x821CBA4C; continue 'dispatch;
	}
	// 821CBA3C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821CBA40: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CBA44: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CBA48: 4800000C  b 0x821cba54
	pc = 0x821CBA54; continue 'dispatch;
	// 821CBA4C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821CBA50: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821CBA54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBA58: 4199FFB8  bgt cr6, 0x821cba10
	if ctx.cr[6].gt {
	pc = 0x821CBA10; continue 'dispatch;
	}
	// 821CBA5C: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 821CBA60: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821CBA64: 419A0034  beq cr6, 0x821cba98
	if ctx.cr[6].eq {
	pc = 0x821CBA98; continue 'dispatch;
	}
	// 821CBA68: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBA6C: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 821CBA70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CBA74: 41990008  bgt cr6, 0x821cba7c
	if ctx.cr[6].gt {
	pc = 0x821CBA7C; continue 'dispatch;
	}
	// 821CBA78: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821CBA7C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CBA80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBA84: 409A0014  bne cr6, 0x821cba98
	if !ctx.cr[6].eq {
	pc = 0x821CBA98; continue 'dispatch;
	}
	// 821CBA88: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821CBA8C: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821CBA90: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821CBA94: 48000008  b 0x821cba9c
	pc = 0x821CBA9C; continue 'dispatch;
	// 821CBA98: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821CBA9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBAA0: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 821CBAA4: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821CBAA8: 83CB9650  lwz r30, -0x69b0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 821CBAAC: 4803BD45  bl 0x822077f0
	ctx.lr = 0x821CBAB0;
	sub_822077F0(ctx, base);
	// 821CBAB0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821CBAB4: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821CBAB8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CBABC: 809B0018  lwz r4, 0x18(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CBAC0: 3B0B9484  addi r24, r11, -0x6b7c
	ctx.r[24].s64 = ctx.r[11].s64 + -27516;
	// 821CBAC4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821CBAC8: C80A9660  lfd f0, -0x69a0(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 821CBACC: C3AB9484  lfs f29, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821CBAD0: FC1F0024  fdiv f0, f31, f0
	ctx.f[0].f64 = ctx.f[31].f64 / ctx.f[0].f64;
	// 821CBAD4: FFC00018  frsp f30, f0
	ctx.f[30].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821CBAD8: 419A0178  beq cr6, 0x821cbc50
	if ctx.cr[6].eq {
	pc = 0x821CBC50; continue 'dispatch;
	}
	// 821CBADC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821CBAE0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821CBAE4: 480E253D  bl 0x822ae020
	ctx.lr = 0x821CBAE8;
	sub_822AE020(ctx, base);
	// 821CBAE8: 807B0018  lwz r3, 0x18(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CBAEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CBAF0: 419A0040  beq cr6, 0x821cbb30
	if ctx.cr[6].eq {
	pc = 0x821CBB30; continue 'dispatch;
	}
	// 821CBAF4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 821CBAF8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821CBAFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBB00: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821CBB04: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CBB08: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CBB0C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBB10: 4082FFE8  bne 0x821cbaf8
	if !ctx.cr[0].eq {
	pc = 0x821CBAF8; continue 'dispatch;
	}
	// 821CBB14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBB18: 409A0014  bne cr6, 0x821cbb2c
	if !ctx.cr[6].eq {
	pc = 0x821CBB2C; continue 'dispatch;
	}
	// 821CBB1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBB20: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBB24: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CBB28: 4E800421  bctrl
	ctx.lr = 0x821CBB2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CBB2C: 935B0018  stw r26, 0x18(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[26].u32 ) };
	// 821CBB30: 935B0018  stw r26, 0x18(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[26].u32 ) };
	// 821CBB34: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 821CBB38: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBB3C: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CBB40: 552827FE  rlwinm r8, r9, 4, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0FFFFFFFu64;
	// 821CBB44: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821CBB48: 419A00F4  beq cr6, 0x821cbc3c
	if ctx.cr[6].eq {
	pc = 0x821CBC3C; continue 'dispatch;
	}
	// 821CBB4C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821CBB50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CBB54: 419A0024  beq cr6, 0x821cbb78
	if ctx.cr[6].eq {
	pc = 0x821CBB78; continue 'dispatch;
	}
	// 821CBB58: 894A003C  lbz r10, 0x3c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 821CBB5C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CBB60: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821CBB64: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821CBB68: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBB6C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CBB70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CBB74: 480000CC  b 0x821cbc40
	pc = 0x821CBC40; continue 'dispatch;
	// 821CBB78: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CBB7C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821CBB80: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 821CBB84: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821CBB88: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821CBB8C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBB90: 40810054  ble 0x821cbbe4
	if !ctx.cr[0].gt {
	pc = 0x821CBBE4; continue 'dispatch;
	}
	// 821CBB94: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821CBB98: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821CBB9C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821CBBA0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBBA4: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 821CBBA8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821CBBAC: 41980008  blt cr6, 0x821cbbb4
	if ctx.cr[6].lt {
	pc = 0x821CBBB4; continue 'dispatch;
	}
	// 821CBBB0: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821CBBB4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821CBBB8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CBBBC: 419A0014  beq cr6, 0x821cbbd0
	if ctx.cr[6].eq {
	pc = 0x821CBBD0; continue 'dispatch;
	}
	// 821CBBC0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821CBBC4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CBBC8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CBBCC: 4800000C  b 0x821cbbd8
	pc = 0x821CBBD8; continue 'dispatch;
	// 821CBBD0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821CBBD4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821CBBD8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBBDC: 4199FFB8  bgt cr6, 0x821cbb94
	if ctx.cr[6].gt {
	pc = 0x821CBB94; continue 'dispatch;
	}
	// 821CBBE0: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821CBBE4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821CBBE8: 419A0040  beq cr6, 0x821cbc28
	if ctx.cr[6].eq {
	pc = 0x821CBC28; continue 'dispatch;
	}
	// 821CBBEC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBBF0: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 821CBBF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CBBF8: 41990008  bgt cr6, 0x821cbc00
	if ctx.cr[6].gt {
	pc = 0x821CBC00; continue 'dispatch;
	}
	// 821CBBFC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821CBC00: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CBC04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBC08: 409A0020  bne cr6, 0x821cbc28
	if !ctx.cr[6].eq {
	pc = 0x821CBC28; continue 'dispatch;
	}
	// 821CBC0C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821CBC10: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821CBC14: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821CBC18: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBC1C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CBC20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CBC24: 4800001C  b 0x821cbc40
	pc = 0x821CBC40; continue 'dispatch;
	// 821CBC28: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821CBC2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBC30: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CBC34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CBC38: 48000008  b 0x821cbc40
	pc = 0x821CBC40; continue 'dispatch;
	// 821CBC3C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821CBC40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CBC44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBC48: 419A0008  beq cr6, 0x821cbc50
	if ctx.cr[6].eq {
	pc = 0x821CBC50; continue 'dispatch;
	}
	// 821CBC4C: D3AA00FC  stfs f29, 0xfc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 821CBC50: 817B0024  lwz r11, 0x24(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 821CBC54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBC58: 419A012C  beq cr6, 0x821cbd84
	if ctx.cr[6].eq {
	pc = 0x821CBD84; continue 'dispatch;
	}
	// 821CBC5C: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CBC60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBC64: 409A0120  bne cr6, 0x821cbd84
	if !ctx.cr[6].eq {
	pc = 0x821CBD84; continue 'dispatch;
	}
	// 821CBC68: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821CBC6C: 480535ED  bl 0x8221f258
	ctx.lr = 0x821CBC70;
	sub_8221F258(ctx, base);
	// 821CBC70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CBC74: 419A0018  beq cr6, 0x821cbc8c
	if ctx.cr[6].eq {
	pc = 0x821CBC8C; continue 'dispatch;
	}
	// 821CBC78: C01822AC  lfs f0, 0x22ac(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CBC7C: EC20F824  fdivs f1, f0, f31
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[31].f64) as f32) as f64;
	// 821CBC80: 480BFEC1  bl 0x8228bb40
	ctx.lr = 0x821CBC84;
	sub_8228BB40(ctx, base);
	// 821CBC84: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821CBC88: 48000008  b 0x821cbc90
	pc = 0x821CBC90; continue 'dispatch;
	// 821CBC8C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821CBC90: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821CBC94: 80BB0024  lwz r5, 0x24(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 821CBC98: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821CBC9C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821CBCA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821CBCA4: 4800249D  bl 0x821ce140
	ctx.lr = 0x821CBCA8;
	sub_821CE140(ctx, base);
	// 821CBCA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CBCAC: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CBCB0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBCB4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821CBCB8: 419A007C  beq cr6, 0x821cbd34
	if ctx.cr[6].eq {
	pc = 0x821CBD34; continue 'dispatch;
	}
	// 821CBCBC: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821CBCC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CBCC4: 419A0040  beq cr6, 0x821cbd04
	if ctx.cr[6].eq {
	pc = 0x821CBD04; continue 'dispatch;
	}
	// 821CBCC8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 821CBCCC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821CBCD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBCD4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821CBCD8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CBCDC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CBCE0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBCE4: 4082FFE8  bne 0x821cbccc
	if !ctx.cr[0].eq {
	pc = 0x821CBCCC; continue 'dispatch;
	}
	// 821CBCE8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBCEC: 409A0014  bne cr6, 0x821cbd00
	if !ctx.cr[6].eq {
	pc = 0x821CBD00; continue 'dispatch;
	}
	// 821CBCF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBCF4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBCF8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CBCFC: 4E800421  bctrl
	ctx.lr = 0x821CBD00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CBD00: 935B001C  stw r26, 0x1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[26].u32 ) };
	// 821CBD04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBD08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBD0C: 917B001C  stw r11, 0x1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821CBD10: 419A0024  beq cr6, 0x821cbd34
	if ctx.cr[6].eq {
	pc = 0x821CBD34; continue 'dispatch;
	}
	// 821CBD14: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821CBD18: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821CBD1C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBD20: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821CBD24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821CBD28: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CBD2C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBD30: 4082FFE8  bne 0x821cbd18
	if !ctx.cr[0].eq {
	pc = 0x821CBD18; continue 'dispatch;
	}
	// 821CBD34: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821CBD38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBD3C: 419A0048  beq cr6, 0x821cbd84
	if ctx.cr[6].eq {
	pc = 0x821CBD84; continue 'dispatch;
	}
	// 821CBD40: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821CBD44: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 821CBD48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821CBD4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBD50: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821CBD54: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821CBD58: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CBD5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBD60: 4082FFE8  bne 0x821cbd48
	if !ctx.cr[0].eq {
	pc = 0x821CBD48; continue 'dispatch;
	}
	// 821CBD64: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821CBD68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBD6C: 409A0014  bne cr6, 0x821cbd80
	if !ctx.cr[6].eq {
	pc = 0x821CBD80; continue 'dispatch;
	}
	// 821CBD70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBD74: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBD78: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CBD7C: 4E800421  bctrl
	ctx.lr = 0x821CBD80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CBD80: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 821CBD84: 807B0024  lwz r3, 0x24(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 821CBD88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CBD8C: 419A0020  beq cr6, 0x821cbdac
	if ctx.cr[6].eq {
	pc = 0x821CBDAC; continue 'dispatch;
	}
	// 821CBD90: C01B005C  lfs f0, 0x5c(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CBD94: EC3E002A  fadds f1, f30, f0
	ctx.f[1].f64 = ((ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64;
	// 821CBD98: D03B005C  stfs f1, 0x5c(r27)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821CBD9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBDA0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CBDA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CBDA8: 4E800421  bctrl
	ctx.lr = 0x821CBDAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CBDAC: 817B003C  lwz r11, 0x3c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(60 as u32) ) } as u64;
	// 821CBDB0: 3B9B003C  addi r28, r27, 0x3c
	ctx.r[28].s64 = ctx.r[27].s64 + 60;
	// 821CBDB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBDB8: 419A01F0  beq cr6, 0x821cbfa8
	if ctx.cr[6].eq {
	pc = 0x821CBFA8; continue 'dispatch;
	}
	// 821CBDBC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBDC0: C01B0060  lfs f0, 0x60(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CBDC4: EDA0F02A  fadds f13, f0, f30
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 821CBDC8: D1BB0060  stfs f13, 0x60(r27)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821CBDCC: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 821CBDD0: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CBDD4: 5528A7FE  rlwinm r8, r9, 0x14, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000FFFu64;
	// 821CBDD8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821CBDDC: 419A00F4  beq cr6, 0x821cbed0
	if ctx.cr[6].eq {
	pc = 0x821CBED0; continue 'dispatch;
	}
	// 821CBDE0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821CBDE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CBDE8: 419A0024  beq cr6, 0x821cbe0c
	if ctx.cr[6].eq {
	pc = 0x821CBE0C; continue 'dispatch;
	}
	// 821CBDEC: 894A002C  lbz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 821CBDF0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CBDF4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821CBDF8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821CBDFC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBE00: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CBE04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CBE08: 480000CC  b 0x821cbed4
	pc = 0x821CBED4; continue 'dispatch;
	// 821CBE0C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CBE10: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821CBE14: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 821CBE18: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821CBE1C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821CBE20: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBE24: 40810054  ble 0x821cbe78
	if !ctx.cr[0].gt {
	pc = 0x821CBE78; continue 'dispatch;
	}
	// 821CBE28: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821CBE2C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821CBE30: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821CBE34: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBE38: 2F07002C  cmpwi cr6, r7, 0x2c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 44, &mut ctx.xer);
	// 821CBE3C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821CBE40: 41980008  blt cr6, 0x821cbe48
	if ctx.cr[6].lt {
	pc = 0x821CBE48; continue 'dispatch;
	}
	// 821CBE44: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821CBE48: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821CBE4C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CBE50: 419A0014  beq cr6, 0x821cbe64
	if ctx.cr[6].eq {
	pc = 0x821CBE64; continue 'dispatch;
	}
	// 821CBE54: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821CBE58: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CBE5C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CBE60: 4800000C  b 0x821cbe6c
	pc = 0x821CBE6C; continue 'dispatch;
	// 821CBE64: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821CBE68: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821CBE6C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBE70: 4199FFB8  bgt cr6, 0x821cbe28
	if ctx.cr[6].gt {
	pc = 0x821CBE28; continue 'dispatch;
	}
	// 821CBE74: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821CBE78: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821CBE7C: 419A0040  beq cr6, 0x821cbebc
	if ctx.cr[6].eq {
	pc = 0x821CBEBC; continue 'dispatch;
	}
	// 821CBE80: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBE84: 2F0B002C  cmpwi cr6, r11, 0x2c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 44, &mut ctx.xer);
	// 821CBE88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CBE8C: 41990008  bgt cr6, 0x821cbe94
	if ctx.cr[6].gt {
	pc = 0x821CBE94; continue 'dispatch;
	}
	// 821CBE90: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821CBE94: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CBE98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBE9C: 409A0020  bne cr6, 0x821cbebc
	if !ctx.cr[6].eq {
	pc = 0x821CBEBC; continue 'dispatch;
	}
	// 821CBEA0: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821CBEA4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821CBEA8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821CBEAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBEB0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CBEB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CBEB8: 4800001C  b 0x821cbed4
	pc = 0x821CBED4; continue 'dispatch;
	// 821CBEBC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821CBEC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBEC4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CBEC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CBECC: 48000008  b 0x821cbed4
	pc = 0x821CBED4; continue 'dispatch;
	// 821CBED0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821CBED4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CBED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBEDC: 419A0010  beq cr6, 0x821cbeec
	if ctx.cr[6].eq {
	pc = 0x821CBEEC; continue 'dispatch;
	}
	// 821CBEE0: 816A0064  lwz r11, 0x64(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(100 as u32) ) } as u64;
	// 821CBEE4: 6169000F  ori r9, r11, 0xf
	ctx.r[9].u64 = ctx.r[11].u64 | 15;
	// 821CBEE8: 912A0064  stw r9, 0x64(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 821CBEEC: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBEF0: C0230028  lfs f1, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821CBEF4: 48107755  bl 0x822d3648
	ctx.lr = 0x821CBEF8;
	sub_822D3648(ctx, base);
	// 821CBEF8: C01B0060  lfs f0, 0x60(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CBEFC: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 821CBF00: 40990090  ble cr6, 0x821cbf90
	if !ctx.cr[6].gt {
	pc = 0x821CBF90; continue 'dispatch;
	}
	// 821CBF04: 809B0020  lwz r4, 0x20(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 821CBF08: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821CBF0C: 419A005C  beq cr6, 0x821cbf68
	if ctx.cr[6].eq {
	pc = 0x821CBF68; continue 'dispatch;
	}
	// 821CBF10: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821CBF14: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821CBF18: 480E2109  bl 0x822ae020
	ctx.lr = 0x821CBF1C;
	sub_822AE020(ctx, base);
	// 821CBF1C: 807B0020  lwz r3, 0x20(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 821CBF20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CBF24: 419A0040  beq cr6, 0x821cbf64
	if ctx.cr[6].eq {
	pc = 0x821CBF64; continue 'dispatch;
	}
	// 821CBF28: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 821CBF2C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821CBF30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBF34: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821CBF38: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CBF3C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CBF40: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBF44: 4082FFE8  bne 0x821cbf2c
	if !ctx.cr[0].eq {
	pc = 0x821CBF2C; continue 'dispatch;
	}
	// 821CBF48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBF4C: 409A0014  bne cr6, 0x821cbf60
	if !ctx.cr[6].eq {
	pc = 0x821CBF60; continue 'dispatch;
	}
	// 821CBF50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBF54: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBF58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CBF5C: 4E800421  bctrl
	ctx.lr = 0x821CBF60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CBF60: 935B0020  stw r26, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	// 821CBF64: 935B0020  stw r26, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	// 821CBF68: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBF6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBF70: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CBF74: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CBF78: 4E800421  bctrl
	ctx.lr = 0x821CBF7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CBF7C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CBF80: 4BFEBB99  bl 0x821b7b18
	ctx.lr = 0x821CBF84;
	sub_821B7B18(ctx, base);
	// 821CBF84: 935C0000  stw r26, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 821CBF88: 93DB006C  stw r30, 0x6c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 821CBF8C: 4800001C  b 0x821cbfa8
	pc = 0x821CBFA8; continue 'dispatch;
	// 821CBF90: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBF94: FC200090  fmr f1, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[0].f64;
	// 821CBF98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBF9C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CBFA0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CBFA4: 4E800421  bctrl
	ctx.lr = 0x821CBFA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CBFA8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBFAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBFB0: 409A049C  bne cr6, 0x821cc44c
	if !ctx.cr[6].eq {
	pc = 0x821CC44C; continue 'dispatch;
	}
	// 821CBFB4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821CBFB8: 815B006C  lwz r10, 0x6c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(108 as u32) ) } as u64;
	// 821CBFBC: 816BE3BC  lwz r11, -0x1c44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7236 as u32) ) } as u64;
	// 821CBFC0: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821CBFC4: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821CBFC8: 40990484  ble cr6, 0x821cc44c
	if !ctx.cr[6].gt {
	pc = 0x821CC44C; continue 'dispatch;
	}
	// 821CBFCC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBFD0: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 821CBFD4: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821CBFD8: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 821CBFDC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CBFE0: 419A00F4  beq cr6, 0x821cc0d4
	if ctx.cr[6].eq {
	pc = 0x821CC0D4; continue 'dispatch;
	}
	// 821CBFE4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821CBFE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CBFEC: 419A0024  beq cr6, 0x821cc010
	if ctx.cr[6].eq {
	pc = 0x821CC010; continue 'dispatch;
	}
	// 821CBFF0: 894A0015  lbz r10, 0x15(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 821CBFF4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CBFF8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821CBFFC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821CC000: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC004: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821CC008: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CC00C: 480000CC  b 0x821cc0d8
	pc = 0x821CC0D8; continue 'dispatch;
	// 821CC010: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CC014: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821CC018: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 821CC01C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821CC020: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821CC024: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CC028: 40810054  ble 0x821cc07c
	if !ctx.cr[0].gt {
	pc = 0x821CC07C; continue 'dispatch;
	}
	// 821CC02C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821CC030: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821CC034: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821CC038: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC03C: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 821CC040: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821CC044: 41980008  blt cr6, 0x821cc04c
	if ctx.cr[6].lt {
	pc = 0x821CC04C; continue 'dispatch;
	}
	// 821CC048: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821CC04C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821CC050: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CC054: 419A0014  beq cr6, 0x821cc068
	if ctx.cr[6].eq {
	pc = 0x821CC068; continue 'dispatch;
	}
	// 821CC058: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821CC05C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CC060: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CC064: 4800000C  b 0x821cc070
	pc = 0x821CC070; continue 'dispatch;
	// 821CC068: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821CC06C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821CC070: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CC074: 4199FFB8  bgt cr6, 0x821cc02c
	if ctx.cr[6].gt {
	pc = 0x821CC02C; continue 'dispatch;
	}
	// 821CC078: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821CC07C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821CC080: 419A0040  beq cr6, 0x821cc0c0
	if ctx.cr[6].eq {
	pc = 0x821CC0C0; continue 'dispatch;
	}
	// 821CC084: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC088: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 821CC08C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CC090: 41990008  bgt cr6, 0x821cc098
	if ctx.cr[6].gt {
	pc = 0x821CC098; continue 'dispatch;
	}
	// 821CC094: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821CC098: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CC09C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC0A0: 409A0020  bne cr6, 0x821cc0c0
	if !ctx.cr[6].eq {
	pc = 0x821CC0C0; continue 'dispatch;
	}
	// 821CC0A4: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821CC0A8: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821CC0AC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821CC0B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC0B4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821CC0B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CC0BC: 4800001C  b 0x821cc0d8
	pc = 0x821CC0D8; continue 'dispatch;
	// 821CC0C0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821CC0C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC0C8: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821CC0CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CC0D0: 48000008  b 0x821cc0d8
	pc = 0x821CC0D8; continue 'dispatch;
	// 821CC0D4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821CC0D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CC0DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC0E0: 419A0244  beq cr6, 0x821cc324
	if ctx.cr[6].eq {
	pc = 0x821CC324; continue 'dispatch;
	}
	// 821CC0E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821CC0E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821CC0EC: 48029235  bl 0x821f5320
	ctx.lr = 0x821CC0F0;
	sub_821F5320(ctx, base);
	// 821CC0F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CC0F4: 419A0018  beq cr6, 0x821cc10c
	if ctx.cr[6].eq {
	pc = 0x821CC10C; continue 'dispatch;
	}
	// 821CC0F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC0FC: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821CC100: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CC104: 4E800421  bctrl
	ctx.lr = 0x821CC108;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CC108: 48000008  b 0x821cc110
	pc = 0x821CC110; continue 'dispatch;
	// 821CC10C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821CC110: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CC114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC118: 419A020C  beq cr6, 0x821cc324
	if ctx.cr[6].eq {
	pc = 0x821CC324; continue 'dispatch;
	}
	// 821CC11C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821CC120: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821CC124: 3BEB222C  addi r31, r11, 0x222c
	ctx.r[31].s64 = ctx.r[11].s64 + 8748;
	// 821CC128: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821CC12C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CC130: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 821CC134: 48060D9D  bl 0x8222ced0
	ctx.lr = 0x821CC138;
	sub_8222CED0(ctx, base);
	// 821CC138: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC13C: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821CC140: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 821CC144: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CC148: 419A00F4  beq cr6, 0x821cc23c
	if ctx.cr[6].eq {
	pc = 0x821CC23C; continue 'dispatch;
	}
	// 821CC14C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821CC150: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CC154: 419A0024  beq cr6, 0x821cc178
	if ctx.cr[6].eq {
	pc = 0x821CC178; continue 'dispatch;
	}
	// 821CC158: 892A00B5  lbz r9, 0xb5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(181 as u32) ) } as u64;
	// 821CC15C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CC160: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821CC164: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821CC168: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC16C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821CC170: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CC174: 480000CC  b 0x821cc240
	pc = 0x821CC240; continue 'dispatch;
	// 821CC178: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CC17C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821CC180: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 821CC184: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821CC188: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821CC18C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CC190: 40810054  ble 0x821cc1e4
	if !ctx.cr[0].gt {
	pc = 0x821CC1E4; continue 'dispatch;
	}
	// 821CC194: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821CC198: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821CC19C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821CC1A0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC1A4: 2F0700B5  cmpwi cr6, r7, 0xb5
	ctx.cr[6].compare_i32(ctx.r[7].s32, 181, &mut ctx.xer);
	// 821CC1A8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821CC1AC: 41980008  blt cr6, 0x821cc1b4
	if ctx.cr[6].lt {
	pc = 0x821CC1B4; continue 'dispatch;
	}
	// 821CC1B0: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821CC1B4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821CC1B8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CC1BC: 419A0014  beq cr6, 0x821cc1d0
	if ctx.cr[6].eq {
	pc = 0x821CC1D0; continue 'dispatch;
	}
	// 821CC1C0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821CC1C4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CC1C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CC1CC: 4800000C  b 0x821cc1d8
	pc = 0x821CC1D8; continue 'dispatch;
	// 821CC1D0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821CC1D4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821CC1D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CC1DC: 4199FFB8  bgt cr6, 0x821cc194
	if ctx.cr[6].gt {
	pc = 0x821CC194; continue 'dispatch;
	}
	// 821CC1E0: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821CC1E4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821CC1E8: 419A0040  beq cr6, 0x821cc228
	if ctx.cr[6].eq {
	pc = 0x821CC228; continue 'dispatch;
	}
	// 821CC1EC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC1F0: 2F0B00B5  cmpwi cr6, r11, 0xb5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 181, &mut ctx.xer);
	// 821CC1F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CC1F8: 41990008  bgt cr6, 0x821cc200
	if ctx.cr[6].gt {
	pc = 0x821CC200; continue 'dispatch;
	}
	// 821CC1FC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821CC200: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CC204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC208: 409A0020  bne cr6, 0x821cc228
	if !ctx.cr[6].eq {
	pc = 0x821CC228; continue 'dispatch;
	}
	// 821CC20C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821CC210: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821CC214: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821CC218: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC21C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821CC220: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CC224: 4800001C  b 0x821cc240
	pc = 0x821CC240; continue 'dispatch;
	// 821CC228: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821CC22C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC230: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821CC234: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CC238: 48000008  b 0x821cc240
	pc = 0x821CC240; continue 'dispatch;
	// 821CC23C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821CC240: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CC244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC248: 419A0048  beq cr6, 0x821cc290
	if ctx.cr[6].eq {
	pc = 0x821CC290; continue 'dispatch;
	}
	// 821CC24C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CC250: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821CC254: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CC258: 48060C79  bl 0x8222ced0
	ctx.lr = 0x821CC25C;
	sub_8222CED0(ctx, base);
	// 821CC25C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CC260: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821CC264: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821CC268: 48060C69  bl 0x8222ced0
	ctx.lr = 0x821CC26C;
	sub_8222CED0(ctx, base);
	// 821CC26C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821CC270: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 821CC274: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821CC278: 3AE00003  li r23, 3
	ctx.r[23].s64 = 3;
	// 821CC27C: 4825552D  bl 0x824217a8
	ctx.lr = 0x821CC280;
	sub_824217A8(ctx, base);
	// 821CC280: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CC284: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC288: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CC28C: 409A0008  bne cr6, 0x821cc294
	if !ctx.cr[6].eq {
	pc = 0x821CC294; continue 'dispatch;
	}
	// 821CC290: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821CC294: 56EA07BC  rlwinm r10, r23, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[23].u32 as u64 & 0xFFFFFFFFu64;
	// 821CC298: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CC29C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821CC2A0: 419A0010  beq cr6, 0x821cc2b0
	if ctx.cr[6].eq {
	pc = 0x821CC2B0; continue 'dispatch;
	}
	// 821CC2A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821CC2A8: 56F707FA  rlwinm r23, r23, 0, 0x1f, 0x1d
	ctx.r[23].u64 = ctx.r[23].u32 as u64 & 0xFFFFFFFFu64;
	// 821CC2AC: 48048B2D  bl 0x82214dd8
	ctx.lr = 0x821CC2B0;
	sub_82214DD8(ctx, base);
	// 821CC2B0: 56EB07FE  clrlwi r11, r23, 0x1f
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x00000001u64;
	// 821CC2B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CC2B8: 419A000C  beq cr6, 0x821cc2c4
	if ctx.cr[6].eq {
	pc = 0x821CC2C4; continue 'dispatch;
	}
	// 821CC2BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CC2C0: 48048B19  bl 0x82214dd8
	ctx.lr = 0x821CC2C4;
	sub_82214DD8(ctx, base);
	// 821CC2C4: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821CC2C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC2CC: 419A0024  beq cr6, 0x821cc2f0
	if ctx.cr[6].eq {
	pc = 0x821CC2F0; continue 'dispatch;
	}
	// 821CC2D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821CC2D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CC2D8: 486D34B9  bl 0x8289f790
	ctx.lr = 0x821CC2DC;
	sub_8289F790(ctx, base);
	// 821CC2DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821CC2E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821CC2E4: 48098EBD  bl 0x822651a0
	ctx.lr = 0x821CC2E8;
	sub_822651A0(ctx, base);
	// 821CC2E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CC2EC: 48048AED  bl 0x82214dd8
	ctx.lr = 0x821CC2F0;
	sub_82214DD8(ctx, base);
	// 821CC2F0: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 821CC2F4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821CC2F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821CC2FC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821CC300: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821CC304: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821CC308: 480B7A29  bl 0x82283d30
	ctx.lr = 0x821CC30C;
	sub_82283D30(ctx, base);
	// 821CC30C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CC310: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821CC314: 480A6D45  bl 0x82273058
	ctx.lr = 0x821CC318;
	sub_82273058(ctx, base);
	// 821CC318: D3BB0060  stfs f29, 0x60(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821CC31C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821CC320: 48048AB9  bl 0x82214dd8
	ctx.lr = 0x821CC324;
	sub_82214DD8(ctx, base);
	// 821CC324: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC32C: 419A0120  beq cr6, 0x821cc44c
	if ctx.cr[6].eq {
	pc = 0x821CC44C; continue 'dispatch;
	}
	// 821CC330: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821CC334: 48052F25  bl 0x8221f258
	ctx.lr = 0x821CC338;
	sub_8221F258(ctx, base);
	// 821CC338: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CC33C: 419A0018  beq cr6, 0x821cc354
	if ctx.cr[6].eq {
	pc = 0x821CC354; continue 'dispatch;
	}
	// 821CC340: C01822AC  lfs f0, 0x22ac(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CC344: EC20F824  fdivs f1, f0, f31
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[31].f64) as f32) as f64;
	// 821CC348: 480BF7F9  bl 0x8228bb40
	ctx.lr = 0x821CC34C;
	sub_8228BB40(ctx, base);
	// 821CC34C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821CC350: 48000008  b 0x821cc358
	pc = 0x821CC358; continue 'dispatch;
	// 821CC354: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821CC358: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821CC35C: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC360: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821CC364: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821CC368: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821CC36C: 48001DD5  bl 0x821ce140
	ctx.lr = 0x821CC370;
	sub_821CE140(ctx, base);
	// 821CC370: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CC374: 817B0020  lwz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 821CC378: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC37C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821CC380: 419A007C  beq cr6, 0x821cc3fc
	if ctx.cr[6].eq {
	pc = 0x821CC3FC; continue 'dispatch;
	}
	// 821CC384: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821CC388: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CC38C: 419A0040  beq cr6, 0x821cc3cc
	if ctx.cr[6].eq {
	pc = 0x821CC3CC; continue 'dispatch;
	}
	// 821CC390: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 821CC394: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821CC398: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CC39C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821CC3A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CC3A4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CC3A8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CC3AC: 4082FFE8  bne 0x821cc394
	if !ctx.cr[0].eq {
	pc = 0x821CC394; continue 'dispatch;
	}
	// 821CC3B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CC3B4: 409A0014  bne cr6, 0x821cc3c8
	if !ctx.cr[6].eq {
	pc = 0x821CC3C8; continue 'dispatch;
	}
	// 821CC3B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC3BC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC3C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CC3C4: 4E800421  bctrl
	ctx.lr = 0x821CC3C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CC3C8: 935B0020  stw r26, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	// 821CC3CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC3D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC3D4: 917B0020  stw r11, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 821CC3D8: 419A0024  beq cr6, 0x821cc3fc
	if ctx.cr[6].eq {
	pc = 0x821CC3FC; continue 'dispatch;
	}
	// 821CC3DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821CC3E0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821CC3E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CC3E8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821CC3EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821CC3F0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CC3F4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CC3F8: 4082FFE8  bne 0x821cc3e0
	if !ctx.cr[0].eq {
	pc = 0x821CC3E0; continue 'dispatch;
	}
	// 821CC3FC: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 821CC400: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC404: 419A0044  beq cr6, 0x821cc448
	if ctx.cr[6].eq {
	pc = 0x821CC448; continue 'dispatch;
	}
	// 821CC408: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821CC40C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 821CC410: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821CC414: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CC418: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821CC41C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821CC420: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CC424: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CC428: 4082FFE8  bne 0x821cc410
	if !ctx.cr[0].eq {
	pc = 0x821CC410; continue 'dispatch;
	}
	// 821CC42C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821CC430: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CC434: 409A0014  bne cr6, 0x821cc448
	if !ctx.cr[6].eq {
	pc = 0x821CC448; continue 'dispatch;
	}
	// 821CC438: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC43C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC440: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CC444: 4E800421  bctrl
	ctx.lr = 0x821CC448;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CC448: D3BB0060  stfs f29, 0x60(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821CC44C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821CC450: CBA1FF98  lfd f29, -0x68(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 821CC454: CBC1FFA0  lfd f30, -0x60(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 821CC458: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821CC45C: 48ADCFE8  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CC460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CC460 size=1828
    let mut pc: u32 = 0x821CC460;
    'dispatch: loop {
        match pc {
            0x821CC460 => {
    //   block [0x821CC460..0x821CCB84)
	// 821CC460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CC464: 48ADCF99  bl 0x82ca93fc
	ctx.lr = 0x821CC468;
	sub_82CA93D0(ctx, base);
	// 821CC468: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 821CC46C: 48AE186D  bl 0x82cadcd8
	ctx.lr = 0x821CC470;
	sub_82CADCA0(ctx, base);
	// 821CC470: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CC474: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 821CC478: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821CC47C: 817A6AB8  lwz r11, 0x6ab8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821CC480: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC484: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CC488: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821CC48C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC490: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC494: 480662E5  bl 0x82232778
	ctx.lr = 0x821CC498;
	sub_82232778(ctx, base);
	// 821CC498: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CC49C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821CC4A0: 419A06D4  beq cr6, 0x821ccb74
	if ctx.cr[6].eq {
	pc = 0x821CCB74; continue 'dispatch;
	}
	// 821CC4A4: 817E004C  lwz r11, 0x4c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 821CC4A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CC4AC: 4099001C  ble cr6, 0x821cc4c8
	if !ctx.cr[6].gt {
	pc = 0x821CC4C8; continue 'dispatch;
	}
	// 821CC4B0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CC4B4: 917E004C  stw r11, 0x4c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 821CC4B8: 41810010  bgt 0x821cc4c8
	if ctx.cr[0].gt {
	pc = 0x821CC4C8; continue 'dispatch;
	}
	// 821CC4BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821CC4C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CC4C4: 4830BB35  bl 0x824d7ff8
	ctx.lr = 0x821CC4C8;
	sub_824D7FF8(ctx, base);
	// 821CC4C8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC4CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CC4D0: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821CC4D4: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC4D8: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821CC4DC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821CC4E0: 4E800421  bctrl
	ctx.lr = 0x821CC4E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CC4E4: 811E0404  lwz r8, 0x404(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1028 as u32) ) } as u64;
	// 821CC4E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CC4EC: 3BE003F0  li r31, 0x3f0
	ctx.r[31].s64 = 1008;
	// 821CC4F0: 3B6BB480  addi r27, r11, -0x4b80
	ctx.r[27].s64 = ctx.r[11].s64 + -19328;
	// 821CC4F4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821CC4F8: 40990060  ble cr6, 0x821cc558
	if !ctx.cr[6].gt {
	pc = 0x821CC558; continue 'dispatch;
	}
	// 821CC4FC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CCB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821CCB88 size=8
    let mut pc: u32 = 0x821CCB88;
    'dispatch: loop {
        match pc {
            0x821CCB88 => {
    //   block [0x821CCB88..0x821CCB90)
	// 821CCB88: C023018C  lfs f1, 0x18c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(396 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821CCB8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CCB90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CCB90 size=120
    let mut pc: u32 = 0x821CCB90;
    'dispatch: loop {
        match pc {
            0x821CCB90 => {
    //   block [0x821CCB90..0x821CCC08)
	// 821CCB90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CCB94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821CCB98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821CCB9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821CCBA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CCBA4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821CCBA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CCBAC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCBB0: 489A3AC1  bl 0x82b70670
	ctx.lr = 0x821CCBB4;
	sub_82B70670(ctx, base);
	// 821CCBB4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCBB8: 816A0040  lwz r11, 0x40(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821CCBBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CCBC0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821CCBC4: 814A003C  lwz r10, 0x3c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 821CCBC8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821CCBCC: 419A0020  beq cr6, 0x821ccbec
	if ctx.cr[6].eq {
	pc = 0x821CCBEC; continue 'dispatch;
	}
	// 821CCBD0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821CCBD4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CCBD8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821CCBDC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821CCBE0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CCBE4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CCBE8: 4082FFE8  bne 0x821ccbd0
	if !ctx.cr[0].eq {
	pc = 0x821CCBD0; continue 'dispatch;
	}
	// 821CCBEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CCBF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821CCBF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CCBF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CCBFC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821CCC00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821CCC04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CCC08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821CCC08 size=20
    let mut pc: u32 = 0x821CCC08;
    'dispatch: loop {
        match pc {
            0x821CCC08 => {
    //   block [0x821CCC08..0x821CCC1C)
	// 821CCC08: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CCC20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CCC20 size=696
    let mut pc: u32 = 0x821CCC20;
    'dispatch: loop {
        match pc {
            0x821CCC20 => {
    //   block [0x821CCC20..0x821CCED8)
	// 821CCC20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CCC24: 48ADC7BD  bl 0x82ca93e0
	ctx.lr = 0x821CCC28;
	sub_82CA93D0(ctx, base);
	// 821CCC28: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CCC2C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821CCC30: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821CCC34: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 821CCC38: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 821CCC3C: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 821CCC40: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 821CCC44: 3A600004  li r19, 4
	ctx.r[19].s64 = 4;
	// 821CCC48: 3A4B3A44  addi r18, r11, 0x3a44
	ctx.r[18].s64 = ctx.r[11].s64 + 14916;
	// 821CCC4C: 3AAA9700  addi r21, r10, -0x6900
	ctx.r[21].s64 = ctx.r[10].s64 + -26880;
	// 821CCC50: 3A893BB0  addi r20, r9, 0x3bb0
	ctx.r[20].s64 = ctx.r[9].s64 + 15280;
	// 821CCC54: 39560001  addi r10, r22, 1
	ctx.r[10].s64 = ctx.r[22].s64 + 1;
	// 821CCC58: 8178000C  lwz r11, 0xc(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CCC5C: 3B200002  li r25, 2
	ctx.r[25].s64 = 2;
	// 821CCC60: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821CCC64: 7F4A5A14  add r26, r10, r11
	ctx.r[26].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821CCC68: 817AFFF4  lwz r11, -0xc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821CCC6C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821CCC70: 419A000C  beq cr6, 0x821ccc7c
	if ctx.cr[6].eq {
	pc = 0x821CCC7C; continue 'dispatch;
	}
	// 821CCC74: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821CCC78: 409A0024  bne cr6, 0x821ccc9c
	if !ctx.cr[6].eq {
	pc = 0x821CCC9C; continue 'dispatch;
	}
	// 821CCC7C: 817AFFFC  lwz r11, -4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821CCC80: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821CCC84: 419A012C  beq cr6, 0x821ccdb0
	if ctx.cr[6].eq {
	pc = 0x821CCDB0; continue 'dispatch;
	}
	// 821CCC88: 389AFFF8  addi r4, r26, -8
	ctx.r[4].s64 = ctx.r[26].s64 + -8;
	// 821CCC8C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821CCC90: 480D20C9  bl 0x8229ed58
	ctx.lr = 0x821CCC94;
	sub_8229ED58(ctx, base);
	// 821CCC94: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821CCC98: 409A0118  bne cr6, 0x821ccdb0
	if !ctx.cr[6].eq {
	pc = 0x821CCDB0; continue 'dispatch;
	}
	// 821CCC9C: 817AFFF4  lwz r11, -0xc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821CCCA0: 38DAFFF0  addi r6, r26, -0x10
	ctx.r[6].s64 = ctx.r[26].s64 + -16;
	// 821CCCA4: 38BAFFF8  addi r5, r26, -8
	ctx.r[5].s64 = ctx.r[26].s64 + -8;
	// 821CCCA8: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821CCCAC: 419A002C  beq cr6, 0x821cccd8
	if ctx.cr[6].eq {
	pc = 0x821CCCD8; continue 'dispatch;
	}
	// 821CCCB0: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 821CCCB4: 419A0018  beq cr6, 0x821ccccc
	if ctx.cr[6].eq {
	pc = 0x821CCCCC; continue 'dispatch;
	}
	// 821CCCB8: 396B001F  addi r11, r11, 0x1f
	ctx.r[11].s64 = ctx.r[11].s64 + 31;
	// 821CCCBC: 81580010  lwz r10, 0x10(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CCCC0: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CCCC4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821CCCC8: 48000018  b 0x821ccce0
	pc = 0x821CCCE0; continue 'dispatch;
	// 821CCCCC: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCCD0: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CCCD4: 4800000C  b 0x821ccce0
	pc = 0x821CCCE0; continue 'dispatch;
	// 821CCCD8: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCCDC: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CCCE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CCCE4: 419A0014  beq cr6, 0x821cccf8
	if ctx.cr[6].eq {
	pc = 0x821CCCF8; continue 'dispatch;
	}
	// 821CCCE8: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CCCEC: 808B00DC  lwz r4, 0xdc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(220 as u32) ) } as u64;
	// 821CCCF0: 4805B781  bl 0x82228470
	ctx.lr = 0x821CCCF4;
	sub_82228470(ctx, base);
	// 821CCCF4: 48000008  b 0x821cccfc
	pc = 0x821CCCFC; continue 'dispatch;
	// 821CCCF8: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 821CCCFC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCD00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CCD04: 409A005C  bne cr6, 0x821ccd60
	if !ctx.cr[6].eq {
	pc = 0x821CCD60; continue 'dispatch;
	}
	// 821CCD08: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCD0C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821CCD10: 419A002C  beq cr6, 0x821ccd3c
	if ctx.cr[6].eq {
	pc = 0x821CCD3C; continue 'dispatch;
	}
	// 821CCD14: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 821CCD18: 419A0018  beq cr6, 0x821ccd30
	if ctx.cr[6].eq {
	pc = 0x821CCD30; continue 'dispatch;
	}
	// 821CCD1C: 396B001F  addi r11, r11, 0x1f
	ctx.r[11].s64 = ctx.r[11].s64 + 31;
	// 821CCD20: 81580010  lwz r10, 0x10(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CCD24: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CCD28: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821CCD2C: 48000018  b 0x821ccd44
	pc = 0x821CCD44; continue 'dispatch;
	// 821CCD30: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCD34: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CCD38: 4800000C  b 0x821ccd44
	pc = 0x821CCD44; continue 'dispatch;
	// 821CCD3C: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCD40: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CCD44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CCD48: 419A0014  beq cr6, 0x821ccd5c
	if ctx.cr[6].eq {
	pc = 0x821CCD5C; continue 'dispatch;
	}
	// 821CCD4C: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CCD50: 808B00DC  lwz r4, 0xdc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(220 as u32) ) } as u64;
	// 821CCD54: 4805B71D  bl 0x82228470
	ctx.lr = 0x821CCD58;
	sub_82228470(ctx, base);
	// 821CCD58: 48000008  b 0x821ccd60
	pc = 0x821CCD60; continue 'dispatch;
	// 821CCD5C: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 821CCD60: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCD64: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CCD68: 419A001C  beq cr6, 0x821ccd84
	if ctx.cr[6].eq {
	pc = 0x821CCD84; continue 'dispatch;
	}
	// 821CCD6C: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 821CCD70: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821CCD74: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 821CCD78: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821CCD7C: 4886752D  bl 0x82a342a8
	ctx.lr = 0x821CCD80;
	sub_82A342A8(ctx, base);
	// 821CCD80: 48000138  b 0x821cceb8
	pc = 0x821CCEB8; continue 'dispatch;
	// 821CCD84: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCD88: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 821CCD8C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821CCD90: 419A000C  beq cr6, 0x821ccd9c
	if ctx.cr[6].eq {
	pc = 0x821CCD9C; continue 'dispatch;
	}
	// 821CCD94: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821CCD98: 409A0008  bne cr6, 0x821ccda0
	if !ctx.cr[6].eq {
	pc = 0x821CCDA0; continue 'dispatch;
	}
	// 821CCD9C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821CCDA0: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 821CCDA4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821CCDA8: 48864EE1  bl 0x82a31c88
	ctx.lr = 0x821CCDAC;
	sub_82A31C88(ctx, base);
	// 821CCDAC: 4800010C  b 0x821cceb8
	pc = 0x821CCEB8; continue 'dispatch;
	// 821CCDB0: 817AFFF8  lwz r11, -8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CCDB4: 83CB000C  lwz r30, 0xc(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CCDB8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821CCDBC: 409A0020  bne cr6, 0x821ccddc
	if !ctx.cr[6].eq {
	pc = 0x821CCDDC; continue 'dispatch;
	}
	// 821CCDC0: 817AFFF4  lwz r11, -0xc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821CCDC4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821CCDC8: 419A00F0  beq cr6, 0x821cceb8
	if ctx.cr[6].eq {
	pc = 0x821CCEB8; continue 'dispatch;
	}
	// 821CCDCC: 389AFFF0  addi r4, r26, -0x10
	ctx.r[4].s64 = ctx.r[26].s64 + -16;
	// 821CCDD0: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821CCDD4: 480D1F85  bl 0x8229ed58
	ctx.lr = 0x821CCDD8;
	sub_8229ED58(ctx, base);
	// 821CCDD8: 480000E0  b 0x821cceb8
	pc = 0x821CCEB8; continue 'dispatch;
	// 821CCDDC: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 821CCDE0: 2F170001  cmpwi cr6, r23, 1
	ctx.cr[6].compare_i32(ctx.r[23].s32, 1, &mut ctx.xer);
	// 821CCDE4: 4099005C  ble cr6, 0x821cce40
	if !ctx.cr[6].gt {
	pc = 0x821CCE40; continue 'dispatch;
	}
	// 821CCDE8: 3BFAFFF0  addi r31, r26, -0x10
	ctx.r[31].s64 = ctx.r[26].s64 + -16;
	// 821CCDEC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCDF0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821CCDF4: 419A0018  beq cr6, 0x821cce0c
	if ctx.cr[6].eq {
	pc = 0x821CCE0C; continue 'dispatch;
	}
	// 821CCDF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CCDFC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821CCE00: 480D1F59  bl 0x8229ed58
	ctx.lr = 0x821CCE04;
	sub_8229ED58(ctx, base);
	// 821CCE04: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821CCE08: 419A0038  beq cr6, 0x821cce40
	if ctx.cr[6].eq {
	pc = 0x821CCE40; continue 'dispatch;
	}
	// 821CCE0C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCE10: 215EFFFD  subfic r10, r30, -3
	ctx.xer.ca = ctx.r[30].u32 <= -3 as u32;
	ctx.r[10].s64 = (-3 as i64) - ctx.r[30].s64;
	// 821CCE14: 83AB000C  lwz r29, 0xc(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CCE18: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CCE1C: 41980010  blt cr6, 0x821cce2c
	if ctx.cr[6].lt {
	pc = 0x821CCE2C; continue 'dispatch;
	}
	// 821CCE20: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821CCE24: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821CCE28: 48865081  bl 0x82a31ea8
	ctx.lr = 0x821CCE2C;
	sub_82A31EA8(ctx, base);
	// 821CCE2C: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 821CCE30: 7FDDF214  add r30, r29, r30
	ctx.r[30].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 821CCE34: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 821CCE38: 7F19B800  cmpw cr6, r25, r23
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[23].s32, &mut ctx.xer);
	// 821CCE3C: 4198FFB0  blt cr6, 0x821ccdec
	if ctx.cr[6].lt {
	pc = 0x821CCDEC; continue 'dispatch;
	}
	// 821CCE40: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CCE44: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821CCE48: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821CCE4C: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 821CCE50: 4BFE5721  bl 0x821b2570
	ctx.lr = 0x821CCE54;
	sub_821B2570(ctx, base);
	// 821CCE54: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821CCE58: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821CCE5C: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 821CCE60: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 821CCE64: 40990034  ble cr6, 0x821cce98
	if !ctx.cr[6].gt {
	pc = 0x821CCE98; continue 'dispatch;
	}
	// 821CCE68: 572B1838  slwi r11, r25, 3
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CCE6C: 7FABD050  subf r29, r11, r26
	ctx.r[29].s64 = ctx.r[26].s64 - ctx.r[11].s64;
	// 821CCE70: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCE74: 7C7BFA14  add r3, r27, r31
	ctx.r[3].u64 = ctx.r[27].u64 + ctx.r[31].u64;
	// 821CCE78: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 821CCE7C: 838B000C  lwz r28, 0xc(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CCE80: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821CCE84: 48ADC5FD  bl 0x82ca9480
	ctx.lr = 0x821CCE88;
	sub_82CA9480(ctx, base);
	// 821CCE88: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821CCE8C: 7FFCFA14  add r31, r28, r31
	ctx.r[31].u64 = ctx.r[28].u64 + ctx.r[31].u64;
	// 821CCE90: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 821CCE94: 4181FFDC  bgt 0x821cce70
	if ctx.cr[0].gt {
	pc = 0x821CCE70; continue 'dispatch;
	}
	// 821CCE98: 572B1838  slwi r11, r25, 3
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CCE9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821CCEA0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821CCEA4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821CCEA8: 7FEBD050  subf r31, r11, r26
	ctx.r[31].s64 = ctx.r[26].s64 - ctx.r[11].s64;
	// 821CCEAC: 4805AEF5  bl 0x82227da0
	ctx.lr = 0x821CCEB0;
	sub_82227DA0(ctx, base);
	// 821CCEB0: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821CCEB4: 927F0004  stw r19, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[19].u32 ) };
	// 821CCEB8: 7D59B850  subf r10, r25, r23
	ctx.r[10].s64 = ctx.r[23].s64 - ctx.r[25].s64;
	// 821CCEBC: 7D79B050  subf r11, r25, r22
	ctx.r[11].s64 = ctx.r[22].s64 - ctx.r[25].s64;
	// 821CCEC0: 3AEA0001  addi r23, r10, 1
	ctx.r[23].s64 = ctx.r[10].s64 + 1;
	// 821CCEC4: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 821CCEC8: 2F170001  cmpwi cr6, r23, 1
	ctx.cr[6].compare_i32(ctx.r[23].s32, 1, &mut ctx.xer);
	// 821CCECC: 4199FD88  bgt cr6, 0x821ccc54
	if ctx.cr[6].gt {
	pc = 0x821CCC54; continue 'dispatch;
	}
	// 821CCED0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821CCED4: 48ADC55C  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CCED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CCED8 size=1076
    let mut pc: u32 = 0x821CCED8;
    'dispatch: loop {
        match pc {
            0x821CCED8 => {
    //   block [0x821CCED8..0x821CD30C)
	// 821CCED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CCEDC: 48ADC509  bl 0x82ca93e4
	ctx.lr = 0x821CCEE0;
	sub_82CA93D0(ctx, base);
	// 821CCEE0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CCEE4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821CCEE8: 7C932378  mr r19, r4
	ctx.r[19].u64 = ctx.r[4].u64;
	// 821CCEEC: 817B0020  lwz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 821CCEF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CCEF4: 419A0094  beq cr6, 0x821ccf88
	if ctx.cr[6].eq {
	pc = 0x821CCF88; continue 'dispatch;
	}
	// 821CCEF8: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CCEFC: 3BDB0018  addi r30, r27, 0x18
	ctx.r[30].s64 = ctx.r[27].s64 + 24;
	// 821CCF00: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCF04: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCF08: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821CCF0C: 419A0008  beq cr6, 0x821ccf14
	if ctx.cr[6].eq {
	pc = 0x821CCF14; continue 'dispatch;
	}
	// 821CCF10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CCF14: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CCF18: 419A0068  beq cr6, 0x821ccf80
	if ctx.cr[6].eq {
	pc = 0x821CCF80; continue 'dispatch;
	}
	// 821CCF1C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCF20: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CCF24: 409A0008  bne cr6, 0x821ccf2c
	if !ctx.cr[6].eq {
	pc = 0x821CCF2C; continue 'dispatch;
	}
	// 821CCF28: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CCF2C: 3BBF0008  addi r29, r31, 8
	ctx.r[29].s64 = ctx.r[31].s64 + 8;
	// 821CCF30: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821CCF34: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821CCF38: 4819D1A9  bl 0x8236a0e0
	ctx.lr = 0x821CCF3C;
	sub_8236A0E0(ctx, base);
	// 821CCF3C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCF40: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CCF44: 409A0008  bne cr6, 0x821ccf4c
	if !ctx.cr[6].eq {
	pc = 0x821CCF4C; continue 'dispatch;
	}
	// 821CCF48: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CCF4C: 817B0040  lwz r11, 0x40(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(64 as u32) ) } as u64;
	// 821CCF50: 387B003C  addi r3, r27, 0x3c
	ctx.r[3].s64 = ctx.r[27].s64 + 60;
	// 821CCF54: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821CCF58: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821CCF5C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821CCF60: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821CCF64: 4897CE1D  bl 0x82b49d80
	ctx.lr = 0x821CCF68;
	sub_82B49D80(ctx, base);
	// 821CCF68: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCF6C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CCF70: 409A0008  bne cr6, 0x821ccf78
	if !ctx.cr[6].eq {
	pc = 0x821CCF78; continue 'dispatch;
	}
	// 821CCF74: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CCF78: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCF7C: 4BFFFF88  b 0x821ccf04
	pc = 0x821CCF04; continue 'dispatch;
	// 821CCF80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CCF84: 48847E0D  bl 0x82a14d90
	ctx.lr = 0x821CCF88;
	sub_82A14D90(ctx, base);
	// 821CCF88: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821CCF8C: 48103D05  bl 0x822d0c90
	ctx.lr = 0x821CCF90;
	sub_822D0C90(ctx, base);
	// 821CCF90: 817B0044  lwz r11, 0x44(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(68 as u32) ) } as u64;
	// 821CCF94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CCF98: 419A0064  beq cr6, 0x821ccffc
	if ctx.cr[6].eq {
	pc = 0x821CCFFC; continue 'dispatch;
	}
	// 821CCF9C: 817B0040  lwz r11, 0x40(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(64 as u32) ) } as u64;
	// 821CCFA0: 3BDB003C  addi r30, r27, 0x3c
	ctx.r[30].s64 = ctx.r[27].s64 + 60;
	// 821CCFA4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCFA8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCFAC: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821CCFB0: 419A0008  beq cr6, 0x821ccfb8
	if ctx.cr[6].eq {
	pc = 0x821CCFB8; continue 'dispatch;
	}
	// 821CCFB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CCFB8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CCFBC: 419A0038  beq cr6, 0x821ccff4
	if ctx.cr[6].eq {
	pc = 0x821CCFF4; continue 'dispatch;
	}
	// 821CCFC0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCFC4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CCFC8: 409A0008  bne cr6, 0x821ccfd0
	if !ctx.cr[6].eq {
	pc = 0x821CCFD0; continue 'dispatch;
	}
	// 821CCFCC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CCFD0: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 821CCFD4: 387B0024  addi r3, r27, 0x24
	ctx.r[3].s64 = ctx.r[27].s64 + 36;
	// 821CCFD8: 4819D109  bl 0x8236a0e0
	ctx.lr = 0x821CCFDC;
	sub_8236A0E0(ctx, base);
	// 821CCFDC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCFE0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CCFE4: 409A0008  bne cr6, 0x821ccfec
	if !ctx.cr[6].eq {
	pc = 0x821CCFEC; continue 'dispatch;
	}
	// 821CCFE8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CCFEC: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCFF0: 4BFFFFB8  b 0x821ccfa8
	pc = 0x821CCFA8; continue 'dispatch;
	// 821CCFF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CCFF8: 48847D99  bl 0x82a14d90
	ctx.lr = 0x821CCFFC;
	sub_82A14D90(ctx, base);
	// 821CCFFC: 817B0038  lwz r11, 0x38(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) } as u64;
	// 821CD000: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 821CD004: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD008: 419A005C  beq cr6, 0x821cd064
	if ctx.cr[6].eq {
	pc = 0x821CD064; continue 'dispatch;
	}
	// 821CD00C: 817B0034  lwz r11, 0x34(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) } as u64;
	// 821CD010: 3BFB0030  addi r31, r27, 0x30
	ctx.r[31].s64 = ctx.r[27].s64 + 48;
	// 821CD014: 3BDB0024  addi r30, r27, 0x24
	ctx.r[30].s64 = ctx.r[27].s64 + 36;
	// 821CD018: 92C10058  stw r22, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[22].u32 ) };
	// 821CD01C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 821CD020: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CD024: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CD028: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821CD02C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821CD030: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD034: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 821CD038: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821CD03C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821CD040: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 821CD044: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821CD048: 4827F0A1  bl 0x8244c0e8
	ctx.lr = 0x821CD04C;
	sub_8244C0E8(ctx, base);
	// 821CD04C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CD050: 48847D41  bl 0x82a14d90
	ctx.lr = 0x821CD054;
	sub_82A14D90(ctx, base);
	// 821CD054: 3D008245  lis r8, -0x7dbb
	ctx.r[8].s64 = -2109407232;
	// 821CD058: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CD05C: 3888B608  addi r4, r8, -0x49f8
	ctx.r[4].s64 = ctx.r[8].s64 + -18936;
	// 821CD060: 4827F109  bl 0x8244c168
	ctx.lr = 0x821CD064;
	sub_8244C168(ctx, base);
	// 821CD064: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821CD068: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821CD06C: 995B0050  stb r10, 0x50(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 821CD070: 3AFB0024  addi r23, r27, 0x24
	ctx.r[23].s64 = ctx.r[27].s64 + 36;
	// 821CD074: 813B0028  lwz r9, 0x28(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CD078: 3EA08349  lis r21, -0x7cb7
	ctx.r[21].s64 = -2092367872;
	// 821CD07C: 3B400018  li r26, 0x18
	ctx.r[26].s64 = 24;
	// 821CD080: 3E808349  lis r20, -0x7cb7
	ctx.r[20].s64 = -2092367872;
	// 821CD084: 816BE9EC  lwz r11, -0x1614(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5652 as u32) ) } as u64;
	// 821CD088: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821CD08C: 3B2B0024  addi r25, r11, 0x24
	ctx.r[25].s64 = ctx.r[11].s64 + 36;
	// 821CD090: 83090000  lwz r24, 0(r9)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD094: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD098: 7F17B840  cmplw cr6, r23, r23
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[23].u32, &mut ctx.xer);
	// 821CD09C: 419A0008  beq cr6, 0x821cd0a4
	if ctx.cr[6].eq {
	pc = 0x821CD0A4; continue 'dispatch;
	}
	// 821CD0A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CD0A4: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CD0A8: 419A0258  beq cr6, 0x821cd300
	if ctx.cr[6].eq {
	pc = 0x821CD300; continue 'dispatch;
	}
	// 821CD0AC: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD0B0: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CD0B4: 409A0008  bne cr6, 0x821cd0bc
	if !ctx.cr[6].eq {
	pc = 0x821CD0BC; continue 'dispatch;
	}
	// 821CD0B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CD0BC: 83980008  lwz r28, 8(r24)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CD0C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821CD0C4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821CD0C8: 4BFE6F59  bl 0x821b4020
	ctx.lr = 0x821CD0CC;
	sub_821B4020(ctx, base);
	// 821CD0CC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CD0D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD0D4: 409A0214  bne cr6, 0x821cd2e8
	if !ctx.cr[6].eq {
	pc = 0x821CD2E8; continue 'dispatch;
	}
	// 821CD0D8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD0DC: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 821CD0E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CD0E4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CD0E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CD0EC: 4E800421  bctrl
	ctx.lr = 0x821CD0F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CD0F0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CD0F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CD0F8: 419A007C  beq cr6, 0x821cd174
	if ctx.cr[6].eq {
	pc = 0x821CD174; continue 'dispatch;
	}
	// 821CD0FC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD100: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CD104: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CD108: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CD10C: 4E800421  bctrl
	ctx.lr = 0x821CD110;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CD110: 81390008  lwz r9, 8(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CD114: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD118: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821CD11C: 419A0058  beq cr6, 0x821cd174
	if ctx.cr[6].eq {
	pc = 0x821CD174; continue 'dispatch;
	}
	// 821CD120: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821CD124: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD128: 409A0034  bne cr6, 0x821cd15c
	if !ctx.cr[6].eq {
	pc = 0x821CD15C; continue 'dispatch;
	}
	// 821CD12C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD130: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CD134: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CD138: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CD13C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CD140: 4E800421  bctrl
	ctx.lr = 0x821CD144;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CD144: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821CD148: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821CD14C: 4BFE6ED5  bl 0x821b4020
	ctx.lr = 0x821CD150;
	sub_821B4020(ctx, base);
	// 821CD150: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CD154: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CD158: 409A0018  bne cr6, 0x821cd170
	if !ctx.cr[6].eq {
	pc = 0x821CD170; continue 'dispatch;
	}
	// 821CD15C: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CD160: 3BFF0048  addi r31, r31, 0x48
	ctx.r[31].s64 = ctx.r[31].s64 + 72;
	// 821CD164: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CD168: 409AFFB8  bne cr6, 0x821cd120
	if !ctx.cr[6].eq {
	pc = 0x821CD120; continue 'dispatch;
	}
	// 821CD16C: 48000008  b 0x821cd174
	pc = 0x821CD174; continue 'dispatch;
	// 821CD170: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 821CD174: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 821CD178: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD17C: 409A016C  bne cr6, 0x821cd2e8
	if !ctx.cr[6].eq {
	pc = 0x821CD2E8; continue 'dispatch;
	}
	// 821CD180: 811B0058  lwz r8, 0x58(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(88 as u32) ) } as u64;
	// 821CD184: 3BBB0054  addi r29, r27, 0x54
	ctx.r[29].s64 = ctx.r[27].s64 + 84;
	// 821CD188: 817B005C  lwz r11, 0x5c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(92 as u32) ) } as u64;
	// 821CD18C: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CD190: 419A0058  beq cr6, 0x821cd1e8
	if ctx.cr[6].eq {
	pc = 0x821CD1E8; continue 'dispatch;
	}
	// 821CD194: 7D2B5850  subf r9, r11, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[11].s64;
	// 821CD198: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CD19C: 7D29D3D6  divw r9, r9, r26
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 821CD1A0: 7F0B5840  cmplw cr6, r11, r11
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CD1A4: 5527083C  slwi r7, r9, 1
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821CD1A8: 7CE93A14  add r7, r9, r7
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 821CD1AC: 54E91838  slwi r9, r7, 3
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CD1B0: 7CE94214  add r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821CD1B4: 419A0030  beq cr6, 0x821cd1e4
	if ctx.cr[6].eq {
	pc = 0x821CD1E4; continue 'dispatch;
	}
	// 821CD1B8: 7D2B4050  subf r9, r11, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 821CD1BC: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821CD1C0: 7CCA4A14  add r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821CD1C4: 7D0A492A  stdx r8, r10, r9
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u64) };
	// 821CD1C8: E8AA0008  ld r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821CD1CC: F8A60008  std r5, 8(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	// 821CD1D0: E88A0010  ld r4, 0x10(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	// 821CD1D4: 394A0018  addi r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 + 24;
	// 821CD1D8: F8860010  std r4, 0x10(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), ctx.r[4].u64 ) };
	// 821CD1DC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CD1E0: 409AFFDC  bne cr6, 0x821cd1bc
	if !ctx.cr[6].eq {
	pc = 0x821CD1BC; continue 'dispatch;
	}
	// 821CD1E4: 90FD0008  stw r7, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821CD1E8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD1EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CD1F0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CD1F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CD1F8: 4E800421  bctrl
	ctx.lr = 0x821CD1FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CD1FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821CD200: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 821CD204: 4809702D  bl 0x82264230
	ctx.lr = 0x821CD208;
	sub_82264230(ctx, base);
	// 821CD208: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CD20C: 419A000C  beq cr6, 0x821cd218
	if ctx.cr[6].eq {
	pc = 0x821CD218; continue 'dispatch;
	}
	// 821CD210: 80A30028  lwz r5, 0x28(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CD214: 48000058  b 0x821cd26c
	pc = 0x821CD26C; continue 'dispatch;
	// 821CD218: 81556AB8  lwz r10, 0x6ab8(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821CD21C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CD220: 419A000C  beq cr6, 0x821cd22c
	if ctx.cr[6].eq {
	pc = 0x821CD22C; continue 'dispatch;
	}
	// 821CD224: 89746A5E  lbz r11, 0x6a5e(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[20].u32.wrapping_add(27230 as u32) ) } as u64;
	// 821CD228: 48000008  b 0x821cd230
	pc = 0x821CD230; continue 'dispatch;
	// 821CD22C: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 821CD230: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CD234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD238: 419A0030  beq cr6, 0x821cd268
	if ctx.cr[6].eq {
	pc = 0x821CD268; continue 'dispatch;
	}
	// 821CD23C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CD240: 814B011C  lwz r10, 0x11c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) } as u64;
	// 821CD244: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821CD248: 409A0020  bne cr6, 0x821cd268
	if !ctx.cr[6].eq {
	pc = 0x821CD268; continue 'dispatch;
	}
	// 821CD24C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821CD250: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 821CD254: 48096FDD  bl 0x82264230
	ctx.lr = 0x821CD258;
	sub_82264230(ctx, base);
	// 821CD258: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CD25C: 419A000C  beq cr6, 0x821cd268
	if ctx.cr[6].eq {
	pc = 0x821CD268; continue 'dispatch;
	}
	// 821CD260: 80A30028  lwz r5, 0x28(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CD264: 48000008  b 0x821cd26c
	pc = 0x821CD26C; continue 'dispatch;
	// 821CD268: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821CD26C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821CD270: 807B0048  lwz r3, 0x48(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CD274: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821CD278: 480007F9  bl 0x821cda70
	ctx.lr = 0x821CD27C;
	sub_821CDA70(ctx, base);
	// 821CD27C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD280: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CD284: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 821CD288: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821CD28C: 7D09D3D7  divw. r8, r9, r26
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821CD290: 41820058  beq 0x821cd2e8
	if ctx.cr[0].eq {
	pc = 0x821CD2E8; continue 'dispatch;
	}
	// 821CD294: 7EDFB378  mr r31, r22
	ctx.r[31].u64 = ctx.r[22].u64;
	// 821CD298: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD29C: 7C8BFA14  add r4, r11, r31
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821CD2A0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CD2A4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD2A8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821CD2AC: 4E800421  bctrl
	ctx.lr = 0x821CD2B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CD2B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821CD2B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821CD2B8: 4BFE6D69  bl 0x821b4020
	ctx.lr = 0x821CD2BC;
	sub_821B4020(ctx, base);
	// 821CD2BC: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CD2C0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821CD2C4: 409A0024  bne cr6, 0x821cd2e8
	if !ctx.cr[6].eq {
	pc = 0x821CD2E8; continue 'dispatch;
	}
	// 821CD2C8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD2CC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821CD2D0: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CD2D4: 3BFF0018  addi r31, r31, 0x18
	ctx.r[31].s64 = ctx.r[31].s64 + 24;
	// 821CD2D8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821CD2DC: 7D09D3D6  divw r8, r9, r26
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 821CD2E0: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CD2E4: 4198FFB4  blt cr6, 0x821cd298
	if ctx.cr[6].lt {
	pc = 0x821CD298; continue 'dispatch;
	}
	// 821CD2E8: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD2EC: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CD2F0: 409A0008  bne cr6, 0x821cd2f8
	if !ctx.cr[6].eq {
	pc = 0x821CD2F8; continue 'dispatch;
	}
	// 821CD2F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CD2F8: 83180000  lwz r24, 0(r24)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD2FC: 4BFFFD98  b 0x821cd094
	pc = 0x821CD094; continue 'dispatch;
	// 821CD300: 9ADB0050  stb r22, 0x50(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(80 as u32), ctx.r[22].u8 ) };
	// 821CD304: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821CD308: 48ADC12C  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CD310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CD310 size=828
    let mut pc: u32 = 0x821CD310;
    'dispatch: loop {
        match pc {
            0x821CD310 => {
    //   block [0x821CD310..0x821CD64C)
	// 821CD310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CD314: 48ADC0DD  bl 0x82ca93f0
	ctx.lr = 0x821CD318;
	sub_82CA93D0(ctx, base);
	// 821CD318: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CD31C: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 821CD320: 3F008349  lis r24, -0x7cb7
	ctx.r[24].s64 = -2092367872;
	// 821CD324: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 821CD328: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD32C: 80786E98  lwz r3, 0x6e98(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28312 as u32) ) } as u64;
	// 821CD330: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CD334: 83EB0014  lwz r31, 0x14(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CD338: 419A030C  beq cr6, 0x821cd644
	if ctx.cr[6].eq {
	pc = 0x821CD644; continue 'dispatch;
	}
	// 821CD33C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821CD340: 4894F179  bl 0x82b1c4b8
	ctx.lr = 0x821CD344;
	sub_82B1C4B8(ctx, base);
	// 821CD344: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CD348: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD34C: 419A02F8  beq cr6, 0x821cd644
	if ctx.cr[6].eq {
	pc = 0x821CD644; continue 'dispatch;
	}
	// 821CD350: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821CD354: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821CD358: 3B4BAC08  addi r26, r11, -0x53f8
	ctx.r[26].s64 = ctx.r[11].s64 + -21496;
	// 821CD35C: 386AAC10  addi r3, r10, -0x53f0
	ctx.r[3].s64 = ctx.r[10].s64 + -21488;
	// 821CD360: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821CD364: 4887F865  bl 0x82a4cbc8
	ctx.lr = 0x821CD368;
	sub_82A4CBC8(ctx, base);
	// 821CD368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CD36C: 4BFE9DBD  bl 0x821b7128
	ctx.lr = 0x821CD370;
	sub_821B7128(ctx, base);
	// 821CD370: 89390068  lbz r9, 0x68(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(104 as u32) ) } as u64;
	// 821CD374: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CD378: 409A01B8  bne cr6, 0x821cd530
	if !ctx.cr[6].eq {
	pc = 0x821CD530; continue 'dispatch;
	}
	// 821CD37C: 81790014  lwz r11, 0x14(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CD380: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821CD384: 419A01AC  beq cr6, 0x821cd530
	if ctx.cr[6].eq {
	pc = 0x821CD530; continue 'dispatch;
	}
	// 821CD388: 3EE08349  lis r23, -0x7cb7
	ctx.r[23].s64 = -2092367872;
	// 821CD38C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 821CD390: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821CD394: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821CD398: 3BAA0364  addi r29, r10, 0x364
	ctx.r[29].s64 = ctx.r[10].s64 + 868;
	// 821CD39C: 897770D3  lbz r11, 0x70d3(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(28883 as u32) ) } as u64;
	// 821CD3A0: 83EA0364  lwz r31, 0x364(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(868 as u32) ) } as u64;
	// 821CD3A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD3A8: 3D602AAA  lis r11, 0x2aaa
	ctx.r[11].s64 = 715784192;
	// 821CD3AC: 616BAAAA  ori r11, r11, 0xaaaa
	ctx.r[11].u64 = ctx.r[11].u64 | 43690;
	// 821CD3B0: 419A0080  beq cr6, 0x821cd430
	if ctx.cr[6].eq {
	pc = 0x821CD430; continue 'dispatch;
	}
	// 821CD3B4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 821CD3B8: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 821CD3BC: 817F34CC  lwz r11, 0x34cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13516 as u32) ) } as u64;
	// 821CD3C0: 80CB006C  lwz r6, 0x6c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 821CD3C4: 60C50040  ori r5, r6, 0x40
	ctx.r[5].u64 = ctx.r[6].u64 | 64;
	// 821CD3C8: 90AB006C  stw r5, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[5].u32 ) };
	// 821CD3CC: 809F0038  lwz r4, 0x38(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821CD3D0: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821CD3D4: 897F2ABC  lbz r11, 0x2abc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821CD3D8: 556A003C  rlwinm r10, r11, 0, 0, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821CD3DC: 913F31AC  stw r9, 0x31ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12716 as u32), ctx.r[9].u32 ) };
	// 821CD3E0: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821CD3E4: 995F2ABC  stb r10, 0x2abc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10940 as u32), ctx.r[10].u8 ) };
	// 821CD3E8: 911F31A4  stw r8, 0x31a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12708 as u32), ctx.r[8].u32 ) };
	// 821CD3EC: 93DF31A8  stw r30, 0x31a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12712 as u32), ctx.r[30].u32 ) };
	// 821CD3F0: 90FF2AB4  stw r7, 0x2ab4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10932 as u32), ctx.r[7].u32 ) };
	// 821CD3F4: 93DF2AB8  stw r30, 0x2ab8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10936 as u32), ctx.r[30].u32 ) };
	// 821CD3F8: 4099000C  ble cr6, 0x821cd404
	if !ctx.cr[6].gt {
	pc = 0x821CD404; continue 'dispatch;
	}
	// 821CD3FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CD400: 4801BAC1  bl 0x821e8ec0
	ctx.lr = 0x821CD404;
	sub_821E8EC0(ctx, base);
	// 821CD404: 3D60C000  lis r11, -0x4000
	ctx.r[11].s64 = -1073741824;
	// 821CD408: 3D40C000  lis r10, -0x4000
	ctx.r[10].s64 = -1073741824;
	// 821CD40C: 61696000  ori r9, r11, 0x6000
	ctx.r[9].u64 = ctx.r[11].u64 | 24576;
	// 821CD410: 61486100  ori r8, r10, 0x6100
	ctx.r[8].u64 = ctx.r[10].u64 | 24832;
	// 821CD414: 95230004  stwu r9, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[3].u32 = ea;
	// 821CD418: 80FF31A4  lwz r7, 0x31a4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12708 as u32) ) } as u64;
	// 821CD41C: 94E30004  stwu r7, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[7].u32) };
	ctx.r[3].u32 = ea;
	// 821CD420: 95030004  stwu r8, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[8].u32) };
	ctx.r[3].u32 = ea;
	// 821CD424: 80DF31A8  lwz r6, 0x31a8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12712 as u32) ) } as u64;
	// 821CD428: 94C30004  stwu r6, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[6].u32) };
	ctx.r[3].u32 = ea;
	// 821CD42C: 48000050  b 0x821cd47c
	pc = 0x821CD47C; continue 'dispatch;
	// 821CD430: 891F2ABC  lbz r8, 0x2abc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821CD434: 80FF0038  lwz r7, 0x38(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821CD438: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821CD43C: 5506003C  rlwinm r6, r8, 0, 0, 0x1e
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821CD440: 913F31AC  stw r9, 0x31ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12716 as u32), ctx.r[9].u32 ) };
	// 821CD444: 917F31A4  stw r11, 0x31a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12708 as u32), ctx.r[11].u32 ) };
	// 821CD448: 7F033840  cmplw cr6, r3, r7
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821CD44C: 98DF2ABC  stb r6, 0x2abc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10940 as u32), ctx.r[6].u8 ) };
	// 821CD450: 93DF31A8  stw r30, 0x31a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12712 as u32), ctx.r[30].u32 ) };
	// 821CD454: 917F2AB4  stw r11, 0x2ab4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10932 as u32), ctx.r[11].u32 ) };
	// 821CD458: 93DF2AB8  stw r30, 0x2ab8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10936 as u32), ctx.r[30].u32 ) };
	// 821CD45C: 4099000C  ble cr6, 0x821cd468
	if !ctx.cr[6].gt {
	pc = 0x821CD468; continue 'dispatch;
	}
	// 821CD460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CD464: 4801BA5D  bl 0x821e8ec0
	ctx.lr = 0x821CD468;
	sub_821E8EC0(ctx, base);
	// 821CD468: 3D60C000  lis r11, -0x4000
	ctx.r[11].s64 = -1073741824;
	// 821CD46C: 616A6000  ori r10, r11, 0x6000
	ctx.r[10].u64 = ctx.r[11].u64 | 24576;
	// 821CD470: 95430004  stwu r10, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[3].u32 = ea;
	// 821CD474: 813F31A4  lwz r9, 0x31a4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12708 as u32) ) } as u64;
	// 821CD478: 95230004  stwu r9, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[3].u32 = ea;
	// 821CD47C: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 821CD480: 38C00070  li r6, 0x70
	ctx.r[6].s64 = 112;
	// 821CD484: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 821CD488: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD48C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821CD490: 4BFCF8D9  bl 0x8219cd68
	ctx.lr = 0x821CD494;
	sub_8219CD68(ctx, base);
	// 821CD494: 81790014  lwz r11, 0x14(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CD498: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821CD49C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CD4A0: 409901A0  ble cr6, 0x821cd640
	if !ctx.cr[6].gt {
	pc = 0x821CD640; continue 'dispatch;
	}
	// 821CD4A4: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821CD4A8: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 821CD4AC: 3B6BA980  addi r27, r11, -0x5680
	ctx.r[27].s64 = ctx.r[11].s64 + -22144;
	// 821CD4B0: 897770D3  lbz r11, 0x70d3(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(28883 as u32) ) } as u64;
	// 821CD4B4: 7F84F030  slw r4, r28, r30
	if (ctx.r[30].u8 & 0x20) != 0 {
		ctx.r[4].u64 = 0;
	} else {
		ctx.r[4].u64 = ((ctx.r[28].u32) << ((ctx.r[30].u8 & 0x1F) as u32)) as u64;
	}
	// 821CD4B8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD4BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD4C0: 419A0010  beq cr6, 0x821cd4d0
	if ctx.cr[6].eq {
	pc = 0x821CD4D0; continue 'dispatch;
	}
	// 821CD4C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821CD4C8: 489D4879  bl 0x82ba1d40
	ctx.lr = 0x821CD4CC;
	sub_82BA1D40(ctx, base);
	// 821CD4CC: 48000008  b 0x821cd4d4
	pc = 0x821CD4D4; continue 'dispatch;
	// 821CD4D0: 48098121  bl 0x822655f0
	ctx.lr = 0x821CD4D4;
	sub_822655F0(ctx, base);
	// 821CD4D4: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD4D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD4DC: 419A0034  beq cr6, 0x821cd510
	if ctx.cr[6].eq {
	pc = 0x821CD510; continue 'dispatch;
	}
	// 821CD4E0: 81560004  lwz r10, 4(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD4E4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 821CD4E8: 81786E98  lwz r11, 0x6e98(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28312 as u32) ) } as u64;
	// 821CD4EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821CD4F0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821CD4F4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821CD4F8: 4BFB0161  bl 0x8217d658
	ctx.lr = 0x821CD4FC;
	sub_8217D658(ctx, base);
	// 821CD4FC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821CD500: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821CD504: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CD508: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821CD50C: 480B52AD  bl 0x822827b8
	ctx.lr = 0x821CD510;
	sub_822827B8(ctx, base);
	// 821CD510: 81790014  lwz r11, 0x14(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CD514: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821CD518: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 821CD51C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821CD520: 4198FF90  blt cr6, 0x821cd4b0
	if ctx.cr[6].lt {
	pc = 0x821CD4B0; continue 'dispatch;
	}
	// 821CD524: 480C90BD  bl 0x822965e0
	ctx.lr = 0x821CD528;
	sub_822965E0(ctx, base);
	// 821CD528: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821CD52C: 48ADBF14  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 821CD530: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821CD534: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 821CD538: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821CD53C: 894B70D3  lbz r10, 0x70d3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28883 as u32) ) } as u64;
	// 821CD540: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821CD544: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CD548: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821CD54C: 3BAB0364  addi r29, r11, 0x364
	ctx.r[29].s64 = ctx.r[11].s64 + 868;
	// 821CD550: 83EB0364  lwz r31, 0x364(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 821CD554: 419A0078  beq cr6, 0x821cd5cc
	if ctx.cr[6].eq {
	pc = 0x821CD5CC; continue 'dispatch;
	}
	// 821CD558: 817F34CC  lwz r11, 0x34cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13516 as u32) ) } as u64;
	// 821CD55C: 812B006C  lwz r9, 0x6c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 821CD560: 61280040  ori r8, r9, 0x40
	ctx.r[8].u64 = ctx.r[9].u64 | 64;
	// 821CD564: 910B006C  stw r8, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[8].u32 ) };
	// 821CD568: 80FF0038  lwz r7, 0x38(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821CD56C: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821CD570: 7F033840  cmplw cr6, r3, r7
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821CD574: 88DF2ABC  lbz r6, 0x2abc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821CD578: 915F31AC  stw r10, 0x31ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12716 as u32), ctx.r[10].u32 ) };
	// 821CD57C: 54C5003C  rlwinm r5, r6, 0, 0, 0x1e
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 821CD580: 939F31A4  stw r28, 0x31a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12708 as u32), ctx.r[28].u32 ) };
	// 821CD584: 93DF31A8  stw r30, 0x31a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12712 as u32), ctx.r[30].u32 ) };
	// 821CD588: 939F2AB4  stw r28, 0x2ab4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10932 as u32), ctx.r[28].u32 ) };
	// 821CD58C: 93DF2AB8  stw r30, 0x2ab8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10936 as u32), ctx.r[30].u32 ) };
	// 821CD590: 98BF2ABC  stb r5, 0x2abc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10940 as u32), ctx.r[5].u8 ) };
	// 821CD594: 4099000C  ble cr6, 0x821cd5a0
	if !ctx.cr[6].gt {
	pc = 0x821CD5A0; continue 'dispatch;
	}
	// 821CD598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CD59C: 4801B925  bl 0x821e8ec0
	ctx.lr = 0x821CD5A0;
	sub_821E8EC0(ctx, base);
	// 821CD5A0: 3D60C000  lis r11, -0x4000
	ctx.r[11].s64 = -1073741824;
	// 821CD5A4: 3D40C000  lis r10, -0x4000
	ctx.r[10].s64 = -1073741824;
	// 821CD5A8: 61696000  ori r9, r11, 0x6000
	ctx.r[9].u64 = ctx.r[11].u64 | 24576;
	// 821CD5AC: 61486100  ori r8, r10, 0x6100
	ctx.r[8].u64 = ctx.r[10].u64 | 24832;
	// 821CD5B0: 95230004  stwu r9, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[3].u32 = ea;
	// 821CD5B4: 80FF31A4  lwz r7, 0x31a4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12708 as u32) ) } as u64;
	// 821CD5B8: 94E30004  stwu r7, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[7].u32) };
	ctx.r[3].u32 = ea;
	// 821CD5BC: 95030004  stwu r8, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[8].u32) };
	ctx.r[3].u32 = ea;
	// 821CD5C0: 80DF31A8  lwz r6, 0x31a8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12712 as u32) ) } as u64;
	// 821CD5C4: 94C30004  stwu r6, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[6].u32) };
	ctx.r[3].u32 = ea;
	// 821CD5C8: 48000050  b 0x821cd618
	pc = 0x821CD618; continue 'dispatch;
	// 821CD5CC: 893F2ABC  lbz r9, 0x2abc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821CD5D0: 811F0038  lwz r8, 0x38(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821CD5D4: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821CD5D8: 5527003C  rlwinm r7, r9, 0, 0, 0x1e
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821CD5DC: 915F31AC  stw r10, 0x31ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12716 as u32), ctx.r[10].u32 ) };
	// 821CD5E0: 939F31A4  stw r28, 0x31a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12708 as u32), ctx.r[28].u32 ) };
	// 821CD5E4: 7F034040  cmplw cr6, r3, r8
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CD5E8: 98FF2ABC  stb r7, 0x2abc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10940 as u32), ctx.r[7].u8 ) };
	// 821CD5EC: 93DF31A8  stw r30, 0x31a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12712 as u32), ctx.r[30].u32 ) };
	// 821CD5F0: 939F2AB4  stw r28, 0x2ab4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10932 as u32), ctx.r[28].u32 ) };
	// 821CD5F4: 93DF2AB8  stw r30, 0x2ab8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10936 as u32), ctx.r[30].u32 ) };
	// 821CD5F8: 4099000C  ble cr6, 0x821cd604
	if !ctx.cr[6].gt {
	pc = 0x821CD604; continue 'dispatch;
	}
	// 821CD5FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CD600: 4801B8C1  bl 0x821e8ec0
	ctx.lr = 0x821CD604;
	sub_821E8EC0(ctx, base);
	// 821CD604: 3D60C000  lis r11, -0x4000
	ctx.r[11].s64 = -1073741824;
	// 821CD608: 616A6000  ori r10, r11, 0x6000
	ctx.r[10].u64 = ctx.r[11].u64 | 24576;
	// 821CD60C: 95430004  stwu r10, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[3].u32 = ea;
	// 821CD610: 813F31A4  lwz r9, 0x31a4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12708 as u32) ) } as u64;
	// 821CD614: 95230004  stwu r9, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[3].u32 = ea;
	// 821CD618: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 821CD61C: 38C00070  li r6, 0x70
	ctx.r[6].s64 = 112;
	// 821CD620: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 821CD624: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821CD628: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD62C: 4BFCF73D  bl 0x8219cd68
	ctx.lr = 0x821CD630;
	sub_8219CD68(ctx, base);
	// 821CD630: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821CD634: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821CD638: 388BA980  addi r4, r11, -0x5680
	ctx.r[4].s64 = ctx.r[11].s64 + -22144;
	// 821CD63C: 480EA835  bl 0x822b7e70
	ctx.lr = 0x821CD640;
	sub_822B7E70(ctx, base);
	// 821CD640: 480C8FA1  bl 0x822965e0
	ctx.lr = 0x821CD644;
	sub_822965E0(ctx, base);
	// 821CD644: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821CD648: 48ADBDF8  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CD650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CD650 size=384
    let mut pc: u32 = 0x821CD650;
    'dispatch: loop {
        match pc {
            0x821CD650 => {
    //   block [0x821CD650..0x821CD7D0)
	// 821CD650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CD654: 48ADBDB9  bl 0x82ca940c
	ctx.lr = 0x821CD658;
	sub_82CA93D0(ctx, base);
	// 821CD658: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CD65C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CD660: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821CD664: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821CD668: 897F0014  lbz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CD66C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD670: 419A0014  beq cr6, 0x821cd684
	if ctx.cr[6].eq {
	pc = 0x821CD684; continue 'dispatch;
	}
	// 821CD674: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 821CD678: 57CA063E  clrlwi r10, r30, 0x18
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 821CD67C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CD680: 419A0148  beq cr6, 0x821cd7c8
	if ctx.cr[6].eq {
	pc = 0x821CD7C8; continue 'dispatch;
	}
	// 821CD684: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 821CD688: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821CD68C: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CD690: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD694: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 821CD698: 419A00E4  beq cr6, 0x821cd77c
	if ctx.cr[6].eq {
	pc = 0x821CD77C; continue 'dispatch;
	}
	// 821CD69C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD6A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821CD6A4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821CD6A8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821CD6AC: 419A006C  beq cr6, 0x821cd718
	if ctx.cr[6].eq {
	pc = 0x821CD718; continue 'dispatch;
	}
	// 821CD6B0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CD6B4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821CD6B8: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 821CD6BC: 419A00FC  beq cr6, 0x821cd7b8
	if ctx.cr[6].eq {
	pc = 0x821CD7B8; continue 'dispatch;
	}
	// 821CD6C0: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821CD6C4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 821CD6C8: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 821CD6CC: 39210074  addi r9, r1, 0x74
	ctx.r[9].s64 = ctx.r[1].s64 + 116;
	// 821CD6D0: 7D451E70  srawi r5, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 821CD6D4: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 821CD6D8: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821CD6DC: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 821CD6E0: 39050001  addi r8, r5, 1
	ctx.r[8].s64 = ctx.r[5].s64 + 1;
	// 821CD6E4: 91210084  stw r9, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 821CD6E8: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821CD6EC: 7D0B0E70  srawi r11, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 1) as i64;
	// 821CD6F0: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821CD6F4: E8610060  ld r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821CD6F8: 7D4B0194  addze r10, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[10].s64 = tmp.s64;
	// 821CD6FC: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821CD700: 480FEF31  bl 0x822cc630
	ctx.lr = 0x821CD704;
	sub_822CC630(ctx, base);
	// 821CD704: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821CD708: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CD70C: 419A00AC  beq cr6, 0x821cd7b8
	if ctx.cr[6].eq {
	pc = 0x821CD7B8; continue 'dispatch;
	}
	// 821CD710: 4804E629  bl 0x8221bd38
	ctx.lr = 0x821CD714;
	sub_8221BD38(ctx, base);
	// 821CD714: 480000A4  b 0x821cd7b8
	pc = 0x821CD7B8; continue 'dispatch;
	// 821CD718: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CD71C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821CD720: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 821CD724: 419A0094  beq cr6, 0x821cd7b8
	if ctx.cr[6].eq {
	pc = 0x821CD7B8; continue 'dispatch;
	}
	// 821CD728: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821CD72C: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 821CD730: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 821CD734: 39210094  addi r9, r1, 0x94
	ctx.r[9].s64 = ctx.r[1].s64 + 148;
	// 821CD738: 7D451E70  srawi r5, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 821CD73C: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 821CD740: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 821CD744: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 821CD748: 39050001  addi r8, r5, 1
	ctx.r[8].s64 = ctx.r[5].s64 + 1;
	// 821CD74C: 912100A4  stw r9, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[9].u32 ) };
	// 821CD750: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821CD754: 7D070E70  srawi r7, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 1) as i64;
	// 821CD758: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821CD75C: 7D670194  addze r11, r7
	tmp.s64 = ctx.r[7].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[7].u32);
	ctx.r[11].s64 = tmp.s64;
	// 821CD760: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821CD764: 488DA49D  bl 0x82aa7c00
	ctx.lr = 0x821CD768;
	sub_82AA7C00(ctx, base);
	// 821CD768: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821CD76C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CD770: 419A0048  beq cr6, 0x821cd7b8
	if ctx.cr[6].eq {
	pc = 0x821CD7B8; continue 'dispatch;
	}
	// 821CD774: 4804E5C5  bl 0x8221bd38
	ctx.lr = 0x821CD778;
	sub_8221BD38(ctx, base);
	// 821CD778: 48000040  b 0x821cd7b8
	pc = 0x821CD7B8; continue 'dispatch;
	// 821CD77C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD780: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821CD784: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821CD788: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 821CD78C: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821CD790: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821CD794: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821CD798: 7D051E70  srawi r5, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 821CD79C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821CD7A0: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821CD7A4: 419A0010  beq cr6, 0x821cd7b4
	if ctx.cr[6].eq {
	pc = 0x821CD7B4; continue 'dispatch;
	}
	// 821CD7A8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821CD7AC: 4BFC9225  bl 0x821969d0
	ctx.lr = 0x821CD7B0;
	sub_821969D0(ctx, base);
	// 821CD7B0: 48000008  b 0x821cd7b8
	pc = 0x821CD7B8; continue 'dispatch;
	// 821CD7B4: 4BFEA025  bl 0x821b77d8
	ctx.lr = 0x821CD7B8;
	sub_821B77D8(ctx, base);
	// 821CD7B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CD7BC: 9BDF0015  stb r30, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[30].u8 ) };
	// 821CD7C0: 9BBF0016  stb r29, 0x16(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(22 as u32), ctx.r[29].u8 ) };
	// 821CD7C4: 997F0014  stb r11, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 821CD7C8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821CD7CC: 48ADBC90  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CD7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821CD7D0 size=16
    let mut pc: u32 = 0x821CD7D0;
    'dispatch: loop {
        match pc {
            0x821CD7D0 => {
    //   block [0x821CD7D0..0x821CD7E0)
	// 821CD7D0: 3CC08336  lis r6, -0x7cca
	ctx.r[6].s64 = -2093613056;
	// 821CD7D4: 896605A0  lbz r11, 0x5a0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(1440 as u32) ) } as u64;
	// 821CD7D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD7DC: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CD7E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821CD7E0 size=228
    let mut pc: u32 = 0x821CD7E0;
    'dispatch: loop {
        match pc {
            0x821CD7E0 => {
    //   block [0x821CD7E0..0x821CD8C4)
	// 821CD7E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CD7E4: 3CA08336  lis r5, -0x7cca
	ctx.r[5].s64 = -2093613056;
	// 821CD7E8: 396B9490  addi r11, r11, -0x6b70
	ctx.r[11].s64 = ctx.r[11].s64 + -27504;
	// 821CD7EC: 394505B0  addi r10, r5, 0x5b0
	ctx.r[10].s64 = ctx.r[5].s64 + 1456;
	// 821CD7F0: 3C808336  lis r4, -0x7cca
	ctx.r[4].s64 = -2093613056;
	// 821CD7F4: 392A0010  addi r9, r10, 0x10
	ctx.r[9].s64 = ctx.r[10].s64 + 16;
	// 821CD7F8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821CD7FC: C0CB296C  lfs f6, 0x296c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10604 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821CD800: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821CD804: C0AB2360  lfs f5, 0x2360(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9056 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821CD808: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821CD80C: 9104059C  stw r8, 0x59c(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(1436 as u32), ctx.r[8].u32 ) };
	// 821CD810: D0CA0004  stfs f6, 4(r10)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821CD814: D0AA0008  stfs f5, 8(r10)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821CD818: D16A000C  stfs f11, 0xc(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821CD81C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821CD820: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821CD824: C14B1FDC  lfs f10, 0x1fdc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8156 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821CD828: D1A505B0  stfs f13, 0x5b0(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(1456 as u32), tmp.u32 ) };
	// 821CD82C: C0EA0C50  lfs f7, 0xc50(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3152 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821CD830: 7CEA07B4  extsw r10, r7
	ctx.r[10].s64 = ctx.r[7].s32 as i64;
	// 821CD834: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821CD838: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 821CD83C: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821CD840: FD80069C  fcfid f12, f0
	ctx.f[12].f64 = (ctx.f[0].s64 as f64);
	// 821CD844: FD206018  frsp f9, f12
	ctx.f[9].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821CD848: ED8959F8  fmsubs f12, f9, f7, f11
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[7].f64 - ctx.f[11].f64) as f32) as f64);
	// 821CD84C: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 821CD850: FC006210  fabs f0, f12
	ctx.f[0].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 821CD854: F941FFF8  std r10, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[10].u64 ) };
	// 821CD858: C881FFF8  lfd f4, -8(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821CD85C: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 821CD860: FC401818  frsp f2, f3
	ctx.f[2].f64 = (ctx.f[3].f64 as f32) as f64;
	// 821CD864: ED000332  fmuls f8, f0, f12
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 821CD868: EC2259F8  fmsubs f1, f2, f7, f11
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[7].f64 - ctx.f[11].f64) as f32) as f64);
	// 821CD86C: ED2832BA  fmadds f9, f8, f10, f6
	ctx.f[9].f64 = (((ctx.f[8].f64 * ctx.f[10].f64 + ctx.f[6].f64) as f32) as f64);
	// 821CD870: FF086800  fcmpu cr6, f8, f13
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[13].f64);
	// 821CD874: FC000A10  fabs f0, f1
	ctx.f[0].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 821CD878: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 821CD87C: ED002ABA  fmadds f8, f0, f10, f5
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[10].f64 + ctx.f[5].f64) as f32) as f64);
	// 821CD880: 409A000C  bne cr6, 0x821cd88c
	if !ctx.cr[6].eq {
	pc = 0x821CD88C; continue 'dispatch;
	}
	// 821CD884: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821CD888: 419A0018  beq cr6, 0x821cd8a0
	if ctx.cr[6].eq {
	pc = 0x821CD8A0; continue 'dispatch;
	}
	// 821CD88C: D1A90000  stfs f13, 0(r9)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821CD890: D1290004  stfs f9, 4(r9)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821CD894: D1090008  stfs f8, 8(r9)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821CD898: D169000C  stfs f11, 0xc(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821CD89C: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 821CD8A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821CD8A4: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 821CD8A8: 4198FFA4  blt cr6, 0x821cd84c
	if ctx.cr[6].lt {
	pc = 0x821CD84C; continue 'dispatch;
	}
	// 821CD8AC: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821CD8B0: 2F070040  cmpwi cr6, r7, 0x40
	ctx.cr[6].compare_i32(ctx.r[7].s32, 64, &mut ctx.xer);
	// 821CD8B4: 4198FF7C  blt cr6, 0x821cd830
	if ctx.cr[6].lt {
	pc = 0x821CD830; continue 'dispatch;
	}
	// 821CD8B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CD8BC: 996605A0  stb r11, 0x5a0(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(1440 as u32), ctx.r[11].u8 ) };
	// 821CD8C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CD8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CD8C8 size=264
    let mut pc: u32 = 0x821CD8C8;
    'dispatch: loop {
        match pc {
            0x821CD8C8 => {
    //   block [0x821CD8C8..0x821CD9D0)
	// 821CD8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CD8CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821CD8D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821CD8D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CD8D8: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821CD8DC: 897F70E2  lbz r11, 0x70e2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28898 as u32) ) } as u64;
	// 821CD8E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD8E4: 409A00D8  bne cr6, 0x821cd9bc
	if !ctx.cr[6].eq {
	pc = 0x821CD9BC; continue 'dispatch;
	}
	// 821CD8E8: 38602310  li r3, 0x2310
	ctx.r[3].s64 = 8976;
	// 821CD8EC: 48ADCB9D  bl 0x82caa488
	ctx.lr = 0x821CD8F0;
	sub_82CAA488(ctx, base);
	// 821CD8F0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821CD8F4: 3943000F  addi r10, r3, 0xf
	ctx.r[10].s64 = ctx.r[3].s64 + 15;
	// 821CD8F8: 38EB0518  addi r7, r11, 0x518
	ctx.r[7].s64 = ctx.r[11].s64 + 1304;
	// 821CD8FC: 554B0036  rlwinm r11, r10, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821CD900: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821CD904: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 821CD908: 38CAB7A4  addi r6, r10, -0x485c
	ctx.r[6].s64 = ctx.r[10].s64 + -18524;
	// 821CD90C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821CD910: C00AB7A4  lfs f0, -0x485c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18524 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CD914: C186DCEC  lfs f12, -0x2314(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-8980 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821CD918: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821CD91C: 419A0084  beq cr6, 0x821cd9a0
	if ctx.cr[6].eq {
	pc = 0x821CD9A0; continue 'dispatch;
	}
	// 821CD920: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821CD924: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821CD928: 41980078  blt cr6, 0x821cd9a0
	if ctx.cr[6].lt {
	pc = 0x821CD9A0; continue 'dispatch;
	}
	// 821CD92C: 7D2607B4  extsw r6, r9
	ctx.r[6].s64 = ctx.r[9].s32 as i64;
	// 821CD930: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 821CD934: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821CD938: FD606E9C  fcfid f11, f13
	ctx.f[11].f64 = (ctx.f[13].s64 as f64);
	// 821CD93C: FDA05818  frsp f13, f11
	ctx.f[13].f64 = (ctx.f[11].f64 as f32) as f64;
	// 821CD940: 7D4607B4  extsw r6, r10
	ctx.r[6].s64 = ctx.r[10].s32 as i64;
	// 821CD944: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821CD948: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 821CD94C: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821CD950: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 821CD954: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821CD958: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 821CD95C: ED096824  fdivs f8, f9, f13
	ctx.f[8].f64 = ((ctx.f[9].f64 / ctx.f[13].f64) as f32) as f64;
	// 821CD960: ECEC4028  fsubs f7, f12, f8
	ctx.f[7].f64 = (((ctx.f[12].f64 - ctx.f[8].f64) as f32) as f64);
	// 821CD964: ECC80232  fmuls f6, f8, f8
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[8].f64) as f32) as f64);
	// 821CD968: ECA701F2  fmuls f5, f7, f7
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[7].f64) as f32) as f64);
	// 821CD96C: EC870232  fmuls f4, f7, f8
	ctx.f[4].f64 = (((ctx.f[7].f64 * ctx.f[8].f64) as f32) as f64);
	// 821CD970: EC660232  fmuls f3, f6, f8
	ctx.f[3].f64 = (((ctx.f[6].f64 * ctx.f[8].f64) as f32) as f64);
	// 821CD974: D06B000C  stfs f3, 0xc(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821CD978: EC450232  fmuls f2, f5, f8
	ctx.f[2].f64 = (((ctx.f[5].f64 * ctx.f[8].f64) as f32) as f64);
	// 821CD97C: EC240232  fmuls f1, f4, f8
	ctx.f[1].f64 = (((ctx.f[4].f64 * ctx.f[8].f64) as f32) as f64);
	// 821CD980: ED6501F2  fmuls f11, f5, f7
	ctx.f[11].f64 = (((ctx.f[5].f64 * ctx.f[7].f64) as f32) as f64);
	// 821CD984: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821CD988: ED420032  fmuls f10, f2, f0
	ctx.f[10].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 821CD98C: D14B0004  stfs f10, 4(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821CD990: ED210032  fmuls f9, f1, f0
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 821CD994: D12B0008  stfs f9, 8(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821CD998: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821CD99C: 4099FFA4  ble cr6, 0x821cd940
	if !ctx.cr[6].gt {
	pc = 0x821CD940; continue 'dispatch;
	}
	// 821CD9A0: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 821CD9A4: 39470080  addi r10, r7, 0x80
	ctx.r[10].s64 = ctx.r[7].s64 + 128;
	// 821CD9A8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821CD9AC: 7F085000  cmpw cr6, r8, r10
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821CD9B0: 4099FF68  ble cr6, 0x821cd918
	if !ctx.cr[6].gt {
	pc = 0x821CD918; continue 'dispatch;
	}
	// 821CD9B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CD9B8: 997F70E2  stb r11, 0x70e2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28898 as u32), ctx.r[11].u8 ) };
	// 821CD9BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821CD9C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CD9C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CD9C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821CD9CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CD9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CD9D0 size=160
    let mut pc: u32 = 0x821CD9D0;
    'dispatch: loop {
        match pc {
            0x821CD9D0 => {
    //   block [0x821CD9D0..0x821CDA70)
	// 821CD9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CD9D4: 48ADBA35  bl 0x82ca9408
	ctx.lr = 0x821CD9D8;
	sub_82CA93D0(ctx, base);
	// 821CD9D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CD9DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821CD9E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821CD9E4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821CD9E8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD9EC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD9F0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD9F4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CD9F8: 419A006C  beq cr6, 0x821cda64
	if ctx.cr[6].eq {
	pc = 0x821CDA64; continue 'dispatch;
	}
	// 821CD9FC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CDA00: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDA04: 409A0008  bne cr6, 0x821cda0c
	if !ctx.cr[6].eq {
	pc = 0x821CDA0C; continue 'dispatch;
	}
	// 821CDA08: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CDA0C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDA10: 89640038  lbz r11, 0x38(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 821CDA14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CDA18: 409A0028  bne cr6, 0x821cda40
	if !ctx.cr[6].eq {
	pc = 0x821CDA40; continue 'dispatch;
	}
	// 821CDA1C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDA20: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821CDA24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821CDA28: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CDA2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CDA30: 4E800421  bctrl
	ctx.lr = 0x821CDA34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CDA34: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CDA38: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CDA3C: 409A001C  bne cr6, 0x821cda58
	if !ctx.cr[6].eq {
	pc = 0x821CDA58; continue 'dispatch;
	}
	// 821CDA40: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDA44: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDA48: 409A0008  bne cr6, 0x821cda50
	if !ctx.cr[6].eq {
	pc = 0x821CDA50; continue 'dispatch;
	}
	// 821CDA4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CDA50: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDA54: 4BFFFF9C  b 0x821cd9f0
	pc = 0x821CD9F0; continue 'dispatch;
	// 821CDA58: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821CDA5C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821CDA60: 48ADB9F8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821CDA64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821CDA68: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821CDA6C: 48ADB9EC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CDA70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CDA70 size=1392
    let mut pc: u32 = 0x821CDA70;
    'dispatch: loop {
        match pc {
            0x821CDA70 => {
    //   block [0x821CDA70..0x821CDFE0)
	// 821CDA70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CDA74: 48ADB965  bl 0x82ca93d8
	ctx.lr = 0x821CDA78;
	sub_82CA93D0(ctx, base);
	// 821CDA78: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 821CDA7C: 48AE0255  bl 0x82cadcd0
	ctx.lr = 0x821CDA80;
	sub_82CADCA0(ctx, base);
	// 821CDA80: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CDA84: 7C701B78  mr r16, r3
	ctx.r[16].u64 = ctx.r[3].u64;
	// 821CDA88: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 821CDA8C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821CDA90: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 821CDA94: 7CD13378  mr r17, r6
	ctx.r[17].u64 = ctx.r[6].u64;
	// 821CDA98: 480517C1  bl 0x8221f258
	ctx.lr = 0x821CDA9C;
	sub_8221F258(ctx, base);
	// 821CDA9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CDAA0: 419A0008  beq cr6, 0x821cdaa8
	if ctx.cr[6].eq {
	pc = 0x821CDAA8; continue 'dispatch;
	}
	// 821CDAA4: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821CDAA8: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CDAAC: 41820008  beq 0x821cdab4
	if ctx.cr[0].eq {
	pc = 0x821CDAB4; continue 'dispatch;
	}
	// 821CDAB0: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821CDAB4: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDAB8: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 821CDABC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDAC0: 3B800048  li r28, 0x48
	ctx.r[28].s64 = 72;
	// 821CDAC4: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 821CDAC8: 7EBFAB78  mr r31, r21
	ctx.r[31].u64 = ctx.r[21].u64;
	// 821CDACC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821CDAD0: 92A10088  stw r21, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[21].u32 ) };
	// 821CDAD4: 7D09E3D7  divw. r8, r9, r28
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[28].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821CDAD8: 41820050  beq 0x821cdb28
	if ctx.cr[0].eq {
	pc = 0x821CDB28; continue 'dispatch;
	}
	// 821CDADC: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 821CDAE0: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 821CDAE4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821CDAE8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821CDAEC: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDAF0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821CDAF4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821CDAF8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821CDAFC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821CDB00: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821CDB04: 488C9865  bl 0x82a97368
	ctx.lr = 0x821CDB08;
	sub_82A97368(ctx, base);
	// 821CDB08: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDB0C: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDB10: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821CDB14: 3BDE0048  addi r30, r30, 0x48
	ctx.r[30].s64 = ctx.r[30].s64 + 72;
	// 821CDB18: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 821CDB1C: 7CE8E3D6  divw r7, r8, r28
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[28].s32;
	// 821CDB20: 7F1F3840  cmplw cr6, r31, r7
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821CDB24: 4198FFC4  blt cr6, 0x821cdae8
	if ctx.cr[6].lt {
	pc = 0x821CDAE8; continue 'dispatch;
	}
	// 821CDB28: 81500008  lwz r10, 8(r16)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDB2C: 3A400028  li r18, 0x28
	ctx.r[18].s64 = 40;
	// 821CDB30: 81700004  lwz r11, 4(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDB34: 7EB3AB78  mr r19, r21
	ctx.r[19].u64 = ctx.r[21].u64;
	// 821CDB38: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821CDB3C: 7D0993D7  divw. r8, r9, r18
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[18].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821CDB40: 4182044C  beq 0x821cdf8c
	if ctx.cr[0].eq {
	pc = 0x821CDF8C; continue 'dispatch;
	}
	// 821CDB44: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821CDB48: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821CDB4C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 821CDB50: 7EB4AB78  mr r20, r21
	ctx.r[20].u64 = ctx.r[21].u64;
	// 821CDB54: C38A9484  lfs f28, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821CDB58: CB490D38  lfd f26, 0xd38(r9)
	ctx.f[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(3384 as u32) ) };
	// 821CDB5C: CB680CB0  lfd f27, 0xcb0(r8)
	ctx.f[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(3248 as u32) ) };
	// 821CDB60: 7EEBA214  add r23, r11, r20
	ctx.r[23].u64 = ctx.r[11].u64 + ctx.r[20].u64;
	// 821CDB64: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 821CDB68: 3B370004  addi r25, r23, 4
	ctx.r[25].s64 = ctx.r[23].s64 + 4;
	// 821CDB6C: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 821CDB70: 8177000C  lwz r11, 0xc(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CDB74: 81570008  lwz r10, 8(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDB78: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821CDB7C: 7D281E71  srawi. r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821CDB80: 41820050  beq 0x821cdbd0
	if ctx.cr[0].eq {
	pc = 0x821CDBD0; continue 'dispatch;
	}
	// 821CDB84: 7EBFAB78  mr r31, r21
	ctx.r[31].u64 = ctx.r[21].u64;
	// 821CDB88: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDB8C: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 821CDB90: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 821CDB94: 7C7F582E  lwzx r3, r31, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821CDB98: 4BFFFE39  bl 0x821cd9d0
	ctx.lr = 0x821CDB9C;
	sub_821CD9D0(ctx, base);
	// 821CDB9C: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CDBA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CDBA4: 419A0028  beq cr6, 0x821cdbcc
	if ctx.cr[6].eq {
	pc = 0x821CDBCC; continue 'dispatch;
	}
	// 821CDBA8: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDBAC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821CDBB0: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDBB4: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 821CDBB8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821CDBBC: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 821CDBC0: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CDBC4: 4198FFC4  blt cr6, 0x821cdb88
	if ctx.cr[6].lt {
	pc = 0x821CDB88; continue 'dispatch;
	}
	// 821CDBC8: 48000008  b 0x821cdbd0
	pc = 0x821CDBD0; continue 'dispatch;
	// 821CDBCC: 7EBDAB78  mr r29, r21
	ctx.r[29].u64 = ctx.r[21].u64;
	// 821CDBD0: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 821CDBD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CDBD8: 419A0394  beq cr6, 0x821cdf6c
	if ctx.cr[6].eq {
	pc = 0x821CDF6C; continue 'dispatch;
	}
	// 821CDBDC: 8177001C  lwz r11, 0x1c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CDBE0: 3B170014  addi r24, r23, 0x14
	ctx.r[24].s64 = ctx.r[23].s64 + 20;
	// 821CDBE4: 81570018  lwz r10, 0x18(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CDBE8: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 821CDBEC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821CDBF0: 7D281E71  srawi. r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821CDBF4: 41820050  beq 0x821cdc44
	if ctx.cr[0].eq {
	pc = 0x821CDC44; continue 'dispatch;
	}
	// 821CDBF8: 7EBFAB78  mr r31, r21
	ctx.r[31].u64 = ctx.r[21].u64;
	// 821CDBFC: 81770018  lwz r11, 0x18(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CDC00: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 821CDC04: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 821CDC08: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821CDC0C: 4BFFFDC5  bl 0x821cd9d0
	ctx.lr = 0x821CDC10;
	sub_821CD9D0(ctx, base);
	// 821CDC10: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CDC14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CDC18: 419A0028  beq cr6, 0x821cdc40
	if ctx.cr[6].eq {
	pc = 0x821CDC40; continue 'dispatch;
	}
	// 821CDC1C: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDC20: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821CDC24: 81580004  lwz r10, 4(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDC28: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 821CDC2C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821CDC30: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 821CDC34: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CDC38: 4198FFC4  blt cr6, 0x821cdbfc
	if ctx.cr[6].lt {
	pc = 0x821CDBFC; continue 'dispatch;
	}
	// 821CDC3C: 48000008  b 0x821cdc44
	pc = 0x821CDC44; continue 'dispatch;
	// 821CDC40: 7EBDAB78  mr r29, r21
	ctx.r[29].u64 = ctx.r[21].u64;
	// 821CDC44: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 821CDC48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CDC4C: 419A0320  beq cr6, 0x821cdf6c
	if ctx.cr[6].eq {
	pc = 0x821CDF6C; continue 'dispatch;
	}
	// 821CDC50: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 821CDC54: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDC58: FFC0E090  fmr f30, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[28].f64;
	// 821CDC5C: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821CDC60: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 821CDC64: FFA0E090  fmr f29, f28
	ctx.f[29].f64 = ctx.f[28].f64;
	// 821CDC68: D3A10054  stfs f29, 0x54(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821CDC6C: FFE0D890  fmr f31, f27
	ctx.f[31].f64 = ctx.f[27].f64;
	// 821CDC70: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDC74: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 821CDC78: E9010060  ld r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821CDC7C: F9010068  std r8, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 821CDC80: 83410068  lwz r26, 0x68(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 821CDC84: 8361006C  lwz r27, 0x6c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821CDC88: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821CDC8C: 419A0010  beq cr6, 0x821cdc9c
	if ctx.cr[6].eq {
	pc = 0x821CDC9C; continue 'dispatch;
	}
	// 821CDC90: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 821CDC94: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDC98: 419A0008  beq cr6, 0x821cdca0
	if ctx.cr[6].eq {
	pc = 0x821CDCA0; continue 'dispatch;
	}
	// 821CDC9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CDCA0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDCA4: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDCA8: 419A014C  beq cr6, 0x821cddf4
	if ctx.cr[6].eq {
	pc = 0x821CDDF4; continue 'dispatch;
	}
	// 821CDCAC: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821CDCB0: 409A0008  bne cr6, 0x821cdcb8
	if !ctx.cr[6].eq {
	pc = 0x821CDCB8; continue 'dispatch;
	}
	// 821CDCB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CDCB8: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDCBC: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDCC0: 409A0008  bne cr6, 0x821cdcc8
	if !ctx.cr[6].eq {
	pc = 0x821CDCC8; continue 'dispatch;
	}
	// 821CDCC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CDCC8: 83DB0008  lwz r30, 8(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDCCC: FF1FD000  fcmpu cr6, f31, f26
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[26].f64);
	// 821CDCD0: 40990054  ble cr6, 0x821cdd24
	if !ctx.cr[6].gt {
	pc = 0x821CDD24; continue 'dispatch;
	}
	// 821CDCD4: C81E0040  lfd f0, 0x40(r30)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) };
	// 821CDCD8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821CDCDC: 40990048  ble cr6, 0x821cdd24
	if !ctx.cr[6].gt {
	pc = 0x821CDD24; continue 'dispatch;
	}
	// 821CDCE0: 89770025  lbz r11, 0x25(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(37 as u32) ) } as u64;
	// 821CDCE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CDCE8: 409A010C  bne cr6, 0x821cddf4
	if !ctx.cr[6].eq {
	pc = 0x821CDDF4; continue 'dispatch;
	}
	// 821CDCEC: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDCF0: DBE100A0  stfd f31, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.f[31].u64 ) };
	// 821CDCF4: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821CDCF8: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 821CDCFC: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821CDD00: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 821CDD04: F9410094  std r10, 0x94(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u64 ) };
	// 821CDD08: 486B5C21  bl 0x82883928
	ctx.lr = 0x821CDD0C;
	sub_82883928(ctx, base);
	// 821CDD0C: D3810070  stfs f28, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821CDD10: D3810074  stfs f28, 0x74(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821CDD14: E9210070  ld r9, 0x70(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 821CDD18: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821CDD1C: C3A10054  lfs f29, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821CDD20: C3C10050  lfs f30, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821CDD24: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDD28: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 821CDD2C: 81580004  lwz r10, 4(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDD30: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821CDD34: 7D281E71  srawi. r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821CDD38: 418200A4  beq 0x821cdddc
	if ctx.cr[0].eq {
	pc = 0x821CDDDC; continue 'dispatch;
	}
	// 821CDD3C: 7EBDAB78  mr r29, r21
	ctx.r[29].u64 = ctx.r[21].u64;
	// 821CDD40: 81770018  lwz r11, 0x18(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CDD44: 895E0038  lbz r10, 0x38(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 821CDD48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CDD4C: 7FEBE82E  lwzx r31, r11, r29
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 821CDD50: 409A006C  bne cr6, 0x821cddbc
	if !ctx.cr[6].eq {
	pc = 0x821CDDBC; continue 'dispatch;
	}
	// 821CDD54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDD58: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 821CDD5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821CDD60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CDD64: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CDD68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CDD6C: 4E800421  bctrl
	ctx.lr = 0x821CDD70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CDD70: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CDD74: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CDD78: 419A0044  beq cr6, 0x821cddbc
	if ctx.cr[6].eq {
	pc = 0x821CDDBC; continue 'dispatch;
	}
	// 821CDD7C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDD80: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821CDD84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CDD88: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821CDD8C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CDD90: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CDD94: 4E800421  bctrl
	ctx.lr = 0x821CDD98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CDD98: E9230000  ld r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821CDD9C: CBFE0040  lfd f31, 0x40(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) };
	// 821CDDA0: F9210068  std r9, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 821CDDA4: C1A1006C  lfs f13, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821CDDA8: EFBD682A  fadds f29, f29, f13
	ctx.f[29].f64 = ((ctx.f[29].f64 + ctx.f[13].f64) as f32) as f64;
	// 821CDDAC: D3A10054  stfs f29, 0x54(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821CDDB0: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CDDB4: EFC0F02A  fadds f30, f0, f30
	ctx.f[30].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 821CDDB8: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821CDDBC: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDDC0: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 821CDDC4: 81580004  lwz r10, 4(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDDC8: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 821CDDCC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821CDDD0: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 821CDDD4: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CDDD8: 4198FF68  blt cr6, 0x821cdd40
	if ctx.cr[6].lt {
	pc = 0x821CDD40; continue 'dispatch;
	}
	// 821CDDDC: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDDE0: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDDE4: 409A0008  bne cr6, 0x821cddec
	if !ctx.cr[6].eq {
	pc = 0x821CDDEC; continue 'dispatch;
	}
	// 821CDDE8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CDDEC: 837B0000  lwz r27, 0(r27)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDDF0: 4BFFFE98  b 0x821cdc88
	pc = 0x821CDC88; continue 'dispatch;
	// 821CDDF4: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDDF8: DBE100C0  stfd f31, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.f[31].u64 ) };
	// 821CDDFC: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821CDE00: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 821CDE04: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821CDE08: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 821CDE0C: F94100B4  std r10, 0xb4(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[10].u64 ) };
	// 821CDE10: 486B5B19  bl 0x82883928
	ctx.lr = 0x821CDE14;
	sub_82883928(ctx, base);
	// 821CDE14: 81390008  lwz r9, 8(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDE18: 81190004  lwz r8, 4(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDE1C: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821CDE20: 54E60038  rlwinm r6, r7, 0, 0, 0x1c
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821CDE24: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821CDE28: 419A0144  beq cr6, 0x821cdf6c
	if ctx.cr[6].eq {
	pc = 0x821CDF6C; continue 'dispatch;
	}
	// 821CDE2C: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDE30: 7EBBAB78  mr r27, r21
	ctx.r[27].u64 = ctx.r[21].u64;
	// 821CDE34: 81580004  lwz r10, 4(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDE38: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821CDE3C: 7D281E71  srawi. r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821CDE40: 4182012C  beq 0x821cdf6c
	if ctx.cr[0].eq {
	pc = 0x821CDF6C; continue 'dispatch;
	}
	// 821CDE44: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 821CDE48: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDE4C: 3BC10080  addi r30, r1, 0x80
	ctx.r[30].s64 = ctx.r[1].s64 + 128;
	// 821CDE50: 81570018  lwz r10, 0x18(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CDE54: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 821CDE58: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDE5C: 7FAAE02E  lwzx r29, r10, r28
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 821CDE60: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821CDE64: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821CDE68: 419A0010  beq cr6, 0x821cde78
	if ctx.cr[6].eq {
	pc = 0x821CDE78; continue 'dispatch;
	}
	// 821CDE6C: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 821CDE70: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDE74: 419A0008  beq cr6, 0x821cde7c
	if ctx.cr[6].eq {
	pc = 0x821CDE7C; continue 'dispatch;
	}
	// 821CDE78: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CDE7C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDE80: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDE84: 419A00C8  beq cr6, 0x821cdf4c
	if ctx.cr[6].eq {
	pc = 0x821CDF4C; continue 'dispatch;
	}
	// 821CDE88: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821CDE8C: 409A0008  bne cr6, 0x821cde94
	if !ctx.cr[6].eq {
	pc = 0x821CDE94; continue 'dispatch;
	}
	// 821CDE90: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CDE94: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDE98: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDE9C: 409A0008  bne cr6, 0x821cdea4
	if !ctx.cr[6].eq {
	pc = 0x821CDEA4; continue 'dispatch;
	}
	// 821CDEA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CDEA4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDEA8: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 821CDEAC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDEB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821CDEB4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CDEB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CDEBC: 4E800421  bctrl
	ctx.lr = 0x821CDEC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CDEC0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CDEC4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CDEC8: 419A006C  beq cr6, 0x821cdf34
	if ctx.cr[6].eq {
	pc = 0x821CDF34; continue 'dispatch;
	}
	// 821CDECC: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821CDED0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDED4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CDED8: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821CDEDC: 409A0008  bne cr6, 0x821cdee4
	if !ctx.cr[6].eq {
	pc = 0x821CDEE4; continue 'dispatch;
	}
	// 821CDEE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CDEE4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDEE8: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDEEC: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CDEF0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 821CDEF4: 419A002C  beq cr6, 0x821cdf20
	if ctx.cr[6].eq {
	pc = 0x821CDF20; continue 'dispatch;
	}
	// 821CDEF8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDEFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CDF00: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821CDF04: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDF08: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDF0C: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821CDF10: 4804DE29  bl 0x8221bd38
	ctx.lr = 0x821CDF14;
	sub_8221BD38(ctx, base);
	// 821CDF14: 80E10088  lwz r7, 0x88(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 821CDF18: 38C7FFFF  addi r6, r7, -1
	ctx.r[6].s64 = ctx.r[7].s64 + -1;
	// 821CDF1C: 90C10088  stw r6, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[6].u32 ) };
	// 821CDF20: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821CDF24: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821CDF28: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821CDF2C: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821CDF30: 4BFFFF34  b 0x821cde64
	pc = 0x821CDE64; continue 'dispatch;
	// 821CDF34: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDF38: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDF3C: 409A0008  bne cr6, 0x821cdf44
	if !ctx.cr[6].eq {
	pc = 0x821CDF44; continue 'dispatch;
	}
	// 821CDF40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CDF44: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDF48: 4BFFFF18  b 0x821cde60
	pc = 0x821CDE60; continue 'dispatch;
	// 821CDF4C: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDF50: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 821CDF54: 81580004  lwz r10, 4(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDF58: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 821CDF5C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821CDF60: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 821CDF64: 7F1B4040  cmplw cr6, r27, r8
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CDF68: 4198FEE0  blt cr6, 0x821cde48
	if ctx.cr[6].lt {
	pc = 0x821CDE48; continue 'dispatch;
	}
	// 821CDF6C: 81700004  lwz r11, 4(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDF70: 3A730001  addi r19, r19, 1
	ctx.r[19].s64 = ctx.r[19].s64 + 1;
	// 821CDF74: 81500008  lwz r10, 8(r16)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDF78: 3A940028  addi r20, r20, 0x28
	ctx.r[20].s64 = ctx.r[20].s64 + 40;
	// 821CDF7C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821CDF80: 7D0993D6  divw r8, r9, r18
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[18].s32;
	// 821CDF84: 7F134040  cmplw cr6, r19, r8
	ctx.cr[6].compare_u32(ctx.r[19].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CDF88: 4198FBD8  blt cr6, 0x821cdb60
	if ctx.cr[6].lt {
	pc = 0x821CDB60; continue 'dispatch;
	}
	// 821CDF8C: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDF90: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDF94: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821CDF98: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDF9C: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821CDFA0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDFA4: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821CDFA8: 92A10088  stw r21, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[21].u32 ) };
	// 821CDFAC: 419A0020  beq cr6, 0x821cdfcc
	if ctx.cr[6].eq {
	pc = 0x821CDFCC; continue 'dispatch;
	}
	// 821CDFB0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821CDFB4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDFB8: 4804DD81  bl 0x8221bd38
	ctx.lr = 0x821CDFBC;
	sub_8221BD38(ctx, base);
	// 821CDFBC: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDFC0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821CDFC4: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821CDFC8: 409AFFE8  bne cr6, 0x821cdfb0
	if !ctx.cr[6].eq {
	pc = 0x821CDFB0; continue 'dispatch;
	}
	// 821CDFCC: 4804DD6D  bl 0x8221bd38
	ctx.lr = 0x821CDFD0;
	sub_8221BD38(ctx, base);
	// 821CDFD0: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 821CDFD4: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 821CDFD8: 48ADFD45  bl 0x82cadd1c
	ctx.lr = 0x821CDFDC;
	sub_82CADCEC(ctx, base);
	// 821CDFDC: 48ADB44C  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CDFE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821CDFE0 size=212
    let mut pc: u32 = 0x821CDFE0;
    'dispatch: loop {
        match pc {
            0x821CDFE0 => {
    //   block [0x821CDFE0..0x821CE0B4)
	// 821CDFE0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CDFE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821CDFE8: 392B6A70  addi r9, r11, 0x6a70
	ctx.r[9].s64 = ctx.r[11].s64 + 27248;
	// 821CDFEC: 390A1BEC  addi r8, r10, 0x1bec
	ctx.r[8].s64 = ctx.r[10].s64 + 7148;
	// 821CDFF0: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821CDFF4: 80E40004  lwz r7, 4(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDFF8: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821CDFFC: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821CE000: 80C40008  lwz r6, 8(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CE004: 90C30008  stw r6, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 821CE008: 80A4000C  lwz r5, 0xc(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CE00C: 90A3000C  stw r5, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 821CE010: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CE014: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821CE018: 81440014  lwz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CE01C: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 821CE020: 81240018  lwz r9, 0x18(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CE024: 91230018  stw r9, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 821CE028: 8104001C  lwz r8, 0x1c(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CE02C: 9103001C  stw r8, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 821CE030: C0040020  lfs f0, 0x20(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CE034: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821CE038: C1A40024  lfs f13, 0x24(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821CE03C: D1A30024  stfs f13, 0x24(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821CE040: C1840028  lfs f12, 0x28(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821CE044: D1830028  stfs f12, 0x28(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821CE048: C164002C  lfs f11, 0x2c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821CE04C: D163002C  stfs f11, 0x2c(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821CE050: C1440030  lfs f10, 0x30(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821CE054: D1430030  stfs f10, 0x30(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821CE058: C1240034  lfs f9, 0x34(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821CE05C: D1230034  stfs f9, 0x34(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821CE060: C1040038  lfs f8, 0x38(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821CE064: D1030038  stfs f8, 0x38(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821CE068: C0E4003C  lfs f7, 0x3c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821CE06C: D0E3003C  stfs f7, 0x3c(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821CE070: C0C40040  lfs f6, 0x40(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821CE074: D0C30040  stfs f6, 0x40(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 821CE078: C0A40044  lfs f5, 0x44(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(68 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821CE07C: D0A30044  stfs f5, 0x44(r3)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 821CE080: C0840048  lfs f4, 0x48(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 821CE084: D0830048  stfs f4, 0x48(r3)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 821CE088: C064004C  lfs f3, 0x4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821CE08C: D063004C  stfs f3, 0x4c(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 821CE090: C0440050  lfs f2, 0x50(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(80 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821CE094: D0430050  stfs f2, 0x50(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821CE098: 88E40054  lbz r7, 0x54(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 821CE09C: 98E30054  stb r7, 0x54(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[7].u8 ) };
	// 821CE0A0: 88C40055  lbz r6, 0x55(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(85 as u32) ) } as u64;
	// 821CE0A4: 98C30055  stb r6, 0x55(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(85 as u32), ctx.r[6].u8 ) };
	// 821CE0A8: 80A40058  lwz r5, 0x58(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) } as u64;
	// 821CE0AC: 90A30058  stw r5, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 821CE0B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CE0B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CE0B8 size=132
    let mut pc: u32 = 0x821CE0B8;
    'dispatch: loop {
        match pc {
            0x821CE0B8 => {
    //   block [0x821CE0B8..0x821CE13C)
	// 821CE0B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CE0BC: 48ADB34D  bl 0x82ca9408
	ctx.lr = 0x821CE0C0;
	sub_82CA93D0(ctx, base);
	// 821CE0C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CE0C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821CE0C8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821CE0CC: 897E0040  lbz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 821CE0D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CE0D4: 419A0010  beq cr6, 0x821ce0e4
	if ctx.cr[6].eq {
	pc = 0x821CE0E4; continue 'dispatch;
	}
	// 821CE0D8: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 821CE0DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CE0E0: 419A0050  beq cr6, 0x821ce130
	if ctx.cr[6].eq {
	pc = 0x821CE130; continue 'dispatch;
	}
	// 821CE0E4: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 821CE0E8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 821CE0EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CE0F0: 419A0008  beq cr6, 0x821ce0f8
	if ctx.cr[6].eq {
	pc = 0x821CE0F8; continue 'dispatch;
	}
	// 821CE0F4: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 821CE0F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821CE0FC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821CE100: 41980028  blt cr6, 0x821ce128
	if ctx.cr[6].lt {
	pc = 0x821CE128; continue 'dispatch;
	}
	// 821CE104: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821CE108: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821CE10C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CE110: 48020461  bl 0x821ee570
	ctx.lr = 0x821CE114;
	sub_821EE570(ctx, base);
	// 821CE114: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CE118: 409A001C  bne cr6, 0x821ce134
	if !ctx.cr[6].eq {
	pc = 0x821CE134; continue 'dispatch;
	}
	// 821CE11C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821CE120: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 821CE124: 4099FFE0  ble cr6, 0x821ce104
	if !ctx.cr[6].gt {
	pc = 0x821CE104; continue 'dispatch;
	}
	// 821CE128: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CE12C: 997E0040  stb r11, 0x40(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
	// 821CE130: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821CE134: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821CE138: 48ADB320  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CE140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CE140 size=512
    let mut pc: u32 = 0x821CE140;
    'dispatch: loop {
        match pc {
            0x821CE140 => {
    //   block [0x821CE140..0x821CE340)
	// 821CE140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CE144: 48ADB2B5  bl 0x82ca93f8
	ctx.lr = 0x821CE148;
	sub_82CA93D0(ctx, base);
	// 821CE148: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CE14C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821CE150: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821CE154: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 821CE158: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 821CE15C: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 821CE160: 817E025C  lwz r11, 0x25c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(604 as u32) ) } as u64;
	// 821CE164: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821CE168: 40990008  ble cr6, 0x821ce170
	if !ctx.cr[6].gt {
	pc = 0x821CE170; continue 'dispatch;
	}
	// 821CE16C: 93BE025C  stw r29, 0x25c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(604 as u32), ctx.r[29].u32 ) };
	// 821CE170: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CE174: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821CE178: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	// 821CE17C: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 821CE180: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 821CE184: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CE188: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821CE18C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821CE190: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821CE194: 4883F765  bl 0x82a0d8f8
	ctx.lr = 0x821CE198;
	sub_82A0D8F8(ctx, base);
	// 821CE198: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821CE19C: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CE1A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CE1A4: 419A000C  beq cr6, 0x821ce1b0
	if ctx.cr[6].eq {
	pc = 0x821CE1B0; continue 'dispatch;
	}
	// 821CE1A8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821CE1AC: 419A0008  beq cr6, 0x821ce1b4
	if ctx.cr[6].eq {
	pc = 0x821CE1B4; continue 'dispatch;
	}
	// 821CE1B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CE1B4: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821CE1B8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CE1BC: 419A005C  beq cr6, 0x821ce218
	if ctx.cr[6].eq {
	pc = 0x821CE218; continue 'dispatch;
	}
	// 821CE1C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CE1C4: 409A0008  bne cr6, 0x821ce1cc
	if !ctx.cr[6].eq {
	pc = 0x821CE1CC; continue 'dispatch;
	}
	// 821CE1C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CE1CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CE1D0: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CE1D4: 409A0008  bne cr6, 0x821ce1dc
	if !ctx.cr[6].eq {
	pc = 0x821CE1DC; continue 'dispatch;
	}
	// 821CE1D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821CE1DC: 81690010  lwz r11, 0x10(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CE1E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CE1E4: 419A0034  beq cr6, 0x821ce218
	if ctx.cr[6].eq {
	pc = 0x821CE218; continue 'dispatch;
	}
	// 821CE1E8: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 821CE1EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CE1F0: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821CE1F4: 419A0024  beq cr6, 0x821ce218
	if ctx.cr[6].eq {
	pc = 0x821CE218; continue 'dispatch;
	}
	// 821CE1F8: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 821CE1FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821CE200: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CE204: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821CE208: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821CE20C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CE210: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CE214: 4082FFE8  bne 0x821ce1fc
	if !ctx.cr[0].eq {
	pc = 0x821CE1FC; continue 'dispatch;
	}
	// 821CE218: 38600044  li r3, 0x44
	ctx.r[3].s64 = 68;
	// 821CE21C: 4805103D  bl 0x8221f258
	ctx.lr = 0x821CE220;
	sub_8221F258(ctx, base);
	// 821CE220: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CE224: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821CE228: 419A0090  beq cr6, 0x821ce2b8
	if ctx.cr[6].eq {
	pc = 0x821CE2B8; continue 'dispatch;
	}
	// 821CE22C: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 821CE230: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 821CE234: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821CE238: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821CE23C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821CE240: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821CE244: 4BFE995D  bl 0x821b7ba0
	ctx.lr = 0x821CE248;
	sub_821B7BA0(ctx, base);
	// 821CE248: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821CE24C: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 821CE250: 394B0FBC  addi r10, r11, 0xfbc
	ctx.r[10].s64 = ctx.r[11].s64 + 4028;
	// 821CE254: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821CE258: 48051001  bl 0x8221f258
	ctx.lr = 0x821CE25C;
	sub_8221F258(ctx, base);
	// 821CE25C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CE260: 419A0008  beq cr6, 0x821ce268
	if ctx.cr[6].eq {
	pc = 0x821CE268; continue 'dispatch;
	}
	// 821CE264: 93830000  stw r28, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 821CE268: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CE26C: 41820008  beq 0x821ce274
	if ctx.cr[0].eq {
	pc = 0x821CE274; continue 'dispatch;
	}
	// 821CE270: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 821CE274: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CE278: 41820008  beq 0x821ce280
	if ctx.cr[0].eq {
	pc = 0x821CE280; continue 'dispatch;
	}
	// 821CE27C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 821CE280: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821CE284: 9B830015  stb r28, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[28].u8 ) };
	// 821CE288: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821CE28C: 99430014  stb r10, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 821CE290: 907F003C  stw r3, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[3].u32 ) };
	// 821CE294: 99430015  stb r10, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 821CE298: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 821CE29C: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821CE2A0: 813F003C  lwz r9, 0x3c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 821CE2A4: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821CE2A8: 811F003C  lwz r8, 0x3c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 821CE2AC: 91080008  stw r8, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821CE2B0: 939F0040  stw r28, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[28].u32 ) };
	// 821CE2B4: 48000008  b 0x821ce2bc
	pc = 0x821CE2BC; continue 'dispatch;
	// 821CE2B8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821CE2BC: 815E0078  lwz r10, 0x78(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) } as u64;
	// 821CE2C0: 387E0060  addi r3, r30, 0x60
	ctx.r[3].s64 = ctx.r[30].s64 + 96;
	// 821CE2C4: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821CE2C8: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821CE2CC: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 821CE2D0: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 821CE2D4: 913E0078  stw r9, 0x78(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 821CE2D8: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821CE2DC: 811E0064  lwz r8, 0x64(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 821CE2E0: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 821CE2E4: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821CE2E8: 480B9759  bl 0x82287a40
	ctx.lr = 0x821CE2EC;
	sub_82287A40(ctx, base);
	// 821CE2EC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821CE2F0: 419A0044  beq cr6, 0x821ce334
	if ctx.cr[6].eq {
	pc = 0x821CE334; continue 'dispatch;
	}
	// 821CE2F4: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 821CE2F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821CE2FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CE300: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821CE304: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821CE308: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CE30C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CE310: 4082FFE8  bne 0x821ce2f8
	if !ctx.cr[0].eq {
	pc = 0x821CE2F8; continue 'dispatch;
	}
	// 821CE314: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821CE318: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CE31C: 409A0018  bne cr6, 0x821ce334
	if !ctx.cr[6].eq {
	pc = 0x821CE334; continue 'dispatch;
	}
	// 821CE320: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CE324: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821CE328: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CE32C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CE330: 4E800421  bctrl
	ctx.lr = 0x821CE334;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CE334: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821CE338: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821CE33C: 48ADB10C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CE340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821CE340 size=8
    let mut pc: u32 = 0x821CE340;
    'dispatch: loop {
        match pc {
            0x821CE340 => {
    //   block [0x821CE340..0x821CE348)
	// 821CE340: 80640008  lwz r3, 8(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CE344: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CE348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CE348 size=1848
    let mut pc: u32 = 0x821CE348;
    'dispatch: loop {
        match pc {
            0x821CE348 => {
    //   block [0x821CE348..0x821CEA80)
	// 821CE348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CE34C: 48ADB0A5  bl 0x82ca93f0
	ctx.lr = 0x821CE350;
	sub_82CA93D0(ctx, base);
	// 821CE350: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 821CE354: 48ADF985  bl 0x82cadcd8
	ctx.lr = 0x821CE358;
	sub_82CADCA0(ctx, base);
	// 821CE358: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CE35C: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 821CE360: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 821CE364: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 821CE368: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CEA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CEA80 size=2820
    let mut pc: u32 = 0x821CEA80;
    'dispatch: loop {
        match pc {
            0x821CEA80 => {
    //   block [0x821CEA80..0x821CF584)
	// 821CEA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CEA84: 48ADA94D  bl 0x82ca93d0
	ctx.lr = 0x821CEA88;
	sub_82CA93D0(ctx, base);
	// 821CEA88: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821CEA8C: 48ADF231  bl 0x82cadcbc
	ctx.lr = 0x821CEA90;
	sub_82CADCA0(ctx, base);
	// 821CEA90: 9421FCB0  stwu r1, -0x350(r1)
	ea = ctx.r[1].u32.wrapping_add(-848 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CEA94: 7C6F1B78  mr r15, r3
	ctx.r[15].u64 = ctx.r[3].u64;
	// 821CEA98: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	// 821CEA9C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821CEAA0: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 821CEAA4: 7CAE2B78  mr r14, r5
	ctx.r[14].u64 = ctx.r[5].u64;
	// 821CEAA8: 91E10364  stw r15, 0x364(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(868 as u32), ctx.r[15].u32 ) };
	// 821CEAAC: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 821CEAB0: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 821CEAB4: 91C10374  stw r14, 0x374(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(884 as u32), ctx.r[14].u32 ) };
	// 821CEAB8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821CEABC: 816F001C  lwz r11, 0x1c(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CEAC0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 821CEAC4: 9341038C  stw r26, 0x38c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(908 as u32), ctx.r[26].u32 ) };
	// 821CEAC8: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 821CEACC: FF802090  fmr f28, f4
	ctx.f[28].f64 = ctx.f[4].f64;
	// 821CEAD0: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 821CEAD4: FFC02890  fmr f30, f5
	ctx.f[30].f64 = ctx.f[5].f64;
	// 821CEAD8: FF003090  fmr f24, f6
	ctx.f[24].f64 = ctx.f[6].f64;
	// 821CEADC: FEE03890  fmr f23, f7
	ctx.f[23].f64 = ctx.f[7].f64;
	// 821CEAE0: 419A0008  beq cr6, 0x821ceae8
	if ctx.cr[6].eq {
	pc = 0x821CEAE8; continue 'dispatch;
	}
	// 821CEAE4: 48106135  bl 0x822d4c18
	ctx.lr = 0x821CEAE8;
	sub_822D4C18(ctx, base);
	// 821CEAE8: 93CF001C  stw r30, 0x1c(r15)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[15].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 821CEAEC: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 821CEAF0: 409A07F8  bne cr6, 0x821cf2e8
	if !ctx.cr[6].eq {
	pc = 0x821CF2E8; continue 'dispatch;
	}
	// 821CEAF4: 822E0028  lwz r17, 0x28(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CEAF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821CEAFC: 816F0008  lwz r11, 8(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CEB00: 812F000C  lwz r9, 0xc(r15)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CEB04: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821CEB08: 906100A0  stw r3, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[3].u32 ) };
	// 821CEB0C: 39510008  addi r10, r17, 8
	ctx.r[10].s64 = ctx.r[17].s64 + 8;
	// 821CEB10: 93810104  stw r28, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[28].u32 ) };
	// 821CEB14: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821CEB18: 81110010  lwz r8, 0x10(r17)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CEB1C: 80F1000C  lwz r7, 0xc(r17)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CEB20: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 821CEB24: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 821CEB28: E8A100A0  ld r5, 0xa0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 821CEB2C: 90610108  stw r3, 0x108(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[3].u32 ) };
	// 821CEB30: 7CC42670  srawi r4, r6, 4
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[6].s32 >> 4) as i64;
	// 821CEB34: 9061010C  stw r3, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[3].u32 ) };
	// 821CEB38: F8A10090  std r5, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[5].u64 ) };
	// 821CEB3C: 908100C8  stw r4, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u32 ) };
	// 821CEB40: 419A0020  beq cr6, 0x821ceb60
	if ctx.cr[6].eq {
	pc = 0x821CEB60; continue 'dispatch;
	}
	// 821CEB44: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821CEB48: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CEB4C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821CEB50: 986A00A0  stb r3, 0xa0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(160 as u32), ctx.r[3].u8 ) };
	// 821CEB54: 812F000C  lwz r9, 0xc(r15)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CEB58: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821CEB5C: 409AFFEC  bne cr6, 0x821ceb48
	if !ctx.cr[6].eq {
	pc = 0x821CEB48; continue 'dispatch;
	}
	// 821CEB60: 7C701B78  mr r16, r3
	ctx.r[16].u64 = ctx.r[3].u64;
	// 821CEB64: 836103DC  lwz r27, 0x3dc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(988 as u32) ) } as u64;
	// 821CEB68: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 821CEB6C: 920100A8  stw r16, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[16].u32 ) };
	// 821CEB70: 409905F4  ble cr6, 0x821cf164
	if !ctx.cr[6].gt {
	pc = 0x821CF164; continue 'dispatch;
	}
	// 821CEB74: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821CEB78: 906100A0  stw r3, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[3].u32 ) };
	// 821CEB7C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821CEB80: 388792D8  addi r4, r7, -0x6d28
	ctx.r[4].s64 = ctx.r[7].s64 + -27944;
	// 821CEB84: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 821CEB88: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 821CEB8C: C34792D8  lfs f26, -0x6d28(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27944 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 821CEB90: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 821CEB94: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821CEB98: C3E401AC  lfs f31, 0x1ac(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(428 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821CEB9C: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821CEBA0: C32401B8  lfs f25, 0x1b8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(440 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 821CEBA4: 3CA0820F  lis r5, -0x7df1
	ctx.r[5].s64 = -2112946176;
	// 821CEBA8: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 821CEBAC: 3A400010  li r18, 0x10
	ctx.r[18].s64 = 16;
	// 821CEBB0: 3B2B6F14  addi r25, r11, 0x6f14
	ctx.r[25].s64 = ctx.r[11].s64 + 28436;
	// 821CEBB4: 3B0A6EF0  addi r24, r10, 0x6ef0
	ctx.r[24].s64 = ctx.r[10].s64 + 28400;
	// 821CEBB8: 3AE96EFC  addi r23, r9, 0x6efc
	ctx.r[23].s64 = ctx.r[9].s64 + 28412;
	// 821CEBBC: 3AC86EE4  addi r22, r8, 0x6ee4
	ctx.r[22].s64 = ctx.r[8].s64 + 28388;
	// 821CEBC0: 3AA79060  addi r21, r7, -0x6fa0
	ctx.r[21].s64 = ctx.r[7].s64 + -28576;
	// 821CEBC4: 3A869160  addi r20, r6, -0x6ea0
	ctx.r[20].s64 = ctx.r[6].s64 + -28320;
	// 821CEBC8: 3B8544B0  addi r28, r5, 0x44b0
	ctx.r[28].s64 = ctx.r[5].s64 + 17584;
	// 821CEBCC: 3A641148  addi r19, r4, 0x1148
	ctx.r[19].s64 = ctx.r[4].s64 + 4424;
	// 821CEBD0: 816E0014  lwz r11, 0x14(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CEBD4: 392E0004  addi r9, r14, 4
	ctx.r[9].s64 = ctx.r[14].s64 + 4;
	// 821CEBD8: 80CE0020  lwz r6, 0x20(r14)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(32 as u32) ) } as u64;
	// 821CEBDC: 38EF0004  addi r7, r15, 4
	ctx.r[7].s64 = ctx.r[15].s64 + 4;
	// 821CEBE0: 7CB05A14  add r5, r16, r11
	ctx.r[5].u64 = ctx.r[16].u64 + ctx.r[11].u64;
	// 821CEBE4: 810E0008  lwz r8, 8(r14)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CEBE8: 814F0008  lwz r10, 8(r15)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CEBEC: 7CAB3038  and r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 & ctx.r[6].u64;
	// 821CEBF0: 80CF000C  lwz r6, 0xc(r15)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CEBF4: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CEBF8: 7C8A3050  subf r4, r10, r6
	ctx.r[4].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821CEBFC: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821CEC00: 914100A4  stw r10, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[10].u32 ) };
	// 821CEC04: 7C8B1E71  srawi. r11, r4, 3
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[4].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CEC08: 55292834  slwi r9, r9, 5
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CEC0C: 7FA94214  add r29, r9, r8
	ctx.r[29].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821CEC10: 835D0020  lwz r26, 0x20(r29)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 821CEC14: 40810054  ble 0x821cec68
	if !ctx.cr[0].gt {
	pc = 0x821CEC68; continue 'dispatch;
	}
	// 821CEC18: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821CEC1C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821CEC20: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821CEC24: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CEC28: 7F07D000  cmpw cr6, r7, r26
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[26].s32, &mut ctx.xer);
	// 821CEC2C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821CEC30: 41980008  blt cr6, 0x821cec38
	if ctx.cr[6].lt {
	pc = 0x821CEC38; continue 'dispatch;
	}
	// 821CEC34: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821CEC38: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821CEC3C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CEC40: 419A0014  beq cr6, 0x821cec54
	if ctx.cr[6].eq {
	pc = 0x821CEC54; continue 'dispatch;
	}
	// 821CEC44: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821CEC48: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CEC4C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CEC50: 4800000C  b 0x821cec5c
	pc = 0x821CEC5C; continue 'dispatch;
	// 821CEC54: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821CEC58: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821CEC5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CEC60: 4199FFB8  bgt cr6, 0x821cec18
	if ctx.cr[6].gt {
	pc = 0x821CEC18; continue 'dispatch;
	}
	// 821CEC64: 914100A4  stw r10, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[10].u32 ) };
	// 821CEC68: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821CEC6C: 419A0034  beq cr6, 0x821ceca0
	if ctx.cr[6].eq {
	pc = 0x821CECA0; continue 'dispatch;
	}
	// 821CEC70: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CEC74: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821CEC78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CEC7C: 41980008  blt cr6, 0x821cec84
	if ctx.cr[6].lt {
	pc = 0x821CEC84; continue 'dispatch;
	}
	// 821CEC80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821CEC84: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CEC88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CEC8C: 409A0014  bne cr6, 0x821ceca0
	if !ctx.cr[6].eq {
	pc = 0x821CECA0; continue 'dispatch;
	}
	// 821CEC90: E96100A0  ld r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 821CEC94: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 821CEC98: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821CEC9C: 48000008  b 0x821ceca4
	pc = 0x821CECA4; continue 'dispatch;
	// 821CECA0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821CECA4: 814F000C  lwz r10, 0xc(r15)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CECA8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CECAC: 409A0108  bne cr6, 0x821cedb4
	if !ctx.cr[6].eq {
	pc = 0x821CEDB4; continue 'dispatch;
	}
	// 821CECB0: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 821CECB4: 40990018  ble cr6, 0x821ceccc
	if !ctx.cr[6].gt {
	pc = 0x821CECCC; continue 'dispatch;
	}
	// 821CECB8: FF1CF000  fcmpu cr6, f28, f30
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[30].f64);
	// 821CECBC: 41990010  bgt cr6, 0x821ceccc
	if ctx.cr[6].gt {
	pc = 0x821CECCC; continue 'dispatch;
	}
	// 821CECC0: EC1CF024  fdivs f0, f28, f30
	ctx.f[0].f64 = ((ctx.f[28].f64 / ctx.f[30].f64) as f32) as f64;
	// 821CECC4: EC190028  fsubs f0, f25, f0
	ctx.f[0].f64 = (((ctx.f[25].f64 - ctx.f[0].f64) as f32) as f64);
	// 821CECC8: 48000008  b 0x821cecd0
	pc = 0x821CECD0; continue 'dispatch;
	// 821CECCC: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 821CECD0: 816E0028  lwz r11, 0x28(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CECD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CECD8: 894B0028  lbz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CECDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CECE0: 419A0008  beq cr6, 0x821cece8
	if ctx.cr[6].eq {
	pc = 0x821CECE8; continue 'dispatch;
	}
	// 821CECE4: 3BE00800  li r31, 0x800
	ctx.r[31].s64 = 2048;
	// 821CECE8: 386000B0  li r3, 0xb0
	ctx.r[3].s64 = 176;
	// 821CECEC: D0010140  stfs f0, 0x140(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 821CECF0: D3C10144  stfs f30, 0x144(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 821CECF4: D3610148  stfs f27, 0x148(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 821CECF8: D3E1014C  stfs f31, 0x14c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 821CECFC: D3E10150  stfs f31, 0x150(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 821CED00: D3E10154  stfs f31, 0x154(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 821CED04: D3E10158  stfs f31, 0x158(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 821CED08: D3410164  stfs f26, 0x164(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 821CED0C: 480505B5  bl 0x8221f2c0
	ctx.lr = 0x821CED10;
	sub_8221F2C0(ctx, base);
	// 821CED10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CED14: 409A0084  bne cr6, 0x821ced98
	if !ctx.cr[6].eq {
	pc = 0x821CED98; continue 'dispatch;
	}
	// 821CED18: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821CED1C: 816A6F6C  lwz r11, 0x6f6c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28524 as u32) ) } as u64;
	// 821CED20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CED24: 419A0014  beq cr6, 0x821ced38
	if ctx.cr[6].eq {
	pc = 0x821CED38; continue 'dispatch;
	}
	// 821CED28: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CED2C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821CED30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821CED34: 4E800421  bctrl
	ctx.lr = 0x821CED38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CED38: 48AF3671  bl 0x82cc23a8
	ctx.lr = 0x821CED3C;
	sub_82CC23A8(ctx, base);
	// 821CED3C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821CED40: 83EF0020  lwz r31, 0x20(r15)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(32 as u32) ) } as u64;
	// 821CED44: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 821CED48: 419A0034  beq cr6, 0x821ced7c
	if ctx.cr[6].eq {
	pc = 0x821CED7C; continue 'dispatch;
	}
	// 821CED4C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CED50: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821CED54: 409A0028  bne cr6, 0x821ced7c
	if !ctx.cr[6].eq {
	pc = 0x821CED7C; continue 'dispatch;
	}
	// 821CED58: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CED5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CED60: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CED64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CED68: 4E800421  bctrl
	ctx.lr = 0x821CED6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CED6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CED70: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821CED74: 480CCC9D  bl 0x8229ba10
	ctx.lr = 0x821CED78;
	sub_8229BA10(ctx, base);
	// 821CED78: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821CED7C: 93410098  stw r26, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[26].u32 ) };
	// 821CED80: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 821CED84: 93C1009C  stw r30, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 821CED88: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 821CED8C: 486732D5  bl 0x82842060
	ctx.lr = 0x821CED90;
	sub_82842060(ctx, base);
	// 821CED90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821CED94: 48000024  b 0x821cedb8
	pc = 0x821CEDB8; continue 'dispatch;
	// 821CED98: 816E0028  lwz r11, 0x28(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CED9C: 38C10140  addi r6, r1, 0x140
	ctx.r[6].s64 = ctx.r[1].s64 + 320;
	// 821CEDA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CEDA4: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	// 821CEDA8: 48287FB1  bl 0x82456d58
	ctx.lr = 0x821CEDAC;
	sub_82456D58(ctx, base);
	// 821CEDAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821CEDB0: 4BFFFF90  b 0x821ced40
	pc = 0x821CED40; continue 'dispatch;
	// 821CEDB4: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CEDB8: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CEDBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CEDC0: 997E00A0  stb r11, 0xa0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(160 as u32), ctx.r[11].u8 ) };
	// 821CEDC4: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 821CEDC8: 419A0384  beq cr6, 0x821cf14c
	if ctx.cr[6].eq {
	pc = 0x821CF14C; continue 'dispatch;
	}
	// 821CEDCC: 39410250  addi r10, r1, 0x250
	ctx.r[10].s64 = ctx.r[1].s64 + 592;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CF588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821CF588 size=68
    let mut pc: u32 = 0x821CF588;
    'dispatch: loop {
        match pc {
            0x821CF588 => {
    //   block [0x821CF588..0x821CF5CC)
	// 821CF588: 89630007  lbz r11, 7(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(7 as u32) ) } as u64;
	// 821CF58C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821CF590: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CF594: 7D4B5830  slw r11, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 821CF598: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CF59C: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 821CF5A0: 7D0B4838  and r11, r8, r9
	ctx.r[11].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821CF5A4: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CF5A8: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821CF5AC: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CF5B0: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821CF5B4: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CF5B8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821CF5BC: 409A0010  bne cr6, 0x821cf5cc
	if !ctx.cr[6].eq {
		sub_821CF5CC(ctx, base);
		return;
	}
	// 821CF5C0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CF5C4: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821CF5C8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CF5CC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821CF5CC size=24
    let mut pc: u32 = 0x821CF5CC;
    'dispatch: loop {
        match pc {
            0x821CF5CC => {
    //   block [0x821CF5CC..0x821CF5E4)
	// 821CF5CC: 80630010  lwz r3, 0x10(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CF5D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CF5D4: 409AFFE0  bne cr6, 0x821cf5b4
	if !ctx.cr[6].eq {
		sub_821CF588(ctx, base);
		return;
	}
	// 821CF5D8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821CF5DC: 386B06F4  addi r3, r11, 0x6f4
	ctx.r[3].s64 = ctx.r[11].s64 + 1780;
	// 821CF5E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CF5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CF5E8 size=240
    let mut pc: u32 = 0x821CF5E8;
    'dispatch: loop {
        match pc {
            0x821CF5E8 => {
    //   block [0x821CF5E8..0x821CF6D8)
	// 821CF5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CF5EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821CF5F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821CF5F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CF5F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821CF5FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF600: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CF604: 419A00A0  beq cr6, 0x821cf6a4
	if ctx.cr[6].eq {
	pc = 0x821CF6A4; continue 'dispatch;
	}
	// 821CF608: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821CF60C: 419A0028  beq cr6, 0x821cf634
	if ctx.cr[6].eq {
	pc = 0x821CF634; continue 'dispatch;
	}
	// 821CF610: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821CF614: 409A0064  bne cr6, 0x821cf678
	if !ctx.cr[6].eq {
	pc = 0x821CF678; continue 'dispatch;
	}
	// 821CF618: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CF61C: 4BFFFF6D  bl 0x821cf588
	ctx.lr = 0x821CF620;
	sub_821CF588(ctx, base);
	// 821CF620: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821CF624: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CF628: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CF62C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821CF630: 4E800020  blr
	return;
	// 821CF634: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CF638: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821CF63C: D9A10050  stfd f13, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[13].u64 ) };
	// 821CF640: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821CF644: 7C8B07B4  extsw r11, r4
	ctx.r[11].s64 = ctx.r[4].s32 as i64;
	// 821CF648: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821CF64C: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821CF650: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 821CF654: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 821CF658: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 821CF65C: 409A001C  bne cr6, 0x821cf678
	if !ctx.cr[6].eq {
	pc = 0x821CF678; continue 'dispatch;
	}
	// 821CF660: 48012279  bl 0x821e18d8
	ctx.lr = 0x821CF664;
	sub_821E18D8(ctx, base);
	// 821CF664: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821CF668: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CF66C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CF670: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821CF674: 4E800020  blr
	return;
	// 821CF678: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CF67C: 48A00CCD  bl 0x82bd0348
	ctx.lr = 0x821CF680;
	sub_82BD0348(ctx, base);
	// 821CF680: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821CF684: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CF688: 38670008  addi r3, r7, 8
	ctx.r[3].s64 = ctx.r[7].s64 + 8;
	// 821CF68C: 48107F1D  bl 0x822d75a8
	ctx.lr = 0x821CF690;
	sub_822D75A8(ctx, base);
	// 821CF690: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821CF694: 409A002C  bne cr6, 0x821cf6c0
	if !ctx.cr[6].eq {
	pc = 0x821CF6C0; continue 'dispatch;
	}
	// 821CF698: 80E70010  lwz r7, 0x10(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CF69C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CF6A0: 409AFFE4  bne cr6, 0x821cf684
	if !ctx.cr[6].eq {
	pc = 0x821CF684; continue 'dispatch;
	}
	// 821CF6A4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821CF6A8: 386B06F4  addi r3, r11, 0x6f4
	ctx.r[3].s64 = ctx.r[11].s64 + 1780;
	// 821CF6AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821CF6B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CF6B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CF6B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821CF6BC: 4E800020  blr
	return;
	// 821CF6C0: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821CF6C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821CF6C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CF6CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CF6D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821CF6D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CF6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CF6D8 size=352
    let mut pc: u32 = 0x821CF6D8;
    'dispatch: loop {
        match pc {
            0x821CF6D8 => {
    //   block [0x821CF6D8..0x821CF838)
	// 821CF6D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CF6DC: 48AD9D19  bl 0x82ca93f4
	ctx.lr = 0x821CF6E0;
	sub_82CA93D0(ctx, base);
	// 821CF6E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CF6E4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 821CF6E8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821CF6EC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821CF6F0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821CF6F4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 821CF6F8: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 821CF6FC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821CF700: 3B0A06F4  addi r24, r10, 0x6f4
	ctx.r[24].s64 = ctx.r[10].s64 + 1780;
	// 821CF704: 3B2B3B80  addi r25, r11, 0x3b80
	ctx.r[25].s64 = ctx.r[11].s64 + 15232;
	// 821CF708: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF70C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821CF710: 409A0074  bne cr6, 0x821cf784
	if !ctx.cr[6].eq {
	pc = 0x821CF784; continue 'dispatch;
	}
	// 821CF714: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CF718: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821CF71C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CF720: 4BFFFEC9  bl 0x821cf5e8
	ctx.lr = 0x821CF724;
	sub_821CF5E8(ctx, base);
	// 821CF724: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821CF728: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF72C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CF730: 409A003C  bne cr6, 0x821cf76c
	if !ctx.cr[6].eq {
	pc = 0x821CF76C; continue 'dispatch;
	}
	// 821CF734: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CF738: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CF73C: 419A0030  beq cr6, 0x821cf76c
	if ctx.cr[6].eq {
	pc = 0x821CF76C; continue 'dispatch;
	}
	// 821CF740: 89630006  lbz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 821CF744: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821CF748: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CF74C: 409A0020  bne cr6, 0x821cf76c
	if !ctx.cr[6].eq {
	pc = 0x821CF76C; continue 'dispatch;
	}
	// 821CF750: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CF754: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821CF758: 80AB00A0  lwz r5, 0xa0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821CF75C: 48A046A5  bl 0x82bd3e00
	ctx.lr = 0x821CF760;
	sub_82BD3E00(ctx, base);
	// 821CF760: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CF764: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821CF768: 409A007C  bne cr6, 0x821cf7e4
	if !ctx.cr[6].eq {
	pc = 0x821CF7E4; continue 'dispatch;
	}
	// 821CF76C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CF770: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821CF774: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF778: 91570004  stw r10, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821CF77C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821CF780: 48AD9CC4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
	// 821CF784: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 821CF788: 419A0018  beq cr6, 0x821cf7a0
	if ctx.cr[6].eq {
	pc = 0x821CF7A0; continue 'dispatch;
	}
	// 821CF78C: 396B001F  addi r11, r11, 0x1f
	ctx.r[11].s64 = ctx.r[11].s64 + 31;
	// 821CF790: 815C0010  lwz r10, 0x10(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CF794: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CF798: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821CF79C: 4800000C  b 0x821cf7a8
	pc = 0x821CF7A8; continue 'dispatch;
	// 821CF7A0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CF7A4: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CF7A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CF7AC: 419A0018  beq cr6, 0x821cf7c4
	if ctx.cr[6].eq {
	pc = 0x821CF7C4; continue 'dispatch;
	}
	// 821CF7B0: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CF7B4: 808B00A0  lwz r4, 0xa0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821CF7B8: 4BFFFDD1  bl 0x821cf588
	ctx.lr = 0x821CF7BC;
	sub_821CF588(ctx, base);
	// 821CF7BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CF7C0: 48000008  b 0x821cf7c8
	pc = 0x821CF7C8; continue 'dispatch;
	// 821CF7C4: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 821CF7C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF7CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CF7D0: 409A0014  bne cr6, 0x821cf7e4
	if !ctx.cr[6].eq {
	pc = 0x821CF7E4; continue 'dispatch;
	}
	// 821CF7D4: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821CF7D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821CF7DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CF7E0: 48A00811  bl 0x82bcfff0
	ctx.lr = 0x821CF7E4;
	sub_82BCFFF0(ctx, base);
	// 821CF7E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF7E8: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821CF7EC: 419A002C  beq cr6, 0x821cf818
	if ctx.cr[6].eq {
	pc = 0x821CF818; continue 'dispatch;
	}
	// 821CF7F0: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 821CF7F4: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 821CF7F8: 2F1B0064  cmpwi cr6, r27, 0x64
	ctx.cr[6].compare_i32(ctx.r[27].s32, 100, &mut ctx.xer);
	// 821CF7FC: 4198FF0C  blt cr6, 0x821cf708
	if ctx.cr[6].lt {
	pc = 0x821CF708; continue 'dispatch;
	}
	// 821CF800: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821CF804: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CF808: 388B3B88  addi r4, r11, 0x3b88
	ctx.r[4].s64 = ctx.r[11].s64 + 15240;
	// 821CF80C: 48A00A05  bl 0x82bd0210
	ctx.lr = 0x821CF810;
	sub_82BD0210(ctx, base);
	// 821CF810: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821CF814: 48AD9C30  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
	// 821CF818: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821CF81C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821CF820: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821CF824: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821CF828: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CF82C: 48A02F45  bl 0x82bd2770
	ctx.lr = 0x821CF830;
	sub_82BD2770(ctx, base);
	// 821CF830: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821CF834: 48AD9C10  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CF838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CF838 size=384
    let mut pc: u32 = 0x821CF838;
    'dispatch: loop {
        match pc {
            0x821CF838 => {
    //   block [0x821CF838..0x821CF9B8)
	// 821CF838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CF83C: 48AD9BB5  bl 0x82ca93f0
	ctx.lr = 0x821CF840;
	sub_82CA93D0(ctx, base);
	// 821CF840: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CF844: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821CF848: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 821CF84C: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 821CF850: 490592F9  bl 0x83228b48
	ctx.lr = 0x821CF854;
	sub_83228B48(ctx, base);
	// 821CF854: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CF858: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CF85C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CF860: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821CF864: 419A0008  beq cr6, 0x821cf86c
	if ctx.cr[6].eq {
	pc = 0x821CF86C; continue 'dispatch;
	}
	// 821CF868: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821CF86C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CF870: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CF874: 419A0010  beq cr6, 0x821cf884
	if ctx.cr[6].eq {
	pc = 0x821CF884; continue 'dispatch;
	}
	// 821CF878: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821CF87C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821CF880: 48AD9BC0  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 821CF884: 817B0154  lwz r11, 0x154(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(340 as u32) ) } as u64;
	// 821CF888: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 821CF88C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821CF890: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821CF894: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CF898: 40990110  ble cr6, 0x821cf9a8
	if !ctx.cr[6].gt {
	pc = 0x821CF9A8; continue 'dispatch;
	}
	// 821CF89C: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821CF8A0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821CF8A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821CF8A8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821CF8AC: 3B4B1A90  addi r26, r11, 0x1a90
	ctx.r[26].s64 = ctx.r[11].s64 + 6800;
	// 821CF8B0: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF8B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821CF8B8: 7CFE5A14  add r7, r30, r11
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821CF8BC: 89670018  lbz r11, 0x18(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CF8C0: C027000C  lfs f1, 0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821CF8C4: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 821CF8C8: 4905F321  bl 0x8322ebe8
	ctx.lr = 0x821CF8CC;
	sub_8322EBE8(ctx, base);
	// 821CF8CC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CF8D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CF8D4: 409A004C  bne cr6, 0x821cf920
	if !ctx.cr[6].eq {
	pc = 0x821CF920; continue 'dispatch;
	}
	// 821CF8D8: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF8DC: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821CF8E0: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821CF8E4: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 821CF8E8: 7CCBE214  add r6, r11, r28
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821CF8EC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821CF8F0: 7CCA492E  stwx r6, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[6].u32) };
	// 821CF8F4: 2F1D0004  cmpwi cr6, r29, 4
	ctx.cr[6].compare_i32(ctx.r[29].s32, 4, &mut ctx.xer);
	// 821CF8F8: 7CEA412E  stwx r7, r10, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), ctx.r[7].u32) };
	// 821CF8FC: 409A0024  bne cr6, 0x821cf920
	if !ctx.cr[6].eq {
	pc = 0x821CF920; continue 'dispatch;
	}
	// 821CF900: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF904: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821CF908: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CF90C: 7CBF5A14  add r5, r31, r11
	ctx.r[5].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 821CF910: 49053CE1  bl 0x832235f0
	ctx.lr = 0x821CF914;
	sub_832235F0(ctx, base);
	// 821CF914: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 821CF918: 3BFF0160  addi r31, r31, 0x160
	ctx.r[31].s64 = ctx.r[31].s64 + 352;
	// 821CF91C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821CF920: 817B0154  lwz r11, 0x154(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(340 as u32) ) } as u64;
	// 821CF924: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 821CF928: 3B9C0030  addi r28, r28, 0x30
	ctx.r[28].s64 = ctx.r[28].s64 + 48;
	// 821CF92C: 3BDE0024  addi r30, r30, 0x24
	ctx.r[30].s64 = ctx.r[30].s64 + 36;
	// 821CF930: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CF934: 4198FF7C  blt cr6, 0x821cf8b0
	if ctx.cr[6].lt {
	pc = 0x821CF8B0; continue 'dispatch;
	}
	// 821CF938: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821CF93C: 4099006C  ble cr6, 0x821cf9a8
	if !ctx.cr[6].gt {
	pc = 0x821CF9A8; continue 'dispatch;
	}
	// 821CF940: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821CF944: 1F980160  mulli r28, r24, 0x160
	ctx.r[28].s64 = ctx.r[24].s64 * 352;
	// 821CF948: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821CF94C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821CF950: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF954: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 821CF958: 7CDC5A14  add r6, r28, r11
	ctx.r[6].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 821CF95C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CF960: 7CBF502E  lwzx r5, r31, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821CF964: 7C9F482E  lwzx r4, r31, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821CF968: 49053F89  bl 0x832238f0
	ctx.lr = 0x821CF96C;
	sub_832238F0(ctx, base);
	// 821CF96C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821CF970: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821CF974: 7F1EE800  cmpw cr6, r30, r29
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[29].s32, &mut ctx.xer);
	// 821CF978: 4198FFD4  blt cr6, 0x821cf94c
	if ctx.cr[6].lt {
	pc = 0x821CF94C; continue 'dispatch;
	}
	// 821CF97C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 821CF980: 2F1D0004  cmpwi cr6, r29, 4
	ctx.cr[6].compare_i32(ctx.r[29].s32, 4, &mut ctx.xer);
	// 821CF984: 40980024  bge cr6, 0x821cf9a8
	if !ctx.cr[6].lt {
	pc = 0x821CF9A8; continue 'dispatch;
	}
	// 821CF988: 1FD80160  mulli r30, r24, 0x160
	ctx.r[30].s64 = ctx.r[24].s64 * 352;
	// 821CF98C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF990: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CF994: 7C9E5A14  add r4, r30, r11
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821CF998: 490533A1  bl 0x83222d38
	ctx.lr = 0x821CF99C;
	sub_83222D38(ctx, base);
	// 821CF99C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821CF9A0: 2F1F0004  cmpwi cr6, r31, 4
	ctx.cr[6].compare_i32(ctx.r[31].s32, 4, &mut ctx.xer);
	// 821CF9A4: 4198FFE8  blt cr6, 0x821cf98c
	if ctx.cr[6].lt {
	pc = 0x821CF98C; continue 'dispatch;
	}
	// 821CF9A8: 570B103A  slwi r11, r24, 2
	ctx.r[11].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CF9AC: 7C6BEA14  add r3, r11, r29
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821CF9B0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821CF9B4: 48AD9A8C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CF9B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CF9B8 size=452
    let mut pc: u32 = 0x821CF9B8;
    'dispatch: loop {
        match pc {
            0x821CF9B8 => {
    //   block [0x821CF9B8..0x821CFB7C)
	// 821CF9B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CF9BC: 48AD9A39  bl 0x82ca93f4
	ctx.lr = 0x821CF9C0;
	sub_82CA93D0(ctx, base);
	// 821CF9C0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CF9C4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821CF9C8: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 821CF9CC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821CF9D0: 49059179  bl 0x83228b48
	ctx.lr = 0x821CF9D4;
	sub_83228B48(ctx, base);
	// 821CF9D4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CF9D8: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CF9DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CF9E0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821CF9E4: 419A0008  beq cr6, 0x821cf9ec
	if ctx.cr[6].eq {
	pc = 0x821CF9EC; continue 'dispatch;
	}
	// 821CF9E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821CF9EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CF9F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CF9F4: 419A0010  beq cr6, 0x821cfa04
	if ctx.cr[6].eq {
	pc = 0x821CFA04; continue 'dispatch;
	}
	// 821CF9F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821CF9FC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821CFA00: 48AD9A44  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
	// 821CFA04: 817B0154  lwz r11, 0x154(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(340 as u32) ) } as u64;
	// 821CFA08: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821CFA0C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821CFA10: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821CFA14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CFA18: 40990154  ble cr6, 0x821cfb6c
	if !ctx.cr[6].gt {
	pc = 0x821CFB6C; continue 'dispatch;
	}
	// 821CFA1C: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821CFA20: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821CFA24: 3B0B1A80  addi r24, r11, 0x1a80
	ctx.r[24].s64 = ctx.r[11].s64 + 6784;
	// 821CFA28: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CFA2C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821CFA30: 813C001C  lwz r9, 0x1c(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CFA34: 7D1D5A14  add r8, r29, r11
	ctx.r[8].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821CFA38: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFA3C: 7D0B4838  and r11, r8, r9
	ctx.r[11].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821CFA40: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CFA44: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821CFA48: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CFA4C: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821CFA50: 89670014  lbz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CFA54: C027000C  lfs f1, 0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821CFA58: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 821CFA5C: 4905F18D  bl 0x8322ebe8
	ctx.lr = 0x821CFA60;
	sub_8322EBE8(ctx, base);
	// 821CFA60: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CFA64: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821CFA68: 409A0084  bne cr6, 0x821cfaec
	if !ctx.cr[6].eq {
	pc = 0x821CFAEC; continue 'dispatch;
	}
	// 821CFA6C: 81790010  lwz r11, 0x10(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CFA70: 57C9103A  slwi r9, r30, 2
	ctx.r[9].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CFA74: 8119001C  lwz r8, 0x1c(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CFA78: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821CFA7C: 7CABEA14  add r5, r11, r29
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821CFA80: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFA84: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821CFA88: 7CA34038  and r3, r5, r8
	ctx.r[3].u64 = ctx.r[5].u64 & ctx.r[8].u64;
	// 821CFA8C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821CFA90: 546B2834  slwi r11, r3, 5
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CFA94: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 821CFA98: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821CFA9C: 7CE9212E  stwx r7, r9, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32), ctx.r[7].u32) };
	// 821CFAA0: 7D69312E  stwx r11, r9, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 821CFAA4: 409A0048  bne cr6, 0x821cfaec
	if !ctx.cr[6].eq {
	pc = 0x821CFAEC; continue 'dispatch;
	}
	// 821CFAA8: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFAAC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821CFAB0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821CFAB4: 7CDA5A14  add r6, r26, r11
	ctx.r[6].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 821CFAB8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821CFABC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821CFAC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CFAC4: 7CBF582E  lwzx r5, r31, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821CFAC8: 7C9F502E  lwzx r4, r31, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821CFACC: 49052715  bl 0x832221e0
	ctx.lr = 0x821CFAD0;
	sub_832221E0(ctx, base);
	// 821CFAD0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821CFAD4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821CFAD8: 2F1F0010  cmpwi cr6, r31, 0x10
	ctx.cr[6].compare_i32(ctx.r[31].s32, 16, &mut ctx.xer);
	// 821CFADC: 4198FFDC  blt cr6, 0x821cfab8
	if ctx.cr[6].lt {
	pc = 0x821CFAB8; continue 'dispatch;
	}
	// 821CFAE0: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 821CFAE4: 3B5A00D0  addi r26, r26, 0xd0
	ctx.r[26].s64 = ctx.r[26].s64 + 208;
	// 821CFAE8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821CFAEC: 817B0154  lwz r11, 0x154(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(340 as u32) ) } as u64;
	// 821CFAF0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821CFAF4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CFAF8: 4198FF30  blt cr6, 0x821cfa28
	if ctx.cr[6].lt {
	pc = 0x821CFA28; continue 'dispatch;
	}
	// 821CFAFC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821CFB00: 4099006C  ble cr6, 0x821cfb6c
	if !ctx.cr[6].gt {
	pc = 0x821CFB6C; continue 'dispatch;
	}
	// 821CFB04: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821CFB08: 1F9700D0  mulli r28, r23, 0xd0
	ctx.r[28].s64 = ctx.r[23].s64 * 208;
	// 821CFB0C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821CFB10: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821CFB14: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFB18: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 821CFB1C: 7CDC5A14  add r6, r28, r11
	ctx.r[6].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 821CFB20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821CFB24: 7CBF502E  lwzx r5, r31, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821CFB28: 7C9F482E  lwzx r4, r31, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821CFB2C: 490526B5  bl 0x832221e0
	ctx.lr = 0x821CFB30;
	sub_832221E0(ctx, base);
	// 821CFB30: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821CFB34: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821CFB38: 7F1DF000  cmpw cr6, r29, r30
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[30].s32, &mut ctx.xer);
	// 821CFB3C: 4198FFD4  blt cr6, 0x821cfb10
	if ctx.cr[6].lt {
	pc = 0x821CFB10; continue 'dispatch;
	}
	// 821CFB40: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821CFB44: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 821CFB48: 40980024  bge cr6, 0x821cfb6c
	if !ctx.cr[6].lt {
	pc = 0x821CFB6C; continue 'dispatch;
	}
	// 821CFB4C: 1FB700D0  mulli r29, r23, 0xd0
	ctx.r[29].s64 = ctx.r[23].s64 * 208;
	// 821CFB50: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFB54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CFB58: 7C9D5A14  add r4, r29, r11
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821CFB5C: 49052205  bl 0x83221d60
	ctx.lr = 0x821CFB60;
	sub_83221D60(ctx, base);
	// 821CFB60: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821CFB64: 2F1F0004  cmpwi cr6, r31, 4
	ctx.cr[6].compare_i32(ctx.r[31].s32, 4, &mut ctx.xer);
	// 821CFB68: 4198FFE8  blt cr6, 0x821cfb50
	if ctx.cr[6].lt {
	pc = 0x821CFB50; continue 'dispatch;
	}
	// 821CFB6C: 56EB103A  slwi r11, r23, 2
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CFB70: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821CFB74: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821CFB78: 48AD98CC  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CFB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CFB80 size=244
    let mut pc: u32 = 0x821CFB80;
    'dispatch: loop {
        match pc {
            0x821CFB80 => {
    //   block [0x821CFB80..0x821CFC74)
	// 821CFB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CFB84: 48AD987D  bl 0x82ca9400
	ctx.lr = 0x821CFB88;
	sub_82CA93D0(ctx, base);
	// 821CFB88: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CFB8C: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 821CFB90: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821CFB94: 834100EC  lwz r26, 0xec(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 821CFB98: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 821CFB9C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821CFBA0: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFBA4: 4804F6B5  bl 0x8221f258
	ctx.lr = 0x821CFBA8;
	sub_8221F258(ctx, base);
	// 821CFBA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CFBAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821CFBB0: 419A0008  beq cr6, 0x821cfbb8
	if ctx.cr[6].eq {
	pc = 0x821CFBB8; continue 'dispatch;
	}
	// 821CFBB4: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 821CFBB8: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 821CFBBC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821CFBC0: 419A0008  beq cr6, 0x821cfbc8
	if ctx.cr[6].eq {
	pc = 0x821CFBC8; continue 'dispatch;
	}
	// 821CFBC4: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821CFBC8: 37DF0008  addic. r30, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821CFBCC: 4182002C  beq 0x821cfbf8
	if ctx.cr[0].eq {
	pc = 0x821CFBF8; continue 'dispatch;
	}
	// 821CFBD0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821CFBD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CFBD8: 48020669  bl 0x821f0240
	ctx.lr = 0x821CFBDC;
	sub_821F0240(ctx, base);
	// 821CFBDC: 389B0004  addi r4, r27, 4
	ctx.r[4].s64 = ctx.r[27].s64 + 4;
	// 821CFBE0: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 821CFBE4: 4802065D  bl 0x821f0240
	ctx.lr = 0x821CFBE8;
	sub_821F0240(ctx, base);
	// 821CFBE8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CFBEC: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821CFBF0: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CFBF4: 915E000C  stw r10, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821CFBF8: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 821CFBFC: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CFC00: 6169FFFF  ori r9, r11, 0xffff
	ctx.r[9].u64 = ctx.r[11].u64 | 65535;
	// 821CFC04: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 821CFC08: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 821CFC0C: 40980048  bge cr6, 0x821cfc54
	if !ctx.cr[6].lt {
	pc = 0x821CFC54; continue 'dispatch;
	}
	// 821CFC10: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CFC14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821CFC18: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 821CFC1C: 48122325  bl 0x822f1f40
	ctx.lr = 0x821CFC20;
	sub_822F1F40(ctx, base);
	// 821CFC20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821CFC24: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821CFC28: 48122189  bl 0x822f1db0
	ctx.lr = 0x821CFC2C;
	sub_822F1DB0(ctx, base);
	// 821CFC2C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821CFC30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821CFC34: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 821CFC38: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 821CFC3C: 481221E5  bl 0x822f1e20
	ctx.lr = 0x821CFC40;
	sub_822F1E20(ctx, base);
	// 821CFC40: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 821CFC44: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821CFC48: 484ABB99  bl 0x8267b7e0
	ctx.lr = 0x821CFC4C;
	sub_8267B7E0(ctx, base);
	// 821CFC4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821CFC50: 4BFA1BC1  bl 0x82171810
	ctx.lr = 0x821CFC54;
	sub_82171810(ctx, base);
	// 821CFC54: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CFC58: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821CFC5C: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821CFC60: 93FA0004  stw r31, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821CFC64: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CFC68: 93EA0000  stw r31, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 821CFC6C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821CFC70: 48AD97E0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CFC78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CFC78 size=396
    let mut pc: u32 = 0x821CFC78;
    'dispatch: loop {
        match pc {
            0x821CFC78 => {
    //   block [0x821CFC78..0x821CFE04)
	// 821CFC78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CFC7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821CFC80: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CFC84: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821CFC88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CFC8C: 419A0018  beq cr6, 0x821cfca4
	if ctx.cr[6].eq {
	pc = 0x821CFCA4; continue 'dispatch;
	}
	// 821CFC90: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 821CFC94: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821CFC98: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821CFC9C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CFCA0: 409A0008  bne cr6, 0x821cfca8
	if !ctx.cr[6].eq {
	pc = 0x821CFCA8; continue 'dispatch;
	}
	// 821CFCA4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821CFCA8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821CFCAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CFCB0: 419A0140  beq cr6, 0x821cfdf0
	if ctx.cr[6].eq {
	pc = 0x821CFDF0; continue 'dispatch;
	}
	// 821CFCB4: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821CFCB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821CFCBC: 55285FFE  rlwinm r8, r9, 0xb, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x001FFFFFu64;
	// 821CFCC0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821CFCC4: 419A00F8  beq cr6, 0x821cfdbc
	if ctx.cr[6].eq {
	pc = 0x821CFDBC; continue 'dispatch;
	}
	// 821CFCC8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821CFCCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CFCD0: 419A0024  beq cr6, 0x821cfcf4
	if ctx.cr[6].eq {
	pc = 0x821CFCF4; continue 'dispatch;
	}
	// 821CFCD4: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 821CFCD8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CFCDC: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821CFCE0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821CFCE4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFCE8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CFCEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CFCF0: 480000D0  b 0x821cfdc0
	pc = 0x821CFDC0; continue 'dispatch;
	// 821CFCF4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CFCF8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821CFCFC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821CFD00: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821CFD04: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821CFD08: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821CFD0C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CFD10: 40810054  ble 0x821cfd64
	if !ctx.cr[0].gt {
	pc = 0x821CFD64; continue 'dispatch;
	}
	// 821CFD14: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821CFD18: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821CFD1C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821CFD20: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CFD24: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 821CFD28: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821CFD2C: 41980008  blt cr6, 0x821cfd34
	if ctx.cr[6].lt {
	pc = 0x821CFD34; continue 'dispatch;
	}
	// 821CFD30: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821CFD34: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821CFD38: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CFD3C: 419A0014  beq cr6, 0x821cfd50
	if ctx.cr[6].eq {
	pc = 0x821CFD50; continue 'dispatch;
	}
	// 821CFD40: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821CFD44: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CFD48: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CFD4C: 4800000C  b 0x821cfd58
	pc = 0x821CFD58; continue 'dispatch;
	// 821CFD50: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821CFD54: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821CFD58: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CFD5C: 4199FFB8  bgt cr6, 0x821cfd14
	if ctx.cr[6].gt {
	pc = 0x821CFD14; continue 'dispatch;
	}
	// 821CFD60: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821CFD64: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821CFD68: 419A0040  beq cr6, 0x821cfda8
	if ctx.cr[6].eq {
	pc = 0x821CFDA8; continue 'dispatch;
	}
	// 821CFD6C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CFD70: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 821CFD74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CFD78: 41990008  bgt cr6, 0x821cfd80
	if ctx.cr[6].gt {
	pc = 0x821CFD80; continue 'dispatch;
	}
	// 821CFD7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821CFD80: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CFD84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CFD88: 409A0020  bne cr6, 0x821cfda8
	if !ctx.cr[6].eq {
	pc = 0x821CFDA8; continue 'dispatch;
	}
	// 821CFD8C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821CFD90: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821CFD94: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821CFD98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFD9C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CFDA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CFDA4: 4800001C  b 0x821cfdc0
	pc = 0x821CFDC0; continue 'dispatch;
	// 821CFDA8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821CFDAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFDB0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CFDB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CFDB8: 48000008  b 0x821cfdc0
	pc = 0x821CFDC0; continue 'dispatch;
	// 821CFDBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821CFDC0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CFDC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CFDC8: 419A0028  beq cr6, 0x821cfdf0
	if ctx.cr[6].eq {
	pc = 0x821CFDF0; continue 'dispatch;
	}
	// 821CFDCC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CFDD0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821CFDD4: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 821CFDD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821CFDDC: 4E800421  bctrl
	ctx.lr = 0x821CFDE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CFDE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821CFDE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CFDE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CFDEC: 4E800020  blr
	return;
	// 821CFDF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821CFDF4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821CFDF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CFDFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CFE00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CFE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CFE08 size=900
    let mut pc: u32 = 0x821CFE08;
    'dispatch: loop {
        match pc {
            0x821CFE08 => {
    //   block [0x821CFE08..0x821D018C)
	// 821CFE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CFE0C: 48AD95F9  bl 0x82ca9404
	ctx.lr = 0x821CFE10;
	sub_82CA93D0(ctx, base);
	// 821CFE10: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CFE14: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821CFE18: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821CFE1C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821CFE20: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821CFE24: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821CFE28: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFE2C: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CFE30: 554927FE  rlwinm r9, r10, 4, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0FFFFFFFu64;
	// 821CFE34: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CFE38: 419A00E8  beq cr6, 0x821cff20
	if ctx.cr[6].eq {
	pc = 0x821CFF20; continue 'dispatch;
	}
	// 821CFE3C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821CFE40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CFE44: 419A0020  beq cr6, 0x821cfe64
	if ctx.cr[6].eq {
	pc = 0x821CFE64; continue 'dispatch;
	}
	// 821CFE48: 894A003C  lbz r10, 0x3c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 821CFE4C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CFE50: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821CFE54: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821CFE58: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821CFE5C: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFE60: 480000C4  b 0x821cff24
	pc = 0x821CFF24; continue 'dispatch;
	// 821CFE64: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CFE68: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821CFE6C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821CFE70: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821CFE74: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821CFE78: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CFE7C: 40810054  ble 0x821cfed0
	if !ctx.cr[0].gt {
	pc = 0x821CFED0; continue 'dispatch;
	}
	// 821CFE80: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821CFE84: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821CFE88: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821CFE8C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CFE90: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 821CFE94: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821CFE98: 41980008  blt cr6, 0x821cfea0
	if ctx.cr[6].lt {
	pc = 0x821CFEA0; continue 'dispatch;
	}
	// 821CFE9C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821CFEA0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821CFEA4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CFEA8: 419A0014  beq cr6, 0x821cfebc
	if ctx.cr[6].eq {
	pc = 0x821CFEBC; continue 'dispatch;
	}
	// 821CFEAC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821CFEB0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CFEB4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CFEB8: 4800000C  b 0x821cfec4
	pc = 0x821CFEC4; continue 'dispatch;
	// 821CFEBC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821CFEC0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821CFEC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CFEC8: 4199FFB8  bgt cr6, 0x821cfe80
	if ctx.cr[6].gt {
	pc = 0x821CFE80; continue 'dispatch;
	}
	// 821CFECC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821CFED0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821CFED4: 419A003C  beq cr6, 0x821cff10
	if ctx.cr[6].eq {
	pc = 0x821CFF10; continue 'dispatch;
	}
	// 821CFED8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CFEDC: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 821CFEE0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821CFEE4: 41990008  bgt cr6, 0x821cfeec
	if ctx.cr[6].gt {
	pc = 0x821CFEEC; continue 'dispatch;
	}
	// 821CFEE8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821CFEEC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CFEF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CFEF4: 409A001C  bne cr6, 0x821cff10
	if !ctx.cr[6].eq {
	pc = 0x821CFF10; continue 'dispatch;
	}
	// 821CFEF8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821CFEFC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821CFF00: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821CFF04: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFF08: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821CFF0C: 48000018  b 0x821cff24
	pc = 0x821CFF24; continue 'dispatch;
	// 821CFF10: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821CFF14: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFF18: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821CFF1C: 48000008  b 0x821cff24
	pc = 0x821CFF24; continue 'dispatch;
	// 821CFF20: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821CFF24: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CFF28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CFF2C: 419A0254  beq cr6, 0x821d0180
	if ctx.cr[6].eq {
	pc = 0x821D0180; continue 'dispatch;
	}
	// 821CFF30: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 821CFF34: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821CFF38: 419A0028  beq cr6, 0x821cff60
	if ctx.cr[6].eq {
	pc = 0x821CFF60; continue 'dispatch;
	}
	// 821CFF3C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821CFF40: 419A0020  beq cr6, 0x821cff60
	if ctx.cr[6].eq {
	pc = 0x821CFF60; continue 'dispatch;
	}
	// 821CFF44: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821CFF48: 419A0018  beq cr6, 0x821cff60
	if ctx.cr[6].eq {
	pc = 0x821CFF60; continue 'dispatch;
	}
	// 821CFF4C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821CFF50: 419A0010  beq cr6, 0x821cff60
	if ctx.cr[6].eq {
	pc = 0x821CFF60; continue 'dispatch;
	}
	// 821CFF54: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821CFF58: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821CFF5C: 409A0008  bne cr6, 0x821cff64
	if !ctx.cr[6].eq {
	pc = 0x821CFF64; continue 'dispatch;
	}
	// 821CFF60: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821CFF64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CFF68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CFF6C: 419A0214  beq cr6, 0x821d0180
	if ctx.cr[6].eq {
	pc = 0x821D0180; continue 'dispatch;
	}
	// 821CFF70: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821CFF74: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 821CFF78: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821CFF7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CFF80: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821CFF84: 4809B045  bl 0x8226afc8
	ctx.lr = 0x821CFF88;
	sub_8226AFC8(ctx, base);
	// 821CFF88: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D0190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D0190 size=804
    let mut pc: u32 = 0x821D0190;
    'dispatch: loop {
        match pc {
            0x821D0190 => {
    //   block [0x821D0190..0x821D04B4)
	// 821D0190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D0194: 48AD9279  bl 0x82ca940c
	ctx.lr = 0x821D0198;
	sub_82CA93D0(ctx, base);
	// 821D0198: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D019C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D01A0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821D01A4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821D01A8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D01AC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821D01B0: 55499FFE  rlwinm r9, r10, 0x13, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00001FFFu64;
	// 821D01B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D01B8: 419A00F4  beq cr6, 0x821d02ac
	if ctx.cr[6].eq {
	pc = 0x821D02AC; continue 'dispatch;
	}
	// 821D01BC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D01C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D01C4: 419A0024  beq cr6, 0x821d01e8
	if ctx.cr[6].eq {
	pc = 0x821D01E8; continue 'dispatch;
	}
	// 821D01C8: 894A006D  lbz r10, 0x6d(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(109 as u32) ) } as u64;
	// 821D01CC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D01D0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D01D4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D01D8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D01DC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821D01E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D01E4: 480000CC  b 0x821d02b0
	pc = 0x821D02B0; continue 'dispatch;
	// 821D01E8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D01EC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D01F0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821D01F4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D01F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D01FC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D0200: 40810054  ble 0x821d0254
	if !ctx.cr[0].gt {
	pc = 0x821D0254; continue 'dispatch;
	}
	// 821D0204: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D0208: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D020C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D0210: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D0214: 2F07006D  cmpwi cr6, r7, 0x6d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 109, &mut ctx.xer);
	// 821D0218: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D021C: 41980008  blt cr6, 0x821d0224
	if ctx.cr[6].lt {
	pc = 0x821D0224; continue 'dispatch;
	}
	// 821D0220: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821D0224: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D0228: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D022C: 419A0014  beq cr6, 0x821d0240
	if ctx.cr[6].eq {
	pc = 0x821D0240; continue 'dispatch;
	}
	// 821D0230: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D0234: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D0238: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D023C: 4800000C  b 0x821d0248
	pc = 0x821D0248; continue 'dispatch;
	// 821D0240: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D0244: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821D0248: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D024C: 4199FFB8  bgt cr6, 0x821d0204
	if ctx.cr[6].gt {
	pc = 0x821D0204; continue 'dispatch;
	}
	// 821D0250: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D0254: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D0258: 419A0040  beq cr6, 0x821d0298
	if ctx.cr[6].eq {
	pc = 0x821D0298; continue 'dispatch;
	}
	// 821D025C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D0260: 2F0B006D  cmpwi cr6, r11, 0x6d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 109, &mut ctx.xer);
	// 821D0264: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D0268: 41990008  bgt cr6, 0x821d0270
	if ctx.cr[6].gt {
	pc = 0x821D0270; continue 'dispatch;
	}
	// 821D026C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821D0270: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D0274: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D0278: 409A0020  bne cr6, 0x821d0298
	if !ctx.cr[6].eq {
	pc = 0x821D0298; continue 'dispatch;
	}
	// 821D027C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D0280: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D0284: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D0288: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D028C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821D0290: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D0294: 4800001C  b 0x821d02b0
	pc = 0x821D02B0; continue 'dispatch;
	// 821D0298: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D029C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D02A0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821D02A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D02A8: 48000008  b 0x821d02b0
	pc = 0x821D02B0; continue 'dispatch;
	// 821D02AC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821D02B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D02B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D02B8: 419A01DC  beq cr6, 0x821d0494
	if ctx.cr[6].eq {
	pc = 0x821D0494; continue 'dispatch;
	}
	// 821D02BC: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D02C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D02C4: 409A016C  bne cr6, 0x821d0430
	if !ctx.cr[6].eq {
	pc = 0x821D0430; continue 'dispatch;
	}
	// 821D02C8: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 821D02CC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821D02D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D02D4: 4BFFFB35  bl 0x821cfe08
	ctx.lr = 0x821D02D8;
	sub_821CFE08(ctx, base);
	// 821D02D8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D02DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D02E0: 419A0150  beq cr6, 0x821d0430
	if ctx.cr[6].eq {
	pc = 0x821D0430; continue 'dispatch;
	}
	// 821D02E4: 89410074  lbz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821D02E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D02EC: 419A0144  beq cr6, 0x821d0430
	if ctx.cr[6].eq {
	pc = 0x821D0430; continue 'dispatch;
	}
	// 821D02F0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D02F4: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 821D02F8: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D02FC: 552827FE  rlwinm r8, r9, 4, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0FFFFFFFu64;
	// 821D0300: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821D0304: 419A00F4  beq cr6, 0x821d03f8
	if ctx.cr[6].eq {
	pc = 0x821D03F8; continue 'dispatch;
	}
	// 821D0308: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D030C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D0310: 419A0024  beq cr6, 0x821d0334
	if ctx.cr[6].eq {
	pc = 0x821D0334; continue 'dispatch;
	}
	// 821D0314: 894A003C  lbz r10, 0x3c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 821D0318: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D031C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D0320: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D0324: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0328: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821D032C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D0330: 480000CC  b 0x821d03fc
	pc = 0x821D03FC; continue 'dispatch;
	// 821D0334: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D0338: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D033C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821D0340: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D0344: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D0348: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D034C: 40810054  ble 0x821d03a0
	if !ctx.cr[0].gt {
	pc = 0x821D03A0; continue 'dispatch;
	}
	// 821D0350: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D0354: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D0358: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D035C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D0360: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 821D0364: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D0368: 41980008  blt cr6, 0x821d0370
	if ctx.cr[6].lt {
	pc = 0x821D0370; continue 'dispatch;
	}
	// 821D036C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821D0370: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D0374: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D0378: 419A0014  beq cr6, 0x821d038c
	if ctx.cr[6].eq {
	pc = 0x821D038C; continue 'dispatch;
	}
	// 821D037C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D0380: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D0384: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D0388: 4800000C  b 0x821d0394
	pc = 0x821D0394; continue 'dispatch;
	// 821D038C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D0390: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821D0394: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D0398: 4199FFB8  bgt cr6, 0x821d0350
	if ctx.cr[6].gt {
	pc = 0x821D0350; continue 'dispatch;
	}
	// 821D039C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D03A0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D03A4: 419A0040  beq cr6, 0x821d03e4
	if ctx.cr[6].eq {
	pc = 0x821D03E4; continue 'dispatch;
	}
	// 821D03A8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D03AC: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 821D03B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D03B4: 41990008  bgt cr6, 0x821d03bc
	if ctx.cr[6].gt {
	pc = 0x821D03BC; continue 'dispatch;
	}
	// 821D03B8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821D03BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D03C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D03C4: 409A0020  bne cr6, 0x821d03e4
	if !ctx.cr[6].eq {
	pc = 0x821D03E4; continue 'dispatch;
	}
	// 821D03C8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D03CC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D03D0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D03D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D03D8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821D03DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D03E0: 4800001C  b 0x821d03fc
	pc = 0x821D03FC; continue 'dispatch;
	// 821D03E4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D03E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D03EC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821D03F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D03F4: 48000008  b 0x821d03fc
	pc = 0x821D03FC; continue 'dispatch;
	// 821D03F8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821D03FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D0400: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D0404: 419A002C  beq cr6, 0x821d0430
	if ctx.cr[6].eq {
	pc = 0x821D0430; continue 'dispatch;
	}
	// 821D0408: 896A00BA  lbz r11, 0xba(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(186 as u32) ) } as u64;
	// 821D040C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D0410: 409A0020  bne cr6, 0x821d0430
	if !ctx.cr[6].eq {
	pc = 0x821D0430; continue 'dispatch;
	}
	// 821D0414: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 821D0418: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821D041C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821D0420: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D04B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D04B8 size=1500
    let mut pc: u32 = 0x821D04B8;
    'dispatch: loop {
        match pc {
            0x821D04B8 => {
    //   block [0x821D04B8..0x821D0A94)
	// 821D04B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D04BC: 48AD8F49  bl 0x82ca9404
	ctx.lr = 0x821D04C0;
	sub_82CA93D0(ctx, base);
	// 821D04C0: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 821D04C4: 48ADD811  bl 0x82cadcd4
	ctx.lr = 0x821D04C8;
	sub_82CADCA0(ctx, base);
	// 821D04C8: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D0A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D0A98 size=196
    let mut pc: u32 = 0x821D0A98;
    'dispatch: loop {
        match pc {
            0x821D0A98 => {
    //   block [0x821D0A98..0x821D0B5C)
	// 821D0A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D0A9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D0AA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D0AA4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D0AA8: 8164002C  lwz r11, 0x2c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D0AAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D0AB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D0AB4: 419A007C  beq cr6, 0x821d0b30
	if ctx.cr[6].eq {
	pc = 0x821D0B30; continue 'dispatch;
	}
	// 821D0AB8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D0ABC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D0AC0: 419A0070  beq cr6, 0x821d0b30
	if ctx.cr[6].eq {
	pc = 0x821D0B30; continue 'dispatch;
	}
	// 821D0AC4: 8064002C  lwz r3, 0x2c(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D0AC8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821D0ACC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D0AD0: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D0AD4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D0AD8: 4E800421  bctrl
	ctx.lr = 0x821D0ADC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D0ADC: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821D0AE0: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 821D0AE4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821D0AE8: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821D0AEC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D0B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D0B60 size=64
    let mut pc: u32 = 0x821D0B60;
    'dispatch: loop {
        match pc {
            0x821D0B60 => {
    //   block [0x821D0B60..0x821D0BA0)
	// 821D0B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D0B64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D0B68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D0B6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D0B70: 80840038  lwz r4, 0x38(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 821D0B74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D0B78: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D0B7C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D0B80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D0B84: 4E800421  bctrl
	ctx.lr = 0x821D0B88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D0B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D0B8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821D0B90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D0B94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D0B98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D0B9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D0BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D0BA0 size=92
    let mut pc: u32 = 0x821D0BA0;
    'dispatch: loop {
        match pc {
            0x821D0BA0 => {
    //   block [0x821D0BA0..0x821D0BFC)
	// 821D0BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D0BA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D0BA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D0BAC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D0BB0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D0BB4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821D0BB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D0BBC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D0BC0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821D0BC4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821D0BC8: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D0BCC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821D0BD0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821D0BD4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D0BD8: 48000029  bl 0x821d0c00
	ctx.lr = 0x821D0BDC;
	sub_821D0C00(ctx, base);
	// 821D0BDC: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D0BE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D0BE4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D0BE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D0BEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D0BF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D0BF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D0BF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D0C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D0C00 size=596
    let mut pc: u32 = 0x821D0C00;
    'dispatch: loop {
        match pc {
            0x821D0C00 => {
    //   block [0x821D0C00..0x821D0E54)
	// 821D0C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D0C04: 48AD87F9  bl 0x82ca93fc
	ctx.lr = 0x821D0C08;
	sub_82CA93D0(ctx, base);
	// 821D0C08: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D0C0C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821D0C10: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821D0C14: 397A00C2  addi r11, r26, 0xc2
	ctx.r[11].s64 = ctx.r[26].s64 + 194;
	// 821D0C18: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821D0C1C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D0C20: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821D0C24: 7FEBDA14  add r31, r11, r27
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821D0C28: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D0C2C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0C30: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821D0C34: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 821D0C38: 7F07E040  cmplw cr6, r7, r28
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821D0C3C: 40990164  ble cr6, 0x821d0da0
	if !ctx.cr[6].gt {
	pc = 0x821D0DA0; continue 'dispatch;
	}
	// 821D0C40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D0C44: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D0C48: 488A32C9  bl 0x82a73f10
	ctx.lr = 0x821D0C4C;
	sub_82A73F10(ctx, base);
	// 821D0C4C: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 821D0C50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D0C54: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D0C58: 579E1838  slwi r30, r28, 3
	ctx.r[30].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821D0C5C: 90A10068  stw r5, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[5].u32 ) };
	// 821D0C60: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821D0C64: 90A10058  stw r5, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 821D0C68: 90A10060  stw r5, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u32 ) };
	// 821D0C6C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821D0C70: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821D0C74: 83210074  lwz r25, 0x74(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821D0C78: 7D7ECA14  add r11, r30, r25
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[25].u64;
	// 821D0C7C: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 821D0C80: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 821D0C84: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821D0C88: 9321006C  stw r25, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[25].u32 ) };
	// 821D0C8C: E9010068  ld r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821D0C90: F9010068  std r8, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 821D0C94: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 821D0C98: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821D0C9C: F8810068  std r4, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[4].u64 ) };
	// 821D0CA0: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 821D0CA4: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821D0CA8: 488ECD69  bl 0x82abda10
	ctx.lr = 0x821D0CAC;
	sub_82ABDA10(ctx, base);
	// 821D0CAC: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821D0CB0: 40990034  ble cr6, 0x821d0ce4
	if !ctx.cr[6].gt {
	pc = 0x821D0CE4; continue 'dispatch;
	}
	// 821D0CB4: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 821D0CB8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 821D0CBC: 7D1DC850  subf r8, r29, r25
	ctx.r[8].s64 = ctx.r[25].s64 - ctx.r[29].s64;
	// 821D0CC0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821D0CC4: C0090000  lfs f0, 0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D0CC8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821D0CCC: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821D0CD0: 7CE8582E  lwzx r7, r8, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821D0CD4: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821D0CD8: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 821D0CDC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821D0CE0: 4082FFE4  bne 0x821d0cc4
	if !ctx.cr[0].eq {
	pc = 0x821D0CC4; continue 'dispatch;
	}
	// 821D0CE4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D0CE8: 395C0001  addi r10, r28, 1
	ctx.r[10].s64 = ctx.r[28].s64 + 1;
	// 821D0CEC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0CF0: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D0CF4: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 821D0CF8: 7F075040  cmplw cr6, r7, r10
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D0CFC: 40990028  ble cr6, 0x821d0d24
	if !ctx.cr[6].gt {
	pc = 0x821D0D24; continue 'dispatch;
	}
	// 821D0D00: 574A2036  slwi r10, r26, 4
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D0D04: 7D7EEA14  add r11, r30, r29
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 821D0D08: 7D2ADA14  add r9, r10, r27
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 821D0D0C: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 821D0D10: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D0D14: 81090C24  lwz r8, 0xc24(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3108 as u32) ) } as u64;
	// 821D0D18: 7DA8F42E  lfsx f13, r8, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D0D1C: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821D0D20: D18BFFF8  stfs f12, -8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821D0D24: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D0D28: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821D0D2C: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 821D0D30: C009FFF4  lfs f0, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D0D34: 40990020  ble cr6, 0x821d0d54
	if !ctx.cr[6].gt {
	pc = 0x821D0D54; continue 'dispatch;
	}
	// 821D0D38: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 821D0D3C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821D0D40: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D0D44: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D0D48: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821D0D4C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D0D50: 4082FFF0  bne 0x821d0d40
	if !ctx.cr[0].eq {
	pc = 0x821D0D40; continue 'dispatch;
	}
	// 821D0D54: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D0D58: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821D0D5C: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 821D0D60: 40990024  ble cr6, 0x821d0d84
	if !ctx.cr[6].gt {
	pc = 0x821D0D84; continue 'dispatch;
	}
	// 821D0D64: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821D0D68: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821D0D6C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D0D70: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821D0D74: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821D0D78: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821D0D7C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821D0D80: 4082FFEC  bne 0x821d0d6c
	if !ctx.cr[0].eq {
	pc = 0x821D0D6C; continue 'dispatch;
	}
	// 821D0D84: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821D0D88: 419A000C  beq cr6, 0x821d0d94
	if ctx.cr[6].eq {
	pc = 0x821D0D94; continue 'dispatch;
	}
	// 821D0D8C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821D0D90: 4804AFA9  bl 0x8221bd38
	ctx.lr = 0x821D0D94;
	sub_8221BD38(ctx, base);
	// 821D0D94: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821D0D98: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821D0D9C: 48AD86B0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 821D0DA0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D0DA4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D0DA8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0DAC: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 821D0DB0: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D0DB4: 7D071E71  srawi. r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821D0DB8: 41820050  beq 0x821d0e08
	if ctx.cr[0].eq {
	pc = 0x821D0E08; continue 'dispatch;
	}
	// 821D0DBC: 574B2036  slwi r11, r26, 4
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D0DC0: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 821D0DC4: 7CEBDA14  add r7, r11, r27
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821D0DC8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821D0DCC: 81070C24  lwz r8, 0xc24(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3108 as u32) ) } as u64;
	// 821D0DD0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821D0DD4: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D0DD8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D0DDC: C0080000  lfs f0, 0(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D0DE0: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821D0DE4: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0DE8: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821D0DEC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821D0DF0: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D0DF4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0DF8: 7C643050  subf r3, r4, r6
	ctx.r[3].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 821D0DFC: 7C681E70  srawi r8, r3, 3
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[3].s32 >> 3) as i64;
	// 821D0E00: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821D0E04: 4198FFC8  blt cr6, 0x821d0dcc
	if ctx.cr[6].lt {
	pc = 0x821D0DCC; continue 'dispatch;
	}
	// 821D0E08: 7F09E000  cmpw cr6, r9, r28
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[28].s32, &mut ctx.xer);
	// 821D0E0C: 40980030  bge cr6, 0x821d0e3c
	if !ctx.cr[6].lt {
	pc = 0x821D0E3C; continue 'dispatch;
	}
	// 821D0E10: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D0E14: 7D49E050  subf r10, r9, r28
	ctx.r[10].s64 = ctx.r[28].s64 - ctx.r[9].s64;
	// 821D0E18: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821D0E1C: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821D0E20: 39099490  addi r8, r9, -0x6b70
	ctx.r[8].s64 = ctx.r[9].s64 + -27504;
	// 821D0E24: C008FFF4  lfs f0, -0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D0E28: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 821D0E2C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821D0E30: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821D0E34: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821D0E38: 4082FFF0  bne 0x821d0e28
	if !ctx.cr[0].eq {
	pc = 0x821D0E28; continue 'dispatch;
	}
	// 821D0E3C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D0E40: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0E44: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D0E48: 7D231E70  srawi r3, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 821D0E4C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821D0E50: 48AD85FC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D0E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D0E58 size=1708
    let mut pc: u32 = 0x821D0E58;
    'dispatch: loop {
        match pc {
            0x821D0E58 => {
    //   block [0x821D0E58..0x821D1504)
	// 821D0E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D0E5C: 48AD859D  bl 0x82ca93f8
	ctx.lr = 0x821D0E60;
	sub_82CA93D0(ctx, base);
	// 821D0E60: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 821D0E64: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 821D0E68: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D0E6C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821D0E70: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821D0E74: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821D0E78: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 821D0E7C: 4809B885  bl 0x8226c700
	ctx.lr = 0x821D0E80;
	sub_8226C700(ctx, base);
	// 821D0E80: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D0E84: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 821D0E88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D0E8C: 419A00E8  beq cr6, 0x821d0f74
	if ctx.cr[6].eq {
	pc = 0x821D0F74; continue 'dispatch;
	}
	// 821D0E90: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D0E94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D0E98: 419A0020  beq cr6, 0x821d0eb8
	if ctx.cr[6].eq {
	pc = 0x821D0EB8; continue 'dispatch;
	}
	// 821D0E9C: 894B005B  lbz r10, 0x5b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(91 as u32) ) } as u64;
	// 821D0EA0: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D0EA4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D0EA8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D0EAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D0EB0: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0EB4: 480000C4  b 0x821d0f78
	pc = 0x821D0F78; continue 'dispatch;
	// 821D0EB8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D0EBC: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D0EC0: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 821D0EC4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D0EC8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D0ECC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D0ED0: 40810054  ble 0x821d0f24
	if !ctx.cr[0].gt {
	pc = 0x821D0F24; continue 'dispatch;
	}
	// 821D0ED4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D0ED8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D0EDC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D0EE0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D0EE4: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 821D0EE8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D0EEC: 41980008  blt cr6, 0x821d0ef4
	if ctx.cr[6].lt {
	pc = 0x821D0EF4; continue 'dispatch;
	}
	// 821D0EF0: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 821D0EF4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D0EF8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D0EFC: 419A0014  beq cr6, 0x821d0f10
	if ctx.cr[6].eq {
	pc = 0x821D0F10; continue 'dispatch;
	}
	// 821D0F00: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D0F04: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D0F08: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D0F0C: 4800000C  b 0x821d0f18
	pc = 0x821D0F18; continue 'dispatch;
	// 821D0F10: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D0F14: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821D0F18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D0F1C: 4199FFB8  bgt cr6, 0x821d0ed4
	if ctx.cr[6].gt {
	pc = 0x821D0ED4; continue 'dispatch;
	}
	// 821D0F20: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D0F24: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D0F28: 419A003C  beq cr6, 0x821d0f64
	if ctx.cr[6].eq {
	pc = 0x821D0F64; continue 'dispatch;
	}
	// 821D0F2C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D0F30: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 821D0F34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D0F38: 41990008  bgt cr6, 0x821d0f40
	if ctx.cr[6].gt {
	pc = 0x821D0F40; continue 'dispatch;
	}
	// 821D0F3C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 821D0F40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D0F44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D0F48: 409A001C  bne cr6, 0x821d0f64
	if !ctx.cr[6].eq {
	pc = 0x821D0F64; continue 'dispatch;
	}
	// 821D0F4C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D0F50: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D0F54: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D0F58: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0F5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D0F60: 48000018  b 0x821d0f78
	pc = 0x821D0F78; continue 'dispatch;
	// 821D0F64: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D0F68: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0F6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D0F70: 48000008  b 0x821d0f78
	pc = 0x821D0F78; continue 'dispatch;
	// 821D0F74: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 821D0F78: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D0F7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D0F80: 419A0010  beq cr6, 0x821d0f90
	if ctx.cr[6].eq {
	pc = 0x821D0F90; continue 'dispatch;
	}
	// 821D0F84: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821D0F88: 8B5F006C  lbz r26, 0x6c(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 821D0F8C: 995F006C  stb r10, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[10].u8 ) };
	// 821D0F90: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821D0F94: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 821D0F98: 4809B769  bl 0x8226c700
	ctx.lr = 0x821D0F9C;
	sub_8226C700(ctx, base);
	// 821D0F9C: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821D0FA0: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 821D0FA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D0FA8: 419A00F4  beq cr6, 0x821d109c
	if ctx.cr[6].eq {
	pc = 0x821D109C; continue 'dispatch;
	}
	// 821D0FAC: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D0FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D0FB4: 419A0024  beq cr6, 0x821d0fd8
	if ctx.cr[6].eq {
	pc = 0x821D0FD8; continue 'dispatch;
	}
	// 821D0FB8: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 821D0FBC: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D0FC0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D0FC4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D0FC8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0FCC: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821D0FD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D0FD4: 480000CC  b 0x821d10a0
	pc = 0x821D10A0; continue 'dispatch;
	// 821D0FD8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D0FDC: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D0FE0: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 821D0FE4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D0FE8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D0FEC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D0FF0: 40810054  ble 0x821d1044
	if !ctx.cr[0].gt {
	pc = 0x821D1044; continue 'dispatch;
	}
	// 821D0FF4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D0FF8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D0FFC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D1000: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1004: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 821D1008: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D100C: 41980008  blt cr6, 0x821d1014
	if ctx.cr[6].lt {
	pc = 0x821D1014; continue 'dispatch;
	}
	// 821D1010: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 821D1014: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D1018: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D101C: 419A0014  beq cr6, 0x821d1030
	if ctx.cr[6].eq {
	pc = 0x821D1030; continue 'dispatch;
	}
	// 821D1020: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D1024: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D1028: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D102C: 4800000C  b 0x821d1038
	pc = 0x821D1038; continue 'dispatch;
	// 821D1030: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D1034: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821D1038: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D103C: 4199FFB8  bgt cr6, 0x821d0ff4
	if ctx.cr[6].gt {
	pc = 0x821D0FF4; continue 'dispatch;
	}
	// 821D1040: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D1044: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D1048: 419A0040  beq cr6, 0x821d1088
	if ctx.cr[6].eq {
	pc = 0x821D1088; continue 'dispatch;
	}
	// 821D104C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1050: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 821D1054: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D1058: 41990008  bgt cr6, 0x821d1060
	if ctx.cr[6].gt {
	pc = 0x821D1060; continue 'dispatch;
	}
	// 821D105C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 821D1060: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D1064: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D1068: 409A0020  bne cr6, 0x821d1088
	if !ctx.cr[6].eq {
	pc = 0x821D1088; continue 'dispatch;
	}
	// 821D106C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D1070: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D1074: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D1078: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D107C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821D1080: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D1084: 4800001C  b 0x821d10a0
	pc = 0x821D10A0; continue 'dispatch;
	// 821D1088: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D108C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D1090: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821D1094: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D1098: 48000008  b 0x821d10a0
	pc = 0x821D10A0; continue 'dispatch;
	// 821D109C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 821D10A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D10A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D10A8: 419A0444  beq cr6, 0x821d14ec
	if ctx.cr[6].eq {
	pc = 0x821D14EC; continue 'dispatch;
	}
	// 821D10AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D10B0: 815B0010  lwz r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D10B4: 3BFB0010  addi r31, r27, 0x10
	ctx.r[31].s64 = ctx.r[27].s64 + 16;
	// 821D10B8: 3B8B9484  addi r28, r11, -0x6b7c
	ctx.r[28].s64 = ctx.r[11].s64 + -27516;
	// 821D10BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D10C0: C3EB9484  lfs f31, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821D10C4: 40990050  ble cr6, 0x821d1114
	if !ctx.cr[6].gt {
	pc = 0x821D1114; continue 'dispatch;
	}
	// 821D10C8: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 821D10CC: 4804E18D  bl 0x8221f258
	ctx.lr = 0x821D10D0;
	sub_8221F258(ctx, base);
	// 821D10D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D10D4: 419A002C  beq cr6, 0x821d1100
	if ctx.cr[6].eq {
	pc = 0x821D1100; continue 'dispatch;
	}
	// 821D10D8: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821D10DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D10E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821D10E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D10E8: 480B2B49  bl 0x82283c30
	ctx.lr = 0x821D10EC;
	sub_82283C30(ctx, base);
	// 821D10EC: 3BDB0008  addi r30, r27, 8
	ctx.r[30].s64 = ctx.r[27].s64 + 8;
	// 821D10F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D10F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D10F8: 480A1F61  bl 0x82273058
	ctx.lr = 0x821D10FC;
	sub_82273058(ctx, base);
	// 821D10FC: 480000AC  b 0x821d11a8
	pc = 0x821D11A8; continue 'dispatch;
	// 821D1100: 3BDB0008  addi r30, r27, 8
	ctx.r[30].s64 = ctx.r[27].s64 + 8;
	// 821D1104: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821D1108: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D110C: 480A1F4D  bl 0x82273058
	ctx.lr = 0x821D1110;
	sub_82273058(ctx, base);
	// 821D1110: 48000098  b 0x821d11a8
	pc = 0x821D11A8; continue 'dispatch;
	// 821D1114: 817B0018  lwz r11, 0x18(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D1118: 3BFB0018  addi r31, r27, 0x18
	ctx.r[31].s64 = ctx.r[27].s64 + 24;
	// 821D111C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D1120: 419A0020  beq cr6, 0x821d1140
	if ctx.cr[6].eq {
	pc = 0x821D1140; continue 'dispatch;
	}
	// 821D1124: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D1128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D112C: 419A0014  beq cr6, 0x821d1140
	if ctx.cr[6].eq {
	pc = 0x821D1140; continue 'dispatch;
	}
	// 821D1130: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D1134: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821D1138: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D113C: 409A0008  bne cr6, 0x821d1144
	if !ctx.cr[6].eq {
	pc = 0x821D1144; continue 'dispatch;
	}
	// 821D1140: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 821D1144: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D1148: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821D114C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D1150: 419A0038  beq cr6, 0x821d1188
	if ctx.cr[6].eq {
	pc = 0x821D1188; continue 'dispatch;
	}
	// 821D1154: 4809B5AD  bl 0x8226c700
	ctx.lr = 0x821D1158;
	sub_8226C700(ctx, base);
	// 821D1158: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 821D115C: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D1160: 3BDB0008  addi r30, r27, 8
	ctx.r[30].s64 = ctx.r[27].s64 + 8;
	// 821D1164: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D1168: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D116C: 4BFF56F5  bl 0x821c6860
	ctx.lr = 0x821D1170;
	sub_821C6860(ctx, base);
	// 821D1170: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821D1174: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821D1178: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D117C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821D1180: 480C5991  bl 0x82296b10
	ctx.lr = 0x821D1184;
	sub_82296B10(ctx, base);
	// 821D1184: 48000024  b 0x821d11a8
	pc = 0x821D11A8; continue 'dispatch;
	// 821D1188: 3BDB0008  addi r30, r27, 8
	ctx.r[30].s64 = ctx.r[27].s64 + 8;
	// 821D118C: 3BFB0014  addi r31, r27, 0x14
	ctx.r[31].s64 = ctx.r[27].s64 + 20;
	// 821D1190: 4809B571  bl 0x8226c700
	ctx.lr = 0x821D1194;
	sub_8226C700(ctx, base);
	// 821D1194: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D1198: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D119C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821D11A0: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821D11A4: 480C5CCD  bl 0x82296e70
	ctx.lr = 0x821D11A8;
	sub_82296E70(ctx, base);
	// 821D11A8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D11AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D11B0: 409A0174  bne cr6, 0x821d1324
	if !ctx.cr[6].eq {
	pc = 0x821D1324; continue 'dispatch;
	}
	// 821D11B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821D11B8: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 821D11BC: 4809B545  bl 0x8226c700
	ctx.lr = 0x821D11C0;
	sub_8226C700(ctx, base);
	// 821D11C0: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821D11C4: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 821D11C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D11CC: 419A00F0  beq cr6, 0x821d12bc
	if ctx.cr[6].eq {
	pc = 0x821D12BC; continue 'dispatch;
	}
	// 821D11D0: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D11D4: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D11D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D11DC: 419A0020  beq cr6, 0x821d11fc
	if ctx.cr[6].eq {
	pc = 0x821D11FC; continue 'dispatch;
	}
	// 821D11E0: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821D11E4: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821D11E8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821D11EC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D11F0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821D11F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D11F8: 480000C8  b 0x821d12c0
	pc = 0x821D12C0; continue 'dispatch;
	// 821D11FC: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D1200: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 821D1204: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D1208: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D120C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D1210: 40810054  ble 0x821d1264
	if !ctx.cr[0].gt {
	pc = 0x821D1264; continue 'dispatch;
	}
	// 821D1214: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D1218: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D121C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821D1220: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1224: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 821D1228: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D122C: 41980008  blt cr6, 0x821d1234
	if ctx.cr[6].lt {
	pc = 0x821D1234; continue 'dispatch;
	}
	// 821D1230: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 821D1234: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D1238: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D123C: 419A0014  beq cr6, 0x821d1250
	if ctx.cr[6].eq {
	pc = 0x821D1250; continue 'dispatch;
	}
	// 821D1240: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D1244: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D1248: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D124C: 4800000C  b 0x821d1258
	pc = 0x821D1258; continue 'dispatch;
	// 821D1250: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D1254: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821D1258: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D125C: 4199FFB8  bgt cr6, 0x821d1214
	if ctx.cr[6].gt {
	pc = 0x821D1214; continue 'dispatch;
	}
	// 821D1260: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D1264: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D1268: 419A0040  beq cr6, 0x821d12a8
	if ctx.cr[6].eq {
	pc = 0x821D12A8; continue 'dispatch;
	}
	// 821D126C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1270: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 821D1274: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D1278: 41990008  bgt cr6, 0x821d1280
	if ctx.cr[6].gt {
	pc = 0x821D1280; continue 'dispatch;
	}
	// 821D127C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 821D1280: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D1284: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D1288: 409A0020  bne cr6, 0x821d12a8
	if !ctx.cr[6].eq {
	pc = 0x821D12A8; continue 'dispatch;
	}
	// 821D128C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D1290: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D1294: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D1298: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D129C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821D12A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D12A4: 4800001C  b 0x821d12c0
	pc = 0x821D12C0; continue 'dispatch;
	// 821D12A8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D12AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D12B0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821D12B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D12B8: 48000008  b 0x821d12c0
	pc = 0x821D12C0; continue 'dispatch;
	// 821D12BC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 821D12C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D12C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D12C8: 419A005C  beq cr6, 0x821d1324
	if ctx.cr[6].eq {
	pc = 0x821D1324; continue 'dispatch;
	}
	// 821D12CC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821D12D0: 38BB0014  addi r5, r27, 0x14
	ctx.r[5].s64 = ctx.r[27].s64 + 20;
	// 821D12D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D12D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D12DC: 48250475  bl 0x82421750
	ctx.lr = 0x821D12E0;
	sub_82421750(ctx, base);
	// 821D12E0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D12E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D12E8: 419A003C  beq cr6, 0x821d1324
	if ctx.cr[6].eq {
	pc = 0x821D1324; continue 'dispatch;
	}
	// 821D12EC: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 821D12F0: 4804DF69  bl 0x8221f258
	ctx.lr = 0x821D12F4;
	sub_8221F258(ctx, base);
	// 821D12F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D12F8: 419A0020  beq cr6, 0x821d1318
	if ctx.cr[6].eq {
	pc = 0x821D1318; continue 'dispatch;
	}
	// 821D12FC: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821D1300: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D1304: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D1308: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D130C: 480B2925  bl 0x82283c30
	ctx.lr = 0x821D1310;
	sub_82283C30(ctx, base);
	// 821D1310: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D1314: 48000008  b 0x821d131c
	pc = 0x821D131C; continue 'dispatch;
	// 821D1318: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821D131C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D1320: 480A1D39  bl 0x82273058
	ctx.lr = 0x821D1324;
	sub_82273058(ctx, base);
	// 821D1324: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D132C: 409A0058  bne cr6, 0x821d1384
	if !ctx.cr[6].eq {
	pc = 0x821D1384; continue 'dispatch;
	}
	// 821D1330: 38BB0014  addi r5, r27, 0x14
	ctx.r[5].s64 = ctx.r[27].s64 + 20;
	// 821D1334: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D1338: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D133C: 480D0955  bl 0x822a1c90
	ctx.lr = 0x821D1340;
	sub_822A1C90(ctx, base);
	// 821D1340: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D1344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D1348: 419A003C  beq cr6, 0x821d1384
	if ctx.cr[6].eq {
	pc = 0x821D1384; continue 'dispatch;
	}
	// 821D134C: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 821D1350: 4804DF09  bl 0x8221f258
	ctx.lr = 0x821D1354;
	sub_8221F258(ctx, base);
	// 821D1354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D1358: 419A0020  beq cr6, 0x821d1378
	if ctx.cr[6].eq {
	pc = 0x821D1378; continue 'dispatch;
	}
	// 821D135C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821D1360: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D1364: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D1368: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D136C: 480B28C5  bl 0x82283c30
	ctx.lr = 0x821D1370;
	sub_82283C30(ctx, base);
	// 821D1370: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D1374: 48000008  b 0x821d137c
	pc = 0x821D137C; continue 'dispatch;
	// 821D1378: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821D137C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D1380: 480A1CD9  bl 0x82273058
	ctx.lr = 0x821D1384;
	sub_82273058(ctx, base);
	// 821D1384: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1388: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D138C: 419A0160  beq cr6, 0x821d14ec
	if ctx.cr[6].eq {
	pc = 0x821D14EC; continue 'dispatch;
	}
	// 821D1390: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821D1394: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D1398: 892BEC1B  lbz r9, -0x13e5(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-5093 as u32) ) } as u64;
	// 821D139C: C3EA0040  lfs f31, 0x40(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821D13A0: C3CA0044  lfs f30, 0x44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821D13A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D13A8: 419A000C  beq cr6, 0x821d13b4
	if ctx.cr[6].eq {
	pc = 0x821D13B4; continue 'dispatch;
	}
	// 821D13AC: C3FCFE50  lfs f31, -0x1b0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-432 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821D13B0: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 821D13B4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821D13B8: 4804DEA1  bl 0x8221f258
	ctx.lr = 0x821D13BC;
	sub_8221F258(ctx, base);
	// 821D13BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D13C0: 419A0014  beq cr6, 0x821d13d4
	if ctx.cr[6].eq {
	pc = 0x821D13D4; continue 'dispatch;
	}
	// 821D13C4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D13C8: 480BA779  bl 0x8228bb40
	ctx.lr = 0x821D13CC;
	sub_8228BB40(ctx, base);
	// 821D13CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D13D0: 48000008  b 0x821d13d8
	pc = 0x821D13D8; continue 'dispatch;
	// 821D13D4: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 821D13D8: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821D13DC: 4804DE7D  bl 0x8221f258
	ctx.lr = 0x821D13E0;
	sub_8221F258(ctx, base);
	// 821D13E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D13E4: 419A0014  beq cr6, 0x821d13f8
	if ctx.cr[6].eq {
	pc = 0x821D13F8; continue 'dispatch;
	}
	// 821D13E8: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821D13EC: 4805834D  bl 0x82229738
	ctx.lr = 0x821D13F0;
	sub_82229738(ctx, base);
	// 821D13F0: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821D13F4: 48000008  b 0x821d13fc
	pc = 0x821D13FC; continue 'dispatch;
	// 821D13F8: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 821D13FC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 821D1400: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1404: 38C00080  li r6, 0x80
	ctx.r[6].s64 = 128;
	// 821D1408: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D140C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821D1410: 4BFFCD31  bl 0x821ce140
	ctx.lr = 0x821D1414;
	sub_821CE140(ctx, base);
	// 821D1414: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D1418: 807B002C  lwz r3, 0x2c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D141C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1420: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821D1424: 419A0078  beq cr6, 0x821d149c
	if ctx.cr[6].eq {
	pc = 0x821D149C; continue 'dispatch;
	}
	// 821D1428: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D142C: 419A0040  beq cr6, 0x821d146c
	if ctx.cr[6].eq {
	pc = 0x821D146C; continue 'dispatch;
	}
	// 821D1430: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 821D1434: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821D1438: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D143C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821D1440: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D1444: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821D1448: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D144C: 4082FFE8  bne 0x821d1434
	if !ctx.cr[0].eq {
	pc = 0x821D1434; continue 'dispatch;
	}
	// 821D1450: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D1454: 409A0014  bne cr6, 0x821d1468
	if !ctx.cr[6].eq {
	pc = 0x821D1468; continue 'dispatch;
	}
	// 821D1458: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D145C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D1460: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D1464: 4E800421  bctrl
	ctx.lr = 0x821D1468;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D1468: 933B002C  stw r25, 0x2c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(44 as u32), ctx.r[25].u32 ) };
	// 821D146C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1470: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D1474: 917B002C  stw r11, 0x2c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 821D1478: 419A0024  beq cr6, 0x821d149c
	if ctx.cr[6].eq {
	pc = 0x821D149C; continue 'dispatch;
	}
	// 821D147C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821D1480: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821D1484: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D1488: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821D148C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821D1490: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821D1494: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D1498: 4082FFE8  bne 0x821d1480
	if !ctx.cr[0].eq {
	pc = 0x821D1480; continue 'dispatch;
	}
	// 821D149C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821D14A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D14A4: 419A0048  beq cr6, 0x821d14ec
	if ctx.cr[6].eq {
	pc = 0x821D14EC; continue 'dispatch;
	}
	// 821D14A8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821D14AC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 821D14B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821D14B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D14B8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821D14BC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821D14C0: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821D14C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D14C8: 4082FFE8  bne 0x821d14b0
	if !ctx.cr[0].eq {
	pc = 0x821D14B0; continue 'dispatch;
	}
	// 821D14CC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821D14D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D14D4: 409A0014  bne cr6, 0x821d14e8
	if !ctx.cr[6].eq {
	pc = 0x821D14E8; continue 'dispatch;
	}
	// 821D14D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D14DC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D14E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D14E4: 4E800421  bctrl
	ctx.lr = 0x821D14E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D14E8: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 821D14EC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821D14F0: 480A03B9  bl 0x822718a8
	ctx.lr = 0x821D14F4;
	sub_822718A8(ctx, base);
	// 821D14F4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821D14F8: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821D14FC: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 821D1500: 48AD7F48  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D1508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D1508 size=24
    let mut pc: u32 = 0x821D1508;
    'dispatch: loop {
        match pc {
            0x821D1508 => {
    //   block [0x821D1508..0x821D1520)
	// 821D1508: 3D607F10  lis r11, 0x7f10
	ctx.r[11].s64 = 2131755008;
	// 821D150C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D1510: 41980010  blt cr6, 0x821d1520
	if ctx.cr[6].lt {
		sub_821D1520(ctx, base);
		return;
	}
	// 821D1514: 3D608700  lis r11, -0x7900
	ctx.r[11].s64 = -2030043136;
	// 821D1518: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D151C: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D1520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821D1520 size=140
    let mut pc: u32 = 0x821D1520;
    'dispatch: loop {
        match pc {
            0x821D1520 => {
    //   block [0x821D1520..0x821D15AC)
	// 821D1520: 3944007F  addi r10, r4, 0x7f
	ctx.r[10].s64 = ctx.r[4].s64 + 127;
	// 821D1524: 546B0030  rlwinm r11, r3, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 821D1528: 554A0030  rlwinm r10, r10, 0, 0, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821D152C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D1530: 7D4A3E70  srawi r10, r10, 7
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 7) as i64;
	// 821D1534: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 821D1538: 5549E8FF  rlwinm. r9, r10, 0x1d, 3, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821D153C: 554A077E  clrlwi r10, r10, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 821D1540: 4182004C  beq 0x821d158c
	if ctx.cr[0].eq {
	pc = 0x821D158C; continue 'dispatch;
	}
	// 821D1544: 7C0058AC  dcbf 0, r11
	// 821D1548: 39000080  li r8, 0x80
	ctx.r[8].s64 = 128;
	// 821D154C: 7C0858AC  dcbf r8, r11
	// 821D1550: 39000100  li r8, 0x100
	ctx.r[8].s64 = 256;
	// 821D1554: 7C0858AC  dcbf r8, r11
	// 821D1558: 39000180  li r8, 0x180
	ctx.r[8].s64 = 384;
	// 821D155C: 7C0858AC  dcbf r8, r11
	// 821D1560: 39000200  li r8, 0x200
	ctx.r[8].s64 = 512;
	// 821D1564: 7C0858AC  dcbf r8, r11
	// 821D1568: 39000280  li r8, 0x280
	ctx.r[8].s64 = 640;
	// 821D156C: 7C0858AC  dcbf r8, r11
	// 821D1570: 39000300  li r8, 0x300
	ctx.r[8].s64 = 768;
	// 821D1574: 7C0858AC  dcbf r8, r11
	// 821D1578: 39000380  li r8, 0x380
	ctx.r[8].s64 = 896;
	// 821D157C: 7C0858AC  dcbf r8, r11
	// 821D1580: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821D1584: 396B0400  addi r11, r11, 0x400
	ctx.r[11].s64 = ctx.r[11].s64 + 1024;
	// 821D1588: 4082FFBC  bne 0x821d1544
	if !ctx.cr[0].eq {
	pc = 0x821D1544; continue 'dispatch;
	}
	// 821D158C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D1590: 419A0014  beq cr6, 0x821d15a4
	if ctx.cr[6].eq {
	pc = 0x821D15A4; continue 'dispatch;
	}
	// 821D1594: 7C0058AC  dcbf 0, r11
	// 821D1598: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821D159C: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821D15A0: 4082FFF4  bne 0x821d1594
	if !ctx.cr[0].eq {
	pc = 0x821D1594; continue 'dispatch;
	}
	// 821D15A4: 7C0004AC  sync
	// 821D15A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D15B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D15B0 size=276
    let mut pc: u32 = 0x821D15B0;
    'dispatch: loop {
        match pc {
            0x821D15B0 => {
    //   block [0x821D15B0..0x821D16C4)
	// 821D15B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D15B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D15B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D15BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D15C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D15C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D15C8: 3FC04000  lis r30, 0x4000
	ctx.r[30].s64 = 1073741824;
	// 821D15CC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D15D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D15D4: 419A0024  beq cr6, 0x821d15f8
	if ctx.cr[6].eq {
	pc = 0x821D15F8; continue 'dispatch;
	}
	// 821D15D8: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D15DC: 552A653E  srwi r10, r9, 0x14
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shr(20);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D15E0: 552900FE  clrlwi r9, r9, 3
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x1FFFFFFFu64;
	// 821D15E4: 394A0200  addi r10, r10, 0x200
	ctx.r[10].s64 = ctx.r[10].s64 + 512;
	// 821D15E8: 554A04E6  rlwinm r10, r10, 0, 0x13, 0x13
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821D15EC: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821D15F0: 7D5E5050  subf r10, r30, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[30].s64;
	// 821D15F4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821D15F8: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 821D15FC: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D1600: 38800420  li r4, 0x420
	ctx.r[4].s64 = 1056;
	// 821D1604: 480350E5  bl 0x822066e8
	ctx.lr = 0x821D1608;
	sub_822066E8(ctx, base);
	// 821D1608: 7C671B79  or. r7, r3, r3
	ctx.r[7].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821D160C: 40820018  bne 0x821d1624
	if !ctx.cr[0].eq {
	pc = 0x821D1624; continue 'dispatch;
	}
	// 821D1610: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D1614: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821D1618: 80EB4158  lwz r7, 0x4158(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16728 as u32) ) } as u64;
	// 821D161C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821D1620: 48000078  b 0x821d1698
	pc = 0x821D1698; continue 'dispatch;
	// 821D1624: 39670004  addi r11, r7, 4
	ctx.r[11].s64 = ctx.r[7].s64 + 4;
	// 821D1628: 5569653E  srwi r9, r11, 0x14
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(20);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821D162C: 556A00FE  clrlwi r10, r11, 3
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 821D1630: 39690200  addi r11, r9, 0x200
	ctx.r[11].s64 = ctx.r[9].s64 + 512;
	// 821D1634: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D1638: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821D163C: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 821D1640: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821D1644: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D1648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D164C: 419A0024  beq cr6, 0x821d1670
	if ctx.cr[6].eq {
	pc = 0x821D1670; continue 'dispatch;
	}
	// 821D1650: 54EA653E  srwi r10, r7, 0x14
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shr(20);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D1654: 54E900FE  clrlwi r9, r7, 3
	ctx.r[9].u64 = ctx.r[7].u32 as u64 & 0x1FFFFFFFu64;
	// 821D1658: 394A0200  addi r10, r10, 0x200
	ctx.r[10].s64 = ctx.r[10].s64 + 512;
	// 821D165C: 554A04E6  rlwinm r10, r10, 0, 0x13, 0x13
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821D1660: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821D1664: 7D5E5050  subf r10, r30, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[30].s64;
	// 821D1668: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821D166C: 48000008  b 0x821d1674
	pc = 0x821D1674; continue 'dispatch;
	// 821D1670: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821D1674: 54EB653E  srwi r11, r7, 0x14
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shr(20);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D1678: 54EA00FE  clrlwi r10, r7, 3
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x1FFFFFFFu64;
	// 821D167C: 396B0200  addi r11, r11, 0x200
	ctx.r[11].s64 = ctx.r[11].s64 + 512;
	// 821D1680: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D1684: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D1688: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821D168C: 7C7E5850  subf r3, r30, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 821D1690: 38831080  addi r4, r3, 0x1080
	ctx.r[4].s64 = ctx.r[3].s64 + 4224;
	// 821D1694: 4BFFFE75  bl 0x821d1508
	ctx.lr = 0x821D1698;
	sub_821D1508(ctx, base);
	// 821D1698: 38670004  addi r3, r7, 4
	ctx.r[3].s64 = ctx.r[7].s64 + 4;
	// 821D169C: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821D16A0: 3967107C  addi r11, r7, 0x107c
	ctx.r[11].s64 = ctx.r[7].s64 + 4220;
	// 821D16A4: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 821D16A8: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 821D16AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D16B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D16B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D16B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D16BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D16C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D16C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D16C8 size=176
    let mut pc: u32 = 0x821D16C8;
    'dispatch: loop {
        match pc {
            0x821D16C8 => {
    //   block [0x821D16C8..0x821D1778)
	// 821D16C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D16CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D16D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D16D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D16D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D16DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D16E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D16E4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D16E8: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D16EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D16F0: 409A0070  bne cr6, 0x821d1760
	if !ctx.cr[6].eq {
	pc = 0x821D1760; continue 'dispatch;
	}
	// 821D16F4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821D16F8: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 821D16FC: 806B6F1C  lwz r3, 0x6f1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28444 as u32) ) } as u64;
	// 821D1700: 48A19AE1  bl 0x82beb1e0
	ctx.lr = 0x821D1704;
	sub_82BEB1E0(ctx, base);
	// 821D1704: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D1708: 419A0044  beq cr6, 0x821d174c
	if ctx.cr[6].eq {
	pc = 0x821D174C; continue 'dispatch;
	}
	// 821D170C: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821D1710: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821D1714: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D1718: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 821D171C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821D1720: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D1724: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 821D1728: 38E86E98  addi r7, r8, 0x6e98
	ctx.r[7].s64 = ctx.r[8].s64 + 28312;
	// 821D172C: 81496F18  lwz r10, 0x6f18(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28440 as u32) ) } as u64;
	// 821D1730: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821D1734: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821D1738: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 821D173C: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821D1740: 91696F18  stw r11, 0x6f18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28440 as u32), ctx.r[11].u32 ) };
	// 821D1744: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 821D1748: 48000008  b 0x821d1750
	pc = 0x821D1750; continue 'dispatch;
	// 821D174C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821D1750: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1754: C03F0274  lfs f1, 0x274(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821D1758: 386B00A8  addi r3, r11, 0xa8
	ctx.r[3].s64 = ctx.r[11].s64 + 168;
	// 821D175C: 4805AB55  bl 0x8222c2b0
	ctx.lr = 0x821D1760;
	sub_8222C2B0(ctx, base);
	// 821D1760: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D1764: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D1768: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D176C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D1770: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D1774: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D1778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D1778 size=8
    let mut pc: u32 = 0x821D1778;
    'dispatch: loop {
        match pc {
            0x821D1778 => {
    //   block [0x821D1778..0x821D1780)
	// 821D1778: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D177C: 48000014  b 0x821d1790
	sub_821D1790(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D1780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D1780 size=16
    let mut pc: u32 = 0x821D1780;
    'dispatch: loop {
        match pc {
            0x821D1780 => {
    //   block [0x821D1780..0x821D1790)
	// 821D1780: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821D1784: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D1788: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821D178C: 4BFF8E5C  b 0x821ca5e8
	sub_821CA5E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D1790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D1790 size=836
    let mut pc: u32 = 0x821D1790;
    'dispatch: loop {
        match pc {
            0x821D1790 => {
    //   block [0x821D1790..0x821D1AD4)
	// 821D1790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D1794: 48AD7C71  bl 0x82ca9404
	ctx.lr = 0x821D1798;
	sub_82CA93D0(ctx, base);
	// 821D1798: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D179C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D17A0: 38600099  li r3, 0x99
	ctx.r[3].s64 = 153;
	// 821D17A4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821D17A8: 4805AA69  bl 0x8222c210
	ctx.lr = 0x821D17AC;
	sub_8222C210(ctx, base);
	// 821D17AC: 3860009A  li r3, 0x9a
	ctx.r[3].s64 = 154;
	// 821D17B0: 48037361  bl 0x82208b10
	ctx.lr = 0x821D17B4;
	sub_82208B10(ctx, base);
	// 821D17B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D17B8: 4BFE8B81  bl 0x821ba338
	ctx.lr = 0x821D17BC;
	sub_821BA338(ctx, base);
	// 821D17BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D17C0: 4BFE8CD9  bl 0x821ba498
	ctx.lr = 0x821D17C4;
	sub_821BA498(ctx, base);
	// 821D17C4: 39600690  li r11, 0x690
	ctx.r[11].s64 = 1680;
	// 821D17C8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821D17CC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D17D0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D1AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D1AD8 size=12
    let mut pc: u32 = 0x821D1AD8;
    'dispatch: loop {
        match pc {
            0x821D1AD8 => {
    //   block [0x821D1AD8..0x821D1AE4)
	// 821D1AD8: 80630038  lwz r3, 0x38(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 821D1ADC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D1AE0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D1AE4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D1AE4 size=16
    let mut pc: u32 = 0x821D1AE4;
    'dispatch: loop {
        match pc {
            0x821D1AE4 => {
    //   block [0x821D1AE4..0x821D1AF4)
	// 821D1AE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1AE8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D1AEC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D1AF0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D1AF4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D1AF4 size=4
    let mut pc: u32 = 0x821D1AF4;
    'dispatch: loop {
        match pc {
            0x821D1AF4 => {
    //   block [0x821D1AF4..0x821D1AF8)
	// 821D1AF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D1AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D1AF8 size=420
    let mut pc: u32 = 0x821D1AF8;
    'dispatch: loop {
        match pc {
            0x821D1AF8 => {
    //   block [0x821D1AF8..0x821D1C9C)
	// 821D1AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D1AFC: 48AD790D  bl 0x82ca9408
	ctx.lr = 0x821D1B00;
	sub_82CA93D0(ctx, base);
	// 821D1B00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D1B04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D1B08: 897F2ABD  lbz r11, 0x2abd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10941 as u32) ) } as u64;
	// 821D1B0C: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D1B10: 41820010  beq 0x821d1b20
	if ctx.cr[0].eq {
	pc = 0x821D1B20; continue 'dispatch;
	}
	// 821D1B14: 489D0A35  bl 0x82ba2548
	ctx.lr = 0x821D1B18;
	sub_82BA2548(ctx, base);
	// 821D1B18: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D1B1C: 48000178  b 0x821d1c94
	pc = 0x821D1C94; continue 'dispatch;
	// 821D1B20: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821D1B24: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821D1B28: 409A000C  bne cr6, 0x821d1b34
	if !ctx.cr[6].eq {
	pc = 0x821D1B34; continue 'dispatch;
	}
	// 821D1B2C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821D1B30: 4800000C  b 0x821d1b3c
	pc = 0x821D1B3C; continue 'dispatch;
	// 821D1B34: 3964000E  addi r11, r4, 0xe
	ctx.r[11].s64 = ctx.r[4].s64 + 14;
	// 821D1B38: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D1B3C: 83DF34CC  lwz r30, 0x34cc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13516 as u32) ) } as u64;
	// 821D1B40: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821D1B44: 419A0020  beq cr6, 0x821d1b64
	if ctx.cr[6].eq {
	pc = 0x821D1B64; continue 'dispatch;
	}
	// 821D1B48: 815E00AC  lwz r10, 0xac(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(172 as u32) ) } as u64;
	// 821D1B4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D1B50: 419A0014  beq cr6, 0x821d1b64
	if ctx.cr[6].eq {
	pc = 0x821D1B64; continue 'dispatch;
	}
	// 821D1B54: 815F3A40  lwz r10, 0x3a40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14912 as u32) ) } as u64;
	// 821D1B58: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D1B5C: 41990008  bgt cr6, 0x821d1b64
	if ctx.cr[6].gt {
	pc = 0x821D1B64; continue 'dispatch;
	}
	// 821D1B60: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821D1B64: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821D1B68: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821D1B6C: 40820020  bne 0x821d1b8c
	if !ctx.cr[0].eq {
	pc = 0x821D1B8C; continue 'dispatch;
	}
	// 821D1B70: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 821D1B74: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D1B78: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821D1B7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D1B80: 48034939  bl 0x822064b8
	ctx.lr = 0x821D1B84;
	sub_822064B8(ctx, base);
	// 821D1B84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D1B88: 48000094  b 0x821d1c1c
	pc = 0x821D1C1C; continue 'dispatch;
	// 821D1B8C: 817E0098  lwz r11, 0x98(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 821D1B90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D1B94: 419A0030  beq cr6, 0x821d1bc4
	if ctx.cr[6].eq {
	pc = 0x821D1BC4; continue 'dispatch;
	}
	// 821D1B98: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821D1B9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D1BA0: 419A000C  beq cr6, 0x821d1bac
	if ctx.cr[6].eq {
	pc = 0x821D1BAC; continue 'dispatch;
	}
	// 821D1BA4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 821D1BA8: 4800007C  b 0x821d1c24
	pc = 0x821D1C24; continue 'dispatch;
	// 821D1BAC: 817E0098  lwz r11, 0x98(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 821D1BB0: 917F3A50  stw r11, 0x3a50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(14928 as u32), ctx.r[11].u32 ) };
	// 821D1BB4: 817E009C  lwz r11, 0x9c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(156 as u32) ) } as u64;
	// 821D1BB8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821D1BBC: 83DE0098  lwz r30, 0x98(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 821D1BC0: 4800005C  b 0x821d1c1c
	pc = 0x821D1C1C; continue 'dispatch;
	// 821D1BC4: 490E7D81  bl 0x832b9944
	ctx.lr = 0x821D1BC8;
	// extern call 0x832B9944 → crate::xboxkrnl::KeGetCurrentProcessType
	crate::xboxkrnl::KeGetCurrentProcessType(ctx, base);
	// 821D1BC8: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 821D1BCC: 409A0010  bne cr6, 0x821d1bdc
	if !ctx.cr[6].eq {
	pc = 0x821D1BDC; continue 'dispatch;
	}
	// 821D1BD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D1BD4: 816B09AC  lwz r11, 0x9ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2476 as u32) ) } as u64;
	// 821D1BD8: 4800000C  b 0x821d1be4
	pc = 0x821D1BE4; continue 'dispatch;
	// 821D1BDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D1BE0: 816B09B0  lwz r11, 0x9b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2480 as u32) ) } as u64;
	// 821D1BE4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1BE8: 3BAB3A7C  addi r29, r11, 0x3a7c
	ctx.r[29].s64 = ctx.r[11].s64 + 14972;
	// 821D1BEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D1BF0: 490E7D75  bl 0x832b9964
	ctx.lr = 0x821D1BF4;
	// extern call 0x832B9964 → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 821D1BF4: 807E00A4  lwz r3, 0xa4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(164 as u32) ) } as u64;
	// 821D1BF8: 817E00AC  lwz r11, 0xac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(172 as u32) ) } as u64;
	// 821D1BFC: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 821D1C00: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D1C04: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821D1C08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821D1C0C: 4E800421  bctrl
	ctx.lr = 0x821D1C10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D1C10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D1C14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D1C18: 490E7D3D  bl 0x832b9954
	ctx.lr = 0x821D1C1C;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 821D1C1C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821D1C20: 409A0010  bne cr6, 0x821d1c30
	if !ctx.cr[6].eq {
	pc = 0x821D1C30; continue 'dispatch;
	}
	// 821D1C24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D1C28: 489D0921  bl 0x82ba2548
	ctx.lr = 0x821D1C2C;
	sub_82BA2548(ctx, base);
	// 821D1C2C: 48000038  b 0x821d1c64
	pc = 0x821D1C64; continue 'dispatch;
	// 821D1C30: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D1C34: 397EFFFC  addi r11, r30, -4
	ctx.r[11].s64 = ctx.r[30].s64 + -4;
	// 821D1C38: 93DF3A50  stw r30, 0x3a50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(14928 as u32), ctx.r[30].u32 ) };
	// 821D1C3C: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D1C40: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 821D1C44: 939F3A44  stw r28, 0x3a44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(14916 as u32), ctx.r[28].u32 ) };
	// 821D1C48: 394AFFF2  addi r10, r10, -0xe
	ctx.r[10].s64 = ctx.r[10].s64 + -14;
	// 821D1C4C: 939F3A54  stw r28, 0x3a54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(14932 as u32), ctx.r[28].u32 ) };
	// 821D1C50: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D1C54: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D1C58: 394BFF60  addi r10, r11, -0xa0
	ctx.r[10].s64 = ctx.r[11].s64 + -160;
	// 821D1C5C: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 821D1C60: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 821D1C64: 817F5DAC  lwz r11, 0x5dac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(23980 as u32) ) } as u64;
	// 821D1C68: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D1C6C: 40820024  bne 0x821d1c90
	if !ctx.cr[0].eq {
	pc = 0x821D1C90; continue 'dispatch;
	}
	// 821D1C70: 809F3A5C  lwz r4, 0x3a5c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14940 as u32) ) } as u64;
	// 821D1C74: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821D1C78: 419A0018  beq cr6, 0x821d1c90
	if ctx.cr[6].eq {
	pc = 0x821D1C90; continue 'dispatch;
	}
	// 821D1C7C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821D1C80: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 821D1C84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D1C88: 480709E1  bl 0x82242668
	ctx.lr = 0x821D1C8C;
	sub_82242668(ctx, base);
	// 821D1C8C: 939F3A5C  stw r28, 0x3a5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(14940 as u32), ctx.r[28].u32 ) };
	// 821D1C90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D1C94: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D1C98: 48AD77C0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D1CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D1CA0 size=820
    let mut pc: u32 = 0x821D1CA0;
    'dispatch: loop {
        match pc {
            0x821D1CA0 => {
    //   block [0x821D1CA0..0x821D1FD4)
	// 821D1CA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D1CA4: 48AD7759  bl 0x82ca93fc
	ctx.lr = 0x821D1CA8;
	sub_82CA93D0(ctx, base);
	// 821D1CA8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821D1CAC: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D1CB0: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821D1CB4: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821D1CB8: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 821D1CBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D1CC0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821D1CC4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821D1CC8: 91686E88  stw r11, 0x6e88(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28296 as u32), ctx.r[11].u32 ) };
	// 821D1CCC: 91476E8C  stw r10, 0x6e8c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(28300 as u32), ctx.r[10].u32 ) };
	// 821D1CD0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821D1CD4: 91266E90  stw r9, 0x6e90(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28304 as u32), ctx.r[9].u32 ) };
	// 821D1CD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D1CDC: 3BEB4D60  addi r31, r11, 0x4d60
	ctx.r[31].s64 = ctx.r[11].s64 + 19808;
	// 821D1CE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D1CE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D1CE8: 48003941  bl 0x821d5628
	ctx.lr = 0x821D1CEC;
	sub_821D5628(ctx, base);
	// 821D1CEC: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 821D1CF0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D1CF4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821D1CF8: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D1CFC: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D1D00: C81B6E18  lfd f0, 0x6e18(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(28184 as u32) ) };
	// 821D1D04: 7CA41671  srawi. r4, r5, 2
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[5].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821D1D08: FFE00018  frsp f31, f0
	ctx.f[31].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821D1D0C: 41820048  beq 0x821d1d54
	if ctx.cr[0].eq {
	pc = 0x821D1D54; continue 'dispatch;
	}
	// 821D1D10: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821D1D14: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821D1D18: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D1D1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D1D20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1D24: 814B0064  lwz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 821D1D28: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D1D2C: 4E800421  bctrl
	ctx.lr = 0x821D1D30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D1D30: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D1D34: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D1D38: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821D1D3C: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 821D1D40: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D1D44: 7D281670  srawi r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 821D1D48: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821D1D4C: 4198FFC8  blt cr6, 0x821d1d14
	if ctx.cr[6].lt {
	pc = 0x821D1D14; continue 'dispatch;
	}
	// 821D1D50: C81B6E18  lfd f0, 0x6e18(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(28184 as u32) ) };
	// 821D1D54: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D1D58: FFE00018  frsp f31, f0
	ctx.f[31].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821D1D5C: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D1D60: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821D1D64: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D1D68: 7D491671  srawi. r9, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821D1D6C: 41820044  beq 0x821d1db0
	if ctx.cr[0].eq {
	pc = 0x821D1DB0; continue 'dispatch;
	}
	// 821D1D70: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821D1D74: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821D1D78: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D1D7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D1D80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1D84: 814B0064  lwz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 821D1D88: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D1D8C: 4E800421  bctrl
	ctx.lr = 0x821D1D90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D1D90: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D1D94: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D1D98: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821D1D9C: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 821D1DA0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D1DA4: 7D281670  srawi r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 821D1DA8: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821D1DAC: 4198FFC8  blt cr6, 0x821d1d74
	if ctx.cr[6].lt {
	pc = 0x821D1D74; continue 'dispatch;
	}
	// 821D1DB0: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D1DB4: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 821D1DB8: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821D1DBC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D1DC0: 394B0010  addi r10, r11, 0x10
	ctx.r[10].s64 = ctx.r[11].s64 + 16;
	// 821D1DC4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D1DC8: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 821D1DCC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D1DD0: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 821D1DD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D1FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D1FD8 size=568
    let mut pc: u32 = 0x821D1FD8;
    'dispatch: loop {
        match pc {
            0x821D1FD8 => {
    //   block [0x821D1FD8..0x821D2210)
	// 821D1FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D1FDC: 48AD7431  bl 0x82ca940c
	ctx.lr = 0x821D1FE0;
	sub_82CA93D0(ctx, base);
	// 821D1FE0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821D1FE4: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D2210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D2210 size=84
    let mut pc: u32 = 0x821D2210;
    'dispatch: loop {
        match pc {
            0x821D2210 => {
    //   block [0x821D2210..0x821D2264)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D2268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D2268 size=312
    let mut pc: u32 = 0x821D2268;
    'dispatch: loop {
        match pc {
            0x821D2268 => {
    //   block [0x821D2268..0x821D23A0)
	// 821D2268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D226C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D2270: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D2274: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D23A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D23A0 size=424
    let mut pc: u32 = 0x821D23A0;
    'dispatch: loop {
        match pc {
            0x821D23A0 => {
    //   block [0x821D23A0..0x821D2548)
	// 821D23A0: 3961FF60  addi r11, r1, -0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + -160;
	// 821D23A4: 3941FFB0  addi r10, r1, -0x50
	ctx.r[10].s64 = ctx.r[1].s64 + -80;
	// 821D23A8: 3921FFD0  addi r9, r1, -0x30
	ctx.r[9].s64 = ctx.r[1].s64 + -48;
	// 821D23AC: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 821D23B0: 38E1FF00  addi r7, r1, -0x100
	ctx.r[7].s64 = ctx.r[1].s64 + -256;
	// 821D23B4: 38C1FF80  addi r6, r1, -0x80
	ctx.r[6].s64 = ctx.r[1].s64 + -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D2548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D2548 size=8
    let mut pc: u32 = 0x821D2548;
    'dispatch: loop {
        match pc {
            0x821D2548 => {
    //   block [0x821D2548..0x821D2550)
	// 821D2548: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D254C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D2550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D2550 size=376
    let mut pc: u32 = 0x821D2550;
    'dispatch: loop {
        match pc {
            0x821D2550 => {
    //   block [0x821D2550..0x821D26C8)
	// 821D2550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D2554: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D2558: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D255C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D2560: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D2564: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D2568: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D256C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2570: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D2574: 409A000C  bne cr6, 0x821d2580
	if !ctx.cr[6].eq {
	pc = 0x821D2580; continue 'dispatch;
	}
	// 821D2578: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D257C: 48000134  b 0x821d26b0
	pc = 0x821D26B0; continue 'dispatch;
	// 821D2580: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D2584: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 821D2588: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D258C: 419A0078  beq cr6, 0x821d2604
	if ctx.cr[6].eq {
	pc = 0x821D2604; continue 'dispatch;
	}
	// 821D2590: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D2594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2598: 409A0064  bne cr6, 0x821d25fc
	if !ctx.cr[6].eq {
	pc = 0x821D25FC; continue 'dispatch;
	}
	// 821D259C: 817E004C  lwz r11, 0x4c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D25A0: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D25A4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D25A8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D25AC: 40810050  ble 0x821d25fc
	if !ctx.cr[0].gt {
	pc = 0x821D25FC; continue 'dispatch;
	}
	// 821D25B0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D25B4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D25B8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D25BC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D25C0: 2F07003B  cmpwi cr6, r7, 0x3b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 59, &mut ctx.xer);
	// 821D25C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D25C8: 41980008  blt cr6, 0x821d25d0
	if ctx.cr[6].lt {
	pc = 0x821D25D0; continue 'dispatch;
	}
	// 821D25CC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821D25D0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D25D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D25D8: 419A0014  beq cr6, 0x821d25ec
	if ctx.cr[6].eq {
	pc = 0x821D25EC; continue 'dispatch;
	}
	// 821D25DC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D25E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D25E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D25E8: 4800000C  b 0x821d25f4
	pc = 0x821D25F4; continue 'dispatch;
	// 821D25EC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D25F0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821D25F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D25F8: 4199FFB8  bgt cr6, 0x821d25b0
	if ctx.cr[6].gt {
	pc = 0x821D25B0; continue 'dispatch;
	}
	// 821D25FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D2600: 48000008  b 0x821d2608
	pc = 0x821D2608; continue 'dispatch;
	// 821D2604: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D2608: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D260C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2610: 419AFF68  beq cr6, 0x821d2578
	if ctx.cr[6].eq {
	pc = 0x821D2578; continue 'dispatch;
	}
	// 821D2614: 809E007C  lwz r4, 0x7c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 821D2618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D261C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2620: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821D2624: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D2628: 4E800421  bctrl
	ctx.lr = 0x821D262C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D262C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821D2630: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 821D2634: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 821D2638: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D26C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D26C8 size=332
    let mut pc: u32 = 0x821D26C8;
    'dispatch: loop {
        match pc {
            0x821D26C8 => {
    //   block [0x821D26C8..0x821D2814)
	// 821D26C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D26CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D26D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D26D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D26D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D26DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D26E0: 3BDF0078  addi r30, r31, 0x78
	ctx.r[30].s64 = ctx.r[31].s64 + 120;
	// 821D26E4: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821D26E8: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 821D26EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D26F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821D26F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821D26F8: 419A0020  beq cr6, 0x821d2718
	if ctx.cr[6].eq {
	pc = 0x821D2718; continue 'dispatch;
	}
	// 821D26FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821D2700: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D2704: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821D2708: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821D270C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821D2710: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D2714: 4082FFE8  bne 0x821d26fc
	if !ctx.cr[0].eq {
	pc = 0x821D26FC; continue 'dispatch;
	}
	// 821D2718: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D271C: 48098EE5  bl 0x8226b600
	ctx.lr = 0x821D2720;
	sub_8226B600(ctx, base);
	// 821D2720: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2724: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D2728: 419A00CC  beq cr6, 0x821d27f4
	if ctx.cr[6].eq {
	pc = 0x821D27F4; continue 'dispatch;
	}
	// 821D272C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2730: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D2734: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D2738: 4E800421  bctrl
	ctx.lr = 0x821D273C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D273C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D2740: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D2744: 419A00B0  beq cr6, 0x821d27f4
	if ctx.cr[6].eq {
	pc = 0x821D27F4; continue 'dispatch;
	}
	// 821D2748: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D274C: 480B3A5D  bl 0x822861a8
	ctx.lr = 0x821D2750;
	sub_822861A8(ctx, base);
	// 821D2750: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2754: 389F0070  addi r4, r31, 0x70
	ctx.r[4].s64 = ctx.r[31].s64 + 112;
	// 821D2758: 815F0070  lwz r10, 0x70(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 821D275C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821D2760: 419A0084  beq cr6, 0x821d27e4
	if ctx.cr[6].eq {
	pc = 0x821D27E4; continue 'dispatch;
	}
	// 821D2764: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 821D2768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D276C: 419A0058  beq cr6, 0x821d27c4
	if ctx.cr[6].eq {
	pc = 0x821D27C4; continue 'dispatch;
	}
	// 821D2770: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 821D2774: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821D2778: 419A0010  beq cr6, 0x821d2788
	if ctx.cr[6].eq {
	pc = 0x821D2788; continue 'dispatch;
	}
	// 821D277C: 813F0054  lwz r9, 0x54(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D2780: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821D2784: 40980040  bge cr6, 0x821d27c4
	if !ctx.cr[6].lt {
	pc = 0x821D27C4; continue 'dispatch;
	}
	// 821D2788: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D278C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821D2790: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821D2794: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D2798: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821D279C: 4E800421  bctrl
	ctx.lr = 0x821D27A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D27A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D27A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D27A8: 4BFA8BF1  bl 0x8217b398
	ctx.lr = 0x821D27AC;
	sub_8217B398(ctx, base);
	// 821D27AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821D27B0: 4BFE5369  bl 0x821b7b18
	ctx.lr = 0x821D27B4;
	sub_821B7B18(ctx, base);
	// 821D27B4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D27B8: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 821D27BC: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821D27C0: 4800000C  b 0x821d27cc
	pc = 0x821D27CC; continue 'dispatch;
	// 821D27C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D27C8: 4BFA8BD1  bl 0x8217b398
	ctx.lr = 0x821D27CC;
	sub_8217B398(ctx, base);
	// 821D27CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D27D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D27D4: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D27D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D27DC: 4E800421  bctrl
	ctx.lr = 0x821D27E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D27E0: 48000014  b 0x821d27f4
	pc = 0x821D27F4; continue 'dispatch;
	// 821D27E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D27E8: 4BFE5331  bl 0x821b7b18
	ctx.lr = 0x821D27EC;
	sub_821B7B18(ctx, base);
	// 821D27EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D27F0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821D27F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D27F8: 4BFE5321  bl 0x821b7b18
	ctx.lr = 0x821D27FC;
	sub_821B7B18(ctx, base);
	// 821D27FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D2800: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D2804: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D2808: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D280C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D2810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D2818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D2818 size=292
    let mut pc: u32 = 0x821D2818;
    'dispatch: loop {
        match pc {
            0x821D2818 => {
    //   block [0x821D2818..0x821D293C)
	// 821D2818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D281C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D2820: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D2824: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821D2828: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 821D282C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D2830: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821D2834: 81250018  lwz r9, 0x18(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D2838: 80C5001C  lwz r6, 0x1c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D283C: 7D493050  subf r10, r9, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 821D2840: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821D2844: 7D6A5BD7  divw. r11, r10, r11
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D2848: 4081005C  ble 0x821d28a4
	if !ctx.cr[0].gt {
	pc = 0x821D28A4; continue 'dispatch;
	}
	// 821D284C: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D2850: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D2854: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821D2858: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D285C: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821D2860: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2864: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 821D2868: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D286C: 41980008  blt cr6, 0x821d2874
	if ctx.cr[6].lt {
	pc = 0x821D2874; continue 'dispatch;
	}
	// 821D2870: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821D2874: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D2878: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D287C: 419A0014  beq cr6, 0x821d2890
	if ctx.cr[6].eq {
	pc = 0x821D2890; continue 'dispatch;
	}
	// 821D2880: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D2884: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 821D2888: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D288C: 4800000C  b 0x821d2898
	pc = 0x821D2898; continue 'dispatch;
	// 821D2890: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821D2894: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821D2898: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D289C: 4199FFB0  bgt cr6, 0x821d284c
	if ctx.cr[6].gt {
	pc = 0x821D284C; continue 'dispatch;
	}
	// 821D28A0: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821D28A4: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D28A8: 419A0034  beq cr6, 0x821d28dc
	if ctx.cr[6].eq {
	pc = 0x821D28DC; continue 'dispatch;
	}
	// 821D28AC: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D28B0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821D28B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D28B8: 41990008  bgt cr6, 0x821d28c0
	if ctx.cr[6].gt {
	pc = 0x821D28C0; continue 'dispatch;
	}
	// 821D28BC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821D28C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D28C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D28C8: 409A0014  bne cr6, 0x821d28dc
	if !ctx.cr[6].eq {
	pc = 0x821D28DC; continue 'dispatch;
	}
	// 821D28CC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D28D0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D28D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D28D8: 48000008  b 0x821d28e0
	pc = 0x821D28E0; continue 'dispatch;
	// 821D28DC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D28E0: 8145001C  lwz r10, 0x1c(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D28E4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D28E8: 419A0010  beq cr6, 0x821d28f8
	if ctx.cr[6].eq {
	pc = 0x821D28F8; continue 'dispatch;
	}
	// 821D28EC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D28F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D28F4: 48000008  b 0x821d28fc
	pc = 0x821D28FC; continue 'dispatch;
	// 821D28F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821D28FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D2900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2904: 419A0024  beq cr6, 0x821d2928
	if ctx.cr[6].eq {
	pc = 0x821D2928; continue 'dispatch;
	}
	// 821D2908: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D290C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D2910: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D2914: 4E800421  bctrl
	ctx.lr = 0x821D2918;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D2918: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821D291C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D2920: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D2924: 4E800020  blr
	return;
	// 821D2928: 88650049  lbz r3, 0x49(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(73 as u32) ) } as u64;
	// 821D292C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821D2930: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D2934: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D2938: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D2940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D2940 size=756
    let mut pc: u32 = 0x821D2940;
    'dispatch: loop {
        match pc {
            0x821D2940 => {
    //   block [0x821D2940..0x821D2C34)
	// 821D2940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D2944: 48AD6AC5  bl 0x82ca9408
	ctx.lr = 0x821D2948;
	sub_82CA93D0(ctx, base);
	// 821D2948: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D294C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821D2950: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D2954: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D2958: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D295C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D2960: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821D2964: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2968: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D296C: 4805FE0D  bl 0x82232778
	ctx.lr = 0x821D2970;
	sub_82232778(ctx, base);
	// 821D2970: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D2974: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D2978: 419A02B0  beq cr6, 0x821d2c28
	if ctx.cr[6].eq {
	pc = 0x821D2C28; continue 'dispatch;
	}
	// 821D297C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2980: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821D2984: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 821D2988: 894B0024  lbz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821D298C: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821D2990: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D2994: 419A00E8  beq cr6, 0x821d2a7c
	if ctx.cr[6].eq {
	pc = 0x821D2A7C; continue 'dispatch;
	}
	// 821D2998: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D299C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D29A0: 419A0020  beq cr6, 0x821d29c0
	if ctx.cr[6].eq {
	pc = 0x821D29C0; continue 'dispatch;
	}
	// 821D29A4: 894A0018  lbz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D29A8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D29AC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D29B0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D29B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D29B8: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D29BC: 480000C4  b 0x821d2a80
	pc = 0x821D2A80; continue 'dispatch;
	// 821D29C0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D29C4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D29C8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821D29CC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D29D0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D29D4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D29D8: 40810054  ble 0x821d2a2c
	if !ctx.cr[0].gt {
	pc = 0x821D2A2C; continue 'dispatch;
	}
	// 821D29DC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D29E0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D29E4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D29E8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D29EC: 2F070018  cmpwi cr6, r7, 0x18
	ctx.cr[6].compare_i32(ctx.r[7].s32, 24, &mut ctx.xer);
	// 821D29F0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D29F4: 41980008  blt cr6, 0x821d29fc
	if ctx.cr[6].lt {
	pc = 0x821D29FC; continue 'dispatch;
	}
	// 821D29F8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821D29FC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D2A00: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D2A04: 419A0014  beq cr6, 0x821d2a18
	if ctx.cr[6].eq {
	pc = 0x821D2A18; continue 'dispatch;
	}
	// 821D2A08: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D2A0C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D2A10: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D2A14: 4800000C  b 0x821d2a20
	pc = 0x821D2A20; continue 'dispatch;
	// 821D2A18: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D2A1C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821D2A20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D2A24: 4199FFB8  bgt cr6, 0x821d29dc
	if ctx.cr[6].gt {
	pc = 0x821D29DC; continue 'dispatch;
	}
	// 821D2A28: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D2A2C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D2A30: 419A003C  beq cr6, 0x821d2a6c
	if ctx.cr[6].eq {
	pc = 0x821D2A6C; continue 'dispatch;
	}
	// 821D2A34: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2A38: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 821D2A3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D2A40: 41990008  bgt cr6, 0x821d2a48
	if ctx.cr[6].gt {
	pc = 0x821D2A48; continue 'dispatch;
	}
	// 821D2A44: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821D2A48: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D2A4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2A50: 409A001C  bne cr6, 0x821d2a6c
	if !ctx.cr[6].eq {
	pc = 0x821D2A6C; continue 'dispatch;
	}
	// 821D2A54: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D2A58: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D2A5C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D2A60: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2A64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D2A68: 48000018  b 0x821d2a80
	pc = 0x821D2A80; continue 'dispatch;
	// 821D2A6C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D2A70: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2A74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D2A78: 48000008  b 0x821d2a80
	pc = 0x821D2A80; continue 'dispatch;
	// 821D2A7C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821D2A80: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D2A84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2A88: 419A0194  beq cr6, 0x821d2c1c
	if ctx.cr[6].eq {
	pc = 0x821D2C1C; continue 'dispatch;
	}
	// 821D2A8C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821D2A90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D2A94: 3BCBB780  addi r30, r11, -0x4880
	ctx.r[30].s64 = ctx.r[11].s64 + -18560;
	// 821D2A98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D2A9C: 4809ED35  bl 0x822717d0
	ctx.lr = 0x821D2AA0;
	sub_822717D0(ctx, base);
	// 821D2AA0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D2AA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2AA8: 419A0174  beq cr6, 0x821d2c1c
	if ctx.cr[6].eq {
	pc = 0x821D2C1C; continue 'dispatch;
	}
	// 821D2AAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D2AB0: 481DDF89  bl 0x823b0a38
	ctx.lr = 0x821D2AB4;
	sub_823B0A38(ctx, base);
	// 821D2AB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D2AB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D2ABC: 48328A2D  bl 0x824fb4e8
	ctx.lr = 0x821D2AC0;
	sub_824FB4E8(ctx, base);
	// 821D2AC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D2AC4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821D2AC8: 419A0018  beq cr6, 0x821d2ae0
	if ctx.cr[6].eq {
	pc = 0x821D2AE0; continue 'dispatch;
	}
	// 821D2ACC: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821D2AD0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D2AD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D2AD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D2ADC: 409A0008  bne cr6, 0x821d2ae4
	if !ctx.cr[6].eq {
	pc = 0x821D2AE4; continue 'dispatch;
	}
	// 821D2AE0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821D2AE4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D2AE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2AEC: 419A0130  beq cr6, 0x821d2c1c
	if ctx.cr[6].eq {
	pc = 0x821D2C1C; continue 'dispatch;
	}
	// 821D2AF0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2AF4: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821D2AF8: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D2AFC: 55283FFE  rlwinm r8, r9, 7, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x01FFFFFFu64;
	// 821D2B00: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821D2B04: 419A00F4  beq cr6, 0x821d2bf8
	if ctx.cr[6].eq {
	pc = 0x821D2BF8; continue 'dispatch;
	}
	// 821D2B08: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D2B0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D2B10: 419A0024  beq cr6, 0x821d2b34
	if ctx.cr[6].eq {
	pc = 0x821D2B34; continue 'dispatch;
	}
	// 821D2B14: 892A0039  lbz r9, 0x39(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(57 as u32) ) } as u64;
	// 821D2B18: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D2B1C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821D2B20: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821D2B24: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2B28: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821D2B2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D2B30: 480000CC  b 0x821d2bfc
	pc = 0x821D2BFC; continue 'dispatch;
	// 821D2B34: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D2B38: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D2B3C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821D2B40: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D2B44: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D2B48: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D2B4C: 40810054  ble 0x821d2ba0
	if !ctx.cr[0].gt {
	pc = 0x821D2BA0; continue 'dispatch;
	}
	// 821D2B50: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D2B54: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D2B58: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D2B5C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2B60: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 821D2B64: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D2B68: 41980008  blt cr6, 0x821d2b70
	if ctx.cr[6].lt {
	pc = 0x821D2B70; continue 'dispatch;
	}
	// 821D2B6C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821D2B70: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D2B74: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D2B78: 419A0014  beq cr6, 0x821d2b8c
	if ctx.cr[6].eq {
	pc = 0x821D2B8C; continue 'dispatch;
	}
	// 821D2B7C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D2B80: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D2B84: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D2B88: 4800000C  b 0x821d2b94
	pc = 0x821D2B94; continue 'dispatch;
	// 821D2B8C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D2B90: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821D2B94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D2B98: 4199FFB8  bgt cr6, 0x821d2b50
	if ctx.cr[6].gt {
	pc = 0x821D2B50; continue 'dispatch;
	}
	// 821D2B9C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D2BA0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D2BA4: 419A0040  beq cr6, 0x821d2be4
	if ctx.cr[6].eq {
	pc = 0x821D2BE4; continue 'dispatch;
	}
	// 821D2BA8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2BAC: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 821D2BB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D2BB4: 41990008  bgt cr6, 0x821d2bbc
	if ctx.cr[6].gt {
	pc = 0x821D2BBC; continue 'dispatch;
	}
	// 821D2BB8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821D2BBC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D2BC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2BC4: 409A0020  bne cr6, 0x821d2be4
	if !ctx.cr[6].eq {
	pc = 0x821D2BE4; continue 'dispatch;
	}
	// 821D2BC8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D2BCC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D2BD0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D2BD4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2BD8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821D2BDC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D2BE0: 4800001C  b 0x821d2bfc
	pc = 0x821D2BFC; continue 'dispatch;
	// 821D2BE4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D2BE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2BEC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821D2BF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D2BF4: 48000008  b 0x821d2bfc
	pc = 0x821D2BFC; continue 'dispatch;
	// 821D2BF8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821D2BFC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D2C00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2C04: 419A0018  beq cr6, 0x821d2c1c
	if ctx.cr[6].eq {
	pc = 0x821D2C1C; continue 'dispatch;
	}
	// 821D2C08: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 821D2C0C: 483128A5  bl 0x824e54b0
	ctx.lr = 0x821D2C10;
	sub_824E54B0(ctx, base);
	// 821D2C10: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D2C14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2C18: 419A0010  beq cr6, 0x821d2c28
	if ctx.cr[6].eq {
	pc = 0x821D2C28; continue 'dispatch;
	}
	// 821D2C1C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821D2C20: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D2C24: 48AD6834  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821D2C28: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D2C2C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D2C30: 48AD6828  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D2C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D2C38 size=460
    let mut pc: u32 = 0x821D2C38;
    'dispatch: loop {
        match pc {
            0x821D2C38 => {
    //   block [0x821D2C38..0x821D2E04)
	// 821D2C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D2C3C: 48AD67BD  bl 0x82ca93f8
	ctx.lr = 0x821D2C40;
	sub_82CA93D0(ctx, base);
	// 821D2C40: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D2E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D2E08 size=168
    let mut pc: u32 = 0x821D2E08;
    'dispatch: loop {
        match pc {
            0x821D2E08 => {
    //   block [0x821D2E08..0x821D2EB0)
	// 821D2E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D2E0C: 48AD65F9  bl 0x82ca9404
	ctx.lr = 0x821D2E10;
	sub_82CA93D0(ctx, base);
	// 821D2E10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D2E14: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821D2E18: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821D2E1C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821D2E20: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 821D2E24: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D2E28: 83FE0020  lwz r31, 0x20(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D2E2C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D2E30: 7D4BFA14  add r10, r11, r31
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821D2E34: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D2E38: 419A0070  beq cr6, 0x821d2ea8
	if ctx.cr[6].eq {
	pc = 0x821D2EA8; continue 'dispatch;
	}
	// 821D2E3C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2E40: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 821D2E44: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2E48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D2E4C: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D2E50: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D2E54: 4E800421  bctrl
	ctx.lr = 0x821D2E58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D2E58: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D2E5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D2E60: 419A002C  beq cr6, 0x821d2e8c
	if ctx.cr[6].eq {
	pc = 0x821D2E8C; continue 'dispatch;
	}
	// 821D2E64: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2E68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D2E6C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2E70: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D2E74: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D2E78: 4E800421  bctrl
	ctx.lr = 0x821D2E7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D2E7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D2E80: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821D2E84: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821D2E88: 4800EB59  bl 0x821e19e0
	ctx.lr = 0x821D2E8C;
	sub_821E19E0(ctx, base);
	// 821D2E8C: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D2E90: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821D2E94: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D2E98: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D2E9C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821D2EA0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D2EA4: 409AFF98  bne cr6, 0x821d2e3c
	if !ctx.cr[6].eq {
	pc = 0x821D2E3C; continue 'dispatch;
	}
	// 821D2EA8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D2EAC: 48AD65A8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D2EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D2EB0 size=24
    let mut pc: u32 = 0x821D2EB0;
    'dispatch: loop {
        match pc {
            0x821D2EB0 => {
    //   block [0x821D2EB0..0x821D2EC8)
	// 821D2EB0: A164001C  lhz r11, 0x1c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D2EB4: 7D6A2838  and r10, r11, r5
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[5].u64;
	// 821D2EB8: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 821D2EBC: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 821D2EC0: 69030001  xori r3, r8, 1
	ctx.r[3].u64 = ctx.r[8].u64 ^ 1;
	// 821D2EC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D2EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D2EC8 size=624
    let mut pc: u32 = 0x821D2EC8;
    'dispatch: loop {
        match pc {
            0x821D2EC8 => {
    //   block [0x821D2EC8..0x821D3138)
	// 821D2EC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D2ECC: 48AD6535  bl 0x82ca9400
	ctx.lr = 0x821D2ED0;
	sub_82CA93D0(ctx, base);
	// 821D2ED0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D2ED4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D2ED8: A17D0014  lhz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D2EDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2EE0: 419A00F0  beq cr6, 0x821d2fd0
	if ctx.cr[6].eq {
	pc = 0x821D2FD0; continue 'dispatch;
	}
	// 821D2EE4: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2EE8: 3D6082BC  lis r11, -0x7d44
	ctx.r[11].s64 = -2101608448;
	// 821D2EEC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D2EF0: 388B9118  addi r4, r11, -0x6ee8
	ctx.r[4].s64 = ctx.r[11].s64 + -28392;
	// 821D2EF4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D2EF8: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D2EFC: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821D2F00: 7D1E1E70  srawi r30, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 821D2F04: 480A8A65  bl 0x8227b968
	ctx.lr = 0x821D2F08;
	sub_8227B968(ctx, base);
	// 821D2F08: 80DD0010  lwz r6, 0x10(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D2F0C: 3BFD0010  addi r31, r29, 0x10
	ctx.r[31].s64 = ctx.r[29].s64 + 16;
	// 821D2F10: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821D2F14: 409A000C  bne cr6, 0x821d2f20
	if !ctx.cr[6].eq {
	pc = 0x821D2F20; continue 'dispatch;
	}
	// 821D2F18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D2F1C: 38CB0CA0  addi r6, r11, 0xca0
	ctx.r[6].s64 = ctx.r[11].s64 + 3232;
	// 821D2F20: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D2F24: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2F28: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D2F2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D2F30: 409AFFF4  bne cr6, 0x821d2f24
	if !ctx.cr[6].eq {
	pc = 0x821D2F24; continue 'dispatch;
	}
	// 821D2F34: 7D665850  subf r11, r6, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 821D2F38: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 821D2F3C: 3D4082BD  lis r10, -0x7d43
	ctx.r[10].s64 = -2101542912;
	// 821D2F40: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2F44: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 821D2F48: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D2F4C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821D2F50: 388AE1F8  addi r4, r10, -0x1e08
	ctx.r[4].s64 = ctx.r[10].s64 + -7688;
	// 821D2F54: 489F992D  bl 0x82bcc880
	ctx.lr = 0x821D2F58;
	sub_82BCC880(ctx, base);
	// 821D2F58: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821D2F5C: 3CC082BD  lis r6, -0x7d43
	ctx.r[6].s64 = -2101542912;
	// 821D2F60: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 821D2F64: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D2F68: 3886C870  addi r4, r6, -0x3790
	ctx.r[4].s64 = ctx.r[6].s64 + -14224;
	// 821D2F6C: 839D0004  lwz r28, 4(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2F70: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821D2F74: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D2F78: 813C0020  lwz r9, 0x20(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D2F7C: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 821D2F80: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 821D2F84: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821D2F88: 7CC95050  subf r6, r9, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821D2F8C: 7CE95850  subf r7, r9, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D2F90: 480ED5E1  bl 0x822c0570
	ctx.lr = 0x821D2F94;
	sub_822C0570(ctx, base);
	// 821D2F94: 815C0014  lwz r10, 0x14(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D2F98: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D2F9C: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D2FA0: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821D2FA4: 41980008  blt cr6, 0x821d2fac
	if ctx.cr[6].lt {
	pc = 0x821D2FAC; continue 'dispatch;
	}
	// 821D2FA8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821D2FAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D2FB0: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2FB4: 489F8D55  bl 0x82bcbd08
	ctx.lr = 0x821D2FB8;
	sub_82BCBD08(ctx, base);
	// 821D2FB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2FBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2FC0: 419A0010  beq cr6, 0x821d2fd0
	if ctx.cr[6].eq {
	pc = 0x821D2FD0; continue 'dispatch;
	}
	// 821D2FC4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821D2FC8: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 821D2FCC: B15F0004  sth r10, 4(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 821D2FD0: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2FD4: 489E55CD  bl 0x82bb85a0
	ctx.lr = 0x821D2FD8;
	sub_82BB85A0(ctx, base);
	// 821D2FD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D2FDC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2FE0: 814B0074  lwz r10, 0x74(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 821D2FE4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D2FE8: 4E800421  bctrl
	ctx.lr = 0x821D2FEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D2FEC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2FF0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821D2FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D2FF8: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D2FFC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821D3000: 4E800421  bctrl
	ctx.lr = 0x821D3004;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D3004: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D3008: 3CE08210  lis r7, -0x7df0
	ctx.r[7].s64 = -2112880640;
	// 821D300C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D3010: 38C7CF28  addi r6, r7, -0x30d8
	ctx.r[6].s64 = ctx.r[7].s64 + -12504;
	// 821D3014: 38BB00C0  addi r5, r27, 0xc0
	ctx.r[5].s64 = ctx.r[27].s64 + 192;
	// 821D3018: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D301C: 480F229D  bl 0x822c52b8
	ctx.lr = 0x821D3020;
	sub_822C52B8(ctx, base);
	// 821D3020: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 821D3024: 38BB0090  addi r5, r27, 0x90
	ctx.r[5].s64 = ctx.r[27].s64 + 144;
	// 821D3028: 38C6DF9C  addi r6, r6, -0x2064
	ctx.r[6].s64 = ctx.r[6].s64 + -8292;
	// 821D302C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D3030: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D3034: 4BFFFDD5  bl 0x821d2e08
	ctx.lr = 0x821D3038;
	sub_821D2E08(ctx, base);
	// 821D3038: 80BB0058  lwz r5, 0x58(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(88 as u32) ) } as u64;
	// 821D303C: 3B9B0030  addi r28, r27, 0x30
	ctx.r[28].s64 = ctx.r[27].s64 + 48;
	// 821D3040: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D3044: 83DB0050  lwz r30, 0x50(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D3048: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821D304C: 7F1E2040  cmplw cr6, r30, r4
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821D3050: 419A0098  beq cr6, 0x821d30e8
	if ctx.cr[6].eq {
	pc = 0x821D30E8; continue 'dispatch;
	}
	// 821D3054: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 821D3058: 3B4BDFB8  addi r26, r11, -0x2048
	ctx.r[26].s64 = ctx.r[11].s64 + -8264;
	// 821D305C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3060: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 821D3064: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D306C: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D3070: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D3074: 4E800421  bctrl
	ctx.lr = 0x821D3078;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D3078: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D307C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D3080: 419A004C  beq cr6, 0x821d30cc
	if ctx.cr[6].eq {
	pc = 0x821D30CC; continue 'dispatch;
	}
	// 821D3084: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D308C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3090: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D3094: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D3098: 4E800421  bctrl
	ctx.lr = 0x821D309C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D309C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D30A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D30A4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821D30A8: 4800E939  bl 0x821e19e0
	ctx.lr = 0x821D30AC;
	sub_821E19E0(ctx, base);
	// 821D30AC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D30B0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D30B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821D30B8: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 821D30BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D30C0: 81090050  lwz r8, 0x50(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D30C4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821D30C8: 4E800421  bctrl
	ctx.lr = 0x821D30CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D30CC: 815C0028  lwz r10, 0x28(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D30D0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821D30D4: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D30D8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D30DC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D30E0: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821D30E4: 409AFF78  bne cr6, 0x821d305c
	if !ctx.cr[6].eq {
	pc = 0x821D305C; continue 'dispatch;
	}
	// 821D30E8: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 821D30EC: 38BB0060  addi r5, r27, 0x60
	ctx.r[5].s64 = ctx.r[27].s64 + 96;
	// 821D30F0: 38CBDFAC  addi r6, r11, -0x2054
	ctx.r[6].s64 = ctx.r[11].s64 + -8276;
	// 821D30F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D30F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D30FC: 4BFFFD0D  bl 0x821d2e08
	ctx.lr = 0x821D3100;
	sub_821D2E08(ctx, base);
	// 821D3100: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 821D3104: 38BB00F0  addi r5, r27, 0xf0
	ctx.r[5].s64 = ctx.r[27].s64 + 240;
	// 821D3108: 38CACF18  addi r6, r10, -0x30e8
	ctx.r[6].s64 = ctx.r[10].s64 + -12520;
	// 821D310C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D3110: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D3114: 480F21A5  bl 0x822c52b8
	ctx.lr = 0x821D3118;
	sub_822C52B8(ctx, base);
	// 821D3118: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821D311C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821D3120: 38C9103C  addi r6, r9, 0x103c
	ctx.r[6].s64 = ctx.r[9].s64 + 4156;
	// 821D3124: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D3128: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D312C: 4BFFFCDD  bl 0x821d2e08
	ctx.lr = 0x821D3130;
	sub_821D2E08(ctx, base);
	// 821D3130: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821D3134: 48AD631C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D3138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D3138 size=132
    let mut pc: u32 = 0x821D3138;
    'dispatch: loop {
        match pc {
            0x821D3138 => {
    //   block [0x821D3138..0x821D31BC)
	// 821D3138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D313C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D3140: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D3144: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D3148: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D314C: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 821D3150: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821D3154: F8C10088  std r6, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[6].u64 ) };
	// 821D3158: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D315C: 81210084  lwz r9, 0x84(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821D3160: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D3164: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821D3168: F8BF0008  std r5, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	// 821D316C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821D3170: F8DF0010  std r6, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 821D3174: 419A0030  beq cr6, 0x821d31a4
	if ctx.cr[6].eq {
	pc = 0x821D31A4; continue 'dispatch;
	}
	// 821D3178: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D317C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D3180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D3184: 419A0010  beq cr6, 0x821d3194
	if ctx.cr[6].eq {
	pc = 0x821D3194; continue 'dispatch;
	}
	// 821D3188: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D318C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D3190: 7D2B1670  srawi r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 821D3194: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D3198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D319C: 4199000C  bgt cr6, 0x821d31a8
	if ctx.cr[6].gt {
	pc = 0x821D31A8; continue 'dispatch;
	}
	// 821D31A0: 4802C5A1  bl 0x821ff740
	ctx.lr = 0x821D31A4;
	sub_821FF740(ctx, base);
	// 821D31A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D31A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821D31AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D31B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D31B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D31B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D31C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D31C0 size=152
    let mut pc: u32 = 0x821D31C0;
    'dispatch: loop {
        match pc {
            0x821D31C0 => {
    //   block [0x821D31C0..0x821D3258)
	// 821D31C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D31C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D31C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D31CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D31D0: 8144001C  lwz r10, 0x1c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D31D4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821D31D8: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D31DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D31E0: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821D31E4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821D31E8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D31EC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821D31F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821D31F4: 419A0024  beq cr6, 0x821d3218
	if ctx.cr[6].eq {
	pc = 0x821D3218; continue 'dispatch;
	}
	// 821D31F8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D31FC: 7D282838  and r8, r9, r5
	ctx.r[8].u64 = ctx.r[9].u64 & ctx.r[5].u64;
	// 821D3200: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821D3204: 409A0040  bne cr6, 0x821d3244
	if !ctx.cr[6].eq {
	pc = 0x821D3244; continue 'dispatch;
	}
	// 821D3208: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 821D320C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D3210: 409AFFE8  bne cr6, 0x821d31f8
	if !ctx.cr[6].eq {
	pc = 0x821D31F8; continue 'dispatch;
	}
	// 821D3214: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821D3218: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821D321C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821D3220: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 821D3224: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D3228: 4BFFFF11  bl 0x821d3138
	ctx.lr = 0x821D322C;
	sub_821D3138(ctx, base);
	// 821D322C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D3230: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D3234: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D3238: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D323C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D3240: 4E800020  blr
	return;
	// 821D3244: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821D3248: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821D324C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821D3250: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D3254: 4BFFFFD0  b 0x821d3224
	pc = 0x821D3224; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D3258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D3258 size=104
    let mut pc: u32 = 0x821D3258;
    'dispatch: loop {
        match pc {
            0x821D3258 => {
    //   block [0x821D3258..0x821D32C0)
	// 821D3258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D325C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D3260: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D3264: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D3268: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D326C: 1020038C  vspltisw v1, 0
	for i in 0..4 {
		ctx.v[1].u32[i] = 0;
	}
	// 821D3270: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821D3274: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D3278: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821D327C: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D3280: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D32C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D32C0 size=688
    let mut pc: u32 = 0x821D32C0;
    'dispatch: loop {
        match pc {
            0x821D32C0 => {
    //   block [0x821D32C0..0x821D3570)
	// 821D32C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D32C4: 48AD6145  bl 0x82ca9408
	ctx.lr = 0x821D32C8;
	sub_82CA93D0(ctx, base);
	// 821D32C8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D32CC: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D32D0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821D32D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D32D8: 3BE40008  addi r31, r4, 8
	ctx.r[31].s64 = ctx.r[4].s64 + 8;
	// 821D32DC: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 821D32E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D32E4: 419A0038  beq cr6, 0x821d331c
	if ctx.cr[6].eq {
	pc = 0x821D331C; continue 'dispatch;
	}
	// 821D32E8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D32EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D32F0: 419A0080  beq cr6, 0x821d3370
	if ctx.cr[6].eq {
	pc = 0x821D3370; continue 'dispatch;
	}
	// 821D32F4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D32F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D32FC: 419A0020  beq cr6, 0x821d331c
	if ctx.cr[6].eq {
	pc = 0x821D331C; continue 'dispatch;
	}
	// 821D3300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D3304: 4BFA0B35  bl 0x82173e38
	ctx.lr = 0x821D3308;
	sub_82173E38(ctx, base);
	// 821D3308: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821D330C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3310: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D3314: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D3318: 409A0008  bne cr6, 0x821d3320
	if !ctx.cr[6].eq {
	pc = 0x821D3320; continue 'dispatch;
	}
	// 821D331C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821D3320: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D3324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D3328: 419A01CC  beq cr6, 0x821d34f4
	if ctx.cr[6].eq {
	pc = 0x821D34F4; continue 'dispatch;
	}
	// 821D332C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D3330: 4BFA0B09  bl 0x82173e38
	ctx.lr = 0x821D3334;
	sub_82173E38(ctx, base);
	// 821D3334: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D3338: 556A4FFE  rlwinm r10, r11, 9, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x007FFFFFu64;
	// 821D333C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D3340: 419A0100  beq cr6, 0x821d3440
	if ctx.cr[6].eq {
	pc = 0x821D3440; continue 'dispatch;
	}
	// 821D3344: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D3348: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D334C: 419A0030  beq cr6, 0x821d337c
	if ctx.cr[6].eq {
	pc = 0x821D337C; continue 'dispatch;
	}
	// 821D3350: 894B0057  lbz r10, 0x57(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(87 as u32) ) } as u64;
	// 821D3354: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D3358: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D335C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D3360: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3364: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821D3368: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D336C: 480000D8  b 0x821d3444
	pc = 0x821D3444; continue 'dispatch;
	// 821D3370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D3374: 4BFC0AC5  bl 0x82193e38
	ctx.lr = 0x821D3378;
	sub_82193E38(ctx, base);
	// 821D3378: 4BFFFFA4  b 0x821d331c
	pc = 0x821D331C; continue 'dispatch;
	// 821D337C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D3380: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D3384: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 821D3388: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D338C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821D3390: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D3394: 40810054  ble 0x821d33e8
	if !ctx.cr[0].gt {
	pc = 0x821D33E8; continue 'dispatch;
	}
	// 821D3398: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D339C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D33A0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D33A4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D33A8: 2F070057  cmpwi cr6, r7, 0x57
	ctx.cr[6].compare_i32(ctx.r[7].s32, 87, &mut ctx.xer);
	// 821D33AC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D33B0: 41980008  blt cr6, 0x821d33b8
	if ctx.cr[6].lt {
	pc = 0x821D33B8; continue 'dispatch;
	}
	// 821D33B4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821D33B8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D33BC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D33C0: 419A0014  beq cr6, 0x821d33d4
	if ctx.cr[6].eq {
	pc = 0x821D33D4; continue 'dispatch;
	}
	// 821D33C4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D33C8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D33CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D33D0: 4800000C  b 0x821d33dc
	pc = 0x821D33DC; continue 'dispatch;
	// 821D33D4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D33D8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821D33DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D33E0: 4199FFB8  bgt cr6, 0x821d3398
	if ctx.cr[6].gt {
	pc = 0x821D3398; continue 'dispatch;
	}
	// 821D33E4: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821D33E8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D33EC: 419A0040  beq cr6, 0x821d342c
	if ctx.cr[6].eq {
	pc = 0x821D342C; continue 'dispatch;
	}
	// 821D33F0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D33F4: 2F0B0057  cmpwi cr6, r11, 0x57
	ctx.cr[6].compare_i32(ctx.r[11].s32, 87, &mut ctx.xer);
	// 821D33F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D33FC: 41990008  bgt cr6, 0x821d3404
	if ctx.cr[6].gt {
	pc = 0x821D3404; continue 'dispatch;
	}
	// 821D3400: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821D3404: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D3408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D340C: 409A0020  bne cr6, 0x821d342c
	if !ctx.cr[6].eq {
	pc = 0x821D342C; continue 'dispatch;
	}
	// 821D3410: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821D3414: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821D3418: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821D341C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3420: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821D3424: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D3428: 4800001C  b 0x821d3444
	pc = 0x821D3444; continue 'dispatch;
	// 821D342C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D3430: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3434: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821D3438: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D343C: 48000008  b 0x821d3444
	pc = 0x821D3444; continue 'dispatch;
	// 821D3440: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821D3444: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D3448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D344C: 419A00A8  beq cr6, 0x821d34f4
	if ctx.cr[6].eq {
	pc = 0x821D34F4; continue 'dispatch;
	}
	// 821D3450: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3454: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821D3458: 83EB007C  lwz r31, 0x7c(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821D345C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D3460: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3464: 812A0044  lwz r9, 0x44(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 821D3468: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821D346C: 4E800421  bctrl
	ctx.lr = 0x821D3470;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D3470: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821D3474: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D3478: E8880000  ld r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 821D347C: E8A80008  ld r5, 8(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 821D3480: 4BFFFDD9  bl 0x821d3258
	ctx.lr = 0x821D3484;
	sub_821D3258(ctx, base);
	// 821D3484: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3488: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D348C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821D3490: 80C70040  lwz r6, 0x40(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(64 as u32) ) } as u64;
	// 821D3494: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 821D3498: 4E800421  bctrl
	ctx.lr = 0x821D349C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D3570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D3570 size=1548
    let mut pc: u32 = 0x821D3570;
    'dispatch: loop {
        match pc {
            0x821D3570 => {
    //   block [0x821D3570..0x821D3B7C)
	// 821D3570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D3574: 48AD5E75  bl 0x82ca93e8
	ctx.lr = 0x821D3578;
	sub_82CA93D0(ctx, base);
	// 821D3578: 9421FDB0  stwu r1, -0x250(r1)
	ea = ctx.r[1].u32.wrapping_add(-592 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D357C: 39670070  addi r11, r7, 0x70
	ctx.r[11].s64 = ctx.r[7].s64 + 112;
	// 821D3580: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 821D3584: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D3588: 7D6B182E  lwzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 821D358C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821D3590: 396B0368  addi r11, r11, 0x368
	ctx.r[11].s64 = ctx.r[11].s64 + 872;
	// 821D3594: 836B001C  lwz r27, 0x1c(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D3598: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821D359C: 419A05D8  beq cr6, 0x821d3b74
	if ctx.cr[6].eq {
	pc = 0x821D3B74; continue 'dispatch;
	}
	// 821D35A0: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D35A4: 1D2701A0  mulli r9, r7, 0x1a0
	ctx.r[9].s64 = ctx.r[7].s64 * 416;
	// 821D35A8: 83050018  lwz r24, 0x18(r5)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D35AC: 390A0009  addi r8, r10, 9
	ctx.r[8].s64 = ctx.r[10].s64 + 9;
	// 821D35B0: 7D491A14  add r10, r9, r3
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 821D35B4: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821D35B8: 394A0044  addi r10, r10, 0x44
	ctx.r[10].s64 = ctx.r[10].s64 + 68;
	// 821D35BC: 7FC95A14  add r30, r9, r11
	ctx.r[30].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821D35C0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821D35C4: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 821D35C8: 419A02E4  beq cr6, 0x821d38ac
	if ctx.cr[6].eq {
	pc = 0x821D38AC; continue 'dispatch;
	}
	// 821D35CC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821D35D0: 3AE50034  addi r23, r5, 0x34
	ctx.r[23].s64 = ctx.r[5].s64 + 52;
	// 821D35D4: 7F2B5050  subf r25, r11, r10
	ctx.r[25].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D35D8: A1410050  lhz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D35DC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821D35E0: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821D35E4: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 821D35E8: 3BAB5CE4  addi r29, r11, 0x5ce4
	ctx.r[29].s64 = ctx.r[11].s64 + 23780;
	// 821D35EC: 7CB93A14  add r5, r25, r7
	ctx.r[5].u64 = ctx.r[25].u64 + ctx.r[7].u64;
	// 821D35F0: 7D79382E  lwzx r11, r25, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821D35F4: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 821D35F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821D35FC: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 821D3600: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3604: 83E50008  lwz r31, 8(r5)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D3608: 419A0040  beq cr6, 0x821d3648
	if ctx.cr[6].eq {
	pc = 0x821D3648; continue 'dispatch;
	}
	// 821D360C: 80BA0000  lwz r5, 0(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3610: 54A4A73E  rlwinm r4, r5, 0x14, 0x1c, 0x1f
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x00000FFFu64;
	// 821D3614: 8AA80009  lbz r21, 9(r8)
	ctx.r[21].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(9 as u32) ) } as u64;
	// 821D3618: 7F152040  cmplw cr6, r21, r4
	ctx.cr[6].compare_u32(ctx.r[21].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821D361C: 409A0014  bne cr6, 0x821d3630
	if !ctx.cr[6].eq {
	pc = 0x821D3630; continue 'dispatch;
	}
	// 821D3620: 8AA8000A  lbz r21, 0xa(r8)
	ctx.r[21].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(10 as u32) ) } as u64;
	// 821D3624: 54B4873E  rlwinm r20, r5, 0x10, 0x1c, 0x1f
	ctx.r[20].u64 = ctx.r[5].u32 as u64 & 0x0000FFFFu64;
	// 821D3628: 7F15A040  cmplw cr6, r21, r20
	ctx.cr[6].compare_u32(ctx.r[21].u32, ctx.r[20].u32, &mut ctx.xer);
	// 821D362C: 419A0014  beq cr6, 0x821d3640
	if ctx.cr[6].eq {
	pc = 0x821D3640; continue 'dispatch;
	}
	// 821D3630: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821D3634: 3908000C  addi r8, r8, 0xc
	ctx.r[8].s64 = ctx.r[8].s64 + 12;
	// 821D3638: 7F09C040  cmplw cr6, r9, r24
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[24].u32, &mut ctx.xer);
	// 821D363C: 4198FFD8  blt cr6, 0x821d3614
	if ctx.cr[6].lt {
	pc = 0x821D3614; continue 'dispatch;
	}
	// 821D3640: 7F09C040  cmplw cr6, r9, r24
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[24].u32, &mut ctx.xer);
	// 821D3644: 41980038  blt cr6, 0x821d367c
	if ctx.cr[6].lt {
	pc = 0x821D367C; continue 'dispatch;
	}
	// 821D3648: 3D80BFC6  lis r12, -0x403a
	ctx.r[12].s64 = -1077542912;
	// 821D364C: 89060000  lbz r8, 0(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3650: 3920005F  li r9, 0x5f
	ctx.r[9].s64 = 95;
	// 821D3654: 618CCFFF  ori r12, r12, 0xcfff
	ctx.r[12].u64 = ctx.r[12].u64 | 53247;
	// 821D3658: 512BA096  rlwimi r11, r9, 0x14, 2, 0xb
	ctx.r[11].u64 = (((ctx.r[9].u32).rotate_left(20) as u64) & 0x000000003FF00000) | (ctx.r[11].u64 & 0xFFFFFFFFC00FFFFF);
	// 821D365C: 554A073E  clrlwi r10, r10, 0x1c
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 821D3660: 7C656038  and r5, r3, r12
	ctx.r[5].u64 = ctx.r[3].u64 & ctx.r[12].u64;
	// 821D3664: 57E40000  rlwinm r4, r31, 0, 0, 0
	ctx.r[4].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3668: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821D366C: 614A9250  ori r10, r10, 0x9250
	ctx.r[10].u64 = ctx.r[10].u64 | 37456;
	// 821D3670: 64AB0006  oris r11, r5, 6
	ctx.r[11].u64 = ctx.r[5].u64 | 393216;
	// 821D3674: 7C884378  or r8, r4, r8
	ctx.r[8].u64 = ctx.r[4].u64 | ctx.r[8].u64;
	// 821D3678: 48000124  b 0x821d379c
	pc = 0x821D379C; continue 'dispatch;
	// 821D367C: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3680: 554A073E  clrlwi r10, r10, 0x1c
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 821D3684: 5524877E  rlwinm r4, r9, 0x10, 0x1d, 0x1f
	ctx.r[4].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 821D3688: 5525B6B8  rlwinm r5, r9, 0x16, 0x1a, 0x1c
	ctx.r[5].u64 = ctx.r[9].u32 as u64 & 0x000003FFu64;
	// 821D368C: 55356F7E  rlwinm r21, r9, 0xd, 0x1d, 0x1f
	ctx.r[21].u64 = ctx.r[9].u32 as u64 & 0x0007FFFFu64;
	// 821D3690: 7CA52378  or r5, r5, r4
	ctx.r[5].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 821D3694: 5524042A  rlwinm r4, r9, 0, 0x10, 0x15
	ctx.r[4].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3698: 54A51838  slwi r5, r5, 3
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821D369C: 55340632  rlwinm r20, r9, 0, 0x18, 0x19
	ctx.r[20].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821D36A0: 7CA5AB78  or r5, r5, r21
	ctx.r[5].u64 = ctx.r[5].u64 | ctx.r[21].u64;
	// 821D36A4: 2B140040  cmplwi cr6, r20, 0x40
	ctx.cr[6].compare_u32(ctx.r[20].u32, 64 as u32, &mut ctx.xer);
	// 821D36A8: 54A5083C  slwi r5, r5, 1
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821D36AC: 7CA52378  or r5, r5, r4
	ctx.r[5].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 821D36B0: 54A51838  slwi r5, r5, 3
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821D36B4: 7CAA5378  or r10, r5, r10
	ctx.r[10].u64 = ctx.r[5].u64 | ctx.r[10].u64;
	// 821D36B8: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D36BC: 409A0084  bne cr6, 0x821d3740
	if !ctx.cr[6].eq {
	pc = 0x821D3740; continue 'dispatch;
	}
	// 821D36C0: 55440424  rlwinm r4, r10, 0, 0x10, 0x12
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821D36C4: 5545043E  clrlwi r5, r10, 0x10
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D36C8: 2B046000  cmplwi cr6, r4, 0x6000
	ctx.cr[6].compare_u32(ctx.r[4].u32, 24576 as u32, &mut ctx.xer);
	// 821D36CC: 41990014  bgt cr6, 0x821d36e0
	if ctx.cr[6].gt {
	pc = 0x821D36E0; continue 'dispatch;
	}
	// 821D36D0: 54AA0424  rlwinm r10, r5, 0, 0x10, 0x12
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821D36D4: 54A504FE  clrlwi r5, r5, 0x13
	ctx.r[5].u64 = ctx.r[5].u32 as u64 & 0x00001FFFu64;
	// 821D36D8: 694A2000  xori r10, r10, 0x2000
	ctx.r[10].u64 = ctx.r[10].u64 ^ 8192;
	// 821D36DC: 7D4A2B78  or r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 821D36E0: 554404EA  rlwinm r4, r10, 0, 0x13, 0x15
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821D36E4: 5545043E  clrlwi r5, r10, 0x10
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D36E8: 2B040C00  cmplwi cr6, r4, 0xc00
	ctx.cr[6].compare_u32(ctx.r[4].u32, 3072 as u32, &mut ctx.xer);
	// 821D36EC: 41990014  bgt cr6, 0x821d3700
	if ctx.cr[6].gt {
	pc = 0x821D3700; continue 'dispatch;
	}
	// 821D36F0: 54AA04EA  rlwinm r10, r5, 0, 0x13, 0x15
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821D36F4: 70A5E3FF  andi. r5, r5, 0xe3ff
	ctx.r[5].u64 = ctx.r[5].u64 & 58367;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821D36F8: 694A0400  xori r10, r10, 0x400
	ctx.r[10].u64 = ctx.r[10].u64 ^ 1024;
	// 821D36FC: 7D4A2B78  or r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 821D3700: 554405B0  rlwinm r4, r10, 0, 0x16, 0x18
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3704: 5545043E  clrlwi r5, r10, 0x10
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D3708: 2B040180  cmplwi cr6, r4, 0x180
	ctx.cr[6].compare_u32(ctx.r[4].u32, 384 as u32, &mut ctx.xer);
	// 821D370C: 41990014  bgt cr6, 0x821d3720
	if ctx.cr[6].gt {
	pc = 0x821D3720; continue 'dispatch;
	}
	// 821D3710: 54AA05B0  rlwinm r10, r5, 0, 0x16, 0x18
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3714: 70A5FC7F  andi. r5, r5, 0xfc7f
	ctx.r[5].u64 = ctx.r[5].u64 & 64639;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821D3718: 694A0080  xori r10, r10, 0x80
	ctx.r[10].u64 = ctx.r[10].u64 ^ 128;
	// 821D371C: 7D4A2B78  or r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 821D3720: 55440676  rlwinm r4, r10, 0, 0x19, 0x1b
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3724: 5545043E  clrlwi r5, r10, 0x10
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D3728: 2B040030  cmplwi cr6, r4, 0x30
	ctx.cr[6].compare_u32(ctx.r[4].u32, 48 as u32, &mut ctx.xer);
	// 821D372C: 41990014  bgt cr6, 0x821d3740
	if ctx.cr[6].gt {
	pc = 0x821D3740; continue 'dispatch;
	}
	// 821D3730: 54AA0676  rlwinm r10, r5, 0, 0x19, 0x1b
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3734: 70A5FF8F  andi. r5, r5, 0xff8f
	ctx.r[5].u64 = ctx.r[5].u64 & 65423;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821D3738: 694A0010  xori r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u64 ^ 16;
	// 821D373C: 7D4A2B78  or r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 821D3740: A0A80000  lhz r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3744: 3C800156  lis r4, 0x156
	ctx.r[4].s64 = 22413312;
	// 821D3748: A1080002  lhz r8, 2(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(2 as u32) ) } as u64;
	// 821D374C: 553563A6  rlwinm r21, r9, 0xc, 0xe, 0x13
	ctx.r[21].u64 = ctx.r[9].u32 as u64 & 0x000FFFFFu64;
	// 821D3750: 2285005F  subfic r20, r5, 0x5f
	ctx.xer.ca = ctx.r[5].u32 <= 95 as u32;
	ctx.r[20].s64 = (95 as i64) - ctx.r[5].s64;
	// 821D3754: 60840056  ori r4, r4, 0x56
	ctx.r[4].u64 = ctx.r[4].u64 | 86;
	// 821D3758: 552905AE  rlwinm r9, r9, 0, 0x16, 0x17
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821D375C: 7C9421D6  mullw r4, r20, r4
	ctx.r[4].s64 = (ctx.r[20].s32 as i64) * (ctx.r[4].s32 as i64);
	// 821D3760: 7CA530AE  lbzx r5, r5, r6
	ctx.r[5].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821D3764: 7C942378  mr r20, r4
	ctx.r[20].u64 = ctx.r[4].u64;
	// 821D3768: 3D80BFC0  lis r12, -0x4040
	ctx.r[12].s64 = -1077936128;
	// 821D376C: 50945A18  rlwimi r20, r4, 0xb, 8, 0xc
	ctx.r[20].u64 = (((ctx.r[4].u32).rotate_left(11) as u64) & 0x0000000000F80000) | (ctx.r[20].u64 & 0xFFFFFFFFFF07FFFF);
	// 821D3770: 5508306E  rlwinm r8, r8, 6, 1, 0x17
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x03FFFFFFu64;
	// 821D3774: 7EA94B78  or r9, r21, r9
	ctx.r[9].u64 = ctx.r[21].u64 | ctx.r[9].u64;
	// 821D3778: 618CCFFF  ori r12, r12, 0xcfff
	ctx.r[12].u64 = ctx.r[12].u64 | 53247;
	// 821D377C: 528B0956  rlwimi r11, r20, 1, 5, 0xb
	ctx.r[11].u64 = (((ctx.r[20].u32).rotate_left(1) as u64) & 0x0000000007F00000) | (ctx.r[11].u64 & 0xFFFFFFFFF80FFFFF);
	// 821D3780: 7D082B78  or r8, r8, r5
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[5].u64;
	// 821D3784: 55242036  slwi r4, r9, 4
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821D3788: 7C636038  and r3, r3, r12
	ctx.r[3].u64 = ctx.r[3].u64 & ctx.r[12].u64;
	// 821D378C: 57E50000  rlwinm r5, r31, 0, 0, 0
	ctx.r[5].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3790: 55690142  rlwinm r9, r11, 0, 5, 1
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3794: 7C8B1B78  or r11, r4, r3
	ctx.r[11].u64 = ctx.r[4].u64 | ctx.r[3].u64;
	// 821D3798: 7D082B78  or r8, r8, r5
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[5].u64;
	// 821D379C: 55650F3C  rlwinm r5, r11, 1, 0x1c, 0x1e
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 821D37A0: 91270000  stw r9, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D37A4: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D37A8: 91070008  stw r8, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821D37AC: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821D37B0: 614A000E  ori r10, r10, 0xe
	ctx.r[10].u64 = ctx.r[10].u64 | 14;
	// 821D37B4: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 821D37B8: 7D25EA2E  lhzx r9, r5, r29
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 821D37BC: 5548043E  clrlwi r8, r10, 0x10
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D37C0: 5545043E  clrlwi r5, r10, 0x10
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D37C4: 7D294038  and r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821D37C8: 5548043E  clrlwi r8, r10, 0x10
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D37CC: 5524043E  clrlwi r4, r9, 0x10
	ctx.r[4].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 821D37D0: 5529ECFE  rlwinm r9, r9, 0x1d, 0x13, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 821D37D4: 5543043E  clrlwi r3, r10, 0x10
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D37D8: 7D292378  or r9, r9, r4
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[4].u64;
	// 821D37DC: 5529E8FE  srwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821D37E0: 7D292378  or r9, r9, r4
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[4].u64;
	// 821D37E4: 5529E8FE  srwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821D37E8: 7D292378  or r9, r9, r4
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[4].u64;
	// 821D37EC: 5529E8FE  srwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821D37F0: 7D292378  or r9, r9, r4
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[4].u64;
	// 821D37F4: 512BFF7E  rlwimi r11, r9, 0x1f, 0x1d, 0x1f
	ctx.r[11].u64 = (((ctx.r[9].u32).rotate_left(31) as u64) & 0x0000000000000007) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFFFF8);
	// 821D37F8: 5569F73C  rlwinm r9, r11, 0x1e, 0x1c, 0x1e
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 821D37FC: 7D29EA2E  lhzx r9, r9, r29
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 821D3800: 7D292838  and r9, r9, r5
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[5].u64;
	// 821D3804: 5525043E  clrlwi r5, r9, 0x10
	ctx.r[5].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 821D3808: 5524ECFE  rlwinm r4, r9, 0x1d, 0x13, 0x1f
	ctx.r[4].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 821D380C: 552913BA  rlwinm r9, r9, 2, 0xe, 0x1d
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x3FFFFFFFu64;
	// 821D3810: 7C842B78  or r4, r4, r5
	ctx.r[4].u64 = ctx.r[4].u64 | ctx.r[5].u64;
	// 821D3814: 5484E8FE  srwi r4, r4, 3
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shr(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821D3818: 7C842B78  or r4, r4, r5
	ctx.r[4].u64 = ctx.r[4].u64 | ctx.r[5].u64;
	// 821D381C: 5484E8FE  srwi r4, r4, 3
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shr(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821D3820: 7C852B78  or r5, r4, r5
	ctx.r[5].u64 = ctx.r[4].u64 | ctx.r[5].u64;
	// 821D3824: 54A5F87E  srwi r5, r5, 1
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shr(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821D3828: 7CA94B78  or r9, r5, r9
	ctx.r[9].u64 = ctx.r[5].u64 | ctx.r[9].u64;
	// 821D382C: 51690772  rlwimi r9, r11, 0, 0x1d, 0x19
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(0) as u64) & 0xFFFFFFFFFFFFFFC7) | (ctx.r[9].u64 & 0x0000000000000038);
	// 821D3830: 552BDF3C  rlwinm r11, r9, 0x1b, 0x1c, 0x1e
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 821D3834: 7D6BEA2E  lhzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 821D3838: 7D6B4038  and r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[8].u64;
	// 821D383C: 5568043E  clrlwi r8, r11, 0x10
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821D3840: 5565ECFE  rlwinm r5, r11, 0x1d, 0x13, 0x1f
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 821D3844: 556B1B78  rlwinm r11, r11, 3, 0xd, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 821D3848: 7CA54378  or r5, r5, r8
	ctx.r[5].u64 = ctx.r[5].u64 | ctx.r[8].u64;
	// 821D384C: 7D6B4378  or r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[8].u64;
	// 821D3850: 54A5E8FE  srwi r5, r5, 3
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shr(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821D3854: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D3858: 7CA84378  or r8, r5, r8
	ctx.r[8].u64 = ctx.r[5].u64 | ctx.r[8].u64;
	// 821D385C: 5508F87E  srwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D3860: 7D0B5B78  or r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 | ctx.r[11].u64;
	// 821D3864: 512B06AC  rlwimi r11, r9, 0, 0x1a, 0x16
	ctx.r[11].u64 = (((ctx.r[9].u32).rotate_left(0) as u64) & 0xFFFFFFFFFFFFFE3F) | (ctx.r[11].u64 & 0x00000000000001C0);
	// 821D3868: 5569C73C  rlwinm r9, r11, 0x18, 0x1c, 0x1e
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D386C: 7D29EA2E  lhzx r9, r9, r29
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 821D3870: 7D291838  and r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[3].u64;
	// 821D3874: 5528043E  clrlwi r8, r9, 0x10
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 821D3878: 55251B78  rlwinm r5, r9, 3, 0xd, 0x1c
	ctx.r[5].u64 = ctx.r[9].u32 as u64 & 0x1FFFFFFFu64;
	// 821D387C: 5529ECFE  rlwinm r9, r9, 0x1d, 0x13, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 821D3880: 7CA54378  or r5, r5, r8
	ctx.r[5].u64 = ctx.r[5].u64 | ctx.r[8].u64;
	// 821D3884: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821D3888: 54A51838  slwi r5, r5, 3
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821D388C: 5529F87E  srwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821D3890: 7CA84378  or r8, r5, r8
	ctx.r[8].u64 = ctx.r[5].u64 | ctx.r[8].u64;
	// 821D3894: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D3898: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821D389C: 516905E6  rlwimi r9, r11, 0, 0x17, 0x13
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(0) as u64) & 0xFFFFFFFFFFFFF1FF) | (ctx.r[9].u64 & 0x0000000000000E00);
	// 821D38A0: 91270004  stw r9, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821D38A4: 38E7000C  addi r7, r7, 0xc
	ctx.r[7].s64 = ctx.r[7].s64 + 12;
	// 821D38A8: 4082FD44  bne 0x821d35ec
	if !ctx.cr[0].eq {
	pc = 0x821D35EC; continue 'dispatch;
	}
	// 821D38AC: 576B103A  slwi r11, r27, 2
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D38B0: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 821D38B4: 7F4BF214  add r26, r11, r30
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821D38B8: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821D38BC: 4098027C  bge cr6, 0x821d3b38
	if !ctx.cr[6].lt {
	pc = 0x821D3B38; continue 'dispatch;
	}
	// 821D38C0: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 821D38C4: 3B2BB720  addi r25, r11, -0x48e0
	ctx.r[25].s64 = ctx.r[11].s64 + -18656;
	// 821D38C8: 7F1BD040  cmplw cr6, r27, r26
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821D38CC: 4098026C  bge cr6, 0x821d3b38
	if !ctx.cr[6].lt {
	pc = 0x821D3B38; continue 'dispatch;
	}
	// 821D38D0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D38D4: 556B0297  rlwinm. r11, r11, 0, 0xa, 0xb
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D38D8: 40820010  bne 0x821d38e8
	if !ctx.cr[0].eq {
	pc = 0x821D38E8; continue 'dispatch;
	}
	// 821D38DC: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 821D38E0: 7F1BD040  cmplw cr6, r27, r26
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821D38E4: 4198FFEC  blt cr6, 0x821d38d0
	if ctx.cr[6].lt {
	pc = 0x821D38D0; continue 'dispatch;
	}
	// 821D38E8: 7F1BD040  cmplw cr6, r27, r26
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821D38EC: 4098024C  bge cr6, 0x821d3b38
	if !ctx.cr[6].lt {
	pc = 0x821D3B38; continue 'dispatch;
	}
	// 821D38F0: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 821D38F4: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 821D38F8: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821D38FC: 4098023C  bge cr6, 0x821d3b38
	if !ctx.cr[6].lt {
	pc = 0x821D3B38; continue 'dispatch;
	}
	// 821D3900: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3904: 55290297  rlwinm. r9, r9, 0, 0xa, 0xb
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821D3908: 40820010  bne 0x821d3918
	if !ctx.cr[0].eq {
	pc = 0x821D3918; continue 'dispatch;
	}
	// 821D390C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821D3910: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821D3914: 4198FFEC  blt cr6, 0x821d3900
	if ctx.cr[6].lt {
	pc = 0x821D3900; continue 'dispatch;
	}
	// 821D3918: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821D391C: 4098021C  bge cr6, 0x821d3b38
	if !ctx.cr[6].lt {
	pc = 0x821D3B38; continue 'dispatch;
	}
	// 821D3920: 7D1E5050  subf r8, r30, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[30].s64;
	// 821D3924: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3928: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D392C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 821D3930: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 821D3934: 7D081670  srawi r8, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821D3938: 38AA0001  addi r5, r10, 1
	ctx.r[5].s64 = ctx.r[10].s64 + 1;
	// 821D393C: 1D08000C  mulli r8, r8, 0xc
	ctx.r[8].s64 = ctx.r[8].s64 * 12;
	// 821D3940: 3945FFFF  addi r10, r5, -1
	ctx.r[10].s64 = ctx.r[5].s64 + -1;
	// 821D3944: 54E70296  rlwinm r7, r7, 0, 0xa, 0xb
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3948: 3CC00030  lis r6, 0x30
	ctx.r[6].s64 = 3145728;
	// 821D394C: 7C684A14  add r3, r8, r9
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821D3950: 3B6B0004  addi r27, r11, 4
	ctx.r[27].s64 = ctx.r[11].s64 + 4;
	// 821D3954: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 821D3958: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821D395C: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 821D3960: 7F073040  cmplw cr6, r7, r6
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D3964: 409A002C  bne cr6, 0x821d3990
	if !ctx.cr[6].eq {
	pc = 0x821D3990; continue 'dispatch;
	}
	// 821D3968: 7D1E5850  subf r8, r30, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 821D396C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821D3970: 7D081670  srawi r8, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821D3974: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 821D3978: 1D08000C  mulli r8, r8, 0xc
	ctx.r[8].s64 = ctx.r[8].s64 * 12;
	// 821D397C: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821D3980: 5568767A  rlwinm r8, r11, 0xe, 0x19, 0x1d
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x0003FFFFu64;
	// 821D3984: 556B3FBE  rlwinm r11, r11, 7, 0x1e, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x01FFFFFFu64;
	// 821D3988: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 821D398C: 7D1D5B78  or r29, r8, r11
	ctx.r[29].u64 = ctx.r[8].u64 | ctx.r[11].u64;
	// 821D3990: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D3994: 419A00EC  beq cr6, 0x821d3a80
	if ctx.cr[6].eq {
	pc = 0x821D3A80; continue 'dispatch;
	}
	// 821D3998: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 821D399C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821D39A0: 7F1F2040  cmplw cr6, r31, r4
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821D39A4: 409800CC  bge cr6, 0x821d3a70
	if !ctx.cr[6].lt {
	pc = 0x821D3A70; continue 'dispatch;
	}
	// 821D39A8: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 821D39AC: 7F9F2050  subf r28, r31, r4
	ctx.r[28].s64 = ctx.r[4].s64 - ctx.r[31].s64;
	// 821D39B0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D39B4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D39B8: 5506767A  rlwinm r6, r8, 0xe, 0x19, 0x1d
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x0003FFFFu64;
	// 821D39BC: 55083FBE  rlwinm r8, r8, 7, 0x1e, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x01FFFFFFu64;
	// 821D39C0: 54F8767A  rlwinm r24, r7, 0xe, 0x19, 0x1d
	ctx.r[24].u64 = ctx.r[7].u32 as u64 & 0x0003FFFFu64;
	// 821D39C4: 54F73FBE  rlwinm r23, r7, 7, 0x1e, 0x1f
	ctx.r[23].u64 = ctx.r[7].u32 as u64 & 0x01FFFFFFu64;
	// 821D39C8: 7CC74378  or r7, r6, r8
	ctx.r[7].u64 = ctx.r[6].u64 | ctx.r[8].u64;
	// 821D39CC: 7F06BB78  or r6, r24, r23
	ctx.r[6].u64 = ctx.r[24].u64 | ctx.r[23].u64;
	// 821D39D0: 7D073051  subf. r8, r7, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[7].s64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821D39D4: 4182001C  beq 0x821d39f0
	if ctx.cr[0].eq {
	pc = 0x821D39F0; continue 'dispatch;
	}
	// 821D39D8: 7F1D3800  cmpw cr6, r29, r7
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821D39DC: 419A0058  beq cr6, 0x821d3a34
	if ctx.cr[6].eq {
	pc = 0x821D3A34; continue 'dispatch;
	}
	// 821D39E0: 7F1D3000  cmpw cr6, r29, r6
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821D39E4: 409A0048  bne cr6, 0x821d3a2c
	if !ctx.cr[6].eq {
	pc = 0x821D3A2C; continue 'dispatch;
	}
	// 821D39E8: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 821D39EC: 48000040  b 0x821d3a2c
	pc = 0x821D3A2C; continue 'dispatch;
	// 821D39F0: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D39F4: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D39F8: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D39FC: 54E7083C  slwi r7, r7, 1
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821D3A00: 7D084E70  srawi r8, r8, 9
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 9) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> 9) as i64;
	// 821D3A04: 7CE74E70  srawi r7, r7, 9
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 9) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[7].s32 >> 9) as i64;
	// 821D3A08: 7D074051  subf. r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821D3A0C: 40820020  bne 0x821d3a2c
	if !ctx.cr[0].eq {
	pc = 0x821D3A2C; continue 'dispatch;
	}
	// 821D3A10: A10B0004  lhz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3A14: A0EA0004  lhz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3A18: 550806BE  clrlwi r8, r8, 0x1a
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x0000003Fu64;
	// 821D3A1C: 54E706BE  clrlwi r7, r7, 0x1a
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x0000003Fu64;
	// 821D3A20: 7D08C8AE  lbzx r8, r8, r25
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 821D3A24: 7CE7C8AE  lbzx r7, r7, r25
	ctx.r[7].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 821D3A28: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 821D3A2C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821D3A30: 40990034  ble cr6, 0x821d3a64
	if !ctx.cr[6].gt {
	pc = 0x821D3A64; continue 'dispatch;
	}
	// 821D3A34: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3A38: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3A3C: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3A40: 830B0008  lwz r24, 8(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D3A44: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821D3A48: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3A4C: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821D3A50: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D3A54: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821D3A58: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821D3A5C: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821D3A60: 930A0008  stw r24, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 821D3A64: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821D3A68: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 821D3A6C: 4082FF44  bne 0x821d39b0
	if !ctx.cr[0].eq {
	pc = 0x821D39B0; continue 'dispatch;
	}
	// 821D3A70: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821D3A74: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 821D3A78: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821D3A7C: 4082FF24  bne 0x821d39a0
	if !ctx.cr[0].eq {
	pc = 0x821D39A0; continue 'dispatch;
	}
	// 821D3A80: 1D65000C  mulli r11, r5, 0xc
	ctx.r[11].s64 = ctx.r[5].s64 * 12;
	// 821D3A84: 7CCB1A14  add r6, r11, r3
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821D3A88: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 821D3A8C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821D3A90: 4800009C  b 0x821d3b2c
	pc = 0x821D3B2C; continue 'dispatch;
	// 821D3A94: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3A98: 81070000  lwz r8, 0(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3A9C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 821D3AA0: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 821D3AA4: 5149CB1A  rlwimi r9, r10, 0x19, 0xc, 0xd
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(25) as u64) & 0x00000000000C0000) | (ctx.r[9].u64 & 0xFFFFFFFFFFF3FFFF);
	// 821D3AA8: 5105CB1A  rlwimi r5, r8, 0x19, 0xc, 0xd
	ctx.r[5].u64 = (((ctx.r[8].u32).rotate_left(25) as u64) & 0x00000000000C0000) | (ctx.r[5].u64 & 0xFFFFFFFFFFF3FFFF);
	// 821D3AAC: 552A01DA  rlwinm r10, r9, 0, 7, 0xd
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3AB0: 54A901DA  rlwinm r9, r5, 0, 7, 0xd
	ctx.r[9].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3AB4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D3AB8: 409A006C  bne cr6, 0x821d3b24
	if !ctx.cr[6].eq {
	pc = 0x821D3B24; continue 'dispatch;
	}
	// 821D3ABC: 81470008  lwz r10, 8(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D3AC0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D3AC4: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D3AC8: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821D3ACC: 7D4A4E70  srawi r10, r10, 9
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 9) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 9) as i64;
	// 821D3AD0: 7D294E70  srawi r9, r9, 9
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 9) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 9) as i64;
	// 821D3AD4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821D3AD8: 4199004C  bgt cr6, 0x821d3b24
	if ctx.cr[6].gt {
	pc = 0x821D3B24; continue 'dispatch;
	}
	// 821D3ADC: A0AB0004  lhz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3AE0: 54A506BE  clrlwi r5, r5, 0x1a
	ctx.r[5].u64 = ctx.r[5].u32 as u64 & 0x0000003Fu64;
	// 821D3AE4: 7CA5C8AE  lbzx r5, r5, r25
	ctx.r[5].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 821D3AE8: 7D4A2850  subf r10, r10, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 821D3AEC: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821D3AF0: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 821D3AF4: 41990030  bgt cr6, 0x821d3b24
	if ctx.cr[6].gt {
	pc = 0x821D3B24; continue 'dispatch;
	}
	// 821D3AF8: 55092F7E  rlwinm r9, r8, 5, 0x1d, 0x1f
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x07FFFFFFu64;
	// 821D3AFC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821D3B00: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D3B04: 40990008  ble cr6, 0x821d3b0c
	if !ctx.cr[6].gt {
	pc = 0x821D3B0C; continue 'dispatch;
	}
	// 821D3B08: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821D3B0C: 5148D888  rlwimi r8, r10, 0x1b, 2, 4
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(27) as u64) & 0x0000000038000000) | (ctx.r[8].u64 & 0xFFFFFFFFC7FFFFFF);
	// 821D3B10: 91070000  stw r8, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821D3B14: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3B18: 654A4000  oris r10, r10, 0x4000
	ctx.r[10].u64 = ctx.r[10].u64 | 1073741824;
	// 821D3B1C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821D3B20: 48000008  b 0x821d3b28
	pc = 0x821D3B28; continue 'dispatch;
	// 821D3B24: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 821D3B28: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 821D3B2C: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D3B30: 4198FF64  blt cr6, 0x821d3a94
	if ctx.cr[6].lt {
	pc = 0x821D3A94; continue 'dispatch;
	}
	// 821D3B34: 4BFFFD94  b 0x821d38c8
	pc = 0x821D38C8; continue 'dispatch;
	// 821D3B38: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 821D3B3C: 48000030  b 0x821d3b6c
	pc = 0x821D3B6C; continue 'dispatch;
	// 821D3B40: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3B44: 556B053E  clrlwi r11, r11, 0x14
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 821D3B48: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 821D3B4C: 7C6BB214  add r3, r11, r22
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[22].u64;
	// 821D3B50: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821D3B54: 419A0010  beq cr6, 0x821d3b64
	if ctx.cr[6].eq {
	pc = 0x821D3B64; continue 'dispatch;
	}
	// 821D3B58: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 821D3B5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D3B60: 48AD5921  bl 0x82ca9480
	ctx.lr = 0x821D3B64;
	sub_82CA9480(ctx, base);
	// 821D3B64: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821D3B68: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 821D3B6C: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821D3B70: 4198FFD0  blt cr6, 0x821d3b40
	if ctx.cr[6].lt {
	pc = 0x821D3B40; continue 'dispatch;
	}
	// 821D3B74: 38210250  addi r1, r1, 0x250
	ctx.r[1].s64 = ctx.r[1].s64 + 592;
	// 821D3B78: 48AD58C0  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D3B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D3B80 size=1792
    let mut pc: u32 = 0x821D3B80;
    'dispatch: loop {
        match pc {
            0x821D3B80 => {
    //   block [0x821D3B80..0x821D4280)
	// 821D3B80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D3B84: 48AD5879  bl 0x82ca93fc
	ctx.lr = 0x821D3B88;
	sub_82CA93D0(ctx, base);
	// 821D3B88: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D3B8C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821D3B90: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821D3B94: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821D3B98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D3B9C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3BA0: C0099A80  lfs f0, -0x6580(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D3BA4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D3BA8: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
	// 821D3BAC: 3B5E0410  addi r26, r30, 0x410
	ctx.r[26].s64 = ctx.r[30].s64 + 1040;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D4280 size=936
    let mut pc: u32 = 0x821D4280;
    'dispatch: loop {
        match pc {
            0x821D4280 => {
    //   block [0x821D4280..0x821D4628)
	// 821D4280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D4284: 48AD517D  bl 0x82ca9400
	ctx.lr = 0x821D4288;
	sub_82CA93D0(ctx, base);
	// 821D4288: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D428C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821D4290: 39400070  li r10, 0x70
	ctx.r[10].s64 = 112;
	// 821D4294: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 821D4298: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821D429C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D42A0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D42A4: C0089A80  lfs f0, -0x6580(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D42A8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D42AC: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D4628 size=1192
    let mut pc: u32 = 0x821D4628;
    'dispatch: loop {
        match pc {
            0x821D4628 => {
    //   block [0x821D4628..0x821D4AD0)
	// 821D4628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D462C: 48AD4DC5  bl 0x82ca93f0
	ctx.lr = 0x821D4630;
	sub_82CA93D0(ctx, base);
	// 821D4630: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D4634: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821D4638: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821D463C: 3ACB8D14  addi r22, r11, -0x72ec
	ctx.r[22].s64 = ctx.r[11].s64 + -29420;
	// 821D4640: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D4644: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D4648: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 821D464C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 821D4650: 4802C121  bl 0x82200770
	ctx.lr = 0x821D4654;
	sub_82200770(ctx, base);
	// 821D4654: 3EE08349  lis r23, -0x7cb7
	ctx.r[23].s64 = -2092367872;
	// 821D4658: 81776AB8  lwz r11, 0x6ab8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D465C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D4660: 814B0078  lwz r10, 0x78(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 821D4664: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4668: 480AD979  bl 0x82281fe0
	ctx.lr = 0x821D466C;
	sub_82281FE0(ctx, base);
	// 821D466C: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D4670: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821D4674: 419A000C  beq cr6, 0x821d4680
	if ctx.cr[6].eq {
	pc = 0x821D4680; continue 'dispatch;
	}
	// 821D4678: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D467C: 490E52D9  bl 0x832b9954
	ctx.lr = 0x821D4680;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 821D4680: 81776AB8  lwz r11, 0x6ab8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D4684: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D4688: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821D468C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4690: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4694: 550A003E  slwi r10, r8, 0
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D4698: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D469C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D46A0: 409A000C  bne cr6, 0x821d46ac
	if !ctx.cr[6].eq {
	pc = 0x821D46AC; continue 'dispatch;
	}
	// 821D46A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D46A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D46AC: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D46B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D46B4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D46B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D46BC: 4E800421  bctrl
	ctx.lr = 0x821D46C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D46C0: 81390000  lwz r9, 0(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D46C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D46C8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821D46CC: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D46D0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821D46D4: 4E800421  bctrl
	ctx.lr = 0x821D46D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D46D8: 7CFF1850  subf r7, r31, r3
	ctx.r[7].s64 = ctx.r[3].s64 - ctx.r[31].s64;
	// 821D46DC: 7CE60034  cntlzw r6, r7
	ctx.r[6].u64 = if ctx.r[7].u32 == 0 { 32 } else { ctx.r[7].u32.leading_zeros() as u64 };
	// 821D46E0: 54C5DFFE  rlwinm r5, r6, 0x1b, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 821D46E4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821D46E8: 419A03E0  beq cr6, 0x821d4ac8
	if ctx.cr[6].eq {
	pc = 0x821D4AC8; continue 'dispatch;
	}
	// 821D46EC: 8359002C  lwz r26, 0x2c(r25)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D46F0: 81790030  lwz r11, 0x30(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 821D46F4: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D46F8: 419A0134  beq cr6, 0x821d482c
	if ctx.cr[6].eq {
	pc = 0x821D482C; continue 'dispatch;
	}
	// 821D46FC: 81776AB8  lwz r11, 0x6ab8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D4700: 3B9A0004  addi r28, r26, 4
	ctx.r[28].s64 = ctx.r[26].s64 + 4;
	// 821D4704: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4708: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D470C: 806A009C  lwz r3, 0x9c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 821D4710: 4808FB21  bl 0x82264230
	ctx.lr = 0x821D4714;
	sub_82264230(ctx, base);
	// 821D4714: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D4718: 419A0104  beq cr6, 0x821d481c
	if ctx.cr[6].eq {
	pc = 0x821D481C; continue 'dispatch;
	}
	// 821D471C: 480CA75D  bl 0x8229ee78
	ctx.lr = 0x821D4720;
	sub_8229EE78(ctx, base);
	// 821D4720: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821D4724: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821D4728: 419A0018  beq cr6, 0x821d4740
	if ctx.cr[6].eq {
	pc = 0x821D4740; continue 'dispatch;
	}
	// 821D472C: 897B0090  lbz r11, 0x90(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(144 as u32) ) } as u64;
	// 821D4730: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D4734: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D4738: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D473C: 409A0008  bne cr6, 0x821d4744
	if !ctx.cr[6].eq {
	pc = 0x821D4744; continue 'dispatch;
	}
	// 821D4740: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 821D4744: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D4748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D474C: 419A00D0  beq cr6, 0x821d481c
	if ctx.cr[6].eq {
	pc = 0x821D481C; continue 'dispatch;
	}
	// 821D4750: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4754: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 821D4758: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821D475C: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4760: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821D4764: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4768: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821D476C: 419A000C  beq cr6, 0x821d4778
	if ctx.cr[6].eq {
	pc = 0x821D4778; continue 'dispatch;
	}
	// 821D4770: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821D4774: 419A0008  beq cr6, 0x821d477c
	if ctx.cr[6].eq {
	pc = 0x821D477C; continue 'dispatch;
	}
	// 821D4778: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D477C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D4780: 419A009C  beq cr6, 0x821d481c
	if ctx.cr[6].eq {
	pc = 0x821D481C; continue 'dispatch;
	}
	// 821D4784: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821D4788: 409A0008  bne cr6, 0x821d4790
	if !ctx.cr[6].eq {
	pc = 0x821D4790; continue 'dispatch;
	}
	// 821D478C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D4790: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4794: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D4798: 409A0008  bne cr6, 0x821d47a0
	if !ctx.cr[6].eq {
	pc = 0x821D47A0; continue 'dispatch;
	}
	// 821D479C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D47A0: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D47A4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821D47A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D47AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D47B0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D47B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D47B8: 4E800421  bctrl
	ctx.lr = 0x821D47BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D47BC: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D47C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D47C4: 419A0040  beq cr6, 0x821d4804
	if ctx.cr[6].eq {
	pc = 0x821D4804; continue 'dispatch;
	}
	// 821D47C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D47CC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821D47D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D47D4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D47D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D47DC: 4E800421  bctrl
	ctx.lr = 0x821D47E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D47E0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821D47E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821D47E8: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D47EC: 4867381D  bl 0x82848008
	ctx.lr = 0x821D47F0;
	sub_82848008(ctx, base);
	// 821D47F0: E9230000  ld r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821D47F4: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821D47F8: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D47FC: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D4800: 4BFFFF64  b 0x821d4764
	pc = 0x821D4764; continue 'dispatch;
	// 821D4804: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4808: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D480C: 409A0008  bne cr6, 0x821d4814
	if !ctx.cr[6].eq {
	pc = 0x821D4814; continue 'dispatch;
	}
	// 821D4810: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D4814: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4818: 4BFFFF48  b 0x821d4760
	pc = 0x821D4760; continue 'dispatch;
	// 821D481C: 81790030  lwz r11, 0x30(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 821D4820: 3B5A0010  addi r26, r26, 0x10
	ctx.r[26].s64 = ctx.r[26].s64 + 16;
	// 821D4824: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D4828: 409AFED4  bne cr6, 0x821d46fc
	if !ctx.cr[6].eq {
	pc = 0x821D46FC; continue 'dispatch;
	}
	// 821D482C: 83B90018  lwz r29, 0x18(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D4830: 8179001C  lwz r11, 0x1c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D4834: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 821D4838: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D483C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 821D4840: 419A0134  beq cr6, 0x821d4974
	if ctx.cr[6].eq {
	pc = 0x821D4974; continue 'dispatch;
	}
	// 821D4844: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D4848: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 821D484C: 552A003E  slwi r10, r9, 0
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D4850: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4854: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D4858: 409A000C  bne cr6, 0x821d4864
	if !ctx.cr[6].eq {
	pc = 0x821D4864; continue 'dispatch;
	}
	// 821D485C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D4860: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D4864: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D4868: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 821D486C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D4870: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4874: 419A0030  beq cr6, 0x821d48a4
	if ctx.cr[6].eq {
	pc = 0x821D48A4; continue 'dispatch;
	}
	// 821D4878: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D487C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D4880: 419A0040  beq cr6, 0x821d48c0
	if ctx.cr[6].eq {
	pc = 0x821D48C0; continue 'dispatch;
	}
	// 821D4884: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D4888: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D488C: 419A0018  beq cr6, 0x821d48a4
	if ctx.cr[6].eq {
	pc = 0x821D48A4; continue 'dispatch;
	}
	// 821D4890: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 821D4894: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D4898: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D489C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D48A0: 409A0008  bne cr6, 0x821d48a8
	if !ctx.cr[6].eq {
	pc = 0x821D48A8; continue 'dispatch;
	}
	// 821D48A4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 821D48A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D48AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D48B0: 419A0018  beq cr6, 0x821d48c8
	if ctx.cr[6].eq {
	pc = 0x821D48C8; continue 'dispatch;
	}
	// 821D48B4: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 821D48B8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 821D48BC: 480000AC  b 0x821d4968
	pc = 0x821D4968; continue 'dispatch;
	// 821D48C0: 4BFBF579  bl 0x82193e38
	ctx.lr = 0x821D48C4;
	sub_82193E38(ctx, base);
	// 821D48C4: 4BFFFFE0  b 0x821d48a4
	pc = 0x821D48A4; continue 'dispatch;
	// 821D48C8: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D48CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D48D0: 419A0018  beq cr6, 0x821d48e8
	if ctx.cr[6].eq {
	pc = 0x821D48E8; continue 'dispatch;
	}
	// 821D48D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D48D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D48DC: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821D48E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D48E4: 4E800421  bctrl
	ctx.lr = 0x821D48E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D48E8: 83D9001C  lwz r30, 0x1c(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D48EC: 3BFD0010  addi r31, r29, 0x10
	ctx.r[31].s64 = ctx.r[29].s64 + 16;
	// 821D48F0: 3B990014  addi r28, r25, 0x14
	ctx.r[28].s64 = ctx.r[25].s64 + 20;
	// 821D48F4: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821D48F8: 419A0020  beq cr6, 0x821d4918
	if ctx.cr[6].eq {
	pc = 0x821D4918; continue 'dispatch;
	}
	// 821D48FC: 7FBFE850  subf r29, r31, r29
	ctx.r[29].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	// 821D4900: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D4904: 7C7DFA14  add r3, r29, r31
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 821D4908: 482062A1  bl 0x823daba8
	ctx.lr = 0x821D490C;
	sub_823DABA8(ctx, base);
	// 821D490C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 821D4910: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821D4914: 409AFFEC  bne cr6, 0x821d4900
	if !ctx.cr[6].eq {
	pc = 0x821D4900; continue 'dispatch;
	}
	// 821D4918: 83BC0008  lwz r29, 8(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D491C: 3BDDFFF0  addi r30, r29, -0x10
	ctx.r[30].s64 = ctx.r[29].s64 + -16;
	// 821D4920: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821D4924: 419A002C  beq cr6, 0x821d4950
	if ctx.cr[6].eq {
	pc = 0x821D4950; continue 'dispatch;
	}
	// 821D4928: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 821D492C: 387FFFFC  addi r3, r31, -4
	ctx.r[3].s64 = ctx.r[31].s64 + -4;
	// 821D4930: 485CC4E9  bl 0x827a0e18
	ctx.lr = 0x821D4934;
	sub_827A0E18(ctx, base);
	// 821D4934: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4938: 48047401  bl 0x8221bd38
	ctx.lr = 0x821D493C;
	sub_8221BD38(ctx, base);
	// 821D493C: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 821D4940: 931F0000  stw r24, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 821D4944: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 821D4948: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821D494C: 409AFFE0  bne cr6, 0x821d492c
	if !ctx.cr[6].eq {
	pc = 0x821D492C; continue 'dispatch;
	}
	// 821D4950: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D4954: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D4958: 392BFFF0  addi r9, r11, -0x10
	ctx.r[9].s64 = ctx.r[11].s64 + -16;
	// 821D495C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821D4960: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D4964: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821D4968: 8179001C  lwz r11, 0x1c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D496C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D4970: 409AFED4  bne cr6, 0x821d4844
	if !ctx.cr[6].eq {
	pc = 0x821D4844; continue 'dispatch;
	}
	// 821D4974: 83F90018  lwz r31, 0x18(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D4978: 8179001C  lwz r11, 0x1c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D497C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D4980: 419A0048  beq cr6, 0x821d49c8
	if ctx.cr[6].eq {
	pc = 0x821D49C8; continue 'dispatch;
	}
	// 821D4984: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D4988: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 821D498C: 552A003E  slwi r10, r9, 0
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D4990: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4994: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D4998: 409A000C  bne cr6, 0x821d49a4
	if !ctx.cr[6].eq {
	pc = 0x821D49A4; continue 'dispatch;
	}
	// 821D499C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D49A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D49A4: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D49A8: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 821D49AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D49B0: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821D49B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D49B8: 4E800421  bctrl
	ctx.lr = 0x821D49BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D49BC: 8139001C  lwz r9, 0x1c(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D49C0: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821D49C4: 409AFFC0  bne cr6, 0x821d4984
	if !ctx.cr[6].eq {
	pc = 0x821D4984; continue 'dispatch;
	}
	// 821D49C8: 81776AB8  lwz r11, 0x6ab8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D49CC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D49D0: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821D49D4: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D49D8: 480A1591  bl 0x82275f68
	ctx.lr = 0x821D49DC;
	sub_82275F68(ctx, base);
	// 821D49DC: 81776AB8  lwz r11, 0x6ab8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D49E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821D49E4: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D49E8: 8088008C  lwz r4, 0x8c(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D49EC: 4BFD7BED  bl 0x821ac5d8
	ctx.lr = 0x821D49F0;
	sub_821AC5D8(ctx, base);
	// 821D49F0: 88E30004  lbz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D49F4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D49F8: 409A001C  bne cr6, 0x821d4a14
	if !ctx.cr[6].eq {
	pc = 0x821D4A14; continue 'dispatch;
	}
	// 821D49FC: 81776AB8  lwz r11, 0x6ab8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D4A00: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D4A04: 894B0104  lbz r10, 0x104(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 821D4A08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D4A0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D4A10: 419A0008  beq cr6, 0x821d4a18
	if ctx.cr[6].eq {
	pc = 0x821D4A18; continue 'dispatch;
	}
	// 821D4A14: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 821D4A18: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 821D4A1C: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D4A20: 480403B9  bl 0x82214dd8
	ctx.lr = 0x821D4A24;
	sub_82214DD8(ctx, base);
	// 821D4A24: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D4A28: 480403B1  bl 0x82214dd8
	ctx.lr = 0x821D4A2C;
	sub_82214DD8(ctx, base);
	// 821D4A2C: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 821D4A30: 480403A9  bl 0x82214dd8
	ctx.lr = 0x821D4A34;
	sub_82214DD8(ctx, base);
	// 821D4A34: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821D4A38: 480403A1  bl 0x82214dd8
	ctx.lr = 0x821D4A3C;
	sub_82214DD8(ctx, base);
	// 821D4A3C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821D4A40: 419A004C  beq cr6, 0x821d4a8c
	if ctx.cr[6].eq {
	pc = 0x821D4A8C; continue 'dispatch;
	}
	// 821D4A44: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 821D4A48: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D4A4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D4A50: 4802BD21  bl 0x82200770
	ctx.lr = 0x821D4A54;
	sub_82200770(ctx, base);
	// 821D4A54: 81776AB8  lwz r11, 0x6ab8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D4A58: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D4A5C: 894B0104  lbz r10, 0x104(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 821D4A60: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D4A64: 409A0014  bne cr6, 0x821d4a78
	if !ctx.cr[6].eq {
	pc = 0x821D4A78; continue 'dispatch;
	}
	// 821D4A68: 806B009C  lwz r3, 0x9c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) } as u64;
	// 821D4A6C: 48023D5D  bl 0x821f87c8
	ctx.lr = 0x821D4A70;
	sub_821F87C8(ctx, base);
	// 821D4A70: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4A74: 4BFE47E5  bl 0x821b9258
	ctx.lr = 0x821D4A78;
	sub_821B9258(ctx, base);
	// 821D4A78: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D4A7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D4A80: 419A000C  beq cr6, 0x821d4a8c
	if ctx.cr[6].eq {
	pc = 0x821D4A8C; continue 'dispatch;
	}
	// 821D4A84: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D4A88: 490E4ECD  bl 0x832b9954
	ctx.lr = 0x821D4A8C;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 821D4A8C: 81776AB8  lwz r11, 0x6ab8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D4A90: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D4A94: 812A008C  lwz r9, 0x8c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D4A98: 888900F5  lbz r4, 0xf5(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(245 as u32) ) } as u64;
	// 821D4A9C: 890900F3  lbz r8, 0xf3(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(243 as u32) ) } as u64;
	// 821D4AA0: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 821D4AA4: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821D4AA8: 419A0010  beq cr6, 0x821d4ab8
	if ctx.cr[6].eq {
	pc = 0x821D4AB8; continue 'dispatch;
	}
	// 821D4AAC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D4AB0: 806B008C  lwz r3, 0x8c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D4AB4: 48158205  bl 0x8232ccb8
	ctx.lr = 0x821D4AB8;
	sub_8232CCB8(ctx, base);
	// 821D4AB8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821D4ABC: 816A9650  lwz r11, -0x69b0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 821D4AC0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D4AC4: 916A9650  stw r11, -0x69b0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-27056 as u32), ctx.r[11].u32 ) };
	// 821D4AC8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821D4ACC: 48AD4974  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D4AD0 size=396
    let mut pc: u32 = 0x821D4AD0;
    'dispatch: loop {
        match pc {
            0x821D4AD0 => {
    //   block [0x821D4AD0..0x821D4C5C)
	// 821D4AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D4AD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D4AD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D4ADC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821D4AE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D4AE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D4AE8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821D4AEC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D4AF0: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	// 821D4AF4: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 821D4AF8: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4AFC: 989F000E  stb r4, 0xe(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(14 as u32), ctx.r[4].u8 ) };
	// 821D4B00: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821D4B04: 80A6001C  lwz r5, 0x1c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D4B08: 81260018  lwz r9, 0x18(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D4B0C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821D4B10: 7D092850  subf r8, r9, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[9].s64;
	// 821D4B14: 7D6853D7  divw. r11, r8, r10
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D4B18: 4081005C  ble 0x821d4b74
	if !ctx.cr[0].gt {
	pc = 0x821D4B74; continue 'dispatch;
	}
	// 821D4B1C: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D4B20: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D4B24: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821D4B28: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D4B2C: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821D4B30: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4B34: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 821D4B38: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D4B3C: 41980008  blt cr6, 0x821d4b44
	if ctx.cr[6].lt {
	pc = 0x821D4B44; continue 'dispatch;
	}
	// 821D4B40: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 821D4B44: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D4B48: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D4B4C: 419A0014  beq cr6, 0x821d4b60
	if ctx.cr[6].eq {
	pc = 0x821D4B60; continue 'dispatch;
	}
	// 821D4B50: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D4B54: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 821D4B58: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D4B5C: 4800000C  b 0x821d4b68
	pc = 0x821D4B68; continue 'dispatch;
	// 821D4B60: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821D4B64: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821D4B68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D4B6C: 4199FFB0  bgt cr6, 0x821d4b1c
	if ctx.cr[6].gt {
	pc = 0x821D4B1C; continue 'dispatch;
	}
	// 821D4B70: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821D4B74: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821D4B78: 419A0034  beq cr6, 0x821d4bac
	if ctx.cr[6].eq {
	pc = 0x821D4BAC; continue 'dispatch;
	}
	// 821D4B7C: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4B80: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821D4B84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D4B88: 41990008  bgt cr6, 0x821d4b90
	if ctx.cr[6].gt {
	pc = 0x821D4B90; continue 'dispatch;
	}
	// 821D4B8C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821D4B90: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D4B94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4B98: 409A0014  bne cr6, 0x821d4bac
	if !ctx.cr[6].eq {
	pc = 0x821D4BAC; continue 'dispatch;
	}
	// 821D4B9C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D4BA0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D4BA4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D4BA8: 48000008  b 0x821d4bb0
	pc = 0x821D4BB0; continue 'dispatch;
	// 821D4BAC: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821D4BB0: 8146001C  lwz r10, 0x1c(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D4BB4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D4BB8: 419A0010  beq cr6, 0x821d4bc8
	if ctx.cr[6].eq {
	pc = 0x821D4BC8; continue 'dispatch;
	}
	// 821D4BBC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4BC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D4BC4: 4800000C  b 0x821d4bd0
	pc = 0x821D4BD0; continue 'dispatch;
	// 821D4BC8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D4BCC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821D4BD0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D4BD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4BD8: 419A0008  beq cr6, 0x821d4be0
	if ctx.cr[6].eq {
	pc = 0x821D4BE0; continue 'dispatch;
	}
	// 821D4BDC: C3EA0008  lfs f31, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821D4BE0: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D4BE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4BE8: 419A0058  beq cr6, 0x821d4c40
	if ctx.cr[6].eq {
	pc = 0x821D4C40; continue 'dispatch;
	}
	// 821D4BEC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821D4BF0: 894B8FED  lbz r10, -0x7013(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28691 as u32) ) } as u64;
	// 821D4BF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D4BF8: 419A0038  beq cr6, 0x821d4c30
	if ctx.cr[6].eq {
	pc = 0x821D4C30; continue 'dispatch;
	}
	// 821D4BFC: 897F0054  lbz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D4C00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4C04: 409A002C  bne cr6, 0x821d4c30
	if !ctx.cr[6].eq {
	pc = 0x821D4C30; continue 'dispatch;
	}
	// 821D4C08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D4C0C: 48097AF5  bl 0x8226c700
	ctx.lr = 0x821D4C10;
	sub_8226C700(ctx, base);
	// 821D4C10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D4C14: 419A002C  beq cr6, 0x821d4c40
	if ctx.cr[6].eq {
	pc = 0x821D4C40; continue 'dispatch;
	}
	// 821D4C18: 8063007C  lwz r3, 0x7c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 821D4C1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4C20: 814B007C  lwz r10, 0x7c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821D4C24: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D4C28: 4E800421  bctrl
	ctx.lr = 0x821D4C2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D4C2C: 48000014  b 0x821d4c40
	pc = 0x821D4C40; continue 'dispatch;
	// 821D4C30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D4C34: C03F0008  lfs f1, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821D4C38: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821D4C3C: 480674A5  bl 0x8223c0e0
	ctx.lr = 0x821D4C40;
	sub_8223C0E0(ctx, base);
	// 821D4C40: D3FF0008  stfs f31, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821D4C44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D4C48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D4C4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D4C50: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D4C54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D4C58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D4C60 size=132
    let mut pc: u32 = 0x821D4C60;
    'dispatch: loop {
        match pc {
            0x821D4C60 => {
    //   block [0x821D4C60..0x821D4CE4)
	// 821D4C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D4C64: 48AD47A9  bl 0x82ca940c
	ctx.lr = 0x821D4C68;
	sub_82CA93D0(ctx, base);
	// 821D4C68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D4C6C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 821D4C70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D4C74: 48053485  bl 0x822280f8
	ctx.lr = 0x821D4C78;
	sub_822280F8(ctx, base);
	// 821D4C78: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821D4C7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821D4C80: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4C84: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821D4C88: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4C8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D4C90: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 821D4C94: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D4C98: 4812D2C1  bl 0x82301f58
	ctx.lr = 0x821D4C9C;
	sub_82301F58(ctx, base);
	// 821D4C9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D4CA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D4CA4: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 821D4CA8: 4E800421  bctrl
	ctx.lr = 0x821D4CAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D4CAC: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D4CB0: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D4CB4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D4CB8: 7D260034  cntlzw r6, r9
	ctx.r[6].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821D4CBC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821D4CC0: 54C5DFFE  rlwinm r5, r6, 0x1b, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 821D4CC4: 68A40001  xori r4, r5, 1
	ctx.r[4].u64 = ctx.r[5].u64 ^ 1;
	// 821D4CC8: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821D4CCC: 90880000  stw r4, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821D4CD0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D4CD4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821D4CD8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821D4CDC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D4CE0: 48AD477C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D4CE8 size=164
    let mut pc: u32 = 0x821D4CE8;
    'dispatch: loop {
        match pc {
            0x821D4CE8 => {
    //   block [0x821D4CE8..0x821D4D8C)
	// 821D4CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D4CEC: 48AD471D  bl 0x82ca9408
	ctx.lr = 0x821D4CF0;
	sub_82CA93D0(ctx, base);
	// 821D4CF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D4CF4: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 821D4CF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D4CFC: 480533FD  bl 0x822280f8
	ctx.lr = 0x821D4D00;
	sub_822280F8(ctx, base);
	// 821D4D00: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821D4D04: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821D4D08: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821D4D0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821D4D10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D4D14: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 821D4D18: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4D1C: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4D20: 480533D9  bl 0x822280f8
	ctx.lr = 0x821D4D24;
	sub_822280F8(ctx, base);
	// 821D4D24: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4D28: 48052839  bl 0x82227560
	ctx.lr = 0x821D4D2C;
	sub_82227560(ctx, base);
	// 821D4D2C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 821D4D30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D4D34: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821D4D38: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D4D3C: 4815194D  bl 0x82326688
	ctx.lr = 0x821D4D40;
	sub_82326688(ctx, base);
	// 821D4D40: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821D4D44: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821D4D48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D4D4C: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 821D4D50: 4E800421  bctrl
	ctx.lr = 0x821D4D54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D4D54: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D4D58: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D4D5C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821D4D60: 7D050034  cntlzw r5, r8
	ctx.r[5].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 821D4D64: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821D4D68: 54A4DFFE  rlwinm r4, r5, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x0000001Fu64;
	// 821D4D6C: 688B0001  xori r11, r4, 1
	ctx.r[11].u64 = ctx.r[4].u64 ^ 1;
	// 821D4D70: 90C70004  stw r6, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821D4D74: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821D4D78: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D4D7C: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 821D4D80: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821D4D84: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D4D88: 48AD46D0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D4D90 size=112
    let mut pc: u32 = 0x821D4D90;
    'dispatch: loop {
        match pc {
            0x821D4D90 => {
    //   block [0x821D4D90..0x821D4E00)
	// 821D4D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D4D94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D4D98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D4D9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D4DA0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821D4DA4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821D4DA8: 4882B921  bl 0x82a006c8
	ctx.lr = 0x821D4DAC;
	sub_82A006C8(ctx, base);
	// 821D4DAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D4DB0: 419A0038  beq cr6, 0x821d4de8
	if ctx.cr[6].eq {
	pc = 0x821D4DE8; continue 'dispatch;
	}
	// 821D4DB4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821D4DB8: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4DBC: 816B6DA0  lwz r11, 0x6da0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821D4DC0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4DC4: 806A000C  lwz r3, 0xc(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D4DC8: 4882C349  bl 0x82a01110
	ctx.lr = 0x821D4DCC;
	sub_82A01110(ctx, base);
	// 821D4DCC: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821D4DD0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821D4DD4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821D4DD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D4DDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D4DE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D4DE4: 4E800020  blr
	return;
	// 821D4DE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D4DEC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821D4DF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D4DF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D4DF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D4DFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D4E00 size=192
    let mut pc: u32 = 0x821D4E00;
    'dispatch: loop {
        match pc {
            0x821D4E00 => {
    //   block [0x821D4E00..0x821D4EC0)
	// 821D4E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D4E04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D4E08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D4E0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D4E10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D4E14: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821D4E18: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D4E1C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D4E20: 556A056A  rlwinm r10, r11, 0, 0x15, 0x15
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D4E24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D4E28: 419A004C  beq cr6, 0x821d4e74
	if ctx.cr[6].eq {
	pc = 0x821D4E74; continue 'dispatch;
	}
	// 821D4E2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D4E30: 4BFEDF49  bl 0x821c2d78
	ctx.lr = 0x821D4E34;
	sub_821C2D78(ctx, base);
	// 821D4E34: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821D4E38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D4E3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821D4E40: 4800A2C9  bl 0x821df108
	ctx.lr = 0x821D4E44;
	sub_821DF108(ctx, base);
	// 821D4E44: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821D4E48: 395F013C  addi r10, r31, 0x13c
	ctx.r[10].s64 = ctx.r[31].s64 + 316;
	// 821D4E4C: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 821D4E50: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821D4E54: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4E58: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821D4E5C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D4E60: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821D4E64: 4200FFF0  bdnz 0x821d4e54
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821D4E54; continue 'dispatch;
	}
	// 821D4E68: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D4E6C: 556A05A8  rlwinm r10, r11, 0, 0x16, 0x14
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D4E70: 915F0048  stw r10, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 821D4E74: C01F013C  lfs f0, 0x13c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D4E78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D4E7C: C1BF0140  lfs f13, 0x140(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D4E80: C19F0144  lfs f12, 0x144(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821D4E84: C17F0148  lfs f11, 0x148(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821D4E88: C15F014C  lfs f10, 0x14c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821D4E8C: C13F0150  lfs f9, 0x150(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821D4E90: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821D4E94: D1BE0004  stfs f13, 4(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821D4E98: D19E0008  stfs f12, 8(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821D4E9C: D17E000C  stfs f11, 0xc(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821D4EA0: D15E0010  stfs f10, 0x10(r30)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821D4EA4: D13E0014  stfs f9, 0x14(r30)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821D4EA8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821D4EAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D4EB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D4EB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D4EB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D4EBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D4EC0 size=44
    let mut pc: u32 = 0x821D4EC0;
    'dispatch: loop {
        match pc {
            0x821D4EC0 => {
    //   block [0x821D4EC0..0x821D4EEC)
	// 821D4EC0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D4EF0 size=40
    let mut pc: u32 = 0x821D4EF0;
    'dispatch: loop {
        match pc {
            0x821D4EF0 => {
    //   block [0x821D4EF0..0x821D4F18)
	// 821D4EF0: 89630025  lbz r11, 0x25(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(37 as u32) ) } as u64;
	// 821D4EF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4EF8: 409A0014  bne cr6, 0x821d4f0c
	if !ctx.cr[6].eq {
	pc = 0x821D4F0C; continue 'dispatch;
	}
	// 821D4EFC: 81630050  lwz r11, 0x50(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D4F00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D4F04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D4F08: 419A0008  beq cr6, 0x821d4f10
	if ctx.cr[6].eq {
	pc = 0x821D4F10; continue 'dispatch;
	}
	// 821D4F0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D4F10: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D4F14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821D4F18 size=56
    let mut pc: u32 = 0x821D4F18;
    'dispatch: loop {
        match pc {
            0x821D4F18 => {
    //   block [0x821D4F18..0x821D4F50)
	// 821D4F18: 89630025  lbz r11, 0x25(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(37 as u32) ) } as u64;
	// 821D4F1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4F20: 409A0014  bne cr6, 0x821d4f34
	if !ctx.cr[6].eq {
	pc = 0x821D4F34; continue 'dispatch;
	}
	// 821D4F24: 81630050  lwz r11, 0x50(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D4F28: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D4F2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D4F30: 419A0008  beq cr6, 0x821d4f38
	if ctx.cr[6].eq {
	pc = 0x821D4F38; continue 'dispatch;
	}
	// 821D4F34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D4F38: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D4F3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4F40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D4F44: 419A000C  beq cr6, 0x821d4f50
	if ctx.cr[6].eq {
		sub_821D4F50(ctx, base);
		return;
	}
	// 821D4F48: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821D4F4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821D4F50 size=12
    let mut pc: u32 = 0x821D4F50;
    'dispatch: loop {
        match pc {
            0x821D4F50 => {
    //   block [0x821D4F50..0x821D4F5C)
	// 821D4F50: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 821D4F54: C02A2984  lfs f1, 0x2984(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10628 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821D4F58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D4F60 size=260
    let mut pc: u32 = 0x821D4F60;
    'dispatch: loop {
        match pc {
            0x821D4F60 => {
    //   block [0x821D4F60..0x821D5064)
	// 821D4F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D4F64: 48AD44A5  bl 0x82ca9408
	ctx.lr = 0x821D4F68;
	sub_82CA93D0(ctx, base);
	// 821D4F68: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D4F6C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821D4F70: 54850430  rlwinm r5, r4, 0, 0x10, 0x18
	ctx.r[5].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 821D4F74: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821D4F78: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 821D4F7C: 549D067E  clrlwi r29, r4, 0x19
	ctx.r[29].u64 = ctx.r[4].u32 as u64 & 0x0000007Fu64;
	// 821D4F80: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821D4F84: 419A00B4  beq cr6, 0x821d5038
	if ctx.cr[6].eq {
	pc = 0x821D5038; continue 'dispatch;
	}
	// 821D4F88: 38830D54  addi r4, r3, 0xd54
	ctx.r[4].s64 = ctx.r[3].s64 + 3412;
	// 821D4F8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D4F90: 4BFFE231  bl 0x821d31c0
	ctx.lr = 0x821D4F94;
	sub_821D31C0(ctx, base);
	// 821D4F94: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821D4F98: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821D4F9C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D4FA0: 419A0098  beq cr6, 0x821d5038
	if ctx.cr[6].eq {
	pc = 0x821D5038; continue 'dispatch;
	}
	// 821D4FA4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D4FA8: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D4FAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4FB0: 419A0018  beq cr6, 0x821d4fc8
	if ctx.cr[6].eq {
	pc = 0x821D4FC8; continue 'dispatch;
	}
	// 821D4FB4: 810A0010  lwz r8, 0x10(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D4FB8: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 821D4FBC: 7CE81670  srawi r8, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[7].s32 >> 2) as i64;
	// 821D4FC0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821D4FC4: 41980008  blt cr6, 0x821d4fcc
	if ctx.cr[6].lt {
	pc = 0x821D4FCC; continue 'dispatch;
	}
	// 821D4FC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D4FCC: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D4FD0: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821D4FD4: 80EB001C  lwz r7, 0x1c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D4FD8: 7CE6F838  and r6, r7, r31
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[31].u64;
	// 821D4FDC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821D4FE0: 419A0040  beq cr6, 0x821d5020
	if ctx.cr[6].eq {
	pc = 0x821D5020; continue 'dispatch;
	}
	// 821D4FE4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D4FE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4FEC: 419A0018  beq cr6, 0x821d5004
	if ctx.cr[6].eq {
	pc = 0x821D5004; continue 'dispatch;
	}
	// 821D4FF0: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D4FF4: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D4FF8: 7CEA1670  srawi r10, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[7].s32 >> 2) as i64;
	// 821D4FFC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D5000: 41980008  blt cr6, 0x821d5008
	if ctx.cr[6].lt {
	pc = 0x821D5008; continue 'dispatch;
	}
	// 821D5004: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D5008: 7C68582E  lwzx r3, r8, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821D500C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D5010: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D5014: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D5018: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D501C: 4E800421  bctrl
	ctx.lr = 0x821D5020;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D5020: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D5024: 4802A71D  bl 0x821ff740
	ctx.lr = 0x821D5028;
	sub_821FF740(ctx, base);
	// 821D5028: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821D502C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821D5030: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D5034: 409AFF70  bne cr6, 0x821d4fa4
	if !ctx.cr[6].eq {
	pc = 0x821D4FA4; continue 'dispatch;
	}
	// 821D5038: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821D503C: 419A0020  beq cr6, 0x821d505c
	if ctx.cr[6].eq {
	pc = 0x821D505C; continue 'dispatch;
	}
	// 821D5040: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 821D5044: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821D5048: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821D504C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821D5050: 388B2028  addi r4, r11, 0x2028
	ctx.r[4].s64 = ctx.r[11].s64 + 8232;
	// 821D5054: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D5058: 480C25A1  bl 0x822975f8
	ctx.lr = 0x821D505C;
	sub_822975F8(ctx, base);
	// 821D505C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821D5060: 48AD43F8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D5068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D5068 size=220
    let mut pc: u32 = 0x821D5068;
    'dispatch: loop {
        match pc {
            0x821D5068 => {
    //   block [0x821D5068..0x821D5144)
	// 821D5068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D506C: 48AD43A1  bl 0x82ca940c
	ctx.lr = 0x821D5070;
	sub_82CA93D0(ctx, base);
	// 821D5070: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821D5074: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D5078: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D507C: 39400670  li r10, 0x670
	ctx.r[10].s64 = 1648;
	// 821D5080: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821D5084: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821D5088: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821D508C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D5090: C3E89484  lfs f31, -0x6b7c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D5148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D5148 size=152
    let mut pc: u32 = 0x821D5148;
    'dispatch: loop {
        match pc {
            0x821D5148 => {
    //   block [0x821D5148..0x821D51E0)
	// 821D5148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D514C: 48AD42C1  bl 0x82ca940c
	ctx.lr = 0x821D5150;
	sub_82CA93D0(ctx, base);
	// 821D5150: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D5154: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D5158: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 821D515C: 3BFE0060  addi r31, r30, 0x60
	ctx.r[31].s64 = ctx.r[30].s64 + 96;
	// 821D5160: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D5164: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821D5168: 419A0058  beq cr6, 0x821d51c0
	if ctx.cr[6].eq {
	pc = 0x821D51C0; continue 'dispatch;
	}
	// 821D516C: A1640072  lhz r11, 0x72(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(114 as u32) ) } as u64;
	// 821D5170: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 821D5174: 813E1C40  lwz r9, 0x1c40(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7232 as u32) ) } as u64;
	// 821D5178: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D517C: 7D07FE70  srawi r7, r8, 0x1f
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 31) as i64;
	// 821D5180: 7D063A78  xor r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 ^ ctx.r[7].u64;
	// 821D5184: 7CA73050  subf r5, r7, r6
	ctx.r[5].s64 = ctx.r[6].s64 - ctx.r[7].s64;
	// 821D5188: 7F054840  cmplw cr6, r5, r9
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821D518C: 4099001C  ble cr6, 0x821d51a8
	if !ctx.cr[6].gt {
	pc = 0x821D51A8; continue 'dispatch;
	}
	// 821D5190: 389FFFE0  addi r4, r31, -0x20
	ctx.r[4].s64 = ctx.r[31].s64 + -32;
	// 821D5194: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D5198: 488E3F91  bl 0x82ab9128
	ctx.lr = 0x821D519C;
	sub_82AB9128(ctx, base);
	// 821D519C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D51A0: A1640072  lhz r11, 0x72(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(114 as u32) ) } as u64;
	// 821D51A4: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821D51A8: A164006C  lhz r11, 0x6c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(108 as u32) ) } as u64;
	// 821D51AC: 556A04A4  rlwinm r10, r11, 0, 0x12, 0x12
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D51B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D51B4: 419A000C  beq cr6, 0x821d51c0
	if ctx.cr[6].eq {
	pc = 0x821D51C0; continue 'dispatch;
	}
	// 821D51B8: 387FFFE0  addi r3, r31, -0x20
	ctx.r[3].s64 = ctx.r[31].s64 + -32;
	// 821D51BC: 488E2DCD  bl 0x82ab7f88
	ctx.lr = 0x821D51C0;
	sub_82AB7F88(ctx, base);
	// 821D51C0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821D51C4: 3BFF01C0  addi r31, r31, 0x1c0
	ctx.r[31].s64 = ctx.r[31].s64 + 448;
	// 821D51C8: 4082FF98  bne 0x821d5160
	if !ctx.cr[0].eq {
	pc = 0x821D5160; continue 'dispatch;
	}
	// 821D51CC: 817E1C44  lwz r11, 0x1c44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7236 as u32) ) } as u64;
	// 821D51D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D51D4: 917E1C44  stw r11, 0x1c44(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(7236 as u32), ctx.r[11].u32 ) };
	// 821D51D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D51DC: 48AD4280  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D51E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D51E0 size=112
    let mut pc: u32 = 0x821D51E0;
    'dispatch: loop {
        match pc {
            0x821D51E0 => {
    //   block [0x821D51E0..0x821D5250)
	// 821D51E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D51E4: 48AD4229  bl 0x82ca940c
	ctx.lr = 0x821D51E8;
	sub_82CA93D0(ctx, base);
	// 821D51E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D51EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D51F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D51F4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821D51F8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821D51FC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821D5200: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821D5204: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821D5208: 419A0018  beq cr6, 0x821d5220
	if ctx.cr[6].eq {
	pc = 0x821D5220; continue 'dispatch;
	}
	// 821D520C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D5210: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D5214: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D5218: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D521C: 4E800421  bctrl
	ctx.lr = 0x821D5220;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D5220: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D5224: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D5228: 419A0014  beq cr6, 0x821d523c
	if ctx.cr[6].eq {
	pc = 0x821D523C; continue 'dispatch;
	}
	// 821D522C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D5230: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D5234: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D5238: 4E800421  bctrl
	ctx.lr = 0x821D523C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D523C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821D5240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D5244: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821D5248: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D524C: 48AD4210  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D5250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D5250 size=152
    let mut pc: u32 = 0x821D5250;
    'dispatch: loop {
        match pc {
            0x821D5250 => {
    //   block [0x821D5250..0x821D52E8)
	// 821D5250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D5254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D5258: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D525C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D5260: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D5264: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D5268: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D526C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821D5270: 392B26C4  addi r9, r11, 0x26c4
	ctx.r[9].s64 = ctx.r[11].s64 + 9924;
	// 821D5274: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821D5278: 390A11B0  addi r8, r10, 0x11b0
	ctx.r[8].s64 = ctx.r[10].s64 + 4528;
	// 821D527C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D5280: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821D5284: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 821D5288: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821D528C: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 821D5290: 93FF0008  stw r31, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 821D5294: 48049FC5  bl 0x8221f258
	ctx.lr = 0x821D5298;
	sub_8221F258(ctx, base);
	// 821D5298: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821D529C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D52A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D52A4: 419A0028  beq cr6, 0x821d52cc
	if ctx.cr[6].eq {
	pc = 0x821D52CC; continue 'dispatch;
	}
	// 821D52A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821D52AC: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821D52B0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821D52B4: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821D52B8: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 821D52BC: 994B0010  stb r10, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u8 ) };
	// 821D52C0: 9BCB0011  stb r30, 0x11(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(17 as u32), ctx.r[30].u8 ) };
	// 821D52C4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821D52C8: 48000008  b 0x821d52d0
	pc = 0x821D52D0; continue 'dispatch;
	// 821D52CC: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 821D52D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D52D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D52D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D52DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D52E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D52E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D52E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D52E8 size=204
    let mut pc: u32 = 0x821D52E8;
    'dispatch: loop {
        match pc {
            0x821D52E8 => {
    //   block [0x821D52E8..0x821D53B4)
	// 821D52E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D52EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D52F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D52F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D52F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D52FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D5300: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D5304: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 821D5308: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 821D530C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D5310: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821D5314: 4808FE8D  bl 0x822651a0
	ctx.lr = 0x821D5318;
	sub_822651A0(ctx, base);
	// 821D5318: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D531C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821D5320: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D5324: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 821D5328: 811E0010  lwz r8, 0x10(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D532C: 911F0010  stw r8, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 821D5330: 80FE0014  lwz r7, 0x14(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D5334: 90FF0014  stw r7, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 821D5338: 80DE0018  lwz r6, 0x18(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D533C: 90DF0018  stw r6, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 821D5340: 80BE001C  lwz r5, 0x1c(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D5344: 90BF001C  stw r5, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[5].u32 ) };
	// 821D5348: 809E0020  lwz r4, 0x20(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D534C: 909F0020  stw r4, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 821D5350: C01E0024  lfs f0, 0x24(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D5354: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821D5358: C1BE0028  lfs f13, 0x28(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D535C: D1BF0028  stfs f13, 0x28(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821D5360: 807E002C  lwz r3, 0x2c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D5364: 907F002C  stw r3, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[3].u32 ) };
	// 821D5368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D536C: C19E0030  lfs f12, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821D5370: D19F0030  stfs f12, 0x30(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821D5374: C17E0034  lfs f11, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821D5378: D17F0034  stfs f11, 0x34(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821D537C: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 821D5380: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 821D5384: 815E003C  lwz r10, 0x3c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 821D5388: 915F003C  stw r10, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 821D538C: 893E0040  lbz r9, 0x40(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 821D5390: 993F0040  stb r9, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[9].u8 ) };
	// 821D5394: 891E0041  lbz r8, 0x41(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(65 as u32) ) } as u64;
	// 821D5398: 991F0041  stb r8, 0x41(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(65 as u32), ctx.r[8].u8 ) };
	// 821D539C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D53A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D53A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D53A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D53AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D53B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D53B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D53B8 size=256
    let mut pc: u32 = 0x821D53B8;
    'dispatch: loop {
        match pc {
            0x821D53B8 => {
    //   block [0x821D53B8..0x821D54B8)
	// 821D53B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D53BC: 48AD4045  bl 0x82ca9400
	ctx.lr = 0x821D53C0;
	sub_82CA93D0(ctx, base);
	// 821D53C0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D53C4: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 821D53C8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821D53CC: 834100EC  lwz r26, 0xec(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 821D53D0: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 821D53D4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821D53D8: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D53DC: 48049E7D  bl 0x8221f258
	ctx.lr = 0x821D53E0;
	sub_8221F258(ctx, base);
	// 821D53E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D53E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821D53E8: 419A0008  beq cr6, 0x821d53f0
	if ctx.cr[6].eq {
	pc = 0x821D53F0; continue 'dispatch;
	}
	// 821D53EC: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 821D53F0: 3B9F0004  addi r28, r31, 4
	ctx.r[28].s64 = ctx.r[31].s64 + 4;
	// 821D53F4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821D53F8: 419A0008  beq cr6, 0x821d5400
	if ctx.cr[6].eq {
	pc = 0x821D5400; continue 'dispatch;
	}
	// 821D53FC: 93DC0000  stw r30, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821D5400: 37DF0008  addic. r30, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821D5404: 41820038  beq 0x821d543c
	if ctx.cr[0].eq {
	pc = 0x821D543C; continue 'dispatch;
	}
	// 821D5408: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D540C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821D5410: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D5414: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D5418: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821D541C: 419A0014  beq cr6, 0x821d5430
	if ctx.cr[6].eq {
	pc = 0x821D5430; continue 'dispatch;
	}
	// 821D5420: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D5424: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D5428: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D542C: 4E800421  bctrl
	ctx.lr = 0x821D5430;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D5430: 389D0008  addi r4, r29, 8
	ctx.r[4].s64 = ctx.r[29].s64 + 8;
	// 821D5434: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 821D5438: 4801AE09  bl 0x821f0240
	ctx.lr = 0x821D543C;
	sub_821F0240(ctx, base);
	// 821D543C: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 821D5440: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D5444: 61695555  ori r9, r11, 0x5555
	ctx.r[9].u64 = ctx.r[11].u64 | 21845;
	// 821D5448: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 821D544C: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 821D5450: 40980048  bge cr6, 0x821d5498
	if !ctx.cr[6].lt {
	pc = 0x821D5498; continue 'dispatch;
	}
	// 821D5454: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D5458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D545C: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 821D5460: 4811CAE1  bl 0x822f1f40
	ctx.lr = 0x821D5464;
	sub_822F1F40(ctx, base);
	// 821D5464: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821D5468: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D546C: 4811C945  bl 0x822f1db0
	ctx.lr = 0x821D5470;
	sub_822F1DB0(ctx, base);
	// 821D5470: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821D5474: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D5478: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 821D547C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 821D5480: 4811C9A1  bl 0x822f1e20
	ctx.lr = 0x821D5484;
	sub_822F1E20(ctx, base);
	// 821D5484: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 821D5488: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D548C: 484A6355  bl 0x8267b7e0
	ctx.lr = 0x821D5490;
	sub_8267B7E0(ctx, base);
	// 821D5490: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D5494: 4BF9C37D  bl 0x82171810
	ctx.lr = 0x821D5498;
	sub_82171810(ctx, base);
	// 821D5498: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D549C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D54A0: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821D54A4: 93FA0004  stw r31, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821D54A8: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D54AC: 93EA0000  stw r31, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 821D54B0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821D54B4: 48AD3F9C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D54B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D54B8 size=104
    let mut pc: u32 = 0x821D54B8;
    'dispatch: loop {
        match pc {
            0x821D54B8 => {
    //   block [0x821D54B8..0x821D5520)
	// 821D54B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D54BC: 48AD3F49  bl 0x82ca9404
	ctx.lr = 0x821D54C0;
	sub_82CA93D0(ctx, base);
	// 821D54C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D54C4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821D54C8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821D54CC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821D54D0: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 821D54D4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 821D54D8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821D54DC: 419A0034  beq cr6, 0x821d5510
	if ctx.cr[6].eq {
	pc = 0x821D5510; continue 'dispatch;
	}
	// 821D54E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821D54E4: 419A0020  beq cr6, 0x821d5504
	if ctx.cr[6].eq {
	pc = 0x821D5504; continue 'dispatch;
	}
	// 821D54E8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821D54EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D54F0: 4BFC1881  bl 0x82196d70
	ctx.lr = 0x821D54F4;
	sub_82196D70(ctx, base);
	// 821D54F4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D54F8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821D54FC: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D5500: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821D5504: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821D5508: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 821D550C: 4082FFD4  bne 0x821d54e0
	if !ctx.cr[0].eq {
	pc = 0x821D54E0; continue 'dispatch;
	}
	// 821D5510: 57AB2036  slwi r11, r29, 4
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D5514: 7C6BDA14  add r3, r11, r27
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821D5518: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D551C: 48AD3F38  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D5520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D5520 size=52
    let mut pc: u32 = 0x821D5520;
    'dispatch: loop {
        match pc {
            0x821D5520 => {
    //   block [0x821D5520..0x821D5554)
	// 821D5520: 81630058  lwz r11, 0x58(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) } as u64;
	// 821D5524: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821D5528: 419A002C  beq cr6, 0x821d5554
	if ctx.cr[6].eq {
		sub_821D5554(ctx, base);
		return;
	}
	// 821D552C: 8163004C  lwz r11, 0x4c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D5530: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D5534: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D5538: 7D283671  srawi. r8, r9, 6
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 6) as i64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821D553C: 41820018  beq 0x821d5554
	if ctx.cr[0].eq {
		sub_821D5554(ctx, base);
		return;
	}
	// 821D5540: 81630054  lwz r11, 0x54(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D5544: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821D5548: 7D6A2038  and r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[4].u64;
	// 821D554C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D5550: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D5554(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D5554 size=8
    let mut pc: u32 = 0x821D5554;
    'dispatch: loop {
        match pc {
            0x821D5554 => {
    //   block [0x821D5554..0x821D555C)
	// 821D5554: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D5558: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D5560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D5560 size=64
    let mut pc: u32 = 0x821D5560;
    'dispatch: loop {
        match pc {
            0x821D5560 => {
    //   block [0x821D5560..0x821D55A0)
	// 821D5560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D5564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D5568: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D556C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D5570: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D5574: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821D5578: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D557C: 994B000C  stb r10, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u8 ) };
	// 821D5580: 80840010  lwz r4, 0x10(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D5584: 4800001D  bl 0x821d55a0
	ctx.lr = 0x821D5588;
	sub_821D55A0(ctx, base);
	// 821D5588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D558C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821D5590: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D5594: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D5598: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D559C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D55A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D55A0 size=132
    let mut pc: u32 = 0x821D55A0;
    'dispatch: loop {
        match pc {
            0x821D55A0 => {
    //   block [0x821D55A0..0x821D5624)
	// 821D55A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D55A4: 48AD3E65  bl 0x82ca9408
	ctx.lr = 0x821D55A8;
	sub_82CA93D0(ctx, base);
	// 821D55A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D55AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D55B0: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 821D55B4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821D55B8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821D55BC: 48049C9D  bl 0x8221f258
	ctx.lr = 0x821D55C0;
	sub_8221F258(ctx, base);
	// 821D55C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D55C4: 419A0014  beq cr6, 0x821d55d8
	if ctx.cr[6].eq {
	pc = 0x821D55D8; continue 'dispatch;
	}
	// 821D55C8: 4BFFFC89  bl 0x821d5250
	ctx.lr = 0x821D55CC;
	sub_821D5250(ctx, base);
	// 821D55CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D55D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821D55D4: 409A001C  bne cr6, 0x821d55f0
	if !ctx.cr[6].eq {
	pc = 0x821D55F0; continue 'dispatch;
	}
	// 821D55D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D55DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D55E0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821D55E4: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821D55E8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D55EC: 48AD3E6C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821D55F0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821D55F4: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D55F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D55FC: 4800094D  bl 0x821d5f48
	ctx.lr = 0x821D5600;
	sub_821D5F48(ctx, base);
	// 821D5600: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D5604: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 821D5608: 997D000C  stb r11, 0xc(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 821D560C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D5610: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D5614: 4BFFFBCD  bl 0x821d51e0
	ctx.lr = 0x821D5618;
	sub_821D51E0(ctx, base);
	// 821D5618: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D561C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D5620: 48AD3E38  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D5628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D5628 size=440
    let mut pc: u32 = 0x821D5628;
    'dispatch: loop {
        match pc {
            0x821D5628 => {
    //   block [0x821D5628..0x821D57E0)
	// 821D5628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D562C: 48AD3DC9  bl 0x82ca93f4
	ctx.lr = 0x821D5630;
	sub_82CA93D0(ctx, base);
	// 821D5630: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D5634: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821D5638: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D563C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821D5640: 3B1F0004  addi r24, r31, 4
	ctx.r[24].s64 = ctx.r[31].s64 + 4;
	// 821D5644: 817A0014  lwz r11, 0x14(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D5648: 92FF0000  stw r23, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 821D564C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D5650: 3B2B0D54  addi r25, r11, 0xd54
	ctx.r[25].s64 = ctx.r[11].s64 + 3412;
	// 821D5654: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D5658: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821D565C: 419A0024  beq cr6, 0x821d5680
	if ctx.cr[6].eq {
	pc = 0x821D5680; continue 'dispatch;
	}
	// 821D5660: 7D652850  subf r11, r5, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 821D5664: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D5668: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821D566C: 7FC61A14  add r30, r6, r3
	ctx.r[30].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 821D5670: 4081000C  ble 0x821d567c
	if !ctx.cr[0].gt {
	pc = 0x821D567C; continue 'dispatch;
	}
	// 821D5674: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 821D5678: 48AD49B1  bl 0x82caa028
	ctx.lr = 0x821D567C;
	sub_82CAA028(ctx, base);
	// 821D567C: 93D80008  stw r30, 8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821D5680: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D5684: 3B7F0014  addi r27, r31, 0x14
	ctx.r[27].s64 = ctx.r[31].s64 + 20;
	// 821D5688: 80BF001C  lwz r5, 0x1c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D568C: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821D5690: 419A0024  beq cr6, 0x821d56b4
	if ctx.cr[6].eq {
	pc = 0x821D56B4; continue 'dispatch;
	}
	// 821D5694: 7D652850  subf r11, r5, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 821D5698: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D569C: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821D56A0: 7FC61A14  add r30, r6, r3
	ctx.r[30].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 821D56A4: 4081000C  ble 0x821d56b0
	if !ctx.cr[0].gt {
	pc = 0x821D56B0; continue 'dispatch;
	}
	// 821D56A8: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 821D56AC: 48AD497D  bl 0x82caa028
	ctx.lr = 0x821D56B0;
	sub_82CAA028(ctx, base);
	// 821D56B0: 93DB0008  stw r30, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821D56B4: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D56B8: 3B9F0024  addi r28, r31, 0x24
	ctx.r[28].s64 = ctx.r[31].s64 + 36;
	// 821D56BC: 80BF002C  lwz r5, 0x2c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D56C0: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821D56C4: 419A0024  beq cr6, 0x821d56e8
	if ctx.cr[6].eq {
	pc = 0x821D56E8; continue 'dispatch;
	}
	// 821D56C8: 7D652850  subf r11, r5, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 821D56CC: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D56D0: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821D56D4: 7FC61A14  add r30, r6, r3
	ctx.r[30].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 821D56D8: 4081000C  ble 0x821d56e4
	if !ctx.cr[0].gt {
	pc = 0x821D56E4; continue 'dispatch;
	}
	// 821D56DC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 821D56E0: 48AD4949  bl 0x82caa028
	ctx.lr = 0x821D56E4;
	sub_82CAA028(ctx, base);
	// 821D56E4: 93DC0008  stw r30, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821D56E8: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 821D56EC: 3BDF003C  addi r30, r31, 0x3c
	ctx.r[30].s64 = ctx.r[31].s64 + 60;
	// 821D56F0: 80BF0044  lwz r5, 0x44(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 821D56F4: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821D56F8: 419A0024  beq cr6, 0x821d571c
	if ctx.cr[6].eq {
	pc = 0x821D571C; continue 'dispatch;
	}
	// 821D56FC: 7D652850  subf r11, r5, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 821D5700: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D5704: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821D5708: 7FA61A14  add r29, r6, r3
	ctx.r[29].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 821D570C: 4081000C  ble 0x821d5718
	if !ctx.cr[0].gt {
	pc = 0x821D5718; continue 'dispatch;
	}
	// 821D5710: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 821D5714: 48AD4915  bl 0x82caa028
	ctx.lr = 0x821D5718;
	sub_82CAA028(ctx, base);
	// 821D5718: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 821D571C: 92FF0034  stw r23, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[23].u32 ) };
	// 821D5720: 38A0000B  li r5, 0xb
	ctx.r[5].s64 = 11;
	// 821D5724: 92FF0038  stw r23, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[23].u32 ) };
	// 821D5728: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821D572C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D5730: 4801ED51  bl 0x821f4480
	ctx.lr = 0x821D5734;
	sub_821F4480(ctx, base);
	// 821D5734: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821D5738: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821D573C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D5740: 419A003C  beq cr6, 0x821d577c
	if ctx.cr[6].eq {
	pc = 0x821D577C; continue 'dispatch;
	}
	// 821D5744: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D5748: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D574C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D5750: 419A0018  beq cr6, 0x821d5768
	if ctx.cr[6].eq {
	pc = 0x821D5768; continue 'dispatch;
	}
	// 821D5754: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D5758: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D575C: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821D5760: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D5764: 41980008  blt cr6, 0x821d576c
	if ctx.cr[6].lt {
	pc = 0x821D576C; continue 'dispatch;
	}
	// 821D5768: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D576C: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D5770: 7D2A582E  lwzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821D5774: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D5778: 48000010  b 0x821d5788
	pc = 0x821D5788; continue 'dispatch;
	// 821D577C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821D5780: 816B6E94  lwz r11, 0x6e94(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28308 as u32) ) } as u64;
	// 821D5784: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821D5788: 38E0000A  li r7, 0xa
	ctx.r[7].s64 = 10;
	// 821D578C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821D5790: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821D5794: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821D5798: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821D579C: 4BFE792D  bl 0x821bd0c8
	ctx.lr = 0x821D57A0;
	sub_821BD0C8(ctx, base);
	// 821D57A0: 38E00009  li r7, 9
	ctx.r[7].s64 = 9;
	// 821D57A4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821D57A8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821D57AC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821D57B0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821D57B4: 480065DD  bl 0x821dbd90
	ctx.lr = 0x821D57B8;
	sub_821DBD90(ctx, base);
	// 821D57B8: 907F0034  stw r3, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[3].u32 ) };
	// 821D57BC: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 821D57C0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821D57C4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821D57C8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821D57CC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821D57D0: 4802A3F1  bl 0x821ffbc0
	ctx.lr = 0x821D57D4;
	sub_821FFBC0(ctx, base);
	// 821D57D4: 907F0038  stw r3, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[3].u32 ) };
	// 821D57D8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821D57DC: 48AD3C68  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D57E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D57E0 size=1828
    let mut pc: u32 = 0x821D57E0;
    'dispatch: loop {
        match pc {
            0x821D57E0 => {
    //   block [0x821D57E0..0x821D5F04)
	// 821D57E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D57E4: 48AD3C15  bl 0x82ca93f8
	ctx.lr = 0x821D57E8;
	sub_82CA93D0(ctx, base);
	// 821D57E8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D57EC: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 821D57F0: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821D57F4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821D57F8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821D57FC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D5800: C0099A80  lfs f0, -0x6580(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D5804: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D5808: 3B6B0010  addi r27, r11, 0x10
	ctx.r[27].s64 = ctx.r[11].s64 + 16;
	// 821D580C: 3B1B0430  addi r24, r27, 0x430
	ctx.r[24].s64 = ctx.r[27].s64 + 1072;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D5F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D5F08 size=60
    let mut pc: u32 = 0x821D5F08;
    'dispatch: loop {
        match pc {
            0x821D5F08 => {
    //   block [0x821D5F08..0x821D5F44)
	// 821D5F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D5F0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D5F10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D5F14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D5F18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D5F1C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 821D5F20: 480218E1  bl 0x821f7800
	ctx.lr = 0x821D5F24;
	sub_821F7800(ctx, base);
	// 821D5F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D5F28: 4809F459  bl 0x82275380
	ctx.lr = 0x821D5F2C;
	sub_82275380(ctx, base);
	// 821D5F2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D5F30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821D5F34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D5F38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D5F3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D5F40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D5F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D5F48 size=112
    let mut pc: u32 = 0x821D5F48;
    'dispatch: loop {
        match pc {
            0x821D5F48 => {
    //   block [0x821D5F48..0x821D5FB8)
	// 821D5F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D5F4C: 48AD34B9  bl 0x82ca9404
	ctx.lr = 0x821D5F50;
	sub_82CA93D0(ctx, base);
	// 821D5F50: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D5F54: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 821D5F58: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D5F5C: 3BCB4BD8  addi r30, r11, 0x4bd8
	ctx.r[30].s64 = ctx.r[11].s64 + 19416;
	// 821D5F60: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821D5F64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821D5F68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D5F6C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821D5F70: 48068A01  bl 0x8223e970
	ctx.lr = 0x821D5F74;
	sub_8223E970(ctx, base);
	// 821D5F74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D5F78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821D5F7C: 419A0018  beq cr6, 0x821d5f94
	if ctx.cr[6].eq {
	pc = 0x821D5F94; continue 'dispatch;
	}
	// 821D5F80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D5F84: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 821D5F88: 394B1198  addi r10, r11, 0x1198
	ctx.r[10].s64 = ctx.r[11].s64 + 4504;
	// 821D5F8C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821D5F90: 4BFFFF79  bl 0x821d5f08
	ctx.lr = 0x821D5F94;
	sub_821D5F08(ctx, base);
	// 821D5F94: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821D5F98: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821D5F9C: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 821D5FA0: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 821D5FA4: 4BFFF345  bl 0x821d52e8
	ctx.lr = 0x821D5FA8;
	sub_821D52E8(ctx, base);
	// 821D5FA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D5FAC: 4806888D  bl 0x8223e838
	ctx.lr = 0x821D5FB0;
	sub_8223E838(ctx, base);
	// 821D5FB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D5FB4: 48AD34A0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D5FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D5FB8 size=192
    let mut pc: u32 = 0x821D5FB8;
    'dispatch: loop {
        match pc {
            0x821D5FB8 => {
    //   block [0x821D5FB8..0x821D6078)
	// 821D5FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D5FBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D5FC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D5FC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D5FC8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D5FCC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821D5FD0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D5FD4: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D5FD8: 556A0630  rlwinm r10, r11, 0, 0x18, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D5FDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D5FE0: 419A004C  beq cr6, 0x821d602c
	if ctx.cr[6].eq {
	pc = 0x821D602C; continue 'dispatch;
	}
	// 821D5FE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D5FE8: 48000091  bl 0x821d6078
	ctx.lr = 0x821D5FEC;
	sub_821D6078(ctx, base);
	// 821D5FEC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821D5FF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D5FF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821D5FF8: 48009111  bl 0x821df108
	ctx.lr = 0x821D5FFC;
	sub_821DF108(ctx, base);
	// 821D5FFC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821D6000: 395F00EC  addi r10, r31, 0xec
	ctx.r[10].s64 = ctx.r[31].s64 + 236;
	// 821D6004: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 821D6008: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821D600C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D6010: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821D6014: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D6018: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821D601C: 4200FFF0  bdnz 0x821d600c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821D600C; continue 'dispatch;
	}
	// 821D6020: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D6024: 556A066E  rlwinm r10, r11, 0, 0x19, 0x17
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D6028: 915F0048  stw r10, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 821D602C: C01F00EC  lfs f0, 0xec(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D6030: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D6034: C1BF00F0  lfs f13, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D6038: C19F00F4  lfs f12, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821D603C: C17F00F8  lfs f11, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821D6040: C15F00FC  lfs f10, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821D6044: C13F0100  lfs f9, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821D6048: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821D604C: D1BE0004  stfs f13, 4(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821D6050: D19E0008  stfs f12, 8(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821D6054: D17E000C  stfs f11, 0xc(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821D6058: D15E0010  stfs f10, 0x10(r30)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821D605C: D13E0014  stfs f9, 0x14(r30)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821D6060: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821D6064: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D6068: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D606C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D6070: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D6074: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D6078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D6078 size=380
    let mut pc: u32 = 0x821D6078;
    'dispatch: loop {
        match pc {
            0x821D6078 => {
    //   block [0x821D6078..0x821D61F4)
	// 821D6078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D607C: 48AD3391  bl 0x82ca940c
	ctx.lr = 0x821D6080;
	sub_82CA93D0(ctx, base);
	// 821D6080: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D6084: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821D6088: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D608C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D6090: 556A05EE  rlwinm r10, r11, 0, 0x17, 0x17
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D6094: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D6098: 419A0130  beq cr6, 0x821d61c8
	if ctx.cr[6].eq {
	pc = 0x821D61C8; continue 'dispatch;
	}
	// 821D609C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D60A0: 480A2229  bl 0x822782c8
	ctx.lr = 0x821D60A4;
	sub_822782C8(ctx, base);
	// 821D60A4: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 821D60A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D60AC: 409A0010  bne cr6, 0x821d60bc
	if !ctx.cr[6].eq {
	pc = 0x821D60BC; continue 'dispatch;
	}
	// 821D60B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D60B4: 3BCB9218  addi r30, r11, -0x6de8
	ctx.r[30].s64 = ctx.r[11].s64 + -28136;
	// 821D60B8: 48000008  b 0x821d60c0
	pc = 0x821D60C0; continue 'dispatch;
	// 821D60BC: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D60C0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821D60C4: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821D60C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D60CC: 38AA803C  addi r5, r10, -0x7fc4
	ctx.r[5].s64 = ctx.r[10].s64 + -32708;
	// 821D60D0: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D60D4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D60D8: 80890060  lwz r4, 0x60(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(96 as u32) ) } as u64;
	// 821D60DC: 4801FBE5  bl 0x821f5cc0
	ctx.lr = 0x821D60E0;
	sub_821F5CC0(ctx, base);
	// 821D60E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D60E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821D60E8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821D60EC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821D60F0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821D60F4: 4899B3AD  bl 0x82b714a0
	ctx.lr = 0x821D60F8;
	sub_82B714A0(ctx, base);
	// 821D60F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D60FC: 4805BBBD  bl 0x82231cb8
	ctx.lr = 0x821D6100;
	sub_82231CB8(ctx, base);
	// 821D6100: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D6104: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D6108: 48101FE1  bl 0x822d80e8
	ctx.lr = 0x821D610C;
	sub_822D80E8(ctx, base);
	// 821D610C: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821D6110: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D6114: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821D6118: 7D0707B4  extsw r7, r8
	ctx.r[7].s64 = ctx.r[8].s32 as i64;
	// 821D611C: C1A10070  lfs f13, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D6120: ECA0682A  fadds f5, f0, f13
	ctx.f[5].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821D6124: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 821D6128: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D612C: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 821D6130: D0A10050  stfs f5, 0x50(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821D6134: FC805818  frsp f4, f11
	ctx.f[4].f64 = (ctx.f[11].f64 as f32) as f64;
	// 821D6138: 48101FB1  bl 0x822d80e8
	ctx.lr = 0x821D613C;
	sub_822D80E8(ctx, base);
	// 821D613C: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 821D6140: C0630004  lfs f3, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821D6144: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821D6148: C0410074  lfs f2, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821D614C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821D6150: D0A10060  stfs f5, 0x60(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821D6154: 7CC307B4  extsw r3, r6
	ctx.r[3].s64 = ctx.r[6].s32 as i64;
	// 821D6158: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D615C: C00592D4  lfs f0, -0x6d2c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D6160: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 821D6164: EDA40032  fmuls f13, f4, f0
	ctx.f[13].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 821D6168: C8210058  lfd f1, 0x58(r1)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821D616C: FD600E9C  fcfid f11, f1
	ctx.f[11].f64 = (ctx.f[1].s64 as f64);
	// 821D6170: 556A062C  rlwinm r10, r11, 0, 0x18, 0x16
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D6174: ED836838  fmsubs f12, f3, f0, f13
	ctx.f[12].f64 = (((ctx.f[3].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821D6178: 915F0048  stw r10, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 821D617C: FD005818  frsp f8, f11
	ctx.f[8].f64 = (ctx.f[11].f64 as f32) as f64;
	// 821D6180: EC0C102A  fadds f0, f12, f2
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[2].f64) as f32) as f64;
	// 821D6184: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821D6188: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D618C: ECE8282A  fadds f7, f8, f5
	ctx.f[7].f64 = ((ctx.f[8].f64 + ctx.f[5].f64) as f32) as f64;
	// 821D6190: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 821D6194: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821D6198: C141005C  lfs f10, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821D619C: ED24502A  fadds f9, f4, f10
	ctx.f[9].f64 = ((ctx.f[4].f64 + ctx.f[10].f64) as f32) as f64;
	// 821D61A0: D121006C  stfs f9, 0x6c(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821D61A4: D0E10068  stfs f7, 0x68(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821D61A8: 80E4000C  lwz r7, 0xc(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D61AC: 80C40000  lwz r6, 0(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D61B0: 80A40004  lwz r5, 4(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D61B4: 81040008  lwz r8, 8(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D61B8: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 821D61BC: 90BF00E0  stw r5, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[5].u32 ) };
	// 821D61C0: 90DF00DC  stw r6, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[6].u32 ) };
	// 821D61C4: 90FF00E8  stw r7, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[7].u32 ) };
	// 821D61C8: C01F00DC  lfs f0, 0xdc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D61CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D61D0: C1BF00E0  lfs f13, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D61D4: C19F00E4  lfs f12, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821D61D8: C17F00E8  lfs f11, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821D61DC: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821D61E0: D1BD0004  stfs f13, 4(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821D61E4: D19D0008  stfs f12, 8(r29)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821D61E8: D17D000C  stfs f11, 0xc(r29)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821D61EC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821D61F0: 48AD326C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D61F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D61F8 size=3444
    let mut pc: u32 = 0x821D61F8;
    'dispatch: loop {
        match pc {
            0x821D61F8 => {
    //   block [0x821D61F8..0x821D6F6C)
	// 821D61F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D61FC: 48AD31F5  bl 0x82ca93f0
	ctx.lr = 0x821D6200;
	sub_82CA93D0(ctx, base);
	// 821D6200: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 821D6204: 48AD7ACD  bl 0x82cadcd0
	ctx.lr = 0x821D6208;
	sub_82CADCA0(ctx, base);
	// 821D6208: 3980FF50  li r12, -0xb0
	ctx.r[12].s64 = -176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D6F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D6F70 size=1504
    let mut pc: u32 = 0x821D6F70;
    'dispatch: loop {
        match pc {
            0x821D6F70 => {
    //   block [0x821D6F70..0x821D7550)
	// 821D6F70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D6F74: 48AD2481  bl 0x82ca93f4
	ctx.lr = 0x821D6F78;
	sub_82CA93D0(ctx, base);
	// 821D6F78: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 821D6F7C: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D6F80: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D6F84: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 821D6F88: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821D6F8C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 821D6F90: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D6F94: 93DD033C  stw r30, 0x33c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(828 as u32), ctx.r[30].u32 ) };
	// 821D6F98: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D6F9C: 554927FE  rlwinm r9, r10, 4, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0FFFFFFFu64;
	// 821D6FA0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D6FA4: 419A00E8  beq cr6, 0x821d708c
	if ctx.cr[6].eq {
	pc = 0x821D708C; continue 'dispatch;
	}
	// 821D6FA8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D6FAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D6FB0: 419A0020  beq cr6, 0x821d6fd0
	if ctx.cr[6].eq {
	pc = 0x821D6FD0; continue 'dispatch;
	}
	// 821D6FB4: 894A003C  lbz r10, 0x3c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 821D6FB8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D6FBC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D6FC0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D6FC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D6FC8: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D6FCC: 480000C4  b 0x821d7090
	pc = 0x821D7090; continue 'dispatch;
	// 821D6FD0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D6FD4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D6FD8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821D6FDC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D6FE0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D6FE4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D6FE8: 40810054  ble 0x821d703c
	if !ctx.cr[0].gt {
	pc = 0x821D703C; continue 'dispatch;
	}
	// 821D6FEC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D6FF0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D6FF4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D6FF8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D6FFC: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 821D7000: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D7004: 41980008  blt cr6, 0x821d700c
	if ctx.cr[6].lt {
	pc = 0x821D700C; continue 'dispatch;
	}
	// 821D7008: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821D700C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D7010: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D7014: 419A0014  beq cr6, 0x821d7028
	if ctx.cr[6].eq {
	pc = 0x821D7028; continue 'dispatch;
	}
	// 821D7018: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D701C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D7020: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D7024: 4800000C  b 0x821d7030
	pc = 0x821D7030; continue 'dispatch;
	// 821D7028: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D702C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821D7030: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D7034: 4199FFB8  bgt cr6, 0x821d6fec
	if ctx.cr[6].gt {
	pc = 0x821D6FEC; continue 'dispatch;
	}
	// 821D7038: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D703C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D7040: 419A003C  beq cr6, 0x821d707c
	if ctx.cr[6].eq {
	pc = 0x821D707C; continue 'dispatch;
	}
	// 821D7044: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D7048: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 821D704C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D7050: 41990008  bgt cr6, 0x821d7058
	if ctx.cr[6].gt {
	pc = 0x821D7058; continue 'dispatch;
	}
	// 821D7054: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821D7058: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D705C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7060: 409A001C  bne cr6, 0x821d707c
	if !ctx.cr[6].eq {
	pc = 0x821D707C; continue 'dispatch;
	}
	// 821D7064: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D7068: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D706C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D7070: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7074: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D7078: 48000018  b 0x821d7090
	pc = 0x821D7090; continue 'dispatch;
	// 821D707C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D7080: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7084: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D7088: 48000008  b 0x821d7090
	pc = 0x821D7090; continue 'dispatch;
	// 821D708C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821D7090: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D7094: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7098: 419A0480  beq cr6, 0x821d7518
	if ctx.cr[6].eq {
	pc = 0x821D7518; continue 'dispatch;
	}
	// 821D709C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821D70A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D70A4: 48010EB5  bl 0x821e7f58
	ctx.lr = 0x821D70A8;
	sub_821E7F58(ctx, base);
	// 821D70A8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D70AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D70B0: 419A0078  beq cr6, 0x821d7128
	if ctx.cr[6].eq {
	pc = 0x821D7128; continue 'dispatch;
	}
	// 821D70B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D70B8: 4BF9BA71  bl 0x82172b28
	ctx.lr = 0x821D70BC;
	sub_82172B28(ctx, base);
	// 821D70BC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D70C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D70C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D70C8: 419A0050  beq cr6, 0x821d7118
	if ctx.cr[6].eq {
	pc = 0x821D7118; continue 'dispatch;
	}
	// 821D70CC: 4BFF90C5  bl 0x821d0190
	ctx.lr = 0x821D70D0;
	sub_821D0190(ctx, base);
	// 821D70D0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D70D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D70D8: 409A046C  bne cr6, 0x821d7544
	if !ctx.cr[6].eq {
	pc = 0x821D7544; continue 'dispatch;
	}
	// 821D70DC: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 821D70E0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821D70E4: 409A0044  bne cr6, 0x821d7128
	if !ctx.cr[6].eq {
	pc = 0x821D7128; continue 'dispatch;
	}
	// 821D70E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821D70EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D70F0: 48010E69  bl 0x821e7f58
	ctx.lr = 0x821D70F4;
	sub_821E7F58(ctx, base);
	// 821D70F4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D70F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D70FC: 419A002C  beq cr6, 0x821d7128
	if ctx.cr[6].eq {
	pc = 0x821D7128; continue 'dispatch;
	}
	// 821D7100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D7104: 4848D335  bl 0x82664438
	ctx.lr = 0x821D7108;
	sub_82664438(ctx, base);
	// 821D7108: 93DD033C  stw r30, 0x33c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(828 as u32), ctx.r[30].u32 ) };
	// 821D710C: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 821D7110: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821D7114: 48AD2330  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
	// 821D7118: 4BFF9079  bl 0x821d0190
	ctx.lr = 0x821D711C;
	sub_821D0190(ctx, base);
	// 821D711C: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 821D7120: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821D7124: 48AD2320  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
	// 821D7128: 897F00BA  lbz r11, 0xba(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(186 as u32) ) } as u64;
	// 821D712C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7130: 409A03E8  bne cr6, 0x821d7518
	if !ctx.cr[6].eq {
	pc = 0x821D7518; continue 'dispatch;
	}
	// 821D7134: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 821D7138: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821D713C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D7140: 4BFF8CC9  bl 0x821cfe08
	ctx.lr = 0x821D7144;
	sub_821CFE08(ctx, base);
	// 821D7144: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D7148: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D714C: 419A03CC  beq cr6, 0x821d7518
	if ctx.cr[6].eq {
	pc = 0x821D7518; continue 'dispatch;
	}
	// 821D7150: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 821D7154: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7158: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821D715C: 913D033C  stw r9, 0x33c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(828 as u32), ctx.r[9].u32 ) };
	// 821D7160: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821D7164: 55079FFE  rlwinm r7, r8, 0x13, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x00001FFFu64;
	// 821D7168: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D716C: 419A00F4  beq cr6, 0x821d7260
	if ctx.cr[6].eq {
	pc = 0x821D7260; continue 'dispatch;
	}
	// 821D7170: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D7174: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D7178: 419A0024  beq cr6, 0x821d719c
	if ctx.cr[6].eq {
	pc = 0x821D719C; continue 'dispatch;
	}
	// 821D717C: 894A006D  lbz r10, 0x6d(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(109 as u32) ) } as u64;
	// 821D7180: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D7184: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D7188: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D718C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7190: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821D7194: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D7198: 480000CC  b 0x821d7264
	pc = 0x821D7264; continue 'dispatch;
	// 821D719C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D71A0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D71A4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821D71A8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D71AC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D71B0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D71B4: 40810054  ble 0x821d7208
	if !ctx.cr[0].gt {
	pc = 0x821D7208; continue 'dispatch;
	}
	// 821D71B8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D71BC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D71C0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D71C4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D71C8: 2F07006D  cmpwi cr6, r7, 0x6d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 109, &mut ctx.xer);
	// 821D71CC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D71D0: 41980008  blt cr6, 0x821d71d8
	if ctx.cr[6].lt {
	pc = 0x821D71D8; continue 'dispatch;
	}
	// 821D71D4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821D71D8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D71DC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D71E0: 419A0014  beq cr6, 0x821d71f4
	if ctx.cr[6].eq {
	pc = 0x821D71F4; continue 'dispatch;
	}
	// 821D71E4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D71E8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D71EC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D71F0: 4800000C  b 0x821d71fc
	pc = 0x821D71FC; continue 'dispatch;
	// 821D71F4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D71F8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821D71FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D7200: 4199FFB8  bgt cr6, 0x821d71b8
	if ctx.cr[6].gt {
	pc = 0x821D71B8; continue 'dispatch;
	}
	// 821D7204: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D7208: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D720C: 419A0040  beq cr6, 0x821d724c
	if ctx.cr[6].eq {
	pc = 0x821D724C; continue 'dispatch;
	}
	// 821D7210: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D7214: 2F0B006D  cmpwi cr6, r11, 0x6d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 109, &mut ctx.xer);
	// 821D7218: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D721C: 41990008  bgt cr6, 0x821d7224
	if ctx.cr[6].gt {
	pc = 0x821D7224; continue 'dispatch;
	}
	// 821D7220: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821D7224: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D7228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D722C: 409A0020  bne cr6, 0x821d724c
	if !ctx.cr[6].eq {
	pc = 0x821D724C; continue 'dispatch;
	}
	// 821D7230: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D7234: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D7238: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D723C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7240: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821D7244: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D7248: 4800001C  b 0x821d7264
	pc = 0x821D7264; continue 'dispatch;
	// 821D724C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D7250: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7254: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821D7258: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D725C: 48000008  b 0x821d7264
	pc = 0x821D7264; continue 'dispatch;
	// 821D7260: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821D7264: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D7268: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D726C: 419A0008  beq cr6, 0x821d7274
	if ctx.cr[6].eq {
	pc = 0x821D7274; continue 'dispatch;
	}
	// 821D7270: 9B8A0024  stb r28, 0x24(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), ctx.r[28].u8 ) };
	// 821D7274: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7278: 480B0B71  bl 0x82287de8
	ctx.lr = 0x821D727C;
	sub_82287DE8(ctx, base);
	// 821D727C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821D7280: 480E16B9  bl 0x822b8938
	ctx.lr = 0x821D7284;
	sub_822B8938(ctx, base);
	// 821D7284: 815D0590  lwz r10, 0x590(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1424 as u32) ) } as u64;
	// 821D7288: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D728C: 3BFD0580  addi r31, r29, 0x580
	ctx.r[31].s64 = ctx.r[29].s64 + 1408;
	// 821D7290: 3BCB92CC  addi r30, r11, -0x6d34
	ctx.r[30].s64 = ctx.r[11].s64 + -27956;
	// 821D7294: C1AA0018  lfs f13, 0x18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D7298: C00A001C  lfs f0, 0x1c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D729C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821D72A0: C1AB92CC  lfs f13, -0x6d34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27956 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D72A4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821D72A8: 40980008  bge cr6, 0x821d72b0
	if !ctx.cr[6].lt {
	pc = 0x821D72B0; continue 'dispatch;
	}
	// 821D72AC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 821D72B0: 817D0590  lwz r11, 0x590(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1424 as u32) ) } as u64;
	// 821D72B4: C1BD07AC  lfs f13, 0x7ac(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1964 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D72B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D72BC: EFED002A  fadds f31, f13, f0
	ctx.f[31].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821D72C0: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 821D72C4: 3B6100B0  addi r27, r1, 0xb0
	ctx.r[27].s64 = ctx.r[1].s64 + 176;
	// 821D72C8: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 821D72CC: 832B000C  lwz r25, 0xc(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D72D0: 830B0014  lwz r24, 0x14(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D72D4: 4BFBA4CD  bl 0x821917a0
	ctx.lr = 0x821D72D8;
	sub_821917A0(ctx, base);
	// 821D72D8: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 821D72DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D72E0: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 821D72E4: 4BFBA675  bl 0x82191958
	ctx.lr = 0x821D72E8;
	sub_82191958(ctx, base);
	// 821D72E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D72EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D72F0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D72F4: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821D72F8: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 821D72FC: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 821D7300: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 821D7304: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 821D7308: 480E1709  bl 0x822b8a10
	ctx.lr = 0x821D730C;
	sub_822B8A10(ctx, base);
	// 821D730C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821D7310: 419A0018  beq cr6, 0x821d7328
	if ctx.cr[6].eq {
	pc = 0x821D7328; continue 'dispatch;
	}
	// 821D7314: C01E2524  lfs f0, 0x2524(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(9508 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D7318: D01D0834  stfs f0, 0x834(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(2100 as u32), tmp.u32 ) };
	// 821D731C: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 821D7320: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821D7324: 48AD2120  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
	// 821D7328: 817D07CC  lwz r11, 0x7cc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1996 as u32) ) } as u64;
	// 821D732C: 3BFD07CC  addi r31, r29, 0x7cc
	ctx.r[31].s64 = ctx.r[29].s64 + 1996;
	// 821D7330: 894B009D  lbz r10, 0x9d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(157 as u32) ) } as u64;
	// 821D7334: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D7338: 419A0048  beq cr6, 0x821d7380
	if ctx.cr[6].eq {
	pc = 0x821D7380; continue 'dispatch;
	}
	// 821D733C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821D7340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D7344: 4BFF9175  bl 0x821d04b8
	ctx.lr = 0x821D7348;
	sub_821D04B8(ctx, base);
	// 821D7348: C01E2494  lfs f0, 0x2494(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(9364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D734C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821D7350: 41990030  bgt cr6, 0x821d7380
	if ctx.cr[6].gt {
	pc = 0x821D7380; continue 'dispatch;
	}
	// 821D7354: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D7358: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D735C: 480101AD  bl 0x821e7508
	ctx.lr = 0x821D7360;
	sub_821E7508(ctx, base);
	// 821D7360: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821D7364: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821D7368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D7550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D7550 size=284
    let mut pc: u32 = 0x821D7550;
    'dispatch: loop {
        match pc {
            0x821D7550 => {
    //   block [0x821D7550..0x821D766C)
	// 821D7550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D7554: 48AD1EB9  bl 0x82ca940c
	ctx.lr = 0x821D7558;
	sub_82CA93D0(ctx, base);
	// 821D7558: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D755C: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821D7560: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821D7564: 390B7DA0  addi r8, r11, 0x7da0
	ctx.r[8].s64 = ctx.r[11].s64 + 32160;
	// 821D7568: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821D756C: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 821D7570: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D7574: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821D7578: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 821D757C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821D7580: 7C8A2B96  divwu r4, r10, r5
	ctx.r[4].u32 = ctx.r[10].u32 / ctx.r[5].u32;
	// 821D7584: 7CC32030  slw r3, r6, r4
	if (ctx.r[4].u8 & 0x20) != 0 {
		ctx.r[3].u64 = 0;
	} else {
		ctx.r[3].u64 = ((ctx.r[6].u32) << ((ctx.r[4].u8 & 0x1F) as u32)) as u64;
	}
	// 821D7588: 7C643838  and r4, r3, r7
	ctx.r[4].u64 = ctx.r[3].u64 & ctx.r[7].u64;
	// 821D758C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821D7590: 419A0014  beq cr6, 0x821d75a4
	if ctx.cr[6].eq {
	pc = 0x821D75A4; continue 'dispatch;
	}
	// 821D7594: A08B0000  lhz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D7598: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821D759C: B0890000  sth r4, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[4].u16 ) };
	// 821D75A0: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	// 821D75A4: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 821D75A8: 38880060  addi r4, r8, 0x60
	ctx.r[4].s64 = ctx.r[8].s64 + 96;
	// 821D75AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821D75B0: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 821D75B4: 4198FFCC  blt cr6, 0x821d7580
	if ctx.cr[6].lt {
	pc = 0x821D7580; continue 'dispatch;
	}
	// 821D75B8: 3FA08336  lis r29, -0x7cca
	ctx.r[29].s64 = -2093613056;
	// 821D75BC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821D75C0: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821D75C4: 817D0364  lwz r11, 0x364(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(868 as u32) ) } as u64;
	// 821D75C8: 814A5144  lwz r10, 0x5144(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20804 as u32) ) } as u64;
	// 821D75CC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 821D75D0: 914B2E2C  stw r10, 0x2e2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(11820 as u32), ctx.r[10].u32 ) };
	// 821D75D4: E8E80010  ld r7, 0x10(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) };
	// 821D75D8: 64E60008  oris r6, r7, 8
	ctx.r[6].u64 = ctx.r[7].u64 | 524288;
	// 821D75DC: 914970B8  stw r10, 0x70b8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28856 as u32), ctx.r[10].u32 ) };
	// 821D75E0: F8C80010  std r6, 0x10(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 821D75E4: 48046EBD  bl 0x8221e4a0
	ctx.lr = 0x821D75E8;
	sub_8221E4A0(ctx, base);
	// 821D75E8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 821D75EC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821D75F0: 7D7F2BD6  divw r11, r31, r5
	ctx.r[11].s32 = ctx.r[31].s32 / ctx.r[5].s32;
	// 821D75F4: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 821D75F8: 39410064  addi r10, r1, 0x64
	ctx.r[10].s64 = ctx.r[1].s64 + 100;
	// 821D75FC: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D7600: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 821D7604: 7FCB4214  add r30, r11, r8
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 821D7608: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821D760C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821D7610: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 821D7614: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D7618: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821D761C: 83FD0364  lwz r31, 0x364(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(868 as u32) ) } as u64;
	// 821D7620: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D7624: 48040795  bl 0x82217db8
	ctx.lr = 0x821D7628;
	sub_82217DB8(ctx, base);
	// 821D7628: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821D762C: 409A0038  bne cr6, 0x821d7664
	if !ctx.cr[6].eq {
	pc = 0x821D7664; continue 'dispatch;
	}
	// 821D7630: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821D7634: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821D7638: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 821D763C: 388B7E00  addi r4, r11, 0x7e00
	ctx.r[4].s64 = ctx.r[11].s64 + 32256;
	// 821D7640: 48AD1E41  bl 0x82ca9480
	ctx.lr = 0x821D7644;
	sub_82CA9480(ctx, base);
	// 821D7644: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D7648: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821D764C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821D7650: 394B0003  addi r10, r11, 3
	ctx.r[10].s64 = ctx.r[11].s64 + 3;
	// 821D7654: 5545003A  rlwinm r5, r10, 0, 0, 0x1d
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821D7658: 48AD1E29  bl 0x82ca9480
	ctx.lr = 0x821D765C;
	sub_82CA9480(ctx, base);
	// 821D765C: 813F3484  lwz r9, 0x3484(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13444 as u32) ) } as u64;
	// 821D7660: 913F0030  stw r9, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[9].u32 ) };
	// 821D7664: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 821D7668: 48AD1DF4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D7670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D7670 size=240
    let mut pc: u32 = 0x821D7670;
    'dispatch: loop {
        match pc {
            0x821D7670 => {
    //   block [0x821D7670..0x821D7760)
	// 821D7670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D7674: 48AD1D91  bl 0x82ca9404
	ctx.lr = 0x821D7678;
	sub_82CA93D0(ctx, base);
	// 821D7678: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D767C: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D7680: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821D7684: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 821D7688: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821D768C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D7690: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 821D7694: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821D7698: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 821D769C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D76A0: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D76A4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D76A8: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821D76AC: 419A0008  beq cr6, 0x821d76b4
	if ctx.cr[6].eq {
	pc = 0x821D76B4; continue 'dispatch;
	}
	// 821D76B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D76B4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D76B8: 419A007C  beq cr6, 0x821d7734
	if ctx.cr[6].eq {
	pc = 0x821D7734; continue 'dispatch;
	}
	// 821D76BC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D76C0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D76C4: 409A0008  bne cr6, 0x821d76cc
	if !ctx.cr[6].eq {
	pc = 0x821D76CC; continue 'dispatch;
	}
	// 821D76C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D76CC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D76D0: 395F0008  addi r10, r31, 8
	ctx.r[10].s64 = ctx.r[31].s64 + 8;
	// 821D76D4: 7F0BD800  cmpw cr6, r11, r27
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[27].s32, &mut ctx.xer);
	// 821D76D8: 4099005C  ble cr6, 0x821d7734
	if !ctx.cr[6].gt {
	pc = 0x821D7734; continue 'dispatch;
	}
	// 821D76DC: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D76E0: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D76E4: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821D76E8: 41980014  blt cr6, 0x821d76fc
	if ctx.cr[6].lt {
	pc = 0x821D76FC; continue 'dispatch;
	}
	// 821D76EC: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D76F0: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821D76F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D76F8: 41980008  blt cr6, 0x821d7700
	if ctx.cr[6].lt {
	pc = 0x821D7700; continue 'dispatch;
	}
	// 821D76FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D7700: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D7704: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7708: 419A0014  beq cr6, 0x821d771c
	if ctx.cr[6].eq {
	pc = 0x821D771C; continue 'dispatch;
	}
	// 821D770C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821D7710: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821D7714: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821D7718: 48972039  bl 0x82b49750
	ctx.lr = 0x821D771C;
	sub_82B49750(ctx, base);
	// 821D771C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7720: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D7724: 409A0008  bne cr6, 0x821d772c
	if !ctx.cr[6].eq {
	pc = 0x821D772C; continue 'dispatch;
	}
	// 821D7728: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D772C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D7730: 4BFFFF74  b 0x821d76a4
	pc = 0x821D76A4; continue 'dispatch;
	// 821D7734: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7738: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D773C: 409A0010  bne cr6, 0x821d774c
	if !ctx.cr[6].eq {
	pc = 0x821D774C; continue 'dispatch;
	}
	// 821D7740: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D7744: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821D7748: 48AD1D0C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 821D774C: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D7750: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D7754: 7D231670  srawi r3, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 821D7758: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821D775C: 48AD1CF8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D7760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D7760 size=596
    let mut pc: u32 = 0x821D7760;
    'dispatch: loop {
        match pc {
            0x821D7760 => {
    //   block [0x821D7760..0x821D79B4)
	// 821D7760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D7764: 48AD1CA1  bl 0x82ca9404
	ctx.lr = 0x821D7768;
	sub_82CA93D0(ctx, base);
	// 821D7768: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D776C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821D7770: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 821D7774: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D7778: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D777C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D7780: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821D7784: 4BFBF5ED  bl 0x82196d70
	ctx.lr = 0x821D7788;
	sub_82196D70(ctx, base);
	// 821D7788: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D778C: 813D000C  lwz r9, 0xc(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D7790: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7794: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7798: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821D779C: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 821D77A0: 409A000C  bne cr6, 0x821d77ac
	if !ctx.cr[6].eq {
	pc = 0x821D77AC; continue 'dispatch;
	}
	// 821D77A4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821D77A8: 48000010  b 0x821d77b8
	pc = 0x821D77B8; continue 'dispatch;
	// 821D77AC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D77B0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D77B4: 7D292670  srawi r9, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 821D77B8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821D77BC: 419A01DC  beq cr6, 0x821d7998
	if ctx.cr[6].eq {
	pc = 0x821D7998; continue 'dispatch;
	}
	// 821D77C0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D77C4: 3D400FFF  lis r10, 0xfff
	ctx.r[10].s64 = 268369920;
	// 821D77C8: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821D77CC: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 821D77D0: 7D0B2670  srawi r11, r8, 4
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 4) as i64;
	// 821D77D4: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D77D8: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821D77DC: 4098000C  bge cr6, 0x821d77e8
	if !ctx.cr[6].lt {
	pc = 0x821D77E8; continue 'dispatch;
	}
	// 821D77E0: 4886FCE9  bl 0x82a474c8
	ctx.lr = 0x821D77E4;
	sub_82A474C8(ctx, base);
	// 821D77E4: 480001B4  b 0x821d7998
	pc = 0x821D7998; continue 'dispatch;
	// 821D77E8: 7D0BF214  add r8, r11, r30
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821D77EC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821D77F0: 409800C4  bge cr6, 0x821d78b4
	if !ctx.cr[6].lt {
	pc = 0x821D78B4; continue 'dispatch;
	}
	// 821D77F4: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D77F8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821D77FC: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D7800: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821D7804: 41980008  blt cr6, 0x821d780c
	if ctx.cr[6].lt {
	pc = 0x821D780C; continue 'dispatch;
	}
	// 821D7808: 7F8B4A14  add r28, r11, r9
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821D780C: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821D7810: 40980008  bge cr6, 0x821d7818
	if !ctx.cr[6].lt {
	pc = 0x821D7818; continue 'dispatch;
	}
	// 821D7814: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 821D7818: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821D781C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D7820: 4824BA19  bl 0x82423238
	ctx.lr = 0x821D7824;
	sub_82423238(ctx, base);
	// 821D7824: 836100AC  lwz r27, 0xac(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 821D7828: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D782C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7830: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821D7834: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821D7838: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D783C: 4850DEBD  bl 0x826e56f8
	ctx.lr = 0x821D7840;
	sub_826E56F8(ctx, base);
	// 821D7840: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D7844: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821D7848: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821D784C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D7850: 4BFFDC69  bl 0x821d54b8
	ctx.lr = 0x821D7854;
	sub_821D54B8(ctx, base);
	// 821D7854: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 821D7858: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821D785C: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D7860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D7864: 4850DE95  bl 0x826e56f8
	ctx.lr = 0x821D7868;
	sub_826E56F8(ctx, base);
	// 821D7868: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D786C: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D7870: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821D7874: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 821D7878: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 821D787C: 7FCBF214  add r30, r11, r30
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821D7880: 419A0014  beq cr6, 0x821d7894
	if ctx.cr[6].eq {
	pc = 0x821D7894; continue 'dispatch;
	}
	// 821D7884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D7888: 4821DD81  bl 0x823f5608
	ctx.lr = 0x821D788C;
	sub_823F5608(ctx, base);
	// 821D788C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7890: 480444A9  bl 0x8221bd38
	ctx.lr = 0x821D7894;
	sub_8221BD38(ctx, base);
	// 821D7894: 578B2036  slwi r11, r28, 4
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D7898: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821D789C: 57CA2036  slwi r10, r30, 4
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D78A0: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821D78A4: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 821D78A8: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 821D78AC: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821D78B0: 480000E8  b 0x821d7998
	pc = 0x821D7998; continue 'dispatch;
	// 821D78B4: 838100AC  lwz r28, 0xac(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 821D78B8: 57DD2036  slwi r29, r30, 4
	ctx.r[29].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 821D78BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D78C0: 7D7C2850  subf r11, r28, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[28].s64;
	// 821D78C4: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 821D78C8: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821D78CC: 40980040  bge cr6, 0x821d790c
	if !ctx.cr[6].lt {
	pc = 0x821D790C; continue 'dispatch;
	}
	// 821D78D0: 7CDDE214  add r6, r29, r28
	ctx.r[6].u64 = ctx.r[29].u64 + ctx.r[28].u64;
	// 821D78D4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821D78D8: 4850DE21  bl 0x826e56f8
	ctx.lr = 0x821D78DC;
	sub_826E56F8(ctx, base);
	// 821D78DC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D78E0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821D78E4: 7D7C2050  subf r11, r28, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[28].s64;
	// 821D78E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D78EC: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 821D78F0: 7CAAF050  subf r5, r10, r30
	ctx.r[5].s64 = ctx.r[30].s64 - ctx.r[10].s64;
	// 821D78F4: 4BFFDBC5  bl 0x821d54b8
	ctx.lr = 0x821D78F8;
	sub_821D54B8(ctx, base);
	// 821D78F8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D78FC: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821D7900: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821D7904: 7C9D5850  subf r4, r29, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 821D7908: 48000084  b 0x821d798c
	pc = 0x821D798C; continue 'dispatch;
	// 821D790C: 7FDD2850  subf r30, r29, r5
	ctx.r[30].s64 = ctx.r[5].s64 - ctx.r[29].s64;
	// 821D7910: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 821D7914: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D7918: 4850DDE1  bl 0x826e56f8
	ctx.lr = 0x821D791C;
	sub_826E56F8(ctx, base);
	// 821D791C: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 821D7920: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821D7924: 7F1CF040  cmplw cr6, r28, r30
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821D7928: 419A0060  beq cr6, 0x821d7988
	if ctx.cr[6].eq {
	pc = 0x821D7988; continue 'dispatch;
	}
	// 821D792C: 7D7DFA14  add r11, r29, r31
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 821D7930: 3BCB000C  addi r30, r11, 0xc
	ctx.r[30].s64 = ctx.r[11].s64 + 12;
	// 821D7934: 3BFFFFF0  addi r31, r31, -0x10
	ctx.r[31].s64 = ctx.r[31].s64 + -16;
	// 821D7938: 3BDEFFF0  addi r30, r30, -0x10
	ctx.r[30].s64 = ctx.r[30].s64 + -16;
	// 821D793C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7940: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7944: 419A0020  beq cr6, 0x821d7964
	if ctx.cr[6].eq {
	pc = 0x821D7964; continue 'dispatch;
	}
	// 821D7948: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D794C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D7950: 419A000C  beq cr6, 0x821d795c
	if ctx.cr[6].eq {
	pc = 0x821D795C; continue 'dispatch;
	}
	// 821D7954: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821D7958: 48000010  b 0x821d7968
	pc = 0x821D7968; continue 'dispatch;
	// 821D795C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D7960: 4BFBC4D9  bl 0x82193e38
	ctx.lr = 0x821D7964;
	sub_82193E38(ctx, base);
	// 821D7964: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821D7968: 387EFFF4  addi r3, r30, -0xc
	ctx.r[3].s64 = ctx.r[30].s64 + -12;
	// 821D796C: 4803CF2D  bl 0x82214898
	ctx.lr = 0x821D7970;
	sub_82214898(ctx, base);
	// 821D7970: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D7974: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821D7978: 917EFFFC  stw r11, -4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 821D797C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D7980: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821D7984: 409AFFB0  bne cr6, 0x821d7934
	if !ctx.cr[6].eq {
	pc = 0x821D7934; continue 'dispatch;
	}
	// 821D7988: 7C9DE214  add r4, r29, r28
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[28].u64;
	// 821D798C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D7990: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821D7994: 4850DDCD  bl 0x826e5760
	ctx.lr = 0x821D7998;
	sub_826E5760(ctx, base);
	// 821D7998: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D799C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D79A0: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 821D79A4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821D79A8: 4BFBC491  bl 0x82193e38
	ctx.lr = 0x821D79AC;
	sub_82193E38(ctx, base);
	// 821D79AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821D79B0: 48AD1AA4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D79B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D79B8 size=220
    let mut pc: u32 = 0x821D79B8;
    'dispatch: loop {
        match pc {
            0x821D79B8 => {
    //   block [0x821D79B8..0x821D7A94)
	// 821D79B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D79BC: 48AD1A2D  bl 0x82ca93e8
	ctx.lr = 0x821D79C0;
	sub_82CA93D0(ctx, base);
	// 821D79C0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D79C4: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 821D79C8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821D79CC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821D79D0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821D79D4: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821D79D8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D79DC: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 821D79E0: 7D364B78  mr r22, r9
	ctx.r[22].u64 = ctx.r[9].u64;
	// 821D79E4: 7D555378  mr r21, r10
	ctx.r[21].u64 = ctx.r[10].u64;
	// 821D79E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D79EC: 409A0010  bne cr6, 0x821d79fc
	if !ctx.cr[6].eq {
	pc = 0x821D79FC; continue 'dispatch;
	}
	// 821D79F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D79F4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821D79F8: 48AD1A40  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
	// 821D79FC: 8B210127  lbz r25, 0x127(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(295 as u32) ) } as u64;
	// 821D7A00: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 821D7A04: 8301011C  lwz r24, 0x11c(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 821D7A08: 82E10114  lwz r23, 0x114(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 821D7A0C: 7F1FB040  cmplw cr6, r31, r22
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[22].u32, &mut ctx.xer);
	// 821D7A10: 41980078  blt cr6, 0x821d7a88
	if ctx.cr[6].lt {
	pc = 0x821D7A88; continue 'dispatch;
	}
	// 821D7A14: 7F1EA840  cmplw cr6, r30, r21
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[21].u32, &mut ctx.xer);
	// 821D7A18: 41980070  blt cr6, 0x821d7a88
	if ctx.cr[6].lt {
	pc = 0x821D7A88; continue 'dispatch;
	}
	// 821D7A1C: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 821D7A20: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 821D7A24: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 821D7A28: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821D7A2C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821D7A30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821D7A34: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821D7A38: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821D7A3C: 480092E5  bl 0x821e0d20
	ctx.lr = 0x821D7A40;
	sub_821E0D20(ctx, base);
	// 821D7A40: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D7A44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7A48: 419A000C  beq cr6, 0x821d7a54
	if ctx.cr[6].eq {
	pc = 0x821D7A54; continue 'dispatch;
	}
	// 821D7A4C: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 821D7A50: 4800002C  b 0x821d7a7c
	pc = 0x821D7A7C; continue 'dispatch;
	// 821D7A54: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 821D7A58: 419A0010  beq cr6, 0x821d7a68
	if ctx.cr[6].eq {
	pc = 0x821D7A68; continue 'dispatch;
	}
	// 821D7A5C: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D7A60: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D7A64: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821D7A68: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 821D7A6C: 40990008  ble cr6, 0x821d7a74
	if !ctx.cr[6].gt {
	pc = 0x821D7A74; continue 'dispatch;
	}
	// 821D7A70: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 821D7A74: 57FFF87E  srwi r31, r31, 1
	ctx.r[31].u32 = ctx.r[31].u32.wrapping_shr(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 821D7A78: 57DEF87E  srwi r30, r30, 1
	ctx.r[30].u32 = ctx.r[30].u32.wrapping_shr(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821D7A7C: 568B063E  clrlwi r11, r20, 0x18
	ctx.r[11].u64 = ctx.r[20].u32 as u64 & 0x000000FFu64;
	// 821D7A80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7A84: 419AFF88  beq cr6, 0x821d7a0c
	if ctx.cr[6].eq {
	pc = 0x821D7A0C; continue 'dispatch;
	}
	// 821D7A88: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 821D7A8C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821D7A90: 48AD19A8  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D7A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D7A98 size=1348
    let mut pc: u32 = 0x821D7A98;
    'dispatch: loop {
        match pc {
            0x821D7A98 => {
    //   block [0x821D7A98..0x821D7FDC)
	// 821D7A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D7A9C: 48AD1945  bl 0x82ca93e0
	ctx.lr = 0x821D7AA0;
	sub_82CA93D0(ctx, base);
	// 821D7AA0: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D7AA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D7AA8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821D7AAC: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 821D7AB0: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D7AB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7AB8: 419A0020  beq cr6, 0x821d7ad8
	if ctx.cr[6].eq {
	pc = 0x821D7AD8; continue 'dispatch;
	}
	// 821D7ABC: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821D7AC0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821D7AC4: 419A0008  beq cr6, 0x821d7acc
	if ctx.cr[6].eq {
	pc = 0x821D7ACC; continue 'dispatch;
	}
	// 821D7AC8: 48045631  bl 0x8221d0f8
	ctx.lr = 0x821D7ACC;
	sub_8221D0F8(ctx, base);
	// 821D7ACC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D7AD0: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821D7AD4: 48AD195C  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
	// 821D7AD8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821D7ADC: 894B6E72  lbz r10, 0x6e72(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28274 as u32) ) } as u64;
	// 821D7AE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D7AE4: 419A0020  beq cr6, 0x821d7b04
	if ctx.cr[6].eq {
	pc = 0x821D7B04; continue 'dispatch;
	}
	// 821D7AE8: 3D607FFF  lis r11, 0x7fff
	ctx.r[11].s64 = 2147418112;
	// 821D7AEC: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D7AF0: 6169FFFF  ori r9, r11, 0xffff
	ctx.r[9].u64 = ctx.r[11].u64 | 65535;
	// 821D7AF4: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821D7AF8: 409A000C  bne cr6, 0x821d7b04
	if !ctx.cr[6].eq {
	pc = 0x821D7B04; continue 'dispatch;
	}
	// 821D7AFC: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D7B00: 48A914A9  bl 0x82c68fa8
	ctx.lr = 0x821D7B04;
	sub_82C68FA8(ctx, base);
	// 821D7B04: 56D5063E  clrlwi r21, r22, 0x18
	ctx.r[21].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	// 821D7B08: 815F009C  lwz r10, 0x9c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 821D7B0C: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D7B10: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 821D7B14: 7EA80034  cntlzw r8, r21
	ctx.r[8].u64 = if ctx.r[21].u32 == 0 { 32 } else { ctx.r[21].u32.leading_zeros() as u64 };
	// 821D7B18: 813F00A0  lwz r9, 0xa0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 821D7B1C: 83DF0094  lwz r30, 0x94(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 821D7B20: 7E93A378  mr r19, r20
	ctx.r[19].u64 = ctx.r[20].u64;
	// 821D7B24: 5507DFFE  rlwinm r7, r8, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 821D7B28: 811F0098  lwz r8, 0x98(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 821D7B2C: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 821D7B30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D7B34: 68EA0001  xori r10, r7, 1
	ctx.r[10].u64 = ctx.r[7].u64 ^ 1;
	// 821D7B38: 3A4A0001  addi r18, r10, 1
	ctx.r[18].s64 = ctx.r[10].s64 + 1;
	// 821D7B3C: 419A0280  beq cr6, 0x821d7dbc
	if ctx.cr[6].eq {
	pc = 0x821D7DBC; continue 'dispatch;
	}
	// 821D7B40: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821D7B44: 409A048C  bne cr6, 0x821d7fd0
	if !ctx.cr[6].eq {
	pc = 0x821D7FD0; continue 'dispatch;
	}
	// 821D7B48: 7D7E4050  subf r11, r30, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[30].s64;
	// 821D7B4C: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821D7B50: 7D6AFE70  srawi r10, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 821D7B54: 7D4B5838  and r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 & ctx.r[11].u64;
	// 821D7B58: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821D7B5C: 7CE61670  srawi r6, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[7].s32 >> 2) as i64;
	// 821D7B60: 7D660195  addze. r11, r6
	tmp.s64 = ctx.r[6].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[6].u32);
	ctx.r[11].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D7B64: 4082000C  bne 0x821d7b70
	if !ctx.cr[0].eq {
	pc = 0x821D7B70; continue 'dispatch;
	}
	// 821D7B68: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821D7B6C: 4800008C  b 0x821d7bf8
	pc = 0x821D7BF8; continue 'dispatch;
	// 821D7B70: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 821D7B74: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D7B78: 4198000C  blt cr6, 0x821d7b84
	if ctx.cr[6].lt {
	pc = 0x821D7B84; continue 'dispatch;
	}
	// 821D7B7C: 3960001F  li r11, 0x1f
	ctx.r[11].s64 = 31;
	// 821D7B80: 48000078  b 0x821d7bf8
	pc = 0x821D7BF8; continue 'dispatch;
	// 821D7B84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D7B88: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821D7B8C: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D7B90: 7CE6FE70  srawi r6, r7, 0x1f
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[7].s32 >> 31) as i64;
	// 821D7B94: 54CA06F6  rlwinm r10, r6, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 821D7B98: 38AA0008  addi r5, r10, 8
	ctx.r[5].s64 = ctx.r[10].s64 + 8;
	// 821D7B9C: 7F442830  slw r4, r26, r5
	if (ctx.r[5].u8 & 0x20) != 0 {
		ctx.r[4].u64 = 0;
	} else {
		ctx.r[4].u64 = ((ctx.r[26].u32) << ((ctx.r[5].u8 & 0x1F) as u32)) as u64;
	}
	// 821D7BA0: 7C6B2050  subf r3, r11, r4
	ctx.r[3].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 821D7BA4: 7C67FE70  srawi r7, r3, 0x1f
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[3].s32 >> 31) as i64;
	// 821D7BA8: 54E70738  rlwinm r7, r7, 0, 0x1c, 0x1c
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821D7BAC: 7D475214  add r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 821D7BB0: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 821D7BB4: 7F453030  slw r5, r26, r6
	if (ctx.r[6].u8 & 0x20) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = ((ctx.r[26].u32) << ((ctx.r[6].u8 & 0x1F) as u32)) as u64;
	}
	// 821D7BB8: 7C8B2850  subf r4, r11, r5
	ctx.r[4].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821D7BBC: 7C83FE70  srawi r3, r4, 0x1f
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[4].s32 >> 31) as i64;
	// 821D7BC0: 5467077A  rlwinm r7, r3, 0, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 821D7BC4: 7D475214  add r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 821D7BC8: 38EA0002  addi r7, r10, 2
	ctx.r[7].s64 = ctx.r[10].s64 + 2;
	// 821D7BCC: 7F463830  slw r6, r26, r7
	if (ctx.r[7].u8 & 0x20) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = ((ctx.r[26].u32) << ((ctx.r[7].u8 & 0x1F) as u32)) as u64;
	}
	// 821D7BD0: 7CAB3050  subf r5, r11, r6
	ctx.r[5].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 821D7BD4: 7CA4FE70  srawi r4, r5, 0x1f
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[5].s32 >> 31) as i64;
	// 821D7BD8: 548707BC  rlwinm r7, r4, 0, 0x1e, 0x1e
	ctx.r[7].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 821D7BDC: 7D475214  add r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 821D7BE0: 386A0001  addi r3, r10, 1
	ctx.r[3].s64 = ctx.r[10].s64 + 1;
	// 821D7BE4: 7F471830  slw r7, r26, r3
	if (ctx.r[3].u8 & 0x20) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = ((ctx.r[26].u32) << ((ctx.r[3].u8 & 0x1F) as u32)) as u64;
	}
	// 821D7BE8: 7CCB3850  subf r6, r11, r7
	ctx.r[6].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 821D7BEC: 7CC5FE70  srawi r5, r6, 0x1f
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[6].s32 >> 31) as i64;
	// 821D7BF0: 54AB07FE  clrlwi r11, r5, 0x1f
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x00000001u64;
	// 821D7BF4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821D7BF8: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 821D7BFC: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 821D7C00: 7D174378  mr r23, r8
	ctx.r[23].u64 = ctx.r[8].u64;
	// 821D7C04: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821D7C08: 7FD8F378  mr r24, r30
	ctx.r[24].u64 = ctx.r[30].u64;
	// 821D7C0C: 7D48FE70  srawi r8, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 821D7C10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7C14: 7D0A5038  and r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 & ctx.r[10].u64;
	// 821D7C18: 7FAA4A14  add r29, r10, r9
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821D7C1C: 419A0028  beq cr6, 0x821d7c44
	if ctx.cr[6].eq {
	pc = 0x821D7C44; continue 'dispatch;
	}
	// 821D7C20: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D7C24: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 821D7C28: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821D7C2C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7C30: 48022FA1  bl 0x821fabd0
	ctx.lr = 0x821D7C34;
	sub_821FABD0(ctx, base);
	// 821D7C34: 81410098  lwz r10, 0x98(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821D7C38: 8121009C  lwz r9, 0x9c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 821D7C3C: 5558083C  slwi r24, r10, 1
	ctx.r[24].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[24].u64 = ctx.r[24].u32 as u64;
	// 821D7C40: 5537083C  slwi r23, r9, 1
	ctx.r[23].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[23].u64 = ctx.r[23].u32 as u64;
	// 821D7C44: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821D7C48: 3B9F0014  addi r28, r31, 0x14
	ctx.r[28].s64 = ctx.r[31].s64 + 20;
	// 821D7C4C: 7E99A378  mr r25, r20
	ctx.r[25].u64 = ctx.r[20].u64;
	// 821D7C50: 836BFA0C  lwz r27, -0x5f4(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1524 as u32) ) } as u64;
	// 821D7C54: 7F1EC040  cmplw cr6, r30, r24
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[24].u32, &mut ctx.xer);
	// 821D7C58: 4198005C  blt cr6, 0x821d7cb4
	if ctx.cr[6].lt {
	pc = 0x821D7CB4; continue 'dispatch;
	}
	// 821D7C5C: 7F1EB840  cmplw cr6, r30, r23
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[23].u32, &mut ctx.xer);
	// 821D7C60: 41980054  blt cr6, 0x821d7cb4
	if ctx.cr[6].lt {
	pc = 0x821D7CB4; continue 'dispatch;
	}
	// 821D7C64: 7EC9B378  mr r9, r22
	ctx.r[9].u64 = ctx.r[22].u64;
	// 821D7C68: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 821D7C6C: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 821D7C70: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821D7C74: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821D7C78: 389F0048  addi r4, r31, 0x48
	ctx.r[4].s64 = ctx.r[31].s64 + 72;
	// 821D7C7C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821D7C80: 48988F59  bl 0x82b60bd8
	ctx.lr = 0x821D7C84;
	sub_82B60BD8(ctx, base);
	// 821D7C84: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D7C88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7C8C: 419A000C  beq cr6, 0x821d7c98
	if ctx.cr[6].eq {
	pc = 0x821D7C98; continue 'dispatch;
	}
	// 821D7C90: 7F59D378  mr r25, r26
	ctx.r[25].u64 = ctx.r[26].u64;
	// 821D7C94: 48000014  b 0x821d7ca8
	pc = 0x821D7CA8; continue 'dispatch;
	// 821D7C98: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 821D7C9C: 419A0008  beq cr6, 0x821d7ca4
	if ctx.cr[6].eq {
	pc = 0x821D7CA4; continue 'dispatch;
	}
	// 821D7CA0: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 821D7CA4: 57DEF87E  srwi r30, r30, 1
	ctx.r[30].u32 = ctx.r[30].u32.wrapping_shr(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821D7CA8: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 821D7CAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7CB0: 419AFFA4  beq cr6, 0x821d7c54
	if ctx.cr[6].eq {
	pc = 0x821D7C54; continue 'dispatch;
	}
	// 821D7CB4: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 821D7CB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7CBC: 419A00E0  beq cr6, 0x821d7d9c
	if ctx.cr[6].eq {
	pc = 0x821D7D9C; continue 'dispatch;
	}
	// 821D7CC0: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D7CC4: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	// 821D7CC8: 92810074  stw r20, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[20].u32 ) };
	// 821D7CCC: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 821D7CD0: 83CB002C  lwz r30, 0x2c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D7CD4: 838B0028  lwz r28, 0x28(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D7CD8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821D7CDC: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 821D7CE0: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 821D7CE4: 419A0040  beq cr6, 0x821d7d24
	if ctx.cr[6].eq {
	pc = 0x821D7D24; continue 'dispatch;
	}
	// 821D7CE8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821D7CEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D7CF0: 7D60F028  lwarx r11, 0, r30
	// lwarx
	let ea = ctx.r[30].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821D7CF4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D7CF8: 7D60F12D  stwcx. r11, 0, r30
	// stwcx.
	let addr = ctx.r[30].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821D7CFC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D7D00: 4082FFE8  bne 0x821d7ce8
	if !ctx.cr[0].eq {
	pc = 0x821D7CE8; continue 'dispatch;
	}
	// 821D7D04: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D7D08: 4BFDFE11  bl 0x821b7b18
	ctx.lr = 0x821D7D0C;
	sub_821B7B18(ctx, base);
	// 821D7D0C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D7D10: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 821D7D14: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 821D7D18: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 821D7D1C: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 821D7D20: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D7D24: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821D7D28: 4BFDFDF1  bl 0x821b7b18
	ctx.lr = 0x821D7D2C;
	sub_821B7B18(ctx, base);
	// 821D7D2C: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 821D7D30: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821D7D34: 38FF0084  addi r7, r31, 0x84
	ctx.r[7].s64 = ctx.r[31].s64 + 132;
	// 821D7D38: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821D7D3C: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 821D7D40: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D7D44: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 821D7D48: 489948D1  bl 0x82b6c618
	ctx.lr = 0x821D7D4C;
	sub_82B6C618(ctx, base);
	// 821D7D4C: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 821D7D50: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D7D54: 4BFDFDC5  bl 0x821b7b18
	ctx.lr = 0x821D7D58;
	sub_821B7B18(ctx, base);
	// 821D7D58: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 821D7D5C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821D7D60: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821D7D64: 394BF9F0  addi r10, r11, -0x610
	ctx.r[10].s64 = ctx.r[11].s64 + -1552;
	// 821D7D68: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 821D7D6C: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 821D7D70: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7D74: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821D7D78: E8810078  ld r4, 0x78(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 821D7D7C: 4887B2C5  bl 0x82a53040
	ctx.lr = 0x821D7D80;
	sub_82A53040(ctx, base);
	// 821D7D80: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821D7D84: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 821D7D88: 81696E78  lwz r11, 0x6e78(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28280 as u32) ) } as u64;
	// 821D7D8C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D7D90: 91696E78  stw r11, 0x6e78(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28280 as u32), ctx.r[11].u32 ) };
	// 821D7D94: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821D7D98: 48AD1698  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
	// 821D7D9C: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 821D7DA0: 419A0230  beq cr6, 0x821d7fd0
	if ctx.cr[6].eq {
	pc = 0x821D7FD0; continue 'dispatch;
	}
	// 821D7DA4: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821D7DA8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821D7DAC: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 821D7DB0: 996A6E33  stb r11, 0x6e33(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28211 as u32), ctx.r[11].u8 ) };
	// 821D7DB4: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821D7DB8: 48AD1678  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
	// 821D7DBC: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 821D7DC0: 38E9FFFF  addi r7, r9, -1
	ctx.r[7].s64 = ctx.r[9].s64 + -1;
	// 821D7DC4: 815F0098  lwz r10, 0x98(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 821D7DC8: 809F0044  lwz r4, 0x44(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 821D7DCC: 7CCB5050  subf r6, r11, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D7DD0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821D7DD4: 7CC5FE70  srawi r5, r6, 0x1f
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[6].s32 >> 31) as i64;
	// 821D7DD8: 7CAA3038  and r10, r5, r6
	ctx.r[10].u64 = ctx.r[5].u64 & ctx.r[6].u64;
	// 821D7DDC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D7DE0: 7D633E70  srawi r3, r11, 7
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[11].s32 >> 7) as i64;
	// 821D7DE4: 7D630194  addze r11, r3
	tmp.s64 = ctx.r[3].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[3].u32);
	ctx.r[11].s64 = tmp.s64;
	// 821D7DE8: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 821D7DEC: 7D46FE70  srawi r6, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 821D7DF0: 7CC55038  and r5, r6, r10
	ctx.r[5].u64 = ctx.r[6].u64 & ctx.r[10].u64;
	// 821D7DF4: 7C655850  subf r3, r5, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 821D7DF8: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821D7DFC: 216B001F  subfic r11, r11, 0x1f
	ctx.xer.ca = ctx.r[11].u32 <= 31 as u32;
	ctx.r[11].s64 = (31 as i64) - ctx.r[11].s64;
	// 821D7E00: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 821D7E04: 7D47FE70  srawi r7, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 821D7E08: 7FA6FE70  srawi r6, r29, 0x1f
	ctx.xer.ca = (ctx.r[29].s32 < 0) && ((ctx.r[29].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[29].s32 >> 31) as i64;
	// 821D7E0C: 7CEA5038  and r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 & ctx.r[10].u64;
	// 821D7E10: 7CC5E838  and r5, r6, r29
	ctx.r[5].u64 = ctx.r[6].u64 & ctx.r[29].u64;
	// 821D7E14: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D7E18: 7D45E850  subf r10, r5, r29
	ctx.r[10].s64 = ctx.r[29].s64 - ctx.r[5].s64;
	// 821D7E1C: 7C6A5850  subf r3, r10, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D7E20: 7C67FE70  srawi r7, r3, 0x1f
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[3].s32 >> 31) as i64;
	// 821D7E24: 7CE71838  and r7, r7, r3
	ctx.r[7].u64 = ctx.r[7].u64 & ctx.r[3].u64;
	// 821D7E28: 7D475214  add r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 821D7E2C: 7D065630  sraw r6, r8, r10
	tmp.u32 = ctx.r[10].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[8].s32 >> tmp.u32) as i64;
	// 821D7E30: 7FC55630  sraw r5, r30, r10
	tmp.u32 = ctx.r[10].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[30].s32 < 0) && ((ctx.r[30].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[30].s32 >> tmp.u32) as i64;
	// 821D7E34: 7D085E30  sraw r8, r8, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> tmp.u32) as i64;
	// 821D7E38: 7CEA4850  subf r7, r10, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 821D7E3C: 7FC95E30  sraw r9, r30, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[30].s32 < 0) && ((ctx.r[30].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[30].s32 >> tmp.u32) as i64;
	// 821D7E40: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 821D7E44: 419A0014  beq cr6, 0x821d7e58
	if ctx.cr[6].eq {
	pc = 0x821D7E58; continue 'dispatch;
	}
	// 821D7E48: A1640020  lhz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D7E4C: A1440022  lhz r10, 0x22(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(34 as u32) ) } as u64;
	// 821D7E50: 5569083E  rotlwi r9, r11, 1
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 821D7E54: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 821D7E58: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821D7E5C: 9AC10067  stb r22, 0x67(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(103 as u32), ctx.r[22].u8 ) };
	// 821D7E60: 391F0014  addi r8, r31, 0x14
	ctx.r[8].s64 = ctx.r[31].s64 + 20;
	// 821D7E64: 92810054  stw r20, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[20].u32 ) };
	// 821D7E68: 3BBF0048  addi r29, r31, 0x48
	ctx.r[29].s64 = ctx.r[31].s64 + 72;
	// 821D7E6C: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 821D7E70: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 821D7E74: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D7E78: 806BFA0C  lwz r3, -0x5f4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1524 as u32) ) } as u64;
	// 821D7E7C: 4BFFFB3D  bl 0x821d79b8
	ctx.lr = 0x821D7E80;
	sub_821D79B8(ctx, base);
	// 821D7E80: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D7E84: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D7E88: 419A00E4  beq cr6, 0x821d7f6c
	if ctx.cr[6].eq {
	pc = 0x821D7F6C; continue 'dispatch;
	}
	// 821D7E8C: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D7E90: 7E9CA378  mr r28, r20
	ctx.r[28].u64 = ctx.r[20].u64;
	// 821D7E94: 92810074  stw r20, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[20].u32 ) };
	// 821D7E98: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 821D7E9C: 83CB002C  lwz r30, 0x2c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D7EA0: 836B0028  lwz r27, 0x28(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D7EA4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821D7EA8: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 821D7EAC: 93610078  stw r27, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[27].u32 ) };
	// 821D7EB0: 419A0040  beq cr6, 0x821d7ef0
	if ctx.cr[6].eq {
	pc = 0x821D7EF0; continue 'dispatch;
	}
	// 821D7EB4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821D7EB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D7EBC: 7D60F028  lwarx r11, 0, r30
	// lwarx
	let ea = ctx.r[30].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821D7EC0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D7EC4: 7D60F12D  stwcx. r11, 0, r30
	// stwcx.
	let addr = ctx.r[30].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821D7EC8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D7ECC: 4082FFE8  bne 0x821d7eb4
	if !ctx.cr[0].eq {
	pc = 0x821D7EB4; continue 'dispatch;
	}
	// 821D7ED0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D7ED4: 4BFDFC45  bl 0x821b7b18
	ctx.lr = 0x821D7ED8;
	sub_821B7B18(ctx, base);
	// 821D7ED8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D7EDC: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 821D7EE0: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 821D7EE4: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 821D7EE8: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 821D7EEC: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D7EF0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821D7EF4: 4BFDFC25  bl 0x821b7b18
	ctx.lr = 0x821D7EF8;
	sub_821B7B18(ctx, base);
	// 821D7EF8: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 821D7EFC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821D7F00: 38FF0084  addi r7, r31, 0x84
	ctx.r[7].s64 = ctx.r[31].s64 + 132;
	// 821D7F04: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821D7F08: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 821D7F0C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821D7F10: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 821D7F14: 48994705  bl 0x82b6c618
	ctx.lr = 0x821D7F18;
	sub_82B6C618(ctx, base);
	// 821D7F18: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 821D7F1C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D7F20: 4BFDFBF9  bl 0x821b7b18
	ctx.lr = 0x821D7F24;
	sub_821B7B18(ctx, base);
	// 821D7F24: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7F28: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821D7F2C: 419A0008  beq cr6, 0x821d7f34
	if ctx.cr[6].eq {
	pc = 0x821D7F34; continue 'dispatch;
	}
	// 821D7F30: 480451C9  bl 0x8221d0f8
	ctx.lr = 0x821D7F34;
	sub_8221D0F8(ctx, base);
	// 821D7F34: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 821D7F38: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821D7F3C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821D7F40: 386BF9F0  addi r3, r11, -0x610
	ctx.r[3].s64 = ctx.r[11].s64 + -1552;
	// 821D7F44: 90610078  stw r3, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 821D7F48: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7F4C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821D7F50: E8810078  ld r4, 0x78(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 821D7F54: 4887B0ED  bl 0x82a53040
	ctx.lr = 0x821D7F58;
	sub_82A53040(ctx, base);
	// 821D7F58: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821D7F5C: 816A6E78  lwz r11, 0x6e78(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28280 as u32) ) } as u64;
	// 821D7F60: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D7F64: 916A6E78  stw r11, 0x6e78(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28280 as u32), ctx.r[11].u32 ) };
	// 821D7F68: 48000018  b 0x821d7f80
	pc = 0x821D7F80; continue 'dispatch;
	// 821D7F6C: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 821D7F70: 419A0010  beq cr6, 0x821d7f80
	if ctx.cr[6].eq {
	pc = 0x821D7F80; continue 'dispatch;
	}
	// 821D7F74: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821D7F78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D7F7C: 996A6E33  stb r11, 0x6e33(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28211 as u32), ctx.r[11].u8 ) };
	// 821D7F80: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 821D7F84: 807F4364  lwz r3, 0x4364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(17252 as u32) ) } as u64;
	// 821D7F88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D7F8C: 419A003C  beq cr6, 0x821d7fc8
	if ctx.cr[6].eq {
	pc = 0x821D7FC8; continue 'dispatch;
	}
	// 821D7F90: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 821D7F94: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821D7F98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D7F9C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821D7FA0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D7FA4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821D7FA8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D7FAC: 4082FFE8  bne 0x821d7f94
	if !ctx.cr[0].eq {
	pc = 0x821D7F94; continue 'dispatch;
	}
	// 821D7FB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D7FB4: 409A0014  bne cr6, 0x821d7fc8
	if !ctx.cr[6].eq {
	pc = 0x821D7FC8; continue 'dispatch;
	}
	// 821D7FB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D7FBC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7FC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D7FC4: 4E800421  bctrl
	ctx.lr = 0x821D7FC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D7FC8: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 821D7FCC: 917F4364  stw r11, 0x4364(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(17252 as u32), ctx.r[11].u32 ) };
	// 821D7FD0: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 821D7FD4: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821D7FD8: 48AD1458  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D7FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D7FE0 size=172
    let mut pc: u32 = 0x821D7FE0;
    'dispatch: loop {
        match pc {
            0x821D7FE0 => {
    //   block [0x821D7FE0..0x821D808C)
	// 821D7FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D7FE4: 48AD1429  bl 0x82ca940c
	ctx.lr = 0x821D7FE8;
	sub_82CA93D0(ctx, base);
	// 821D7FE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D7FEC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821D7FF0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D7FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D7FF8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821D7FFC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821D8000: 48052BE1  bl 0x8222abe0
	ctx.lr = 0x821D8004;
	sub_8222ABE0(ctx, base);
	// 821D8004: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D8008: 3D60F0F0  lis r11, -0xf10
	ctx.r[11].s64 = -252706816;
	// 821D800C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821D8010: 616AF0F0  ori r10, r11, 0xf0f0
	ctx.r[10].u64 = ctx.r[11].u64 | 61680;
	// 821D8014: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821D8018: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821D801C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D8020: 48052BC1  bl 0x8222abe0
	ctx.lr = 0x821D8024;
	sub_8222ABE0(ctx, base);
	// 821D8024: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D8028: 419A000C  beq cr6, 0x821d8034
	if ctx.cr[6].eq {
	pc = 0x821D8034; continue 'dispatch;
	}
	// 821D802C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 821D8030: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821D8034: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 821D8038: 38800050  li r4, 0x50
	ctx.r[4].s64 = 80;
	// 821D803C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D8040: 48052BA1  bl 0x8222abe0
	ctx.lr = 0x821D8044;
	sub_8222ABE0(ctx, base);
	// 821D8044: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D8048: 419A0034  beq cr6, 0x821d807c
	if ctx.cr[6].eq {
	pc = 0x821D807C; continue 'dispatch;
	}
	// 821D804C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D8050: 39430010  addi r10, r3, 0x10
	ctx.r[10].s64 = ctx.r[3].s64 + 16;
	// 821D8054: 392B11A4  addi r9, r11, 0x11a4
	ctx.r[9].s64 = ctx.r[11].s64 + 4516;
	// 821D8058: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 821D805C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D8060: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 821D8064: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 821D8068: 48AD1419  bl 0x82ca9480
	ctx.lr = 0x821D806C;
	sub_82CA9480(ctx, base);
	// 821D806C: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D8070: 911E0000  stw r8, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821D8074: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D8078: 48AD13E4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821D807C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D8080: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821D8084: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D8088: 48AD13D4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D8090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D8090 size=208
    let mut pc: u32 = 0x821D8090;
    'dispatch: loop {
        match pc {
            0x821D8090 => {
    //   block [0x821D8090..0x821D8160)
	// 821D8090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D8094: 48AD1375  bl 0x82ca9408
	ctx.lr = 0x821D8098;
	sub_82CA93D0(ctx, base);
	// 821D8098: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821D809C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D80A0: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 821D80A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D80A8: 48050051  bl 0x822280f8
	ctx.lr = 0x821D80AC;
	sub_822280F8(ctx, base);
	// 821D80AC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821D80B0: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 821D80B4: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821D80B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D80BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821D80C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D80C4: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 821D80C8: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 821D80CC: 83C80004  lwz r30, 4(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D80D0: 83A80000  lwz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D80D4: 48050025  bl 0x822280f8
	ctx.lr = 0x821D80D8;
	sub_822280F8(ctx, base);
	// 821D80D8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D80DC: 4804F485  bl 0x82227560
	ctx.lr = 0x821D80E0;
	sub_82227560(ctx, base);
	// 821D80E0: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 821D80E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D80E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821D80EC: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D80F0: 48129E09  bl 0x82301ef8
	ctx.lr = 0x821D80F4;
	sub_82301EF8(ctx, base);
	// 821D80F4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 821D80F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D80FC: 88610051  lbz r3, 0x51(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 821D8100: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821D8104: 485FEDBD  bl 0x827d6ec0
	ctx.lr = 0x821D8108;
	sub_827D6EC0(ctx, base);
	// 821D8108: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821D810C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821D8110: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D8114: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D8118: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 821D811C: 4E800421  bctrl
	ctx.lr = 0x821D8120;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D8120: 7C6707B4  extsw r7, r3
	ctx.r[7].s64 = ctx.r[3].s32 as i64;
	// 821D8124: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D8128: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 821D812C: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 821D8130: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821D8134: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821D8138: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821D813C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821D8140: D1860000  stfs f12, 0(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821D8144: 90A60004  stw r5, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 821D8148: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D814C: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 821D8150: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 821D8154: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821D8158: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821D815C: 48AD12FC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D8160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D8160 size=128
    let mut pc: u32 = 0x821D8160;
    'dispatch: loop {
        match pc {
            0x821D8160 => {
    //   block [0x821D8160..0x821D81E0)
	// 821D8160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D8164: 48AD12A9  bl 0x82ca940c
	ctx.lr = 0x821D8168;
	sub_82CA93D0(ctx, base);
	// 821D8168: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D816C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 821D8170: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D8174: 4804FF85  bl 0x822280f8
	ctx.lr = 0x821D8178;
	sub_822280F8(ctx, base);
	// 821D8178: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821D817C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821D8180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D8184: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D8188: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D818C: 4804FF6D  bl 0x822280f8
	ctx.lr = 0x821D8190;
	sub_822280F8(ctx, base);
	// 821D8190: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D8194: 4804F3CD  bl 0x82227560
	ctx.lr = 0x821D8198;
	sub_82227560(ctx, base);
	// 821D8198: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D819C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D81A0: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 821D81A4: 4E800421  bctrl
	ctx.lr = 0x821D81A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D81A8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D81AC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D81B0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821D81B4: 7D470034  cntlzw r7, r10
	ctx.r[7].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 821D81B8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821D81BC: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 821D81C0: 68C50001  xori r5, r6, 1
	ctx.r[5].u64 = ctx.r[6].u64 ^ 1;
	// 821D81C4: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821D81C8: 90A90000  stw r5, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 821D81CC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D81D0: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 821D81D4: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 821D81D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D81DC: 48AD1280  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D81E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D81E0 size=428
    let mut pc: u32 = 0x821D81E0;
    'dispatch: loop {
        match pc {
            0x821D81E0 => {
    //   block [0x821D81E0..0x821D838C)
	// 821D81E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D81E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D81E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D81EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D81F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D81F4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D81F8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821D81FC: 419A017C  beq cr6, 0x821d8378
	if ctx.cr[6].eq {
	pc = 0x821D8378; continue 'dispatch;
	}
	// 821D8200: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D8204: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821D8208: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821D820C: 5528EFFE  rlwinm r8, r9, 0x1d, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 821D8210: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821D8214: 419A00DC  beq cr6, 0x821d82f0
	if ctx.cr[6].eq {
	pc = 0x821D82F0; continue 'dispatch;
	}
	// 821D8218: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D821C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D8220: 419A001C  beq cr6, 0x821d823c
	if ctx.cr[6].eq {
	pc = 0x821D823C; continue 'dispatch;
	}
	// 821D8224: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 821D8228: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D822C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D8230: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D8234: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D8238: 480000B4  b 0x821d82ec
	pc = 0x821D82EC; continue 'dispatch;
	// 821D823C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D8240: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821D8244: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D8248: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821D824C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D8250: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D8254: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D8258: 40810054  ble 0x821d82ac
	if !ctx.cr[0].gt {
	pc = 0x821D82AC; continue 'dispatch;
	}
	// 821D825C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D8260: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D8264: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D8268: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D826C: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 821D8270: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D8274: 41980008  blt cr6, 0x821d827c
	if ctx.cr[6].lt {
	pc = 0x821D827C; continue 'dispatch;
	}
	// 821D8278: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821D827C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D8280: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D8284: 419A0014  beq cr6, 0x821d8298
	if ctx.cr[6].eq {
	pc = 0x821D8298; continue 'dispatch;
	}
	// 821D8288: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D828C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D8290: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D8294: 4800000C  b 0x821d82a0
	pc = 0x821D82A0; continue 'dispatch;
	// 821D8298: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D829C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821D82A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D82A4: 4199FFB8  bgt cr6, 0x821d825c
	if ctx.cr[6].gt {
	pc = 0x821D825C; continue 'dispatch;
	}
	// 821D82A8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D82AC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D82B0: 419A0034  beq cr6, 0x821d82e4
	if ctx.cr[6].eq {
	pc = 0x821D82E4; continue 'dispatch;
	}
	// 821D82B4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D82B8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821D82BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D82C0: 41990008  bgt cr6, 0x821d82c8
	if ctx.cr[6].gt {
	pc = 0x821D82C8; continue 'dispatch;
	}
	// 821D82C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D82C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D82CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D82D0: 409A0014  bne cr6, 0x821d82e4
	if !ctx.cr[6].eq {
	pc = 0x821D82E4; continue 'dispatch;
	}
	// 821D82D4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D82D8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D82DC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D82E0: 48000008  b 0x821d82e8
	pc = 0x821D82E8; continue 'dispatch;
	// 821D82E4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D82E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D82EC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821D82F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D82F4: C02A0028  lfs f1, 0x28(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821D82F8: 48017D49  bl 0x821f0040
	ctx.lr = 0x821D82FC;
	sub_821F0040(ctx, base);
	// 821D82FC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D8300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D8304: 419A003C  beq cr6, 0x821d8340
	if ctx.cr[6].eq {
	pc = 0x821D8340; continue 'dispatch;
	}
	// 821D8308: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D830C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821D8310: 41980028  blt cr6, 0x821d8338
	if ctx.cr[6].lt {
	pc = 0x821D8338; continue 'dispatch;
	}
	// 821D8314: 419A0018  beq cr6, 0x821d832c
	if ctx.cr[6].eq {
	pc = 0x821D832C; continue 'dispatch;
	}
	// 821D8318: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 821D831C: 40980024  bge cr6, 0x821d8340
	if !ctx.cr[6].lt {
	pc = 0x821D8340; continue 'dispatch;
	}
	// 821D8320: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D8324: 4876A715  bl 0x82942a38
	ctx.lr = 0x821D8328;
	sub_82942A38(ctx, base);
	// 821D8328: 48000018  b 0x821d8340
	pc = 0x821D8340; continue 'dispatch;
	// 821D832C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D8330: 4876A4C9  bl 0x829427f8
	ctx.lr = 0x821D8334;
	sub_829427F8(ctx, base);
	// 821D8334: 4800000C  b 0x821d8340
	pc = 0x821D8340; continue 'dispatch;
	// 821D8338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D833C: 4BFE291D  bl 0x821bac58
	ctx.lr = 0x821D8340;
	sub_821BAC58(ctx, base);
	// 821D8340: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D8344: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821D8348: 419A0028  beq cr6, 0x821d8370
	if ctx.cr[6].eq {
	pc = 0x821D8370; continue 'dispatch;
	}
	// 821D834C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821D8350: 409A0028  bne cr6, 0x821d8378
	if !ctx.cr[6].eq {
	pc = 0x821D8378; continue 'dispatch;
	}
	// 821D8354: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D8358: 4BFD0221  bl 0x821a8578
	ctx.lr = 0x821D835C;
	sub_821A8578(ctx, base);
	// 821D835C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D8360: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D8364: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D8368: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D836C: 4E800020  blr
	return;
	// 821D8370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D8374: 4876A6C5  bl 0x82942a38
	ctx.lr = 0x821D8378;
	sub_82942A38(ctx, base);
	// 821D8378: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D837C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D8380: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D8384: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D8388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D8390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D8390 size=136
    let mut pc: u32 = 0x821D8390;
    'dispatch: loop {
        match pc {
            0x821D8390 => {
    //   block [0x821D8390..0x821D8418)
	// 821D8390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D8394: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D8398: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D839C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D83A0: C0030034  lfs f0, 0x34(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D83A4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821D83A8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821D83AC: 8063003C  lwz r3, 0x3c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 821D83B0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D83B4: EC200072  fmuls f1, f0, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 821D83B8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821D83BC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D83C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821D83C4: 481092E5  bl 0x822e16a8
	ctx.lr = 0x821D83C8;
	sub_822E16A8(ctx, base);
	// 821D83C8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821D83CC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821D83D0: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821D83D4: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D8418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D8418 size=240
    let mut pc: u32 = 0x821D8418;
    'dispatch: loop {
        match pc {
            0x821D8418 => {
    //   block [0x821D8418..0x821D8508)
	// 821D8418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D841C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D8420: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D8424: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D8428: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 821D842C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D8430: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D8434: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D8438: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821D843C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821D8440: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D8444: 4E800421  bctrl
	ctx.lr = 0x821D8448;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D8448: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821D844C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821D8450: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 821D8454: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 821D8458: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821D845C: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 821D8460: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D8464: 80C70020  lwz r6, 0x20(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D8468: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 821D846C: 4E800421  bctrl
	ctx.lr = 0x821D8470;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D8470: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D8474: 48027E6D  bl 0x822002e0
	ctx.lr = 0x821D8478;
	sub_822002E0(ctx, base);
	// 821D8478: 5465063E  clrlwi r5, r3, 0x18
	ctx.r[5].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D847C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D8480: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821D8484: 419A0018  beq cr6, 0x821d849c
	if ctx.cr[6].eq {
	pc = 0x821D849C; continue 'dispatch;
	}
	// 821D8488: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D848C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D8490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D8494: 4BFFFEFD  bl 0x821d8390
	ctx.lr = 0x821D8498;
	sub_821D8390(ctx, base);
	// 821D8498: 4800000C  b 0x821d84a4
	pc = 0x821D84A4; continue 'dispatch;
	// 821D849C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D84A0: 48063911  bl 0x8223bdb0
	ctx.lr = 0x821D84A4;
	sub_8223BDB0(ctx, base);
	// 821D84A4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821D84A8: 419A0044  beq cr6, 0x821d84ec
	if ctx.cr[6].eq {
	pc = 0x821D84EC; continue 'dispatch;
	}
	// 821D84AC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 821D84B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821D84B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D84B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821D84BC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821D84C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821D84C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D84C8: 4082FFE8  bne 0x821d84b0
	if !ctx.cr[0].eq {
	pc = 0x821D84B0; continue 'dispatch;
	}
	// 821D84CC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821D84D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D84D4: 409A0018  bne cr6, 0x821d84ec
	if !ctx.cr[6].eq {
	pc = 0x821D84EC; continue 'dispatch;
	}
	// 821D84D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D84DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D84E0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D84E4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D84E8: 4E800421  bctrl
	ctx.lr = 0x821D84EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D84EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D84F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D84F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D84F8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 821D84FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D8500: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D8504: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D8508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D8508 size=104
    let mut pc: u32 = 0x821D8508;
    'dispatch: loop {
        match pc {
            0x821D8508 => {
    //   block [0x821D8508..0x821D8570)
	// 821D8508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D850C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D8510: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D8514: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D8518: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D851C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D8520: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D8524: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D8528: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D852C: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821D8530: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D8534: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821D8538: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821D853C: 4E800421  bctrl
	ctx.lr = 0x821D8540;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D8540: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821D8544: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D8548: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D854C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D8570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D8570 size=20
    let mut pc: u32 = 0x821D8570;
    'dispatch: loop {
        match pc {
            0x821D8570 => {
    //   block [0x821D8570..0x821D8584)
	// 821D8570: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D8574: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D8588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D8588 size=208
    let mut pc: u32 = 0x821D8588;
    'dispatch: loop {
        match pc {
            0x821D8588 => {
    //   block [0x821D8588..0x821D8658)
	// 821D8588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D858C: 48AD0E79  bl 0x82ca9404
	ctx.lr = 0x821D8590;
	sub_82CA93D0(ctx, base);
	// 821D8590: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 821D8594: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821D8598: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D859C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D85A0: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821D85A4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D85A8: D3C100C4  stfs f30, 0xc4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 821D85AC: 3B60000F  li r27, 0xf
	ctx.r[27].s64 = 15;
	// 821D85B0: 3BFD1028  addi r31, r29, 0x1028
	ctx.r[31].s64 = ctx.r[29].s64 + 4136;
	// 821D85B4: 3BDD0F38  addi r30, r29, 0xf38
	ctx.r[30].s64 = ctx.r[29].s64 + 3896;
	// 821D85B8: C3EB9490  lfs f31, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821D85BC: 7F9D2050  subf r28, r29, r4
	ctx.r[28].s64 = ctx.r[4].s64 - ctx.r[29].s64;
	// 821D85C0: 7C1CFC2E  lfsx f0, r28, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D85C4: 7CDCF214  add r6, r28, r30
	ctx.r[6].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 821D85C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D85CC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821D85D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D85D4: EC20FFBC  fnmsubs f1, f0, f30, f31
	ctx.f[1].f64 = -(((ctx.f[0].f64 * ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 821D85D8: 48062D09  bl 0x8223b2e0
	ctx.lr = 0x821D85DC;
	sub_8223B2E0(ctx, base);
	// 821D85DC: D3FF0000  stfs f31, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821D85E0: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 821D85E4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821D85E8: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 821D85EC: 4082FFD4  bne 0x821d85c0
	if !ctx.cr[0].eq {
	pc = 0x821D85C0; continue 'dispatch;
	}
	// 821D85F0: 395D0C30  addi r10, r29, 0xc30
	ctx.r[10].s64 = ctx.r[29].s64 + 3120;
	// 821D85F4: 397D0010  addi r11, r29, 0x10
	ctx.r[11].s64 = ctx.r[29].s64 + 16;
	// 821D85F8: 392000C2  li r9, 0xc2
	ctx.r[9].s64 = 194;
	// 821D85FC: 390100C4  addi r8, r1, 0xc4
	ctx.r[8].s64 = ctx.r[1].s64 + 196;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D8658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D8658 size=2128
    let mut pc: u32 = 0x821D8658;
    'dispatch: loop {
        match pc {
            0x821D8658 => {
    //   block [0x821D8658..0x821D8EA8)
	// 821D8658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D865C: 48AD0D9D  bl 0x82ca93f8
	ctx.lr = 0x821D8660;
	sub_82CA93D0(ctx, base);
	// 821D8660: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 821D8664: 48AD5675  bl 0x82cadcd8
	ctx.lr = 0x821D8668;
	sub_82CADCA0(ctx, base);
	// 821D8668: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D8EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D8EA8 size=844
    let mut pc: u32 = 0x821D8EA8;
    'dispatch: loop {
        match pc {
            0x821D8EA8 => {
    //   block [0x821D8EA8..0x821D91F4)
	// 821D8EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D8EAC: 48AD0545  bl 0x82ca93f0
	ctx.lr = 0x821D8EB0;
	sub_82CA93D0(ctx, base);
	// 821D8EB0: DBC1FF98  stfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 821D8EB4: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 821D8EB8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D8EBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D8EC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D8EC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D8EC8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D8ECC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D8ED0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D8ED4: 4E800421  bctrl
	ctx.lr = 0x821D8ED8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D8ED8: 2F030006  cmpwi cr6, r3, 6
	ctx.cr[6].compare_i32(ctx.r[3].s32, 6, &mut ctx.xer);
	// 821D8EDC: 419A000C  beq cr6, 0x821d8ee8
	if ctx.cr[6].eq {
	pc = 0x821D8EE8; continue 'dispatch;
	}
	// 821D8EE0: 2F030024  cmpwi cr6, r3, 0x24
	ctx.cr[6].compare_i32(ctx.r[3].s32, 36, &mut ctx.xer);
	// 821D8EE4: 409A0300  bne cr6, 0x821d91e4
	if !ctx.cr[6].eq {
	pc = 0x821D91E4; continue 'dispatch;
	}
	// 821D8EE8: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 821D8EEC: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 821D8EF0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D8EF4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821D8EF8: 419A000C  beq cr6, 0x821d8f04
	if ctx.cr[6].eq {
	pc = 0x821D8F04; continue 'dispatch;
	}
	// 821D8EFC: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 821D8F00: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 821D8F04: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D8F08: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 821D8F0C: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D8F10: 915F00B0  stw r10, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 821D8F14: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D8F18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D8F1C: 409A0024  bne cr6, 0x821d8f40
	if !ctx.cr[6].eq {
	pc = 0x821D8F40; continue 'dispatch;
	}
	// 821D8F20: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D8F24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D8F28: 419A0008  beq cr6, 0x821d8f30
	if ctx.cr[6].eq {
	pc = 0x821D8F30; continue 'dispatch;
	}
	// 821D8F2C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D8F30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D8F34: 409A000C  bne cr6, 0x821d8f40
	if !ctx.cr[6].eq {
	pc = 0x821D8F40; continue 'dispatch;
	}
	// 821D8F38: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821D8F3C: 48000054  b 0x821d8f90
	pc = 0x821D8F90; continue 'dispatch;
	// 821D8F40: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D8F44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D8F48: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821D8F4C: 419A0024  beq cr6, 0x821d8f70
	if ctx.cr[6].eq {
	pc = 0x821D8F70; continue 'dispatch;
	}
	// 821D8F50: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 821D8F54: 419A000C  beq cr6, 0x821d8f60
	if ctx.cr[6].eq {
	pc = 0x821D8F60; continue 'dispatch;
	}
	// 821D8F58: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 821D8F5C: 409A0024  bne cr6, 0x821d8f80
	if !ctx.cr[6].eq {
	pc = 0x821D8F80; continue 'dispatch;
	}
	// 821D8F60: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D8F64: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	// 821D8F68: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D8F6C: 48000014  b 0x821d8f80
	pc = 0x821D8F80; continue 'dispatch;
	// 821D8F70: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D8F74: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D8F78: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821D8F7C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D8F80: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 821D8F84: 7D6AFE70  srawi r10, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 821D8F88: 7D495838  and r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 & ctx.r[11].u64;
	// 821D8F8C: 7D4900D0  neg r10, r9
	ctx.r[10].s64 = -ctx.r[9].s64;
	// 821D8F90: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D8F94: 915F00F8  stw r10, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[10].u32 ) };
	// 821D8F98: 3BBE0020  addi r29, r30, 0x20
	ctx.r[29].s64 = ctx.r[30].s64 + 32;
	// 821D8F9C: 3B8B92D4  addi r28, r11, -0x6d2c
	ctx.r[28].s64 = ctx.r[11].s64 + -27948;
	// 821D8FA0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821D8FA4: 3B7D0010  addi r27, r29, 0x10
	ctx.r[27].s64 = ctx.r[29].s64 + 16;
	// 821D8FA8: 3B5D0004  addi r26, r29, 4
	ctx.r[26].s64 = ctx.r[29].s64 + 4;
	// 821D8FAC: 397F0050  addi r11, r31, 0x50
	ctx.r[11].s64 = ctx.r[31].s64 + 80;
	// 821D8FB0: C3FC01B0  lfs f31, 0x1b0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(432 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821D8FB4: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 821D8FB8: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821D8FBC: 3B1D000C  addi r24, r29, 0xc
	ctx.r[24].s64 = ctx.r[29].s64 + 12;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D91F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D91F8 size=12
    let mut pc: u32 = 0x821D91F8;
    'dispatch: loop {
        match pc {
            0x821D91F8 => {
    //   block [0x821D91F8..0x821D9204)
	// 821D91F8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821D91FC: 386BC7F0  addi r3, r11, -0x3810
	ctx.r[3].s64 = ctx.r[11].s64 + -14352;
	// 821D9200: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D9208 size=100
    let mut pc: u32 = 0x821D9208;
    'dispatch: loop {
        match pc {
            0x821D9208 => {
    //   block [0x821D9208..0x821D926C)
	// 821D9208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D920C: 48AD0201  bl 0x82ca940c
	ctx.lr = 0x821D9210;
	sub_82CA93D0(ctx, base);
	// 821D9210: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9214: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D9218: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D921C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D9220: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9224: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D9228: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821D922C: 4E800421  bctrl
	ctx.lr = 0x821D9230;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D9230: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9234: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D9238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D923C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D9240: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821D9244: 4E800421  bctrl
	ctx.lr = 0x821D9248;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D9248: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821D924C: 409A0014  bne cr6, 0x821d9260
	if !ctx.cr[6].eq {
	pc = 0x821D9260; continue 'dispatch;
	}
	// 821D9250: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D9254: C01E0008  lfs f0, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D9258: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821D925C: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 821D9260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D9264: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D9268: 48AD01F4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9270 size=916
    let mut pc: u32 = 0x821D9270;
    'dispatch: loop {
        match pc {
            0x821D9270 => {
    //   block [0x821D9270..0x821D9604)
	// 821D9270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9274: 48AD0189  bl 0x82ca93fc
	ctx.lr = 0x821D9278;
	sub_82CA93D0(ctx, base);
	// 821D9278: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D927C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821D9280: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821D9284: 387C0028  addi r3, r28, 0x28
	ctx.r[3].s64 = ctx.r[28].s64 + 40;
	// 821D9288: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 821D928C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821D9290: 4BFD9269  bl 0x821b24f8
	ctx.lr = 0x821D9294;
	sub_821B24F8(ctx, base);
	// 821D9294: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821D9298: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821D929C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821D92A0: 419A0008  beq cr6, 0x821d92a8
	if ctx.cr[6].eq {
	pc = 0x821D92A8; continue 'dispatch;
	}
	// 821D92A4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821D92A8: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D92AC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821D92B0: 8145002C  lwz r10, 0x2c(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D92B4: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 821D92B8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D92BC: 419A00E8  beq cr6, 0x821d93a4
	if ctx.cr[6].eq {
	pc = 0x821D93A4; continue 'dispatch;
	}
	// 821D92C0: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D92C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D92C8: 419A0020  beq cr6, 0x821d92e8
	if ctx.cr[6].eq {
	pc = 0x821D92E8; continue 'dispatch;
	}
	// 821D92CC: 894B005B  lbz r10, 0x5b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(91 as u32) ) } as u64;
	// 821D92D0: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D92D4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D92D8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D92DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821D92E0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D92E4: 480000C4  b 0x821d93a8
	pc = 0x821D93A8; continue 'dispatch;
	// 821D92E8: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D92EC: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D92F0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821D92F4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D92F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D92FC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D9300: 40810054  ble 0x821d9354
	if !ctx.cr[0].gt {
	pc = 0x821D9354; continue 'dispatch;
	}
	// 821D9304: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D9308: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D930C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D9310: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9314: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 821D9318: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D931C: 41980008  blt cr6, 0x821d9324
	if ctx.cr[6].lt {
	pc = 0x821D9324; continue 'dispatch;
	}
	// 821D9320: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821D9324: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D9328: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D932C: 419A0014  beq cr6, 0x821d9340
	if ctx.cr[6].eq {
	pc = 0x821D9340; continue 'dispatch;
	}
	// 821D9330: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D9334: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D9338: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D933C: 4800000C  b 0x821d9348
	pc = 0x821D9348; continue 'dispatch;
	// 821D9340: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D9344: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821D9348: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D934C: 4199FFB8  bgt cr6, 0x821d9304
	if ctx.cr[6].gt {
	pc = 0x821D9304; continue 'dispatch;
	}
	// 821D9350: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D9354: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D9358: 419A003C  beq cr6, 0x821d9394
	if ctx.cr[6].eq {
	pc = 0x821D9394; continue 'dispatch;
	}
	// 821D935C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9360: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 821D9364: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D9368: 41990008  bgt cr6, 0x821d9370
	if ctx.cr[6].gt {
	pc = 0x821D9370; continue 'dispatch;
	}
	// 821D936C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821D9370: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D9374: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D9378: 409A001C  bne cr6, 0x821d9394
	if !ctx.cr[6].eq {
	pc = 0x821D9394; continue 'dispatch;
	}
	// 821D937C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D9380: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821D9384: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D9388: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D938C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9390: 48000018  b 0x821d93a8
	pc = 0x821D93A8; continue 'dispatch;
	// 821D9394: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D9398: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821D939C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D93A0: 48000008  b 0x821d93a8
	pc = 0x821D93A8; continue 'dispatch;
	// 821D93A4: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 821D93A8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821D93AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D93B0: 419A012C  beq cr6, 0x821d94dc
	if ctx.cr[6].eq {
	pc = 0x821D94DC; continue 'dispatch;
	}
	// 821D93B4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821D93B8: 4803B741  bl 0x82214af8
	ctx.lr = 0x821D93BC;
	sub_82214AF8(ctx, base);
	// 821D93BC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D93C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D93C4: 409A0118  bne cr6, 0x821d94dc
	if !ctx.cr[6].eq {
	pc = 0x821D94DC; continue 'dispatch;
	}
	// 821D93C8: 81650028  lwz r11, 0x28(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D93CC: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821D93D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D93D4: 409A0108  bne cr6, 0x821d94dc
	if !ctx.cr[6].eq {
	pc = 0x821D94DC; continue 'dispatch;
	}
	// 821D93D8: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D93DC: 397C0048  addi r11, r28, 0x48
	ctx.r[11].s64 = ctx.r[28].s64 + 72;
	// 821D93E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D93E4: 419A0040  beq cr6, 0x821d9424
	if ctx.cr[6].eq {
	pc = 0x821D9424; continue 'dispatch;
	}
	// 821D93E8: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D93EC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821D93F0: 419A0034  beq cr6, 0x821d9424
	if ctx.cr[6].eq {
	pc = 0x821D9424; continue 'dispatch;
	}
	// 821D93F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D93F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D93FC: 409A0010  bne cr6, 0x821d940c
	if !ctx.cr[6].eq {
	pc = 0x821D940C; continue 'dispatch;
	}
	// 821D9400: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821D9404: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 821D9408: 48000008  b 0x821d9410
	pc = 0x821D9410; continue 'dispatch;
	// 821D940C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9410: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821D9414: 480D05D5  bl 0x822a99e8
	ctx.lr = 0x821D9418;
	sub_822A99E8(ctx, base);
	// 821D9418: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D941C: 419A0008  beq cr6, 0x821d9424
	if ctx.cr[6].eq {
	pc = 0x821D9424; continue 'dispatch;
	}
	// 821D9420: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821D9424: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821D9428: 419A0094  beq cr6, 0x821d94bc
	if ctx.cr[6].eq {
	pc = 0x821D94BC; continue 'dispatch;
	}
	// 821D942C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 821D9430: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D9434: 389C0044  addi r4, r28, 0x44
	ctx.r[4].s64 = ctx.r[28].s64 + 68;
	// 821D9438: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821D943C: 4867BFE5  bl 0x82855420
	ctx.lr = 0x821D9440;
	sub_82855420(ctx, base);
	// 821D9440: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D9444: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821D9448: 409A0088  bne cr6, 0x821d94d0
	if !ctx.cr[6].eq {
	pc = 0x821D94D0; continue 'dispatch;
	}
	// 821D944C: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 821D9450: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D9454: 419A007C  beq cr6, 0x821d94d0
	if ctx.cr[6].eq {
	pc = 0x821D94D0; continue 'dispatch;
	}
	// 821D9458: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D945C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821D9460: 3BCB0E20  addi r30, r11, 0xe20
	ctx.r[30].s64 = ctx.r[11].s64 + 3616;
	// 821D9464: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D9468: 480C1D51  bl 0x8229b1b8
	ctx.lr = 0x821D946C;
	sub_8229B1B8(ctx, base);
	// 821D946C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D9470: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D9474: 419A005C  beq cr6, 0x821d94d0
	if ctx.cr[6].eq {
	pc = 0x821D94D0; continue 'dispatch;
	}
	// 821D9478: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D947C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821D9480: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D9484: 48053A4D  bl 0x8222ced0
	ctx.lr = 0x821D9488;
	sub_8222CED0(ctx, base);
	// 821D9488: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821D948C: 419A0038  beq cr6, 0x821d94c4
	if ctx.cr[6].eq {
	pc = 0x821D94C4; continue 'dispatch;
	}
	// 821D9490: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 821D9494: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D9498: 389C0044  addi r4, r28, 0x44
	ctx.r[4].s64 = ctx.r[28].s64 + 68;
	// 821D949C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D94A0: 4867BF81  bl 0x82855420
	ctx.lr = 0x821D94A4;
	sub_82855420(ctx, base);
	// 821D94A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D94A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D94AC: 4803B92D  bl 0x82214dd8
	ctx.lr = 0x821D94B0;
	sub_82214DD8(ctx, base);
	// 821D94B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D94B4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821D94B8: 48ACFF94  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 821D94BC: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 821D94C0: 4BFFFF8C  b 0x821d944c
	pc = 0x821D944C; continue 'dispatch;
	// 821D94C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D94C8: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 821D94CC: 4803B90D  bl 0x82214dd8
	ctx.lr = 0x821D94D0;
	sub_82214DD8(ctx, base);
	// 821D94D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D94D4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821D94D8: 48ACFF74  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 821D94DC: 38A00009  li r5, 9
	ctx.r[5].s64 = 9;
	// 821D94E0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821D94E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D94E8: 4805CCF1  bl 0x822361d8
	ctx.lr = 0x821D94EC;
	sub_822361D8(ctx, base);
	// 821D94EC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D94F0: 813C0018  lwz r9, 0x18(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D94F4: 397C0014  addi r11, r28, 0x14
	ctx.r[11].s64 = ctx.r[28].s64 + 20;
	// 821D94F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D94FC: 419A000C  beq cr6, 0x821d9508
	if ctx.cr[6].eq {
	pc = 0x821D9508; continue 'dispatch;
	}
	// 821D9500: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D9504: 419A0008  beq cr6, 0x821d950c
	if ctx.cr[6].eq {
	pc = 0x821D950C; continue 'dispatch;
	}
	// 821D9508: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D950C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D9510: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821D9514: 419A0054  beq cr6, 0x821d9568
	if ctx.cr[6].eq {
	pc = 0x821D9568; continue 'dispatch;
	}
	// 821D9518: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D951C: 409A0008  bne cr6, 0x821d9524
	if !ctx.cr[6].eq {
	pc = 0x821D9524; continue 'dispatch;
	}
	// 821D9520: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D9524: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9528: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D952C: 409A0008  bne cr6, 0x821d9534
	if !ctx.cr[6].eq {
	pc = 0x821D9534; continue 'dispatch;
	}
	// 821D9530: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D9534: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D9538: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D953C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D9540: 409A0010  bne cr6, 0x821d9550
	if !ctx.cr[6].eq {
	pc = 0x821D9550; continue 'dispatch;
	}
	// 821D9544: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821D9548: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 821D954C: 48000008  b 0x821d9554
	pc = 0x821D9554; continue 'dispatch;
	// 821D9550: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9554: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821D9558: 480D0491  bl 0x822a99e8
	ctx.lr = 0x821D955C;
	sub_822A99E8(ctx, base);
	// 821D955C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D9560: 419A0008  beq cr6, 0x821d9568
	if ctx.cr[6].eq {
	pc = 0x821D9568; continue 'dispatch;
	}
	// 821D9564: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821D9568: 807C0020  lwz r3, 0x20(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D956C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D9570: 419A002C  beq cr6, 0x821d959c
	if ctx.cr[6].eq {
	pc = 0x821D959C; continue 'dispatch;
	}
	// 821D9574: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9578: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821D957C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821D9580: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821D9584: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9588: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D958C: 4E800421  bctrl
	ctx.lr = 0x821D9590;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D9590: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D9594: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821D9598: 409A0060  bne cr6, 0x821d95f8
	if !ctx.cr[6].eq {
	pc = 0x821D95F8; continue 'dispatch;
	}
	// 821D959C: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 821D95A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D95A4: 419A0054  beq cr6, 0x821d95f8
	if ctx.cr[6].eq {
	pc = 0x821D95F8; continue 'dispatch;
	}
	// 821D95A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D95AC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821D95B0: 3BEB0E20  addi r31, r11, 0xe20
	ctx.r[31].s64 = ctx.r[11].s64 + 3616;
	// 821D95B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D95B8: 480C1C01  bl 0x8229b1b8
	ctx.lr = 0x821D95BC;
	sub_8229B1B8(ctx, base);
	// 821D95BC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D95C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D95C4: 419A0034  beq cr6, 0x821d95f8
	if ctx.cr[6].eq {
	pc = 0x821D95F8; continue 'dispatch;
	}
	// 821D95C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D95CC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821D95D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D95D4: 480538FD  bl 0x8222ced0
	ctx.lr = 0x821D95D8;
	sub_8222CED0(ctx, base);
	// 821D95D8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821D95DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D95E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821D95E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821D95E8: 4BFFFC89  bl 0x821d9270
	ctx.lr = 0x821D95EC;
	sub_821D9270(ctx, base);
	// 821D95EC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D95F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D95F4: 4803B7E5  bl 0x82214dd8
	ctx.lr = 0x821D95F8;
	sub_82214DD8(ctx, base);
	// 821D95F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D95FC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821D9600: 48ACFE4C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9608 size=248
    let mut pc: u32 = 0x821D9608;
    'dispatch: loop {
        match pc {
            0x821D9608 => {
    //   block [0x821D9608..0x821D9700)
	// 821D9608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D960C: 48ACFDF5  bl 0x82ca9400
	ctx.lr = 0x821D9610;
	sub_82CA93D0(ctx, base);
	// 821D9610: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9614: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821D9618: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D961C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821D9620: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 821D9624: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 821D9628: 817D002C  lwz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D962C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D9630: 409A0038  bne cr6, 0x821d9668
	if !ctx.cr[6].eq {
	pc = 0x821D9668; continue 'dispatch;
	}
	// 821D9634: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9638: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D963C: 837C6D9C  lwz r27, 0x6d9c(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28060 as u32) ) } as u64;
	// 821D9640: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821D9644: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9648: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821D964C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821D9650: 4E800421  bctrl
	ctx.lr = 0x821D9654;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D9654: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821D9658: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9700 size=128
    let mut pc: u32 = 0x821D9700;
    'dispatch: loop {
        match pc {
            0x821D9700 => {
    //   block [0x821D9700..0x821D9780)
	// 821D9700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D9708: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D970C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D9710: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9714: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D9718: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D971C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821D9720: 392B0DC0  addi r9, r11, 0xdc0
	ctx.r[9].s64 = ctx.r[11].s64 + 3520;
	// 821D9724: 386A6354  addi r3, r10, 0x6354
	ctx.r[3].s64 = ctx.r[10].s64 + 25428;
	// 821D9728: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D972C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D9730: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D9734: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D9738: 480001F9  bl 0x821d9930
	ctx.lr = 0x821D973C;
	sub_821D9930(ctx, base);
	// 821D973C: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 821D9740: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821D9744: 38C80FD0  addi r6, r8, 0xfd0
	ctx.r[6].s64 = ctx.r[8].s64 + 4048;
	// 821D9748: 57C507FE  clrlwi r5, r30, 0x1f
	ctx.r[5].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 821D974C: 90FF0010  stw r7, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 821D9750: 90DF0000  stw r6, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 821D9754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D9758: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821D975C: 419A000C  beq cr6, 0x821d9768
	if ctx.cr[6].eq {
	pc = 0x821D9768; continue 'dispatch;
	}
	// 821D9760: 480425D9  bl 0x8221bd38
	ctx.lr = 0x821D9764;
	sub_8221BD38(ctx, base);
	// 821D9764: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D9768: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D976C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D9770: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D9774: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D9778: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D977C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9780 size=312
    let mut pc: u32 = 0x821D9780;
    'dispatch: loop {
        match pc {
            0x821D9780 => {
    //   block [0x821D9780..0x821D98B8)
	// 821D9780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D9788: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D978C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821D9790: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 821D9794: 48E2D241  bl 0x830069d4
	ctx.lr = 0x821D9798;
	sub_83006760(ctx, base);
	// 821D9798: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D979C: 1002084A  vsubfp v0, v2, v1
	ctx.fpscr.enable_flush_mode_unconditional();
	for i in 0..4 {
		ctx.v[0].f32[i] = ctx.v[2].f32[i] - ctx.v[1].f32[i];
	}
	// 821D97A0: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821D97A4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D98B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D98B8 size=76
    let mut pc: u32 = 0x821D98B8;
    'dispatch: loop {
        match pc {
            0x821D98B8 => {
    //   block [0x821D98B8..0x821D9904)
	// 821D98B8: 39630070  addi r11, r3, 0x70
	ctx.r[11].s64 = ctx.r[3].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D9908 size=32
    let mut pc: u32 = 0x821D9908;
    'dispatch: loop {
        match pc {
            0x821D9908 => {
    //   block [0x821D9908..0x821D9928)
	// 821D9908: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D990C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821D9910: 409A0018  bne cr6, 0x821d9928
	if !ctx.cr[6].eq {
		sub_821D9928(ctx, base);
		return;
	}
	// 821D9914: 80630038  lwz r3, 0x38(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 821D9918: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D991C: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821D9920: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D9924: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D9928 size=8
    let mut pc: u32 = 0x821D9928;
    'dispatch: loop {
        match pc {
            0x821D9928 => {
    //   block [0x821D9928..0x821D9930)
	// 821D9928: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821D992C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9930 size=360
    let mut pc: u32 = 0x821D9930;
    'dispatch: loop {
        match pc {
            0x821D9930 => {
    //   block [0x821D9930..0x821D9A98)
	// 821D9930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9934: 48ACFACD  bl 0x82ca9400
	ctx.lr = 0x821D9938;
	sub_82CA93D0(ctx, base);
	// 821D9938: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D993C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821D9940: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821D9944: 3BEB6354  addi r31, r11, 0x6354
	ctx.r[31].s64 = ctx.r[11].s64 + 25428;
	// 821D9948: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821D994C: 934100CC  stw r26, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[26].u32 ) };
	// 821D9950: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D9954: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821D9958: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 821D995C: 48026E15  bl 0x82200770
	ctx.lr = 0x821D9960;
	sub_82200770(ctx, base);
	// 821D9960: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9964: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D9968: 395B0007  addi r10, r27, 7
	ctx.r[10].s64 = ctx.r[27].s64 + 7;
	// 821D996C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821D9970: 7D2B2850  subf r9, r11, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821D9974: 555DE8FE  srwi r29, r10, 3
	ctx.r[29].u32 = ctx.r[10].u32.wrapping_shr(3);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 821D9978: 7D282670  srawi r8, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 821D997C: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821D9980: 41980080  blt cr6, 0x821d9a00
	if ctx.cr[6].lt {
	pc = 0x821D9A00; continue 'dispatch;
	}
	// 821D9984: 7D2B2850  subf r9, r11, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821D9988: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 821D998C: 395D0001  addi r10, r29, 1
	ctx.r[10].s64 = ctx.r[29].s64 + 1;
	// 821D9990: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 821D9994: 7D282670  srawi r8, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 821D9998: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 821D999C: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D99A0: 4098002C  bge cr6, 0x821d99cc
	if !ctx.cr[6].lt {
	pc = 0x821D99CC; continue 'dispatch;
	}
	// 821D99A4: 7D6B2850  subf r11, r11, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821D99A8: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 821D99AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D99B0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821D99B4: 7D692670  srawi r9, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 821D99B8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D99BC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 821D99C0: 7CA95050  subf r5, r9, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821D99C4: 48999F1D  bl 0x82b738e0
	ctx.lr = 0x821D99C8;
	sub_82B738E0(ctx, base);
	// 821D99C8: 48000034  b 0x821d99fc
	pc = 0x821D99FC; continue 'dispatch;
	// 821D99CC: 7D2B2850  subf r9, r11, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821D99D0: 7D282670  srawi r8, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 821D99D4: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821D99D8: 40980028  bge cr6, 0x821d9a00
	if !ctx.cr[6].lt {
	pc = 0x821D9A00; continue 'dispatch;
	}
	// 821D99DC: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D99E0: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D99E4: 7F1E2840  cmplw cr6, r30, r5
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821D99E8: 419A0018  beq cr6, 0x821d9a00
	if ctx.cr[6].eq {
	pc = 0x821D9A00; continue 'dispatch;
	}
	// 821D99EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D99F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D99F4: 4894E365  bl 0x82b27d58
	ctx.lr = 0x821D99F8;
	sub_82B27D58(ctx, base);
	// 821D99F8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821D99FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9A00: 57AA2036  slwi r10, r29, 4
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D9A04: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D9A08: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9A0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D9A10: 409A000C  bne cr6, 0x821d9a1c
	if !ctx.cr[6].eq {
	pc = 0x821D9A1C; continue 'dispatch;
	}
	// 821D9A14: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 821D9A18: 48000010  b 0x821d9a28
	pc = 0x821D9A28; continue 'dispatch;
	// 821D9A1C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D9A20: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D9A24: 7D291670  srawi r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 821D9A28: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D9A2C: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D9A30: 7D481670  srawi r8, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 821D9A34: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821D9A38: 40980014  bge cr6, 0x821d9a4c
	if !ctx.cr[6].lt {
	pc = 0x821D9A4C; continue 'dispatch;
	}
	// 821D9A3C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 821D9A40: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 821D9A44: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821D9A48: 4800001C  b 0x821d9a64
	pc = 0x821D9A64; continue 'dispatch;
	// 821D9A4C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821D9A50: 38C100CC  addi r6, r1, 0xcc
	ctx.r[6].s64 = ctx.r[1].s64 + 204;
	// 821D9A54: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821D9A58: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821D9A5C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D9A60: 489A67E1  bl 0x82b80240
	ctx.lr = 0x821D9A64;
	sub_82B80240(ctx, base);
	// 821D9A64: 576A083C  slwi r10, r27, 1
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D9A68: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821D9A6C: 88E1005C  lbz r7, 0x5c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821D9A70: 7D1B5214  add r8, r27, r10
	ctx.r[8].u64 = ctx.r[27].u64 + ctx.r[10].u64;
	// 821D9A74: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D9A78: 55062036  slwi r6, r8, 4
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821D9A7C: 7D665850  subf r11, r6, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 821D9A80: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 821D9A84: 419A000C  beq cr6, 0x821d9a90
	if ctx.cr[6].eq {
	pc = 0x821D9A90; continue 'dispatch;
	}
	// 821D9A88: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821D9A8C: 490DFEC9  bl 0x832b9954
	ctx.lr = 0x821D9A90;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 821D9A90: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821D9A94: 48ACF9BC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9A98 size=340
    let mut pc: u32 = 0x821D9A98;
    'dispatch: loop {
        match pc {
            0x821D9A98 => {
    //   block [0x821D9A98..0x821D9BEC)
	// 821D9A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9A9C: 48ACF959  bl 0x82ca93f4
	ctx.lr = 0x821D9AA0;
	sub_82CA93D0(ctx, base);
	// 821D9AA0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9AA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D9AA8: 4BFDD5B9  bl 0x821b7060
	ctx.lr = 0x821D9AAC;
	sub_821B7060(ctx, base);
	// 821D9AAC: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 821D9AB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D9AB4: 809EF848  lwz r4, -0x7b8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1976 as u32) ) } as u64;
	// 821D9AB8: 480126E1  bl 0x821ec198
	ctx.lr = 0x821D9ABC;
	sub_821EC198(ctx, base);
	// 821D9ABC: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821D9AC0: 807EF848  lwz r3, -0x7b8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1976 as u32) ) } as u64;
	// 821D9AC4: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821D9AC8: 396B2390  addi r11, r11, 0x2390
	ctx.r[11].s64 = ctx.r[11].s64 + 9104;
	// 821D9ACC: 38AA7E70  addi r5, r10, 0x7e70
	ctx.r[5].s64 = ctx.r[10].s64 + 32368;
	// 821D9AD0: 3C808349  lis r4, -0x7cb7
	ctx.r[4].s64 = -2092367872;
	// 821D9AD4: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 821D9AD8: 3BEB2008  addi r31, r11, 0x2008
	ctx.r[31].s64 = ctx.r[11].s64 + 8200;
	// 821D9ADC: 3B08A978  addi r24, r8, -0x5688
	ctx.r[24].s64 = ctx.r[8].s64 + -22152;
	// 821D9AE0: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821D9AE4: 3F608332  lis r27, -0x7cce
	ctx.r[27].s64 = -2093875200;
	// 821D9AE8: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 821D9AEC: 3FC08332  lis r30, -0x7cce
	ctx.r[30].s64 = -2093875200;
	// 821D9AF0: 3FA08332  lis r29, -0x7cce
	ctx.r[29].s64 = -2093875200;
	// 821D9AF4: 3F808332  lis r28, -0x7cce
	ctx.r[28].s64 = -2093875200;
	// 821D9AF8: 3F408332  lis r26, -0x7cce
	ctx.r[26].s64 = -2093875200;
	// 821D9AFC: 3F208332  lis r25, -0x7cce
	ctx.r[25].s64 = -2093875200;
	// 821D9B00: 3BDEA9CC  addi r30, r30, -0x5634
	ctx.r[30].s64 = ctx.r[30].s64 + -22068;
	// 821D9B04: 3BBDA9A8  addi r29, r29, -0x5658
	ctx.r[29].s64 = ctx.r[29].s64 + -22104;
	// 821D9B08: 3B9CAA38  addi r28, r28, -0x55c8
	ctx.r[28].s64 = ctx.r[28].s64 + -21960;
	// 821D9B0C: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 821D9B10: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 821D9B14: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821D9B18: 89296E22  lbz r9, 0x6e22(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(28194 as u32) ) } as u64;
	// 821D9B1C: 55471838  slwi r7, r10, 3
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821D9B20: 89446E23  lbz r10, 0x6e23(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(28195 as u32) ) } as u64;
	// 821D9B24: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 821D9B28: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821D9B2C: 9921007C  stb r9, 0x7c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[9].u8 ) };
	// 821D9B30: 7CA7592E  stwx r5, r7, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 821D9B34: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821D9B38: 80CB2000  lwz r6, 0x2000(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821D9B3C: 810B400C  lwz r8, 0x400c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821D9B40: 55171838  slwi r23, r8, 3
	ctx.r[23].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[23].u64 = ctx.r[23].u32 as u64;
	// 821D9B44: 9941007D  stb r10, 0x7d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(125 as u32), ctx.r[10].u8 ) };
	// 821D9B48: 39070001  addi r8, r7, 1
	ctx.r[8].s64 = ctx.r[7].s64 + 1;
	// 821D9B4C: 54CA083C  slwi r10, r6, 1
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D9B50: 910B2004  stw r8, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	// 821D9B54: 391BA980  addi r8, r27, -0x5680
	ctx.r[8].s64 = ctx.r[27].s64 + -22144;
	// 821D9B58: 914B2000  stw r10, 0x2000(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8192 as u32), ctx.r[10].u32 ) };
	// 821D9B5C: 38FAA988  addi r7, r26, -0x5678
	ctx.r[7].s64 = ctx.r[26].s64 + -22136;
	// 821D9B60: 7CB7F92E  stwx r5, r23, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[23].u32.wrapping_add(ctx.r[31].u32), ctx.r[5].u32) };
	// 821D9B64: 3B79AA14  addi r27, r25, -0x55ec
	ctx.r[27].s64 = ctx.r[25].s64 + -21996;
	// 821D9B68: 814B400C  lwz r10, 0x400c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821D9B6C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821D9B70: 812B4008  lwz r9, 0x4008(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16392 as u32) ) } as u64;
	// 821D9B74: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821D9B78: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821D9B7C: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 821D9B80: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 821D9B84: 90E10068  stw r7, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[7].u32 ) };
	// 821D9B88: 914B400C  stw r10, 0x400c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16396 as u32), ctx.r[10].u32 ) };
	// 821D9B8C: 912B4008  stw r9, 0x4008(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16392 as u32), ctx.r[9].u32 ) };
	// 821D9B90: 98C10050  stb r6, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u8 ) };
	// 821D9B94: 4809CC4D  bl 0x822767e0
	ctx.lr = 0x821D9B98;
	sub_822767E0(ctx, base);
	// 821D9B98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D9B9C: 48045745  bl 0x8221f2e0
	ctx.lr = 0x821D9BA0;
	sub_8221F2E0(ctx, base);
	// 821D9BA0: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 821D9BA4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821D9BA8: 807FF9C0  lwz r3, -0x640(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821D9BAC: 4805D475  bl 0x82237020
	ctx.lr = 0x821D9BB0;
	sub_82237020(ctx, base);
	// 821D9BB0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821D9BB4: 807FF9C0  lwz r3, -0x640(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821D9BB8: 4805D469  bl 0x82237020
	ctx.lr = 0x821D9BBC;
	sub_82237020(ctx, base);
	// 821D9BBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D9BC0: 807FF9C0  lwz r3, -0x640(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821D9BC4: 4805D45D  bl 0x82237020
	ctx.lr = 0x821D9BC8;
	sub_82237020(ctx, base);
	// 821D9BC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D9BCC: 807FF9C0  lwz r3, -0x640(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821D9BD0: 4805D451  bl 0x82237020
	ctx.lr = 0x821D9BD4;
	sub_82237020(ctx, base);
	// 821D9BD4: 3CA08349  lis r5, -0x7cb7
	ctx.r[5].s64 = -2092367872;
	// 821D9BD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D9BDC: 99656F24  stb r11, 0x6f24(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(28452 as u32), ctx.r[11].u8 ) };
	// 821D9BE0: 4BFDD481  bl 0x821b7060
	ctx.lr = 0x821D9BE4;
	sub_821B7060(ctx, base);
	// 821D9BE4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821D9BE8: 48ACF85C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9BF0 size=108
    let mut pc: u32 = 0x821D9BF0;
    'dispatch: loop {
        match pc {
            0x821D9BF0 => {
    //   block [0x821D9BF0..0x821D9C5C)
	// 821D9BF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9BF4: 48ACF819  bl 0x82ca940c
	ctx.lr = 0x821D9BF8;
	sub_82CA93D0(ctx, base);
	// 821D9BF8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9BFC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821D9C00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D9C04: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9C08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D9C0C: 419A0048  beq cr6, 0x821d9c54
	if ctx.cr[6].eq {
	pc = 0x821D9C54; continue 'dispatch;
	}
	// 821D9C10: 480225E1  bl 0x821fc1f0
	ctx.lr = 0x821D9C14;
	sub_821FC1F0(ctx, base);
	// 821D9C14: 387E0020  addi r3, r30, 0x20
	ctx.r[3].s64 = ctx.r[30].s64 + 32;
	// 821D9C18: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9C1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D9C20: 4800EFE9  bl 0x821e8c08
	ctx.lr = 0x821D9C24;
	sub_821E8C08(ctx, base);
	// 821D9C24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D9C28: 480223E1  bl 0x821fc008
	ctx.lr = 0x821D9C2C;
	sub_821FC008(ctx, base);
	// 821D9C2C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821D9C30: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821D9C34: 419A0020  beq cr6, 0x821d9c54
	if ctx.cr[6].eq {
	pc = 0x821D9C54; continue 'dispatch;
	}
	// 821D9C38: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 821D9C3C: 387E0034  addi r3, r30, 0x34
	ctx.r[3].s64 = ctx.r[30].s64 + 52;
	// 821D9C40: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D9C44: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 821D9C48: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821D9C4C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821D9C50: 488BD719  bl 0x82a97368
	ctx.lr = 0x821D9C54;
	sub_82A97368(ctx, base);
	// 821D9C54: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D9C58: 48ACF804  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D9C60 size=36
    let mut pc: u32 = 0x821D9C60;
    'dispatch: loop {
        match pc {
            0x821D9C60 => {
    //   block [0x821D9C60..0x821D9C84)
	// 821D9C60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821D9C64: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D9C68: 908B000C  stw r4, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 821D9C6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D9C70: 419A0008  beq cr6, 0x821d9c78
	if ctx.cr[6].eq {
	pc = 0x821D9C78; continue 'dispatch;
	}
	// 821D9C74: 908A002C  stw r4, 0x2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[4].u32 ) };
	// 821D9C78: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D9C7C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821D9C80: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9C84(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D9C84 size=12
    let mut pc: u32 = 0x821D9C84;
    'dispatch: loop {
        match pc {
            0x821D9C84 => {
    //   block [0x821D9C84..0x821D9C90)
	// 821D9C84: 808B002C  lwz r4, 0x2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D9C88: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821D9C8C: 48BA26A4  b 0x82d7c330
	sub_82D7C330(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D9C90 size=4
    let mut pc: u32 = 0x821D9C90;
    'dispatch: loop {
        match pc {
            0x821D9C90 => {
    //   block [0x821D9C90..0x821D9C94)
	// 821D9C90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9C98 size=168
    let mut pc: u32 = 0x821D9C98;
    'dispatch: loop {
        match pc {
            0x821D9C98 => {
    //   block [0x821D9C98..0x821D9D40)
	// 821D9C98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9C9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D9CA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D9CA4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9CA8: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821D9CAC: 80A30010  lwz r5, 0x10(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D9CB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821D9CB4: 388B0D54  addi r4, r11, 0xd54
	ctx.r[4].s64 = ctx.r[11].s64 + 3412;
	// 821D9CB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D9CBC: 4801A7C5  bl 0x821f4480
	ctx.lr = 0x821D9CC0;
	sub_821F4480(ctx, base);
	// 821D9CC0: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821D9CC4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821D9CC8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D9CCC: 419A0060  beq cr6, 0x821d9d2c
	if ctx.cr[6].eq {
	pc = 0x821D9D2C; continue 'dispatch;
	}
	// 821D9CD0: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D9CD4: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D9CD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D9CDC: 419A0018  beq cr6, 0x821d9cf4
	if ctx.cr[6].eq {
	pc = 0x821D9CF4; continue 'dispatch;
	}
	// 821D9CE0: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D9CE4: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D9CE8: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821D9CEC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D9CF0: 41980008  blt cr6, 0x821d9cf8
	if ctx.cr[6].lt {
	pc = 0x821D9CF8; continue 'dispatch;
	}
	// 821D9CF4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D9CF8: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D9CFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D9D00: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821D9D04: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9D08: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D9D0C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821D9D10: 4E800421  bctrl
	ctx.lr = 0x821D9D14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D9D14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D9D18: 48026061  bl 0x821ffd78
	ctx.lr = 0x821D9D1C;
	sub_821FFD78(ctx, base);
	// 821D9D1C: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821D9D20: 80E10064  lwz r7, 0x64(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821D9D24: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821D9D28: 409AFFA8  bne cr6, 0x821d9cd0
	if !ctx.cr[6].eq {
	pc = 0x821D9CD0; continue 'dispatch;
	}
	// 821D9D2C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D9D30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D9D34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D9D38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D9D3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D9D40 size=244
    let mut pc: u32 = 0x821D9D40;
    'dispatch: loop {
        match pc {
            0x821D9D40 => {
    //   block [0x821D9D40..0x821D9E34)
	// 821D9D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D9D48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D9D4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D9D50: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 821D9D54: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9D58: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821D9D5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D9D60: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D9D64: 397F00D8  addi r11, r31, 0xd8
	ctx.r[11].s64 = ctx.r[31].s64 + 216;
	// 821D9D68: C81F00E0  lfd f0, 0xe0(r31)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	// 821D9D6C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821D9D70: 40990020  ble cr6, 0x821d9d90
	if !ctx.cr[6].gt {
	pc = 0x821D9D90; continue 'dispatch;
	}
	// 821D9D74: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821D9D78: D80B0000  stfd f0, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.f[0].u64 ) };
	// 821D9D7C: DBEB0008  stfd f31, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.f[31].u64 ) };
	// 821D9D80: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821D9D84: C009D5C8  lfs f0, -0x2a38(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D9D88: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821D9D8C: 48000008  b 0x821d9d94
	pc = 0x821D9D94; continue 'dispatch;
	// 821D9D90: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821D9D94: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821D9D98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D9D9C: 419A007C  beq cr6, 0x821d9e18
	if ctx.cr[6].eq {
	pc = 0x821D9E18; continue 'dispatch;
	}
	// 821D9DA0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9DA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D9DA8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9DAC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D9DB0: 4E800421  bctrl
	ctx.lr = 0x821D9DB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D9DB4: 2F030005  cmpwi cr6, r3, 5
	ctx.cr[6].compare_i32(ctx.r[3].s32, 5, &mut ctx.xer);
	// 821D9DB8: 419A0018  beq cr6, 0x821d9dd0
	if ctx.cr[6].eq {
	pc = 0x821D9DD0; continue 'dispatch;
	}
	// 821D9DBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D9DC0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D9DC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D9DC8: 4889F771  bl 0x82a79538
	ctx.lr = 0x821D9DCC;
	sub_82A79538(ctx, base);
	// 821D9DCC: 4800004C  b 0x821d9e18
	pc = 0x821D9E18; continue 'dispatch;
	// 821D9DD0: 395F0140  addi r10, r31, 0x140
	ctx.r[10].s64 = ctx.r[31].s64 + 320;
	// 821D9DD4: 393F0100  addi r9, r31, 0x100
	ctx.r[9].s64 = ctx.r[31].s64 + 256;
	// 821D9DD8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821D9DDC: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 821D9DE0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821D9DE4: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821D9DE8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821D9DEC: F9090000  std r8, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 821D9DF0: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 821D9DF4: 4200FFF0  bdnz 0x821d9de4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821D9DE4; continue 'dispatch;
	}
	// 821D9DF8: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 821D9DFC: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821D9E00: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821D9E04: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821D9E08: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821D9E0C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821D9E10: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D9E14: 4200FFF0  bdnz 0x821d9e04
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821D9E04; continue 'dispatch;
	}
	// 821D9E18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D9E1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D9E20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D9E24: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 821D9E28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D9E2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D9E30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9E38 size=100
    let mut pc: u32 = 0x821D9E38;
    'dispatch: loop {
        match pc {
            0x821D9E38 => {
    //   block [0x821D9E38..0x821D9E9C)
	// 821D9E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9E3C: 48ACF5D1  bl 0x82ca940c
	ctx.lr = 0x821D9E40;
	sub_82CA93D0(ctx, base);
	// 821D9E40: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821D9E44: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9E48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D9E4C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821D9E50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D9E54: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821D9E58: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821D9E5C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D9E60: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D9E64: 997F0060  stb r11, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 821D9E68: 4808E119  bl 0x82267f80
	ctx.lr = 0x821D9E6C;
	sub_82267F80(ctx, base);
	// 821D9E6C: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821D9E70: 4082000C  bne 0x821d9e7c
	if !ctx.cr[0].eq {
	pc = 0x821D9E7C; continue 'dispatch;
	}
	// 821D9E74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D9E78: 48000018  b 0x821d9e90
	pc = 0x821D9E90; continue 'dispatch;
	// 821D9E7C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821D9E80: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D9E84: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821D9E88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D9E8C: 480AE975  bl 0x82288800
	ctx.lr = 0x821D9E90;
	sub_82288800(ctx, base);
	// 821D9E90: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D9E94: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821D9E98: 48ACF5C4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9EA0 size=72
    let mut pc: u32 = 0x821D9EA0;
    'dispatch: loop {
        match pc {
            0x821D9EA0 => {
    //   block [0x821D9EA0..0x821D9EE8)
	// 821D9EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9EA4: 48ACF569  bl 0x82ca940c
	ctx.lr = 0x821D9EA8;
	sub_82CA93D0(ctx, base);
	// 821D9EA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9EAC: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9EB0: 817F03B8  lwz r11, 0x3b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(952 as u32) ) } as u64;
	// 821D9EB4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D9EB8: 917F03B8  stw r11, 0x3b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(952 as u32), ctx.r[11].u32 ) };
	// 821D9EBC: 40820024  bne 0x821d9ee0
	if !ctx.cr[0].eq {
	pc = 0x821D9EE0; continue 'dispatch;
	}
	// 821D9EC0: 3BC00011  li r30, 0x11
	ctx.r[30].s64 = 17;
	// 821D9EC4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821D9EC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D9ECC: 4805FD7D  bl 0x82239c48
	ctx.lr = 0x821D9ED0;
	sub_82239C48(ctx, base);
	// 821D9ED0: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 821D9ED4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821D9ED8: 3BFF0038  addi r31, r31, 0x38
	ctx.r[31].s64 = ctx.r[31].s64 + 56;
	// 821D9EDC: 4082FFEC  bne 0x821d9ec8
	if !ctx.cr[0].eq {
	pc = 0x821D9EC8; continue 'dispatch;
	}
	// 821D9EE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D9EE4: 48ACF578  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9EE8 size=188
    let mut pc: u32 = 0x821D9EE8;
    'dispatch: loop {
        match pc {
            0x821D9EE8 => {
    //   block [0x821D9EE8..0x821D9FA4)
	// 821D9EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9EEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D9EF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D9EF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D9EF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9EFC: F8A10090  std r5, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[5].u64 ) };
	// 821D9F00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D9F04: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 821D9F08: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821D9F0C: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 821D9F10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D9F14: 409A0008  bne cr6, 0x821d9f1c
	if !ctx.cr[6].eq {
	pc = 0x821D9F1C; continue 'dispatch;
	}
	// 821D9F18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D9F1C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9F20: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821D9F24: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D9F28: 409A0008  bne cr6, 0x821d9f30
	if !ctx.cr[6].eq {
	pc = 0x821D9F30; continue 'dispatch;
	}
	// 821D9F2C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821D9F30: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9F34: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D9F38: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9F3C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821D9F40: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 821D9F44: 419A003C  beq cr6, 0x821d9f80
	if ctx.cr[6].eq {
	pc = 0x821D9F80; continue 'dispatch;
	}
	// 821D9F48: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9F4C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821D9F50: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9F54: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D9F58: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9F5C: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9F60: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821D9F64: 48041DD5  bl 0x8221bd38
	ctx.lr = 0x821D9F68;
	sub_8221BD38(ctx, base);
	// 821D9F68: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D9F6C: E8C10090  ld r6, 0x90(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821D9F70: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 821D9F74: 90BF0008  stw r5, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 821D9F78: F8DE0000  std r6, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 821D9F7C: 4800000C  b 0x821d9f88
	pc = 0x821D9F88; continue 'dispatch;
	// 821D9F80: E9610090  ld r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821D9F84: F97E0000  std r11, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821D9F88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D9F8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D9F90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D9F94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D9F98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D9F9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D9FA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D9FA8 size=452
    let mut pc: u32 = 0x821D9FA8;
    'dispatch: loop {
        match pc {
            0x821D9FA8 => {
    //   block [0x821D9FA8..0x821DA16C)
	// 821D9FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9FAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D9FB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D9FB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9FB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D9FBC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9FC0: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821D9FC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821D9FC8: 4E800421  bctrl
	ctx.lr = 0x821D9FCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D9FCC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D9FD0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821D9FD4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9FD8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D9FDC: 409A003C  bne cr6, 0x821da018
	if !ctx.cr[6].eq {
	pc = 0x821DA018; continue 'dispatch;
	}
	// 821D9FE0: C16B0034  lfs f11, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821D9FE4: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D9FE8: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 821D9FEC: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D9FF0: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821D9FF4: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 821D9FF8: C19F00E8  lfs f12, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821D9FFC: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821DA000: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 821DA004: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 821DA008: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 821DA00C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 821DA010: EC20002C  fsqrts f1, f0
	ctx.f[1].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 821DA014: 48000144  b 0x821da158
	pc = 0x821DA158; continue 'dispatch;
	// 821DA018: C17F00F8  lfs f11, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821DA01C: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DA020: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 821DA024: C15F00FC  lfs f10, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821DA028: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DA02C: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 821DA030: C17F0100  lfs f11, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821DA034: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821DA038: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821DA03C: C15F00E0  lfs f10, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821DA040: C17F00F8  lfs f11, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821DA044: FF0B5000  fcmpu cr6, f11, f10
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[10].f64);
	// 821DA048: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 821DA04C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 821DA050: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 821DA054: EC20002C  fsqrts f1, f0
	ctx.f[1].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 821DA058: 409A0028  bne cr6, 0x821da080
	if !ctx.cr[6].eq {
	pc = 0x821DA080; continue 'dispatch;
	}
	// 821DA05C: C01F00FC  lfs f0, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DA060: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DA064: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821DA068: 409A0018  bne cr6, 0x821da080
	if !ctx.cr[6].eq {
	pc = 0x821DA080; continue 'dispatch;
	}
	// 821DA06C: C01F0100  lfs f0, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DA070: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DA074: C1BF00E8  lfs f13, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DA078: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821DA07C: 419A0008  beq cr6, 0x821da084
	if ctx.cr[6].eq {
	pc = 0x821DA084; continue 'dispatch;
	}
	// 821DA080: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DA084: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DA088: 418200D0  beq 0x821da158
	if ctx.cr[0].eq {
	pc = 0x821DA158; continue 'dispatch;
	}
	// 821DA08C: 813F013C  lwz r9, 0x13c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 821DA090: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 821DA094: 419A0074  beq cr6, 0x821da108
	if ctx.cr[6].eq {
	pc = 0x821DA108; continue 'dispatch;
	}
	// 821DA098: 811F007C  lwz r8, 0x7c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821DA09C: 39490001  addi r10, r9, 1
	ctx.r[10].s64 = ctx.r[9].s64 + 1;
	// 821DA0A0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821DA0A4: 40980064  bge cr6, 0x821da108
	if !ctx.cr[6].lt {
	pc = 0x821DA108; continue 'dispatch;
	}
	// 821DA0A8: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 821DA0AC: 1D29000C  mulli r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 * 12;
	// 821DA0B0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821DA0B4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821DA0B8: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821DA0BC: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DA0C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821DA0C4: C00BFFFC  lfs f0, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DA0C8: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 821DA0CC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821DA0D0: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821DA0D4: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DA0D8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821DA0DC: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 821DA0E0: C16BFFF8  lfs f11, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821DA0E4: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821DA0E8: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 821DA0EC: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821DA0F0: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 821DA0F4: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 821DA0F8: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 821DA0FC: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 821DA100: EC20082A  fadds f1, f0, f1
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 821DA104: 4198FFB8  blt cr6, 0x821da0bc
	if ctx.cr[6].lt {
	pc = 0x821DA0BC; continue 'dispatch;
	}
	// 821DA108: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821DA10C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DA110: 41820048  beq 0x821da158
	if ctx.cr[0].eq {
	pc = 0x821DA158; continue 'dispatch;
	}
	// 821DA114: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 821DA118: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 821DA11C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821DA120: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DA124: C17F00E8  lfs f11, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821DA128: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DA12C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821DA130: C18BFFF8  lfs f12, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821DA134: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DA138: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 821DA13C: C18BFFFC  lfs f12, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821DA140: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821DA144: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 821DA148: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 821DA14C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 821DA150: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 821DA154: EC20082A  fadds f1, f0, f1
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 821DA158: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821DA15C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DA160: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DA164: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821DA168: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DA170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DA170 size=28
    let mut pc: u32 = 0x821DA170;
    'dispatch: loop {
        match pc {
            0x821DA170 => {
    //   block [0x821DA170..0x821DA18C)
	// 821DA170: 896300BC  lbz r11, 0xbc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(188 as u32) ) } as u64;
	// 821DA174: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821DA178: 409A0014  bne cr6, 0x821da18c
	if !ctx.cr[6].eq {
		sub_821DA18C(ctx, base);
		return;
	}
	// 821DA17C: 896300BE  lbz r11, 0xbe(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(190 as u32) ) } as u64;
	// 821DA180: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821DA184: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DA188: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DA18C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DA18C size=8
    let mut pc: u32 = 0x821DA18C;
    'dispatch: loop {
        match pc {
            0x821DA18C => {
    //   block [0x821DA18C..0x821DA194)
	// 821DA18C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821DA190: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DA198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DA198 size=236
    let mut pc: u32 = 0x821DA198;
    'dispatch: loop {
        match pc {
            0x821DA198 => {
    //   block [0x821DA198..0x821DA284)
	// 821DA198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DA19C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DA1A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821DA1A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DA1A8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DA1AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DA1B0: 897F00B0  lbz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821DA1B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA1B8: 409A002C  bne cr6, 0x821da1e4
	if !ctx.cr[6].eq {
	pc = 0x821DA1E4; continue 'dispatch;
	}
	// 821DA1BC: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 821DA1C0: 815F00B8  lwz r10, 0xb8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 821DA1C4: 812B00B0  lwz r9, 0xb0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) } as u64;
	// 821DA1C8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821DA1CC: 409A0018  bne cr6, 0x821da1e4
	if !ctx.cr[6].eq {
	pc = 0x821DA1E4; continue 'dispatch;
	}
	// 821DA1D0: 812B00AC  lwz r9, 0xac(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 821DA1D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DA1D8: 815F00B4  lwz r10, 0xb4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 821DA1DC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821DA1E0: 419A0008  beq cr6, 0x821da1e8
	if ctx.cr[6].eq {
	pc = 0x821DA1E8; continue 'dispatch;
	}
	// 821DA1E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DA1E8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DA1EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA1F0: 419A0078  beq cr6, 0x821da268
	if ctx.cr[6].eq {
	pc = 0x821DA268; continue 'dispatch;
	}
	// 821DA1F4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DA1F8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA1FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DA200: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DA204: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DA208: 812A0044  lwz r9, 0x44(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 821DA20C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821DA210: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821DA214: 4E800421  bctrl
	ctx.lr = 0x821DA218;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DA218: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821DA21C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DA220: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821DA224: 4904ED55  bl 0x83228f78
	ctx.lr = 0x821DA228;
	sub_83228F78(ctx, base);
	// 821DA228: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821DA22C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DA288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DA288 size=192
    let mut pc: u32 = 0x821DA288;
    'dispatch: loop {
        match pc {
            0x821DA288 => {
    //   block [0x821DA288..0x821DA348)
	// 821DA288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DA28C: 48ACF181  bl 0x82ca940c
	ctx.lr = 0x821DA290;
	sub_82CA93D0(ctx, base);
	// 821DA290: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DA294: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821DA298: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821DA29C: 389E0018  addi r4, r30, 0x18
	ctx.r[4].s64 = ctx.r[30].s64 + 24;
	// 821DA2A0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821DA2A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA2A8: 483A5231  bl 0x8257f4d8
	ctx.lr = 0x821DA2AC;
	sub_8257F4D8(ctx, base);
	// 821DA2AC: 83BE0020  lwz r29, 0x20(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DA2B0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821DA2B4: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821DA2B8: 419A0068  beq cr6, 0x821da320
	if ctx.cr[6].eq {
	pc = 0x821DA320; continue 'dispatch;
	}
	// 821DA2BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA2C0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA2C4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DA2C8: 409A000C  bne cr6, 0x821da2d4
	if !ctx.cr[6].eq {
	pc = 0x821DA2D4; continue 'dispatch;
	}
	// 821DA2CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DA2D0: 48000034  b 0x821da304
	pc = 0x821DA304; continue 'dispatch;
	// 821DA2D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DA2D8: 409A000C  bne cr6, 0x821da2e4
	if !ctx.cr[6].eq {
	pc = 0x821DA2E4; continue 'dispatch;
	}
	// 821DA2DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DA2E0: 48000024  b 0x821da304
	pc = 0x821DA304; continue 'dispatch;
	// 821DA2E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA2E8: 419A001C  beq cr6, 0x821da304
	if ctx.cr[6].eq {
	pc = 0x821DA304; continue 'dispatch;
	}
	// 821DA2EC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA2F0: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA2F4: 48093505  bl 0x8226d7f8
	ctx.lr = 0x821DA2F8;
	sub_8226D7F8(ctx, base);
	// 821DA2F8: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821DA2FC: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821DA300: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821DA304: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DA308: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA30C: 409A0014  bne cr6, 0x821da320
	if !ctx.cr[6].eq {
	pc = 0x821DA320; continue 'dispatch;
	}
	// 821DA310: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DA314: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821DA318: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821DA31C: 48000008  b 0x821da324
	pc = 0x821DA324; continue 'dispatch;
	// 821DA320: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821DA324: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DA328: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DA32C: 419A0010  beq cr6, 0x821da33c
	if ctx.cr[6].eq {
	pc = 0x821DA33C; continue 'dispatch;
	}
	// 821DA330: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA334: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DA338: 48ACF124  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821DA33C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821DA340: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DA344: 48ACF118  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DA348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DA348 size=104
    let mut pc: u32 = 0x821DA348;
    'dispatch: loop {
        match pc {
            0x821DA348 => {
    //   block [0x821DA348..0x821DA3B0)
	// 821DA348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DA34C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DA350: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DA354: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821DA358: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DA35C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821DA360: 90870000  stw r4, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821DA364: 91670004  stw r11, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821DA368: 419A0034  beq cr6, 0x821da39c
	if ctx.cr[6].eq {
	pc = 0x821DA39C; continue 'dispatch;
	}
	// 821DA36C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DA370: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821DA374: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA378: 409A0014  bne cr6, 0x821da38c
	if !ctx.cr[6].eq {
	pc = 0x821DA38C; continue 'dispatch;
	}
	// 821DA37C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DA380: 816B6AC0  lwz r11, 0x6ac0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27328 as u32) ) } as u64;
	// 821DA384: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA388: 419A0014  beq cr6, 0x821da39c
	if ctx.cr[6].eq {
	pc = 0x821DA39C; continue 'dispatch;
	}
	// 821DA38C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DA390: 806B6DA0  lwz r3, 0x6da0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821DA394: 48009EBD  bl 0x821e4250
	ctx.lr = 0x821DA398;
	sub_821E4250(ctx, base);
	// 821DA398: 90670004  stw r3, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821DA39C: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821DA3A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821DA3A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DA3A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DA3AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DA3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DA3B0 size=184
    let mut pc: u32 = 0x821DA3B0;
    'dispatch: loop {
        match pc {
            0x821DA3B0 => {
    //   block [0x821DA3B0..0x821DA468)
	// 821DA3B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DA3B4: 48ACF059  bl 0x82ca940c
	ctx.lr = 0x821DA3B8;
	sub_82CA93D0(ctx, base);
	// 821DA3B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DA3BC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DA3C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821DA3C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DA3C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA3CC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821DA3D0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA3D4: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DA3D8: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DA3DC: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 821DA3E0: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA3E4: 83A60004  lwz r29, 4(r6)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA3E8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821DA3EC: 4E800421  bctrl
	ctx.lr = 0x821DA3F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DA3F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821DA3F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA3F8: 4BFFFE91  bl 0x821da288
	ctx.lr = 0x821DA3FC;
	sub_821DA288(ctx, base);
	// 821DA3FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821DA400: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA404: 4803A9D5  bl 0x82214dd8
	ctx.lr = 0x821DA408;
	sub_82214DD8(ctx, base);
	// 821DA408: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA40C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA410: 80AB001C  lwz r5, 0x1c(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DA414: 808B0020  lwz r4, 0x20(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DA418: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 821DA41C: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 821DA420: 4BFD80D9  bl 0x821b24f8
	ctx.lr = 0x821DA424;
	sub_821B24F8(ctx, base);
	// 821DA424: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821DA428: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 821DA42C: 4882629D  bl 0x82a006c8
	ctx.lr = 0x821DA430;
	sub_82A006C8(ctx, base);
	// 821DA430: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821DA434: 419A001C  beq cr6, 0x821da450
	if ctx.cr[6].eq {
	pc = 0x821DA450; continue 'dispatch;
	}
	// 821DA438: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA43C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DA440: 4BFFFF09  bl 0x821da348
	ctx.lr = 0x821DA444;
	sub_821DA348(ctx, base);
	// 821DA444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DA448: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DA44C: 48ACF010  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821DA450: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821DA454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DA458: 4BFFFEF1  bl 0x821da348
	ctx.lr = 0x821DA45C;
	sub_821DA348(ctx, base);
	// 821DA45C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DA460: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DA464: 48ACEFF8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DA468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DA468 size=1292
    let mut pc: u32 = 0x821DA468;
    'dispatch: loop {
        match pc {
            0x821DA468 => {
    //   block [0x821DA468..0x821DA974)
	// 821DA468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DA46C: 48ACEFA1  bl 0x82ca940c
	ctx.lr = 0x821DA470;
	sub_82CA93D0(ctx, base);
	// 821DA470: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DA474: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821DA478: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821DA47C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821DA480: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 821DA484: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DA488: 409900FC  ble cr6, 0x821da584
	if !ctx.cr[6].gt {
	pc = 0x821DA584; continue 'dispatch;
	}
	// 821DA48C: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821DA490: 40980010  bge cr6, 0x821da4a0
	if !ctx.cr[6].lt {
	pc = 0x821DA4A0; continue 'dispatch;
	}
	// 821DA494: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DA498: 3BEB7088  addi r31, r11, 0x7088
	ctx.r[31].s64 = ctx.r[11].s64 + 28808;
	// 821DA49C: 4800000C  b 0x821da4a8
	pc = 0x821DA4A8; continue 'dispatch;
	// 821DA4A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821DA4A4: 3BEB0CA0  addi r31, r11, 0xca0
	ctx.r[31].s64 = ctx.r[11].s64 + 3232;
	// 821DA4A8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DA4AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA4B0: 388B7990  addi r4, r11, 0x7990
	ctx.r[4].s64 = ctx.r[11].s64 + 31120;
	// 821DA4B4: 48015D8D  bl 0x821f0240
	ctx.lr = 0x821DA4B8;
	sub_821F0240(ctx, base);
	// 821DA4B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DA4BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA4C0: 48000501  bl 0x821da9c0
	ctx.lr = 0x821DA4C4;
	sub_821DA9C0(ctx, base);
	// 821DA4C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821DA4C8: 809E0040  lwz r4, 0x40(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 821DA4CC: 481747F5  bl 0x8234ecc0
	ctx.lr = 0x821DA4D0;
	sub_8234ECC0(ctx, base);
	// 821DA4D0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821DA4D4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821DA4D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DA4DC: 48008C2D  bl 0x821e3108
	ctx.lr = 0x821DA4E0;
	sub_821E3108(ctx, base);
	// 821DA4E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821DA4E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA4E8: 48015D59  bl 0x821f0240
	ctx.lr = 0x821DA4EC;
	sub_821F0240(ctx, base);
	// 821DA4EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821DA4F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA4F4: 3BEA0B74  addi r31, r10, 0xb74
	ctx.r[31].s64 = ctx.r[10].s64 + 2932;
	// 821DA4F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DA4FC: 480004C5  bl 0x821da9c0
	ctx.lr = 0x821DA500;
	sub_821DA9C0(ctx, base);
	// 821DA500: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DA504: 4803A8D5  bl 0x82214dd8
	ctx.lr = 0x821DA508;
	sub_82214DD8(ctx, base);
	// 821DA508: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA50C: 4803A8CD  bl 0x82214dd8
	ctx.lr = 0x821DA510;
	sub_82214DD8(ctx, base);
	// 821DA510: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821DA514: 4803A8C5  bl 0x82214dd8
	ctx.lr = 0x821DA518;
	sub_82214DD8(ctx, base);
	// 821DA518: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821DA51C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821DA520: 481CDF01  bl 0x823a8420
	ctx.lr = 0x821DA524;
	sub_823A8420(ctx, base);
	// 821DA524: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821DA528: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821DA52C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DA530: 48008BD9  bl 0x821e3108
	ctx.lr = 0x821DA534;
	sub_821E3108(ctx, base);
	// 821DA534: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821DA538: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA53C: 48015D05  bl 0x821f0240
	ctx.lr = 0x821DA540;
	sub_821F0240(ctx, base);
	// 821DA540: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DA544: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA548: 48000479  bl 0x821da9c0
	ctx.lr = 0x821DA54C;
	sub_821DA9C0(ctx, base);
	// 821DA54C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821DA550: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA554: 48015CED  bl 0x821f0240
	ctx.lr = 0x821DA558;
	sub_821F0240(ctx, base);
	// 821DA558: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA55C: 4803A87D  bl 0x82214dd8
	ctx.lr = 0x821DA560;
	sub_82214DD8(ctx, base);
	// 821DA560: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DA564: 4803A875  bl 0x82214dd8
	ctx.lr = 0x821DA568;
	sub_82214DD8(ctx, base);
	// 821DA568: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821DA56C: 4803A86D  bl 0x82214dd8
	ctx.lr = 0x821DA570;
	sub_82214DD8(ctx, base);
	// 821DA570: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA574: 4803A865  bl 0x82214dd8
	ctx.lr = 0x821DA578;
	sub_82214DD8(ctx, base);
	// 821DA578: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA57C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821DA580: 48ACEEDC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821DA584: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821DA588: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DA58C: 4BFFFE25  bl 0x821da3b0
	ctx.lr = 0x821DA590;
	sub_821DA3B0(ctx, base);
	// 821DA590: 4BFD7F69  bl 0x821b24f8
	ctx.lr = 0x821DA594;
	sub_821B24F8(ctx, base);
	// 821DA594: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821DA598: 388B1728  addi r4, r11, 0x1728
	ctx.r[4].s64 = ctx.r[11].s64 + 5928;
	// 821DA59C: 48148FA5  bl 0x82323540
	ctx.lr = 0x821DA5A0;
	sub_82323540(ctx, base);
	// 821DA5A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821DA5A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA5A8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821DA5AC: 48052925  bl 0x8222ced0
	ctx.lr = 0x821DA5B0;
	sub_8222CED0(ctx, base);
	// 821DA5B0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821DA5B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA5B8: 419A005C  beq cr6, 0x821da614
	if ctx.cr[6].eq {
	pc = 0x821DA614; continue 'dispatch;
	}
	// 821DA5BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA5C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DA5C4: 40990050  ble cr6, 0x821da614
	if !ctx.cr[6].gt {
	pc = 0x821DA614; continue 'dispatch;
	}
	// 821DA5C8: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 821DA5CC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821DA5D0: 409A0014  bne cr6, 0x821da5e4
	if !ctx.cr[6].eq {
	pc = 0x821DA5E4; continue 'dispatch;
	}
	// 821DA5D4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821DA5D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA5DC: 388BA404  addi r4, r11, -0x5bfc
	ctx.r[4].s64 = ctx.r[11].s64 + -23548;
	// 821DA5E0: 480003E1  bl 0x821da9c0
	ctx.lr = 0x821DA5E4;
	sub_821DA9C0(ctx, base);
	// 821DA5E4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821DA5E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA5EC: 48015C55  bl 0x821f0240
	ctx.lr = 0x821DA5F0;
	sub_821F0240(ctx, base);
	// 821DA5F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821DA5F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA5F8: 388B0B74  addi r4, r11, 0xb74
	ctx.r[4].s64 = ctx.r[11].s64 + 2932;
	// 821DA5FC: 480003C5  bl 0x821da9c0
	ctx.lr = 0x821DA600;
	sub_821DA9C0(ctx, base);
	// 821DA600: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA604: 4803A7D5  bl 0x82214dd8
	ctx.lr = 0x821DA608;
	sub_82214DD8(ctx, base);
	// 821DA608: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA60C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821DA610: 48ACEE4C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821DA614: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 821DA618: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821DA61C: 409A0334  bne cr6, 0x821da950
	if !ctx.cr[6].eq {
	pc = 0x821DA950; continue 'dispatch;
	}
	// 821DA620: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821DA624: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821DA628: 388B9FC4  addi r4, r11, -0x603c
	ctx.r[4].s64 = ctx.r[11].s64 + -24636;
	// 821DA62C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA630: 480528A1  bl 0x8222ced0
	ctx.lr = 0x821DA634;
	sub_8222CED0(ctx, base);
	// 821DA634: 57EA063E  clrlwi r10, r31, 0x18
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821DA638: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DA63C: 419A0018  beq cr6, 0x821da654
	if ctx.cr[6].eq {
	pc = 0x821DA654; continue 'dispatch;
	}
	// 821DA640: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821DA644: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA648: 388B0B74  addi r4, r11, 0xb74
	ctx.r[4].s64 = ctx.r[11].s64 + 2932;
	// 821DA64C: 48000375  bl 0x821da9c0
	ctx.lr = 0x821DA650;
	sub_821DA9C0(ctx, base);
	// 821DA650: 480002D8  b 0x821da928
	pc = 0x821DA928; continue 'dispatch;
	// 821DA654: 80DE0004  lwz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA658: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821DA65C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821DA660: 81460030  lwz r10, 0x30(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(48 as u32) ) } as u64;
	// 821DA664: 554937FE  rlwinm r9, r10, 6, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x03FFFFFFu64;
	// 821DA668: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DA66C: 419A00E8  beq cr6, 0x821da754
	if ctx.cr[6].eq {
	pc = 0x821DA754; continue 'dispatch;
	}
	// 821DA670: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 821DA674: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA678: 419A0020  beq cr6, 0x821da698
	if ctx.cr[6].eq {
	pc = 0x821DA698; continue 'dispatch;
	}
	// 821DA67C: 894B007A  lbz r10, 0x7a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(122 as u32) ) } as u64;
	// 821DA680: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DA684: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821DA688: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821DA68C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DA690: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA694: 480000C4  b 0x821da758
	pc = 0x821DA758; continue 'dispatch;
	// 821DA698: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DA69C: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 821DA6A0: 90810060  stw r4, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[4].u32 ) };
	// 821DA6A4: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 821DA6A8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821DA6AC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DA6B0: 40810054  ble 0x821da704
	if !ctx.cr[0].gt {
	pc = 0x821DA704; continue 'dispatch;
	}
	// 821DA6B4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821DA6B8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DA6BC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821DA6C0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA6C4: 2F07007A  cmpwi cr6, r7, 0x7a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 122, &mut ctx.xer);
	// 821DA6C8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821DA6CC: 41980008  blt cr6, 0x821da6d4
	if ctx.cr[6].lt {
	pc = 0x821DA6D4; continue 'dispatch;
	}
	// 821DA6D0: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 821DA6D4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821DA6D8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DA6DC: 419A0014  beq cr6, 0x821da6f0
	if ctx.cr[6].eq {
	pc = 0x821DA6F0; continue 'dispatch;
	}
	// 821DA6E0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821DA6E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821DA6E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821DA6EC: 4800000C  b 0x821da6f8
	pc = 0x821DA6F8; continue 'dispatch;
	// 821DA6F0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821DA6F4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821DA6F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DA6FC: 4199FFB8  bgt cr6, 0x821da6b4
	if ctx.cr[6].gt {
	pc = 0x821DA6B4; continue 'dispatch;
	}
	// 821DA700: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821DA704: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821DA708: 419A003C  beq cr6, 0x821da744
	if ctx.cr[6].eq {
	pc = 0x821DA744; continue 'dispatch;
	}
	// 821DA70C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA710: 2F0B007A  cmpwi cr6, r11, 0x7a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 122, &mut ctx.xer);
	// 821DA714: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DA718: 41990008  bgt cr6, 0x821da720
	if ctx.cr[6].gt {
	pc = 0x821DA720; continue 'dispatch;
	}
	// 821DA71C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821DA720: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DA724: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA728: 409A001C  bne cr6, 0x821da744
	if !ctx.cr[6].eq {
	pc = 0x821DA744; continue 'dispatch;
	}
	// 821DA72C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821DA730: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DA734: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821DA738: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821DA73C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA740: 48000018  b 0x821da758
	pc = 0x821DA758; continue 'dispatch;
	// 821DA744: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821DA748: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DA74C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA750: 48000008  b 0x821da758
	pc = 0x821DA758; continue 'dispatch;
	// 821DA754: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 821DA758: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821DA75C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DA760: 419A0020  beq cr6, 0x821da780
	if ctx.cr[6].eq {
	pc = 0x821DA780; continue 'dispatch;
	}
	// 821DA764: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821DA768: 4BFE82B1  bl 0x821c2a18
	ctx.lr = 0x821DA76C;
	sub_821C2A18(ctx, base);
	// 821DA76C: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 821DA770: 409A0010  bne cr6, 0x821da780
	if !ctx.cr[6].eq {
	pc = 0x821DA780; continue 'dispatch;
	}
	// 821DA774: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821DA778: 388BA40C  addi r4, r11, -0x5bf4
	ctx.r[4].s64 = ctx.r[11].s64 + -23540;
	// 821DA77C: 48000134  b 0x821da8b0
	pc = 0x821DA8B0; continue 'dispatch;
	// 821DA780: 81460024  lwz r10, 0x24(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 821DA784: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821DA788: 5549A7FE  rlwinm r9, r10, 0x14, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000FFFu64;
	// 821DA78C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DA790: 419A00E8  beq cr6, 0x821da878
	if ctx.cr[6].eq {
	pc = 0x821DA878; continue 'dispatch;
	}
	// 821DA794: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 821DA798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA79C: 419A0020  beq cr6, 0x821da7bc
	if ctx.cr[6].eq {
	pc = 0x821DA7BC; continue 'dispatch;
	}
	// 821DA7A0: 894B000C  lbz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DA7A4: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DA7A8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821DA7AC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821DA7B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DA7B4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA7B8: 480000C4  b 0x821da87c
	pc = 0x821DA87C; continue 'dispatch;
	// 821DA7BC: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DA7C0: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 821DA7C4: 90810060  stw r4, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[4].u32 ) };
	// 821DA7C8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821DA7CC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821DA7D0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DA7D4: 40810054  ble 0x821da828
	if !ctx.cr[0].gt {
	pc = 0x821DA828; continue 'dispatch;
	}
	// 821DA7D8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821DA7DC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DA7E0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821DA7E4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA7E8: 2F07000C  cmpwi cr6, r7, 0xc
	ctx.cr[6].compare_i32(ctx.r[7].s32, 12, &mut ctx.xer);
	// 821DA7EC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821DA7F0: 41980008  blt cr6, 0x821da7f8
	if ctx.cr[6].lt {
	pc = 0x821DA7F8; continue 'dispatch;
	}
	// 821DA7F4: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 821DA7F8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821DA7FC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DA800: 419A0014  beq cr6, 0x821da814
	if ctx.cr[6].eq {
	pc = 0x821DA814; continue 'dispatch;
	}
	// 821DA804: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821DA808: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821DA80C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821DA810: 4800000C  b 0x821da81c
	pc = 0x821DA81C; continue 'dispatch;
	// 821DA814: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821DA818: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821DA81C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DA820: 4199FFB8  bgt cr6, 0x821da7d8
	if ctx.cr[6].gt {
	pc = 0x821DA7D8; continue 'dispatch;
	}
	// 821DA824: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821DA828: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821DA82C: 419A003C  beq cr6, 0x821da868
	if ctx.cr[6].eq {
	pc = 0x821DA868; continue 'dispatch;
	}
	// 821DA830: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA834: 2F0B000C  cmpwi cr6, r11, 0xc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 12, &mut ctx.xer);
	// 821DA838: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DA83C: 41990008  bgt cr6, 0x821da844
	if ctx.cr[6].gt {
	pc = 0x821DA844; continue 'dispatch;
	}
	// 821DA840: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821DA844: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DA848: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA84C: 409A001C  bne cr6, 0x821da868
	if !ctx.cr[6].eq {
	pc = 0x821DA868; continue 'dispatch;
	}
	// 821DA850: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821DA854: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DA858: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821DA85C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821DA860: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA864: 48000018  b 0x821da87c
	pc = 0x821DA87C; continue 'dispatch;
	// 821DA868: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821DA86C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DA870: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA874: 48000008  b 0x821da87c
	pc = 0x821DA87C; continue 'dispatch;
	// 821DA878: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 821DA87C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821DA880: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DA884: 419A0034  beq cr6, 0x821da8b8
	if ctx.cr[6].eq {
	pc = 0x821DA8B8; continue 'dispatch;
	}
	// 821DA888: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DA88C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821DA890: 419A0018  beq cr6, 0x821da8a8
	if ctx.cr[6].eq {
	pc = 0x821DA8A8; continue 'dispatch;
	}
	// 821DA894: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821DA898: 409A0020  bne cr6, 0x821da8b8
	if !ctx.cr[6].eq {
	pc = 0x821DA8B8; continue 'dispatch;
	}
	// 821DA89C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821DA8A0: 388BA420  addi r4, r11, -0x5be0
	ctx.r[4].s64 = ctx.r[11].s64 + -23520;
	// 821DA8A4: 4800000C  b 0x821da8b0
	pc = 0x821DA8B0; continue 'dispatch;
	// 821DA8A8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821DA8AC: 388BA414  addi r4, r11, -0x5bec
	ctx.r[4].s64 = ctx.r[11].s64 + -23532;
	// 821DA8B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA8B4: 4800010D  bl 0x821da9c0
	ctx.lr = 0x821DA8B8;
	sub_821DA9C0(ctx, base);
	// 821DA8B8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DA8BC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821DA8C0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DA8C4: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821DA8C8: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA8CC: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA8D0: 4870B1A9  bl 0x828e5a78
	ctx.lr = 0x821DA8D4;
	sub_828E5A78(ctx, base);
	// 821DA8D4: 80FE0004  lwz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA8D8: 7F071840  cmplw cr6, r7, r3
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821DA8DC: 409A004C  bne cr6, 0x821da928
	if !ctx.cr[6].eq {
	pc = 0x821DA928; continue 'dispatch;
	}
	// 821DA8E0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821DA8E4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821DA8E8: 388BA428  addi r4, r11, -0x5bd8
	ctx.r[4].s64 = ctx.r[11].s64 + -23512;
	// 821DA8EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DA8F0: 480525E1  bl 0x8222ced0
	ctx.lr = 0x821DA8F4;
	sub_8222CED0(ctx, base);
	// 821DA8F4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 821DA8F8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821DA8FC: 388AA438  addi r4, r10, -0x5bc8
	ctx.r[4].s64 = ctx.r[10].s64 + -23496;
	// 821DA900: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821DA904: 480525CD  bl 0x8222ced0
	ctx.lr = 0x821DA908;
	sub_8222CED0(ctx, base);
	// 821DA908: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821DA90C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 821DA910: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA914: 4800BF35  bl 0x821e6848
	ctx.lr = 0x821DA918;
	sub_821E6848(ctx, base);
	// 821DA918: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821DA91C: 4803A4BD  bl 0x82214dd8
	ctx.lr = 0x821DA920;
	sub_82214DD8(ctx, base);
	// 821DA920: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DA924: 4803A4B5  bl 0x82214dd8
	ctx.lr = 0x821DA928;
	sub_82214DD8(ctx, base);
	// 821DA928: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821DA92C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA930: 48015911  bl 0x821f0240
	ctx.lr = 0x821DA934;
	sub_821F0240(ctx, base);
	// 821DA934: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA938: 4803A4A1  bl 0x82214dd8
	ctx.lr = 0x821DA93C;
	sub_82214DD8(ctx, base);
	// 821DA93C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA940: 4803A499  bl 0x82214dd8
	ctx.lr = 0x821DA944;
	sub_82214DD8(ctx, base);
	// 821DA944: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA948: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821DA94C: 48ACEB10  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821DA950: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821DA954: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA958: 388B5E78  addi r4, r11, 0x5e78
	ctx.r[4].s64 = ctx.r[11].s64 + 24184;
	// 821DA95C: 480158E5  bl 0x821f0240
	ctx.lr = 0x821DA960;
	sub_821F0240(ctx, base);
	// 821DA960: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA964: 4803A475  bl 0x82214dd8
	ctx.lr = 0x821DA968;
	sub_82214DD8(ctx, base);
	// 821DA968: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA96C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821DA970: 48ACEAEC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DA978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DA978 size=72
    let mut pc: u32 = 0x821DA978;
    'dispatch: loop {
        match pc {
            0x821DA978 => {
    //   block [0x821DA978..0x821DA9C0)
	// 821DA978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DA97C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DA980: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821DA984: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DA988: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DA98C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DA990: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821DA994: 480158AD  bl 0x821f0240
	ctx.lr = 0x821DA998;
	sub_821F0240(ctx, base);
	// 821DA998: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DA99C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821DA9A0: 48000021  bl 0x821da9c0
	ctx.lr = 0x821DA9A4;
	sub_821DA9C0(ctx, base);
	// 821DA9A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DA9A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821DA9AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DA9B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DA9B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821DA9B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821DA9BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DA9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DA9C0 size=216
    let mut pc: u32 = 0x821DA9C0;
    'dispatch: loop {
        match pc {
            0x821DA9C0 => {
    //   block [0x821DA9C0..0x821DAA98)
	// 821DA9C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DA9C4: 48ACEA45  bl 0x82ca9408
	ctx.lr = 0x821DA9C8;
	sub_82CA93D0(ctx, base);
	// 821DA9C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DA9CC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821DA9D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821DA9D4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA9D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA9DC: 419A0020  beq cr6, 0x821da9fc
	if ctx.cr[6].eq {
	pc = 0x821DA9FC; continue 'dispatch;
	}
	// 821DA9E0: 48053E19  bl 0x8222e7f8
	ctx.lr = 0x821DA9E4;
	sub_8222E7F8(ctx, base);
	// 821DA9E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821DA9E8: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA9EC: 48963F15  bl 0x82b3e900
	ctx.lr = 0x821DA9F0;
	sub_82B3E900(ctx, base);
	// 821DA9F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821DA9F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DA9F8: 48ACEA60  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821DA9FC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821DAA00: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821DAA04: 419A0068  beq cr6, 0x821daa6c
	if ctx.cr[6].eq {
	pc = 0x821DAA6C; continue 'dispatch;
	}
	// 821DAA08: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAA0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DAA10: 419A005C  beq cr6, 0x821daa6c
	if ctx.cr[6].eq {
	pc = 0x821DAA6C; continue 'dispatch;
	}
	// 821DAA14: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 821DAA18: 48044841  bl 0x8221f258
	ctx.lr = 0x821DAA1C;
	sub_8221F258(ctx, base);
	// 821DAA1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DAA20: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821DAA24: 419A0048  beq cr6, 0x821daa6c
	if ctx.cr[6].eq {
	pc = 0x821DAA6C; continue 'dispatch;
	}
	// 821DAA28: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821DAA2C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821DAA30: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821DAA34: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 821DAA38: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAA3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DAA40: 419A0014  beq cr6, 0x821daa54
	if ctx.cr[6].eq {
	pc = 0x821DAA54; continue 'dispatch;
	}
	// 821DAA44: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821DAA48: 7D65F0AE  lbzx r11, r5, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 821DAA4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DAA50: 409AFFF4  bne cr6, 0x821daa44
	if !ctx.cr[6].eq {
	pc = 0x821DAA44; continue 'dispatch;
	}
	// 821DAA54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821DAA58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DAA5C: 4802DD1D  bl 0x82208778
	ctx.lr = 0x821DAA60;
	sub_82208778(ctx, base);
	// 821DAA60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DAA64: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 821DAA68: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 821DAA6C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAA70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DAA74: 419A000C  beq cr6, 0x821daa80
	if ctx.cr[6].eq {
	pc = 0x821DAA80; continue 'dispatch;
	}
	// 821DAA78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821DAA7C: 4BFEBCED  bl 0x821c6768
	ctx.lr = 0x821DAA80;
	sub_821C6768(ctx, base);
	// 821DAA80: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821DAA84: 419A0008  beq cr6, 0x821daa8c
	if ctx.cr[6].eq {
	pc = 0x821DAA8C; continue 'dispatch;
	}
	// 821DAA88: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821DAA8C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821DAA90: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DAA94: 48ACE9C4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DAA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DAA98 size=176
    let mut pc: u32 = 0x821DAA98;
    'dispatch: loop {
        match pc {
            0x821DAA98 => {
    //   block [0x821DAA98..0x821DAB48)
	// 821DAA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DAA9C: 48ACE971  bl 0x82ca940c
	ctx.lr = 0x821DAAA0;
	sub_82CA93D0(ctx, base);
	// 821DAAA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DAAA4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821DAAA8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821DAAAC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821DAAB0: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 821DAAB4: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 821DAAB8: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821DAABC: 40990074  ble cr6, 0x821dab30
	if !ctx.cr[6].gt {
	pc = 0x821DAB30; continue 'dispatch;
	}
	// 821DAAC0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DAAC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DAAC8: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821DAACC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAAD0: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821DAAD4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821DAAD8: 4E800421  bctrl
	ctx.lr = 0x821DAADC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DAADC: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821DAAE0: 3BDF0070  addi r30, r31, 0x70
	ctx.r[30].s64 = ctx.r[31].s64 + 112;
	// 821DAAE4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821DAAE8: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DAB48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DAB48 size=204
    let mut pc: u32 = 0x821DAB48;
    'dispatch: loop {
        match pc {
            0x821DAB48 => {
    //   block [0x821DAB48..0x821DAC14)
	// 821DAB48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DAB4C: 48ACE8BD  bl 0x82ca9408
	ctx.lr = 0x821DAB50;
	sub_82CA93D0(ctx, base);
	// 821DAB50: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DAB54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821DAB58: 90A10058  stw r5, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 821DAB5C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821DAB60: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 821DAB64: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 821DAB68: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821DAB6C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821DAB70: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 821DAB74: 48039D25  bl 0x82214898
	ctx.lr = 0x821DAB78;
	sub_82214898(ctx, base);
	// 821DAB78: 817C0050  lwz r11, 0x50(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(80 as u32) ) } as u64;
	// 821DAB7C: 3BFC004C  addi r31, r28, 0x4c
	ctx.r[31].s64 = ctx.r[28].s64 + 76;
	// 821DAB80: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 821DAB84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DAB88: 409A000C  bne cr6, 0x821dab94
	if !ctx.cr[6].eq {
	pc = 0x821DAB94; continue 'dispatch;
	}
	// 821DAB8C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 821DAB90: 48000010  b 0x821daba0
	pc = 0x821DABA0; continue 'dispatch;
	// 821DAB94: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DAB98: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821DAB9C: 7D484BD6  divw r10, r8, r9
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 821DABA0: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DABA4: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 821DABA8: 7D2B4BD6  divw r9, r11, r9
	ctx.r[9].s32 = ctx.r[11].s32 / ctx.r[9].s32;
	// 821DABAC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DABB0: 40980024  bge cr6, 0x821dabd4
	if !ctx.cr[6].lt {
	pc = 0x821DABD4; continue 'dispatch;
	}
	// 821DABB4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821DABB8: 419A0010  beq cr6, 0x821dabc8
	if ctx.cr[6].eq {
	pc = 0x821DABC8; continue 'dispatch;
	}
	// 821DABBC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 821DABC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821DABC4: 483A53AD  bl 0x8257ff70
	ctx.lr = 0x821DABC8;
	sub_8257FF70(ctx, base);
	// 821DABC8: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 821DABCC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821DABD0: 48000020  b 0x821dabf0
	pc = 0x821DABF0; continue 'dispatch;
	// 821DABD4: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 821DABD8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821DABDC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821DABE0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821DABE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DABE8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DABEC: 4855285D  bl 0x8272d448
	ctx.lr = 0x821DABF0;
	sub_8272D448(ctx, base);
	// 821DABF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821DABF4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 821DABF8: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 821DABFC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821DAC00: 4BFB9239  bl 0x82193e38
	ctx.lr = 0x821DAC04;
	sub_82193E38(ctx, base);
	// 821DAC04: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821DAC08: 4809FB69  bl 0x8227a770
	ctx.lr = 0x821DAC0C;
	sub_8227A770(ctx, base);
	// 821DAC0C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821DAC10: 48ACE848  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DAC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DAC18 size=504
    let mut pc: u32 = 0x821DAC18;
    'dispatch: loop {
        match pc {
            0x821DAC18 => {
    //   block [0x821DAC18..0x821DAE10)
	// 821DAC18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DAC1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DAC20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821DAC24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DAC28: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 821DAC2C: 48AD30AD  bl 0x82cadcd8
	ctx.lr = 0x821DAC30;
	sub_82CADCA0(ctx, base);
	// 821DAC30: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DAE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DAE10 size=472
    let mut pc: u32 = 0x821DAE10;
    'dispatch: loop {
        match pc {
            0x821DAE10 => {
    //   block [0x821DAE10..0x821DAFE8)
	// 821DAE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DAE14: 48ACE5E1  bl 0x82ca93f4
	ctx.lr = 0x821DAE18;
	sub_82CA93D0(ctx, base);
	// 821DAE18: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 821DAE1C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DAE20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAE24: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 821DAE28: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821DAE2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DAE30: 4E800421  bctrl
	ctx.lr = 0x821DAE34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DAE34: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821DAE38: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821DAE3C: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 821DAE40: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821DAE44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DAE48: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 821DAE4C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAE50: 80E80020  lwz r7, 0x20(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DAE54: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821DAE58: 4E800421  bctrl
	ctx.lr = 0x821DAE5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DAE5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DAE60: 48025481  bl 0x822002e0
	ctx.lr = 0x821DAE64;
	sub_822002E0(ctx, base);
	// 821DAE64: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DAE68: 83210050  lwz r25, 0x50(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821DAE6C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821DAE70: 419A00B8  beq cr6, 0x821daf28
	if ctx.cr[6].eq {
	pc = 0x821DAF28; continue 'dispatch;
	}
	// 821DAE74: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 821DAE78: 38990024  addi r4, r25, 0x24
	ctx.r[4].s64 = ctx.r[25].s64 + 36;
	// 821DAE7C: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 821DAE80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DAE84: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 821DAE88: 48015469  bl 0x821f02f0
	ctx.lr = 0x821DAE8C;
	sub_821F02F0(ctx, base);
	// 821DAE8C: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 821DAE90: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 821DAE94: 83410064  lwz r26, 0x64(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821DAE98: 83010068  lwz r24, 0x68(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 821DAE9C: 7D5AC050  subf r10, r26, r24
	ctx.r[10].s64 = ctx.r[24].s64 - ctx.r[26].s64;
	// 821DAEA0: 7F8A5BD7  divw. r28, r10, r11
	ctx.r[28].s32 = ctx.r[10].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821DAEA4: 41820064  beq 0x821daf08
	if ctx.cr[0].eq {
	pc = 0x821DAF08; continue 'dispatch;
	}
	// 821DAEA8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821DAEAC: 3BFA0004  addi r31, r26, 4
	ctx.r[31].s64 = ctx.r[26].s64 + 4;
	// 821DAEB0: 3B6BFFDF  addi r27, r11, -0x21
	ctx.r[27].s64 = ctx.r[11].s64 + -33;
	// 821DAEB4: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAEB8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821DAEBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DAEC0: 419A000C  beq cr6, 0x821daecc
	if ctx.cr[6].eq {
	pc = 0x821DAECC; continue 'dispatch;
	}
	// 821DAEC4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DAEC8: 409A000C  bne cr6, 0x821daed4
	if !ctx.cr[6].eq {
	pc = 0x821DAED4; continue 'dispatch;
	}
	// 821DAECC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821DAED0: 48000008  b 0x821daed8
	pc = 0x821DAED8; continue 'dispatch;
	// 821DAED4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAED8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAEDC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821DAEE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DAEE4: 419A0008  beq cr6, 0x821daeec
	if ctx.cr[6].eq {
	pc = 0x821DAEEC; continue 'dispatch;
	}
	// 821DAEE8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAEEC: 48ACF205  bl 0x82caa0f0
	ctx.lr = 0x821DAEF0;
	sub_82CAA0F0(ctx, base);
	// 821DAEF0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821DAEF4: 419A0090  beq cr6, 0x821daf84
	if ctx.cr[6].eq {
	pc = 0x821DAF84; continue 'dispatch;
	}
	// 821DAEF8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821DAEFC: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 821DAF00: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821DAF04: 409AFFB0  bne cr6, 0x821daeb4
	if !ctx.cr[6].eq {
	pc = 0x821DAEB4; continue 'dispatch;
	}
	// 821DAF08: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821DAF0C: 419A001C  beq cr6, 0x821daf28
	if ctx.cr[6].eq {
	pc = 0x821DAF28; continue 'dispatch;
	}
	// 821DAF10: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821DAF14: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821DAF18: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821DAF1C: 4838BAF5  bl 0x82566a10
	ctx.lr = 0x821DAF20;
	sub_82566A10(ctx, base);
	// 821DAF20: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821DAF24: 48040E15  bl 0x8221bd38
	ctx.lr = 0x821DAF28;
	sub_8221BD38(ctx, base);
	// 821DAF28: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821DAF2C: 419A0044  beq cr6, 0x821daf70
	if ctx.cr[6].eq {
	pc = 0x821DAF70; continue 'dispatch;
	}
	// 821DAF30: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	// 821DAF34: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821DAF38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821DAF3C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821DAF40: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821DAF44: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821DAF48: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821DAF4C: 4082FFE8  bne 0x821daf34
	if !ctx.cr[0].eq {
	pc = 0x821DAF34; continue 'dispatch;
	}
	// 821DAF50: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821DAF54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DAF58: 409A0018  bne cr6, 0x821daf70
	if !ctx.cr[6].eq {
	pc = 0x821DAF70; continue 'dispatch;
	}
	// 821DAF5C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAF60: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821DAF64: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DAF68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DAF6C: 4E800421  bctrl
	ctx.lr = 0x821DAF70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DAF70: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DAF74: C02BD5C8  lfs f1, -0x2a38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821DAF78: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821DAF7C: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821DAF80: 48ACE4C4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
	// 821DAF84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DAF88: C3FFFFFC  lfs f31, -4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821DAF8C: 4881474D  bl 0x829ef6d8
	ctx.lr = 0x821DAF90;
	sub_829EF6D8(ctx, base);
	// 821DAF90: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821DAF94: 419A0044  beq cr6, 0x821dafd8
	if ctx.cr[6].eq {
	pc = 0x821DAFD8; continue 'dispatch;
	}
	// 821DAF98: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	// 821DAF9C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821DAFA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821DAFA4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821DAFA8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821DAFAC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821DAFB0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821DAFB4: 4082FFE8  bne 0x821daf9c
	if !ctx.cr[0].eq {
	pc = 0x821DAF9C; continue 'dispatch;
	}
	// 821DAFB8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821DAFBC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DAFC0: 409A0018  bne cr6, 0x821dafd8
	if !ctx.cr[6].eq {
	pc = 0x821DAFD8; continue 'dispatch;
	}
	// 821DAFC4: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAFC8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821DAFCC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DAFD0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DAFD4: 4E800421  bctrl
	ctx.lr = 0x821DAFD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DAFD8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821DAFDC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821DAFE0: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821DAFE4: 48ACE460  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DAFE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DAFE8 size=116
    let mut pc: u32 = 0x821DAFE8;
    'dispatch: loop {
        match pc {
            0x821DAFE8 => {
    //   block [0x821DAFE8..0x821DB05C)
	// 821DAFE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DAFEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DAFF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DAFF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DAFF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DAFFC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB000: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821DB004: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DB008: 4E800421  bctrl
	ctx.lr = 0x821DB00C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB00C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DB010: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DB014: 419A0030  beq cr6, 0x821db044
	if ctx.cr[6].eq {
	pc = 0x821DB044; continue 'dispatch;
	}
	// 821DB018: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DB01C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB020: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821DB024: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DB028: 4E800421  bctrl
	ctx.lr = 0x821DB02C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB02C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821DB030: 48000031  bl 0x821db060
	ctx.lr = 0x821DB034;
	sub_821DB060(ctx, base);
	// 821DB034: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DB038: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821DB03C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DB040: 409A0008  bne cr6, 0x821db048
	if !ctx.cr[6].eq {
	pc = 0x821DB048; continue 'dispatch;
	}
	// 821DB044: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821DB048: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821DB04C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DB050: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DB054: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821DB058: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DB060 size=108
    let mut pc: u32 = 0x821DB060;
    'dispatch: loop {
        match pc {
            0x821DB060 => {
    //   block [0x821DB060..0x821DB0CC)
	// 821DB060: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 821DB064: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 821DB068: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DB06C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821DB070: 7D093050  subf r8, r9, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 821DB074: 9141FFF0  stw r10, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u32 ) };
	// 821DB078: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 821DB07C: 9121FFF4  stw r9, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[9].u32 ) };
	// 821DB080: 7D685BD7  divw. r11, r8, r11
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DB084: 4081005C  ble 0x821db0e0
	if !ctx.cr[0].gt {
		sub_821DB0CC(ctx, base);
		return;
	}
	// 821DB088: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821DB08C: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DB090: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821DB094: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DB098: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821DB09C: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB0A0: 7F072000  cmpw cr6, r7, r4
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[4].s32, &mut ctx.xer);
	// 821DB0A4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821DB0A8: 41980008  blt cr6, 0x821db0b0
	if ctx.cr[6].lt {
	pc = 0x821DB0B0; continue 'dispatch;
	}
	// 821DB0AC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821DB0B0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821DB0B4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DB0B8: 419A0014  beq cr6, 0x821db0cc
	if ctx.cr[6].eq {
		sub_821DB0CC(ctx, base);
		return;
	}
	// 821DB0BC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821DB0C0: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 821DB0C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821DB0C8: 4800000C  b 0x821db0d4
	sub_821DB0CC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB0CC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DB0CC size=92
    let mut pc: u32 = 0x821DB0CC;
    'dispatch: loop {
        match pc {
            0x821DB0CC => {
    //   block [0x821DB0CC..0x821DB128)
	// 821DB0CC: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821DB0D0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821DB0D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DB0D8: 4199FFB0  bgt cr6, 0x821db088
	if ctx.cr[6].gt {
		sub_821DB060(ctx, base);
		return;
	}
	// 821DB0DC: 9121FFF4  stw r9, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[9].u32 ) };
	// 821DB0E0: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821DB0E4: 419A0044  beq cr6, 0x821db128
	if ctx.cr[6].eq {
		sub_821DB128(ctx, base);
		return;
	}
	// 821DB0E8: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB0EC: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821DB0F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DB0F4: 41980008  blt cr6, 0x821db0fc
	if ctx.cr[6].lt {
	pc = 0x821DB0FC; continue 'dispatch;
	}
	// 821DB0F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DB0FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DB100: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DB104: 409A0024  bne cr6, 0x821db128
	if !ctx.cr[6].eq {
		sub_821DB128(ctx, base);
		return;
	}
	// 821DB108: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821DB10C: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821DB110: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821DB114: 7D6B2850  subf r11, r11, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821DB118: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821DB11C: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821DB120: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 821DB124: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DB128 size=24
    let mut pc: u32 = 0x821DB128;
    'dispatch: loop {
        match pc {
            0x821DB128 => {
    //   block [0x821DB128..0x821DB140)
	// 821DB128: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821DB12C: 7D6B2850  subf r11, r11, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821DB130: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821DB134: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821DB138: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 821DB13C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DB140 size=640
    let mut pc: u32 = 0x821DB140;
    'dispatch: loop {
        match pc {
            0x821DB140 => {
    //   block [0x821DB140..0x821DB3C0)
	// 821DB140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DB144: 48ACE2C5  bl 0x82ca9408
	ctx.lr = 0x821DB148;
	sub_82CA93D0(ctx, base);
	// 821DB148: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 821DB14C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821DB150: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DB154: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DB158: 4808E409  bl 0x82269560
	ctx.lr = 0x821DB15C;
	sub_82269560(ctx, base);
	// 821DB15C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821DB160: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DB164: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DB168: 9B9F0020  stb r28, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[28].u8 ) };
	// 821DB16C: 4182005C  beq 0x821db1c8
	if ctx.cr[0].eq {
	pc = 0x821DB1C8; continue 'dispatch;
	}
	// 821DB170: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DB174: 83DF01DC  lwz r30, 0x1dc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 821DB178: 83AB0014  lwz r29, 0x14(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB17C: 4808583D  bl 0x822609b8
	ctx.lr = 0x821DB180;
	sub_822609B8(ctx, base);
	// 821DB180: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821DB184: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821DB188: 4BFD4C69  bl 0x821afdf0
	ctx.lr = 0x821DB18C;
	sub_821AFDF0(ctx, base);
	// 821DB18C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DB190: 41820038  beq 0x821db1c8
	if ctx.cr[0].eq {
	pc = 0x821DB1C8; continue 'dispatch;
	}
	// 821DB194: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DB198: 480EB589  bl 0x822c6720
	ctx.lr = 0x821DB19C;
	sub_822C6720(ctx, base);
	// 821DB19C: 987F01E0  stb r3, 0x1e0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[3].u8 ) };
	// 821DB1A0: 48085819  bl 0x822609b8
	ctx.lr = 0x821DB1A4;
	sub_822609B8(ctx, base);
	// 821DB1A4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DB1A8: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DB1AC: 83DF01DC  lwz r30, 0x1dc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 821DB1B0: D01F01E4  stfs f0, 0x1e4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 821DB1B4: 83AB0014  lwz r29, 0x14(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB1B8: 48085801  bl 0x822609b8
	ctx.lr = 0x821DB1BC;
	sub_822609B8(ctx, base);
	// 821DB1BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821DB1C0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821DB1C4: 480EA075  bl 0x822c5238
	ctx.lr = 0x821DB1C8;
	sub_822C5238(ctx, base);
	// 821DB1C8: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DB1CC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DB1D0: 41820038  beq 0x821db208
	if ctx.cr[0].eq {
	pc = 0x821DB208; continue 'dispatch;
	}
	// 821DB1D4: 897F01E0  lbz r11, 0x1e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 821DB1D8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DB1DC: 4182002C  beq 0x821db208
	if ctx.cr[0].eq {
	pc = 0x821DB208; continue 'dispatch;
	}
	// 821DB1E0: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821DB1E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DB1E8: 419A0028  beq cr6, 0x821db210
	if ctx.cr[6].eq {
	pc = 0x821DB210; continue 'dispatch;
	}
	// 821DB1EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821DB1F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DB1F4: 48C95DCD  bl 0x82e70fc0
	ctx.lr = 0x821DB1F8;
	sub_82E70FC0(ctx, base);
	// 821DB1F8: 480857C1  bl 0x822609b8
	ctx.lr = 0x821DB1FC;
	sub_822609B8(ctx, base);
	// 821DB1FC: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DB200: D01F01D0  stfs f0, 0x1d0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 821DB204: 4800000C  b 0x821db210
	pc = 0x821DB210; continue 'dispatch;
	// 821DB208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DB20C: 480C1DCD  bl 0x8229cfd8
	ctx.lr = 0x821DB210;
	sub_8229CFD8(ctx, base);
	// 821DB210: 897F01B0  lbz r11, 0x1b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 821DB214: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DB218: 41820194  beq 0x821db3ac
	if ctx.cr[0].eq {
	pc = 0x821DB3AC; continue 'dispatch;
	}
	// 821DB21C: 897F01E0  lbz r11, 0x1e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 821DB220: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DB224: 40820188  bne 0x821db3ac
	if !ctx.cr[0].eq {
	pc = 0x821DB3AC; continue 'dispatch;
	}
	// 821DB228: 897F01E1  lbz r11, 0x1e1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(481 as u32) ) } as u64;
	// 821DB22C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DB230: 4082017C  bne 0x821db3ac
	if !ctx.cr[0].eq {
	pc = 0x821DB3AC; continue 'dispatch;
	}
	// 821DB234: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB238: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB23C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821DB240: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DB244: 4E800421  bctrl
	ctx.lr = 0x821DB248;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB248: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB24C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821DB250: 389F0034  addi r4, r31, 0x34
	ctx.r[4].s64 = ctx.r[31].s64 + 52;
	// 821DB254: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821DB258: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB25C: C3EB0014  lfs f31, 0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821DB260: C3CB0018  lfs f30, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821DB264: 814A003C  lwz r10, 0x3c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 821DB268: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DB26C: 4E800421  bctrl
	ctx.lr = 0x821DB270;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB270: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB274: C03F01E8  lfs f1, 0x1e8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821DB278: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB27C: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821DB280: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DB284: 4E800421  bctrl
	ctx.lr = 0x821DB288;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB288: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821DB28C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821DB290: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 821DB294: C02A0C14  lfs f1, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821DB298: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DB29C: 4182000C  beq 0x821db2a8
	if ctx.cr[0].eq {
	pc = 0x821DB2A8; continue 'dispatch;
	}
	// 821DB2A0: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DB2A4: 48000008  b 0x821db2ac
	pc = 0x821DB2AC; continue 'dispatch;
	// 821DB2A8: FDA00890  fmr f13, f1
	ctx.f[13].f64 = ctx.f[1].f64;
	// 821DB2AC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DB2B0: 41820008  beq 0x821db2b8
	if ctx.cr[0].eq {
	pc = 0x821DB2B8; continue 'dispatch;
	}
	// 821DB2B4: C02B000C  lfs f1, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821DB2B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821DB2BC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB2C0: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DB2C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB2C8: EC4D0032  fmuls f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821DB2CC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821DB2D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DB2D4: 4E800421  bctrl
	ctx.lr = 0x821DB2D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB2D8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB2DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DB2E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DB2E4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB2E8: 4BFD3441  bl 0x821ae728
	ctx.lr = 0x821DB2EC;
	sub_821AE728(ctx, base);
	// 821DB2EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821DB2F0: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 821DB2F4: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB2F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DB2FC: 4E800421  bctrl
	ctx.lr = 0x821DB300;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB300: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821DB304: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 821DB308: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821DB30C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DB310: 41820048  beq 0x821db358
	if ctx.cr[0].eq {
	pc = 0x821DB358; continue 'dispatch;
	}
	// 821DB314: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB318: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DB31C: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DB320: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB324: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DB328: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DB32C: 4E800421  bctrl
	ctx.lr = 0x821DB330;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB330: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB334: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB338: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821DB33C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DB340: 4E800421  bctrl
	ctx.lr = 0x821DB344;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB344: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DB348: 41820010  beq 0x821db358
	if ctx.cr[0].eq {
	pc = 0x821DB358; continue 'dispatch;
	}
	// 821DB34C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DB350: 9B9F01E1  stb r28, 0x1e1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(481 as u32), ctx.r[28].u8 ) };
	// 821DB354: 997F01B0  stb r11, 0x1b0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[11].u8 ) };
	// 821DB358: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB35C: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821DB360: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821DB364: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB368: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821DB36C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DB370: 4E800421  bctrl
	ctx.lr = 0x821DB374;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB374: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB378: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821DB37C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB380: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821DB384: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DB388: 4E800421  bctrl
	ctx.lr = 0x821DB38C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB38C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB390: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB394: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DB398: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DB39C: 4E800421  bctrl
	ctx.lr = 0x821DB3A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB3A0: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 821DB3A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821DB3A8: 419A0008  beq cr6, 0x821db3b0
	if ctx.cr[6].eq {
	pc = 0x821DB3B0; continue 'dispatch;
	}
	// 821DB3AC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821DB3B0: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 821DB3B4: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821DB3B8: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821DB3BC: 48ACE09C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB3C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DB3C0 size=372
    let mut pc: u32 = 0x821DB3C0;
    'dispatch: loop {
        match pc {
            0x821DB3C0 => {
    //   block [0x821DB3C0..0x821DB534)
	// 821DB3C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DB3C4: 48ACE045  bl 0x82ca9408
	ctx.lr = 0x821DB3C8;
	sub_82CA93D0(ctx, base);
	// 821DB3C8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821DB3CC: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DB3D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DB3D4: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 821DB3D8: 3BA00030  li r29, 0x30
	ctx.r[29].s64 = 48;
	// 821DB3DC: 3BC00010  li r30, 0x10
	ctx.r[30].s64 = 16;
	// 821DB3E0: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DB538 size=80
    let mut pc: u32 = 0x821DB538;
    'dispatch: loop {
        match pc {
            0x821DB538 => {
    //   block [0x821DB538..0x821DB588)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DB588 size=24
    let mut pc: u32 = 0x821DB588;
    'dispatch: loop {
        match pc {
            0x821DB588 => {
    //   block [0x821DB588..0x821DB5A0)
	// 821DB588: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 821DB58C: 394B2AF0  addi r10, r11, 0x2af0
	ctx.r[10].s64 = ctx.r[11].s64 + 10992;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DB5A0 size=56
    let mut pc: u32 = 0x821DB5A0;
    'dispatch: loop {
        match pc {
            0x821DB5A0 => {
    //   block [0x821DB5A0..0x821DB5D8)
	// 821DB5A0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821DB5A4: 419A0018  beq cr6, 0x821db5bc
	if ctx.cr[6].eq {
	pc = 0x821DB5BC; continue 'dispatch;
	}
	// 821DB5A8: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821DB5AC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821DB5B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DB5B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DB5B8: 409A0008  bne cr6, 0x821db5c0
	if !ctx.cr[6].eq {
	pc = 0x821DB5C0; continue 'dispatch;
	}
	// 821DB5BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DB5C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DB5C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DB5C8: 419A0010  beq cr6, 0x821db5d8
	if ctx.cr[6].eq {
		sub_821DB5D8(ctx, base);
		return;
	}
	// 821DB5CC: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 821DB5D0: 5563FFFE  rlwinm r3, r11, 0x1f, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821DB5D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DB5D8 size=8
    let mut pc: u32 = 0x821DB5D8;
    'dispatch: loop {
        match pc {
            0x821DB5D8 => {
    //   block [0x821DB5D8..0x821DB5E0)
	// 821DB5D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821DB5DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB5E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DB5E0 size=828
    let mut pc: u32 = 0x821DB5E0;
    'dispatch: loop {
        match pc {
            0x821DB5E0 => {
    //   block [0x821DB5E0..0x821DB91C)
	// 821DB5E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DB5E4: 48ACDE25  bl 0x82ca9408
	ctx.lr = 0x821DB5E8;
	sub_82CA93D0(ctx, base);
	// 821DB5E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DB5EC: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821DB5F0: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821DB5F4: 3BCB2390  addi r30, r11, 0x2390
	ctx.r[30].s64 = ctx.r[11].s64 + 9104;
	// 821DB5F8: 390A7E70  addi r8, r10, 0x7e70
	ctx.r[8].s64 = ctx.r[10].s64 + 32368;
	// 821DB5FC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821DB600: 38FE2008  addi r7, r30, 0x2008
	ctx.r[7].s64 = ctx.r[30].s64 + 8200;
	// 821DB604: 98C10050  stb r6, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u8 ) };
	// 821DB608: 817E2004  lwz r11, 0x2004(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB60C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821DB610: 7D0BF12E  stwx r8, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[8].u32) };
	// 821DB614: 815E2004  lwz r10, 0x2004(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB618: 813E2000  lwz r9, 0x2000(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821DB61C: 817E400C  lwz r11, 0x400c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821DB620: 55661838  slwi r6, r11, 3
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821DB624: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 821DB628: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821DB62C: 917E2004  stw r11, 0x2004(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8196 as u32), ctx.r[11].u32 ) };
	// 821DB630: 915E2000  stw r10, 0x2000(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8192 as u32), ctx.r[10].u32 ) };
	// 821DB634: 7D06392E  stwx r8, r6, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32), ctx.r[8].u32) };
	// 821DB638: 817E400C  lwz r11, 0x400c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821DB63C: 815E4008  lwz r10, 0x4008(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16392 as u32) ) } as u64;
	// 821DB640: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821DB644: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821DB648: 915E4008  stw r10, 0x4008(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16392 as u32), ctx.r[10].u32 ) };
	// 821DB64C: 917E400C  stw r11, 0x400c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16396 as u32), ctx.r[11].u32 ) };
	// 821DB650: 816406FC  lwz r11, 0x6fc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821DB654: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821DB658: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821DB65C: 419A00C4  beq cr6, 0x821db720
	if ctx.cr[6].eq {
	pc = 0x821DB720; continue 'dispatch;
	}
	// 821DB660: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 821DB664: 894B0045  lbz r10, 0x45(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(69 as u32) ) } as u64;
	// 821DB668: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821DB66C: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s64 = ctx.r[10].s64 * 8200;
	// 821DB670: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 821DB674: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DB678: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821DB67C: 419A0090  beq cr6, 0x821db70c
	if ctx.cr[6].eq {
	pc = 0x821DB70C; continue 'dispatch;
	}
	// 821DB680: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821DB684: 810B0038  lwz r8, 0x38(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821DB688: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821DB68C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DB690: 409A003C  bne cr6, 0x821db6cc
	if !ctx.cr[6].eq {
	pc = 0x821DB6CC; continue 'dispatch;
	}
	// 821DB694: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB698: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821DB69C: 38CB0030  addi r6, r11, 0x30
	ctx.r[6].s64 = ctx.r[11].s64 + 48;
	// 821DB6A0: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DB6A4: 912B0038  stw r9, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 821DB6A8: 7CC8512E  stwx r6, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 821DB6AC: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821DB6B0: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB6B4: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DB6B8: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821DB6BC: 91260004  stw r9, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821DB6C0: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB6C4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821DB6C8: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	// 821DB6CC: 894B0044  lbz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821DB6D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821DB6D4: 912B0034  stw r9, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[9].u32 ) };
	// 821DB6D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DB6DC: 409A0030  bne cr6, 0x821db70c
	if !ctx.cr[6].eq {
	pc = 0x821DB70C; continue 'dispatch;
	}
	// 821DB6E0: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821DB6E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DB6E8: 390B0030  addi r8, r11, 0x30
	ctx.r[8].s64 = ctx.r[11].s64 + 48;
	// 821DB6EC: 994B0044  stb r10, 0x44(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 821DB6F0: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821DB6F4: 81690DB0  lwz r11, 0xdb0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821DB6F8: 38C70DB8  addi r6, r7, 0xdb8
	ctx.r[6].s64 = ctx.r[7].s64 + 3512;
	// 821DB6FC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821DB700: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821DB704: 91690DB0  stw r11, 0xdb0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3504 as u32), ctx.r[11].u32 ) };
	// 821DB708: 7D0A312E  stwx r8, r10, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32), ctx.r[8].u32) };
	// 821DB70C: 4805EB05  bl 0x8223a210
	ctx.lr = 0x821DB710;
	sub_8223A210(ctx, base);
	// 821DB710: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DB714: 48043BCD  bl 0x8221f2e0
	ctx.lr = 0x821DB718;
	sub_8221F2E0(ctx, base);
	// 821DB718: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DB71C: 48ACDD3C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821DB720: 3BEB63A0  addi r31, r11, 0x63a0
	ctx.r[31].s64 = ctx.r[11].s64 + 25504;
	// 821DB724: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DB728: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 821DB72C: 3B8B0DB8  addi r28, r11, 0xdb8
	ctx.r[28].s64 = ctx.r[11].s64 + 3512;
	// 821DB730: 897F0045  lbz r11, 0x45(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(69 as u32) ) } as u64;
	// 821DB734: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821DB738: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 * 8200;
	// 821DB73C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821DB740: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 821DB744: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821DB748: 419A0084  beq cr6, 0x821db7cc
	if ctx.cr[6].eq {
	pc = 0x821DB7CC; continue 'dispatch;
	}
	// 821DB74C: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821DB750: 813F0038  lwz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821DB754: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821DB758: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821DB75C: 409A003C  bne cr6, 0x821db798
	if !ctx.cr[6].eq {
	pc = 0x821DB798; continue 'dispatch;
	}
	// 821DB760: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB764: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821DB768: 38FF0030  addi r7, r31, 0x30
	ctx.r[7].s64 = ctx.r[31].s64 + 48;
	// 821DB76C: 55061838  slwi r6, r8, 3
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821DB770: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 821DB774: 7CE6592E  stwx r7, r6, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 821DB778: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821DB77C: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB780: 54A91838  slwi r9, r5, 3
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821DB784: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821DB788: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821DB78C: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB790: 390A0001  addi r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 1;
	// 821DB794: 910B2004  stw r8, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	// 821DB798: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 821DB79C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DB7A0: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 821DB7A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DB7A8: 409A0024  bne cr6, 0x821db7cc
	if !ctx.cr[6].eq {
	pc = 0x821DB7CC; continue 'dispatch;
	}
	// 821DB7AC: 817D0DB0  lwz r11, 0xdb0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821DB7B0: 393F0030  addi r9, r31, 0x30
	ctx.r[9].s64 = ctx.r[31].s64 + 48;
	// 821DB7B4: 995F0044  stb r10, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 821DB7B8: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821DB7BC: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 821DB7C0: 911D0DB0  stw r8, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[8].u32 ) };
	// 821DB7C4: 7D27E12E  stwx r9, r7, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	// 821DB7C8: 48000008  b 0x821db7d0
	pc = 0x821DB7D0; continue 'dispatch;
	// 821DB7CC: 811D0DB0  lwz r8, 0xdb0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821DB7D0: 897F002D  lbz r11, 0x2d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(45 as u32) ) } as u64;
	// 821DB7D4: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DB7D8: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 * 8200;
	// 821DB7DC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821DB7E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DB7E4: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821DB7E8: 419A0080  beq cr6, 0x821db868
	if ctx.cr[6].eq {
	pc = 0x821DB868; continue 'dispatch;
	}
	// 821DB7EC: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821DB7F0: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DB7F4: 7D474838  and r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821DB7F8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DB7FC: 409A003C  bne cr6, 0x821db838
	if !ctx.cr[6].eq {
	pc = 0x821DB838; continue 'dispatch;
	}
	// 821DB800: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB804: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821DB808: 38DF0018  addi r6, r31, 0x18
	ctx.r[6].s64 = ctx.r[31].s64 + 24;
	// 821DB80C: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821DB810: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821DB814: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821DB818: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB81C: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DB820: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821DB824: 7CE95A14  add r7, r9, r11
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821DB828: 91470004  stw r10, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821DB82C: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB830: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 821DB834: 90CB2004  stw r6, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	// 821DB838: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821DB83C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821DB840: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 821DB844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DB848: 409A0020  bne cr6, 0x821db868
	if !ctx.cr[6].eq {
	pc = 0x821DB868; continue 'dispatch;
	}
	// 821DB84C: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821DB850: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DB854: 38FF0018  addi r7, r31, 0x18
	ctx.r[7].s64 = ctx.r[31].s64 + 24;
	// 821DB858: 39480001  addi r10, r8, 1
	ctx.r[10].s64 = ctx.r[8].s64 + 1;
	// 821DB85C: 997F002C  stb r11, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u8 ) };
	// 821DB860: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821DB864: 7CE9E12E  stwx r7, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[7].u32) };
	// 821DB868: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821DB86C: 4805E9A5  bl 0x8223a210
	ctx.lr = 0x821DB870;
	sub_8223A210(ctx, base);
	// 821DB870: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DB874: 895F002D  lbz r10, 0x2d(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(45 as u32) ) } as u64;
	// 821DB878: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 821DB87C: 1D6A2008  mulli r11, r10, 0x2008
	ctx.r[11].s64 = ctx.r[10].s64 * 8200;
	// 821DB880: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821DB884: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821DB888: 419A0084  beq cr6, 0x821db90c
	if ctx.cr[6].eq {
	pc = 0x821DB90C; continue 'dispatch;
	}
	// 821DB88C: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821DB890: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DB894: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821DB898: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821DB89C: 409A003C  bne cr6, 0x821db8d8
	if !ctx.cr[6].eq {
	pc = 0x821DB8D8; continue 'dispatch;
	}
	// 821DB8A0: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB8A4: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821DB8A8: 38FF0018  addi r7, r31, 0x18
	ctx.r[7].s64 = ctx.r[31].s64 + 24;
	// 821DB8AC: 55061838  slwi r6, r8, 3
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821DB8B0: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821DB8B4: 7CE6592E  stwx r7, r6, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 821DB8B8: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB8BC: 54A91838  slwi r9, r5, 3
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821DB8C0: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DB8C4: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821DB8C8: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821DB8CC: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB8D0: 386A0001  addi r3, r10, 1
	ctx.r[3].s64 = ctx.r[10].s64 + 1;
	// 821DB8D4: 906B2004  stw r3, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[3].u32 ) };
	// 821DB8D8: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821DB8DC: 3940000F  li r10, 0xf
	ctx.r[10].s64 = 15;
	// 821DB8E0: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 821DB8E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DB8E8: 409A0024  bne cr6, 0x821db90c
	if !ctx.cr[6].eq {
	pc = 0x821DB90C; continue 'dispatch;
	}
	// 821DB8EC: 817D0DB0  lwz r11, 0xdb0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821DB8F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DB8F4: 393F0018  addi r9, r31, 0x18
	ctx.r[9].s64 = ctx.r[31].s64 + 24;
	// 821DB8F8: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DB8FC: 995F002C  stb r10, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u8 ) };
	// 821DB900: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821DB904: 917D0DB0  stw r11, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[11].u32 ) };
	// 821DB908: 7D28E12E  stwx r9, r8, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	// 821DB90C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DB910: 480439D1  bl 0x8221f2e0
	ctx.lr = 0x821DB914;
	sub_8221F2E0(ctx, base);
	// 821DB914: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DB918: 48ACDB40  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DB920 size=124
    let mut pc: u32 = 0x821DB920;
    'dispatch: loop {
        match pc {
            0x821DB920 => {
    //   block [0x821DB920..0x821DB99C)
	// 821DB920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DB924: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DB928: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821DB92C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DB930: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DB934: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DB938: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821DB93C: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 821DB940: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DB9A0 size=516
    let mut pc: u32 = 0x821DB9A0;
    'dispatch: loop {
        match pc {
            0x821DB9A0 => {
    //   block [0x821DB9A0..0x821DBBA4)
	// 821DB9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DB9A4: 48ACDA51  bl 0x82ca93f4
	ctx.lr = 0x821DB9A8;
	sub_82CA93D0(ctx, base);
	// 821DB9A8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DB9AC: 3EE0820A  lis r23, -0x7df6
	ctx.r[23].s64 = -2113273856;
	// 821DB9B0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821DB9B4: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 821DB9B8: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 821DB9BC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821DB9C0: C0179484  lfs f0, -0x6b7c(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DB9C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DB9C8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821DB9CC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821DB9D0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821DB9D4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821DB9D8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821DB9DC: 4080FFF0  bge 0x821db9cc
	if !ctx.cr[0].lt {
	pc = 0x821DB9CC; continue 'dispatch;
	}
	// 821DB9E0: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB9E4: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821DB9E8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821DB9EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821DB9F0: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 821DB9F4: 4BFF520D  bl 0x821d0c00
	ctx.lr = 0x821DB9F8;
	sub_821D0C00(ctx, base);
	// 821DB9F8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821DB9FC: 3BFD0110  addi r31, r29, 0x110
	ctx.r[31].s64 = ctx.r[29].s64 + 272;
	// 821DBA00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821DBA04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DBA08: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821DBA0C: 480A4835  bl 0x82280240
	ctx.lr = 0x821DBA10;
	sub_82280240(ctx, base);
	// 821DBA10: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821DBA14: 3BDD0114  addi r30, r29, 0x114
	ctx.r[30].s64 = ctx.r[29].s64 + 276;
	// 821DBA18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821DBA1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821DBA20: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821DBA24: 480A481D  bl 0x82280240
	ctx.lr = 0x821DBA28;
	sub_82280240(ctx, base);
	// 821DBA28: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821DBA2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DBA30: 4BFE7469  bl 0x821c2e98
	ctx.lr = 0x821DBA34;
	sub_821C2E98(ctx, base);
	// 821DBA34: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821DBA38: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821DBA3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821DBA40: 4BFE7459  bl 0x821c2e98
	ctx.lr = 0x821DBA44;
	sub_821C2E98(ctx, base);
	// 821DBA44: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821DBA48: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821DBA4C: 3BEBDED4  addi r31, r11, -0x212c
	ctx.r[31].s64 = ctx.r[11].s64 + -8492;
	// 821DBA50: 793EFFE6  rldicr r30, r9, 0x3f, 0x3f
	ctx.r[30].u64 = (ctx.r[9].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821DBA54: 3F608336  lis r27, -0x7cca
	ctx.r[27].s64 = -2093613056;
	// 821DBA58: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821DBA5C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBA60: 808B0A74  lwz r4, 0xa74(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2676 as u32) ) } as u64;
	// 821DBA64: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821DBA68: 41980020  blt cr6, 0x821dba88
	if ctx.cr[6].lt {
	pc = 0x821DBA88; continue 'dispatch;
	}
	// 821DBA6C: 39640020  addi r11, r4, 0x20
	ctx.r[11].s64 = ctx.r[4].s64 + 32;
	// 821DBA70: 807B0364  lwz r3, 0x364(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(868 as u32) ) } as u64;
	// 821DBA74: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBA78: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821DBA7C: 7FC65436  srd r6, r30, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[30].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821DBA80: 4BFDB461  bl 0x821b6ee0
	ctx.lr = 0x821DBA84;
	sub_821B6EE0(ctx, base);
	// 821DBA84: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBA88: 808B0A80  lwz r4, 0xa80(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2688 as u32) ) } as u64;
	// 821DBA8C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821DBA90: 4198001C  blt cr6, 0x821dbaac
	if ctx.cr[6].lt {
	pc = 0x821DBAAC; continue 'dispatch;
	}
	// 821DBA94: 39640020  addi r11, r4, 0x20
	ctx.r[11].s64 = ctx.r[4].s64 + 32;
	// 821DBA98: 807B0364  lwz r3, 0x364(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(868 as u32) ) } as u64;
	// 821DBA9C: 80BA0004  lwz r5, 4(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBAA0: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821DBAA4: 7FC65436  srd r6, r30, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[30].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821DBAA8: 4BFDB439  bl 0x821b6ee0
	ctx.lr = 0x821DBAAC;
	sub_821B6EE0(ctx, base);
	// 821DBAAC: 386000E1  li r3, 0xe1
	ctx.r[3].s64 = 225;
	// 821DBAB0: C0210068  lfs f1, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821DBAB4: 4800D1C5  bl 0x821e8c78
	ctx.lr = 0x821DBAB8;
	sub_821E8C78(ctx, base);
	// 821DBAB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821DBABC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821DBAC0: 480394F1  bl 0x82214fb0
	ctx.lr = 0x821DBAC4;
	sub_82214FB0(ctx, base);
	// 821DBAC4: 8979070A  lbz r11, 0x70a(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(1802 as u32) ) } as u64;
	// 821DBAC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DBACC: 409A0030  bne cr6, 0x821dbafc
	if !ctx.cr[6].eq {
	pc = 0x821DBAFC; continue 'dispatch;
	}
	// 821DBAD0: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 821DBAD4: 419A0024  beq cr6, 0x821dbaf8
	if ctx.cr[6].eq {
	pc = 0x821DBAF8; continue 'dispatch;
	}
	// 821DBAD8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821DBADC: 894BCBD2  lbz r10, -0x342e(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-13358 as u32) ) } as u64;
	// 821DBAE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DBAE4: 419A0014  beq cr6, 0x821dbaf8
	if ctx.cr[6].eq {
	pc = 0x821DBAF8; continue 'dispatch;
	}
	// 821DBAE8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821DBAEC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821DBAF0: 48892FB9  bl 0x82a6eaa8
	ctx.lr = 0x821DBAF4;
	sub_82A6EAA8(ctx, base);
	// 821DBAF4: 48000008  b 0x821dbafc
	pc = 0x821DBAFC; continue 'dispatch;
	// 821DBAF8: 480925A1  bl 0x8226e098
	ctx.lr = 0x821DBAFC;
	sub_8226E098(ctx, base);
	// 821DBAFC: 3860010A  li r3, 0x10a
	ctx.r[3].s64 = 266;
	// 821DBB00: C03D004C  lfs f1, 0x4c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821DBB04: 4800D175  bl 0x821e8c78
	ctx.lr = 0x821DBB08;
	sub_821E8C78(ctx, base);
	// 821DBB08: 38600109  li r3, 0x109
	ctx.r[3].s64 = 265;
	// 821DBB0C: C03D0050  lfs f1, 0x50(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821DBB10: 4800D169  bl 0x821e8c78
	ctx.lr = 0x821DBB14;
	sub_821E8C78(ctx, base);
	// 821DBB14: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DBB18: C0179484  lfs f0, -0x6b7c(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DBB1C: 39400690  li r10, 0x690
	ctx.r[10].s64 = 1680;
	// 821DBB20: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821DBB24: 392B91A0  addi r9, r11, -0x6e60
	ctx.r[9].s64 = ctx.r[11].s64 + -28256;
	// 821DBB28: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821DBB2C: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821DBB30: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821DBB34: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 821DBB38: 798CDFE6  rldicr r12, r12, 0x3b, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(59) & 0xFFFFFFFFFFFFFFFF;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DBBA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DBBA8 size=308
    let mut pc: u32 = 0x821DBBA8;
    'dispatch: loop {
        match pc {
            0x821DBBA8 => {
    //   block [0x821DBBA8..0x821DBCDC)
	// 821DBBA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DBBAC: 48ACD859  bl 0x82ca9404
	ctx.lr = 0x821DBBB0;
	sub_82CA93D0(ctx, base);
	// 821DBBB0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DBBB4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821DBBB8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821DBBBC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821DBBC0: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 821DBBC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821DBBC8: 48024BA9  bl 0x82200770
	ctx.lr = 0x821DBBCC;
	sub_82200770(ctx, base);
	// 821DBBCC: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DBBD0: 480E9E51  bl 0x822c5a20
	ctx.lr = 0x821DBBD4;
	sub_822C5A20(ctx, base);
	// 821DBBD4: 807B0010  lwz r3, 0x10(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DBBD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821DBBDC: 419A0008  beq cr6, 0x821dbbe4
	if ctx.cr[6].eq {
	pc = 0x821DBBE4; continue 'dispatch;
	}
	// 821DBBE0: 480C6FA9  bl 0x822a2b88
	ctx.lr = 0x821DBBE4;
	sub_822A2B88(ctx, base);
	// 821DBBE4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBBE8: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DBBEC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DBBF0: 419A00D0  beq cr6, 0x821dbcc0
	if ctx.cr[6].eq {
	pc = 0x821DBCC0; continue 'dispatch;
	}
	// 821DBBF4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DBBF8: 3BEB0030  addi r31, r11, 0x30
	ctx.r[31].s64 = ctx.r[11].s64 + 48;
	// 821DBBFC: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 821DBC00: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821DBC04: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821DBC08: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DBC0C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821DBC10: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBC14: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821DBC18: 419A000C  beq cr6, 0x821dbc24
	if ctx.cr[6].eq {
	pc = 0x821DBC24; continue 'dispatch;
	}
	// 821DBC1C: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821DBC20: 419A0008  beq cr6, 0x821dbc28
	if ctx.cr[6].eq {
	pc = 0x821DBC28; continue 'dispatch;
	}
	// 821DBC24: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DBC28: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DBC2C: 419A007C  beq cr6, 0x821dbca8
	if ctx.cr[6].eq {
	pc = 0x821DBCA8; continue 'dispatch;
	}
	// 821DBC30: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821DBC34: 409A0008  bne cr6, 0x821dbc3c
	if !ctx.cr[6].eq {
	pc = 0x821DBC3C; continue 'dispatch;
	}
	// 821DBC38: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DBC3C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBC40: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DBC44: 409A0008  bne cr6, 0x821dbc4c
	if !ctx.cr[6].eq {
	pc = 0x821DBC4C; continue 'dispatch;
	}
	// 821DBC48: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DBC4C: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DBC50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DBC54: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DBC58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DBC5C: 4E800421  bctrl
	ctx.lr = 0x821DBC60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DBC60: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DBC64: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DBC68: 419A001C  beq cr6, 0x821dbc84
	if ctx.cr[6].eq {
	pc = 0x821DBC84; continue 'dispatch;
	}
	// 821DBC6C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBC70: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DBC74: 409A0008  bne cr6, 0x821dbc7c
	if !ctx.cr[6].eq {
	pc = 0x821DBC7C; continue 'dispatch;
	}
	// 821DBC78: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DBC7C: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DBC80: 4BFFFF8C  b 0x821dbc0c
	pc = 0x821DBC0C; continue 'dispatch;
	// 821DBC84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DBC88: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DBC8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DBC90: 48084A61  bl 0x822606f0
	ctx.lr = 0x821DBC94;
	sub_822606F0(ctx, base);
	// 821DBC94: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821DBC98: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821DBC9C: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821DBCA0: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821DBCA4: 4BFFFF6C  b 0x821dbc10
	pc = 0x821DBC10; continue 'dispatch;
	// 821DBCA8: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBCAC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DBCB0: 409A0008  bne cr6, 0x821dbcb8
	if !ctx.cr[6].eq {
	pc = 0x821DBCB8; continue 'dispatch;
	}
	// 821DBCB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DBCB8: 839C0000  lwz r28, 0(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DBCBC: 4BFFFF30  b 0x821dbbec
	pc = 0x821DBBEC; continue 'dispatch;
	// 821DBCC0: 8941005C  lbz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821DBCC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DBCC8: 419A000C  beq cr6, 0x821dbcd4
	if ctx.cr[6].eq {
	pc = 0x821DBCD4; continue 'dispatch;
	}
	// 821DBCCC: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821DBCD0: 490DDC85  bl 0x832b9954
	ctx.lr = 0x821DBCD4;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 821DBCD4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821DBCD8: 48ACD77C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DBCE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DBCE0 size=20
    let mut pc: u32 = 0x821DBCE0;
    'dispatch: loop {
        match pc {
            0x821DBCE0 => {
    //   block [0x821DBCE0..0x821DBCF4)
	// 821DBCE0: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DBCE4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821DBCE8: 894B0011  lbz r10, 0x11(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 821DBCEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DBCF0: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DBCF4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DBCF4 size=8
    let mut pc: u32 = 0x821DBCF4;
    'dispatch: loop {
        match pc {
            0x821DBCF4 => {
    //   block [0x821DBCF4..0x821DBCFC)
	// 821DBCF4: 886B0010  lbz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DBCF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DBD00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DBD00 size=140
    let mut pc: u32 = 0x821DBD00;
    'dispatch: loop {
        match pc {
            0x821DBD00 => {
    //   block [0x821DBD00..0x821DBD8C)
	// 821DBD00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DBD04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DBD08: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DBD0C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBD10: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 821DBD14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DBD18: 409A000C  bne cr6, 0x821dbd24
	if !ctx.cr[6].eq {
	pc = 0x821DBD24; continue 'dispatch;
	}
	// 821DBD1C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821DBD20: 48000010  b 0x821dbd30
	pc = 0x821DBD30; continue 'dispatch;
	// 821DBD24: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DBD28: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821DBD2C: 7D291670  srawi r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 821DBD30: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DBD34: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821DBD38: 7D481670  srawi r8, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 821DBD3C: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821DBD40: 40980024  bge cr6, 0x821dbd64
	if !ctx.cr[6].lt {
	pc = 0x821DBD64; continue 'dispatch;
	}
	// 821DBD44: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DBD48: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 821DBD4C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821DBD50: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821DBD54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821DBD58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DBD5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DBD60: 4E800020  blr
	return;
	// 821DBD64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821DBD68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821DBD6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821DBD70: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821DBD74: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DBD78: 48286739  bl 0x824624b0
	ctx.lr = 0x821DBD7C;
	sub_824624B0(ctx, base);
	// 821DBD7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821DBD80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DBD84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DBD88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DBD90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DBD90 size=436
    let mut pc: u32 = 0x821DBD90;
    'dispatch: loop {
        match pc {
            0x821DBD90 => {
    //   block [0x821DBD90..0x821DBF44)
	// 821DBD90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DBD94: 48ACD665  bl 0x82ca93f8
	ctx.lr = 0x821DBD98;
	sub_82CA93D0(ctx, base);
	// 821DBD98: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 821DBD9C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DBDA0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821DBDA4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821DBDA8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821DBDAC: 38A00009  li r5, 9
	ctx.r[5].s64 = 9;
	// 821DBDB0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821DBDB4: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 821DBDB8: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 821DBDBC: 480186C5  bl 0x821f4480
	ctx.lr = 0x821DBDC0;
	sub_821F4480(ctx, base);
	// 821DBDC0: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 821DBDC4: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821DBDC8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DBDCC: 419A0168  beq cr6, 0x821dbf34
	if ctx.cr[6].eq {
	pc = 0x821DBF34; continue 'dispatch;
	}
	// 821DBDD0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DBDD4: 3D207FFF  lis r9, 0x7fff
	ctx.r[9].s64 = 2147418112;
	// 821DBDD8: 3B0000D0  li r24, 0xd0
	ctx.r[24].s64 = 208;
	// 821DBDDC: 613BFFFF  ori r27, r9, 0xffff
	ctx.r[27].u64 = ctx.r[9].u64 | 65535;
	// 821DBDE0: C3EB9A80  lfs f31, -0x6580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821DBDE4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DBDE8: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821DBDEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DBDF0: 419A0018  beq cr6, 0x821dbe08
	if ctx.cr[6].eq {
	pc = 0x821DBE08; continue 'dispatch;
	}
	// 821DBDF4: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DBDF8: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821DBDFC: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821DBE00: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DBE04: 41980008  blt cr6, 0x821dbe0c
	if ctx.cr[6].lt {
	pc = 0x821DBE0C; continue 'dispatch;
	}
	// 821DBE08: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DBE0C: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821DBE10: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821DBE14: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821DBE18: 7FEA582E  lwzx r31, r10, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821DBE1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DBE20: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DBE24: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821DBE28: 81090068  lwz r8, 0x68(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(104 as u32) ) } as u64;
	// 821DBE2C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821DBE30: 4E800421  bctrl
	ctx.lr = 0x821DBE34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DBE34: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DBE38: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DBE3C: 419A00E0  beq cr6, 0x821dbf1c
	if ctx.cr[6].eq {
	pc = 0x821DBF1C; continue 'dispatch;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DBF48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DBF48 size=384
    let mut pc: u32 = 0x821DBF48;
    'dispatch: loop {
        match pc {
            0x821DBF48 => {
    //   block [0x821DBF48..0x821DC0C8)
	// 821DBF48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DBF4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DBF50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DBF54: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821DBF58: 419A0018  beq cr6, 0x821dbf70
	if ctx.cr[6].eq {
	pc = 0x821DBF70; continue 'dispatch;
	}
	// 821DBF5C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821DBF60: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821DBF64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DBF68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DBF6C: 409A0008  bne cr6, 0x821dbf74
	if !ctx.cr[6].eq {
	pc = 0x821DBF74; continue 'dispatch;
	}
	// 821DBF70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DBF74: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DBF78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DBF7C: 419A0134  beq cr6, 0x821dc0b0
	if ctx.cr[6].eq {
	pc = 0x821DC0B0; continue 'dispatch;
	}
	// 821DBF80: 81440028  lwz r10, 0x28(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 821DBF84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DBF88: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 821DBF8C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DBF90: 419A00EC  beq cr6, 0x821dc07c
	if ctx.cr[6].eq {
	pc = 0x821DC07C; continue 'dispatch;
	}
	// 821DBF94: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 821DBF98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DBF9C: 419A0020  beq cr6, 0x821dbfbc
	if ctx.cr[6].eq {
	pc = 0x821DBFBC; continue 'dispatch;
	}
	// 821DBFA0: 894B0022  lbz r10, 0x22(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(34 as u32) ) } as u64;
	// 821DBFA4: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DBFA8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821DBFAC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821DBFB0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DBFB4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBFB8: 480000C8  b 0x821dc080
	pc = 0x821DC080; continue 'dispatch;
	// 821DBFBC: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DBFC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DBFC4: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 821DBFC8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821DBFCC: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821DBFD0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821DBFD4: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DBFD8: 40810054  ble 0x821dc02c
	if !ctx.cr[0].gt {
	pc = 0x821DC02C; continue 'dispatch;
	}
	// 821DBFDC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821DBFE0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DBFE4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821DBFE8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DBFEC: 2F070022  cmpwi cr6, r7, 0x22
	ctx.cr[6].compare_i32(ctx.r[7].s32, 34, &mut ctx.xer);
	// 821DBFF0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821DBFF4: 41980008  blt cr6, 0x821dbffc
	if ctx.cr[6].lt {
	pc = 0x821DBFFC; continue 'dispatch;
	}
	// 821DBFF8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821DBFFC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821DC000: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DC004: 419A0014  beq cr6, 0x821dc018
	if ctx.cr[6].eq {
	pc = 0x821DC018; continue 'dispatch;
	}
	// 821DC008: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821DC00C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821DC010: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821DC014: 4800000C  b 0x821dc020
	pc = 0x821DC020; continue 'dispatch;
	// 821DC018: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821DC01C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821DC020: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DC024: 4199FFB8  bgt cr6, 0x821dbfdc
	if ctx.cr[6].gt {
	pc = 0x821DBFDC; continue 'dispatch;
	}
	// 821DC028: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821DC02C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821DC030: 419A003C  beq cr6, 0x821dc06c
	if ctx.cr[6].eq {
	pc = 0x821DC06C; continue 'dispatch;
	}
	// 821DC034: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DC038: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 821DC03C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DC040: 41990008  bgt cr6, 0x821dc048
	if ctx.cr[6].gt {
	pc = 0x821DC048; continue 'dispatch;
	}
	// 821DC044: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DC048: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DC04C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DC050: 409A001C  bne cr6, 0x821dc06c
	if !ctx.cr[6].eq {
	pc = 0x821DC06C; continue 'dispatch;
	}
	// 821DC054: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DC058: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DC05C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821DC060: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821DC064: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC068: 48000018  b 0x821dc080
	pc = 0x821DC080; continue 'dispatch;
	// 821DC06C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821DC070: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DC074: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC078: 48000008  b 0x821dc080
	pc = 0x821DC080; continue 'dispatch;
	// 821DC07C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821DC080: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821DC084: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DC088: 419A0028  beq cr6, 0x821dc0b0
	if ctx.cr[6].eq {
	pc = 0x821DC0B0; continue 'dispatch;
	}
	// 821DC08C: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DC090: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DC094: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821DC098: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821DC09C: 4E800421  bctrl
	ctx.lr = 0x821DC0A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DC0A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821DC0A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DC0A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DC0AC: 4E800020  blr
	return;
	// 821DC0B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DC0B4: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821DC0B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821DC0BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DC0C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DC0C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DC0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DC0C8 size=144
    let mut pc: u32 = 0x821DC0C8;
    'dispatch: loop {
        match pc {
            0x821DC0C8 => {
    //   block [0x821DC0C8..0x821DC158)
	// 821DC0C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DC0CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DC0D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DC0D4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821DC0D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DC0DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DC0E0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821DC0E4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821DC0E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DC158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DC158 size=24
    let mut pc: u32 = 0x821DC158;
    'dispatch: loop {
        match pc {
            0x821DC158 => {
    //   block [0x821DC158..0x821DC170)
	// 821DC158: 81432E48  lwz r10, 0x2e48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(11848 as u32) ) } as u64;
	// 821DC15C: 81632E4C  lwz r11, 0x2e4c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(11852 as u32) ) } as u64;
	// 821DC160: 508A06FE  rlwimi r10, r4, 0, 0x1b, 0x1f
	ctx.r[10].u64 = (((ctx.r[4].u32).rotate_left(0) as u64) & 0x000000000000001F) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFFE0);
	// 821DC164: 55690001  rlwinm. r9, r11, 0, 0, 0
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821DC168: 91432E48  stw r10, 0x2e48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(11848 as u32), ctx.r[10].u32 ) };
	// 821DC16C: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DC170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DC170 size=100
    let mut pc: u32 = 0x821DC170;
    'dispatch: loop {
        match pc {
            0x821DC170 => {
    //   block [0x821DC170..0x821DC1D4)
	// 821DC170: 556A0043  rlwinm. r10, r11, 0, 1, 1
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821DC174: 81632E48  lwz r11, 0x2e48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(11848 as u32) ) } as u64;
	// 821DC178: 40820024  bne 0x821dc19c
	if !ctx.cr[0].eq {
	pc = 0x821DC19C; continue 'dispatch;
	}
	// 821DC17C: 716A1010  andi. r10, r11, 0x1010
	ctx.r[10].u64 = ctx.r[11].u64 & 4112;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821DC180: 55692336  rlwinm r9, r11, 4, 0xc, 0x1b
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 821DC184: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821DC188: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821DC18C: 554A601E  rlwinm r10, r10, 0xc, 0, 0xf
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 821DC190: 554A0314  rlwinm r10, r10, 0, 0xc, 0xa
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821DC194: 554A0104  rlwinm r10, r10, 0, 4, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821DC198: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 821DC19C: 91632938  stw r11, 0x2938(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10552 as u32), ctx.r[11].u32 ) };
	// 821DC1A0: 91632958  stw r11, 0x2958(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10584 as u32), ctx.r[11].u32 ) };
	// 821DC1A4: 9163295C  stw r11, 0x295c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10588 as u32), ctx.r[11].u32 ) };
	// 821DC1A8: 91632960  stw r11, 0x2960(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10592 as u32), ctx.r[11].u32 ) };
	// 821DC1AC: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 821DC1B0: 616B0400  ori r11, r11, 0x400
	ctx.r[11].u64 = ctx.r[11].u64 | 1024;
	// 821DC1B4: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821DC1B8: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 821DC1BC: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821DC1C0: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 821DC1C4: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821DC1C8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821DC1CC: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821DC1D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DC1D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DC1D8 size=148
    let mut pc: u32 = 0x821DC1D8;
    'dispatch: loop {
        match pc {
            0x821DC1D8 => {
    //   block [0x821DC1D8..0x821DC26C)
	// 821DC1D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DC1DC: 48ACD22D  bl 0x82ca9408
	ctx.lr = 0x821DC1E0;
	sub_82CA93D0(ctx, base);
	// 821DC1E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DC1E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821DC1E8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821DC1EC: 7F1CF040  cmplw cr6, r28, r30
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821DC1F0: 419A0070  beq cr6, 0x821dc260
	if ctx.cr[6].eq {
	pc = 0x821DC260; continue 'dispatch;
	}
	// 821DC1F4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC1F8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821DC1FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DC200: 40990060  ble cr6, 0x821dc260
	if !ctx.cr[6].gt {
	pc = 0x821DC260; continue 'dispatch;
	}
	// 821DC204: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821DC208: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC20C: 7C8BF82E  lwzx r4, r11, r31
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821DC210: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DC214: 41820038  beq 0x821dc24c
	if ctx.cr[0].eq {
	pc = 0x821DC24C; continue 'dispatch;
	}
	// 821DC218: 89640004  lbz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC21C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DC220: 4182002C  beq 0x821dc24c
	if ctx.cr[0].eq {
	pc = 0x821DC24C; continue 'dispatch;
	}
	// 821DC224: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC228: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821DC22C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DC230: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC234: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DC238: 4E800421  bctrl
	ctx.lr = 0x821DC23C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DC23C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC240: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DC244: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821DC248: 994B0004  stb r10, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 821DC24C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC250: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821DC254: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821DC258: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821DC25C: 4198FFAC  blt cr6, 0x821dc208
	if ctx.cr[6].lt {
	pc = 0x821DC208; continue 'dispatch;
	}
	// 821DC260: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821DC264: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DC268: 48ACD1F0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DC270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DC270 size=916
    let mut pc: u32 = 0x821DC270;
    'dispatch: loop {
        match pc {
            0x821DC270 => {
    //   block [0x821DC270..0x821DC604)
	// 821DC270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DC274: 48ACD181  bl 0x82ca93f4
	ctx.lr = 0x821DC278;
	sub_82CA93D0(ctx, base);
	// 821DC278: DBC1FFA0  stfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 821DC27C: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 821DC280: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DC284: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 821DC288: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821DC28C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DC290: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 821DC294: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 821DC298: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821DC29C: 807C6AB8  lwz r3, 0x6ab8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821DC2A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821DC2A4: 419A0010  beq cr6, 0x821dc2b4
	if ctx.cr[6].eq {
	pc = 0x821DC2B4; continue 'dispatch;
	}
	// 821DC2A8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DC2AC: 896B6A5E  lbz r11, 0x6a5e(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27230 as u32) ) } as u64;
	// 821DC2B0: 48000008  b 0x821dc2b8
	pc = 0x821DC2B8; continue 'dispatch;
	// 821DC2B4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821DC2B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DC2BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DC2C0: 419A0114  beq cr6, 0x821dc3d4
	if ctx.cr[6].eq {
	pc = 0x821DC3D4; continue 'dispatch;
	}
	// 821DC2C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DC2C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821DC2CC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DC2D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DC2D4: 4E800421  bctrl
	ctx.lr = 0x821DC2D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DC2D8: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821DC2DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821DC2E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821DC2E4: 83C90004  lwz r30, 4(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC2E8: 389E0038  addi r4, r30, 0x38
	ctx.r[4].s64 = ctx.r[30].s64 + 56;
	// 821DC2EC: 48024485  bl 0x82200770
	ctx.lr = 0x821DC2F0;
	sub_82200770(ctx, base);
	// 821DC2F0: 88E10074  lbz r7, 0x74(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821DC2F4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DC2F8: 83DE0080  lwz r30, 0x80(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 821DC2FC: 419A000C  beq cr6, 0x821dc308
	if ctx.cr[6].eq {
	pc = 0x821DC308; continue 'dispatch;
	}
	// 821DC300: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 821DC304: 490DD651  bl 0x832b9954
	ctx.lr = 0x821DC308;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 821DC308: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DC30C: DBC10088  stfd f30, 0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.f[30].u64 ) };
	// 821DC310: 9B610085  stb r27, 0x85(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(133 as u32), ctx.r[27].u8 ) };
	// 821DC314: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 821DC318: 7D2AF050  subf r9, r10, r30
	ctx.r[9].s64 = ctx.r[30].s64 - ctx.r[10].s64;
	// 821DC31C: 817C6AB8  lwz r11, 0x6ab8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821DC320: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821DC324: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821DC328: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821DC32C: 5507DFFE  rlwinm r7, r8, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 821DC330: 98E10084  stb r7, 0x84(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[7].u8 ) };
	// 821DC334: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DC338: 80A60058  lwz r5, 0x58(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(88 as u32) ) } as u64;
	// 821DC33C: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC340: 48003A91  bl 0x821dfdd0
	ctx.lr = 0x821DC344;
	sub_821DFDD0(ctx, base);
	// 821DC344: 809D000C  lwz r4, 0xc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DC348: 8064009C  lwz r3, 0x9c(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(156 as u32) ) } as u64;
	// 821DC34C: 4801C47D  bl 0x821f87c8
	ctx.lr = 0x821DC350;
	sub_821F87C8(ctx, base);
	// 821DC350: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821DC354: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821DC358: 419A029C  beq cr6, 0x821dc5f4
	if ctx.cr[6].eq {
	pc = 0x821DC5F4; continue 'dispatch;
	}
	// 821DC35C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821DC360: 48001051  bl 0x821dd3b0
	ctx.lr = 0x821DC364;
	sub_821DD3B0(ctx, base);
	// 821DC364: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DC368: C1A100E0  lfs f13, 0xe0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DC36C: 3BCBFE2C  addi r30, r11, -0x1d4
	ctx.r[30].s64 = ctx.r[11].s64 + -468;
	// 821DC370: C01E94A8  lfs f0, -0x6b58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27480 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DC374: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821DC378: 4805DC19  bl 0x82239f90
	ctx.lr = 0x821DC37C;
	sub_82239F90(ctx, base);
	// 821DC37C: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821DC380: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 821DC384: 390100D0  addi r8, r1, 0xd0
	ctx.r[8].s64 = ctx.r[1].s64 + 208;
	// 821DC388: C01E9664  lfs f0, -0x699c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27036 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DC38C: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 821DC390: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DC608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DC608 size=12
    let mut pc: u32 = 0x821DC608;
    'dispatch: loop {
        match pc {
            0x821DC608 => {
    //   block [0x821DC608..0x821DC614)
	// 821DC608: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821DC60C: 386B8E60  addi r3, r11, -0x71a0
	ctx.r[3].s64 = ctx.r[11].s64 + -29088;
	// 821DC610: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DC618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DC618 size=556
    let mut pc: u32 = 0x821DC618;
    'dispatch: loop {
        match pc {
            0x821DC618 => {
    //   block [0x821DC618..0x821DC844)
	// 821DC618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DC61C: 48ACCDE9  bl 0x82ca9404
	ctx.lr = 0x821DC620;
	sub_82CA93D0(ctx, base);
	// 821DC620: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DC624: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DC628: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821DC62C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821DC630: 38AA79B0  addi r5, r10, 0x79b0
	ctx.r[5].s64 = ctx.r[10].s64 + 31152;
	// 821DC634: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DC638: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821DC63C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DC640: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 821DC644: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC648: 83670010  lwz r27, 0x10(r7)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DC64C: 4804B97D  bl 0x82227fc8
	ctx.lr = 0x821DC650;
	sub_82227FC8(ctx, base);
	// 821DC650: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DC654: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821DC658: 409A0018  bne cr6, 0x821dc670
	if !ctx.cr[6].eq {
	pc = 0x821DC670; continue 'dispatch;
	}
	// 821DC65C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DC660: 48275CA9  bl 0x82452308
	ctx.lr = 0x821DC664;
	sub_82452308(ctx, base);
	// 821DC664: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821DC668: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821DC66C: 48ACCDE8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 821DC670: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DC674: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC678: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821DC67C: 3BCB9700  addi r30, r11, -0x6900
	ctx.r[30].s64 = ctx.r[11].s64 + -26880;
	// 821DC680: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DC684: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821DC688: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821DC68C: 2F080018  cmpwi cr6, r8, 0x18
	ctx.cr[6].compare_i32(ctx.r[8].s32, 24, &mut ctx.xer);
	// 821DC690: 409A0034  bne cr6, 0x821dc6c4
	if !ctx.cr[6].eq {
	pc = 0x821DC6C4; continue 'dispatch;
	}
	// 821DC694: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821DC698: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DC69C: 40980028  bge cr6, 0x821dc6c4
	if !ctx.cr[6].lt {
	pc = 0x821DC6C4; continue 'dispatch;
	}
	// 821DC6A0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821DC6A4: 419A0020  beq cr6, 0x821dc6c4
	if ctx.cr[6].eq {
	pc = 0x821DC6C4; continue 'dispatch;
	}
	// 821DC6A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC6AC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821DC6B0: 409A0014  bne cr6, 0x821dc6c4
	if !ctx.cr[6].eq {
	pc = 0x821DC6C4; continue 'dispatch;
	}
	// 821DC6B4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821DC6B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DC6BC: 4805BA15  bl 0x822380d0
	ctx.lr = 0x821DC6C0;
	sub_822380D0(ctx, base);
	// 821DC6C0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821DC6C4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821DC6C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DC6CC: 4804BA2D  bl 0x822280f8
	ctx.lr = 0x821DC6D0;
	sub_822280F8(ctx, base);
	// 821DC6D0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DC6D4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC6D8: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DC6DC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DC6E0: 40980138  bge cr6, 0x821dc818
	if !ctx.cr[6].lt {
	pc = 0x821DC818; continue 'dispatch;
	}
	// 821DC6E4: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821DC6E8: 419A003C  beq cr6, 0x821dc724
	if ctx.cr[6].eq {
	pc = 0x821DC724; continue 'dispatch;
	}
	// 821DC6EC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC6F0: 2F090003  cmpwi cr6, r9, 3
	ctx.cr[6].compare_i32(ctx.r[9].s32, 3, &mut ctx.xer);
	// 821DC6F4: 409A0030  bne cr6, 0x821dc724
	if !ctx.cr[6].eq {
	pc = 0x821DC724; continue 'dispatch;
	}
	// 821DC6F8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821DC6FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DC700: 4805B9D1  bl 0x822380d0
	ctx.lr = 0x821DC704;
	sub_822380D0(ctx, base);
	// 821DC704: E97D0008  ld r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 821DC708: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821DC70C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821DC710: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 821DC714: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821DC718: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821DC71C: 4BFBA4D5  bl 0x82196bf0
	ctx.lr = 0x821DC720;
	sub_82196BF0(ctx, base);
	// 821DC720: 480000BC  b 0x821dc7dc
	pc = 0x821DC7DC; continue 'dispatch;
	// 821DC724: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DC728: 409800F0  bge cr6, 0x821dc818
	if !ctx.cr[6].lt {
	pc = 0x821DC818; continue 'dispatch;
	}
	// 821DC72C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821DC730: 419A00E8  beq cr6, 0x821dc818
	if ctx.cr[6].eq {
	pc = 0x821DC818; continue 'dispatch;
	}
	// 821DC734: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC738: 2F090004  cmpwi cr6, r9, 4
	ctx.cr[6].compare_i32(ctx.r[9].s32, 4, &mut ctx.xer);
	// 821DC73C: 409A00DC  bne cr6, 0x821dc818
	if !ctx.cr[6].eq {
	pc = 0x821DC818; continue 'dispatch;
	}
	// 821DC740: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DC744: 41980008  blt cr6, 0x821dc74c
	if ctx.cr[6].lt {
	pc = 0x821DC74C; continue 'dispatch;
	}
	// 821DC748: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821DC74C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC750: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 821DC754: 419A0050  beq cr6, 0x821dc7a4
	if ctx.cr[6].eq {
	pc = 0x821DC7A4; continue 'dispatch;
	}
	// 821DC758: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821DC75C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DC760: 480C25F9  bl 0x8229ed58
	ctx.lr = 0x821DC764;
	sub_8229ED58(ctx, base);
	// 821DC764: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821DC768: 409A000C  bne cr6, 0x821dc774
	if !ctx.cr[6].eq {
	pc = 0x821DC774; continue 'dispatch;
	}
	// 821DC76C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DC770: 4800003C  b 0x821dc7ac
	pc = 0x821DC7AC; continue 'dispatch;
	// 821DC774: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DC778: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821DC77C: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821DC780: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821DC784: 4198000C  blt cr6, 0x821dc790
	if ctx.cr[6].lt {
	pc = 0x821DC790; continue 'dispatch;
	}
	// 821DC788: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DC78C: 4BF9CDF5  bl 0x82179580
	ctx.lr = 0x821DC790;
	sub_82179580(ctx, base);
	// 821DC790: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DC794: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC798: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DC79C: 41980008  blt cr6, 0x821dc7a4
	if ctx.cr[6].lt {
	pc = 0x821DC7A4; continue 'dispatch;
	}
	// 821DC7A0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821DC7A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DC7A8: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821DC7AC: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821DC7B0: E95D0008  ld r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 821DC7B4: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 821DC7B8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821DC7BC: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821DC7C0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821DC7C4: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 821DC7C8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 821DC7CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821DC7D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821DC7D4: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 821DC7D8: 480F9F31  bl 0x822d6708
	ctx.lr = 0x821DC7DC;
	sub_822D6708(ctx, base);
	// 821DC7DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821DC7E0: 419A0038  beq cr6, 0x821dc818
	if ctx.cr[6].eq {
	pc = 0x821DC818; continue 'dispatch;
	}
	// 821DC7E4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC7E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DC7EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821DC7F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DC7F4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821DC7F8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821DC7FC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC800: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 821DC804: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821DC808: 48222449  bl 0x823fec50
	ctx.lr = 0x821DC80C;
	sub_823FEC50(ctx, base);
	// 821DC80C: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 821DC810: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821DC814: 48ACCC40  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 821DC818: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC81C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821DC820: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DC824: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821DC828: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821DC82C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821DC830: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC834: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 821DC838: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821DC83C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821DC840: 48ACCC14  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DC848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DC848 size=600
    let mut pc: u32 = 0x821DC848;
    'dispatch: loop {
        match pc {
            0x821DC848 => {
    //   block [0x821DC848..0x821DCAA0)
	// 821DC848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DC84C: 48ACCBBD  bl 0x82ca9408
	ctx.lr = 0x821DC850;
	sub_82CA93D0(ctx, base);
	// 821DC850: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 821DC854: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 821DC858: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821DC85C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DC860: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DCAA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DCAA0 size=128
    let mut pc: u32 = 0x821DCAA0;
    'dispatch: loop {
        match pc {
            0x821DCAA0 => {
    //   block [0x821DCAA0..0x821DCB20)
	// 821DCAA0: 81632E4C  lwz r11, 0x2e4c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(11852 as u32) ) } as u64;
	// 821DCAA4: 508BF800  rlwimi r11, r4, 0x1f, 0, 0
	ctx.r[11].u64 = (((ctx.r[4].u32).rotate_left(31) as u64) & 0x0000000080000000) | (ctx.r[11].u64 & 0xFFFFFFFF7FFFFFFF);
	// 821DCAA8: 91632E4C  stw r11, 0x2e4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(11852 as u32), ctx.r[11].u32 ) };
	// 821DCAAC: 556A0043  rlwinm. r10, r11, 0, 1, 1
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821DCAB0: 81632E48  lwz r11, 0x2e48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(11848 as u32) ) } as u64;
	// 821DCAB4: 40820024  bne 0x821dcad8
	if !ctx.cr[0].eq {
	pc = 0x821DCAD8; continue 'dispatch;
	}
	// 821DCAB8: 716A1010  andi. r10, r11, 0x1010
	ctx.r[10].u64 = ctx.r[11].u64 & 4112;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821DCABC: 55692336  rlwinm r9, r11, 4, 0xc, 0x1b
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 821DCAC0: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821DCAC4: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821DCAC8: 554A601E  rlwinm r10, r10, 0xc, 0, 0xf
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 821DCACC: 554A0314  rlwinm r10, r10, 0, 0xc, 0xa
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821DCAD0: 554A0104  rlwinm r10, r10, 0, 4, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821DCAD4: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 821DCAD8: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821DCADC: 409A000C  bne cr6, 0x821dcae8
	if !ctx.cr[6].eq {
	pc = 0x821DCAE8; continue 'dispatch;
	}
	// 821DCAE0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821DCAE4: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821DCAE8: 9163295C  stw r11, 0x295c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10588 as u32), ctx.r[11].u32 ) };
	// 821DCAEC: 91632938  stw r11, 0x2938(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10552 as u32), ctx.r[11].u32 ) };
	// 821DCAF0: 91632958  stw r11, 0x2958(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10584 as u32), ctx.r[11].u32 ) };
	// 821DCAF4: 91632960  stw r11, 0x2960(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10592 as u32), ctx.r[11].u32 ) };
	// 821DCAF8: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 821DCAFC: 616B0400  ori r11, r11, 0x400
	ctx.r[11].u64 = ctx.r[11].u64 | 1024;
	// 821DCB00: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821DCB04: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 821DCB08: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821DCB0C: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 821DCB10: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821DCB14: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821DCB18: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821DCB1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DCB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DCB20 size=1136
    let mut pc: u32 = 0x821DCB20;
    'dispatch: loop {
        match pc {
            0x821DCB20 => {
    //   block [0x821DCB20..0x821DCF90)
	// 821DCB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DCB24: 48ACC8AD  bl 0x82ca93d0
	ctx.lr = 0x821DCB28;
	sub_82CA93D0(ctx, base);
	// 821DCB28: DBC1FF58  stfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 821DCB2C: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 821DCB30: 3980FF40  li r12, -0xc0
	ctx.r[12].s64 = -192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DCF90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DCF90 size=416
    let mut pc: u32 = 0x821DCF90;
    'dispatch: loop {
        match pc {
            0x821DCF90 => {
    //   block [0x821DCF90..0x821DD130)
	// 821DCF90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DCF94: 48ACC465  bl 0x82ca93f8
	ctx.lr = 0x821DCF98;
	sub_82CA93D0(ctx, base);
	// 821DCF98: 8163013C  lwz r11, 0x13c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(316 as u32) ) } as u64;
	// 821DCF9C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821DCFA0: 81430138  lwz r10, 0x138(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(312 as u32) ) } as u64;
	// 821DCFA4: 38E30100  addi r7, r3, 0x100
	ctx.r[7].s64 = ctx.r[3].s64 + 256;
	// 821DCFA8: 81230134  lwz r9, 0x134(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(308 as u32) ) } as u64;
	// 821DCFAC: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 821DCFB0: 3BEAFFFF  addi r31, r10, -1
	ctx.r[31].s64 = ctx.r[10].s64 + -1;
	// 821DCFB4: 81030130  lwz r8, 0x130(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(304 as u32) ) } as u64;
	// 821DCFB8: 3BC9FFFF  addi r30, r9, -1
	ctx.r[30].s64 = ctx.r[9].s64 + -1;
	// 821DCFBC: 83840010  lwz r28, 0x10(r4)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DCFC0: 7CBBFE70  srawi r27, r5, 0x1f
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[5].s32 >> 31) as i64;
	// 821DCFC4: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 821DCFC8: 7FFAFE70  srawi r26, r31, 0x1f
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[31].s32 >> 31) as i64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DD130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DD130 size=416
    let mut pc: u32 = 0x821DD130;
    'dispatch: loop {
        match pc {
            0x821DD130 => {
    //   block [0x821DD130..0x821DD2D0)
	// 821DD130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DD134: 48ACC2C5  bl 0x82ca93f8
	ctx.lr = 0x821DD138;
	sub_82CA93D0(ctx, base);
	// 821DD138: 816300BC  lwz r11, 0xbc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(188 as u32) ) } as u64;
	// 821DD13C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821DD140: 814300B8  lwz r10, 0xb8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(184 as u32) ) } as u64;
	// 821DD144: 38E300A0  addi r7, r3, 0xa0
	ctx.r[7].s64 = ctx.r[3].s64 + 160;
	// 821DD148: 812300B4  lwz r9, 0xb4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(180 as u32) ) } as u64;
	// 821DD14C: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 821DD150: 3BEAFFFF  addi r31, r10, -1
	ctx.r[31].s64 = ctx.r[10].s64 + -1;
	// 821DD154: 810300B0  lwz r8, 0xb0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) } as u64;
	// 821DD158: 3BC9FFFF  addi r30, r9, -1
	ctx.r[30].s64 = ctx.r[9].s64 + -1;
	// 821DD15C: 83840010  lwz r28, 0x10(r4)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DD160: 7CBBFE70  srawi r27, r5, 0x1f
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[5].s32 >> 31) as i64;
	// 821DD164: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 821DD168: 7FFAFE70  srawi r26, r31, 0x1f
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[31].s32 >> 31) as i64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DD2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DD2D0 size=224
    let mut pc: u32 = 0x821DD2D0;
    'dispatch: loop {
        match pc {
            0x821DD2D0 => {
    //   block [0x821DD2D0..0x821DD3B0)
	// 821DD2D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DD2D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DD2D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821DD2DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DD2E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DD2E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821DD2E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821DD2EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DD2F0: 997F0700  stb r11, 0x700(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1792 as u32), ctx.r[11].u8 ) };
	// 821DD2F4: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DD2F8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821DD2FC: 419A009C  beq cr6, 0x821dd398
	if ctx.cr[6].eq {
	pc = 0x821DD398; continue 'dispatch;
	}
	// 821DD300: 480CCF41  bl 0x822aa240
	ctx.lr = 0x821DD304;
	sub_822AA240(ctx, base);
	// 821DD304: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DD308: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821DD30C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821DD310: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DD314: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DD318: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821DD31C: 4E800421  bctrl
	ctx.lr = 0x821DD320;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DD320: 57C8063E  clrlwi r8, r30, 0x18
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 821DD324: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821DD328: 419A0008  beq cr6, 0x821dd330
	if ctx.cr[6].eq {
	pc = 0x821DD330; continue 'dispatch;
	}
	// 821DD32C: 480B200D  bl 0x8228f338
	ctx.lr = 0x821DD330;
	sub_8228F338(ctx, base);
	// 821DD330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DD334: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DD338: 4BFEFFD9  bl 0x821cd310
	ctx.lr = 0x821DD33C;
	sub_821CD310(ctx, base);
	// 821DD33C: 48046815  bl 0x82223b50
	ctx.lr = 0x821DD340;
	sub_82223B50(ctx, base);
	// 821DD340: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 821DD344: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 821DD348: 38A00060  li r5, 0x60
	ctx.r[5].s64 = 96;
	// 821DD34C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821DD350: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821DD354: 4BFBFA15  bl 0x8219cd68
	ctx.lr = 0x821DD358;
	sub_8219CD68(ctx, base);
	// 821DD358: 480443E9  bl 0x82221740
	ctx.lr = 0x821DD35C;
	sub_82221740(ctx, base);
	// 821DD35C: 38C00050  li r6, 0x50
	ctx.r[6].s64 = 80;
	// 821DD360: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 821DD364: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821DD368: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821DD36C: 4BFBF9FD  bl 0x8219cd68
	ctx.lr = 0x821DD370;
	sub_8219CD68(ctx, base);
	// 821DD370: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DD374: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821DD378: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821DD37C: 894B70D3  lbz r10, 0x70d3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28883 as u32) ) } as u64;
	// 821DD380: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DD384: 419A0010  beq cr6, 0x821dd394
	if ctx.cr[6].eq {
	pc = 0x821DD394; continue 'dispatch;
	}
	// 821DD388: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821DD38C: 489C49B5  bl 0x82ba1d40
	ctx.lr = 0x821DD390;
	sub_82BA1D40(ctx, base);
	// 821DD390: 48000008  b 0x821dd398
	pc = 0x821DD398; continue 'dispatch;
	// 821DD394: 4808825D  bl 0x822655f0
	ctx.lr = 0x821DD398;
	sub_822655F0(ctx, base);
	// 821DD398: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821DD39C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DD3A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DD3A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821DD3A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821DD3AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DD3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DD3B0 size=288
    let mut pc: u32 = 0x821DD3B0;
    'dispatch: loop {
        match pc {
            0x821DD3B0 => {
    //   block [0x821DD3B0..0x821DD4D0)
	// 821DD3B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DD3B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DD3B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DD3BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DD3C0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DD3C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DD3C8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821DD3CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DD3D0: 419A0010  beq cr6, 0x821dd3e0
	if ctx.cr[6].eq {
	pc = 0x821DD3E0; continue 'dispatch;
	}
	// 821DD3D4: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821DD3D8: 894A6A5E  lbz r10, 0x6a5e(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(27230 as u32) ) } as u64;
	// 821DD3DC: 48000008  b 0x821dd3e4
	pc = 0x821DD3E4; continue 'dispatch;
	// 821DD3E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821DD3E4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821DD3E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DD3EC: 419A0058  beq cr6, 0x821dd444
	if ctx.cr[6].eq {
	pc = 0x821DD444; continue 'dispatch;
	}
	// 821DD3F0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DD3F4: 894B0104  lbz r10, 0x104(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 821DD3F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DD3FC: 409A0048  bne cr6, 0x821dd444
	if !ctx.cr[6].eq {
	pc = 0x821DD444; continue 'dispatch;
	}
	// 821DD400: 80640004  lwz r3, 4(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DD404: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821DD408: 419A0030  beq cr6, 0x821dd438
	if ctx.cr[6].eq {
	pc = 0x821DD438; continue 'dispatch;
	}
	// 821DD40C: 48088B85  bl 0x82265f90
	ctx.lr = 0x821DD410;
	sub_82265F90(ctx, base);
	// 821DD410: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821DD414: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 821DD418: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821DD41C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821DD420: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821DD424: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821DD428: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821DD42C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821DD430: 4200FFF0  bdnz 0x821dd420
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821DD420; continue 'dispatch;
	}
	// 821DD434: 48000084  b 0x821dd4b8
	pc = 0x821DD4B8; continue 'dispatch;
	// 821DD438: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DD43C: 4826143D  bl 0x8243e878
	ctx.lr = 0x821DD440;
	sub_8243E878(ctx, base);
	// 821DD440: 48000078  b 0x821dd4b8
	pc = 0x821DD4B8; continue 'dispatch;
	// 821DD444: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DD448: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 821DD44C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 821DD450: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821DD454: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821DD458: 38E99140  addi r7, r9, -0x6ec0
	ctx.r[7].s64 = ctx.r[9].s64 + -28352;
	// 821DD45C: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DD460: 38C89150  addi r6, r8, -0x6eb0
	ctx.r[6].s64 = ctx.r[8].s64 + -28336;
	// 821DD464: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821DD468: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DD4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DD4D0 size=328
    let mut pc: u32 = 0x821DD4D0;
    'dispatch: loop {
        match pc {
            0x821DD4D0 => {
    //   block [0x821DD4D0..0x821DD618)
	// 821DD4D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DD4D4: 48ACBF39  bl 0x82ca940c
	ctx.lr = 0x821DD4D8;
	sub_82CA93D0(ctx, base);
	// 821DD4D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DD4DC: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 821DD4E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DD4E4: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DD4E8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821DD4EC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821DD4F0: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821DD4F4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821DD4F8: 7D2B2671  srawi. r11, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 4) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DD4FC: 40810054  ble 0x821dd550
	if !ctx.cr[0].gt {
	pc = 0x821DD550; continue 'dispatch;
	}
	// 821DD500: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821DD504: 55282036  slwi r8, r9, 4
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DD508: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821DD50C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DD510: 7F072000  cmpw cr6, r7, r4
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[4].s32, &mut ctx.xer);
	// 821DD514: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821DD518: 41980008  blt cr6, 0x821dd520
	if ctx.cr[6].lt {
	pc = 0x821DD520; continue 'dispatch;
	}
	// 821DD51C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821DD520: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821DD524: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DD528: 419A0014  beq cr6, 0x821dd53c
	if ctx.cr[6].eq {
	pc = 0x821DD53C; continue 'dispatch;
	}
	// 821DD52C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821DD530: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 821DD534: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821DD538: 4800000C  b 0x821dd544
	pc = 0x821DD544; continue 'dispatch;
	// 821DD53C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821DD540: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821DD544: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DD548: 4199FFB8  bgt cr6, 0x821dd500
	if ctx.cr[6].gt {
	pc = 0x821DD500; continue 'dispatch;
	}
	// 821DD54C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821DD550: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821DD554: 419A0034  beq cr6, 0x821dd588
	if ctx.cr[6].eq {
	pc = 0x821DD588; continue 'dispatch;
	}
	// 821DD558: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DD55C: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821DD560: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DD564: 41980008  blt cr6, 0x821dd56c
	if ctx.cr[6].lt {
	pc = 0x821DD56C; continue 'dispatch;
	}
	// 821DD568: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DD56C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DD570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DD574: 409A0014  bne cr6, 0x821dd588
	if !ctx.cr[6].eq {
	pc = 0x821DD588; continue 'dispatch;
	}
	// 821DD578: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DD57C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821DD580: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821DD584: 48000008  b 0x821dd58c
	pc = 0x821DD58C; continue 'dispatch;
	// 821DD588: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821DD58C: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DD590: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DD594: 419A0078  beq cr6, 0x821dd60c
	if ctx.cr[6].eq {
	pc = 0x821DD60C; continue 'dispatch;
	}
	// 821DD598: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DD59C: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 821DD5A0: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DD5A4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DD5A8: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821DD5AC: 419A0008  beq cr6, 0x821dd5b4
	if ctx.cr[6].eq {
	pc = 0x821DD5B4; continue 'dispatch;
	}
	// 821DD5B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DD5B4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DD5B8: 419A0054  beq cr6, 0x821dd60c
	if ctx.cr[6].eq {
	pc = 0x821DD60C; continue 'dispatch;
	}
	// 821DD5BC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DD5C0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DD5C4: 409A0008  bne cr6, 0x821dd5cc
	if !ctx.cr[6].eq {
	pc = 0x821DD5CC; continue 'dispatch;
	}
	// 821DD5C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DD5CC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DD5D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DD5D4: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DD5D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DD5DC: 4E800421  bctrl
	ctx.lr = 0x821DD5E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DD5E0: 7F03E800  cmpw cr6, r3, r29
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[29].s32, &mut ctx.xer);
	// 821DD5E4: 419A001C  beq cr6, 0x821dd600
	if ctx.cr[6].eq {
	pc = 0x821DD600; continue 'dispatch;
	}
	// 821DD5E8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DD5EC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DD5F0: 409A0008  bne cr6, 0x821dd5f8
	if !ctx.cr[6].eq {
	pc = 0x821DD5F8; continue 'dispatch;
	}
	// 821DD5F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DD5F8: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DD5FC: 4BFFFFA8  b 0x821dd5a4
	pc = 0x821DD5A4; continue 'dispatch;
	// 821DD600: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821DD604: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DD608: 48ACBE54  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821DD60C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821DD610: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DD614: 48ACBE48  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DD618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DD618 size=328
    let mut pc: u32 = 0x821DD618;
    'dispatch: loop {
        match pc {
            0x821DD618 => {
    //   block [0x821DD618..0x821DD760)
	// 821DD618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DD61C: 48ACBDED  bl 0x82ca9408
	ctx.lr = 0x821DD620;
	sub_82CA93D0(ctx, base);
	// 821DD620: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DD624: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DD628: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821DD62C: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 821DD630: 48048CC9  bl 0x822262f8
	ctx.lr = 0x821DD634;
	sub_822262F8(ctx, base);
	// 821DD634: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DD638: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DD63C: 409A011C  bne cr6, 0x821dd758
	if !ctx.cr[6].eq {
	pc = 0x821DD758; continue 'dispatch;
	}
	// 821DD640: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DD644: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821DD648: 80C30010  lwz r6, 0x10(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DD64C: 3CA08331  lis r5, -0x7ccf
	ctx.r[5].s64 = -2093940736;
	// 821DD650: 80830060  lwz r4, 0x60(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 821DD654: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821DD658: 83A3005C  lwz r29, 0x5c(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) } as u64;
	// 821DD65C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821DD660: 3B9F00B0  addi r28, r31, 0xb0
	ctx.r[28].s64 = ctx.r[31].s64 + 176;
	// 821DD664: C00300B0  lfs f0, 0xb0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DD668: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821DD66C: 990B16C7  stb r8, 0x16c7(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(5831 as u32), ctx.r[8].u8 ) };
	// 821DD670: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821DD674: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821DD678: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 821DD67C: 90C10068  stw r6, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[6].u32 ) };
	// 821DD680: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821DD684: 9081006C  stw r4, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[4].u32 ) };
	// 821DD688: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 821DD68C: 98E55E3A  stb r7, 0x5e3a(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(24122 as u32), ctx.r[7].u8 ) };
	// 821DD690: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 821DD694: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 821DD698: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821DD69C: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821DD6A0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821DD6A4: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 821DD6A8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821DD6AC: 4200FFF0  bdnz 0x821dd69c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821DD69C; continue 'dispatch;
	}
	// 821DD6B0: 8163004C  lwz r11, 0x4c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821DD6B4: C0030050  lfs f0, 0x50(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DD6B8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DD6BC: C1A30044  lfs f13, 0x44(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DD6C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821DD6C4: C1830040  lfs f12, 0x40(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821DD6C8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821DD6CC: 906100D8  stw r3, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[3].u32 ) };
	// 821DD6D0: 7D6807B4  extsw r8, r11
	ctx.r[8].s64 = ctx.r[11].s32 as i64;
	// 821DD6D4: D1A100C8  stfs f13, 0xc8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 821DD6D8: 7D4707B4  extsw r7, r10
	ctx.r[7].s64 = ctx.r[10].s32 as i64;
	// 821DD6DC: D18100CC  stfs f12, 0xcc(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 821DD6E0: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 821DD6E4: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DD6E8: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 821DD6EC: C9410050  lfd f10, 0x50(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DD6F0: FD005E9C  fcfid f8, f11
	ctx.f[8].f64 = (ctx.f[11].s64 as f64);
	// 821DD6F4: 912100C0  stw r9, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[9].u32 ) };
	// 821DD6F8: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 821DD6FC: 912100C4  stw r9, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[9].u32 ) };
	// 821DD700: FCC04018  frsp f6, f8
	ctx.f[6].f64 = (ctx.f[8].f64 as f32) as f64;
	// 821DD704: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821DD708: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821DD70C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DD710: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 821DD714: EC860032  fmuls f4, f6, f0
	ctx.f[4].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 821DD718: D08100D4  stfs f4, 0xd4(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 821DD71C: ECA70032  fmuls f5, f7, f0
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 821DD720: D0A100D0  stfs f5, 0xd0(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 821DD724: 4806043D  bl 0x8223db60
	ctx.lr = 0x821DD728;
	sub_8223DB60(ctx, base);
	// 821DD728: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 821DD72C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821DD730: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821DD734: 88A670D3  lbz r5, 0x70d3(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(28883 as u32) ) } as u64;
	// 821DD738: 806B0364  lwz r3, 0x364(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 821DD73C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821DD740: 419A0014  beq cr6, 0x821dd754
	if ctx.cr[6].eq {
	pc = 0x821DD754; continue 'dispatch;
	}
	// 821DD744: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821DD748: 489C45F9  bl 0x82ba1d40
	ctx.lr = 0x821DD74C;
	sub_82BA1D40(ctx, base);
	// 821DD74C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821DD750: 48ACBD08  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821DD754: 48087E9D  bl 0x822655f0
	ctx.lr = 0x821DD758;
	sub_822655F0(ctx, base);
	// 821DD758: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821DD75C: 48ACBCFC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DD760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DD760 size=2924
    let mut pc: u32 = 0x821DD760;
    'dispatch: loop {
        match pc {
            0x821DD760 => {
    //   block [0x821DD760..0x821DE2CC)
	// 821DD760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DD764: 48ACBC6D  bl 0x82ca93d0
	ctx.lr = 0x821DD768;
	sub_82CA93D0(ctx, base);
	// 821DD768: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821DD76C: 48AD0551  bl 0x82cadcbc
	ctx.lr = 0x821DD770;
	sub_82CADCA0(ctx, base);
	// 821DD770: 9421FD10  stwu r1, -0x2f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-752 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DD774: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821DD778: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821DD77C: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 821DD780: 3D20834B  lis r9, -0x7cb5
	ctx.r[9].s64 = -2092236800;
	// 821DD784: 394B2390  addi r10, r11, 0x2390
	ctx.r[10].s64 = ctx.r[11].s64 + 9104;
	// 821DD788: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 821DD78C: 7C8E2378  mr r14, r4
	ctx.r[14].u64 = ctx.r[4].u64;
	// 821DD790: 396A2004  addi r11, r10, 0x2004
	ctx.r[11].s64 = ctx.r[10].s64 + 8196;
	// 821DD794: 39097E70  addi r8, r9, 0x7e70
	ctx.r[8].s64 = ctx.r[9].s64 + 32368;
	// 821DD798: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DD79C: 38EA6014  addi r7, r10, 0x6014
	ctx.r[7].s64 = ctx.r[10].s64 + 24596;
	// 821DD7A0: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821DD7A4: 7CC95A14  add r6, r9, r11
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821DD7A8: 9106DFFC  stw r8, -0x2004(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(-8196 as u32), ctx.r[8].u32 ) };
	// 821DD7AC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DD7B0: 80ABFFFC  lwz r5, -4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821DD7B4: 54A3083C  slwi r3, r5, 1
	ctx.r[3].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821DD7B8: 38890001  addi r4, r9, 1
	ctx.r[4].s64 = ctx.r[9].s64 + 1;
	// 821DD7BC: 906BFFFC  stw r3, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[3].u32 ) };
	// 821DD7C0: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821DD7C4: 396B2008  addi r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + 8200;
	// 821DD7C8: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821DD7CC: 4198FFCC  blt cr6, 0x821dd798
	if ctx.cr[6].lt {
	pc = 0x821DD798; continue 'dispatch;
	}
	// 821DD7D0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821DD7D4: C8140048  lfd f0, 0x48(r20)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[20].u32.wrapping_add(72 as u32) ) };
	// 821DD7D8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821DD7DC: 3AAAB480  addi r21, r10, -0x4b80
	ctx.r[21].s64 = ctx.r[10].s64 + -19328;
	// 821DD7E0: 39740048  addi r11, r20, 0x48
	ctx.r[11].s64 = ctx.r[20].s64 + 72;
	// 821DD7E4: C9890D38  lfd f12, 0xd38(r9)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(3384 as u32) ) };
	// 821DD7E8: C1B5E010  lfs f13, -0x1ff0(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-8176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DD7EC: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 821DD7F0: C3D5E004  lfs f30, -0x1ffc(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-8188 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821DD7F4: 419A006C  beq cr6, 0x821dd860
	if ctx.cr[6].eq {
	pc = 0x821DD860; continue 'dispatch;
	}
	// 821DD7F8: C96B0008  lfd f11, 8(r11)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821DD7FC: FD6B0028  fsub f11, f11, f0
	ctx.f[11].f64 = ctx.f[11].f64 - ctx.f[0].f64;
	// 821DD800: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 821DD804: 4099005C  ble cr6, 0x821dd860
	if !ctx.cr[6].gt {
	pc = 0x821DD860; continue 'dispatch;
	}
	// 821DD808: 814E0004  lwz r10, 4(r14)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DD80C: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 821DD810: 39090E68  addi r8, r9, 0xe68
	ctx.r[8].s64 = ctx.r[9].s64 + 3688;
	// 821DD814: C98A02E8  lfd f12, 0x2e8(r10)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(744 as u32) ) };
	// 821DD818: FD4C0028  fsub f10, f12, f0
	ctx.f[10].f64 = ctx.f[12].f64 - ctx.f[0].f64;
	// 821DD81C: FD2A5824  fdiv f9, f10, f11
	ctx.f[9].f64 = ctx.f[10].f64 / ctx.f[11].f64;
	// 821DD820: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 821DD824: FF08F000  fcmpu cr6, f8, f30
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[30].f64);
	// 821DD828: 7CE00026  mfcr r7
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[7].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821DD82C: 54E6DF7A  rlwinm r6, r7, 0x1b, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 821DD830: 54E5F77A  rlwinm r5, r7, 0x1e, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 821DD834: 7CC42B78  or r4, r6, r5
	ctx.r[4].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 821DD838: 7CE8242E  lfsx f7, r8, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821DD83C: FCC7F22E  fsel f6, f7, f8, f30
	ctx.f[6].f64 = if ctx.f[7].f64 >= 0.0 { ctx.f[8].f64 } else { ctx.f[30].f64 };
	// 821DD840: ECA66828  fsubs f5, f6, f13
	ctx.f[5].f64 = (((ctx.f[6].f64 - ctx.f[13].f64) as f32) as f64);
	// 821DD844: FF05F000  fcmpu cr6, f5, f30
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[30].f64);
	// 821DD848: 7C600026  mfcr r3
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[3].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821DD84C: 546ADF7A  rlwinm r10, r3, 0x1b, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x0000001Fu64;
	// 821DD850: 5469F77A  rlwinm r9, r3, 0x1e, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x00000003u64;
	// 821DD854: 7D474B78  or r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821DD858: 7C883C2E  lfsx f4, r8, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 821DD85C: FDA4336E  fsel f13, f4, f13, f6
	ctx.f[13].f64 = if ctx.f[4].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[6].f64 };
	// 821DD860: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DD864: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821DD868: 409A000C  bne cr6, 0x821dd874
	if !ctx.cr[6].eq {
	pc = 0x821DD874; continue 'dispatch;
	}
	// 821DD86C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DD870: 4800000C  b 0x821dd87c
	pc = 0x821DD87C; continue 'dispatch;
	// 821DD874: D1AB0010  stfs f13, 0x10(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821DD878: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DD87C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DD880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DD884: 419A001C  beq cr6, 0x821dd8a0
	if ctx.cr[6].eq {
	pc = 0x821DD8A0; continue 'dispatch;
	}
	// 821DD888: 81740000  lwz r11, 0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DD88C: C0340058  lfs f1, 0x58(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(88 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821DD890: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 821DD894: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821DD898: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DD89C: 4E800421  bctrl
	ctx.lr = 0x821DD8A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DD8A0: 81740000  lwz r11, 0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DD8A4: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 821DD8A8: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 821DD8AC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DD8B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DD8B4: 4E800421  bctrl
	ctx.lr = 0x821DD8B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DD8B8: 3D40834F  lis r10, -0x7cb1
	ctx.r[10].s64 = -2091974656;
	// 821DD8BC: 816A6DC8  lwz r11, 0x6dc8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28104 as u32) ) } as u64;
	// 821DD8C0: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821DD8C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DD8C8: 409A000C  bne cr6, 0x821dd8d4
	if !ctx.cr[6].eq {
	pc = 0x821DD8D4; continue 'dispatch;
	}
	// 821DD8CC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821DD8D0: 916A6DC8  stw r11, 0x6dc8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28104 as u32), ctx.r[11].u32 ) };
	// 821DD8D4: 556907BC  rlwinm r9, r11, 0, 0x1e, 0x1e
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821DD8D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DD8DC: 409A000C  bne cr6, 0x821dd8e8
	if !ctx.cr[6].eq {
	pc = 0x821DD8E8; continue 'dispatch;
	}
	// 821DD8E0: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 821DD8E4: 916A6DC8  stw r11, 0x6dc8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28104 as u32), ctx.r[11].u32 ) };
	// 821DD8E8: 3CE0834C  lis r7, -0x7cb4
	ctx.r[7].s64 = -2092171264;
	// 821DD8EC: C3F5E010  lfs f31, -0x1ff0(r21)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-8176 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821DD8F0: 3D60834F  lis r11, -0x7cb1
	ctx.r[11].s64 = -2091974656;
	// 821DD8F4: 39EB6AC8  addi r15, r11, 0x6ac8
	ctx.r[15].s64 = ctx.r[11].s64 + 27336;
	// 821DD8F8: 8967EC92  lbz r11, -0x136e(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(-4974 as u32) ) } as u64;
	// 821DD8FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DD900: 409A00E4  bne cr6, 0x821dd9e4
	if !ctx.cr[6].eq {
	pc = 0x821DD9E4; continue 'dispatch;
	}
	// 821DD904: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 821DD908: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 821DD90C: 396F0002  addi r11, r15, 2
	ctx.r[11].s64 = ctx.r[15].s64 + 2;
	// 821DD910: 6129FFFE  ori r9, r9, 0xfffe
	ctx.r[9].u64 = ctx.r[9].u64 | 65534;
	// 821DD914: 390A0001  addi r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 1;
	// 821DD918: 7CCA4A14  add r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821DD91C: 5544043E  clrlwi r4, r10, 0x10
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821DD920: B10B0006  sth r8, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[8].u16 ) };
	// 821DD924: 54C3043E  clrlwi r3, r6, 0x10
	ctx.r[3].u64 = ctx.r[6].u32 as u64 & 0x0000FFFFu64;
	// 821DD928: 7CA84A14  add r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821DD92C: B08B0000  sth r4, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u16 ) };
	// 821DD930: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821DD934: B06BFFFE  sth r3, -2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(-2 as u32), ctx.r[3].u16 ) };
	// 821DD938: B0AB0002  sth r5, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[5].u16 ) };
	// 821DD93C: B06B0004  sth r3, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u16 ) };
	// 821DD940: 2F0A0102  cmpwi cr6, r10, 0x102
	ctx.cr[6].compare_i32(ctx.r[10].s32, 258, &mut ctx.xer);
	// 821DD944: B08B0008  sth r4, 8(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u16 ) };
	// 821DD948: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 821DD94C: 4198FFC8  blt cr6, 0x821dd914
	if ctx.cr[6].lt {
	pc = 0x821DD914; continue 'dispatch;
	}
	// 821DD950: C0152148  lfs f0, 0x2148(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DD954: 3CC0834F  lis r6, -0x7cb1
	ctx.r[6].s64 = -2091974656;
	// 821DD958: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821DD95C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DD960: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821DD964: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DD968: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821DD96C: 38A66A88  addi r5, r6, 0x6a88
	ctx.r[5].s64 = ctx.r[6].s64 + 27272;
	// 821DD970: D3C10054  stfs f30, 0x54(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821DD974: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DD978: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821DD97C: 9967EC92  stb r11, -0x136e(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(-4974 as u32), ctx.r[11].u8 ) };
	// 821DD980: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821DD984: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DD988: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821DD98C: F9250008  std r9, 8(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 821DD990: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821DD994: F9050018  std r8, 0x18(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(24 as u32), ctx.r[8].u64 ) };
	// 821DD998: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821DD99C: D3C10064  stfs f30, 0x64(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821DD9A0: E9010060  ld r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821DD9A4: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821DD9A8: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821DD9AC: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821DD9B0: D3E10094  stfs f31, 0x94(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821DD9B4: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821DD9B8: D3C10068  stfs f30, 0x68(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821DD9BC: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821DD9C0: E9210068  ld r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821DD9C4: F9650010  std r11, 0x10(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821DD9C8: F9466A88  std r10, 0x6a88(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(27272 as u32), ctx.r[10].u64 ) };
	// 821DD9CC: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DD9D0: E9610090  ld r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821DD9D4: F9250028  std r9, 0x28(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(40 as u32), ctx.r[9].u64 ) };
	// 821DD9D8: F9650030  std r11, 0x30(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(48 as u32), ctx.r[11].u64 ) };
	// 821DD9DC: F9450020  std r10, 0x20(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(32 as u32), ctx.r[10].u64 ) };
	// 821DD9E0: F9050038  std r8, 0x38(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 821DD9E4: 817400D4  lwz r11, 0xd4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(212 as u32) ) } as u64;
	// 821DD9E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DD9EC: 409A0010  bne cr6, 0x821dd9fc
	if !ctx.cr[6].eq {
	pc = 0x821DD9FC; continue 'dispatch;
	}
	// 821DD9F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DD9F4: 3A4B9218  addi r18, r11, -0x6de8
	ctx.r[18].s64 = ctx.r[11].s64 + -28136;
	// 821DD9F8: 48000008  b 0x821dda00
	pc = 0x821DDA00; continue 'dispatch;
	// 821DD9FC: 824B0000  lwz r18, 0(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DDA00: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821DDA04: 812E0004  lwz r9, 4(r14)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DDA08: 388E06B0  addi r4, r14, 0x6b0
	ctx.r[4].s64 = ctx.r[14].s64 + 1712;
	// 821DDA0C: 390B60B8  addi r8, r11, 0x60b8
	ctx.r[8].s64 = ctx.r[11].s64 + 24760;
	// 821DDA10: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 821DDA14: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821DDA18: C0090210  lfs f0, 0x210(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(528 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DDA1C: 814B60B8  lwz r10, 0x60b8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24760 as u32) ) } as u64;
	// 821DDA20: 81280008  lwz r9, 8(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DDA24: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DDA28: 7CEA4850  subf r7, r10, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 821DDA2C: 8148000C  lwz r10, 0xc(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DDA30: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821DDA34: 7CE607B4  extsw r6, r7
	ctx.r[6].s64 = ctx.r[7].s32 as i64;
	// 821DDA38: 7CAB07B4  extsw r11, r5
	ctx.r[11].s64 = ctx.r[5].s32 as i64;
	// 821DDA3C: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 821DDA40: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DDA44: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 821DDA48: C9A10070  lfd f13, 0x70(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 821DDA4C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 821DDA50: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 821DDA54: FF405018  frsp f26, f10
	ctx.f[26].f64 = (ctx.f[10].f64 as f32) as f64;
	// 821DDA58: FF206018  frsp f25, f12
	ctx.f[25].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821DDA5C: ED3AC824  fdivs f9, f26, f25
	ctx.f[9].f64 = ((ctx.f[26].f64 / ctx.f[25].f64) as f32) as f64;
	// 821DDA60: EF690024  fdivs f27, f9, f0
	ctx.f[27].f64 = ((ctx.f[9].f64 / ctx.f[0].f64) as f32) as f64;
	// 821DDA64: 4BFC4A2D  bl 0x821a2490
	ctx.lr = 0x821DDA68;
	sub_821A2490(ctx, base);
	// 821DDA68: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821DDA6C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821DDA70: 392000B0  li r9, 0xb0
	ctx.r[9].s64 = 176;
	// 821DDA74: 390A91A0  addi r8, r10, -0x6e60
	ctx.r[8].s64 = ctx.r[10].s64 + -28256;
	// 821DDA78: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821DDA7C: 38C10160  addi r6, r1, 0x160
	ctx.r[6].s64 = ctx.r[1].s64 + 352;
	// 821DDA80: 38A10180  addi r5, r1, 0x180
	ctx.r[5].s64 = ctx.r[1].s64 + 384;
	// 821DDA84: 38810170  addi r4, r1, 0x170
	ctx.r[4].s64 = ctx.r[1].s64 + 368;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DE2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821DE2D0 size=20
    let mut pc: u32 = 0x821DE2D0;
    'dispatch: loop {
        match pc {
            0x821DE2D0 => {
    //   block [0x821DE2D0..0x821DE2E4)
	// 821DE2D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DE2D4: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DE2D8: D0040014  stfs f0, 0x14(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821DE2DC: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821DE2E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DE2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DE2E8 size=320
    let mut pc: u32 = 0x821DE2E8;
    'dispatch: loop {
        match pc {
            0x821DE2E8 => {
    //   block [0x821DE2E8..0x821DE428)
	// 821DE2E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DE2EC: 48ACB115  bl 0x82ca9400
	ctx.lr = 0x821DE2F0;
	sub_82CA93D0(ctx, base);
	// 821DE2F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DE2F4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821DE2F8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821DE2FC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821DE300: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 821DE304: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE308: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DE30C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DE310: 4E800421  bctrl
	ctx.lr = 0x821DE314;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DE314: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DE318: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DE31C: 419A0080  beq cr6, 0x821de39c
	if ctx.cr[6].eq {
	pc = 0x821DE39C; continue 'dispatch;
	}
	// 821DE320: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821DE324: 579D2036  slwi r29, r28, 4
	ctx.r[29].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 821DE328: 3BCBF850  addi r30, r11, -0x7b0
	ctx.r[30].s64 = ctx.r[11].s64 + -1968;
	// 821DE32C: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 821DE330: 7FFD5A14  add r31, r29, r11
	ctx.r[31].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821DE334: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DE338: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE33C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821DE340: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DE344: 40820020  bne 0x821de364
	if !ctx.cr[0].eq {
	pc = 0x821DE364; continue 'dispatch;
	}
	// 821DE348: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821DE34C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821DE350: 488B1399  bl 0x82a8f6e8
	ctx.lr = 0x821DE354;
	sub_82A8F6E8(ctx, base);
	// 821DE354: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DE358: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE35C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821DE360: 7D2B1670  srawi r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 821DE364: 395E0014  addi r10, r30, 0x14
	ctx.r[10].s64 = ctx.r[30].s64 + 20;
	// 821DE368: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE36C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821DE370: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DE374: 7CE85850  subf r7, r8, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 821DE378: 7D5D502E  lwzx r10, r29, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821DE37C: 54E6003A  rlwinm r6, r7, 0, 0, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821DE380: 7CAA4A14  add r5, r10, r9
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821DE384: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821DE388: 8145FFFC  lwz r10, -4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821DE38C: 419A000C  beq cr6, 0x821de398
	if ctx.cr[6].eq {
	pc = 0x821DE398; continue 'dispatch;
	}
	// 821DE390: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 821DE394: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821DE398: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 821DE39C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821DE3A0: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821DE3A4: 392BF9B0  addi r9, r11, -0x650
	ctx.r[9].s64 = ctx.r[11].s64 + -1616;
	// 821DE3A8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821DE3AC: 7FEA482E  lwzx r31, r10, r9
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821DE3B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DE3B4: 4804C7C5  bl 0x8222ab78
	ctx.lr = 0x821DE3B8;
	sub_8222AB78(ctx, base);
	// 821DE3B8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821DE3BC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821DE3C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DE3C4: 4804C81D  bl 0x8222abe0
	ctx.lr = 0x821DE3C8;
	sub_8222ABE0(ctx, base);
	// 821DE3C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821DE3CC: 419A0008  beq cr6, 0x821de3d4
	if ctx.cr[6].eq {
	pc = 0x821DE3D4; continue 'dispatch;
	}
	// 821DE3D0: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821DE3D4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821DE3D8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821DE3DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DE3E0: 4804C801  bl 0x8222abe0
	ctx.lr = 0x821DE3E4;
	sub_8222ABE0(ctx, base);
	// 821DE3E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821DE3E8: 419A0008  beq cr6, 0x821de3f0
	if ctx.cr[6].eq {
	pc = 0x821DE3F0; continue 'dispatch;
	}
	// 821DE3EC: 93430000  stw r26, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 821DE3F0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE3F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DE3F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821DE3FC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DE400: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DE404: 4E800421  bctrl
	ctx.lr = 0x821DE408;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DE408: 813F002C  lwz r9, 0x2c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821DE40C: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DE410: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821DE414: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821DE418: 80FF0020  lwz r7, 0x20(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DE41C: 90FF0028  stw r7, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[7].u32 ) };
	// 821DE420: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821DE424: 48ACB02C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DE428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DE428 size=76
    let mut pc: u32 = 0x821DE428;
    'dispatch: loop {
        match pc {
            0x821DE428 => {
    //   block [0x821DE428..0x821DE474)
	// 821DE428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DE42C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DE430: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DE434: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DE438: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 821DE43C: 48040065  bl 0x8221e4a0
	ctx.lr = 0x821DE440;
	sub_8221E4A0(ctx, base);
	// 821DE440: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 821DE444: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821DE448: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821DE44C: 7CFF5A14  add r7, r31, r11
	ctx.r[7].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 821DE450: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821DE454: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821DE458: 806A0364  lwz r3, 0x364(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(868 as u32) ) } as u64;
	// 821DE45C: 4803FB65  bl 0x8221dfc0
	ctx.lr = 0x821DE460;
	sub_8221DFC0(ctx, base);
	// 821DE460: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821DE464: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DE468: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DE46C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821DE470: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DE478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DE478 size=440
    let mut pc: u32 = 0x821DE478;
    'dispatch: loop {
        match pc {
            0x821DE478 => {
    //   block [0x821DE478..0x821DE630)
	// 821DE478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DE47C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DE480: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DE484: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DE488: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821DE48C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DE490: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821DE494: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE498: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE49C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 821DE4A0: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 821DE4A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE4A8: 419A0084  beq cr6, 0x821de52c
	if ctx.cr[6].eq {
	pc = 0x821DE52C; continue 'dispatch;
	}
	// 821DE4AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE4B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DE4B4: 419A0074  beq cr6, 0x821de528
	if ctx.cr[6].eq {
	pc = 0x821DE528; continue 'dispatch;
	}
	// 821DE4B8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821DE4BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE4C0: 419A0018  beq cr6, 0x821de4d8
	if ctx.cr[6].eq {
	pc = 0x821DE4D8; continue 'dispatch;
	}
	// 821DE4C4: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 821DE4C8: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821DE4CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DE4D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DE4D4: 409A0008  bne cr6, 0x821de4dc
	if !ctx.cr[6].eq {
	pc = 0x821DE4DC; continue 'dispatch;
	}
	// 821DE4D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821DE4DC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821DE4E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DE4E4: 419A0138  beq cr6, 0x821de61c
	if ctx.cr[6].eq {
	pc = 0x821DE61C; continue 'dispatch;
	}
	// 821DE4E8: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821DE4EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821DE4F0: 5528FFFE  rlwinm r8, r9, 0x1f, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 821DE4F4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821DE4F8: 419A0104  beq cr6, 0x821de5fc
	if ctx.cr[6].eq {
	pc = 0x821DE5FC; continue 'dispatch;
	}
	// 821DE4FC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821DE500: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DE504: 419A0030  beq cr6, 0x821de534
	if ctx.cr[6].eq {
	pc = 0x821DE534; continue 'dispatch;
	}
	// 821DE508: 894A0021  lbz r10, 0x21(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 821DE50C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DE510: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821DE514: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821DE518: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE51C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821DE520: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DE524: 480000DC  b 0x821de600
	pc = 0x821DE600; continue 'dispatch;
	// 821DE528: 4BFB5911  bl 0x82193e38
	ctx.lr = 0x821DE52C;
	sub_82193E38(ctx, base);
	// 821DE52C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DE530: 4BFFFFA8  b 0x821de4d8
	pc = 0x821DE4D8; continue 'dispatch;
	// 821DE534: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DE538: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821DE53C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821DE540: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821DE544: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821DE548: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821DE54C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DE550: 40810054  ble 0x821de5a4
	if !ctx.cr[0].gt {
	pc = 0x821DE5A4; continue 'dispatch;
	}
	// 821DE554: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821DE558: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DE55C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821DE560: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE564: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 821DE568: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821DE56C: 41980008  blt cr6, 0x821de574
	if ctx.cr[6].lt {
	pc = 0x821DE574; continue 'dispatch;
	}
	// 821DE570: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821DE574: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821DE578: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DE57C: 419A0014  beq cr6, 0x821de590
	if ctx.cr[6].eq {
	pc = 0x821DE590; continue 'dispatch;
	}
	// 821DE580: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821DE584: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821DE588: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821DE58C: 4800000C  b 0x821de598
	pc = 0x821DE598; continue 'dispatch;
	// 821DE590: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821DE594: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821DE598: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DE59C: 4199FFB8  bgt cr6, 0x821de554
	if ctx.cr[6].gt {
	pc = 0x821DE554; continue 'dispatch;
	}
	// 821DE5A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821DE5A4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821DE5A8: 419A0040  beq cr6, 0x821de5e8
	if ctx.cr[6].eq {
	pc = 0x821DE5E8; continue 'dispatch;
	}
	// 821DE5AC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE5B0: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 821DE5B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DE5B8: 41990008  bgt cr6, 0x821de5c0
	if ctx.cr[6].gt {
	pc = 0x821DE5C0; continue 'dispatch;
	}
	// 821DE5BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DE5C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DE5C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE5C8: 409A0020  bne cr6, 0x821de5e8
	if !ctx.cr[6].eq {
	pc = 0x821DE5E8; continue 'dispatch;
	}
	// 821DE5CC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DE5D0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821DE5D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821DE5D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE5DC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821DE5E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DE5E4: 4800001C  b 0x821de600
	pc = 0x821DE600; continue 'dispatch;
	// 821DE5E8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821DE5EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE5F0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821DE5F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DE5F8: 48000008  b 0x821de600
	pc = 0x821DE600; continue 'dispatch;
	// 821DE5FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DE600: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DE604: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE608: 419A0014  beq cr6, 0x821de61c
	if ctx.cr[6].eq {
	pc = 0x821DE61C; continue 'dispatch;
	}
	// 821DE60C: 896A008C  lbz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 821DE610: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821DE614: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE618: 409A0008  bne cr6, 0x821de620
	if !ctx.cr[6].eq {
	pc = 0x821DE620; continue 'dispatch;
	}
	// 821DE61C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821DE620: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821DE624: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DE628: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DE62C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DE630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DE630 size=416
    let mut pc: u32 = 0x821DE630;
    'dispatch: loop {
        match pc {
            0x821DE630 => {
    //   block [0x821DE630..0x821DE7D0)
	// 821DE630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DE634: 48ACADC5  bl 0x82ca93f8
	ctx.lr = 0x821DE638;
	sub_82CA93D0(ctx, base);
	// 821DE638: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DE63C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821DE640: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821DE644: 3B6B4FF8  addi r27, r11, 0x4ff8
	ctx.r[27].s64 = ctx.r[11].s64 + 20472;
	// 821DE648: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE64C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DE650: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DE654: 40990008  ble cr6, 0x821de65c
	if !ctx.cr[6].gt {
	pc = 0x821DE65C; continue 'dispatch;
	}
	// 821DE658: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DE65C: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 821DE660: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DE664: 40990008  ble cr6, 0x821de66c
	if !ctx.cr[6].gt {
	pc = 0x821DE66C; continue 'dispatch;
	}
	// 821DE668: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DE66C: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 821DE670: 3F208336  lis r25, -0x7cca
	ctx.r[25].s64 = -2093613056;
	// 821DE674: 7F1CC040  cmplw cr6, r28, r24
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[24].u32, &mut ctx.xer);
	// 821DE678: 419A0150  beq cr6, 0x821de7c8
	if ctx.cr[6].eq {
	pc = 0x821DE7C8; continue 'dispatch;
	}
	// 821DE67C: 815A06FC  lwz r10, 0x6fc(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821DE680: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 821DE684: 409A00A4  bne cr6, 0x821de728
	if !ctx.cr[6].eq {
	pc = 0x821DE728; continue 'dispatch;
	}
	// 821DE688: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DE68C: 41980008  blt cr6, 0x821de694
	if ctx.cr[6].lt {
	pc = 0x821DE694; continue 'dispatch;
	}
	// 821DE690: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DE694: 83DC0000  lwz r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE698: 8159F94C  lwz r10, -0x6b4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-1716 as u32) ) } as u64;
	// 821DE69C: 3BFE00D4  addi r31, r30, 0xd4
	ctx.r[31].s64 = ctx.r[30].s64 + 212;
	// 821DE6A0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821DE6A4: 813E00DC  lwz r9, 0xdc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(220 as u32) ) } as u64;
	// 821DE6A8: 7D480034  cntlzw r8, r10
	ctx.r[8].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 821DE6AC: 80FE00D8  lwz r7, 0xd8(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(216 as u32) ) } as u64;
	// 821DE6B0: 551DDFFE  rlwinm r29, r8, 0x1b, 0x1f, 0x1f
	ctx.r[29].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 821DE6B4: 7CC74850  subf r6, r7, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 821DE6B8: 54C5003A  rlwinm r5, r6, 0, 0, 0x1d
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 821DE6BC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821DE6C0: 419A00F4  beq cr6, 0x821de7b4
	if ctx.cr[6].eq {
	pc = 0x821DE7B4; continue 'dispatch;
	}
	// 821DE6C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821DE6C8: 48952B79  bl 0x82b31240
	ctx.lr = 0x821DE6CC;
	sub_82B31240(ctx, base);
	// 821DE6CC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DE6D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE6D4: 419A00DC  beq cr6, 0x821de7b0
	if ctx.cr[6].eq {
	pc = 0x821DE7B0; continue 'dispatch;
	}
	// 821DE6D8: 817E00C8  lwz r11, 0xc8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 821DE6DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE6E0: 419A0020  beq cr6, 0x821de700
	if ctx.cr[6].eq {
	pc = 0x821DE700; continue 'dispatch;
	}
	// 821DE6E4: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821DE6E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE6EC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE6F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DE6F4: 4E800421  bctrl
	ctx.lr = 0x821DE6F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DE6F8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 821DE6FC: 48000008  b 0x821de704
	pc = 0x821DE704; continue 'dispatch;
	// 821DE700: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821DE704: 807E00CC  lwz r3, 0xcc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(204 as u32) ) } as u64;
	// 821DE708: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821DE70C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821DE710: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821DE714: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE718: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DE71C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DE720: 4E800421  bctrl
	ctx.lr = 0x821DE724;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DE724: 4800008C  b 0x821de7b0
	pc = 0x821DE7B0; continue 'dispatch;
	// 821DE728: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DE72C: 41980008  blt cr6, 0x821de734
	if ctx.cr[6].lt {
	pc = 0x821DE734; continue 'dispatch;
	}
	// 821DE730: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DE734: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE738: 3BDF00D4  addi r30, r31, 0xd4
	ctx.r[30].s64 = ctx.r[31].s64 + 212;
	// 821DE73C: 815F00DC  lwz r10, 0xdc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 821DE740: 813F00D8  lwz r9, 0xd8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 821DE744: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821DE748: 5507003A  rlwinm r7, r8, 0, 0, 0x1d
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821DE74C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821DE750: 419A0064  beq cr6, 0x821de7b4
	if ctx.cr[6].eq {
	pc = 0x821DE7B4; continue 'dispatch;
	}
	// 821DE754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DE758: 48952AE9  bl 0x82b31240
	ctx.lr = 0x821DE75C;
	sub_82B31240(ctx, base);
	// 821DE75C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DE760: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE764: 419A004C  beq cr6, 0x821de7b0
	if ctx.cr[6].eq {
	pc = 0x821DE7B0; continue 'dispatch;
	}
	// 821DE768: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 821DE76C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE770: 419A0020  beq cr6, 0x821de790
	if ctx.cr[6].eq {
	pc = 0x821DE790; continue 'dispatch;
	}
	// 821DE774: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821DE778: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE77C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE780: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DE784: 4E800421  bctrl
	ctx.lr = 0x821DE788;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DE788: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 821DE78C: 48000008  b 0x821de794
	pc = 0x821DE794; continue 'dispatch;
	// 821DE790: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821DE794: 807F00CC  lwz r3, 0xcc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 821DE798: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821DE79C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821DE7A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE7A4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DE7A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DE7AC: 4E800421  bctrl
	ctx.lr = 0x821DE7B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DE7B0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DE7B4: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DE7B8: 41980008  blt cr6, 0x821de7c0
	if ctx.cr[6].lt {
	pc = 0x821DE7C0; continue 'dispatch;
	}
	// 821DE7BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DE7C0: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 821DE7C4: 4BFFFEB0  b 0x821de674
	pc = 0x821DE674; continue 'dispatch;
	// 821DE7C8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821DE7CC: 48ACAC7C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DE7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DE7D0 size=324
    let mut pc: u32 = 0x821DE7D0;
    'dispatch: loop {
        match pc {
            0x821DE7D0 => {
    //   block [0x821DE7D0..0x821DE914)
	// 821DE7D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DE7D4: 48ACAC35  bl 0x82ca9408
	ctx.lr = 0x821DE7D8;
	sub_82CA93D0(ctx, base);
	// 821DE7D8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821DE7DC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DE7E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DE7E4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821DE7E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821DE7EC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821DE7F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821DE7F4: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821DE7F8: 419A0018  beq cr6, 0x821de810
	if ctx.cr[6].eq {
	pc = 0x821DE810; continue 'dispatch;
	}
	// 821DE7FC: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 821DE800: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821DE804: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DE808: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DE80C: 409A0008  bne cr6, 0x821de814
	if !ctx.cr[6].eq {
	pc = 0x821DE814; continue 'dispatch;
	}
	// 821DE810: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DE814: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DE818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE81C: 419A00E8  beq cr6, 0x821de904
	if ctx.cr[6].eq {
	pc = 0x821DE904; continue 'dispatch;
	}
	// 821DE820: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE824: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DE828: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DE82C: 419A00D8  beq cr6, 0x821de904
	if ctx.cr[6].eq {
	pc = 0x821DE904; continue 'dispatch;
	}
	// 821DE830: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE834: 7F03E040  cmplw cr6, r3, r28
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821DE838: 419A00CC  beq cr6, 0x821de904
	if ctx.cr[6].eq {
	pc = 0x821DE904; continue 'dispatch;
	}
	// 821DE83C: 4877A335  bl 0x82958b70
	ctx.lr = 0x821DE840;
	sub_82958B70(ctx, base);
	// 821DE840: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821DE844: 419A0018  beq cr6, 0x821de85c
	if ctx.cr[6].eq {
	pc = 0x821DE85C; continue 'dispatch;
	}
	// 821DE848: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821DE84C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821DE850: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DE854: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DE858: 409A0008  bne cr6, 0x821de860
	if !ctx.cr[6].eq {
	pc = 0x821DE860; continue 'dispatch;
	}
	// 821DE85C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DE860: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DE864: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE868: 419A008C  beq cr6, 0x821de8f4
	if ctx.cr[6].eq {
	pc = 0x821DE8F4; continue 'dispatch;
	}
	// 821DE86C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE870: 4877A301  bl 0x82958b70
	ctx.lr = 0x821DE874;
	sub_82958B70(ctx, base);
	// 821DE874: 39630014  addi r11, r3, 0x14
	ctx.r[11].s64 = ctx.r[3].s64 + 20;
	// 821DE878: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DE87C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE880: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DE884: 409A0018  bne cr6, 0x821de89c
	if !ctx.cr[6].eq {
	pc = 0x821DE89C; continue 'dispatch;
	}
	// 821DE888: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE88C: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 821DE890: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DE894: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DE898: 419A0008  beq cr6, 0x821de8a0
	if ctx.cr[6].eq {
	pc = 0x821DE8A0; continue 'dispatch;
	}
	// 821DE89C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DE8A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DE8A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE8A8: 419A004C  beq cr6, 0x821de8f4
	if ctx.cr[6].eq {
	pc = 0x821DE8F4; continue 'dispatch;
	}
	// 821DE8AC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE8B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DE8B4: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DE8B8: 481FF641  bl 0x823ddef8
	ctx.lr = 0x821DE8BC;
	sub_823DDEF8(ctx, base);
	// 821DE8BC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DE8C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE8C4: 419A0030  beq cr6, 0x821de8f4
	if ctx.cr[6].eq {
	pc = 0x821DE8F4; continue 'dispatch;
	}
	// 821DE8C8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE8CC: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 821DE8D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DE8D4: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821DE8D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DE8DC: 4E800421  bctrl
	ctx.lr = 0x821DE8E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DE8E0: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DE8E4: C1A30010  lfs f13, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DE8E8: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821DE8EC: FD606210  fabs f11, f12
	ctx.f[11].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 821DE8F0: EFEBF82A  fadds f31, f11, f31
	ctx.f[31].f64 = ((ctx.f[11].f64 + ctx.f[31].f64) as f32) as f64;
	// 821DE8F4: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DE8F8: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 821DE8FC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DE900: 409AFF30  bne cr6, 0x821de830
	if !ctx.cr[6].eq {
	pc = 0x821DE830; continue 'dispatch;
	}
	// 821DE904: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821DE908: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821DE90C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821DE910: 48ACAB48  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DE918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DE918 size=560
    let mut pc: u32 = 0x821DE918;
    'dispatch: loop {
        match pc {
            0x821DE918 => {
    //   block [0x821DE918..0x821DEB48)
	// 821DE918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DE91C: 48ACAAE5  bl 0x82ca9400
	ctx.lr = 0x821DE920;
	sub_82CA93D0(ctx, base);
	// 821DE920: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DEB48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DEB48 size=600
    let mut pc: u32 = 0x821DEB48;
    'dispatch: loop {
        match pc {
            0x821DEB48 => {
    //   block [0x821DEB48..0x821DEDA0)
	// 821DEB48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DEB4C: 48ACA8B9  bl 0x82ca9404
	ctx.lr = 0x821DEB50;
	sub_82CA93D0(ctx, base);
	// 821DEB50: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DEB54: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821DEB58: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821DEB5C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DEB60: 556A06F6  rlwinm r10, r11, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821DEB64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DEB68: 419A020C  beq cr6, 0x821ded74
	if ctx.cr[6].eq {
	pc = 0x821DED74; continue 'dispatch;
	}
	// 821DEB6C: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 821DEB70: 807D6AB8  lwz r3, 0x6ab8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821DEB74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DEB78: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DEB7C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DEB80: 4E800421  bctrl
	ctx.lr = 0x821DEB84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DEB84: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821DEB88: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821DEB8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DEB90: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DEB94: 81696B08  lwz r11, 0x6b08(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821DEB98: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DEB9C: 3BCA0020  addi r30, r10, 0x20
	ctx.r[30].s64 = ctx.r[10].s64 + 32;
	// 821DEBA0: 80EB0020  lwz r7, 0x20(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DEBA4: 80C7001C  lwz r6, 0x1c(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DEBA8: 8386004C  lwz r28, 0x4c(r6)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 821DEBAC: 480001F5  bl 0x821deda0
	ctx.lr = 0x821DEBB0;
	sub_821DEDA0(ctx, base);
	// 821DEBB0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821DEBB4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821DEBB8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DEDA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DEDA0 size=868
    let mut pc: u32 = 0x821DEDA0;
    'dispatch: loop {
        match pc {
            0x821DEDA0 => {
    //   block [0x821DEDA0..0x821DF104)
	// 821DEDA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DEDA4: 48ACA65D  bl 0x82ca9400
	ctx.lr = 0x821DEDA8;
	sub_82CA93D0(ctx, base);
	// 821DEDA8: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DF108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DF108 size=308
    let mut pc: u32 = 0x821DF108;
    'dispatch: loop {
        match pc {
            0x821DF108 => {
    //   block [0x821DF108..0x821DF23C)
	// 821DF108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DF10C: 48ACA2FD  bl 0x82ca9408
	ctx.lr = 0x821DF110;
	sub_82CA93D0(ctx, base);
	// 821DF110: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DF114: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821DF118: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821DF11C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821DF120: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821DF124: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821DF128: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DF12C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DF130: 838A004C  lwz r28, 0x4c(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(76 as u32) ) } as u64;
	// 821DF134: 4BFFFC6D  bl 0x821deda0
	ctx.lr = 0x821DF138;
	sub_821DEDA0(ctx, base);
	// 821DF138: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821DF13C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821DF140: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DF240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821DF240 size=536
    let mut pc: u32 = 0x821DF240;
    'dispatch: loop {
        match pc {
            0x821DF240 => {
    //   block [0x821DF240..0x821DF458)
	// 821DF240: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 821DF244: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821DF248: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 821DF24C: C1010024  lfs f8, 0x24(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821DF250: C0040098  lfs f0, 0x98(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DF254: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DF258: C1A40090  lfs f13, 0x90(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DF25C: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 821DF260: FD406890  fmr f10, f13
	ctx.f[10].f64 = ctx.f[13].f64;
	// 821DF264: 392B92D4  addi r9, r11, -0x6d2c
	ctx.r[9].s64 = ctx.r[11].s64 + -27948;
	// 821DF268: ED60682A  fadds f11, f0, f13
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821DF26C: 3941FFD0  addi r10, r1, -0x30
	ctx.r[10].s64 = ctx.r[1].s64 + -48;
	// 821DF270: 38A1FFD0  addi r5, r1, -0x30
	ctx.r[5].s64 = ctx.r[1].s64 + -48;
	// 821DF274: C0E40094  lfs f7, 0x94(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(148 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821DF278: C00B92D4  lfs f0, -0x6d2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DF27C: FC403890  fmr f2, f7
	ctx.f[2].f64 = ctx.f[7].f64;
	// 821DF280: C0C4008C  lfs f6, 0x8c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821DF284: 3901FFD4  addi r8, r1, -0x2c
	ctx.r[8].s64 = ctx.r[1].s64 + -44;
	// 821DF288: C1A901B0  lfs f13, 0x1b0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(432 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DF28C: ECA7302A  fadds f5, f7, f6
	ctx.f[5].f64 = ((ctx.f[7].f64 + ctx.f[6].f64) as f32) as f64;
	// 821DF290: D1A1FFD0  stfs f13, -0x30(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), tmp.u32 ) };
	// 821DF294: 38C1FFD4  addi r6, r1, -0x2c
	ctx.r[6].s64 = ctx.r[1].s64 + -44;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


