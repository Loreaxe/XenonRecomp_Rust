pub fn sub_825C4790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C4790 size=1204
    let mut pc: u32 = 0x825C4790;
    'dispatch: loop {
        match pc {
            0x825C4790 => {
    //   block [0x825C4790..0x825C4C44)
	// 825C4790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C4794: 4BF70909  bl 0x8253509c
	ctx.lr = 0x825C4798;
	sub_82535080(ctx, base);
	// 825C4798: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C479C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C47A0: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 825C47A4: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 825C47A8: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 825C47AC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 825C47B0: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C47B4: 7D154378  mr r21, r8
	ctx.r[21].u64 = ctx.r[8].u64;
	// 825C47B8: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 825C47BC: 7D565378  mr r22, r10
	ctx.r[22].u64 = ctx.r[10].u64;
	// 825C47C0: 3B600004  li r27, 4
	ctx.r[27].s64 = 4;
	// 825C47C4: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 825C47C8: 409A0194  bne cr6, 0x825c495c
	if !ctx.cr[6].eq {
	pc = 0x825C495C; continue 'dispatch;
	}
	// 825C47CC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 825C47D0: 4BFFFC39  bl 0x825c4408
	ctx.lr = 0x825C47D4;
	sub_825C4408(ctx, base);
	// 825C47D4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825C47D8: 2F1A0004  cmpwi cr6, r26, 4
	ctx.cr[6].compare_i32(ctx.r[26].s32, 4, &mut ctx.xer);
	// 825C47DC: 409A0010  bne cr6, 0x825c47ec
	if !ctx.cr[6].eq {
	pc = 0x825C47EC; continue 'dispatch;
	}
	// 825C47E0: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 825C47E4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825C47E8: 4BF70904  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
	// 825C47EC: 83A10104  lwz r29, 0x104(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 825C47F0: 574B1838  slwi r11, r26, 3
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C47F4: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C47F8: 7F6BFA14  add r27, r11, r31
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825C47FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C4800: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4804: A09B0006  lhz r4, 6(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(6 as u32) ) } as u64;
	// 825C4808: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C480C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C4810: 4E800421  bctrl
	ctx.lr = 0x825C4814;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C4814: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825C4818: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825C481C: 409A0008  bne cr6, 0x825c4824
	if !ctx.cr[6].eq {
	pc = 0x825C4824; continue 'dispatch;
	}
	// 825C4820: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 825C4824: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4828: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C482C: 915B0004  stw r10, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825C4830: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C4834: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825C4838: 4BFFEF81  bl 0x825c37b8
	ctx.lr = 0x825C483C;
	sub_825C37B8(ctx, base);
	// 825C483C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4840: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 825C4844: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 825C4848: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825C484C: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 825C4850: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 825C4854: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825C4858: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825C485C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C4860: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C4864: 4E800421  bctrl
	ctx.lr = 0x825C4868;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C4868: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 825C486C: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 825C4870: 409A00B4  bne cr6, 0x825c4924
	if !ctx.cr[6].eq {
	pc = 0x825C4924; continue 'dispatch;
	}
	// 825C4874: 391F001C  addi r8, r31, 0x1c
	ctx.r[8].s64 = ctx.r[31].s64 + 28;
	// 825C4878: 893F0000  lbz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C487C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C4880: 38FF0004  addi r7, r31, 4
	ctx.r[7].s64 = ctx.r[31].s64 + 4;
	// 825C4884: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C4888: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825C488C: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4890: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C4894: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C4898: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825C489C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C48A0: 91270000  stw r9, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825C48A4: 392AFFFF  addi r9, r10, -1
	ctx.r[9].s64 = ctx.r[10].s64 + -1;
	// 825C48A8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825C48AC: 91070004  stw r8, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825C48B0: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825C48B4: 390A0004  addi r8, r10, 4
	ctx.r[8].s64 = ctx.r[10].s64 + 4;
	// 825C48B8: 993F0002  stb r9, 2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[9].u8 ) };
	// 825C48BC: 552A1838  slwi r10, r9, 3
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C48C0: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825C48C4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825C48C8: 41980020  blt cr6, 0x825c48e8
	if ctx.cr[6].lt {
	pc = 0x825C48E8; continue 'dispatch;
	}
	// 825C48CC: 7D2A4050  subf r9, r10, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 825C48D0: 7D09502E  lwzx r8, r9, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825C48D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C48D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C48DC: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825C48E0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825C48E4: 4098FFEC  bge cr6, 0x825c48d0
	if !ctx.cr[6].lt {
	pc = 0x825C48D0; continue 'dispatch;
	}
	// 825C48E8: 5749083C  slwi r9, r26, 1
	ctx.r[9].u32 = ctx.r[26].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C48EC: 39760090  addi r11, r22, 0x90
	ctx.r[11].s64 = ctx.r[22].s64 + 144;
	// 825C48F0: 7D3A4A14  add r9, r26, r9
	ctx.r[9].u64 = ctx.r[26].u64 + ctx.r[9].u64;
	// 825C48F4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 825C48F8: 55292036  slwi r9, r9, 4
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C48FC: 38600006  li r3, 6
	ctx.r[3].s64 = 6;
	// 825C4900: 7D29B214  add r9, r9, r22
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[22].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C4C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C4C48 size=488
    let mut pc: u32 = 0x825C4C48;
    'dispatch: loop {
        match pc {
            0x825C4C48 => {
    //   block [0x825C4C48..0x825C4E30)
	// 825C4C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C4C4C: 4BF70461  bl 0x825350ac
	ctx.lr = 0x825C4C50;
	sub_82535080(ctx, base);
	// 825C4C50: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C4E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C4E30 size=540
    let mut pc: u32 = 0x825C4E30;
    'dispatch: loop {
        match pc {
            0x825C4E30 => {
    //   block [0x825C4E30..0x825C504C)
	// 825C4E30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C4E34: 4BF70269  bl 0x8253509c
	ctx.lr = 0x825C4E38;
	sub_82535080(ctx, base);
	// 825C4E38: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5050 size=4
    let mut pc: u32 = 0x825C5050;
    'dispatch: loop {
        match pc {
            0x825C5050 => {
    //   block [0x825C5050..0x825C5054)
	// 825C5050: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5058 size=4
    let mut pc: u32 = 0x825C5058;
    'dispatch: loop {
        match pc {
            0x825C5058 => {
    //   block [0x825C5058..0x825C505C)
	// 825C5058: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5060 size=44
    let mut pc: u32 = 0x825C5060;
    'dispatch: loop {
        match pc {
            0x825C5060 => {
    //   block [0x825C5060..0x825C508C)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5090 size=4
    let mut pc: u32 = 0x825C5090;
    'dispatch: loop {
        match pc {
            0x825C5090 => {
    //   block [0x825C5090..0x825C5094)
	// 825C5090: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5098 size=32
    let mut pc: u32 = 0x825C5098;
    'dispatch: loop {
        match pc {
            0x825C5098 => {
    //   block [0x825C5098..0x825C50B8)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C50B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825C50B8 size=352
    let mut pc: u32 = 0x825C50B8;
    'dispatch: loop {
        match pc {
            0x825C50B8 => {
    //   block [0x825C50B8..0x825C5218)
	// 825C50B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C50BC: 4BF6FFE9  bl 0x825350a4
	ctx.lr = 0x825C50C0;
	sub_82535080(ctx, base);
	// 825C50C0: DBC1FFA0  stfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 825C50C4: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 825C50C8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C50CC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 825C50D0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825C50D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825C50D8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825C50DC: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 825C50E0: C3C92074  lfs f30, 0x2074(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8308 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825C50E4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825C50E8: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825C50EC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825C50F0: 7FD9F378  mr r25, r30
	ctx.r[25].u64 = ctx.r[30].u64;
	// 825C50F4: 3B4BA430  addi r26, r11, -0x5bd0
	ctx.r[26].s64 = ctx.r[11].s64 + -23504;
	// 825C50F8: 3AE00030  li r23, 0x30
	ctx.r[23].s64 = 48;
	// 825C50FC: 7D7BD214  add r11, r27, r26
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[26].u64;
	// 825C5100: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C5104: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C5108: 7D4B0774  extsb r11, r10
	ctx.r[11].s64 = ctx.r[10].s8 as i64;
	// 825C510C: 7D2A0774  extsb r10, r9
	ctx.r[10].s64 = ctx.r[9].s8 as i64;
	// 825C5110: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C5114: 7FE9EA14  add r31, r9, r29
	ctx.r[31].u64 = ctx.r[9].u64 + ctx.r[29].u64;
	// 825C5118: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C511C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825C5120: 41980084  blt cr6, 0x825c51a4
	if ctx.cr[6].lt {
	pc = 0x825C51A4; continue 'dispatch;
	}
	// 825C5124: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C5128: 7F89EA14  add r28, r9, r29
	ctx.r[28].u64 = ctx.r[9].u64 + ctx.r[29].u64;
	// 825C512C: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C5130: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825C5134: 41980070  blt cr6, 0x825c51a4
	if ctx.cr[6].lt {
	pc = 0x825C51A4; continue 'dispatch;
	}
	// 825C5138: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5218 size=560
    let mut pc: u32 = 0x825C5218;
    'dispatch: loop {
        match pc {
            0x825C5218 => {
    //   block [0x825C5218..0x825C5448)
	// 825C5218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C521C: 4BF6FEA1  bl 0x825350bc
	ctx.lr = 0x825C5220;
	sub_82535080(ctx, base);
	// 825C5220: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825C5448 size=576
    let mut pc: u32 = 0x825C5448;
    'dispatch: loop {
        match pc {
            0x825C5448 => {
    //   block [0x825C5448..0x825C5688)
	// 825C5448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C544C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C5450: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C5454: 38E100F4  addi r7, r1, 0xf4
	ctx.r[7].s64 = ctx.r[1].s64 + 244;
	// 825C5458: D02100F4  stfs f1, 0xf4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 825C545C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5688 size=172
    let mut pc: u32 = 0x825C5688;
    'dispatch: loop {
        match pc {
            0x825C5688 => {
    //   block [0x825C5688..0x825C5734)
	// 825C5688: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C5738 size=372
    let mut pc: u32 = 0x825C5738;
    'dispatch: loop {
        match pc {
            0x825C5738 => {
    //   block [0x825C5738..0x825C58AC)
	// 825C5738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C573C: 4BF6F979  bl 0x825350b4
	ctx.lr = 0x825C5740;
	sub_82535080(ctx, base);
	// 825C5740: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C5744: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825C5748: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 825C574C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825C5750: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825C5754: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C58B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C58B0 size=1100
    let mut pc: u32 = 0x825C58B0;
    'dispatch: loop {
        match pc {
            0x825C58B0 => {
    //   block [0x825C58B0..0x825C5940)
	// 825C58B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C58B4: 4BF6F801  bl 0x825350b4
	ctx.lr = 0x825C58B8;
	sub_82535080(ctx, base);
	// 825C58B8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C58BC: 54AB1838  slwi r11, r5, 3
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C58C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825C58C4: 7D6B3378  or r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[6].u64;
	// 825C58C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825C58CC: 394BFFF7  addi r10, r11, -9
	ctx.r[10].s64 = ctx.r[11].s64 + -9;
	// 825C58D0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 825C58D4: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 825C58D8: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 825C58DC: 2B0A0010  cmplwi cr6, r10, 0x10
	ctx.cr[6].compare_u32(ctx.r[10].u32, 16 as u32, &mut ctx.xer);
	// 825C58E0: 41990414  bgt cr6, 0x825c5cf4
	if ctx.cr[6].gt {
	pc = 0x825C5CF4; continue 'dispatch;
	}
	// 825C58E4: 3D80825C  lis r12, -0x7da4
	ctx.r[12].s64 = -2107899904;
	// 825C58E8: 398C58FC  addi r12, r12, 0x58fc
	ctx.r[12].s64 = ctx.r[12].s64 + 22780;
	// 825C58EC: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825C58F0: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825C58F4: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825C58F8: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x825C5940; continue 'dispatch;
		},
		1 => {
	pc = 0x825C5A08; continue 'dispatch;
		},
		2 => {
	pc = 0x825C5AA0; continue 'dispatch;
		},
		3 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		4 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		5 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		6 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		7 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		8 => {
	pc = 0x825C5A40; continue 'dispatch;
		},
		9 => {
	pc = 0x825C5BA0; continue 'dispatch;
		},
		10 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		11 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		12 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		13 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		14 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		15 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		16 => {
	pc = 0x825C5A94; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825C58FC: 825C5940  lwz r18, 0x5940(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(22848 as u32) ) } as u64;
	// 825C5900: 825C5A08  lwz r18, 0x5a08(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23048 as u32) ) } as u64;
	// 825C5904: 825C5AA0  lwz r18, 0x5aa0(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23200 as u32) ) } as u64;
	// 825C5908: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C590C: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C5910: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C5914: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C5918: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C591C: 825C5A40  lwz r18, 0x5a40(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23104 as u32) ) } as u64;
	// 825C5920: 825C5BA0  lwz r18, 0x5ba0(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23456 as u32) ) } as u64;
	// 825C5924: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C5928: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C592C: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C5930: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C5934: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C5938: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C593C: 825C5A94  lwz r18, 0x5a94(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23188 as u32) ) } as u64;
            }
            0x825C5940 => {
    //   block [0x825C5940..0x825C5A08)
	pc = 0x825C5A08; continue 'dispatch;
            }
            0x825C5A08 => {
    //   block [0x825C5A08..0x825C5A40)
	pc = 0x825C5A40; continue 'dispatch;
            }
            0x825C5A40 => {
    //   block [0x825C5A40..0x825C5A94)
	pc = 0x825C5A94; continue 'dispatch;
            }
            0x825C5A94 => {
    //   block [0x825C5A94..0x825C5AA0)
	// 825C5A94: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825C5A98: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 825C5A9C: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	pc = 0x825C5AA0; continue 'dispatch;
            }
            0x825C5AA0 => {
    //   block [0x825C5AA0..0x825C5BA0)
	// 825C5AA0: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	pc = 0x825C5BA0; continue 'dispatch;
            }
            0x825C5BA0 => {
    //   block [0x825C5BA0..0x825C5CF4)
	// 825C5BA0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	pc = 0x825C5CF4; continue 'dispatch;
            }
            0x825C5CF4 => {
    //   block [0x825C5CF4..0x825C5CFC)
	// 825C5CF4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825C5CF8: 4BF6F40C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5D00 size=196
    let mut pc: u32 = 0x825C5D00;
    'dispatch: loop {
        match pc {
            0x825C5D00 => {
    //   block [0x825C5D00..0x825C5DC4)
	// 825C5D00: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5DC4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5DC4 size=36
    let mut pc: u32 = 0x825C5DC4;
    'dispatch: loop {
        match pc {
            0x825C5DC4 => {
    //   block [0x825C5DC4..0x825C5DE8)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5DE8 size=64
    let mut pc: u32 = 0x825C5DE8;
    'dispatch: loop {
        match pc {
            0x825C5DE8 => {
    //   block [0x825C5DE8..0x825C5E28)
	// 825C5DE8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825C5DEC: 419A0018  beq cr6, 0x825c5e04
	if ctx.cr[6].eq {
	pc = 0x825C5E04; continue 'dispatch;
	}
	// 825C5DF0: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5E28 size=12
    let mut pc: u32 = 0x825C5E28;
    'dispatch: loop {
        match pc {
            0x825C5E28 => {
    //   block [0x825C5E28..0x825C5E34)
	// 825C5E28: 1000584A  vsubfp v0, v0, v11
	ctx.fpscr.enable_flush_mode_unconditional();
	for i in 0..4 {
		ctx.v[0].f32[i] = ctx.v[0].f32[i] - ctx.v[11].f32[i];
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C5E38 size=1156
    let mut pc: u32 = 0x825C5E38;
    'dispatch: loop {
        match pc {
            0x825C5E38 => {
    //   block [0x825C5E38..0x825C62BC)
	// 825C5E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C5E3C: 4BF6F26D  bl 0x825350a8
	ctx.lr = 0x825C5E40;
	sub_82535080(ctx, base);
	// 825C5E40: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C5E44: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825C5E48: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825C5E4C: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 825C5E50: 7D0B0774  extsb r11, r8
	ctx.r[11].s64 = ctx.r[8].s8 as i64;
	// 825C5E54: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C62C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C62C0 size=332
    let mut pc: u32 = 0x825C62C0;
    'dispatch: loop {
        match pc {
            0x825C62C0 => {
    //   block [0x825C62C0..0x825C640C)
	// 825C62C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C62C4: 99640008  stb r11, 8(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 825C62C8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C62CC: 99640009  stb r11, 9(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(9 as u32), ctx.r[11].u8 ) };
	// 825C62D0: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C62D4: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 825C62D8: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 825C62DC: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 825C62E0: 41980078  blt cr6, 0x825c6358
	if ctx.cr[6].lt {
	pc = 0x825C6358; continue 'dispatch;
	}
	// 825C62E4: 8143003C  lwz r10, 0x3c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 825C62E8: 5566043E  clrlwi r6, r11, 0x10
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 825C62EC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825C62F0: 5549043E  clrlwi r9, r10, 0x10
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 825C62F4: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 825C62F8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825C62FC: 40990010  ble cr6, 0x825c630c
	if !ctx.cr[6].gt {
	pc = 0x825C630C; continue 'dispatch;
	}
	// 825C6300: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 825C6304: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825C6308: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825C630C: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 825C6310: 40990044  ble cr6, 0x825c6354
	if !ctx.cr[6].gt {
	pc = 0x825C6354; continue 'dispatch;
	}
	// 825C6314: 8143004C  lwz r10, 0x4c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 825C6318: 5567043E  clrlwi r7, r11, 0x10
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 825C631C: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 825C6320: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 825C6324: 7F063840  cmplw cr6, r6, r7
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825C6328: 40990014  ble cr6, 0x825c633c
	if !ctx.cr[6].gt {
	pc = 0x825C633C; continue 'dispatch;
	}
	// 825C632C: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 825C6330: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825C6334: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 825C6338: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 825C633C: 2F080001  cmpwi cr6, r8, 1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 1, &mut ctx.xer);
	// 825C6340: 409A0010  bne cr6, 0x825c6350
	if !ctx.cr[6].eq {
	pc = 0x825C6350; continue 'dispatch;
	}
	// 825C6344: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 825C6348: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 825C634C: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 825C6350: B1440004  sth r10, 4(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 825C6354: B1240002  sth r9, 2(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(2 as u32), ctx.r[9].u16 ) };
	// 825C6358: B1640000  sth r11, 0(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 825C635C: 80E30004  lwz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C6360: 816300EC  lwz r11, 0xec(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(236 as u32) ) } as u64;
	// 825C6364: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 825C6368: 556A043E  clrlwi r10, r11, 0x10
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 825C636C: 41980090  blt cr6, 0x825c63fc
	if ctx.cr[6].lt {
	pc = 0x825C63FC; continue 'dispatch;
	}
	// 825C6370: 816300FC  lwz r11, 0xfc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(252 as u32) ) } as u64;
	// 825C6374: 5546043E  clrlwi r6, r10, 0x10
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 825C6378: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825C637C: 5569043E  clrlwi r9, r11, 0x10
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 825C6380: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825C6384: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825C6388: 40990010  ble cr6, 0x825c6398
	if !ctx.cr[6].gt {
	pc = 0x825C6398; continue 'dispatch;
	}
	// 825C638C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 825C6390: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825C6394: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825C6398: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 825C639C: 40990050  ble cr6, 0x825c63ec
	if !ctx.cr[6].gt {
	pc = 0x825C63EC; continue 'dispatch;
	}
	// 825C63A0: 8163010C  lwz r11, 0x10c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 825C63A4: 5547043E  clrlwi r7, r10, 0x10
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 825C63A8: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 825C63AC: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 825C63B0: 7F063840  cmplw cr6, r6, r7
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825C63B4: 40990014  ble cr6, 0x825c63c8
	if !ctx.cr[6].gt {
	pc = 0x825C63C8; continue 'dispatch;
	}
	// 825C63B8: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 825C63BC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825C63C0: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 825C63C4: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 825C63C8: 2F080001  cmpwi cr6, r8, 1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 1, &mut ctx.xer);
	// 825C63CC: 409A0010  bne cr6, 0x825c63dc
	if !ctx.cr[6].eq {
	pc = 0x825C63DC; continue 'dispatch;
	}
	// 825C63D0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 825C63D4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825C63D8: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 825C63DC: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C63E0: 39080002  addi r8, r8, 2
	ctx.r[8].s64 = ctx.r[8].s64 + 2;
	// 825C63E4: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825C63E8: 7D68232E  sthx r11, r8, r4
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32), ctx.r[11].u16) };
	// 825C63EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C63F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825C63F4: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C63F8: 7D2B232E  sthx r9, r11, r4
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), ctx.r[9].u16) };
	// 825C63FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C6400: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C6404: 7D4B232E  sthx r10, r11, r4
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), ctx.r[10].u16) };
	// 825C6408: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C6410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C6410 size=48
    let mut pc: u32 = 0x825C6410;
    'dispatch: loop {
        match pc {
            0x825C6410 => {
    //   block [0x825C6410..0x825C6440)
	// 825C6410: C004000C  lfs f0, 0xc(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C6414: D0050020  stfs f0, 0x20(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(32 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C6440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C6440 size=48
    let mut pc: u32 = 0x825C6440;
    'dispatch: loop {
        match pc {
            0x825C6440 => {
    //   block [0x825C6440..0x825C6470)
	// 825C6440: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C6444: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825C6448: 409A0028  bne cr6, 0x825c6470
	if !ctx.cr[6].eq {
		sub_825C6470(ctx, base);
		return;
	}
	// 825C644C: 396000A0  li r11, 0xa0
	ctx.r[11].s64 = 160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C6470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C6470 size=20
    let mut pc: u32 = 0x825C6470;
    'dispatch: loop {
        match pc {
            0x825C6470 => {
    //   block [0x825C6470..0x825C6484)
	// 825C6470: 39600130  li r11, 0x130
	ctx.r[11].s64 = 304;
	// 825C6474: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C6488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825C6488 size=680
    let mut pc: u32 = 0x825C6488;
    'dispatch: loop {
        match pc {
            0x825C6488 => {
    //   block [0x825C6488..0x825C6730)
	// 825C6488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C648C: 4BF6EC11  bl 0x8253509c
	ctx.lr = 0x825C6490;
	sub_82535080(ctx, base);
	// 825C6490: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 825C6494: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C6498: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C649C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C64A0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825C64A4: 409A004C  bne cr6, 0x825c64f0
	if !ctx.cr[6].eq {
	pc = 0x825C64F0; continue 'dispatch;
	}
	// 825C64A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C64AC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825C64B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C64B4: 4099003C  ble cr6, 0x825c64f0
	if !ctx.cr[6].gt {
	pc = 0x825C64F0; continue 'dispatch;
	}
	// 825C64B8: 3B9F0020  addi r28, r31, 0x20
	ctx.r[28].s64 = ctx.r[31].s64 + 32;
	// 825C64BC: 38BF00A0  addi r5, r31, 0xa0
	ctx.r[5].s64 = ctx.r[31].s64 + 160;
	// 825C64C0: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 825C64C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825C64C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C64CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C64D0: 4BFFED49  bl 0x825c5218
	ctx.lr = 0x825C64D4;
	sub_825C5218(ctx, base);
	// 825C64D4: 2F03000E  cmpwi cr6, r3, 0xe
	ctx.cr[6].compare_i32(ctx.r[3].s32, 14, &mut ctx.xer);
	// 825C64D8: 419A01FC  beq cr6, 0x825c66d4
	if ctx.cr[6].eq {
	pc = 0x825C66D4; continue 'dispatch;
	}
	// 825C64DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C64E0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825C64E4: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 825C64E8: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825C64EC: 4198FFD8  blt cr6, 0x825c64c4
	if ctx.cr[6].lt {
	pc = 0x825C64C4; continue 'dispatch;
	}
	// 825C64F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C64F4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825C64F8: 409A005C  bne cr6, 0x825c6554
	if !ctx.cr[6].eq {
	pc = 0x825C6554; continue 'dispatch;
	}
	// 825C64FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C6500: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825C6504: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C6508: 4099003C  ble cr6, 0x825c6544
	if !ctx.cr[6].gt {
	pc = 0x825C6544; continue 'dispatch;
	}
	// 825C650C: 3B9F00A0  addi r28, r31, 0xa0
	ctx.r[28].s64 = ctx.r[31].s64 + 160;
	// 825C6510: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 825C6514: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 825C6518: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825C651C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C6520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C6524: 4BFFECF5  bl 0x825c5218
	ctx.lr = 0x825C6528;
	sub_825C5218(ctx, base);
	// 825C6528: 2F03000E  cmpwi cr6, r3, 0xe
	ctx.cr[6].compare_i32(ctx.r[3].s32, 14, &mut ctx.xer);
	// 825C652C: 419A01CC  beq cr6, 0x825c66f8
	if ctx.cr[6].eq {
	pc = 0x825C66F8; continue 'dispatch;
	}
	// 825C6530: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C6534: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825C6538: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 825C653C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825C6540: 4198FFD8  blt cr6, 0x825c6518
	if ctx.cr[6].lt {
	pc = 0x825C6518; continue 'dispatch;
	}
	// 825C6544: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C6548: 3AA00003  li r21, 3
	ctx.r[21].s64 = 3;
	// 825C654C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825C6550: 419A0008  beq cr6, 0x825c6558
	if ctx.cr[6].eq {
	pc = 0x825C6558; continue 'dispatch;
	}
	// 825C6554: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	// 825C6558: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C655C: 3AC00003  li r22, 3
	ctx.r[22].s64 = 3;
	// 825C6560: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825C6564: 419A0008  beq cr6, 0x825c656c
	if ctx.cr[6].eq {
	pc = 0x825C656C; continue 'dispatch;
	}
	// 825C6568: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 825C656C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825C6570: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 825C6574: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 825C6578: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825C657C: 2F150000  cmpwi cr6, r21, 0
	ctx.cr[6].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 825C6580: C3EB8CB4  lfs f31, -0x734c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825C6584: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825C6588: 3B4BA430  addi r26, r11, -0x5bd0
	ctx.r[26].s64 = ctx.r[11].s64 + -23504;
	// 825C658C: 409900B8  ble cr6, 0x825c6644
	if !ctx.cr[6].gt {
	pc = 0x825C6644; continue 'dispatch;
	}
	// 825C6590: 3B7F0020  addi r27, r31, 0x20
	ctx.r[27].s64 = ctx.r[31].s64 + 32;
	// 825C6594: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825C6598: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 825C659C: 40990098  ble cr6, 0x825c6634
	if !ctx.cr[6].gt {
	pc = 0x825C6634; continue 'dispatch;
	}
	// 825C65A0: 3BDF00A0  addi r30, r31, 0xa0
	ctx.r[30].s64 = ctx.r[31].s64 + 160;
	// 825C65A4: 3B3A0002  addi r25, r26, 2
	ctx.r[25].s64 = ctx.r[26].s64 + 2;
	// 825C65A8: 7D7CC8AE  lbzx r11, r28, r25
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 825C65AC: 395A0002  addi r10, r26, 2
	ctx.r[10].s64 = ctx.r[26].s64 + 2;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C6730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825C6730 size=3152
    //   switch @ 0x825C6B38: r11 with 25 label(s)
    //       case  0 → 0x825C6F8C
    //       case  1 → 0x825C7044
    //       case  2 → 0x825C6D04
    //       case  3 → 0x825C6CB8
    //       case  4 → 0x825C7330
    //       case  5 → 0x825C7330
    //       case  6 → 0x825C7330
    //       case  7 → 0x825C7330
    //       case  8 → 0x825C7164
    //       case  9 → 0x825C6C00
    //       case 10 → 0x825C6BA0
    //       case 11 → 0x825C7330
    //       case 12 → 0x825C7330
    //       case 13 → 0x825C7330
    //       case 14 → 0x825C7330
    //       case 15 → 0x825C7330
    //       case 16 → 0x825C6E70
    //       case 17 → 0x825C6BB8
    //       case 18 → 0x825C7330
    //       case 19 → 0x825C7330
    //       case 20 → 0x825C7330
    //       case 21 → 0x825C7330
    //       case 22 → 0x825C7330
    //       case 23 → 0x825C7330
    //       case 24 → 0x825C6E3C
    let mut pc: u32 = 0x825C6730;
    'dispatch: loop {
        match pc {
            0x825C6730 => {
    //   block [0x825C6730..0x825C6BA0)
	// 825C6730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C6734: 4BF6E94D  bl 0x82535080
	ctx.lr = 0x825C6738;
	sub_82535080(ctx, base);
	// 825C6738: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825C673C: 4BF6F8A1  bl 0x82535fdc
	ctx.lr = 0x825C6740;
	sub_82535FB0(ctx, base);
	// 825C6740: 3981FF30  addi r12, r1, -0xd0
	ctx.r[12].s64 = ctx.r[1].s64 + -208;
	// 825C6744: 4BF72C61  bl 0x825393a4
	ctx.lr = 0x825C6748;
	sub_82539130(ctx, base);
	// 825C6748: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C674C: 39C00010  li r14, 0x10
	ctx.r[14].s64 = 16;
	// 825C6750: 90610274  stw r3, 0x274(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(628 as u32), ctx.r[3].u32 ) };
	// 825C6754: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	pc = 0x825C6BA0; continue 'dispatch;
            }
            0x825C6BA0 => {
    //   block [0x825C6BA0..0x825C6BB8)
	// 825C6BA0: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 825C6BA4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 825C6BA8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 825C6BAC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825C6BB0: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 825C6BB4: 48000018  b 0x825c6bcc
	pc = 0x825C6BCC; continue 'dispatch;
            }
            0x825C6BB8 => {
    //   block [0x825C6BB8..0x825C6C00)
	// 825C6BB8: 3920FFF8  li r9, -8
	ctx.r[9].s64 = -8;
	// 825C6BBC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825C6BC0: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 825C6BC4: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 825C6BC8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825C6BCC: 815F0170  lwz r10, 0x170(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 825C6BD0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825C6BD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C6BD8: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 825C6BDC: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 825C6BE0: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825C6BE4: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 825C6BE8: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C6BEC: 4BFFF24D  bl 0x825c5e38
	ctx.lr = 0x825C6BF0;
	sub_825C5E38(ctx, base);
	// 825C6BF0: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 825C6BF4: 419A073C  beq cr6, 0x825c7330
	if ctx.cr[6].eq {
	pc = 0x825C7330; continue 'dispatch;
	}
	// 825C6BF8: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 825C6BFC: 409A0650  bne cr6, 0x825c724c
	if !ctx.cr[6].eq {
	pc = 0x825C724C; continue 'dispatch;
	}
	pc = 0x825C6C00; continue 'dispatch;
            }
            0x825C6C00 => {
    //   block [0x825C6C00..0x825C6CB8)
	// 825C6C00: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
	pc = 0x825C6CB8; continue 'dispatch;
            }
            0x825C6CB8 => {
    //   block [0x825C6CB8..0x825C6D04)
	// 825C6CB8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825C6CBC: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 825C6CC0: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 825C6CC4: 4BFFE785  bl 0x825c5448
	ctx.lr = 0x825C6CC8;
	sub_825C5448(ctx, base);
	// 825C6CC8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825C6CCC: 41980664  blt cr6, 0x825c7330
	if ctx.cr[6].lt {
	pc = 0x825C7330; continue 'dispatch;
	}
	// 825C6CD0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C6CD4: 3943000A  addi r10, r3, 0xa
	ctx.r[10].s64 = ctx.r[3].s64 + 10;
	// 825C6CD8: 3923000E  addi r9, r3, 0xe
	ctx.r[9].s64 = ctx.r[3].s64 + 14;
	// 825C6CDC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C6CE0: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C6CE4: 55292036  slwi r9, r9, 4
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C6CE8: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825C6CEC: 396000D0  li r11, 0xd0
	ctx.r[11].s64 = 208;
	pc = 0x825C6D04; continue 'dispatch;
            }
            0x825C6D04 => {
    //   block [0x825C6D04..0x825C6E3C)
	// 825C6D04: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
	// 825C6D08: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 825C6D0C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825C6D10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C6D14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C6D18: 4BFFE501  bl 0x825c5218
	ctx.lr = 0x825C6D1C;
	sub_825C5218(ctx, base);
	// 825C6D1C: 2F03000E  cmpwi cr6, r3, 0xe
	ctx.cr[6].compare_i32(ctx.r[3].s32, 14, &mut ctx.xer);
	// 825C6D20: 419A052C  beq cr6, 0x825c724c
	if ctx.cr[6].eq {
	pc = 0x825C724C; continue 'dispatch;
	}
	// 825C6D24: 7D6378AE  lbzx r11, r3, r15
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[15].u32)) } as u64;
	// 825C6D28: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825C6D2C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C6D30: 419802D8  blt cr6, 0x825c7008
	if ctx.cr[6].lt {
	pc = 0x825C7008; continue 'dispatch;
	}
	// 825C6D34: 394B000A  addi r10, r11, 0xa
	ctx.r[10].s64 = ctx.r[11].s64 + 10;
	pc = 0x825C6E3C; continue 'dispatch;
            }
            0x825C6E3C => {
    //   block [0x825C6E3C..0x825C6E70)
	// 825C6E3C: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 825C6E40: FC20D090  fmr f1, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[26].f64;
	// 825C6E44: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825C6E48: 4BFFE601  bl 0x825c5448
	ctx.lr = 0x825C6E4C;
	sub_825C5448(ctx, base);
	// 825C6E4C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825C6E50: 419804E0  blt cr6, 0x825c7330
	if ctx.cr[6].lt {
	pc = 0x825C7330; continue 'dispatch;
	}
	// 825C6E54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C6E58: 39430002  addi r10, r3, 2
	ctx.r[10].s64 = ctx.r[3].s64 + 2;
	pc = 0x825C6E70; continue 'dispatch;
            }
            0x825C6E70 => {
    //   block [0x825C6E70..0x825C6F8C)
	// 825C6E70: 38C0FFF8  li r6, -8
	ctx.r[6].s64 = -8;
	// 825C6E74: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 825C6E78: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825C6E7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C6E80: 4BFFE399  bl 0x825c5218
	ctx.lr = 0x825C6E84;
	sub_825C5218(ctx, base);
	// 825C6E84: 2F03000E  cmpwi cr6, r3, 0xe
	ctx.cr[6].compare_i32(ctx.r[3].s32, 14, &mut ctx.xer);
	// 825C6E88: 419A03C4  beq cr6, 0x825c724c
	if ctx.cr[6].eq {
	pc = 0x825C724C; continue 'dispatch;
	}
	// 825C6E8C: 7D6378AE  lbzx r11, r3, r15
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[15].u32)) } as u64;
	// 825C6E90: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825C6E94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C6E98: 419802A0  blt cr6, 0x825c7138
	if ctx.cr[6].lt {
	pc = 0x825C7138; continue 'dispatch;
	}
	// 825C6E9C: 394B0002  addi r10, r11, 2
	ctx.r[10].s64 = ctx.r[11].s64 + 2;
	pc = 0x825C6F8C; continue 'dispatch;
            }
            0x825C6F8C => {
    //   block [0x825C6F8C..0x825C7044)
	pc = 0x825C7044; continue 'dispatch;
            }
            0x825C7044 => {
    //   block [0x825C7044..0x825C7164)
	// 825C7044: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 825C7048: 393F0020  addi r9, r31, 0x20
	ctx.r[9].s64 = ctx.r[31].s64 + 32;
	// 825C704C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 825C7050: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 825C7054: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x825C7164; continue 'dispatch;
            }
            0x825C7164 => {
    //   block [0x825C7164..0x825C7330)
	// 825C7164: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 825C7168: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 825C716C: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 825C7170: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 825C7174: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	pc = 0x825C7330; continue 'dispatch;
            }
            0x825C7330 => {
    //   block [0x825C7330..0x825C7380)
	// 825C7330: 816102A4  lwz r11, 0x2a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(676 as u32) ) } as u64;
	// 825C7334: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C7338: FF1C0000  fcmpu cr6, f28, f0
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[0].f64);
	// 825C733C: 40980024  bge cr6, 0x825c7360
	if !ctx.cr[6].lt {
	pc = 0x825C7360; continue 'dispatch;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C7380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C7380 size=1028
    let mut pc: u32 = 0x825C7380;
    'dispatch: loop {
        match pc {
            0x825C7380 => {
    //   block [0x825C7380..0x825C7784)
	// 825C7380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C7384: 4BF6DD19  bl 0x8253509c
	ctx.lr = 0x825C7388;
	sub_82535080(ctx, base);
	// 825C7388: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C738C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C7390: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825C7394: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825C7398: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825C739C: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 825C73A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C73A4: 3B000030  li r24, 0x30
	ctx.r[24].s64 = 48;
	// 825C73A8: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 825C73AC: 3B2000B0  li r25, 0xb0
	ctx.r[25].s64 = 176;
	// 825C73B0: 3B400003  li r26, 3
	ctx.r[26].s64 = 3;
	// 825C73B4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825C73B8: 41980078  blt cr6, 0x825c7430
	if ctx.cr[6].lt {
	pc = 0x825C7430; continue 'dispatch;
	}
	// 825C73BC: 40990018  ble cr6, 0x825c73d4
	if !ctx.cr[6].gt {
	pc = 0x825C73D4; continue 'dispatch;
	}
	// 825C73C0: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 825C73C4: 39400050  li r10, 0x50
	ctx.r[10].s64 = 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C7788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C7788 size=424
    let mut pc: u32 = 0x825C7788;
    'dispatch: loop {
        match pc {
            0x825C7788 => {
    //   block [0x825C7788..0x825C7930)
	// 825C7788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C778C: 4BF6D92D  bl 0x825350b8
	ctx.lr = 0x825C7790;
	sub_82535080(ctx, base);
	// 825C7790: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C7794: 83AD0000  lwz r29, 0(r13)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C7798: 3BC00014  li r30, 0x14
	ctx.r[30].s64 = 20;
	// 825C779C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825C77A0: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 825C77A4: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 825C77A8: 7D7EE82E  lwzx r11, r30, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 825C77AC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C77B0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825C77B4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825C77B8: 40980020  bge cr6, 0x825c77d8
	if !ctx.cr[6].lt {
	pc = 0x825C77D8; continue 'dispatch;
	}
	// 825C77BC: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825C77C0: 3929A3F8  addi r9, r9, -0x5c08
	ctx.r[9].s64 = ctx.r[9].s64 + -23560;
	// 825C77C4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825C77C8: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825C77CC: 38EA000C  addi r7, r10, 0xc
	ctx.r[7].s64 = ctx.r[10].s64 + 12;
	// 825C77D0: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825C77D4: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825C77D8: 396100E0  addi r11, r1, 0xe0
	ctx.r[11].s64 = ctx.r[1].s64 + 224;
	// 825C77DC: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 825C77E0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825C77E4: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C7930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C7930 size=3720
    //   switch @ 0x825C7AFC: r11 with 25 label(s)
    //       case  0 → 0x825C80F8
    //       case  1 → 0x825C81DC
    //       case  2 → 0x825C7CCC
    //       case  3 → 0x825C7C80
    //       case  4 → 0x825C7F5C
    //       case  5 → 0x825C7F5C
    //       case  6 → 0x825C7F5C
    //       case  7 → 0x825C7F5C
    //       case  8 → 0x825C831C
    //       case  9 → 0x825C7BC4
    //       case 10 → 0x825C7B64
    //       case 11 → 0x825C7F5C
    //       case 12 → 0x825C7F5C
    //       case 13 → 0x825C7F5C
    //       case 14 → 0x825C7F5C
    //       case 15 → 0x825C7F5C
    //       case 16 → 0x825C7E40
    //       case 17 → 0x825C7B7C
    //       case 18 → 0x825C7F5C
    //       case 19 → 0x825C7F5C
    //       case 20 → 0x825C7F5C
    //       case 21 → 0x825C7F5C
    //       case 22 → 0x825C7F5C
    //       case 23 → 0x825C7F5C
    //       case 24 → 0x825C7E08
    let mut pc: u32 = 0x825C7930;
    'dispatch: loop {
        match pc {
            0x825C7930 => {
    //   block [0x825C7930..0x825C7B64)
	// 825C7930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C7934: 4BF6D74D  bl 0x82535080
	ctx.lr = 0x825C7938;
	sub_82535080(ctx, base);
	// 825C7938: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825C793C: 4BF6E6A5  bl 0x82535fe0
	ctx.lr = 0x825C7940;
	sub_82535FB0(ctx, base);
	// 825C7940: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C7944: 7CD53378  mr r21, r6
	ctx.r[21].u64 = ctx.r[6].u64;
	// 825C7948: 90A10204  stw r5, 0x204(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(516 as u32), ctx.r[5].u32 ) };
	// 825C794C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825C7950: 90E10214  stw r7, 0x214(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(532 as u32), ctx.r[7].u32 ) };
	// 825C7954: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C7958: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 825C795C: 39F50010  addi r15, r21, 0x10
	ctx.r[15].s64 = ctx.r[21].s64 + 16;
	// 825C7960: E8950000  ld r4, 0(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) };
	// 825C7964: 392100E0  addi r9, r1, 0xe0
	ctx.r[9].s64 = ctx.r[1].s64 + 224;
	// 825C7968: E8750008  ld r3, 8(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) };
	// 825C796C: 39D50020  addi r14, r21, 0x20
	ctx.r[14].s64 = ctx.r[21].s64 + 32;
	// 825C7970: 390100D0  addi r8, r1, 0xd0
	ctx.r[8].s64 = ctx.r[1].s64 + 208;
	// 825C7974: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C7978: 38B50030  addi r5, r21, 0x30
	ctx.r[5].s64 = ctx.r[21].s64 + 48;
	// 825C797C: 936101FC  stw r27, 0x1fc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(508 as u32), ctx.r[27].u32 ) };
	// 825C7980: EBCF0008  ld r30, 8(r15)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[15].u32.wrapping_add(8 as u32) ) };
	// 825C7984: 38E100F0  addi r7, r1, 0xf0
	ctx.r[7].s64 = ctx.r[1].s64 + 240;
	// 825C7988: F88A0000  std r4, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u64 ) };
	// 825C798C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C7990: F86A0008  std r3, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[3].u64 ) };
	// 825C7994: 3B5F0004  addi r26, r31, 4
	ctx.r[26].s64 = ctx.r[31].s64 + 4;
	// 825C7998: E94F0000  ld r10, 0(r15)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) };
	// 825C799C: 38CB000E  addi r6, r11, 0xe
	ctx.r[6].s64 = ctx.r[11].s64 + 14;
	// 825C79A0: E88E0000  ld r4, 0(r14)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[14].u32.wrapping_add(0 as u32) ) };
	// 825C79A4: EBAE0008  ld r29, 8(r14)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[14].u32.wrapping_add(8 as u32) ) };
	// 825C79A8: 54C62036  slwi r6, r6, 4
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 825C79AC: E8650000  ld r3, 0(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	// 825C79B0: E8A50008  ld r5, 8(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	// 825C79B4: 7CC6FA14  add r6, r6, r31
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[31].u64;
	// 825C79B8: F9490000  std r10, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 825C79BC: 3940FFC0  li r10, -0x40
	ctx.r[10].s64 = -64;
	// 825C79C0: FBC90008  std r30, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[30].u64 ) };
	// 825C79C4: 392100B0  addi r9, r1, 0xb0
	ctx.r[9].s64 = ctx.r[1].s64 + 176;
	// 825C79C8: F8880000  std r4, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u64 ) };
	// 825C79CC: FBA80008  std r29, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 825C79D0: F8670000  std r3, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[3].u64 ) };
	// 825C79D4: F8A70008  std r5, 8(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	pc = 0x825C7B64; continue 'dispatch;
            }
            0x825C7B64 => {
    //   block [0x825C7B64..0x825C7B7C)
	// 825C7B64: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 825C7B68: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 825C7B6C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 825C7B70: 38BF00A0  addi r5, r31, 0xa0
	ctx.r[5].s64 = ctx.r[31].s64 + 160;
	// 825C7B74: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 825C7B78: 48000018  b 0x825c7b90
	pc = 0x825C7B90; continue 'dispatch;
            }
            0x825C7B7C => {
    //   block [0x825C7B7C..0x825C7BC4)
	// 825C7B7C: 3920FFF8  li r9, -8
	ctx.r[9].s64 = -8;
	// 825C7B80: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825C7B84: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 825C7B88: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 825C7B8C: 389F00A0  addi r4, r31, 0xa0
	ctx.r[4].s64 = ctx.r[31].s64 + 160;
	// 825C7B90: 815F0170  lwz r10, 0x170(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 825C7B94: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825C7B98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C7B9C: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 825C7BA0: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 825C7BA4: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825C7BA8: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 825C7BAC: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C7BB0: 4BFFE289  bl 0x825c5e38
	ctx.lr = 0x825C7BB4;
	sub_825C5E38(ctx, base);
	// 825C7BB4: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 825C7BB8: 419A03A4  beq cr6, 0x825c7f5c
	if ctx.cr[6].eq {
	pc = 0x825C7F5C; continue 'dispatch;
	}
	// 825C7BBC: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 825C7BC0: 409A085C  bne cr6, 0x825c841c
	if !ctx.cr[6].eq {
	pc = 0x825C841C; continue 'dispatch;
	}
	pc = 0x825C7BC4; continue 'dispatch;
            }
            0x825C7BC4 => {
    //   block [0x825C7BC4..0x825C7C80)
	// 825C7BC4: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
	// 825C7BC8: 3B9F0030  addi r28, r31, 0x30
	ctx.r[28].s64 = ctx.r[31].s64 + 48;
	// 825C7BCC: 3BBF00A0  addi r29, r31, 0xa0
	ctx.r[29].s64 = ctx.r[31].s64 + 160;
	// 825C7BD0: 3B7F00B0  addi r27, r31, 0xb0
	ctx.r[27].s64 = ctx.r[31].s64 + 176;
	// 825C7BD4: 396100F0  addi r11, r1, 0xf0
	ctx.r[11].s64 = ctx.r[1].s64 + 240;
	pc = 0x825C7C80; continue 'dispatch;
            }
            0x825C7C80 => {
    //   block [0x825C7C80..0x825C7CCC)
	// 825C7C80: 389F00A0  addi r4, r31, 0xa0
	ctx.r[4].s64 = ctx.r[31].s64 + 160;
	// 825C7C84: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 825C7C88: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 825C7C8C: 4BFFD7BD  bl 0x825c5448
	ctx.lr = 0x825C7C90;
	sub_825C5448(ctx, base);
	// 825C7C90: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825C7C94: 419802C8  blt cr6, 0x825c7f5c
	if ctx.cr[6].lt {
	pc = 0x825C7F5C; continue 'dispatch;
	}
	// 825C7C98: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C7C9C: 3943000A  addi r10, r3, 0xa
	ctx.r[10].s64 = ctx.r[3].s64 + 10;
	// 825C7CA0: 3923000E  addi r9, r3, 0xe
	ctx.r[9].s64 = ctx.r[3].s64 + 14;
	// 825C7CA4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C7CA8: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C7CAC: 55292036  slwi r9, r9, 4
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C7CB0: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825C7CB4: 396000D0  li r11, 0xd0
	ctx.r[11].s64 = 208;
	pc = 0x825C7CCC; continue 'dispatch;
            }
            0x825C7CCC => {
    //   block [0x825C7CCC..0x825C7E08)
	// 825C7CCC: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
	// 825C7CD0: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 825C7CD4: 38BF00A0  addi r5, r31, 0xa0
	ctx.r[5].s64 = ctx.r[31].s64 + 160;
	// 825C7CD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C7CDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C7CE0: 4BFFD539  bl 0x825c5218
	ctx.lr = 0x825C7CE4;
	sub_825C5218(ctx, base);
	// 825C7CE4: 2F03000E  cmpwi cr6, r3, 0xe
	ctx.cr[6].compare_i32(ctx.r[3].s32, 14, &mut ctx.xer);
	// 825C7CE8: 419A0734  beq cr6, 0x825c841c
	if ctx.cr[6].eq {
	pc = 0x825C841C; continue 'dispatch;
	}
	// 825C7CEC: 816100A8  lwz r11, 0xa8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 825C7CF0: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825C7CF4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825C7CF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C7CFC: 419804A4  blt cr6, 0x825c81a0
	if ctx.cr[6].lt {
	pc = 0x825C81A0; continue 'dispatch;
	}
	// 825C7D00: 394B000A  addi r10, r11, 0xa
	ctx.r[10].s64 = ctx.r[11].s64 + 10;
	pc = 0x825C7E08; continue 'dispatch;
            }
            0x825C7E08 => {
    //   block [0x825C7E08..0x825C7E40)
	// 825C7E08: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 825C7E0C: FC20D090  fmr f1, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[26].f64;
	// 825C7E10: 387F00A0  addi r3, r31, 0xa0
	ctx.r[3].s64 = ctx.r[31].s64 + 160;
	// 825C7E14: 4BFFD635  bl 0x825c5448
	ctx.lr = 0x825C7E18;
	sub_825C5448(ctx, base);
	// 825C7E18: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825C7E1C: 41980140  blt cr6, 0x825c7f5c
	if ctx.cr[6].lt {
	pc = 0x825C7F5C; continue 'dispatch;
	}
	// 825C7E20: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C7E24: 39430002  addi r10, r3, 2
	ctx.r[10].s64 = ctx.r[3].s64 + 2;
	// 825C7E28: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C7E2C: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C7E30: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825C7E34: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	pc = 0x825C7E40; continue 'dispatch;
            }
            0x825C7E40 => {
    //   block [0x825C7E40..0x825C7F5C)
	// 825C7E40: 3BDF00A0  addi r30, r31, 0xa0
	ctx.r[30].s64 = ctx.r[31].s64 + 160;
	// 825C7E44: 38C0FFF8  li r6, -8
	ctx.r[6].s64 = -8;
	// 825C7E48: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 825C7E4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C7E50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C7E54: 4BFFD3C5  bl 0x825c5218
	ctx.lr = 0x825C7E58;
	sub_825C5218(ctx, base);
	// 825C7E58: 2F03000E  cmpwi cr6, r3, 0xe
	ctx.cr[6].compare_i32(ctx.r[3].s32, 14, &mut ctx.xer);
	// 825C7E5C: 419A05C0  beq cr6, 0x825c841c
	if ctx.cr[6].eq {
	pc = 0x825C841C; continue 'dispatch;
	}
	// 825C7E60: 816100A8  lwz r11, 0xa8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 825C7E64: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825C7E68: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825C7E6C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C7E70: 41980480  blt cr6, 0x825c82f0
	if ctx.cr[6].lt {
	pc = 0x825C82F0; continue 'dispatch;
	}
	// 825C7E74: 394B0002  addi r10, r11, 2
	ctx.r[10].s64 = ctx.r[11].s64 + 2;
	pc = 0x825C7F5C; continue 'dispatch;
            }
            0x825C7F5C => {
    //   block [0x825C7F5C..0x825C80F8)
	// 825C7F5C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 825C7F60: 3BDF0120  addi r30, r31, 0x120
	ctx.r[30].s64 = ctx.r[31].s64 + 288;
	// 825C7F64: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 825C7F68: 390000A0  li r8, 0xa0
	ctx.r[8].s64 = 160;
	// 825C7F6C: 3BBF0020  addi r29, r31, 0x20
	ctx.r[29].s64 = ctx.r[31].s64 + 32;
	// 825C7F70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	pc = 0x825C80F8; continue 'dispatch;
            }
            0x825C80F8 => {
    //   block [0x825C80F8..0x825C81DC)
	// 825C80F8: 396000A0  li r11, 0xa0
	ctx.r[11].s64 = 160;
	// 825C80FC: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825C81DC; continue 'dispatch;
            }
            0x825C81DC => {
    //   block [0x825C81DC..0x825C831C)
	// 825C81DC: 397F00A0  addi r11, r31, 0xa0
	ctx.r[11].s64 = ctx.r[31].s64 + 160;
	// 825C81E0: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 825C81E4: 393F0020  addi r9, r31, 0x20
	ctx.r[9].s64 = ctx.r[31].s64 + 32;
	// 825C81E8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 825C81EC: 38DF0120  addi r6, r31, 0x120
	ctx.r[6].s64 = ctx.r[31].s64 + 288;
	pc = 0x825C831C; continue 'dispatch;
            }
            0x825C831C => {
    //   block [0x825C831C..0x825C87B8)
	// 825C831C: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 825C8320: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825C8324: 391F00A0  addi r8, r31, 0xa0
	ctx.r[8].s64 = ctx.r[31].s64 + 160;
	// 825C8328: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 825C832C: 38FF0120  addi r7, r31, 0x120
	ctx.r[7].s64 = ctx.r[31].s64 + 288;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C87B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825C87B8 size=464
    let mut pc: u32 = 0x825C87B8;
    'dispatch: loop {
        match pc {
            0x825C87B8 => {
    //   block [0x825C87B8..0x825C8988)
	// 825C87B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C87BC: 4BF6C8F9  bl 0x825350b4
	ctx.lr = 0x825C87C0;
	sub_82535080(ctx, base);
	// 825C87C0: 9421FDE0  stwu r1, -0x220(r1)
	ea = ctx.r[1].u32.wrapping_add(-544 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C87C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825C87C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825C87CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C87D0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825C87D4: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825C87D8: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 825C87DC: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 825C87E0: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 825C87E4: 895E0009  lbz r10, 9(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(9 as u32) ) } as u64;
	// 825C87E8: 897E000A  lbz r11, 0xa(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(10 as u32) ) } as u64;
	// 825C87EC: 88BE0008  lbz r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C87F0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C87F4: 83BF000C  lwz r29, 0xc(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825C87F8: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 825C87FC: 556AE13E  srwi r10, r11, 4
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C8800: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 825C8804: 90A10070  stw r5, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[5].u32 ) };
	// 825C8808: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 825C880C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 825C8810: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C8814: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 825C8818: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C881C: 4E800421  bctrl
	ctx.lr = 0x825C8820;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C8820: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825C8824: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C8828: 38C10150  addi r6, r1, 0x150
	ctx.r[6].s64 = ctx.r[1].s64 + 336;
	// 825C882C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C8830: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825C8834: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C8838: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825C883C: 816A0034  lwz r11, 0x34(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 825C8840: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C8844: 4E800421  bctrl
	ctx.lr = 0x825C8848;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C8848: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 825C884C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825C8850: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C8854: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825C8858: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C885C: 4BFFF0D5  bl 0x825c7930
	ctx.lr = 0x825C8860;
	sub_825C7930(ctx, base);
	// 825C8860: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825C8864: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C8868: 419A0010  beq cr6, 0x825c8878
	if ctx.cr[6].eq {
	pc = 0x825C8878; continue 'dispatch;
	}
	// 825C886C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C8870: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825C8874: 4BFFDA4D  bl 0x825c62c0
	ctx.lr = 0x825C8878;
	sub_825C62C0(ctx, base);
	// 825C8878: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825C887C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C8880: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825C8884: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C8888: C1A1006C  lfs f13, 0x6c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C888C: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C8988 size=176
    let mut pc: u32 = 0x825C8988;
    'dispatch: loop {
        match pc {
            0x825C8988 => {
    //   block [0x825C8988..0x825C8A38)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C8A38 size=36
    let mut pc: u32 = 0x825C8A38;
    'dispatch: loop {
        match pc {
            0x825C8A38 => {
    //   block [0x825C8A38..0x825C8A5C)
	// 825C8A38: ED8C682A  fadds f12, f12, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 825C8A3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825C8A40: C1AB298C  lfs f13, 0x298c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10636 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C8A44: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 825C8A48: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825C8A4C: 40990010  ble cr6, 0x825c8a5c
	if !ctx.cr[6].gt {
		sub_825C8A5C(ctx, base);
		return;
	}
	// 825C8A50: EC0B0024  fdivs f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 825C8A54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825C8A58: 4800000C  b 0x825c8a64
	sub_825C8A5C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8A5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C8A5C size=36
    let mut pc: u32 = 0x825C8A5C;
    'dispatch: loop {
        match pc {
            0x825C8A5C => {
    //   block [0x825C8A5C..0x825C8A80)
	// 825C8A5C: FC003090  fmr f0, f6
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[6].f64;
	// 825C8A60: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825C8A64: D001FFE0  stfs f0, -0x20(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 825C8A68: EC0A3838  fmsubs f0, f10, f0, f7
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 - ctx.f[7].f64) as f32) as f64);
	// 825C8A6C: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 825C8A70: 41980010  blt cr6, 0x825c8a80
	if ctx.cr[6].lt {
		sub_825C8A80(ctx, base);
		return;
	}
	// 825C8A74: FC003090  fmr f0, f6
	ctx.f[0].f64 = ctx.f[6].f64;
	// 825C8A78: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825C8A7C: 48000014  b 0x825c8a90
	sub_825C8A80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C8A80 size=44
    let mut pc: u32 = 0x825C8A80;
    'dispatch: loop {
        match pc {
            0x825C8A80 => {
    //   block [0x825C8A80..0x825C8AAC)
	// 825C8A80: FF004000  fcmpu cr6, f0, f8
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[8].f64);
	// 825C8A84: 41990048  bgt cr6, 0x825c8acc
	if ctx.cr[6].gt {
		sub_825C8ACC(ctx, base);
		return;
	}
	// 825C8A88: FC004090  fmr f0, f8
	ctx.f[0].f64 = ctx.f[8].f64;
	// 825C8A8C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825C8A90: D001FFE4  stfs f0, -0x1c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), tmp.u32 ) };
	// 825C8A94: EC0A283A  fmadds f0, f10, f0, f5
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[5].f64) as f32) as f64);
	// 825C8A98: FF004000  fcmpu cr6, f0, f8
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[8].f64);
	// 825C8A9C: 41990010  bgt cr6, 0x825c8aac
	if ctx.cr[6].gt {
		sub_825C8AAC(ctx, base);
		return;
	}
	// 825C8AA0: D101FFE0  stfs f8, -0x20(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 825C8AA4: 60630002  ori r3, r3, 2
	ctx.r[3].u64 = ctx.r[3].u64 | 2;
	// 825C8AA8: 4800002C  b 0x825c8ad4
	sub_825C8ACC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8AAC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C8AAC size=20
    let mut pc: u32 = 0x825C8AAC;
    'dispatch: loop {
        match pc {
            0x825C8AAC => {
    //   block [0x825C8AAC..0x825C8AC0)
	// 825C8AAC: FF002000  fcmpu cr6, f0, f4
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[4].f64);
	// 825C8AB0: 41980010  blt cr6, 0x825c8ac0
	if ctx.cr[6].lt {
		sub_825C8AC0(ctx, base);
		return;
	}
	// 825C8AB4: D0C1FFE0  stfs f6, -0x20(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 825C8AB8: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 825C8ABC: 48000018  b 0x825c8ad4
	sub_825C8ACC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C8AC0 size=12
    let mut pc: u32 = 0x825C8AC0;
    'dispatch: loop {
        match pc {
            0x825C8AC0 => {
    //   block [0x825C8AC0..0x825C8ACC)
	// 825C8AC0: EC002024  fdivs f0, f0, f4
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[4].f64) as f32) as f64;
	// 825C8AC4: D001FFE0  stfs f0, -0x20(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 825C8AC8: 4800000C  b 0x825c8ad4
	sub_825C8ACC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8ACC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C8ACC size=88
    let mut pc: u32 = 0x825C8ACC;
    'dispatch: loop {
        match pc {
            0x825C8ACC => {
    //   block [0x825C8ACC..0x825C8B24)
	// 825C8ACC: EC004824  fdivs f0, f0, f9
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[9].f64) as f32) as f64;
	// 825C8AD0: D001FFE4  stfs f0, -0x1c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), tmp.u32 ) };
	// 825C8AD4: 3941FFE0  addi r10, r1, -0x20
	ctx.r[10].s64 = ctx.r[1].s64 + -32;
	// 825C8AD8: 3921FFE4  addi r9, r1, -0x1c
	ctx.r[9].s64 = ctx.r[1].s64 + -28;
	// 825C8ADC: 39670010  addi r11, r7, 0x10
	ctx.r[11].s64 = ctx.r[7].s64 + 16;
	// 825C8AE0: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C8B28 size=76
    let mut pc: u32 = 0x825C8B28;
    'dispatch: loop {
        match pc {
            0x825C8B28 => {
    //   block [0x825C8B28..0x825C8B74)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8B74(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C8B74 size=28
    let mut pc: u32 = 0x825C8B74;
    'dispatch: loop {
        match pc {
            0x825C8B74 => {
    //   block [0x825C8B74..0x825C8B90)
	// 825C8B74: C1A1FFF4  lfs f13, -0xc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C8B78: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825C8B7C: 41980014  blt cr6, 0x825c8b90
	if ctx.cr[6].lt {
		sub_825C8B90(ctx, base);
		return;
	}
	// 825C8B80: 100D000A  vaddfp v0, v13, v0
	ctx.fpscr.enable_flush_mode_unconditional();
	for i in 0..4 {
		ctx.v[0].f32[i] = ctx.v[13].f32[i] + ctx.v[0].f32[i];
	}
	// 825C8B84: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C8B90 size=36
    let mut pc: u32 = 0x825C8B90;
    'dispatch: loop {
        match pc {
            0x825C8B90 => {
    //   block [0x825C8B90..0x825C8BB4)
	// 825C8B90: 3961FFF4  addi r11, r1, -0xc
	ctx.r[11].s64 = ctx.r[1].s64 + -12;
	// 825C8B94: EC006824  fdivs f0, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 825C8B98: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 825C8B9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C8BB8 size=212
    let mut pc: u32 = 0x825C8BB8;
    'dispatch: loop {
        match pc {
            0x825C8BB8 => {
    //   block [0x825C8BB8..0x825C8C8C)
	// 825C8BB8: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C8C90 size=188
    let mut pc: u32 = 0x825C8C90;
    'dispatch: loop {
        match pc {
            0x825C8C90 => {
    //   block [0x825C8C90..0x825C8D4C)
	// 825C8C90: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C8D50 size=324
    let mut pc: u32 = 0x825C8D50;
    'dispatch: loop {
        match pc {
            0x825C8D50 => {
    //   block [0x825C8D50..0x825C8E94)
	// 825C8D50: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C8E98 size=196
    let mut pc: u32 = 0x825C8E98;
    'dispatch: loop {
        match pc {
            0x825C8E98 => {
    //   block [0x825C8E98..0x825C8F5C)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8F5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C8F5C size=104
    let mut pc: u32 = 0x825C8F5C;
    'dispatch: loop {
        match pc {
            0x825C8F5C => {
    //   block [0x825C8F5C..0x825C8FC4)
	// 825C8F5C: 114A584A  vsubfp v10, v10, v11
	ctx.fpscr.enable_flush_mode_unconditional();
	for i in 0..4 {
		ctx.v[10].f32[i] = ctx.v[10].f32[i] - ctx.v[11].f32[i];
	}
	// 825C8F60: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 825C8F64: FF0A6800  fcmpu cr6, f10, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[13].f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8FC4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C8FC4 size=12
    let mut pc: u32 = 0x825C8FC4;
    'dispatch: loop {
        match pc {
            0x825C8FC4 => {
    //   block [0x825C8FC4..0x825C8FD0)
	// 825C8FC4: D0070000  stfs f0, 0(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825C8FC8: D0070008  stfs f0, 8(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825C8FCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C8FD0 size=56
    let mut pc: u32 = 0x825C8FD0;
    'dispatch: loop {
        match pc {
            0x825C8FD0 => {
    //   block [0x825C8FD0..0x825C9008)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C9008 size=68
    let mut pc: u32 = 0x825C9008;
    'dispatch: loop {
        match pc {
            0x825C9008 => {
    //   block [0x825C9008..0x825C904C)
	// 825C9008: C181FFF0  lfs f12, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825C900C: 3961FFF8  addi r11, r1, -8
	ctx.r[11].s64 = ctx.r[1].s64 + -8;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C904C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C904C size=48
    let mut pc: u32 = 0x825C904C;
    'dispatch: loop {
        match pc {
            0x825C904C => {
    //   block [0x825C904C..0x825C907C)
	// 825C904C: 1000604A  vsubfp v0, v0, v12
	ctx.fpscr.enable_flush_mode_unconditional();
	for i in 0..4 {
		ctx.v[0].f32[i] = ctx.v[0].f32[i] - ctx.v[12].f32[i];
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9080 size=896
    let mut pc: u32 = 0x825C9080;
    'dispatch: loop {
        match pc {
            0x825C9080 => {
    //   block [0x825C9080..0x825C9400)
	// 825C9080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C9088: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825C908C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C9090: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C9094: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 825C9098: 113F038C  vspltisw v9, -1
	for i in 0..4 {
		ctx.v[9].u32[i] = 4294967295;
	}
	// 825C909C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 825C90A0: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 825C90A4: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 825C90A8: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C9400 size=1380
    let mut pc: u32 = 0x825C9400;
    'dispatch: loop {
        match pc {
            0x825C9400 => {
    //   block [0x825C9400..0x825C9964)
	// 825C9400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9404: 4BF6BCB5  bl 0x825350b8
	ctx.lr = 0x825C9408;
	sub_82535080(ctx, base);
	// 825C9408: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 825C940C: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 825C9410: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825C9414: 3BE50010  addi r31, r5, 0x10
	ctx.r[31].s64 = ctx.r[5].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C9968 size=324
    let mut pc: u32 = 0x825C9968;
    'dispatch: loop {
        match pc {
            0x825C9968 => {
    //   block [0x825C9968..0x825C9AAC)
	// 825C9968: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9AB0 size=588
    let mut pc: u32 = 0x825C9AB0;
    'dispatch: loop {
        match pc {
            0x825C9AB0 => {
    //   block [0x825C9AB0..0x825C9CFC)
	// 825C9AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9AB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C9AB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C9ABC: DBA1FFD8  stfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[29].u64 ) };
	// 825C9AC0: DBC1FFE0  stfd f30, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 825C9AC4: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 825C9AC8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C9ACC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C9D00 size=2656
    let mut pc: u32 = 0x825C9D00;
    'dispatch: loop {
        match pc {
            0x825C9D00 => {
    //   block [0x825C9D00..0x825CA760)
	// 825C9D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9D04: 4BF6B389  bl 0x8253508c
	ctx.lr = 0x825C9D08;
	sub_82535080(ctx, base);
	// 825C9D08: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 825C9D0C: 4BF6C2D9  bl 0x82535fe4
	ctx.lr = 0x825C9D10;
	sub_82535FB0(ctx, base);
	// 825C9D10: 3980FF40  li r12, -0xc0
	ctx.r[12].s64 = -192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825CA760 size=36
    let mut pc: u32 = 0x825CA760;
    'dispatch: loop {
        match pc {
            0x825CA760 => {
    //   block [0x825CA760..0x825CA784)
	// 825CA760: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825CA764: 546AE000  rlwinm r10, r3, 0x1c, 0, 0
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 825CA768: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CA76C: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 825CA770: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 825CA774: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 825CA778: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 825CA77C: C021FFF0  lfs f1, -0x10(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825CA780: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA788 size=148
    let mut pc: u32 = 0x825CA788;
    'dispatch: loop {
        match pc {
            0x825CA788 => {
    //   block [0x825CA788..0x825CA81C)
	// 825CA788: 7C8B2670  srawi r11, r4, 4
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[4].s32 >> 4) as i64;
	// 825CA78C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825CA790: 7D6A58F8  nor r10, r11, r11
	ctx.r[10].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CA794: 7D6958F8  nor r9, r11, r11
	ctx.r[9].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CA798: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CA79C: 5547EFFE  rlwinm r7, r10, 0x1d, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 825CA7A0: 5526F7FE  rlwinm r6, r9, 0x1e, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 825CA7A4: 556BFFFE  rlwinm r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 825CA7A8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825CA7AC: 419A0030  beq cr6, 0x825ca7dc
	if ctx.cr[6].eq {
	pc = 0x825CA7DC; continue 'dispatch;
	}
	// 825CA7B0: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825CA7B4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA7B8: 7D293214  add r9, r9, r6
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[6].u64;
	// 825CA7BC: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825CA7C0: 7D094830  slw r9, r8, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[8].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 825CA7C4: 5524083C  slwi r4, r9, 1
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 825CA7C8: 7C845038  and r4, r4, r10
	ctx.r[4].u64 = ctx.r[4].u64 & ctx.r[10].u64;
	// 825CA7CC: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 825CA7D0: 409A000C  bne cr6, 0x825ca7dc
	if !ctx.cr[6].eq {
	pc = 0x825CA7DC; continue 'dispatch;
	}
	// 825CA7D4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825CA7D8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825CA7DC: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 825CA7E0: 419A0034  beq cr6, 0x825ca814
	if ctx.cr[6].eq {
	pc = 0x825CA814; continue 'dispatch;
	}
	// 825CA7E4: 394B0002  addi r10, r11, 2
	ctx.r[10].s64 = ctx.r[11].s64 + 2;
	// 825CA7E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA7EC: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CA7F0: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825CA7F4: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CA7F8: 7D0A5030  slw r10, r8, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[8].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825CA7FC: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825CA800: 7D295838  and r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[11].u64;
	// 825CA804: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825CA808: 409A000C  bne cr6, 0x825ca814
	if !ctx.cr[6].eq {
	pc = 0x825CA814; continue 'dispatch;
	}
	// 825CA80C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825CA810: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CA814: 2F050002  cmpwi cr6, r5, 2
	ctx.cr[6].compare_i32(ctx.r[5].s32, 2, &mut ctx.xer);
	// 825CA818: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA81C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA81C size=40
    let mut pc: u32 = 0x825CA81C;
    'dispatch: loop {
        match pc {
            0x825CA81C => {
    //   block [0x825CA81C..0x825CA844)
	// 825CA81C: 39460004  addi r10, r6, 4
	ctx.r[10].s64 = ctx.r[6].s64 + 4;
	// 825CA820: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA824: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CA828: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825CA82C: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CA830: 7D0A5030  slw r10, r8, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[8].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825CA834: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825CA838: 7D295838  and r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[11].u64;
	// 825CA83C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825CA840: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA844(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA844 size=12
    let mut pc: u32 = 0x825CA844;
    'dispatch: loop {
        match pc {
            0x825CA844 => {
    //   block [0x825CA844..0x825CA850)
	// 825CA844: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825CA848: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CA84C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA850 size=80
    let mut pc: u32 = 0x825CA850;
    'dispatch: loop {
        match pc {
            0x825CA850 => {
    //   block [0x825CA850..0x825CA8A0)
	// 825CA850: 7C8B2670  srawi r11, r4, 4
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[4].s32 >> 4) as i64;
	// 825CA854: 5488073E  clrlwi r8, r4, 0x1c
	ctx.r[8].u64 = ctx.r[4].u32 as u64 & 0x0000000Fu64;
	// 825CA858: 7D6A58F8  nor r10, r11, r11
	ctx.r[10].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CA85C: 7D6958F8  nor r9, r11, r11
	ctx.r[9].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CA860: 7D6758F8  nor r7, r11, r11
	ctx.r[7].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CA864: 554BEFFE  rlwinm r11, r10, 0x1d, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 825CA868: 552AF7FE  rlwinm r10, r9, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 825CA86C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825CA870: 54E9FFFE  rlwinm r9, r7, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 825CA874: 409A0038  bne cr6, 0x825ca8ac
	if !ctx.cr[6].eq {
		sub_825CA8AC(ctx, base);
		return;
	}
	// 825CA878: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825CA87C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA880: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825CA884: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 825CA888: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CA88C: 7D0A5030  slw r10, r8, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[8].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825CA890: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825CA894: 7D295838  and r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[11].u64;
	// 825CA898: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825CA89C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA8A0 size=12
    let mut pc: u32 = 0x825CA8A0;
    'dispatch: loop {
        match pc {
            0x825CA8A0 => {
    //   block [0x825CA8A0..0x825CA8AC)
	// 825CA8A0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825CA8A4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CA8A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA8AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA8AC size=56
    let mut pc: u32 = 0x825CA8AC;
    'dispatch: loop {
        match pc {
            0x825CA8AC => {
    //   block [0x825CA8AC..0x825CA8E4)
	// 825CA8AC: 2F080001  cmpwi cr6, r8, 1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 1, &mut ctx.xer);
	// 825CA8B0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825CA8B4: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	// 825CA8B8: 419A0008  beq cr6, 0x825ca8c0
	if ctx.cr[6].eq {
	pc = 0x825CA8C0; continue 'dispatch;
	}
	// 825CA8BC: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 825CA8C0: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825CA8C4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA8C8: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825CA8CC: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825CA8D0: 7D0B5830  slw r11, r8, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[8].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825CA8D4: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825CA8D8: 7D295038  and r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	// 825CA8DC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825CA8E0: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA8E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA8E4 size=12
    let mut pc: u32 = 0x825CA8E4;
    'dispatch: loop {
        match pc {
            0x825CA8E4 => {
    //   block [0x825CA8E4..0x825CA8F0)
	// 825CA8E4: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825CA8E8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CA8EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA8F0 size=796
    let mut pc: u32 = 0x825CA8F0;
    'dispatch: loop {
        match pc {
            0x825CA8F0 => {
    //   block [0x825CA8F0..0x825CAC0C)
	// 825CA8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CA8F4: 4BF6A7C5  bl 0x825350b8
	ctx.lr = 0x825CA8F8;
	sub_82535080(ctx, base);
	// 825CA8F8: 89440021  lbz r10, 0x21(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(33 as u32) ) } as u64;
	// 825CA8FC: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 825CA900: 41980308  blt cr6, 0x825cac08
	if ctx.cr[6].lt {
	pc = 0x825CAC08; continue 'dispatch;
	}
	// 825CA904: 89640020  lbz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 825CA908: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 825CA90C: 41980010  blt cr6, 0x825ca91c
	if ctx.cr[6].lt {
	pc = 0x825CA91C; continue 'dispatch;
	}
	// 825CA910: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825CA914: 99640022  stb r11, 0x22(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(34 as u32), ctx.r[11].u8 ) };
	// 825CA918: 4BF6A7F0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
	// 825CA91C: 7CAB2670  srawi r11, r5, 4
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[5].s32 >> 4) as i64;
	// 825CA920: 55690738  rlwinm r9, r11, 0, 0x1c, 0x1c
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825CA924: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825CA928: 419A000C  beq cr6, 0x825ca934
	if ctx.cr[6].eq {
	pc = 0x825CA934; continue 'dispatch;
	}
	// 825CA92C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825CA930: 48000014  b 0x825ca944
	pc = 0x825CA944; continue 'dispatch;
	// 825CA934: 556B077A  rlwinm r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825CA938: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825CA93C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825CA940: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 825CA944: 7CCB2670  srawi r11, r6, 4
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> 4) as i64;
	// 825CA948: 55690738  rlwinm r9, r11, 0, 0x1c, 0x1c
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825CA94C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825CA950: 419A000C  beq cr6, 0x825ca95c
	if ctx.cr[6].eq {
	pc = 0x825CA95C; continue 'dispatch;
	}
	// 825CA954: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825CA958: 48000014  b 0x825ca96c
	pc = 0x825CA96C; continue 'dispatch;
	// 825CA95C: 556B077A  rlwinm r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825CA960: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825CA964: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825CA968: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 825CA96C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CA970: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CA974: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825CA978: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825CA97C: 40990250  ble cr6, 0x825cabcc
	if !ctx.cr[6].gt {
	pc = 0x825CABCC; continue 'dispatch;
	}
	// 825CA980: 8BA40021  lbz r29, 0x21(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(33 as u32) ) } as u64;
	// 825CA984: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825CA988: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA98C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 825CA990: 41990098  bgt cr6, 0x825caa28
	if ctx.cr[6].gt {
	pc = 0x825CAA28; continue 'dispatch;
	}
	// 825CA994: 89630001  lbz r11, 1(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 825CA998: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825CA99C: 556BE13E  srwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825CA9A0: 7D6A58F8  nor r10, r11, r11
	ctx.r[10].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CA9A4: 7D6858F8  nor r8, r11, r11
	ctx.r[8].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CA9A8: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CA9AC: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 825CA9B0: 5508F7FE  rlwinm r8, r8, 0x1e, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	// 825CA9B4: 556BFFFE  rlwinm r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 825CA9B8: 419A0028  beq cr6, 0x825ca9e0
	if ctx.cr[6].eq {
	pc = 0x825CA9E0; continue 'dispatch;
	}
	// 825CA9BC: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CA9C0: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825CA9C4: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CA9C8: 7CEA5030  slw r10, r7, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[7].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825CA9CC: 555C083C  slwi r28, r10, 1
	ctx.r[28].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 825CA9D0: 7F9C2838  and r28, r28, r5
	ctx.r[28].u64 = ctx.r[28].u64 & ctx.r[5].u64;
	// 825CA9D4: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 825CA9D8: 409A0008  bne cr6, 0x825ca9e0
	if !ctx.cr[6].eq {
	pc = 0x825CA9E0; continue 'dispatch;
	}
	// 825CA9DC: 7CAA2A14  add r5, r10, r5
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 825CA9E0: 2F1F0001  cmpwi cr6, r31, 1
	ctx.cr[6].compare_i32(ctx.r[31].s32, 1, &mut ctx.xer);
	// 825CA9E4: 419A002C  beq cr6, 0x825caa10
	if ctx.cr[6].eq {
	pc = 0x825CAA10; continue 'dispatch;
	}
	// 825CA9E8: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 825CA9EC: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825CA9F0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825CA9F4: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825CA9F8: 7CEB5830  slw r11, r7, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[7].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825CA9FC: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CAA00: 7D4A2838  and r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[5].u64;
	// 825CAA04: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825CAA08: 409A0008  bne cr6, 0x825caa10
	if !ctx.cr[6].eq {
	pc = 0x825CAA10; continue 'dispatch;
	}
	// 825CAA0C: 7CAB2A14  add r5, r11, r5
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 825CAA10: 2F1F0002  cmpwi cr6, r31, 2
	ctx.cr[6].compare_i32(ctx.r[31].s32, 2, &mut ctx.xer);
	// 825CAA14: 419A01A8  beq cr6, 0x825cabbc
	if ctx.cr[6].eq {
	pc = 0x825CABBC; continue 'dispatch;
	}
	// 825CAA18: 39680004  addi r11, r8, 4
	ctx.r[11].s64 = ctx.r[8].s64 + 4;
	// 825CAA1C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825CAA20: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825CAA24: 4800017C  b 0x825caba0
	pc = 0x825CABA0; continue 'dispatch;
	// 825CAA28: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 825CAA2C: 419900B4  bgt cr6, 0x825caae0
	if ctx.cr[6].gt {
	pc = 0x825CAAE0; continue 'dispatch;
	}
	// 825CAA30: 89630001  lbz r11, 1(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 825CAA34: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825CAA38: 556BE13E  srwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825CAA3C: 7D6A58F8  nor r10, r11, r11
	ctx.r[10].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CAA40: 7D6858F8  nor r8, r11, r11
	ctx.r[8].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CAA44: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CAA48: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 825CAA4C: 5508F7FE  rlwinm r8, r8, 0x1e, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	// 825CAA50: 556BFFFE  rlwinm r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 825CAA54: 419A0028  beq cr6, 0x825caa7c
	if ctx.cr[6].eq {
	pc = 0x825CAA7C; continue 'dispatch;
	}
	// 825CAA58: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CAA5C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825CAA60: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CAA64: 7CEA5030  slw r10, r7, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[7].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825CAA68: 555C083C  slwi r28, r10, 1
	ctx.r[28].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 825CAA6C: 7F9C3038  and r28, r28, r6
	ctx.r[28].u64 = ctx.r[28].u64 & ctx.r[6].u64;
	// 825CAA70: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 825CAA74: 409A0008  bne cr6, 0x825caa7c
	if !ctx.cr[6].eq {
	pc = 0x825CAA7C; continue 'dispatch;
	}
	// 825CAA78: 7CCA3214  add r6, r10, r6
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 825CAA7C: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 825CAA80: 419A002C  beq cr6, 0x825caaac
	if ctx.cr[6].eq {
	pc = 0x825CAAAC; continue 'dispatch;
	}
	// 825CAA84: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 825CAA88: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825CAA8C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825CAA90: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825CAA94: 7CEB5830  slw r11, r7, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[7].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825CAA98: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CAA9C: 7D4A3038  and r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[6].u64;
	// 825CAAA0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825CAAA4: 409A0008  bne cr6, 0x825caaac
	if !ctx.cr[6].eq {
	pc = 0x825CAAAC; continue 'dispatch;
	}
	// 825CAAA8: 7CCB3214  add r6, r11, r6
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 825CAAAC: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 825CAAB0: 419A010C  beq cr6, 0x825cabbc
	if ctx.cr[6].eq {
	pc = 0x825CABBC; continue 'dispatch;
	}
	// 825CAAB4: 39680004  addi r11, r8, 4
	ctx.r[11].s64 = ctx.r[8].s64 + 4;
	// 825CAAB8: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825CAABC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825CAAC0: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825CAAC4: 7CEB5830  slw r11, r7, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[7].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825CAAC8: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CAACC: 7D4A3038  and r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[6].u64;
	// 825CAAD0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825CAAD4: 409A00E8  bne cr6, 0x825cabbc
	if !ctx.cr[6].eq {
	pc = 0x825CABBC; continue 'dispatch;
	}
	// 825CAAD8: 7CCB3214  add r6, r11, r6
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 825CAADC: 480000E0  b 0x825cabbc
	pc = 0x825CABBC; continue 'dispatch;
	// 825CAAE0: 5568073E  clrlwi r8, r11, 0x1c
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 825CAAE4: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 825CAAE8: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825CAAEC: 7D6A58F8  nor r10, r11, r11
	ctx.r[10].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CAAF0: 7D6958F8  nor r9, r11, r11
	ctx.r[9].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CAAF4: 7D7C58F8  nor r28, r11, r11
	ctx.r[28].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CAAF8: 554BEFFE  rlwinm r11, r10, 0x1d, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 825CAAFC: 552AF7FE  rlwinm r10, r9, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 825CAB00: 5789FFFE  rlwinm r9, r28, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	// 825CAB04: 409A0010  bne cr6, 0x825cab14
	if !ctx.cr[6].eq {
	pc = 0x825CAB14; continue 'dispatch;
	}
	// 825CAB08: 552B083C  slwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825CAB0C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825CAB10: 48000020  b 0x825cab30
	pc = 0x825CAB30; continue 'dispatch;
	// 825CAB14: 2F080001  cmpwi cr6, r8, 1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 1, &mut ctx.xer);
	// 825CAB18: 409A000C  bne cr6, 0x825cab24
	if !ctx.cr[6].eq {
	pc = 0x825CAB24; continue 'dispatch;
	}
	// 825CAB1C: 39490002  addi r10, r9, 2
	ctx.r[10].s64 = ctx.r[9].s64 + 2;
	// 825CAB20: 48000008  b 0x825cab28
	pc = 0x825CAB28; continue 'dispatch;
	// 825CAB24: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825CAB28: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CAB2C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825CAB30: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825CAB34: 7CEB5830  slw r11, r7, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[7].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825CAB38: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CAB3C: 7D4A3038  and r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[6].u64;
	// 825CAB40: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825CAB44: 409A0008  bne cr6, 0x825cab4c
	if !ctx.cr[6].eq {
	pc = 0x825CAB4C; continue 'dispatch;
	}
	// 825CAB48: 7CCB3214  add r6, r11, r6
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 825CAB4C: 89630001  lbz r11, 1(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 825CAB50: 5568073E  clrlwi r8, r11, 0x1c
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 825CAB54: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 825CAB58: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825CAB5C: 7D6A58F8  nor r10, r11, r11
	ctx.r[10].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CAB60: 7D6958F8  nor r9, r11, r11
	ctx.r[9].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CAB64: 7D7C58F8  nor r28, r11, r11
	ctx.r[28].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CAB68: 554BEFFE  rlwinm r11, r10, 0x1d, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 825CAB6C: 552AF7FE  rlwinm r10, r9, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 825CAB70: 5789FFFE  rlwinm r9, r28, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	// 825CAB74: 409A0010  bne cr6, 0x825cab84
	if !ctx.cr[6].eq {
	pc = 0x825CAB84; continue 'dispatch;
	}
	// 825CAB78: 552B083C  slwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825CAB7C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825CAB80: 48000020  b 0x825caba0
	pc = 0x825CABA0; continue 'dispatch;
	// 825CAB84: 2F080001  cmpwi cr6, r8, 1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 1, &mut ctx.xer);
	// 825CAB88: 409A000C  bne cr6, 0x825cab94
	if !ctx.cr[6].eq {
	pc = 0x825CAB94; continue 'dispatch;
	}
	// 825CAB8C: 39490002  addi r10, r9, 2
	ctx.r[10].s64 = ctx.r[9].s64 + 2;
	// 825CAB90: 48000008  b 0x825cab98
	pc = 0x825CAB98; continue 'dispatch;
	// 825CAB94: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825CAB98: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CAB9C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825CABA0: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825CABA4: 7CEB5830  slw r11, r7, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[7].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825CABA8: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CABAC: 7D4A2838  and r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[5].u64;
	// 825CABB0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825CABB4: 409A0008  bne cr6, 0x825cabbc
	if !ctx.cr[6].eq {
	pc = 0x825CABBC; continue 'dispatch;
	}
	// 825CABB8: 7CAB2A14  add r5, r11, r5
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 825CABBC: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 825CABC0: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 825CABC4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825CABC8: 409AFDC0  bne cr6, 0x825ca988
	if !ctx.cr[6].eq {
	pc = 0x825CA988; continue 'dispatch;
	}
	// 825CABCC: 3D800055  lis r12, 0x55
	ctx.r[12].s64 = 5570560;
	// 825CABD0: 618C5555  ori r12, r12, 0x5555
	ctx.r[12].u64 = ctx.r[12].u64 | 21845;
	// 825CABD4: 7CCB6038  and r11, r6, r12
	ctx.r[11].u64 = ctx.r[6].u64 & ctx.r[12].u64;
	// 825CABD8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CABDC: 4199001C  bgt cr6, 0x825cabf8
	if ctx.cr[6].gt {
	pc = 0x825CABF8; continue 'dispatch;
	}
	// 825CABE0: 3D800055  lis r12, 0x55
	ctx.r[12].s64 = 5570560;
	// 825CABE4: 618C5555  ori r12, r12, 0x5555
	ctx.r[12].u64 = ctx.r[12].u64 | 21845;
	// 825CABE8: 7CAB6038  and r11, r5, r12
	ctx.r[11].u64 = ctx.r[5].u64 & ctx.r[12].u64;
	// 825CABEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CABF0: 41990008  bgt cr6, 0x825cabf8
	if ctx.cr[6].gt {
	pc = 0x825CABF8; continue 'dispatch;
	}
	// 825CABF4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825CABF8: 7CEB0774  extsb r11, r7
	ctx.r[11].s64 = ctx.r[7].s8 as i64;
	// 825CABFC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825CAC00: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825CAC04: 99640022  stb r11, 0x22(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(34 as u32), ctx.r[11].u8 ) };
	// 825CAC08: 4BF6A500  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CAC10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CAC10 size=20
    let mut pc: u32 = 0x825CAC10;
    'dispatch: loop {
        match pc {
            0x825CAC10 => {
    //   block [0x825CAC10..0x825CAC24)
	// 825CAC10: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825CAC14: 546AFE76  rlwinm r10, r3, 0x1f, 0x19, 0x1b
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x00000001u64;
	// 825CAC18: 396BA4B0  addi r11, r11, -0x5b50
	ctx.r[11].s64 = ctx.r[11].s64 + -23376;
	// 825CAC1C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825CAC20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CAC28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825CAC28 size=312
    let mut pc: u32 = 0x825CAC28;
    'dispatch: loop {
        match pc {
            0x825CAC28 => {
    //   block [0x825CAC28..0x825CAD60)
	// 825CAC28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CAC2C: 4BF6A485  bl 0x825350b0
	ctx.lr = 0x825CAC30;
	sub_82535080(ctx, base);
	// 825CAC30: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825CAC34: EB640000  ld r27, 0(r4)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 825CAC38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825CAC3C: E8840008  ld r4, 8(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	// 825CAC40: 54A8103A  slwi r8, r5, 2
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825CAC44: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 825CAC48: 3BE1FFA0  addi r31, r1, -0x60
	ctx.r[31].s64 = ctx.r[1].s64 + -96;
	// 825CAC4C: 3941FFB0  addi r10, r1, -0x50
	ctx.r[10].s64 = ctx.r[1].s64 + -80;
	// 825CAC50: C1A91848  lfs f13, 0x1848(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825CAC54: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825CAC58: C00B1850  lfs f0, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CAC5C: 3961FFA0  addi r11, r1, -0x60
	ctx.r[11].s64 = ctx.r[1].s64 + -96;
	// 825CAC60: 54DE103A  slwi r30, r6, 2
	ctx.r[30].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 825CAC64: D001FF70  stfs f0, -0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), tmp.u32 ) };
	// 825CAC68: 3BA1FFB0  addi r29, r1, -0x50
	ctx.r[29].s64 = ctx.r[1].s64 + -80;
	// 825CAC6C: D001FF74  stfs f0, -0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-140 as u32), tmp.u32 ) };
	// 825CAC70: FB6A0000  std r27, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 825CAC74: D001FF78  stfs f0, -0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), tmp.u32 ) };
	// 825CAC78: C189294C  lfs f12, 0x294c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10572 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825CAC7C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 825CAC80: F88A0008  std r4, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[4].u64 ) };
	// 825CAC84: D001FF7C  stfs f0, -0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-132 as u32), tmp.u32 ) };
	// 825CAC88: D001FF60  stfs f0, -0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), tmp.u32 ) };
	// 825CAC8C: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 825CAC90: 7C1EED2E  stfsx f0, r30, r29
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32), tmp.u32) };
	// 825CAC94: D001FF64  stfs f0, -0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-156 as u32), tmp.u32 ) };
	// 825CAC98: C1692068  lfs f11, 0x2068(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8296 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825CAC9C: E9230000  ld r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 825CACA0: E8630008  ld r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 825CACA4: D001FF68  stfs f0, -0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), tmp.u32 ) };
	// 825CACA8: D001FF6C  stfs f0, -0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-148 as u32), tmp.u32 ) };
	// 825CACAC: 3B41FF60  addi r26, r1, -0xa0
	ctx.r[26].s64 = ctx.r[1].s64 + -160;
	// 825CACB0: D1A1FF80  stfs f13, -0x80(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), tmp.u32 ) };
	// 825CACB4: D181FF84  stfs f12, -0x7c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-124 as u32), tmp.u32 ) };
	// 825CACB8: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 825CACBC: D161FF88  stfs f11, -0x78(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), tmp.u32 ) };
	// 825CACC0: F86B0008  std r3, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u64 ) };
	// 825CACC4: 7C08FD2E  stfsx f0, r8, r31
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 825CACC8: 3961FFA0  addi r11, r1, -0x60
	ctx.r[11].s64 = ctx.r[1].s64 + -96;
	// 825CACCC: D001FF8C  stfs f0, -0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-116 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CAD60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825CAD60 size=144
    let mut pc: u32 = 0x825CAD60;
    'dispatch: loop {
        match pc {
            0x825CAD60 => {
    //   block [0x825CAD60..0x825CADF0)
	// 825CAD60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825CAD64: D021001C  stfs f1, 0x1c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 825CAD68: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CADF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825CADF0 size=28
    let mut pc: u32 = 0x825CADF0;
    'dispatch: loop {
        match pc {
            0x825CADF0 => {
    //   block [0x825CADF0..0x825CAE0C)
	// 825CADF0: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CADF4: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825CADF8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825CADFC: 40990010  ble cr6, 0x825cae0c
	if !ctx.cr[6].gt {
		sub_825CAE0C(ctx, base);
		return;
	}
	// 825CAE00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CAE04: 39400080  li r10, 0x80
	ctx.r[10].s64 = 128;
	// 825CAE08: 4800000C  b 0x825cae14
	sub_825CAE0C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CAE0C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825CAE0C size=48
    let mut pc: u32 = 0x825CAE0C;
    'dispatch: loop {
        match pc {
            0x825CAE0C => {
    //   block [0x825CAE0C..0x825CAE3C)
	// 825CAE0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825CAE10: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 825CAE14: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825CAE18: C0030008  lfs f0, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CAE1C: 7DA91C2E  lfsx f13, r9, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825CAE20: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825CAE24: 4099000C  ble cr6, 0x825cae30
	if !ctx.cr[6].gt {
	pc = 0x825CAE30; continue 'dispatch;
	}
	// 825CAE28: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 825CAE2C: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 825CAE30: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 825CAE34: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CAE38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CAE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CAE40 size=1708
    let mut pc: u32 = 0x825CAE40;
    'dispatch: loop {
        match pc {
            0x825CAE40 => {
    //   block [0x825CAE40..0x825CB4EC)
	// 825CAE40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CAE44: 4BF6A26D  bl 0x825350b0
	ctx.lr = 0x825CAE48;
	sub_82535080(ctx, base);
	// 825CAE48: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 825CAE4C: 4BF6B179  bl 0x82535fc4
	ctx.lr = 0x825CAE50;
	sub_82535FB0(ctx, base);
	// 825CAE50: 3980FF30  li r12, -0xd0
	ctx.r[12].s64 = -208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CB4F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CB4F0 size=704
    let mut pc: u32 = 0x825CB4F0;
    'dispatch: loop {
        match pc {
            0x825CB4F0 => {
    //   block [0x825CB4F0..0x825CB7B0)
	// 825CB4F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CB4F4: 4BF69BB5  bl 0x825350a8
	ctx.lr = 0x825CB4F8;
	sub_82535080(ctx, base);
	// 825CB4F8: 8145003C  lwz r10, 0x3c(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(60 as u32) ) } as u64;
	// 825CB4FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825CB500: 38E00070  li r7, 0x70
	ctx.r[7].s64 = 112;
	// 825CB504: 81050038  lwz r8, 0x38(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(56 as u32) ) } as u64;
	// 825CB508: 5558FE76  rlwinm r24, r10, 0x1f, 0x19, 0x1b
	ctx.r[24].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 825CB50C: 392BA4B0  addi r9, r11, -0x5b50
	ctx.r[9].s64 = ctx.r[11].s64 + -23376;
	// 825CB510: 39640020  addi r11, r4, 0x20
	ctx.r[11].s64 = ctx.r[4].s64 + 32;
	// 825CB514: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CB7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CB7B0 size=1040
    let mut pc: u32 = 0x825CB7B0;
    'dispatch: loop {
        match pc {
            0x825CB7B0 => {
    //   block [0x825CB7B0..0x825CBBC0)
	// 825CB7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CB7B4: 4BF698E9  bl 0x8253509c
	ctx.lr = 0x825CB7B8;
	sub_82535080(ctx, base);
	// 825CB7B8: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 825CB7BC: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CBBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CBBC0 size=556
    let mut pc: u32 = 0x825CBBC0;
    'dispatch: loop {
        match pc {
            0x825CBBC0 => {
    //   block [0x825CBBC0..0x825CBDEC)
	// 825CBBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CBBC4: 4BF694D5  bl 0x82535098
	ctx.lr = 0x825CBBC8;
	sub_82535080(ctx, base);
	// 825CBBC8: DBE1FF90  stfd f31, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 825CBBCC: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CBBD0: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 825CBBD4: EAAA0000  ld r21, 0(r10)
	ctx.r[21].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 825CBBD8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825CBBDC: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 825CBBE0: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 825CBBE4: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 825CBBE8: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 825CBBEC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825CBBF0: 3B4100A0  addi r26, r1, 0xa0
	ctx.r[26].s64 = ctx.r[1].s64 + 160;
	// 825CBBF4: 557B103A  slwi r27, r11, 2
	ctx.r[27].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 825CBBF8: C0081850  lfs f0, 0x1850(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CBBFC: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 825CBC00: B2C10052  sth r22, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[22].u16 ) };
	// 825CBC04: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 825CBC08: EAC90000  ld r22, 0(r9)
	ctx.r[22].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 825CBC0C: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 825CBC10: E9290008  ld r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 825CBC14: 54D9103A  slwi r25, r6, 2
	ctx.r[25].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 825CBC18: 3B0100B0  addi r24, r1, 0xb0
	ctx.r[24].s64 = ctx.r[1].s64 + 176;
	// 825CBC1C: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825CBC20: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CBC24: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825CBC28: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825CBC2C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825CBC30: FAC80000  std r22, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[22].u64 ) };
	// 825CBC34: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825CBC38: F9280008  std r9, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 825CBC3C: 7C1BD52E  stfsx f0, r27, r26
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32), tmp.u32) };
	// 825CBC40: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 825CBC44: FAA70000  std r21, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[21].u64 ) };
	// 825CBC48: F9470008  std r10, 8(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 825CBC4C: 7C19C52E  stfsx f0, r25, r24
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32), tmp.u32) };
	// 825CBC50: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 825CBC54: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825CBC58: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 825CBC5C: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825CBC60: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 825CBC64: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CBDF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CBDF0 size=2848
    let mut pc: u32 = 0x825CBDF0;
    'dispatch: loop {
        match pc {
            0x825CBDF0 => {
    //   block [0x825CBDF0..0x825CC910)
	// 825CBDF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CBDF4: 4BF6928D  bl 0x82535080
	ctx.lr = 0x825CBDF8;
	sub_82535080(ctx, base);
	// 825CBDF8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825CBDFC: 4BF6A1ED  bl 0x82535fe8
	ctx.lr = 0x825CBE00;
	sub_82535FB0(ctx, base);
	// 825CBE00: 9421FD50  stwu r1, -0x2b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-688 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CBE04: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825CBE08: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825CBE0C: 3B0B9F50  addi r24, r11, -0x60b0
	ctx.r[24].s64 = ctx.r[11].s64 + -24752;
	// 825CBE10: 3D60829A  lis r11, -0x7d66
	ctx.r[11].s64 = -2103836672;
	// 825CBE14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CBE18: 3AAB3D80  addi r21, r11, 0x3d80
	ctx.r[21].s64 = ctx.r[11].s64 + 15744;
	// 825CBE1C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825CBE20: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825CBE24: 3A8B0E30  addi r20, r11, 0xe30
	ctx.r[20].s64 = ctx.r[11].s64 + 3632;
	// 825CBE28: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825CBE2C: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 825CBE30: 3AEBFA60  addi r23, r11, -0x5a0
	ctx.r[23].s64 = ctx.r[11].s64 + -1440;
	// 825CBE34: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825CBE38: 3A200008  li r17, 8
	ctx.r[17].s64 = 8;
	// 825CBE3C: 3A6BFA60  addi r19, r11, -0x5a0
	ctx.r[19].s64 = ctx.r[11].s64 + -1440;
	// 825CBE40: 39610140  addi r11, r1, 0x140
	ctx.r[11].s64 = ctx.r[1].s64 + 320;
	// 825CBE44: 3FA08206  lis r29, -0x7dfa
	ctx.r[29].s64 = -2113536000;
	// 825CBE48: 3FC0820D  lis r30, -0x7df3
	ctx.r[30].s64 = -2113077248;
	// 825CBE4C: 3C608200  lis r3, -0x7e00
	ctx.r[3].s64 = -2113929216;
	// 825CBE50: 92210058  stw r17, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[17].u32 ) };
	// 825CBE54: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 825CBE58: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CC910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CC910 size=628
    let mut pc: u32 = 0x825CC910;
    'dispatch: loop {
        match pc {
            0x825CC910 => {
    //   block [0x825CC910..0x825CCB84)
	// 825CC910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CC914: 4BF6879D  bl 0x825350b0
	ctx.lr = 0x825CC918;
	sub_82535080(ctx, base);
	// 825CC918: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CC91C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825CC920: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825CC924: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825CC928: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CC92C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825CC930: 9B9B0000  stb r28, 0(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[28].u8 ) };
	// 825CC934: 4BF5F99D  bl 0x8252c2d0
	ctx.lr = 0x825CC938;
	sub_8252C2D0(ctx, base);
	// 825CC938: 39200050  li r9, 0x50
	ctx.r[9].s64 = 80;
	// 825CC93C: B3810052  sth r28, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[28].u16 ) };
	// 825CC940: 395F00C0  addi r10, r31, 0xc0
	ctx.r[10].s64 = ctx.r[31].s64 + 192;
	// 825CC944: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 825CC948: 3BC00010  li r30, 0x10
	ctx.r[30].s64 = 16;
	// 825CC94C: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CCB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CCB88 size=6648
    let mut pc: u32 = 0x825CCB88;
    'dispatch: loop {
        match pc {
            0x825CCB88 => {
    //   block [0x825CCB88..0x825CE580)
	// 825CCB88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CCB8C: 4BF684F5  bl 0x82535080
	ctx.lr = 0x825CCB90;
	sub_82535080(ctx, base);
	// 825CCB90: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825CCB94: 4BF6944D  bl 0x82535fe0
	ctx.lr = 0x825CCB98;
	sub_82535FB0(ctx, base);
	// 825CCB98: 3981FF30  addi r12, r1, -0xd0
	ctx.r[12].s64 = ctx.r[1].s64 + -208;
	// 825CCB9C: 4BF6C801  bl 0x8253939c
	ctx.lr = 0x825CCBA0;
	sub_82539130(ctx, base);
	// 825CCBA0: 9421FD10  stwu r1, -0x2f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-752 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CCBA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CCBA8: 39400050  li r10, 0x50
	ctx.r[10].s64 = 80;
	// 825CCBAC: 397F00C0  addi r11, r31, 0xc0
	ctx.r[11].s64 = ctx.r[31].s64 + 192;
	// 825CCBB0: 3A7F0020  addi r19, r31, 0x20
	ctx.r[19].s64 = ctx.r[31].s64 + 32;
	// 825CCBB4: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 825CCBB8: 3AA00020  li r21, 0x20
	ctx.r[21].s64 = 32;
	// 825CCBBC: 811F0010  lwz r8, 0x10(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CE580 size=220
    let mut pc: u32 = 0x825CE580;
    'dispatch: loop {
        match pc {
            0x825CE580 => {
    //   block [0x825CE580..0x825CE65C)
	// 825CE580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CE584: 4BF66B39  bl 0x825350bc
	ctx.lr = 0x825CE588;
	sub_82535080(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CE660 size=284
    let mut pc: u32 = 0x825CE660;
    'dispatch: loop {
        match pc {
            0x825CE660 => {
    //   block [0x825CE660..0x825CE77C)
	// 825CE660: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 825CE664: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 825CE668: 39630040  addi r11, r3, 0x40
	ctx.r[11].s64 = ctx.r[3].s64 + 64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CE780 size=212
    let mut pc: u32 = 0x825CE780;
    'dispatch: loop {
        match pc {
            0x825CE780 => {
    //   block [0x825CE780..0x825CE854)
	// 825CE780: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE854(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CE854 size=136
    let mut pc: u32 = 0x825CE854;
    'dispatch: loop {
        match pc {
            0x825CE854 => {
    //   block [0x825CE854..0x825CE8DC)
	// 825CE854: EDA06AFA  fmadds f13, f0, f11, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 825CE858: 39640040  addi r11, r4, 0x40
	ctx.r[11].s64 = ctx.r[4].s64 + 64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE8DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CE8DC size=8
    let mut pc: u32 = 0x825CE8DC;
    'dispatch: loop {
        match pc {
            0x825CE8DC => {
    //   block [0x825CE8DC..0x825CE8E4)
	// 825CE8DC: EC206AFC  fnmsubs f1, f0, f11, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = -(((ctx.f[0].f64 * ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 825CE8E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CE8E8 size=356
    let mut pc: u32 = 0x825CE8E8;
    'dispatch: loop {
        match pc {
            0x825CE8E8 => {
    //   block [0x825CE8E8..0x825CEA4C)
	// 825CE8E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CE8EC: 4BF667C5  bl 0x825350b0
	ctx.lr = 0x825CE8F0;
	sub_82535080(ctx, base);
	// 825CE8F0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 825CE8F4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CE8F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CE8FC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825CE900: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 825CE904: 83BE0040  lwz r29, 0x40(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 825CE908: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE90C: 386B0040  addi r3, r11, 0x40
	ctx.r[3].s64 = ctx.r[11].s64 + 64;
	// 825CE910: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CE914: EFE00072  fmuls f31, f0, f1
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 825CE918: C03D0000  lfs f1, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825CE91C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825CE920: 4BFDAC49  bl 0x825a9568
	ctx.lr = 0x825CE924;
	sub_825A9568(ctx, base);
	// 825CE924: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CE928: 3B9F0040  addi r28, r31, 0x40
	ctx.r[28].s64 = ctx.r[31].s64 + 64;
	// 825CE92C: C03D0000  lfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825CE930: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825CE934: 386B0040  addi r3, r11, 0x40
	ctx.r[3].s64 = ctx.r[11].s64 + 64;
	// 825CE938: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825CE93C: 4BFDAC2D  bl 0x825a9568
	ctx.lr = 0x825CE940;
	sub_825A9568(ctx, base);
	// 825CE940: 3BBF0080  addi r29, r31, 0x80
	ctx.r[29].s64 = ctx.r[31].s64 + 128;
	// 825CE944: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825CE948: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CE94C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CE950: 4BFDA809  bl 0x825a9158
	ctx.lr = 0x825CE954;
	sub_825A9158(ctx, base);
	// 825CE954: 38BE0020  addi r5, r30, 0x20
	ctx.r[5].s64 = ctx.r[30].s64 + 32;
	// 825CE958: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825CE95C: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 825CE960: 4BFDD241  bl 0x825abba0
	ctx.lr = 0x825CE964;
	sub_825ABBA0(ctx, base);
	// 825CE964: 38BE0030  addi r5, r30, 0x30
	ctx.r[5].s64 = ctx.r[30].s64 + 48;
	// 825CE968: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825CE96C: 387F00D0  addi r3, r31, 0xd0
	ctx.r[3].s64 = ctx.r[31].s64 + 208;
	// 825CE970: 4BFDD199  bl 0x825abb08
	ctx.lr = 0x825CE974;
	sub_825ABB08(ctx, base);
	// 825CE974: C01E0014  lfs f0, 0x14(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CE978: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 825CE97C: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 825CE980: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE984: 38E00080  li r7, 0x80
	ctx.r[7].s64 = 128;
	// 825CE988: 3B9F0010  addi r28, r31, 0x10
	ctx.r[28].s64 = ctx.r[31].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CEA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CEA50 size=368
    let mut pc: u32 = 0x825CEA50;
    'dispatch: loop {
        match pc {
            0x825CEA50 => {
    //   block [0x825CEA50..0x825CEBC0)
	// 825CEA50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CEA54: 4BF66665  bl 0x825350b8
	ctx.lr = 0x825CEA58;
	sub_82535080(ctx, base);
	// 825CEA58: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 825CEA5C: 4BF67579  bl 0x82535fd4
	ctx.lr = 0x825CEA60;
	sub_82535FB0(ctx, base);
	// 825CEA60: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CEA64: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825CEA68: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 825CEA6C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CEA70: FF801090  fmr f28, f2
	ctx.f[28].f64 = ctx.f[2].f64;
	// 825CEA74: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825CEA78: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 825CEA7C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825CEA80: FF402090  fmr f26, f4
	ctx.f[26].f64 = ctx.f[4].f64;
	// 825CEA84: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825CEA88: C00B2038  lfs f0, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CEA8C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CEA90: C19F0010  lfs f12, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825CEA94: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825CEA98: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825CEA9C: EF6C0032  fmuls f27, f12, f0
	ctx.f[27].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 825CEAA0: C2EA8E24  lfs f23, -0x71dc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-29148 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 825CEAA4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825CEAA8: C3291850  lfs f25, 0x1850(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6224 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 825CEAAC: C30B8E30  lfs f24, -0x71d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29136 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 825CEAB0: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 825CEAB4: FF1D6800  fcmpu cr6, f29, f13
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[13].f64);
	// 825CEAB8: 409900D4  ble cr6, 0x825ceb8c
	if !ctx.cr[6].gt {
	pc = 0x825CEB8C; continue 'dispatch;
	}
	// 825CEABC: EC1AE828  fsubs f0, f26, f29
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[29].f64) as f32) as f64);
	// 825CEAC0: FD80D850  fneg f12, f27
	ctx.f[12].u64 = ctx.f[27].u64 ^ 0x8000_0000_0000_0000u64;
	// 825CEAC4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 825CEAC8: 419900C4  bgt cr6, 0x825ceb8c
	if ctx.cr[6].gt {
	pc = 0x825CEB8C; continue 'dispatch;
	}
	// 825CEACC: EDADE828  fsubs f13, f13, f29
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[29].f64) as f32) as f64);
	// 825CEAD0: 57AB07FE  clrlwi r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 825CEAD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CEAD8: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 825CEADC: 409A0014  bne cr6, 0x825ceaf0
	if !ctx.cr[6].eq {
	pc = 0x825CEAF0; continue 'dispatch;
	}
	// 825CEAE0: EDA0C028  fsubs f13, f0, f24
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[24].f64) as f32) as f64);
	// 825CEAE4: FC0DC02E  fsel f0, f13, f0, f24
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[24].f64 };
	// 825CEAE8: EDA0B828  fsubs f13, f0, f23
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[23].f64) as f32) as f64);
	// 825CEAEC: FC0D05EE  fsel f0, f13, f23, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[23].f64 } else { ctx.f[0].f64 };
	// 825CEAF0: EDB90028  fsubs f13, f25, f0
	ctx.f[13].f64 = (((ctx.f[25].f64 - ctx.f[0].f64) as f32) as f64);
	// 825CEAF4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825CEAF8: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 825CEAFC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825CEB00: EFED07BA  fmadds f31, f13, f30, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 825CEB04: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825CEB08: 4BFFFDE1  bl 0x825ce8e8
	ctx.lr = 0x825CEB0C;
	sub_825CE8E8(ctx, base);
	// 825CEB0C: 39610130  addi r11, r1, 0x130
	ctx.r[11].s64 = ctx.r[1].s64 + 304;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CEBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CEBC0 size=712
    let mut pc: u32 = 0x825CEBC0;
    'dispatch: loop {
        match pc {
            0x825CEBC0 => {
    //   block [0x825CEBC0..0x825CEE88)
	// 825CEBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CEBC4: 4BF664D9  bl 0x8253509c
	ctx.lr = 0x825CEBC8;
	sub_82535080(ctx, base);
	// 825CEBC8: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 825CEBCC: 4BF67409  bl 0x82535fd4
	ctx.lr = 0x825CEBD0;
	sub_82535FB0(ctx, base);
	// 825CEBD0: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CEBD4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825CEBD8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825CEBDC: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825CEBE0: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 825CEBE4: 3ABD0080  addi r21, r29, 0x80
	ctx.r[21].s64 = ctx.r[29].s64 + 128;
	// 825CEBE8: 839D000C  lwz r28, 0xc(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 825CEBEC: C3DD0080  lfs f30, 0x80(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825CEBF0: C36B1850  lfs f27, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 825CEBF4: FF40F090  fmr f26, f30
	ctx.f[26].f64 = ctx.f[30].f64;
	// 825CEBF8: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 825CEBFC: 419A027C  beq cr6, 0x825cee78
	if ctx.cr[6].eq {
	pc = 0x825CEE78; continue 'dispatch;
	}
	// 825CEC00: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 825CEC04: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825CEC08: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825CEC0C: 3B1D0008  addi r24, r29, 8
	ctx.r[24].s64 = ctx.r[29].s64 + 8;
	// 825CEC10: 3AFD0044  addi r23, r29, 0x44
	ctx.r[23].s64 = ctx.r[29].s64 + 68;
	// 825CEC14: C3291FF8  lfs f25, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 825CEC18: 3AC00010  li r22, 0x10
	ctx.r[22].s64 = 16;
	// 825CEC1C: C3AA2068  lfs f29, 0x2068(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8296 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825CEC20: C2EBBFFC  lfs f23, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 825CEC24: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 825CEC28: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825CEC2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CEC30: 4BFFFCB9  bl 0x825ce8e8
	ctx.lr = 0x825CEC34;
	sub_825CE8E8(ctx, base);
	// 825CEC34: EFFBF028  fsubs f31, f27, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[27].f64 - ctx.f[30].f64) as f32) as f64);
	// 825CEC38: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 825CEC3C: 83F80000  lwz r31, 0(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CEC40: C0170000  lfs f0, 0(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CEC44: FF80D890  fmr f28, f27
	ctx.f[28].f64 = ctx.f[27].f64;
	// 825CEC48: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 825CEC4C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825CEC50: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 825CEC54: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825CEC58: EF0007F2  fmuls f24, f0, f31
	ctx.f[24].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 825CEC5C: 419801F4  blt cr6, 0x825cee50
	if ctx.cr[6].lt {
	pc = 0x825CEE50; continue 'dispatch;
	}
	// 825CEC60: 39410140  addi r10, r1, 0x140
	ctx.r[10].s64 = ctx.r[1].s64 + 320;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CEE88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CEE88 size=304
    let mut pc: u32 = 0x825CEE88;
    'dispatch: loop {
        match pc {
            0x825CEE88 => {
    //   block [0x825CEE88..0x825CEFB8)
	// 825CEE88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CEE8C: 4BF66225  bl 0x825350b0
	ctx.lr = 0x825CEE90;
	sub_82535080(ctx, base);
	// 825CEE90: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CEE94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CEE98: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825CEE9C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 825CEEA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CEEA4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825CEEA8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825CEEAC: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 825CEEB0: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 825CEEB4: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 825CEEB8: 4BFDA2A1  bl 0x825a9158
	ctx.lr = 0x825CEEBC;
	sub_825A9158(ctx, base);
	// 825CEEBC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825CEEC0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825CEEC4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825CEEC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825CEECC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CEED0: 4BFF8A61  bl 0x825c7930
	ctx.lr = 0x825CEED4;
	sub_825C7930(ctx, base);
	// 825CEED4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CEFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CEFB8 size=292
    let mut pc: u32 = 0x825CEFB8;
    'dispatch: loop {
        match pc {
            0x825CEFB8 => {
    //   block [0x825CEFB8..0x825CF0DC)
	// 825CEFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CEFBC: 4BF660FD  bl 0x825350b8
	ctx.lr = 0x825CEFC0;
	sub_82535080(ctx, base);
	// 825CEFC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CEFC4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825CEFC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CEFCC: 39000060  li r8, 0x60
	ctx.r[8].s64 = 96;
	// 825CEFD0: 38E00050  li r7, 0x50
	ctx.r[7].s64 = 80;
	// 825CEFD4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CEFD8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CEFDC: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CEFE0: 83AA0008  lwz r29, 8(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CEFE4: 83890008  lwz r28, 8(r9)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CEFE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CEFEC: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CEFF0: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825CEFF4: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 825CEFF8: C1BE0010  lfs f13, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825CEFFC: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CF000: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825CF004: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CF0E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CF0E0 size=2692
    let mut pc: u32 = 0x825CF0E0;
    'dispatch: loop {
        match pc {
            0x825CF0E0 => {
    //   block [0x825CF0E0..0x825CFB64)
	// 825CF0E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CF0E4: 4BF65FA5  bl 0x82535088
	ctx.lr = 0x825CF0E8;
	sub_82535080(ctx, base);
	// 825CF0E8: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 825CF0EC: 4BF66EDD  bl 0x82535fc8
	ctx.lr = 0x825CF0F0;
	sub_82535FB0(ctx, base);
	// 825CF0F0: 9421FC40  stwu r1, -0x3c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-960 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CF0F4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825CF0F8: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 825CF0FC: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 825CF100: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 825CF104: FF601890  fmr f27, f3
	ctx.f[27].f64 = ctx.f[3].f64;
	// 825CF108: 7D124378  mr r18, r8
	ctx.r[18].u64 = ctx.r[8].u64;
	// 825CF10C: FF002090  fmr f24, f4
	ctx.f[24].f64 = ctx.f[4].f64;
	// 825CF110: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 825CF114: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 825CF118: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CF11C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825CF120: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF124: 7C902378  mr r16, r4
	ctx.r[16].u64 = ctx.r[4].u64;
	// 825CF128: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 825CF12C: C2E71850  lfs f23, 0x1850(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(6224 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 825CF130: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825CF134: C3288E24  lfs f25, -0x71dc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-29148 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 825CF138: 3AF90004  addi r23, r25, 4
	ctx.r[23].s64 = ctx.r[25].s64 + 4;
	// 825CF13C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF140: C3498E30  lfs f26, -0x71d0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-29136 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 825CF144: EDBDE028  fsubs f13, f29, f28
	ctx.f[13].f64 = (((ctx.f[29].f64 - ctx.f[28].f64) as f32) as f64);
	// 825CF148: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF14C: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 825CF150: EC18D828  fsubs f0, f24, f27
	ctx.f[0].f64 = (((ctx.f[24].f64 - ctx.f[27].f64) as f32) as f64);
	// 825CF154: 3A790008  addi r19, r25, 8
	ctx.r[19].s64 = ctx.r[25].s64 + 8;
	// 825CF158: 3AA00020  li r21, 0x20
	ctx.r[21].s64 = 32;
	// 825CF15C: C16A0010  lfs f11, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825CF160: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825CF164: C18B0010  lfs f12, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825CF168: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825CF16C: EEAC582A  fadds f21, f12, f11
	ctx.f[21].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 825CF170: 3AC000A0  li r22, 0xa0
	ctx.r[22].s64 = 160;
	// 825CF174: 3A2B9F50  addi r17, r11, -0x60b0
	ctx.r[17].s64 = ctx.r[11].s64 + -24752;
	// 825CF178: 3B400130  li r26, 0x130
	ctx.r[26].s64 = 304;
	// 825CF17C: C2CABFFC  lfs f22, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 825CF180: 3B80FFC0  li r28, -0x40
	ctx.r[28].s64 = -64;
	// 825CF184: EE806824  fdivs f20, f0, f13
	ctx.f[20].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 825CF188: C1900010  lfs f12, 0x10(r16)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825CF18C: EC18D828  fsubs f0, f24, f27
	ctx.f[0].f64 = (((ctx.f[24].f64 - ctx.f[27].f64) as f32) as f64);
	// 825CF190: FDA06050  fneg f13, f12
	ctx.f[13].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 825CF194: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825CF198: 4099000C  ble cr6, 0x825cf1a4
	if !ctx.cr[6].gt {
	pc = 0x825CF1A4; continue 'dispatch;
	}
	// 825CF19C: FFA0E090  fmr f29, f28
	ctx.f[29].f64 = ctx.f[28].f64;
	// 825CF1A0: FC00B090  fmr f0, f22
	ctx.f[0].f64 = ctx.f[22].f64;
	// 825CF1A4: C1B00000  lfs f13, 0(r16)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825CF1A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825CF1AC: ED786828  fsubs f11, f24, f13
	ctx.f[11].f64 = (((ctx.f[24].f64 - ctx.f[13].f64) as f32) as f64);
	// 825CF1B0: FD605A10  fabs f11, f11
	ctx.f[11].u64 = ctx.f[11].u64 & !0x8000_0000_0000_0000u64;
	// 825CF1B4: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 825CF1B8: 41980008  blt cr6, 0x825cf1c0
	if ctx.cr[6].lt {
	pc = 0x825CF1C0; continue 'dispatch;
	}
	// 825CF1BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CF1C0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825CF1C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CF1C8: 419A0014  beq cr6, 0x825cf1dc
	if ctx.cr[6].eq {
	pc = 0x825CF1DC; continue 'dispatch;
	}
	// 825CF1CC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825CF1D0: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	// 825CF1D4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825CF1D8: 4800002C  b 0x825cf204
	pc = 0x825CF204; continue 'dispatch;
	// 825CF1DC: EDADD828  fsubs f13, f13, f27
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[27].f64) as f32) as f64);
	// 825CF1E0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825CF1E4: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 825CF1E8: EDA0D028  fsubs f13, f0, f26
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	// 825CF1EC: FC0DD02E  fsel f0, f13, f0, f26
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[26].f64 };
	// 825CF1F0: EDA0C828  fsubs f13, f0, f25
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[25].f64) as f32) as f64);
	// 825CF1F4: FC0D066E  fsel f0, f13, f25, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[25].f64 } else { ctx.f[0].f64 };
	// 825CF1F8: EDB70028  fsubs f13, f23, f0
	ctx.f[13].f64 = (((ctx.f[23].f64 - ctx.f[0].f64) as f32) as f64);
	// 825CF1FC: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 825CF200: EFED073A  fmadds f31, f13, f28, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[28].f64 + ctx.f[0].f64) as f32) as f64);
	// 825CF204: 83F30000  lwz r31, 0(r19)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF208: 38C10170  addi r6, r1, 0x170
	ctx.r[6].s64 = ctx.r[1].s64 + 368;
	// 825CF20C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF210: C01F0058  lfs f0, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CF214: EFC007F2  fmuls f30, f0, f31
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 825CF218: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CF21C: C03F0050  lfs f1, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825CF220: 386B0040  addi r3, r11, 0x40
	ctx.r[3].s64 = ctx.r[11].s64 + 64;
	// 825CF224: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 825CF228: 4BFDA341  bl 0x825a9568
	ctx.lr = 0x825CF22C;
	sub_825A9568(ctx, base);
	// 825CF22C: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF230: 38C10290  addi r6, r1, 0x290
	ctx.r[6].s64 = ctx.r[1].s64 + 656;
	// 825CF234: C03F0050  lfs f1, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825CF238: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 825CF23C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CF240: 386B0040  addi r3, r11, 0x40
	ctx.r[3].s64 = ctx.r[11].s64 + 64;
	// 825CF244: 4BFDA325  bl 0x825a9568
	ctx.lr = 0x825CF248;
	sub_825A9568(ctx, base);
	// 825CF248: 38A10290  addi r5, r1, 0x290
	ctx.r[5].s64 = ctx.r[1].s64 + 656;
	// 825CF24C: 38810170  addi r4, r1, 0x170
	ctx.r[4].s64 = ctx.r[1].s64 + 368;
	// 825CF250: 38610250  addi r3, r1, 0x250
	ctx.r[3].s64 = ctx.r[1].s64 + 592;
	// 825CF254: 4BFD9F05  bl 0x825a9158
	ctx.lr = 0x825CF258;
	sub_825A9158(ctx, base);
	// 825CF258: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825CF25C: 419A007C  beq cr6, 0x825cf2d8
	if ctx.cr[6].eq {
	pc = 0x825CF2D8; continue 'dispatch;
	}
	// 825CF260: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF264: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 825CF268: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF26C: 38C10250  addi r6, r1, 0x250
	ctx.r[6].s64 = ctx.r[1].s64 + 592;
	// 825CF270: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825CF274: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF278: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF27C: 4BFF86B5  bl 0x825c7930
	ctx.lr = 0x825CF280;
	sub_825C7930(ctx, base);
	// 825CF280: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF284: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825CF288: 409A0014  bne cr6, 0x825cf29c
	if !ctx.cr[6].eq {
	pc = 0x825CF29C; continue 'dispatch;
	}
	// 825CF28C: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CFB68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CFB68 size=4192
    let mut pc: u32 = 0x825CFB68;
    'dispatch: loop {
        match pc {
            0x825CFB68 => {
    //   block [0x825CFB68..0x825D0BC8)
	// 825CFB68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CFB6C: 4BF65515  bl 0x82535080
	ctx.lr = 0x825CFB70;
	sub_82535080(ctx, base);
	// 825CFB70: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825CFB74: 4BF6643D  bl 0x82535fb0
	ctx.lr = 0x825CFB78;
	sub_82535FB0(ctx, base);
	// 825CFB78: 3980FEC0  li r12, -0x140
	ctx.r[12].s64 = -320;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D0BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D0BC8 size=1448
    let mut pc: u32 = 0x825D0BC8;
    'dispatch: loop {
        match pc {
            0x825D0BC8 => {
    //   block [0x825D0BC8..0x825D1170)
	// 825D0BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D0BCC: 4BF644B5  bl 0x82535080
	ctx.lr = 0x825D0BD0;
	sub_82535080(ctx, base);
	// 825D0BD0: 9421FD60  stwu r1, -0x2a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-672 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D0BD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D0BD8: 7CB32B78  mr r19, r5
	ctx.r[19].u64 = ctx.r[5].u64;
	// 825D0BDC: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 825D0BE0: 7D374B78  mr r23, r9
	ctx.r[23].u64 = ctx.r[9].u64;
	// 825D0BE4: 7D144378  mr r20, r8
	ctx.r[20].u64 = ctx.r[8].u64;
	// 825D0BE8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D0BEC: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825D0BF0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D0BF4: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 825D0BF8: 8933000B  lbz r9, 0xb(r19)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[19].u32.wrapping_add(11 as u32) ) } as u64;
	// 825D0BFC: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 825D0C00: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D0C04: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 825D0C08: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825D0C0C: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D0C10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D0C14: 936102BC  stw r27, 0x2bc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(700 as u32), ctx.r[27].u32 ) };
	// 825D0C18: 90E10068  stw r7, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[7].u32 ) };
	// 825D0C1C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D0C20: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 825D0C24: 395E0010  addi r10, r30, 0x10
	ctx.r[10].s64 = ctx.r[30].s64 + 16;
	// 825D0C28: 712900EF  andi. r9, r9, 0xef
	ctx.r[9].u64 = ctx.r[9].u64 & 239;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D0C2C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825D0C30: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D0C34: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825D0C38: C0080004  lfs f0, 4(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D0C3C: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825D0C40: 9933000B  stb r9, 0xb(r19)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[19].u32.wrapping_add(11 as u32), ctx.r[9].u8 ) };
	// 825D0C44: 4BFF7B75  bl 0x825c87b8
	ctx.lr = 0x825D0C48;
	sub_825C87B8(ctx, base);
	// 825D0C48: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 825D0C4C: 409A0028  bne cr6, 0x825d0c74
	if !ctx.cr[6].eq {
	pc = 0x825D0C74; continue 'dispatch;
	}
	// 825D0C50: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D0C54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D0C58: 419A0510  beq cr6, 0x825d1168
	if ctx.cr[6].eq {
	pc = 0x825D1168; continue 'dispatch;
	}
	// 825D0C5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D0C60: 80B70004  lwz r5, 4(r23)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D0C64: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D0C68: 4BFF1DB1  bl 0x825c2a18
	ctx.lr = 0x825D0C6C;
	sub_825C2A18(ctx, base);
	// 825D0C6C: 382102A0  addi r1, r1, 0x2a0
	ctx.r[1].s64 = ctx.r[1].s64 + 672;
	// 825D0C70: 4BF64460  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
	// 825D0C74: E9540000  ld r10, 0(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) };
	// 825D0C78: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 825D0C7C: E9340008  ld r9, 8(r20)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) };
	// 825D0C80: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825D0C84: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 825D0C88: F92B0008  std r9, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 825D0C8C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D0C90: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825D0C94: 409A005C  bne cr6, 0x825d0cf0
	if !ctx.cr[6].eq {
	pc = 0x825D0CF0; continue 'dispatch;
	}
	// 825D0C98: 89780008  lbz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D0C9C: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 825D0CA0: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D0CA4: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 825D0CA8: 80FE0004  lwz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D0CAC: 556B083E  rotlwi r11, r11, 1
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825D0CB0: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D0CB4: 38B80009  addi r5, r24, 9
	ctx.r[5].s64 = ctx.r[24].s64 + 9;
	// 825D0CB8: 7C8BC214  add r4, r11, r24
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 825D0CBC: 81010068  lwz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825D0CC0: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D0CC4: 80E70008  lwz r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D0CC8: 817D0038  lwz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 825D0CCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D0CD0: 4E800421  bctrl
	ctx.lr = 0x825D0CD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D0CD4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825D0CD8: 419AFF84  beq cr6, 0x825d0c5c
	if ctx.cr[6].eq {
	pc = 0x825D0C5C; continue 'dispatch;
	}
	// 825D0CDC: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 825D0CE0: 409A0010  bne cr6, 0x825d0cf0
	if !ctx.cr[6].eq {
	pc = 0x825D0CF0; continue 'dispatch;
	}
	// 825D0CE4: 8973000B  lbz r11, 0xb(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[19].u32.wrapping_add(11 as u32) ) } as u64;
	// 825D0CE8: 616B0010  ori r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 16;
	// 825D0CEC: 9973000B  stb r11, 0xb(r19)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[19].u32.wrapping_add(11 as u32), ctx.r[11].u8 ) };
	// 825D0CF0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825D0CF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D0CF8: 4BFF1B39  bl 0x825c2830
	ctx.lr = 0x825D0CFC;
	sub_825C2830(ctx, base);
	// 825D0CFC: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D0D00: 5476063E  clrlwi r22, r3, 0x18
	ctx.r[22].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825D0D04: 82B70000  lwz r21, 0(r23)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D0D08: 7F0BB000  cmpw cr6, r11, r22
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[22].s32, &mut ctx.xer);
	// 825D0D0C: 40990258  ble cr6, 0x825d0f64
	if !ctx.cr[6].gt {
	pc = 0x825D0F64; continue 'dispatch;
	}
	// 825D0D10: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D0D14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D0D18: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D0D1C: 833E0004  lwz r25, 4(r30)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D0D20: C00A0004  lfs f0, 4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D0D24: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 825D0D28: D00101F8  stfs f0, 0x1f8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(504 as u32), tmp.u32 ) };
	// 825D0D2C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D0D30: 83590000  lwz r26, 0(r25)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D1170 size=112
    let mut pc: u32 = 0x825D1170;
    'dispatch: loop {
        match pc {
            0x825D1170 => {
    //   block [0x825D1170..0x825D11E0)
	// 825D1170: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1174: 54AA2036  slwi r10, r5, 4
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D1178: 54892036  slwi r9, r4, 4
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825D117C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825D1180: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825D1184: 54C82036  slwi r8, r6, 4
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825D1188: 38C1FFF0  addi r6, r1, -0x10
	ctx.r[6].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D11E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D11E0 size=24
    let mut pc: u32 = 0x825D11E0;
    'dispatch: loop {
        match pc {
            0x825D11E0 => {
    //   block [0x825D11E0..0x825D11F8)
	// 825D11E0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825D11E4: 396BFA60  addi r11, r11, -0x5a0
	ctx.r[11].s64 = ctx.r[11].s64 + -1440;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D11F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D11F8 size=184
    let mut pc: u32 = 0x825D11F8;
    'dispatch: loop {
        match pc {
            0x825D11F8 => {
    //   block [0x825D11F8..0x825D12B0)
	// 825D11F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D11FC: 54CA2036  slwi r10, r6, 4
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D1200: 54A92036  slwi r9, r5, 4
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825D1204: 54882036  slwi r8, r4, 4
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825D1208: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825D120C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825D1210: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 825D1214: 3861FFE0  addi r3, r1, -0x20
	ctx.r[3].s64 = ctx.r[1].s64 + -32;
	// 825D1218: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D12B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825D12B0 size=160
    let mut pc: u32 = 0x825D12B0;
    'dispatch: loop {
        match pc {
            0x825D12B0 => {
    //   block [0x825D12B0..0x825D1350)
	// 825D12B0: C18B000C  lfs f12, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D12B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825D12B8: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 825D12BC: D181FFF0  stfs f12, -0x10(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 825D12C0: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D12C4: 3941FFE0  addi r10, r1, -0x20
	ctx.r[10].s64 = ctx.r[1].s64 + -32;
	// 825D12C8: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825D12CC: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D12D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D12D4: D001FFFC  stfs f0, -4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 825D12D8: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D12DC: 90870010  stw r4, 0x10(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 825D12E0: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 825D12E4: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 825D12E8: FC006050  fneg f0, f12
	ctx.f[0].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 825D12EC: D001FFF8  stfs f0, -8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 825D12F0: C00B1850  lfs f0, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D12F4: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 825D12F8: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 825D12FC: D001FFE0  stfs f0, -0x20(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D1350 size=496
    let mut pc: u32 = 0x825D1350;
    'dispatch: loop {
        match pc {
            0x825D1350 => {
    //   block [0x825D1350..0x825D1540)
	// 825D1350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D1354: 4BF63D3D  bl 0x82535090
	ctx.lr = 0x825D1358;
	sub_82535080(ctx, base);
	// 825D1358: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D135C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 825D1360: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 825D1364: 7D1F4378  mr r31, r8
	ctx.r[31].u64 = ctx.r[8].u64;
	// 825D1368: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825D136C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825D1370: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 825D1374: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825D1378: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 825D137C: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 825D1380: 3B7E0010  addi r27, r30, 0x10
	ctx.r[27].s64 = ctx.r[30].s64 + 16;
	// 825D1384: 917E0018  stw r11, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 825D1388: 3B5E0014  addi r26, r30, 0x14
	ctx.r[26].s64 = ctx.r[30].s64 + 20;
	// 825D138C: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825D1390: 3B3E0018  addi r25, r30, 0x18
	ctx.r[25].s64 = ctx.r[30].s64 + 24;
	// 825D1394: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 825D1398: 3ABF0010  addi r21, r31, 0x10
	ctx.r[21].s64 = ctx.r[31].s64 + 16;
	// 825D139C: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 825D13A0: 3B1F0014  addi r24, r31, 0x14
	ctx.r[24].s64 = ctx.r[31].s64 + 20;
	// 825D13A4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D13A8: 3AFF0018  addi r23, r31, 0x18
	ctx.r[23].s64 = ctx.r[31].s64 + 24;
	// 825D13AC: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 825D13B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D13B4: 3A5D0004  addi r18, r29, 4
	ctx.r[18].s64 = ctx.r[29].s64 + 4;
	// 825D13B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D13BC: 40990114  ble cr6, 0x825d14d0
	if !ctx.cr[6].gt {
	pc = 0x825D14D0; continue 'dispatch;
	}
	// 825D13C0: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 825D13C4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825D13C8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825D13CC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825D13D0: 3A6BFA60  addi r19, r11, -0x5a0
	ctx.r[19].s64 = ctx.r[11].s64 + -1440;
	// 825D13D4: C1692600  lfs f11, 0x2600(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9728 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825D13D8: C14AA580  lfs f10, -0x5a80(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-23168 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825D13DC: 7F062000  cmpw cr6, r6, r4
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[4].s32, &mut ctx.xer);
	// 825D13E0: 419A00DC  beq cr6, 0x825d14bc
	if ctx.cr[6].eq {
	pc = 0x825D14BC; continue 'dispatch;
	}
	// 825D13E4: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825D13E8: 419A00D4  beq cr6, 0x825d14bc
	if ctx.cr[6].eq {
	pc = 0x825D14BC; continue 'dispatch;
	}
	// 825D13EC: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 825D13F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D13F4: 4BFFFE05  bl 0x825d11f8
	ctx.lr = 0x825D13F8;
	sub_825D11F8(ctx, base);
	// 825D13F8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825D13FC: 409A00C0  bne cr6, 0x825d14bc
	if !ctx.cr[6].eq {
	pc = 0x825D14BC; continue 'dispatch;
	}
	// 825D1400: 56CB063E  clrlwi r11, r22, 0x18
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	// 825D1404: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D1408: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D1540 size=452
    let mut pc: u32 = 0x825D1540;
    'dispatch: loop {
        match pc {
            0x825D1540 => {
    //   block [0x825D1540..0x825D1704)
	// 825D1540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D1544: 4BF63B51  bl 0x82535094
	ctx.lr = 0x825D1548;
	sub_82535080(ctx, base);
	// 825D1548: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 825D154C: 4BF64A99  bl 0x82535fe4
	ctx.lr = 0x825D1550;
	sub_82535FB0(ctx, base);
	// 825D1550: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D1554: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825D1558: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D155C: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 825D1560: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 825D1564: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 825D1568: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D156C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825D1570: C3CB8CB4  lfs f30, -0x734c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29516 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825D1574: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 825D1578: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 825D157C: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 825D1580: 7E759B78  mr r21, r19
	ctx.r[21].u64 = ctx.r[19].u64;
	// 825D1584: 7E7D9B78  mr r29, r19
	ctx.r[29].u64 = ctx.r[19].u64;
	// 825D1588: 3ADE0004  addi r22, r30, 4
	ctx.r[22].s64 = ctx.r[30].s64 + 4;
	// 825D158C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D1590: 4099015C  ble cr6, 0x825d16ec
	if !ctx.cr[6].gt {
	pc = 0x825D16EC; continue 'dispatch;
	}
	// 825D1594: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 825D1598: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825D159C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825D15A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825D15A4: 7E7C9B78  mr r28, r19
	ctx.r[28].u64 = ctx.r[19].u64;
	// 825D15A8: C3A820AC  lfs f29, 0x20ac(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8364 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825D15AC: 3B0B9F50  addi r24, r11, -0x60b0
	ctx.r[24].s64 = ctx.r[11].s64 + -24752;
	// 825D15B0: C3891850  lfs f28, 0x1850(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6224 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 825D15B4: C36A2784  lfs f27, 0x2784(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10116 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 825D15B8: 7F1DD800  cmpw cr6, r29, r27
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[27].s32, &mut ctx.xer);
	// 825D15BC: 419A011C  beq cr6, 0x825d16d8
	if ctx.cr[6].eq {
	pc = 0x825D16D8; continue 'dispatch;
	}
	// 825D15C0: 7F1DD000  cmpw cr6, r29, r26
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[26].s32, &mut ctx.xer);
	// 825D15C4: 419A0114  beq cr6, 0x825d16d8
	if ctx.cr[6].eq {
	pc = 0x825D16D8; continue 'dispatch;
	}
	// 825D15C8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D1708 size=792
    let mut pc: u32 = 0x825D1708;
    'dispatch: loop {
        match pc {
            0x825D1708 => {
    //   block [0x825D1708..0x825D1A20)
	// 825D1708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D170C: 4BF63991  bl 0x8253509c
	ctx.lr = 0x825D1710;
	sub_82535080(ctx, base);
	// 825D1710: DBA1FF88  stfd f29, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[29].u64 ) };
	// 825D1714: DBC1FF90  stfd f30, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 825D1718: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 825D171C: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D1720: 3EE08000  lis r23, -0x8000
	ctx.r[23].s64 = -2147483648;
	// 825D1724: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825D1728: 3B61007C  addi r27, r1, 0x7c
	ctx.r[27].s64 = ctx.r[1].s64 + 124;
	// 825D172C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825D1730: 62F70020  ori r23, r23, 0x20
	ctx.r[23].u64 = ctx.r[23].u64 | 32;
	// 825D1734: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 825D1738: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825D173C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825D1740: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 825D1744: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D1748: 90A10074  stw r5, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[5].u32 ) };
	// 825D174C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825D1750: 92E10078  stw r23, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[23].u32 ) };
	// 825D1754: C3A92600  lfs f29, 0x2600(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9728 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825D1758: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 825D175C: C3EA8E24  lfs f31, -0x71dc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-29148 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825D1760: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 825D1764: C3CB0DA0  lfs f30, 0xda0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3488 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825D1768: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 825D176C: 3B5F0004  addi r26, r31, 4
	ctx.r[26].s64 = ctx.r[31].s64 + 4;
	// 825D1770: 3AC0FFFF  li r22, -1
	ctx.r[22].s64 = -1;
	// 825D1774: 48000010  b 0x825d1784
	pc = 0x825D1784; continue 'dispatch;
	// 825D1778: 82E10078  lwz r23, 0x78(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 825D177C: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825D1780: 83610070  lwz r27, 0x70(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825D1784: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 825D1788: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D178C: 92C1005C  stw r22, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[22].u32 ) };
	// 825D1790: FDA0F090  fmr f13, f30
	ctx.f[13].f64 = ctx.f[30].f64;
	// 825D1794: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825D1798: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D179C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825D17A0: 409901FC  ble cr6, 0x825d199c
	if !ctx.cr[6].gt {
	pc = 0x825D199C; continue 'dispatch;
	}
	// 825D17A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D17A8: 38670001  addi r3, r7, 1
	ctx.r[3].s64 = ctx.r[7].s64 + 1;
	// 825D17AC: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 825D17B0: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D17B4: 409800B4  bge cr6, 0x825d1868
	if !ctx.cr[6].lt {
	pc = 0x825D1868; continue 'dispatch;
	}
	// 825D17B8: 38C40010  addi r6, r4, 0x10
	ctx.r[6].s64 = ctx.r[4].s64 + 16;
	// 825D17BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D17C0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D1A20 size=612
    let mut pc: u32 = 0x825D1A20;
    'dispatch: loop {
        match pc {
            0x825D1A20 => {
    //   block [0x825D1A20..0x825D1C84)
	// 825D1A20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D1A24: 4BF6368D  bl 0x825350b0
	ctx.lr = 0x825D1A28;
	sub_82535080(ctx, base);
	// 825D1A28: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D1A2C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825D1A30: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D1A34: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D1A38: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825D1A3C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 825D1A40: 80FC0004  lwz r7, 4(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1A44: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 825D1A48: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 825D1A4C: 40990078  ble cr6, 0x825d1ac4
	if !ctx.cr[6].gt {
	pc = 0x825D1AC4; continue 'dispatch;
	}
	// 825D1A50: 811D0000  lwz r8, 0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1A54: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1A58: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1A5C: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 825D1A60: 409A0014  bne cr6, 0x825d1a74
	if !ctx.cr[6].eq {
	pc = 0x825D1A74; continue 'dispatch;
	}
	// 825D1A64: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1A68: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1A6C: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825D1A70: 419A001C  beq cr6, 0x825d1a8c
	if ctx.cr[6].eq {
	pc = 0x825D1A8C; continue 'dispatch;
	}
	// 825D1A74: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1A78: 7F064000  cmpw cr6, r6, r8
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[8].s32, &mut ctx.xer);
	// 825D1A7C: 409A0018  bne cr6, 0x825d1a94
	if !ctx.cr[6].eq {
	pc = 0x825D1A94; continue 'dispatch;
	}
	// 825D1A80: 80DD0004  lwz r6, 4(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1A84: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 825D1A88: 409A000C  bne cr6, 0x825d1a94
	if !ctx.cr[6].eq {
	pc = 0x825D1A94; continue 'dispatch;
	}
	// 825D1A8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D1A90: 48000008  b 0x825d1a98
	pc = 0x825D1A98; continue 'dispatch;
	// 825D1A94: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 825D1A98: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 825D1A9C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D1AA0: 409A001C  bne cr6, 0x825d1abc
	if !ctx.cr[6].eq {
	pc = 0x825D1ABC; continue 'dispatch;
	}
	// 825D1AA4: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1AA8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825D1AAC: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 825D1AB0: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825D1AB4: 4198FFA4  blt cr6, 0x825d1a58
	if ctx.cr[6].lt {
	pc = 0x825D1A58; continue 'dispatch;
	}
	// 825D1AB8: 4800000C  b 0x825d1ac4
	pc = 0x825D1AC4; continue 'dispatch;
	// 825D1ABC: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 825D1AC0: 409A01BC  bne cr6, 0x825d1c7c
	if !ctx.cr[6].eq {
	pc = 0x825D1C7C; continue 'dispatch;
	}
	// 825D1AC4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D1AC8: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D1ACC: 7F075800  cmpw cr6, r7, r11
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D1AD0: 409A0010  bne cr6, 0x825d1ae0
	if !ctx.cr[6].eq {
	pc = 0x825D1AE0; continue 'dispatch;
	}
	// 825D1AD4: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 825D1AD8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825D1ADC: 4BE9C875  bl 0x8246e350
	ctx.lr = 0x825D1AE0;
	sub_8246E350(ctx, base);
	// 825D1AE0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1AE4: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 825D1AE8: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1AEC: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 825D1AF0: 38CB0001  addi r6, r11, 1
	ctx.r[6].s64 = ctx.r[11].s64 + 1;
	// 825D1AF4: 556A2834  slwi r10, r11, 5
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D1AF8: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 825D1AFC: 7D6A4214  add r11, r10, r8
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825D1B00: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825D1B04: 90DC0004  stw r6, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825D1B08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D1B0C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1B10: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D1B14: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1B18: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D1B1C: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D1B20: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D1C88 size=1848
    let mut pc: u32 = 0x825D1C88;
    'dispatch: loop {
        match pc {
            0x825D1C88 => {
    //   block [0x825D1C88..0x825D23C0)
	// 825D1C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D1C8C: 4BF63421  bl 0x825350ac
	ctx.lr = 0x825D1C90;
	sub_82535080(ctx, base);
	// 825D1C90: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 825D1C94: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 825D1C98: 9421EED0  stwu r1, -0x1130(r1)
	ea = ctx.r[1].u32.wrapping_add(-4400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D1C9C: 812D0000  lwz r9, 0(r13)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1CA0: 39600014  li r11, 0x14
	ctx.r[11].s64 = 20;
	// 825D1CA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D1CA8: 7F295A14  add r25, r9, r11
	ctx.r[25].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825D1CAC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825D1CB0: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1CB4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1CB8: 810A000C  lwz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D1CBC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825D1CC0: 40980020  bge cr6, 0x825d1ce0
	if !ctx.cr[6].lt {
	pc = 0x825D1CE0; continue 'dispatch;
	}
	// 825D1CC4: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 825D1CC8: 3908A584  addi r8, r8, -0x5a7c
	ctx.r[8].s64 = ctx.r[8].s64 + -23164;
	// 825D1CCC: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825D1CD0: 7D0C42E6  mftb r8, 0x10c
	ctx.r[8].u64 = crate::rt::rdtsc_u64();
	// 825D1CD4: 38EB000C  addi r7, r11, 0xc
	ctx.r[7].s64 = ctx.r[11].s64 + 12;
	// 825D1CD8: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825D1CDC: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825D1CE0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 825D1CE4: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1CE8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825D1CEC: 7F495A14  add r26, r9, r11
	ctx.r[26].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825D1CF0: 3FA08000  lis r29, -0x8000
	ctx.r[29].s64 = -2147483648;
	// 825D1CF4: 395F0001  addi r10, r31, 1
	ctx.r[10].s64 = ctx.r[31].s64 + 1;
	// 825D1CF8: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 825D1CFC: 55442036  slwi r4, r10, 4
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 825D1D00: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1D04: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 825D1D08: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 825D1D0C: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 825D1D10: 810B002C  lwz r8, 0x2c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 825D1D14: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 825D1D18: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825D1D1C: 4199000C  bgt cr6, 0x825d1d28
	if ctx.cr[6].gt {
	pc = 0x825D1D28; continue 'dispatch;
	}
	// 825D1D20: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 825D1D24: 4800001C  b 0x825d1d40
	pc = 0x825D1D40; continue 'dispatch;
	// 825D1D28: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1D2C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825D1D30: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825D1D34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D1D38: 4E800421  bctrl
	ctx.lr = 0x825D1D3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D1D3C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 825D1D40: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1D44: 7FEBEB78  or r11, r31, r29
	ctx.r[11].u64 = ctx.r[31].u64 | ctx.r[29].u64;
	// 825D1D48: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825D1D4C: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 825D1D50: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D1D54: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 825D1D58: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 825D1D5C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825D1D60: 4099002C  ble cr6, 0x825d1d8c
	if !ctx.cr[6].gt {
	pc = 0x825D1D8C; continue 'dispatch;
	}
	// 825D1D64: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 825D1D68: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1D6C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D23C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D23C0 size=332
    let mut pc: u32 = 0x825D23C0;
    'dispatch: loop {
        match pc {
            0x825D23C0 => {
    //   block [0x825D23C0..0x825D250C)
	// 825D23C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D23C4: 4BF62CE9  bl 0x825350ac
	ctx.lr = 0x825D23C8;
	sub_82535080(ctx, base);
	// 825D23C8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D23CC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825D23D0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825D23D4: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 825D23D8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825D23DC: 7D7ACA14  add r11, r26, r25
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[25].u64;
	// 825D23E0: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 825D23E4: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825D23E8: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 825D23EC: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825D2510 size=32
    let mut pc: u32 = 0x825D2510;
    'dispatch: loop {
        match pc {
            0x825D2510 => {
    //   block [0x825D2510..0x825D2530)
	// 825D2510: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825D2514: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2518: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 825D251C: 40980014  bge cr6, 0x825d2530
	if !ctx.cr[6].lt {
		sub_825D2530(ctx, base);
		return;
	}
	// 825D2520: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825D2524: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2528: EC201028  fsubs f1, f0, f2
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[2].f64) as f32) as f64);
	// 825D252C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2530 size=16
    let mut pc: u32 = 0x825D2530;
    'dispatch: loop {
        match pc {
            0x825D2530 => {
    //   block [0x825D2530..0x825D2540)
	// 825D2530: FF020000  fcmpu cr6, f2, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 825D2534: 4099000C  ble cr6, 0x825d2540
	if !ctx.cr[6].gt {
		sub_825D2540(ctx, base);
		return;
	}
	// 825D2538: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 825D253C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825D2540 size=16
    let mut pc: u32 = 0x825D2540;
    'dispatch: loop {
        match pc {
            0x825D2540 => {
    //   block [0x825D2540..0x825D2550)
	// 825D2540: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D2544: C00B294C  lfs f0, 0x294c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2548: EC201028  fsubs f1, f0, f2
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[2].f64) as f32) as f64);
	// 825D254C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2550 size=4
    let mut pc: u32 = 0x825D2550;
    'dispatch: loop {
        match pc {
            0x825D2550 => {
    //   block [0x825D2550..0x825D2554)
	// 825D2550: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2558 size=52
    let mut pc: u32 = 0x825D2558;
    'dispatch: loop {
        match pc {
            0x825D2558 => {
    //   block [0x825D2558..0x825D258C)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D258C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D258C size=196
    let mut pc: u32 = 0x825D258C;
    'dispatch: loop {
        match pc {
            0x825D258C => {
    //   block [0x825D258C..0x825D2650)
	// 825D258C: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 825D2590: 3941FFE0  addi r10, r1, -0x20
	ctx.r[10].s64 = ctx.r[1].s64 + -32;
	// 825D2594: 3921FFE0  addi r9, r1, -0x20
	ctx.r[9].s64 = ctx.r[1].s64 + -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825D2650 size=80
    let mut pc: u32 = 0x825D2650;
    'dispatch: loop {
        match pc {
            0x825D2650 => {
    //   block [0x825D2650..0x825D26A0)
	// 825D2650: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825D2654: FD800210  fabs f12, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 825D2658: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825D265C: C0E30030  lfs f7, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 825D2660: C12B2150  lfs f9, 0x2150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8528 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 825D2664: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D2668: C10A277C  lfs f8, 0x277c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10108 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 825D266C: C0CB1848  lfs f6, 0x1848(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6216 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 825D2670: FF0C4800  fcmpu cr6, f12, f9
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[9].f64);
	// 825D2674: 4098002C  bge cr6, 0x825d26a0
	if !ctx.cr[6].lt {
		sub_825D26A0(ctx, base);
		return;
	}
	// 825D2678: FD806A10  fabs f12, f13
	ctx.f[12].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 825D267C: FF0C4000  fcmpu cr6, f12, f8
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[8].f64);
	// 825D2680: 40980020  bge cr6, 0x825d26a0
	if !ctx.cr[6].lt {
		sub_825D26A0(ctx, base);
		return;
	}
	// 825D2684: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825D2688: 396B1FF8  addi r11, r11, 0x1ff8
	ctx.r[11].s64 = ctx.r[11].s64 + 8184;
	// 825D268C: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825D2690: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D2694: C00B294C  lfs f0, 0x294c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2698: FC2D02AE  fsel f1, f13, f10, f0
	ctx.f[1].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[10].f64 } else { ctx.f[0].f64 };
	// 825D269C: 480000F0  b 0x825d278c
	sub_825D2784(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D26A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825D26A0 size=76
    let mut pc: u32 = 0x825D26A0;
    'dispatch: loop {
        match pc {
            0x825D26A0 => {
    //   block [0x825D26A0..0x825D26EC)
	// 825D26A0: FD800210  fabs f12, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 825D26A4: FD606A10  fabs f11, f13
	ctx.f[11].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 825D26A8: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 825D26AC: 4099004C  ble cr6, 0x825d26f8
	if !ctx.cr[6].gt {
		sub_825D26F8(ctx, base);
		return;
	}
	// 825D26B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825D26B4: ED8D0024  fdivs f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 825D26B8: C1AB3168  lfs f13, 0x3168(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12648 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D26BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825D26C0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825D26C4: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D26C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825D26CC: EDA06028  fsubs f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 825D26D0: 396B1FF8  addi r11, r11, 0x1ff8
	ctx.r[11].s64 = ctx.r[11].s64 + 8184;
	// 825D26D4: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825D26D8: 40980014  bge cr6, 0x825d26ec
	if !ctx.cr[6].lt {
		sub_825D26EC(ctx, base);
		return;
	}
	// 825D26DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D26E0: C00B294C  lfs f0, 0x294c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D26E4: EC20682A  fadds f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825D26E8: 480000A4  b 0x825d278c
	sub_825D2784(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D26EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D26EC size=12
    let mut pc: u32 = 0x825D26EC;
    'dispatch: loop {
        match pc {
            0x825D26EC => {
    //   block [0x825D26EC..0x825D26F8)
	// 825D26EC: FC005090  fmr f0, f10
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[10].f64;
	// 825D26F0: EC20682A  fadds f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825D26F4: 48000098  b 0x825d278c
	sub_825D2784(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D26F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825D26F8 size=56
    let mut pc: u32 = 0x825D26F8;
    'dispatch: loop {
        match pc {
            0x825D26F8 => {
    //   block [0x825D26F8..0x825D2730)
	// 825D26F8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825D26FC: ED606824  fdivs f11, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 825D2700: C18BA594  lfs f12, -0x5a6c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D2704: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825D2708: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 825D270C: 396B1FF8  addi r11, r11, 0x1ff8
	ctx.r[11].s64 = ctx.r[11].s64 + 8184;
	// 825D2710: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825D2714: 4098001C  bge cr6, 0x825d2730
	if !ctx.cr[6].lt {
		sub_825D2730(ctx, base);
		return;
	}
	// 825D2718: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 825D271C: FF0C4800  fcmpu cr6, f12, f9
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[9].f64);
	// 825D2720: 40980010  bge cr6, 0x825d2730
	if !ctx.cr[6].lt {
		sub_825D2730(ctx, base);
		return;
	}
	// 825D2724: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D2728: C18B294C  lfs f12, 0x294c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10572 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D272C: 48000028  b 0x825d2754
	sub_825D274C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825D2730 size=28
    let mut pc: u32 = 0x825D2730;
    'dispatch: loop {
        match pc {
            0x825D2730 => {
    //   block [0x825D2730..0x825D274C)
	// 825D2730: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825D2734: C18B3168  lfs f12, 0x3168(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12648 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D2738: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 825D273C: 40980010  bge cr6, 0x825d274c
	if !ctx.cr[6].lt {
		sub_825D274C(ctx, base);
		return;
	}
	// 825D2740: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D2744: C18B294C  lfs f12, 0x294c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10572 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D2748: 48000008  b 0x825d2750
	sub_825D274C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D274C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D274C size=28
    let mut pc: u32 = 0x825D274C;
    'dispatch: loop {
        match pc {
            0x825D274C => {
    //   block [0x825D274C..0x825D2768)
	// 825D274C: FD805090  fmr f12, f10
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = ctx.f[10].f64;
	// 825D2750: ED8C582A  fadds f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 825D2754: FD606210  fabs f11, f12
	ctx.f[11].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 825D2758: FF0B3800  fcmpu cr6, f11, f7
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[7].f64);
	// 825D275C: 4098000C  bge cr6, 0x825d2768
	if !ctx.cr[6].lt {
		sub_825D2768(ctx, base);
		return;
	}
	// 825D2760: FC205090  fmr f1, f10
	ctx.f[1].f64 = ctx.f[10].f64;
	// 825D2764: 48000028  b 0x825d278c
	sub_825D2784(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2768 size=28
    let mut pc: u32 = 0x825D2768;
    'dispatch: loop {
        match pc {
            0x825D2768 => {
    //   block [0x825D2768..0x825D2784)
	// 825D2768: FF0D4800  fcmpu cr6, f13, f9
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[9].f64);
	// 825D276C: 40990018  ble cr6, 0x825d2784
	if !ctx.cr[6].gt {
		sub_825D2784(ctx, base);
		return;
	}
	// 825D2770: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 825D2774: FF004000  fcmpu cr6, f0, f8
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[8].f64);
	// 825D2778: 4098000C  bge cr6, 0x825d2784
	if !ctx.cr[6].lt {
		sub_825D2784(ctx, base);
		return;
	}
	// 825D277C: FC003090  fmr f0, f6
	ctx.f[0].f64 = ctx.f[6].f64;
	// 825D2780: 48000008  b 0x825d2788
	sub_825D2784(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2784(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2784 size=32
    let mut pc: u32 = 0x825D2784;
    'dispatch: loop {
        match pc {
            0x825D2784 => {
    //   block [0x825D2784..0x825D27A4)
	// 825D2784: FC005090  fmr f0, f10
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[10].f64;
	// 825D2788: EC20602A  fadds f1, f0, f12
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 825D278C: FC003850  fneg f0, f7
	ctx.f[0].u64 = ctx.f[7].u64 ^ 0x8000_0000_0000_0000u64;
	// 825D2790: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 825D2794: 40980008  bge cr6, 0x825d279c
	if !ctx.cr[6].lt {
	pc = 0x825D279C; continue 'dispatch;
	}
	// 825D2798: EC21302A  fadds f1, f1, f6
	ctx.f[1].f64 = ((ctx.f[1].f64 + ctx.f[6].f64) as f32) as f64;
	// 825D279C: FF013000  fcmpu cr6, f1, f6
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[6].f64);
	// 825D27A0: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D27A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D27A4 size=8
    let mut pc: u32 = 0x825D27A4;
    'dispatch: loop {
        match pc {
            0x825D27A4 => {
    //   block [0x825D27A4..0x825D27AC)
	// 825D27A4: FC205090  fmr f1, f10
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[10].f64;
	// 825D27A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D27B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D27B0 size=176
    let mut pc: u32 = 0x825D27B0;
    'dispatch: loop {
        match pc {
            0x825D27B0 => {
    //   block [0x825D27B0..0x825D2860)
	// 825D27B0: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825D27B4: 419A0038  beq cr6, 0x825d27ec
	if ctx.cr[6].eq {
	pc = 0x825D27EC; continue 'dispatch;
	}
	// 825D27B8: A1650000  lhz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D27BC: A1460000  lhz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D27C0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825D27C4: 409A0028  bne cr6, 0x825d27ec
	if !ctx.cr[6].eq {
	pc = 0x825D27EC; continue 'dispatch;
	}
	// 825D27C8: A1650002  lhz r11, 2(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D27CC: A1460002  lhz r10, 2(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D27D0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D27D4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825D27D8: 7D6B222E  lhzx r11, r11, r4
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 825D27DC: 7D4A222E  lhzx r10, r10, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 825D27E0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825D27E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D27E8: 409A0008  bne cr6, 0x825d27f0
	if !ctx.cr[6].eq {
	pc = 0x825D27F0; continue 'dispatch;
	}
	// 825D27EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825D27F0: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825D27F4: 419A0038  beq cr6, 0x825d282c
	if ctx.cr[6].eq {
	pc = 0x825D282C; continue 'dispatch;
	}
	// 825D27F8: A1670000  lhz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D27FC: A1280000  lhz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2800: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825D2804: 409A0028  bne cr6, 0x825d282c
	if !ctx.cr[6].eq {
	pc = 0x825D282C; continue 'dispatch;
	}
	// 825D2808: A1670002  lhz r11, 2(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D280C: A1280002  lhz r9, 2(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D2810: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D2814: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825D2818: 7D6B222E  lhzx r11, r11, r4
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 825D281C: 7D29222E  lhzx r9, r9, r4
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 825D2820: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825D2824: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D2828: 409A0008  bne cr6, 0x825d2830
	if !ctx.cr[6].eq {
	pc = 0x825D2830; continue 'dispatch;
	}
	// 825D282C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D2830: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 825D2834: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D2838: 419A0014  beq cr6, 0x825d284c
	if ctx.cr[6].eq {
	pc = 0x825D284C; continue 'dispatch;
	}
	// 825D283C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825D2840: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D2844: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D2848: 409A0008  bne cr6, 0x825d2850
	if !ctx.cr[6].eq {
	pc = 0x825D2850; continue 'dispatch;
	}
	// 825D284C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D2850: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 825D2854: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825D2858: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D285C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2860 size=68
    let mut pc: u32 = 0x825D2860;
    'dispatch: loop {
        match pc {
            0x825D2860 => {
    //   block [0x825D2860..0x825D28A4)
	// 825D2860: 7F054040  cmplw cr6, r5, r8
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825D2864: 419A0040  beq cr6, 0x825d28a4
	if ctx.cr[6].eq {
		sub_825D28A4(ctx, base);
		return;
	}
	// 825D2868: A1650000  lhz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D286C: A1480000  lhz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2870: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825D2874: 409A0030  bne cr6, 0x825d28a4
	if !ctx.cr[6].eq {
		sub_825D28A4(ctx, base);
		return;
	}
	// 825D2878: A1650002  lhz r11, 2(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D287C: A1480002  lhz r10, 2(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D2880: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D2884: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825D2888: 7D6B222E  lhzx r11, r11, r4
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 825D288C: 7D4A222E  lhzx r10, r10, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 825D2890: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825D2894: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825D2898: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825D289C: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 825D28A0: 48000008  b 0x825d28a8
	sub_825D28A4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D28A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D28A4 size=84
    let mut pc: u32 = 0x825D28A4;
    'dispatch: loop {
        match pc {
            0x825D28A4 => {
    //   block [0x825D28A4..0x825D28F8)
	// 825D28A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D28A8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825D28AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D28B0: 419A0048  beq cr6, 0x825d28f8
	if ctx.cr[6].eq {
		sub_825D28F8(ctx, base);
		return;
	}
	// 825D28B4: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825D28B8: 419A0040  beq cr6, 0x825d28f8
	if ctx.cr[6].eq {
		sub_825D28F8(ctx, base);
		return;
	}
	// 825D28BC: A1670000  lhz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D28C0: A1480000  lhz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D28C4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825D28C8: 409A0030  bne cr6, 0x825d28f8
	if !ctx.cr[6].eq {
		sub_825D28F8(ctx, base);
		return;
	}
	// 825D28CC: A1670002  lhz r11, 2(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D28D0: A1480002  lhz r10, 2(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D28D4: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D28D8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825D28DC: 7D6B222E  lhzx r11, r11, r4
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 825D28E0: 7D4A222E  lhzx r10, r10, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 825D28E4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825D28E8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825D28EC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825D28F0: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 825D28F4: 48000008  b 0x825d28fc
	sub_825D28F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D28F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D28F8 size=84
    let mut pc: u32 = 0x825D28F8;
    'dispatch: loop {
        match pc {
            0x825D28F8 => {
    //   block [0x825D28F8..0x825D294C)
	// 825D28F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D28FC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825D2900: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D2904: 419A0048  beq cr6, 0x825d294c
	if ctx.cr[6].eq {
		sub_825D294C(ctx, base);
		return;
	}
	// 825D2908: A1650002  lhz r11, 2(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D290C: A1480000  lhz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2910: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D2914: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 825D2918: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D291C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825D2920: 409A002C  bne cr6, 0x825d294c
	if !ctx.cr[6].eq {
		sub_825D294C(ctx, base);
		return;
	}
	// 825D2924: A1480002  lhz r10, 2(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D2928: A1250000  lhz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D292C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825D2930: 7D4A222E  lhzx r10, r10, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 825D2934: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825D2938: 409A0014  bne cr6, 0x825d294c
	if !ctx.cr[6].eq {
		sub_825D294C(ctx, base);
		return;
	}
	// 825D293C: 7D6B4050  subf r11, r11, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 825D2940: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825D2944: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825D2948: 48000008  b 0x825d2950
	sub_825D294C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D294C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D294C size=84
    let mut pc: u32 = 0x825D294C;
    'dispatch: loop {
        match pc {
            0x825D294C => {
    //   block [0x825D294C..0x825D29A0)
	// 825D294C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D2950: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825D2954: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D2958: 419A0048  beq cr6, 0x825d29a0
	if ctx.cr[6].eq {
		sub_825D29A0(ctx, base);
		return;
	}
	// 825D295C: A1670002  lhz r11, 2(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D2960: A1480000  lhz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2964: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D2968: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 825D296C: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2970: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825D2974: 409A002C  bne cr6, 0x825d29a0
	if !ctx.cr[6].eq {
		sub_825D29A0(ctx, base);
		return;
	}
	// 825D2978: A1480002  lhz r10, 2(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D297C: A1270000  lhz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2980: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825D2984: 7D4A222E  lhzx r10, r10, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 825D2988: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825D298C: 409A0014  bne cr6, 0x825d29a0
	if !ctx.cr[6].eq {
		sub_825D29A0(ctx, base);
		return;
	}
	// 825D2990: 7D6B4050  subf r11, r11, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 825D2994: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825D2998: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825D299C: 48000008  b 0x825d29a4
	sub_825D29A0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D29A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D29A0 size=76
    let mut pc: u32 = 0x825D29A0;
    'dispatch: loop {
        match pc {
            0x825D29A0 => {
    //   block [0x825D29A0..0x825D29EC)
	// 825D29A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D29A4: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 825D29A8: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825D29AC: 419A0040  beq cr6, 0x825d29ec
	if ctx.cr[6].eq {
		sub_825D29EC(ctx, base);
		return;
	}
	// 825D29B0: A1650000  lhz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D29B4: A1260000  lhz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D29B8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825D29BC: 409A0030  bne cr6, 0x825d29ec
	if !ctx.cr[6].eq {
		sub_825D29EC(ctx, base);
		return;
	}
	// 825D29C0: A1650002  lhz r11, 2(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D29C4: A1260002  lhz r9, 2(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D29C8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D29CC: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825D29D0: 7D6B222E  lhzx r11, r11, r4
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 825D29D4: 7D29222E  lhzx r9, r9, r4
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 825D29D8: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 825D29DC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825D29E0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825D29E4: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 825D29E8: 48000008  b 0x825d29f0
	sub_825D29EC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D29EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D29EC size=84
    let mut pc: u32 = 0x825D29EC;
    'dispatch: loop {
        match pc {
            0x825D29EC => {
    //   block [0x825D29EC..0x825D2A40)
	// 825D29EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D29F0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825D29F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D29F8: 419A0048  beq cr6, 0x825d2a40
	if ctx.cr[6].eq {
		sub_825D2A40(ctx, base);
		return;
	}
	// 825D29FC: 7F073040  cmplw cr6, r7, r6
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825D2A00: 419A0040  beq cr6, 0x825d2a40
	if ctx.cr[6].eq {
		sub_825D2A40(ctx, base);
		return;
	}
	// 825D2A04: A1660000  lhz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2A08: A1270000  lhz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2A0C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825D2A10: 409A0030  bne cr6, 0x825d2a40
	if !ctx.cr[6].eq {
		sub_825D2A40(ctx, base);
		return;
	}
	// 825D2A14: A1660002  lhz r11, 2(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D2A18: A1270002  lhz r9, 2(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D2A1C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D2A20: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825D2A24: 7D6B222E  lhzx r11, r11, r4
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 825D2A28: 7D29222E  lhzx r9, r9, r4
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 825D2A2C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825D2A30: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825D2A34: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825D2A38: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 825D2A3C: 48000008  b 0x825d2a44
	sub_825D2A40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2A40 size=84
    let mut pc: u32 = 0x825D2A40;
    'dispatch: loop {
        match pc {
            0x825D2A40 => {
    //   block [0x825D2A40..0x825D2A94)
	// 825D2A40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D2A44: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825D2A48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D2A4C: 419A0048  beq cr6, 0x825d2a94
	if ctx.cr[6].eq {
		sub_825D2A94(ctx, base);
		return;
	}
	// 825D2A50: A1650002  lhz r11, 2(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D2A54: A1260000  lhz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2A58: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D2A5C: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 825D2A60: A10B0000  lhz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2A64: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825D2A68: 409A002C  bne cr6, 0x825d2a94
	if !ctx.cr[6].eq {
		sub_825D2A94(ctx, base);
		return;
	}
	// 825D2A6C: A1260002  lhz r9, 2(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D2A70: A1050000  lhz r8, 0(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2A74: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825D2A78: 7D29222E  lhzx r9, r9, r4
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 825D2A7C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825D2A80: 409A0014  bne cr6, 0x825d2a94
	if !ctx.cr[6].eq {
		sub_825D2A94(ctx, base);
		return;
	}
	// 825D2A84: 7D6B3050  subf r11, r11, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 825D2A88: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825D2A8C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825D2A90: 48000008  b 0x825d2a98
	sub_825D2A94(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2A94(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2A94 size=84
    let mut pc: u32 = 0x825D2A94;
    'dispatch: loop {
        match pc {
            0x825D2A94 => {
    //   block [0x825D2A94..0x825D2AE8)
	// 825D2A94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D2A98: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825D2A9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D2AA0: 419A0048  beq cr6, 0x825d2ae8
	if ctx.cr[6].eq {
		sub_825D2AE8(ctx, base);
		return;
	}
	// 825D2AA4: A1670002  lhz r11, 2(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D2AA8: A1260000  lhz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2AAC: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D2AB0: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 825D2AB4: A10B0000  lhz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2AB8: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825D2ABC: 409A002C  bne cr6, 0x825d2ae8
	if !ctx.cr[6].eq {
		sub_825D2AE8(ctx, base);
		return;
	}
	// 825D2AC0: A1260002  lhz r9, 2(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D2AC4: A1070000  lhz r8, 0(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2AC8: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825D2ACC: 7D29222E  lhzx r9, r9, r4
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 825D2AD0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825D2AD4: 409A0014  bne cr6, 0x825d2ae8
	if !ctx.cr[6].eq {
		sub_825D2AE8(ctx, base);
		return;
	}
	// 825D2AD8: 7D6B3050  subf r11, r11, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 825D2ADC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825D2AE0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825D2AE4: 48000008  b 0x825d2aec
	sub_825D2AE8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2AE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2AE8 size=44
    let mut pc: u32 = 0x825D2AE8;
    'dispatch: loop {
        match pc {
            0x825D2AE8 => {
    //   block [0x825D2AE8..0x825D2B14)
	// 825D2AE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D2AEC: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 825D2AF0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D2AF4: 419A0014  beq cr6, 0x825d2b08
	if ctx.cr[6].eq {
	pc = 0x825D2B08; continue 'dispatch;
	}
	// 825D2AF8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825D2AFC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D2B00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D2B04: 409A0008  bne cr6, 0x825d2b0c
	if !ctx.cr[6].eq {
	pc = 0x825D2B0C; continue 'dispatch;
	}
	// 825D2B08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D2B0C: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825D2B10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825D2B18 size=28
    let mut pc: u32 = 0x825D2B18;
    'dispatch: loop {
        match pc {
            0x825D2B18 => {
    //   block [0x825D2B18..0x825D2B34)
	// 825D2B18: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2B1C: C1A50000  lfs f13, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D2B20: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825D2B24: 40980010  bge cr6, 0x825d2b34
	if !ctx.cr[6].lt {
		sub_825D2B34(ctx, base);
		return;
	}
	// 825D2B28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D2B2C: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825D2B30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2B34(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825D2B34 size=80
    let mut pc: u32 = 0x825D2B34;
    'dispatch: loop {
        match pc {
            0x825D2B34 => {
    //   block [0x825D2B34..0x825D2B84)
	// 825D2B34: FF006800  fcmpu cr6, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825D2B38: 409A0014  bne cr6, 0x825d2b4c
	if !ctx.cr[6].eq {
	pc = 0x825D2B4C; continue 'dispatch;
	}
	// 825D2B3C: C1840004  lfs f12, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D2B40: C1650004  lfs f11, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825D2B44: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 825D2B48: 4198FFE0  blt cr6, 0x825d2b28
	if ctx.cr[6].lt {
		sub_825D2B18(ctx, base);
		return;
	}
	// 825D2B4C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825D2B50: 409A0028  bne cr6, 0x825d2b78
	if !ctx.cr[6].eq {
	pc = 0x825D2B78; continue 'dispatch;
	}
	// 825D2B54: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2B58: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D2B5C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825D2B60: 409A0018  bne cr6, 0x825d2b78
	if !ctx.cr[6].eq {
	pc = 0x825D2B78; continue 'dispatch;
	}
	// 825D2B64: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2B68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D2B6C: C1A50008  lfs f13, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D2B70: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825D2B74: 41980008  blt cr6, 0x825d2b7c
	if ctx.cr[6].lt {
	pc = 0x825D2B7C; continue 'dispatch;
	}
	// 825D2B78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D2B7C: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825D2B80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825D2B88 size=32
    let mut pc: u32 = 0x825D2B88;
    'dispatch: loop {
        match pc {
            0x825D2B88 => {
    //   block [0x825D2B88..0x825D2BA8)
	// 825D2B88: C0040004  lfs f0, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2B8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D2B90: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D2B94: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825D2B98: 41980008  blt cr6, 0x825d2ba0
	if ctx.cr[6].lt {
	pc = 0x825D2BA0; continue 'dispatch;
	}
	// 825D2B9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D2BA0: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825D2BA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825D2BA8 size=32
    let mut pc: u32 = 0x825D2BA8;
    'dispatch: loop {
        match pc {
            0x825D2BA8 => {
    //   block [0x825D2BA8..0x825D2BC8)
	// 825D2BA8: C0040010  lfs f0, 0x10(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2BAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D2BB0: C1A50010  lfs f13, 0x10(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D2BB4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825D2BB8: 41980008  blt cr6, 0x825d2bc0
	if ctx.cr[6].lt {
	pc = 0x825D2BC0; continue 'dispatch;
	}
	// 825D2BBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D2BC0: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825D2BC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2BC8 size=12
    let mut pc: u32 = 0x825D2BC8;
    'dispatch: loop {
        match pc {
            0x825D2BC8 => {
    //   block [0x825D2BC8..0x825D2BD4)
	// 825D2BC8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D2BCC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D2BD0: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2BD4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2BD4 size=44
    let mut pc: u32 = 0x825D2BD4;
    'dispatch: loop {
        match pc {
            0x825D2BD4 => {
    //   block [0x825D2BD4..0x825D2C00)
	// 825D2BD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2BD8: 39240010  addi r9, r4, 0x10
	ctx.r[9].s64 = ctx.r[4].s64 + 16;
	// 825D2BDC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825D2C00 size=188
    let mut pc: u32 = 0x825D2C00;
    'dispatch: loop {
        match pc {
            0x825D2C00 => {
    //   block [0x825D2C00..0x825D2CBC)
	// 825D2C00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D2C04: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2C08: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2C0C: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D2C10: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D2C14: C1840004  lfs f12, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D2C18: C1640014  lfs f11, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825D2C1C: C1440008  lfs f10, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825D2C20: 7D2B442E  lfsx f9, r11, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 825D2C24: ECE04828  fsubs f7, f0, f9
	ctx.f[7].f64 = (((ctx.f[0].f64 - ctx.f[9].f64) as f32) as f64);
	// 825D2C28: C1040018  lfs f8, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 825D2C2C: FC07026E  fsel f0, f7, f9, f0
	ctx.f[0].f64 = if ctx.f[7].f64 >= 0.0 { ctx.f[9].f64 } else { ctx.f[0].f64 };
	// 825D2C30: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825D2C34: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2C38: 7C0B442E  lfsx f0, r11, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2C3C: ED2D0028  fsubs f9, f13, f0
	ctx.f[9].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 825D2C40: FC09036E  fsel f0, f9, f13, f0
	ctx.f[0].f64 = if ctx.f[9].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 825D2C44: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825D2C48: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2C4C: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825D2C50: C0080004  lfs f0, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2C54: EDAC0028  fsubs f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 825D2C58: FC0D602E  fsel f0, f13, f0, f12
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[12].f64 };
	// 825D2C5C: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825D2C60: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2C64: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825D2C68: C0080004  lfs f0, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2C6C: EDAB0028  fsubs f13, f11, f0
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 825D2C70: FC0D02EE  fsel f0, f13, f11, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[0].f64 };
	// 825D2C74: D0040014  stfs f0, 0x14(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 825D2C78: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2C7C: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825D2C80: C0080008  lfs f0, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2C84: EDAA0028  fsubs f13, f10, f0
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 825D2C88: FC0D502E  fsel f0, f13, f0, f10
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[10].f64 };
	// 825D2C8C: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825D2C90: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2C94: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825D2C98: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825D2C9C: C0080008  lfs f0, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2CA0: EDA80028  fsubs f13, f8, f0
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 825D2CA4: FC0D022E  fsel f0, f13, f8, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[8].f64 } else { ctx.f[0].f64 };
	// 825D2CA8: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 825D2CAC: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D2CB0: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 825D2CB4: 4198FF50  blt cr6, 0x825d2c04
	if ctx.cr[6].lt {
	pc = 0x825D2C04; continue 'dispatch;
	}
	// 825D2CB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2CC0 size=4
    let mut pc: u32 = 0x825D2CC0;
    'dispatch: loop {
        match pc {
            0x825D2CC0 => {
    //   block [0x825D2CC0..0x825D2CC4)
	// 825D2CC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D2CC8 size=488
    let mut pc: u32 = 0x825D2CC8;
    'dispatch: loop {
        match pc {
            0x825D2CC8 => {
    //   block [0x825D2CC8..0x825D2EB0)
	// 825D2CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D2CCC: 4BF623E9  bl 0x825350b4
	ctx.lr = 0x825D2CD0;
	sub_82535080(ctx, base);
	// 825D2CD0: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D2CD4: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 825D2CD8: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 825D2CDC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D2CE0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825D2CE4: 4BFFFEE5  bl 0x825d2bc8
	ctx.lr = 0x825D2CE8;
	sub_825D2BC8(ctx, base);
	// 825D2CE8: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 825D2CEC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D2EB0 size=352
    let mut pc: u32 = 0x825D2EB0;
    'dispatch: loop {
        match pc {
            0x825D2EB0 => {
    //   block [0x825D2EB0..0x825D3010)
	// 825D2EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D2EB4: 4BF62201  bl 0x825350b4
	ctx.lr = 0x825D2EB8;
	sub_82535080(ctx, base);
	// 825D2EB8: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D2EBC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825D2EC0: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2EC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D2EC8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825D2ECC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D3010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D3010 size=140
    let mut pc: u32 = 0x825D3010;
    'dispatch: loop {
        match pc {
            0x825D3010 => {
    //   block [0x825D3010..0x825D309C)
	// 825D3010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D3014: 4BF62099  bl 0x825350ac
	ctx.lr = 0x825D3018;
	sub_82535080(ctx, base);
	// 825D3018: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D301C: 832D0000  lwz r25, 0(r13)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D3020: 3B400010  li r26, 0x10
	ctx.r[26].s64 = 16;
	// 825D3024: 38A00016  li r5, 0x16
	ctx.r[5].s64 = 22;
	// 825D3028: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 825D302C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D3030: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 825D3034: 4BE91235  bl 0x82464268
	ctx.lr = 0x825D3038;
	sub_82464268(ctx, base);
	// 825D3038: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D303C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825D3040: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D3044: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D3048: 40990040  ble cr6, 0x825d3088
	if !ctx.cr[6].gt {
	pc = 0x825D3088; continue 'dispatch;
	}
	// 825D304C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825D3050: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825D3054: 3B6BA598  addi r27, r11, -0x5a68
	ctx.r[27].s64 = ctx.r[11].s64 + -23144;
	// 825D3058: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D305C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D3060: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825D3064: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 825D3068: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825D306C: A0CB0004  lhz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D3070: 4BE96F19  bl 0x82469f88
	ctx.lr = 0x825D3074;
	sub_82469F88(ctx, base);
	// 825D3074: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D3078: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825D307C: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825D3080: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D3084: 4198FFD4  blt cr6, 0x825d3058
	if ctx.cr[6].lt {
	pc = 0x825D3058; continue 'dispatch;
	}
	// 825D3088: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D308C: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 825D3090: 4BE91231  bl 0x824642c0
	ctx.lr = 0x825D3094;
	sub_824642C0(ctx, base);
	// 825D3094: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825D3098: 4BF62064  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D30A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D30A0 size=788
    let mut pc: u32 = 0x825D30A0;
    'dispatch: loop {
        match pc {
            0x825D30A0 => {
    //   block [0x825D30A0..0x825D33B4)
	// 825D30A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D30A4: 4BF6200D  bl 0x825350b0
	ctx.lr = 0x825D30A8;
	sub_82535080(ctx, base);
	// 825D30A8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D30AC: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D30B0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D30B4: 83E50000  lwz r31, 0(r5)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D30B8: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 825D30BC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825D30C0: 409802E0  bge cr6, 0x825d33a0
	if !ctx.cr[6].lt {
	pc = 0x825D33A0; continue 'dispatch;
	}
	// 825D30C4: 81460008  lwz r10, 8(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D30C8: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 825D30CC: 409802D4  bge cr6, 0x825d33a0
	if !ctx.cr[6].lt {
	pc = 0x825D33A0; continue 'dispatch;
	}
	// 825D30D0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825D30D4: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 825D30D8: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 825D30DC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 825D30E0: 409A006C  bne cr6, 0x825d314c
	if !ctx.cr[6].eq {
	pc = 0x825D314C; continue 'dispatch;
	}
	// 825D30E4: 81450004  lwz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D30E8: A12A0002  lhz r9, 2(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D30EC: A16A0000  lhz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D30F0: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825D30F4: 7D49522E  lhzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825D30F8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D30FC: 40980010  bge cr6, 0x825d310c
	if !ctx.cr[6].lt {
	pc = 0x825D310C; continue 'dispatch;
	}
	// 825D3100: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 825D3104: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825D3108: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 825D310C: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D3110: 80A60008  lwz r5, 8(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D3114: 2F050002  cmpwi cr6, r5, 2
	ctx.cr[6].compare_i32(ctx.r[5].s32, 2, &mut ctx.xer);
	// 825D3118: A0890000  lhz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D311C: 409A0068  bne cr6, 0x825d3184
	if !ctx.cr[6].eq {
	pc = 0x825D3184; continue 'dispatch;
	}
	// 825D3120: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825D3124: A1090002  lhz r8, 2(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D3128: 5508183E  rotlwi r8, r8, 3
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(3)) as u64;
	// 825D312C: 7D084A2E  lhzx r8, r8, r9
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 825D3130: 7F082000  cmpw cr6, r8, r4
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[4].s32, &mut ctx.xer);
	// 825D3134: 40980010  bge cr6, 0x825d3144
	if !ctx.cr[6].lt {
	pc = 0x825D3144; continue 'dispatch;
	}
	// 825D3138: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 825D313C: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 825D3140: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 825D3144: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 825D3148: 4800003C  b 0x825d3184
	pc = 0x825D3184; continue 'dispatch;
	// 825D314C: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 825D3150: 409A0228  bne cr6, 0x825d3378
	if !ctx.cr[6].eq {
	pc = 0x825D3378; continue 'dispatch;
	}
	// 825D3154: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D3158: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D315C: A12A0002  lhz r9, 2(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D3160: A08A0000  lhz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D3164: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825D3168: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D316C: 7D49522E  lhzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825D3170: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D3174: 40980010  bge cr6, 0x825d3184
	if !ctx.cr[6].lt {
	pc = 0x825D3184; continue 'dispatch;
	}
	// 825D3178: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 825D317C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825D3180: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 825D3184: 55692036  slwi r9, r11, 4
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825D3188: 55462036  slwi r6, r10, 4
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 825D318C: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 825D3190: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825D3194: 549C2036  slwi r28, r4, 4
	ctx.r[28].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D33B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825D33B8 size=188
    let mut pc: u32 = 0x825D33B8;
    'dispatch: loop {
        match pc {
            0x825D33B8 => {
    //   block [0x825D33B8..0x825D3474)
	// 825D33B8: C1A40000  lfs f13, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D33BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825D33C0: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D33C4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D3474(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D3474 size=252
    let mut pc: u32 = 0x825D3474;
    'dispatch: loop {
        match pc {
            0x825D3474 => {
    //   block [0x825D3474..0x825D3570)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D3570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D3570 size=456
    let mut pc: u32 = 0x825D3570;
    'dispatch: loop {
        match pc {
            0x825D3570 => {
    //   block [0x825D3570..0x825D3738)
	// 825D3570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D3574: 4BF61B2D  bl 0x825350a0
	ctx.lr = 0x825D3578;
	sub_82535080(ctx, base);
	// 825D3578: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D357C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 825D3580: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825D3584: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825D3588: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 825D358C: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 825D3590: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D3594: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 825D3598: 83C90000  lwz r30, 0(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D359C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D35A0: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D35A4: 3B890004  addi r28, r9, 4
	ctx.r[28].s64 = ctx.r[9].s64 + 4;
	// 825D35A8: 3B680004  addi r27, r8, 4
	ctx.r[27].s64 = ctx.r[8].s64 + 4;
	// 825D35AC: 3B5F0004  addi r26, r31, 4
	ctx.r[26].s64 = ctx.r[31].s64 + 4;
	// 825D35B0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D35B4: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D35B8: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D35BC: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 825D35C0: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 825D35C4: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 825D35C8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825D35CC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D35D0: A14A0000  lhz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D35D4: 554A203E  rotlwi r10, r10, 4
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(4)) as u64;
	// 825D35D8: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D35DC: 7CCAF214  add r6, r10, r30
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 825D35E0: 556B203E  rotlwi r11, r11, 4
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(4)) as u64;
	// 825D35E4: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 825D35E8: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825D35EC: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 825D35F0: 4BFFFDC9  bl 0x825d33b8
	ctx.lr = 0x825D35F4;
	sub_825D33B8(ctx, base);
	// 825D35F4: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D35F8: 81480008  lwz r10, 8(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D35FC: 3AE90008  addi r23, r9, 8
	ctx.r[23].s64 = ctx.r[9].s64 + 8;
	// 825D3600: 3AC80008  addi r22, r8, 8
	ctx.r[22].s64 = ctx.r[8].s64 + 8;
	// 825D3604: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825D3608: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 825D360C: 5578083C  slwi r24, r11, 1
	ctx.r[24].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[24].u64 = ctx.r[24].u32 as u64;
	// 825D3610: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 825D3614: 4099011C  ble cr6, 0x825d3730
	if !ctx.cr[6].gt {
	pc = 0x825D3730; continue 'dispatch;
	}
	// 825D3618: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825D361C: C14B277C  lfs f10, 0x277c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10108 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825D3620: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D3624: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D3628: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 825D362C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825D3630: 41980068  blt cr6, 0x825d3698
	if ctx.cr[6].lt {
	pc = 0x825D3698; continue 'dispatch;
	}
	// 825D3634: 55091838  slwi r9, r8, 3
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825D3638: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D3738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D3738 size=104
    let mut pc: u32 = 0x825D3738;
    'dispatch: loop {
        match pc {
            0x825D3738 => {
    //   block [0x825D3738..0x825D37A0)
	// 825D3738: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825D373C: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 825D3740: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D3744: A14A0000  lhz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D3748: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825D374C: 40990014  ble cr6, 0x825d3760
	if !ctx.cr[6].gt {
	pc = 0x825D3760; continue 'dispatch;
	}
	// 825D3750: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 825D3754: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825D3758: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 825D375C: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 825D3760: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 825D3764: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 825D3768: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D376C: A14A0000  lhz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D3770: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825D3774: 40990014  ble cr6, 0x825d3788
	if !ctx.cr[6].gt {
	pc = 0x825D3788; continue 'dispatch;
	}
	// 825D3778: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 825D377C: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 825D3780: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 825D3784: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 825D3788: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825D378C: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 825D3790: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D3794: A14A0000  lhz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D3798: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825D379C: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D37A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D37A0 size=20
    let mut pc: u32 = 0x825D37A0;
    'dispatch: loop {
        match pc {
            0x825D37A0 => {
    //   block [0x825D37A0..0x825D37B4)
	// 825D37A0: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 825D37A4: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825D37A8: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 825D37AC: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 825D37B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D37B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D37B8 size=1168
    let mut pc: u32 = 0x825D37B8;
    'dispatch: loop {
        match pc {
            0x825D37B8 => {
    //   block [0x825D37B8..0x825D3C48)
	// 825D37B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D37BC: 4BF618E9  bl 0x825350a4
	ctx.lr = 0x825D37C0;
	sub_82535080(ctx, base);
	// 825D37C0: 9421FD50  stwu r1, -0x2b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-688 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D37C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D37C8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825D37CC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 825D37D0: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825D37D4: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 825D37D8: C1AB1850  lfs f13, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D37DC: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 825D37E0: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D37E4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825D37E8: D1A10080  stfs f13, 0x80(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 825D37EC: 39610130  addi r11, r1, 0x130
	ctx.r[11].s64 = ctx.r[1].s64 + 304;
	// 825D37F0: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 825D37F4: 3940000D  li r10, 0xd
	ctx.r[10].s64 = 13;
	// 825D37F8: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 825D37FC: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 825D3800: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 825D3804: C1892074  lfs f12, 0x2074(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8308 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D3808: 39210130  addi r9, r1, 0x130
	ctx.r[9].s64 = ctx.r[1].s64 + 304;
	// 825D380C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825D3810: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825D3814: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D3C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D3C48 size=348
    let mut pc: u32 = 0x825D3C48;
    'dispatch: loop {
        match pc {
            0x825D3C48 => {
    //   block [0x825D3C48..0x825D3DA4)
	// 825D3C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D3C4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D3C50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D3C54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D3C58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D3C5C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825D3C60: 3BC30004  addi r30, r3, 4
	ctx.r[30].s64 = ctx.r[3].s64 + 4;
	// 825D3C64: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D3C68: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D3C6C: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 825D3C70: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 825D3C74: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825D3C78: 4198008C  blt cr6, 0x825d3d04
	if ctx.cr[6].lt {
	pc = 0x825D3D04; continue 'dispatch;
	}
	// 825D3C7C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825D3C80: 38C7FFF0  addi r6, r7, -0x10
	ctx.r[6].s64 = ctx.r[7].s64 + -16;
	// 825D3C84: C1AB20B0  lfs f13, 0x20b0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D3C88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D3C8C: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 825D3C90: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825D3C94: 4198004C  blt cr6, 0x825d3ce0
	if ctx.cr[6].lt {
	pc = 0x825D3CE0; continue 'dispatch;
	}
	// 825D3C98: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D3C9C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825D3CA0: C18A0000  lfs f12, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D3CA4: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 825D3CA8: 41980038  blt cr6, 0x825d3ce0
	if ctx.cr[6].lt {
	pc = 0x825D3CE0; continue 'dispatch;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D3DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D3DA8 size=1688
    let mut pc: u32 = 0x825D3DA8;
    'dispatch: loop {
        match pc {
            0x825D3DA8 => {
    //   block [0x825D3DA8..0x825D4440)
	// 825D3DA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D3DAC: 4BF612D5  bl 0x82535080
	ctx.lr = 0x825D3DB0;
	sub_82535080(ctx, base);
	// 825D3DB0: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825D3DB4: 4BF6222D  bl 0x82535fe0
	ctx.lr = 0x825D3DB8;
	sub_82535FB0(ctx, base);
	// 825D3DB8: 3980FF00  li r12, -0x100
	ctx.r[12].s64 = -256;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D4440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D4440 size=420
    let mut pc: u32 = 0x825D4440;
    'dispatch: loop {
        match pc {
            0x825D4440 => {
    //   block [0x825D4440..0x825D45E4)
	// 825D4440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D4444: 4BF60C61  bl 0x825350a4
	ctx.lr = 0x825D4448;
	sub_82535080(ctx, base);
	// 825D4448: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D444C: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 825D4450: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825D4454: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 825D4458: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825D445C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 825D4460: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4464: 3B1F0004  addi r24, r31, 4
	ctx.r[24].s64 = ctx.r[31].s64 + 4;
	// 825D4468: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D446C: 3AFF0008  addi r23, r31, 8
	ctx.r[23].s64 = ctx.r[31].s64 + 8;
	// 825D4470: 3BDC0001  addi r30, r28, 1
	ctx.r[30].s64 = ctx.r[28].s64 + 1;
	// 825D4474: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D4478: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 825D447C: 40980024  bge cr6, 0x825d44a0
	if !ctx.cr[6].lt {
	pc = 0x825D44A0; continue 'dispatch;
	}
	// 825D4480: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D4484: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D4488: 41980008  blt cr6, 0x825d4490
	if ctx.cr[6].lt {
	pc = 0x825D4490; continue 'dispatch;
	}
	// 825D448C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825D4490: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 825D4494: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825D4498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D449C: 4BE99E2D  bl 0x8246e2c8
	ctx.lr = 0x825D44A0;
	sub_8246E2C8(ctx, base);
	// 825D44A0: 93D80000  stw r30, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D45E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D45E8 size=352
    let mut pc: u32 = 0x825D45E8;
    'dispatch: loop {
        match pc {
            0x825D45E8 => {
    //   block [0x825D45E8..0x825D4748)
	// 825D45E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D45EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D45F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D45F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D45F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D45FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D4600: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 825D4604: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4608: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D460C: C0071FF8  lfs f0, 0x1ff8(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D4610: 392AFFFF  addi r9, r10, -1
	ctx.r[9].s64 = ctx.r[10].s64 + -1;
	// 825D4614: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825D4618: 39090001  addi r8, r9, 1
	ctx.r[8].s64 = ctx.r[9].s64 + 1;
	// 825D461C: 2F080004  cmpwi cr6, r8, 4
	ctx.cr[6].compare_i32(ctx.r[8].s32, 4, &mut ctx.xer);
	// 825D4620: 4198009C  blt cr6, 0x825d46bc
	if ctx.cr[6].lt {
	pc = 0x825D46BC; continue 'dispatch;
	}
	// 825D4624: 5507F0BE  srwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shr(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825D4628: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 825D462C: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825D4630: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 825D4634: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 825D4638: 38C00030  li r6, 0x30
	ctx.r[6].s64 = 48;
	// 825D463C: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D4640: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825D4644: 409A0014  bne cr6, 0x825d4658
	if !ctx.cr[6].eq {
	pc = 0x825D4658; continue 'dispatch;
	}
	// 825D4648: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D4748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D4748 size=472
    let mut pc: u32 = 0x825D4748;
    'dispatch: loop {
        match pc {
            0x825D4748 => {
    //   block [0x825D4748..0x825D4920)
	// 825D4748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D474C: 4BF60971  bl 0x825350bc
	ctx.lr = 0x825D4750;
	sub_82535080(ctx, base);
	// 825D4750: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D4754: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D4920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D4920 size=940
    let mut pc: u32 = 0x825D4920;
    'dispatch: loop {
        match pc {
            0x825D4920 => {
    //   block [0x825D4920..0x825D4CCC)
	// 825D4920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D4924: 4BF60785  bl 0x825350a8
	ctx.lr = 0x825D4928;
	sub_82535080(ctx, base);
	// 825D4928: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 825D492C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D4930: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825D4934: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 825D4938: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825D493C: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 825D4940: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 825D4944: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4948: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D494C: 409A0010  bne cr6, 0x825d495c
	if !ctx.cr[6].eq {
	pc = 0x825D495C; continue 'dispatch;
	}
	// 825D4950: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4954: C3EA0004  lfs f31, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825D4958: 48000034  b 0x825d498c
	pc = 0x825D498C; continue 'dispatch;
	// 825D495C: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4960: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D4964: 409A0010  bne cr6, 0x825d4974
	if !ctx.cr[6].eq {
	pc = 0x825D4974; continue 'dispatch;
	}
	// 825D4968: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D496C: C3EA0004  lfs f31, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825D4970: 4800001C  b 0x825d498c
	pc = 0x825D498C; continue 'dispatch;
	// 825D4974: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4978: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D497C: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D4980: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D4984: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 825D4988: FFEC682E  fsel f31, f12, f0, f13
	ctx.f[31].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 825D498C: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4990: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825D4994: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D4998: 4099018C  ble cr6, 0x825d4b24
	if !ctx.cr[6].gt {
	pc = 0x825D4B24; continue 'dispatch;
	}
	// 825D499C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D49A0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D49A4: C1B80000  lfs f13, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D49A8: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D49AC: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D49B0: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 825D49B4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825D49B8: 4199016C  bgt cr6, 0x825d4b24
	if ctx.cr[6].gt {
	pc = 0x825D4B24; continue 'dispatch;
	}
	// 825D49BC: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D49C0: C1BA0010  lfs f13, 0x10(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D49C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D49C8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825D49CC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D49D0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825D49D4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825D49D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825D49DC: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 825D49E0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D49E4: A0CA0000  lhz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D49E8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825D49EC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825D49F0: 90C1005C  stw r6, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[6].u32 ) };
	// 825D49F4: 409900AC  ble cr6, 0x825d4aa0
	if !ctx.cr[6].gt {
	pc = 0x825D4AA0; continue 'dispatch;
	}
	// 825D49F8: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D49FC: A0EB0000  lhz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4A00: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 825D4A04: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4A08: A1290000  lhz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4A0C: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825D4A10: 409A0028  bne cr6, 0x825d4a38
	if !ctx.cr[6].eq {
	pc = 0x825D4A38; continue 'dispatch;
	}
	// 825D4A14: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4A18: A09E0000  lhz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4A1C: A1290000  lhz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4A20: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 825D4A24: 409A0014  bne cr6, 0x825d4a38
	if !ctx.cr[6].eq {
	pc = 0x825D4A38; continue 'dispatch;
	}
	// 825D4A28: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D4A2C: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825D4A30: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825D4A34: 419A0008  beq cr6, 0x825d4a3c
	if ctx.cr[6].eq {
	pc = 0x825D4A3C; continue 'dispatch;
	}
	// 825D4A38: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825D4A3C: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 825D4A40: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D4A44: 409A001C  bne cr6, 0x825d4a60
	if !ctx.cr[6].eq {
	pc = 0x825D4A60; continue 'dispatch;
	}
	// 825D4A48: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4A4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D4A50: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 825D4A54: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825D4A58: 4198FFAC  blt cr6, 0x825d4a04
	if ctx.cr[6].lt {
	pc = 0x825D4A04; continue 'dispatch;
	}
	// 825D4A5C: 48000044  b 0x825d4aa0
	pc = 0x825D4AA0; continue 'dispatch;
	// 825D4A60: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D4A64: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825D4A68: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D4A6C: 7D4B4214  add r10, r11, r8
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825D4A70: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D4A74: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825D4A78: 40980024  bge cr6, 0x825d4a9c
	if !ctx.cr[6].lt {
	pc = 0x825D4A9C; continue 'dispatch;
	}
	// 825D4A7C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825D4A80: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 825D4A84: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 825D4A88: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4A8C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D4A90: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D4A94: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825D4A98: 4200FFF0  bdnz 0x825d4a88
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825D4A88; continue 'dispatch;
	}
	// 825D4A9C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825D4AA0: 7CAB0774  extsb r11, r5
	ctx.r[11].s64 = ctx.r[5].s8 as i64;
	// 825D4AA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D4AA8: 409A0068  bne cr6, 0x825d4b10
	if !ctx.cr[6].eq {
	pc = 0x825D4B10; continue 'dispatch;
	}
	// 825D4AAC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D4AB0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4AB4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D4AB8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D4ABC: 409A0010  bne cr6, 0x825d4acc
	if !ctx.cr[6].eq {
	pc = 0x825D4ACC; continue 'dispatch;
	}
	// 825D4AC0: 38800014  li r4, 0x14
	ctx.r[4].s64 = 20;
	// 825D4AC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D4AC8: 4BE99889  bl 0x8246e350
	ctx.lr = 0x825D4ACC;
	sub_8246E350(ctx, base);
	// 825D4ACC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4AD0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825D4AD4: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4AD8: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 825D4ADC: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825D4AE0: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 825D4AE4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D4AE8: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825D4AEC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 825D4AF0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4AF4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825D4AF8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D4AFC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D4B00: 4200FFF0  bdnz 0x825d4af0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825D4AF0; continue 'dispatch;
	}
	// 825D4B04: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4B08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D4B0C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825D4B10: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4B14: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 825D4B18: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 825D4B1C: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D4B20: 4198FE80  blt cr6, 0x825d49a0
	if ctx.cr[6].lt {
	pc = 0x825D49A0; continue 'dispatch;
	}
	// 825D4B24: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4B28: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825D4B2C: 83DA0000  lwz r30, 0(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4B30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D4B34: 4099018C  ble cr6, 0x825d4cc0
	if !ctx.cr[6].gt {
	pc = 0x825D4CC0; continue 'dispatch;
	}
	// 825D4B38: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D4B3C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4B40: C1B80000  lfs f13, 0(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D4B44: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D4B48: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D4B4C: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 825D4B50: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825D4B54: 4199016C  bgt cr6, 0x825d4cc0
	if ctx.cr[6].gt {
	pc = 0x825D4CC0; continue 'dispatch;
	}
	// 825D4B58: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4B5C: C1BA0010  lfs f13, 0x10(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D4B60: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4B64: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825D4B68: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4B6C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825D4B70: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825D4B74: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D4B78: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 825D4B7C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D4B80: A0AA0000  lhz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4B84: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825D4B88: 90C10054  stw r6, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[6].u32 ) };
	// 825D4B8C: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 825D4B90: 409900AC  ble cr6, 0x825d4c3c
	if !ctx.cr[6].gt {
	pc = 0x825D4C3C; continue 'dispatch;
	}
	// 825D4B94: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4B98: A0FE0000  lhz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4B9C: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 825D4BA0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4BA4: A1290000  lhz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4BA8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825D4BAC: 409A0028  bne cr6, 0x825d4bd4
	if !ctx.cr[6].eq {
	pc = 0x825D4BD4; continue 'dispatch;
	}
	// 825D4BB0: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4BB4: A0660000  lhz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4BB8: A1290000  lhz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4BBC: 7F091840  cmplw cr6, r9, r3
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[3].u32, &mut ctx.xer);
	// 825D4BC0: 409A0014  bne cr6, 0x825d4bd4
	if !ctx.cr[6].eq {
	pc = 0x825D4BD4; continue 'dispatch;
	}
	// 825D4BC4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D4BC8: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 825D4BCC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825D4BD0: 419A0008  beq cr6, 0x825d4bd8
	if ctx.cr[6].eq {
	pc = 0x825D4BD8; continue 'dispatch;
	}
	// 825D4BD4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825D4BD8: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 825D4BDC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D4BE0: 409A001C  bne cr6, 0x825d4bfc
	if !ctx.cr[6].eq {
	pc = 0x825D4BFC; continue 'dispatch;
	}
	// 825D4BE4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4BE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D4BEC: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 825D4BF0: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825D4BF4: 4198FFAC  blt cr6, 0x825d4ba0
	if ctx.cr[6].lt {
	pc = 0x825D4BA0; continue 'dispatch;
	}
	// 825D4BF8: 48000044  b 0x825d4c3c
	pc = 0x825D4C3C; continue 'dispatch;
	// 825D4BFC: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D4C00: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825D4C04: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D4C08: 7D4B4214  add r10, r11, r8
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825D4C0C: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D4C10: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825D4C14: 40980024  bge cr6, 0x825d4c38
	if !ctx.cr[6].lt {
	pc = 0x825D4C38; continue 'dispatch;
	}
	// 825D4C18: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825D4C1C: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 825D4C20: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 825D4C24: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4C28: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D4C2C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D4C30: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825D4C34: 4200FFF0  bdnz 0x825d4c24
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825D4C24; continue 'dispatch;
	}
	// 825D4C38: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D4C3C: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 825D4C40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D4C44: 409A0068  bne cr6, 0x825d4cac
	if !ctx.cr[6].eq {
	pc = 0x825D4CAC; continue 'dispatch;
	}
	// 825D4C48: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D4C4C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4C50: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D4C54: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D4C58: 409A0010  bne cr6, 0x825d4c68
	if !ctx.cr[6].eq {
	pc = 0x825D4C68; continue 'dispatch;
	}
	// 825D4C5C: 38800014  li r4, 0x14
	ctx.r[4].s64 = 20;
	// 825D4C60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D4C64: 4BE996ED  bl 0x8246e350
	ctx.lr = 0x825D4C68;
	sub_8246E350(ctx, base);
	// 825D4C68: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4C6C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825D4C70: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4C74: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 825D4C78: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825D4C7C: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 825D4C80: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D4C84: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825D4C88: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 825D4C8C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4C90: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825D4C94: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D4C98: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D4C9C: 4200FFF0  bdnz 0x825d4c8c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825D4C8C; continue 'dispatch;
	}
	// 825D4CA0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4CA4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D4CA8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825D4CAC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4CB0: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 825D4CB4: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 825D4CB8: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D4CBC: 4198FE80  blt cr6, 0x825d4b3c
	if ctx.cr[6].lt {
	pc = 0x825D4B3C; continue 'dispatch;
	}
	// 825D4CC0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825D4CC4: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 825D4CC8: 4BF60430  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D4CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D4CD0 size=1956
    let mut pc: u32 = 0x825D4CD0;
    'dispatch: loop {
        match pc {
            0x825D4CD0 => {
    //   block [0x825D4CD0..0x825D5474)
	// 825D4CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D4CD4: 4BF603AD  bl 0x82535080
	ctx.lr = 0x825D4CD8;
	sub_82535080(ctx, base);
	// 825D4CD8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825D4CDC: 4BF612F5  bl 0x82535fd0
	ctx.lr = 0x825D4CE0;
	sub_82535FB0(ctx, base);
	// 825D4CE0: 3980FEE0  li r12, -0x120
	ctx.r[12].s64 = -288;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D5478 size=744
    let mut pc: u32 = 0x825D5478;
    'dispatch: loop {
        match pc {
            0x825D5478 => {
    //   block [0x825D5478..0x825D5760)
	// 825D5478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D547C: 4BF5FC31  bl 0x825350ac
	ctx.lr = 0x825D5480;
	sub_82535080(ctx, base);
	// 825D5480: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D5484: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D5488: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D548C: 3B630004  addi r27, r3, 4
	ctx.r[27].s64 = ctx.r[3].s64 + 4;
	// 825D5490: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D5494: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825D5498: C1AA1FF8  lfs f13, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D549C: 40990028  ble cr6, 0x825d54c4
	if !ctx.cr[6].gt {
	pc = 0x825D54C4; continue 'dispatch;
	}
	// 825D54A0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825D54A4: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D54A8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D54AC: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825D54B0: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825D54B4: D1A9000C  stfs f13, 0xc(r9)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825D54B8: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D54BC: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825D54C0: 4198FFE4  blt cr6, 0x825d54a4
	if ctx.cr[6].lt {
	pc = 0x825D54A4; continue 'dispatch;
	}
	// 825D54C4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D54C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D54CC: 40990288  ble cr6, 0x825d5754
	if !ctx.cr[6].gt {
	pc = 0x825D5754; continue 'dispatch;
	}
	// 825D54D0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825D54D4: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 825D54D8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825D54DC: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 825D54E0: 3BCAFA60  addi r30, r10, -0x5a0
	ctx.r[30].s64 = ctx.r[10].s64 + -1440;
	// 825D54E4: C0091850  lfs f0, 0x1850(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D54E8: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 825D54EC: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D54F0: 4098024C  bge cr6, 0x825d573c
	if !ctx.cr[6].lt {
	pc = 0x825D573C; continue 'dispatch;
	}
	// 825D54F4: 389C0010  addi r4, r28, 0x10
	ctx.r[4].s64 = ctx.r[28].s64 + 16;
	// 825D54F8: 3BB90001  addi r29, r25, 1
	ctx.r[29].s64 = ctx.r[25].s64 + 1;
	// 825D54FC: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 825D5500: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D5504: 40980220  bge cr6, 0x825d5724
	if !ctx.cr[6].lt {
	pc = 0x825D5724; continue 'dispatch;
	}
	// 825D5508: 38C40010  addi r6, r4, 0x10
	ctx.r[6].s64 = ctx.r[4].s64 + 16;
	// 825D550C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5510: 7D3C5A14  add r9, r28, r11
	ctx.r[9].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 825D5514: 38A9000C  addi r5, r9, 0xc
	ctx.r[5].s64 = ctx.r[9].s64 + 12;
	// 825D5518: C189000C  lfs f12, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D551C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 825D5520: 419A01F0  beq cr6, 0x825d5710
	if ctx.cr[6].eq {
	pc = 0x825D5710; continue 'dispatch;
	}
	// 825D5524: 7D445A14  add r10, r4, r11
	ctx.r[10].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 825D5528: 38EA000C  addi r7, r10, 0xc
	ctx.r[7].s64 = ctx.r[10].s64 + 12;
	// 825D552C: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D5530: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 825D5534: 419A01DC  beq cr6, 0x825d5710
	if ctx.cr[6].eq {
	pc = 0x825D5710; continue 'dispatch;
	}
	// 825D5538: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 825D553C: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 825D5540: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D5544: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 825D5548: 419A01C8  beq cr6, 0x825d5710
	if ctx.cr[6].eq {
	pc = 0x825D5710; continue 'dispatch;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D5760 size=2916
    let mut pc: u32 = 0x825D5760;
    'dispatch: loop {
        match pc {
            0x825D5760 => {
    //   block [0x825D5760..0x825D62C4)
	// 825D5760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D5764: 4BF5F91D  bl 0x82535080
	ctx.lr = 0x825D5768;
	sub_82535080(ctx, base);
	// 825D5768: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 825D576C: 3981FF60  addi r12, r1, -0xa0
	ctx.r[12].s64 = ctx.r[1].s64 + -160;
	// 825D5770: 4BF63C35  bl 0x825393a4
	ctx.lr = 0x825D5774;
	sub_82539130(ctx, base);
	// 825D5774: 9421FDD0  stwu r1, -0x230(r1)
	ea = ctx.r[1].u32.wrapping_add(-560 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D5778: 7CB32B78  mr r19, r5
	ctx.r[19].u64 = ctx.r[5].u64;
	// 825D577C: 90610244  stw r3, 0x244(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(580 as u32), ctx.r[3].u32 ) };
	// 825D5780: 7CCF3378  mr r15, r6
	ctx.r[15].u64 = ctx.r[6].u64;
	// 825D5784: 9081024C  stw r4, 0x24c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(588 as u32), ctx.r[4].u32 ) };
	// 825D5788: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 825D578C: 3A330008  addi r17, r19, 8
	ctx.r[17].s64 = ctx.r[19].s64 + 8;
	// 825D5790: 7D124378  mr r18, r8
	ctx.r[18].u64 = ctx.r[8].u64;
	// 825D5794: 81730008  lwz r11, 8(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D5798: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 825D579C: 83530004  lwz r26, 4(r19)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D57A0: 7D4E5378  mr r14, r10
	ctx.r[14].u64 = ctx.r[10].u64;
	// 825D57A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D57A8: 82F30000  lwz r23, 0(r19)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D57AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D57B0: 92610254  stw r19, 0x254(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(596 as u32), ctx.r[19].u32 ) };
	// 825D57B4: 91E1025C  stw r15, 0x25c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(604 as u32), ctx.r[15].u32 ) };
	// 825D57B8: 3A930004  addi r20, r19, 4
	ctx.r[20].s64 = ctx.r[19].s64 + 4;
	// 825D57BC: 93210264  stw r25, 0x264(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(612 as u32), ctx.r[25].u32 ) };
	// 825D57C0: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 825D57C4: 92210050  stw r17, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[17].u32 ) };
	// 825D57C8: C3EB1850  lfs f31, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825D57CC: 409902E0  ble cr6, 0x825d5aac
	if !ctx.cr[6].gt {
	pc = 0x825D5AAC; continue 'dispatch;
	}
	// 825D57D0: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 825D57D4: 81740000  lwz r11, 0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D57D8: 7D76582A  ldx r11, r22, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[11].u32)) };
	// 825D57DC: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 825D57E0: A1610094  lhz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825D57E4: 557F183E  rotlwi r31, r11, 3
	ctx.r[31].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D57E8: 7F155800  cmpw cr6, r21, r11
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D57EC: 7D5FD214  add r10, r31, r26
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[26].u64;
	// 825D57F0: A3CA0004  lhz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D57F4: 40980298  bge cr6, 0x825d5a8c
	if !ctx.cr[6].lt {
	pc = 0x825D5A8C; continue 'dispatch;
	}
	// 825D57F8: 7F15F000  cmpw cr6, r21, r30
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[30].s32, &mut ctx.xer);
	// 825D57FC: 40980290  bge cr6, 0x825d5a8c
	if !ctx.cr[6].lt {
	pc = 0x825D5A8C; continue 'dispatch;
	}
	// 825D5800: 83980004  lwz r28, 4(r24)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D5804: 3B780004  addi r27, r24, 4
	ctx.r[27].s64 = ctx.r[24].s64 + 4;
	// 825D5808: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D580C: 3B380008  addi r25, r24, 8
	ctx.r[25].s64 = ctx.r[24].s64 + 8;
	// 825D5810: 3BBC0001  addi r29, r28, 1
	ctx.r[29].s64 = ctx.r[28].s64 + 1;
	// 825D5814: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D5818: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 825D581C: 40980024  bge cr6, 0x825d5840
	if !ctx.cr[6].lt {
	pc = 0x825D5840; continue 'dispatch;
	}
	// 825D5820: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D5824: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D5828: 41980008  blt cr6, 0x825d5830
	if ctx.cr[6].lt {
	pc = 0x825D5830; continue 'dispatch;
	}
	// 825D582C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825D5830: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 825D5834: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825D5838: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825D583C: 4BE98A8D  bl 0x8246e2c8
	ctx.lr = 0x825D5840;
	sub_8246E2C8(ctx, base);
	// 825D5840: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D5844: 80D80000  lwz r6, 0(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5848: 57872036  slwi r7, r28, 4
	ctx.r[7].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825D584C: 93BB0000  stw r29, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825D5850: 7FCBD214  add r30, r11, r26
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 825D5854: A1610090  lhz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 825D5858: 7C9FD22E  lhzx r4, r31, r26
	ctx.r[4].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 825D585C: 7F9FD214  add r28, r31, r26
	ctx.r[28].u64 = ctx.r[31].u64 + ctx.r[26].u64;
	// 825D5860: 7FE73214  add r31, r7, r6
	ctx.r[31].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 825D5864: 5565203E  rotlwi r5, r11, 4
	ctx.r[5].u64 = ((ctx.r[11].u32).rotate_left(4)) as u64;
	// 825D5868: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D586C: 5486203E  rotlwi r6, r4, 4
	ctx.r[6].u64 = ((ctx.r[4].u32).rotate_left(4)) as u64;
	// 825D5870: A0FE0000  lhz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5874: 7CA55A14  add r5, r5, r11
	ctx.r[5].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 825D5878: 7CC65A14  add r6, r6, r11
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 825D587C: 54E7203E  rotlwi r7, r7, 4
	ctx.r[7].u64 = ((ctx.r[7].u32).rotate_left(4)) as u64;
	// 825D5880: 39210110  addi r9, r1, 0x110
	ctx.r[9].s64 = ctx.r[1].s64 + 272;
	// 825D5884: 7C875A14  add r4, r7, r11
	ctx.r[4].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 825D5888: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 825D588C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 825D5890: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825D5894: 39410120  addi r10, r1, 0x120
	ctx.r[10].s64 = ctx.r[1].s64 + 288;
	// 825D5898: 39010140  addi r8, r1, 0x140
	ctx.r[8].s64 = ctx.r[1].s64 + 320;
	// 825D589C: E8870000  ld r4, 0(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 825D58A0: E8AB0000  ld r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 825D58A4: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 825D58A8: E8E70008  ld r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 825D58AC: E8660000  ld r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	// 825D58B0: F8890000  std r4, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[4].u64 ) };
	// 825D58B4: F8AA0000  std r5, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 825D58B8: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 825D58BC: 39610120  addi r11, r1, 0x120
	ctx.r[11].s64 = ctx.r[1].s64 + 288;
	// 825D58C0: F8E90008  std r7, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 825D58C4: 39210110  addi r9, r1, 0x110
	ctx.r[9].s64 = ctx.r[1].s64 + 272;
	// 825D58C8: E8C60008  ld r6, 8(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	// 825D58CC: F8680000  std r3, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[3].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D62C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D62C8 size=556
    let mut pc: u32 = 0x825D62C8;
    'dispatch: loop {
        match pc {
            0x825D62C8 => {
    //   block [0x825D62C8..0x825D64F4)
	// 825D62C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D62CC: 4BF5EDE1  bl 0x825350ac
	ctx.lr = 0x825D62D0;
	sub_82535080(ctx, base);
	// 825D62D0: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 825D62D4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D62D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D62DC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825D62E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D62E4: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D62E8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D62EC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825D62F0: C3EA2068  lfs f31, 0x2068(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8296 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825D62F4: 40990034  ble cr6, 0x825d6328
	if !ctx.cr[6].gt {
	pc = 0x825D6328; continue 'dispatch;
	}
	// 825D62F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825D62FC: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6300: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D6304: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6308: 7D2A4A2E  lhzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 825D630C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825D6310: 5529203E  rotlwi r9, r9, 4
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(4)) as u64;
	// 825D6314: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825D6318: D3E9000C  stfs f31, 0xc(r9)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825D631C: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D6320: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825D6324: 4198FFD8  blt cr6, 0x825d62fc
	if ctx.cr[6].lt {
	pc = 0x825D62FC; continue 'dispatch;
	}
	// 825D6328: 832D0000  lwz r25, 0(r13)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D632C: 3B400010  li r26, 0x10
	ctx.r[26].s64 = 16;
	// 825D6330: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6334: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825D6338: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 825D633C: 55641036  rlwinm r4, r11, 2, 0, 0x1b
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D6340: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 825D6344: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 825D6348: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 825D634C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825D6350: 41990010  bgt cr6, 0x825d6360
	if ctx.cr[6].gt {
	pc = 0x825D6360; continue 'dispatch;
	}
	// 825D6354: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 825D6358: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 825D635C: 48000018  b 0x825d6374
	pc = 0x825D6374; continue 'dispatch;
	// 825D6360: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6364: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825D6368: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D636C: 4E800421  bctrl
	ctx.lr = 0x825D6370;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D6370: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825D6374: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6378: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D637C: 67DE8000  oris r30, r30, 0x8000
	ctx.r[30].u64 = ctx.r[30].u64 | 2147483648;
	// 825D6380: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D6384: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D6388: 4099005C  ble cr6, 0x825d63e4
	if !ctx.cr[6].gt {
	pc = 0x825D63E4; continue 'dispatch;
	}
	// 825D638C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825D6390: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825D6394: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 825D6398: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825D639C: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D63A0: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825D63A4: C009000C  lfs f0, 0xc(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D63A8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825D63AC: 409A001C  bne cr6, 0x825d63c8
	if !ctx.cr[6].eq {
	pc = 0x825D63C8; continue 'dispatch;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D64F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D64F8 size=384
    let mut pc: u32 = 0x825D64F8;
    'dispatch: loop {
        match pc {
            0x825D64F8 => {
    //   block [0x825D64F8..0x825D6678)
	// 825D64F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D64FC: 4BF5EBA5  bl 0x825350a0
	ctx.lr = 0x825D6500;
	sub_82535080(ctx, base);
	// 825D6500: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D6504: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825D6508: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825D650C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825D6510: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D6514: 83F90008  lwz r31, 8(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D6518: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D651C: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 825D6520: 40980024  bge cr6, 0x825d6544
	if !ctx.cr[6].lt {
	pc = 0x825D6544; continue 'dispatch;
	}
	// 825D6524: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D6528: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D652C: 41980008  blt cr6, 0x825d6534
	if ctx.cr[6].lt {
	pc = 0x825D6534; continue 'dispatch;
	}
	// 825D6530: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 825D6534: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 825D6538: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825D653C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D6540: 4BE97D89  bl 0x8246e2c8
	ctx.lr = 0x825D6544;
	sub_8246E2C8(ctx, base);
	// 825D6544: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825D6548: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 825D654C: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D6550: 82DB0008  lwz r22, 8(r27)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D6554: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D6558: 409900C0  ble cr6, 0x825d6618
	if !ctx.cr[6].gt {
	pc = 0x825D6618; continue 'dispatch;
	}
	// 825D655C: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 825D6560: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825D6564: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 825D6568: 6177FFFF  ori r23, r11, 0xffff
	ctx.r[23].u64 = ctx.r[11].u64 | 65535;
	// 825D656C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6570: 7FDA5A14  add r30, r26, r11
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 825D6574: A17E0006  lhz r11, 6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 825D6578: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825D657C: 419A0018  beq cr6, 0x825d6594
	if ctx.cr[6].eq {
	pc = 0x825D6594; continue 'dispatch;
	}
	// 825D6580: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 825D6584: 419A0010  beq cr6, 0x825d6594
	if ctx.cr[6].eq {
	pc = 0x825D6594; continue 'dispatch;
	}
	// 825D6588: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D658C: 7EFC5B2E  sthx r23, r28, r11
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32), ctx.r[23].u16) };
	// 825D6590: 48000070  b 0x825d6600
	pc = 0x825D6600; continue 'dispatch;
	// 825D6594: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D6598: 3BFB0004  addi r31, r27, 4
	ctx.r[31].s64 = ctx.r[27].s64 + 4;
	// 825D659C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D65A0: 7D7C532E  sthx r11, r28, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u16) };
	// 825D65A4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D65A8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D65AC: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D65B0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D65B4: 409A0010  bne cr6, 0x825d65c4
	if !ctx.cr[6].eq {
	pc = 0x825D65C4; continue 'dispatch;
	}
	// 825D65B8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825D65BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D65C0: 4BE97D91  bl 0x8246e350
	ctx.lr = 0x825D65C4;
	sub_8246E350(ctx, base);
	// 825D65C4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D65C8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D65CC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D65D0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825D65D4: A15E0000  lhz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D65D8: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 825D65DC: A15E0002  lhz r10, 2(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D65E0: B14B0002  sth r10, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[10].u16 ) };
	// 825D65E4: A15E0004  lhz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D65E8: B14B0004  sth r10, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 825D65EC: A15E0006  lhz r10, 6(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 825D65F0: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 825D65F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D65F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D65FC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825D6600: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D6604: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 825D6608: 3B5A0008  addi r26, r26, 8
	ctx.r[26].s64 = ctx.r[26].s64 + 8;
	// 825D660C: 3B9C0002  addi r28, r28, 2
	ctx.r[28].s64 = ctx.r[28].s64 + 2;
	// 825D6610: 7F185800  cmpw cr6, r24, r11
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D6614: 4198FF58  blt cr6, 0x825d656c
	if ctx.cr[6].lt {
	pc = 0x825D656C; continue 'dispatch;
	}
	// 825D6618: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D661C: 7EC9B378  mr r9, r22
	ctx.r[9].u64 = ctx.r[22].u64;
	// 825D6620: 7F165800  cmpw cr6, r22, r11
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D6624: 4098004C  bge cr6, 0x825d6670
	if !ctx.cr[6].lt {
	pc = 0x825D6670; continue 'dispatch;
	}
	// 825D6628: 56CA1838  slwi r10, r22, 3
	ctx.r[10].u32 = ctx.r[22].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D662C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6630: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825D6634: 811D0000  lwz r8, 0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6638: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825D663C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825D6640: A0EB0002  lhz r7, 2(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D6644: A0CB0004  lhz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6648: 54E7083E  rotlwi r7, r7, 1
	ctx.r[7].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 825D664C: 54C6083E  rotlwi r6, r6, 1
	ctx.r[6].u64 = ((ctx.r[6].u32).rotate_left(1)) as u64;
	// 825D6650: 7D07422E  lhzx r8, r7, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 825D6654: B10B0002  sth r8, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[8].u16 ) };
	// 825D6658: 811D0000  lwz r8, 0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D665C: 7D06422E  lhzx r8, r6, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 825D6660: B10B0004  sth r8, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u16 ) };
	// 825D6664: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D6668: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D666C: 4198FFC0  blt cr6, 0x825d662c
	if ctx.cr[6].lt {
	pc = 0x825D662C; continue 'dispatch;
	}
	// 825D6670: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825D6674: 4BF5EA7C  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D6678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D6678 size=432
    let mut pc: u32 = 0x825D6678;
    'dispatch: loop {
        match pc {
            0x825D6678 => {
    //   block [0x825D6678..0x825D6828)
	// 825D6678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D667C: 4BF5EA25  bl 0x825350a0
	ctx.lr = 0x825D6680;
	sub_82535080(ctx, base);
	// 825D6680: DBC1FF98  stfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 825D6684: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 825D6688: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D668C: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 825D6690: 82C40000  lwz r22, 0(r4)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6694: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825D6698: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825D669C: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 825D66A0: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 825D66A4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D66A8: 7D174378  mr r23, r8
	ctx.r[23].u64 = ctx.r[8].u64;
	// 825D66AC: C3DB000C  lfs f30, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825D66B0: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 825D66B4: 40990164  ble cr6, 0x825d6818
	if !ctx.cr[6].gt {
	pc = 0x825D6818; continue 'dispatch;
	}
	// 825D66B8: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D66BC: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D66C0: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D66C4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825D66C8: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 825D66CC: 4098014C  bge cr6, 0x825d6818
	if !ctx.cr[6].lt {
	pc = 0x825D6818; continue 'dispatch;
	}
	// 825D66D0: 3961005C  addi r11, r1, 0x5c
	ctx.r[11].s64 = ctx.r[1].s64 + 92;
	// 825D66D4: 3D008000  lis r8, -0x8000
	ctx.r[8].s64 = -2147483648;
	// 825D66D8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D66DC: 61080040  ori r8, r8, 0x40
	ctx.r[8].u64 = ctx.r[8].u64 | 64;
	// 825D66E0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D66E4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825D66E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D66EC: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 825D66F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D66F4: C3E90004  lfs f31, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825D66F8: 4099007C  ble cr6, 0x825d6774
	if !ctx.cr[6].gt {
	pc = 0x825D6774; continue 'dispatch;
	}
	// 825D66FC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825D6700: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6704: 7FDC5214  add r30, r28, r10
	ctx.r[30].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 825D6708: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D670C: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 825D6710: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 825D6714: 41990060  bgt cr6, 0x825d6774
	if ctx.cr[6].gt {
	pc = 0x825D6774; continue 'dispatch;
	}
	// 825D6718: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825D671C: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 825D6720: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825D6724: 409A0014  bne cr6, 0x825d6738
	if !ctx.cr[6].eq {
	pc = 0x825D6738; continue 'dispatch;
	}
	// 825D6728: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825D672C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D6730: 4BE97C21  bl 0x8246e350
	ctx.lr = 0x825D6734;
	sub_8246E350(ctx, base);
	// 825D6734: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D6738: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D673C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D6740: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6744: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825D6748: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825D674C: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 825D6750: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D6754: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6758: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D675C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D6760: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6764: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D6768: 7F1D5000  cmpw cr6, r29, r10
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825D676C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D6770: 4198FF90  blt cr6, 0x825d6700
	if ctx.cr[6].lt {
	pc = 0x825D6700; continue 'dispatch;
	}
	// 825D6774: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825D6778: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825D677C: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 825D6780: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 825D6784: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 825D6788: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 825D678C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825D6790: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 825D6794: 4BFFDFB5  bl 0x825d4748
	ctx.lr = 0x825D6798;
	sub_825D4748(ctx, base);
	// 825D6798: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D679C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D67A0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D67A4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D67A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D67AC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825D67B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D67B4: D3EB0004  stfs f31, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825D67B8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D67BC: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D67C0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825D67C4: 40980020  bge cr6, 0x825d67e4
	if !ctx.cr[6].lt {
	pc = 0x825D67E4; continue 'dispatch;
	}
	// 825D67C8: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 825D67CC: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 825D67D0: 41990008  bgt cr6, 0x825d67d8
	if ctx.cr[6].gt {
	pc = 0x825D67D8; continue 'dispatch;
	}
	// 825D67D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D67D8: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825D67DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D67E0: 4BE97AE9  bl 0x8246e2c8
	ctx.lr = 0x825D67E4;
	sub_8246E2C8(ctx, base);
	// 825D67E4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825D67E8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825D67EC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D67F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D67F4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D67F8: 409A0020  bne cr6, 0x825d6818
	if !ctx.cr[6].eq {
	pc = 0x825D6818; continue 'dispatch;
	}
	// 825D67FC: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6800: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825D6804: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825D6808: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D680C: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825D6810: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825D6814: 4BE8D8A5  bl 0x824640b8
	ctx.lr = 0x825D6818;
	sub_824640B8(ctx, base);
	// 825D6818: 382102D0  addi r1, r1, 0x2d0
	ctx.r[1].s64 = ctx.r[1].s64 + 720;
	// 825D681C: CBC1FF98  lfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 825D6820: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 825D6824: 4BF5E8CC  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D6828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D6828 size=320
    let mut pc: u32 = 0x825D6828;
    'dispatch: loop {
        match pc {
            0x825D6828 => {
    //   block [0x825D6828..0x825D6968)
	// 825D6828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D682C: 4BF5E88D  bl 0x825350b8
	ctx.lr = 0x825D6830;
	sub_82535080(ctx, base);
	// 825D6830: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D6834: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 825D6838: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825D683C: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 825D6840: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6844: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 825D6848: 409A0118  bne cr6, 0x825d6960
	if !ctx.cr[6].eq {
	pc = 0x825D6960; continue 'dispatch;
	}
	// 825D684C: 838100F4  lwz r28, 0xf4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 825D6850: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6854: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 825D6858: 409A0108  bne cr6, 0x825d6960
	if !ctx.cr[6].eq {
	pc = 0x825D6960; continue 'dispatch;
	}
	// 825D685C: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D6860: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6864: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825D6868: 419A0024  beq cr6, 0x825d688c
	if ctx.cr[6].eq {
	pc = 0x825D688C; continue 'dispatch;
	}
	// 825D686C: 54CA043E  clrlwi r10, r6, 0x10
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x0000FFFFu64;
	// 825D6870: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 825D6874: 419A0018  beq cr6, 0x825d688c
	if ctx.cr[6].eq {
	pc = 0x825D688C; continue 'dispatch;
	}
	// 825D6878: 80C40004  lwz r6, 4(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D687C: A0C60000  lhz r6, 0(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6880: 7F065040  cmplw cr6, r6, r10
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825D6884: 409A0008  bne cr6, 0x825d688c
	if !ctx.cr[6].eq {
	pc = 0x825D688C; continue 'dispatch;
	}
	// 825D6888: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D688C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6890: C003000C  lfs f0, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D6894: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6898: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D689C: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D68A0: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 825D68A4: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 825D68A8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825D68AC: 409800B4  bge cr6, 0x825d6960
	if !ctx.cr[6].lt {
	pc = 0x825D6960; continue 'dispatch;
	}
	// 825D68B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825D68B4: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 825D68B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D68BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D68C0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825D68C4: 3941005C  addi r10, r1, 0x5c
	ctx.r[10].s64 = ctx.r[1].s64 + 92;
	// 825D68C8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D68CC: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 825D68D0: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 825D68D4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825D68D8: C02B0004  lfs f1, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D68DC: E8BE0000  ld r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825D68E0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825D68E4: F8A1005C  std r5, 0x5c(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u64 ) };
	// 825D68E8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825D68EC: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 825D68F0: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 825D68F4: F9610064  std r11, 0x64(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u64 ) };
	// 825D68F8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 825D68FC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D6900: 4BFFDE49  bl 0x825d4748
	ctx.lr = 0x825D6904;
	sub_825D4748(ctx, base);
	// 825D6904: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6908: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D690C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6910: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6914: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825D6918: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825D691C: C00ABFFC  lfs f0, -0x4004(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D6920: 419A0008  beq cr6, 0x825d6928
	if ctx.cr[6].eq {
	pc = 0x825D6928; continue 'dispatch;
	}
	// 825D6924: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6928: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D692C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825D6930: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825D6934: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825D6938: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825D693C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D6940: 409A0020  bne cr6, 0x825d6960
	if !ctx.cr[6].eq {
	pc = 0x825D6960; continue 'dispatch;
	}
	// 825D6944: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6948: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825D694C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825D6950: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D6954: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825D6958: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825D695C: 4BE8D75D  bl 0x824640b8
	ctx.lr = 0x825D6960;
	sub_824640B8(ctx, base);
	// 825D6960: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825D6964: 4BF5E7A4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D6968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D6968 size=356
    let mut pc: u32 = 0x825D6968;
    'dispatch: loop {
        match pc {
            0x825D6968 => {
    //   block [0x825D6968..0x825D6ACC)
	// 825D6968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D696C: 4BF5E745  bl 0x825350b0
	ctx.lr = 0x825D6970;
	sub_82535080(ctx, base);
	// 825D6970: 9421FD60  stwu r1, -0x2a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-672 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D6974: 3961005C  addi r11, r1, 0x5c
	ctx.r[11].s64 = ctx.r[1].s64 + 92;
	// 825D6978: 83A40004  lwz r29, 4(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D697C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D6980: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 825D6984: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825D6988: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825D698C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825D6990: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 825D6994: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825D6998: 616B0080  ori r11, r11, 0x80
	ctx.r[11].u64 = ctx.r[11].u64 | 128;
	// 825D699C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D69A0: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D69A4: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D69A8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825D69AC: 838BFFFC  lwz r28, -4(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 825D69B0: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 825D69B4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D69B8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 825D69BC: A16B0004  lhz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D69C0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D69C4: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825D69C8: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 825D69CC: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 825D69D0: 419A0014  beq cr6, 0x825d69e4
	if ctx.cr[6].eq {
	pc = 0x825D69E4; continue 'dispatch;
	}
	// 825D69D4: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 825D69D8: 419A00D4  beq cr6, 0x825d6aac
	if ctx.cr[6].eq {
	pc = 0x825D6AAC; continue 'dispatch;
	}
	// 825D69DC: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 825D69E0: 409A000C  bne cr6, 0x825d69ec
	if !ctx.cr[6].eq {
	pc = 0x825D69EC; continue 'dispatch;
	}
	// 825D69E4: 7F0AD800  cmpw cr6, r10, r27
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[27].s32, &mut ctx.xer);
	// 825D69E8: 409A00D0  bne cr6, 0x825d6ab8
	if !ctx.cr[6].eq {
	pc = 0x825D6AB8; continue 'dispatch;
	}
	// 825D69EC: B36B0006  sth r27, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[27].u16 ) };
	// 825D69F0: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825D69F4: 409AFFC8  bne cr6, 0x825d69bc
	if !ctx.cr[6].eq {
	pc = 0x825D69BC; continue 'dispatch;
	}
	// 825D69F8: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D69FC: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 825D6A00: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6A04: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D6A08: 7FEBEA14  add r31, r11, r29
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825D6A0C: A17F0002  lhz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D6A10: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D6A14: 7FCBEA14  add r30, r11, r29
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825D6A18: A17E0006  lhz r11, 6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 825D6A1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D6A20: 409A003C  bne cr6, 0x825d6a5c
	if !ctx.cr[6].eq {
	pc = 0x825D6A5C; continue 'dispatch;
	}
	// 825D6A24: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825D6A28: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D6A2C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D6A30: 409A0014  bne cr6, 0x825d6a44
	if !ctx.cr[6].eq {
	pc = 0x825D6A44; continue 'dispatch;
	}
	// 825D6A34: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 825D6A38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D6A3C: 4BE97915  bl 0x8246e350
	ctx.lr = 0x825D6A40;
	sub_8246E350(ctx, base);
	// 825D6A40: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D6A44: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D6A48: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D6A4C: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 825D6A50: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D6A54: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 825D6A58: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825D6A5C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825D6A60: 409AFFA0  bne cr6, 0x825d6a00
	if !ctx.cr[6].eq {
	pc = 0x825D6A00; continue 'dispatch;
	}
	// 825D6A64: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D6A68: 409AFF38  bne cr6, 0x825d69a0
	if !ctx.cr[6].eq {
	pc = 0x825D69A0; continue 'dispatch;
	}
	// 825D6A6C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825D6A70: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825D6A74: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D6A78: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D6A7C: 995A0000  stb r10, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825D6A80: 409A0020  bne cr6, 0x825d6aa0
	if !ctx.cr[6].eq {
	pc = 0x825D6AA0; continue 'dispatch;
	}
	// 825D6A84: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6A88: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825D6A8C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825D6A90: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D6A94: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825D6A98: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825D6A9C: 4BE8D61D  bl 0x824640b8
	ctx.lr = 0x825D6AA0;
	sub_824640B8(ctx, base);
	// 825D6AA0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D6AA4: 382102A0  addi r1, r1, 0x2a0
	ctx.r[1].s64 = ctx.r[1].s64 + 672;
	// 825D6AA8: 4BF5E658  b 0x82535100
	sub_825350D0(ctx, base);
	return;
	// 825D6AAC: 2F1B0003  cmpwi cr6, r27, 3
	ctx.cr[6].compare_i32(ctx.r[27].s32, 3, &mut ctx.xer);
	// 825D6AB0: 419AFF40  beq cr6, 0x825d69f0
	if ctx.cr[6].eq {
	pc = 0x825D69F0; continue 'dispatch;
	}
	// 825D6AB4: 4BFFFF38  b 0x825d69ec
	pc = 0x825D69EC; continue 'dispatch;
	// 825D6AB8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825D6ABC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825D6AC0: 55690000  rlwinm r9, r11, 0, 0, 0
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825D6AC4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D6AC8: 4BFFFFB4  b 0x825d6a7c
	pc = 0x825D6A7C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D6AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D6AD0 size=1208
    let mut pc: u32 = 0x825D6AD0;
    'dispatch: loop {
        match pc {
            0x825D6AD0 => {
    //   block [0x825D6AD0..0x825D6F88)
	// 825D6AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D6AD4: 4BF5E5C9  bl 0x8253509c
	ctx.lr = 0x825D6AD8;
	sub_82535080(ctx, base);
	// 825D6AD8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D6ADC: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 825D6AE0: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 825D6AE4: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 825D6AE8: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 825D6AEC: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 825D6AF0: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D6AF4: 82F90004  lwz r23, 4(r25)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6AF8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D6AFC: 40990028  ble cr6, 0x825d6b24
	if !ctx.cr[6].gt {
	pc = 0x825D6B24; continue 'dispatch;
	}
	// 825D6B00: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	// 825D6B04: 81390004  lwz r9, 4(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6B08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D6B0C: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825D6B10: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825D6B14: B2C90006  sth r22, 6(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(6 as u32), ctx.r[22].u16 ) };
	// 825D6B18: 81390008  lwz r9, 8(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D6B1C: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825D6B20: 4198FFE4  blt cr6, 0x825d6b04
	if ctx.cr[6].lt {
	pc = 0x825D6B04; continue 'dispatch;
	}
	// 825D6B24: 7CDA0774  extsb r26, r6
	ctx.r[26].s64 = ctx.r[6].s8 as i64;
	// 825D6B28: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6B2C: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 825D6B30: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825D6B34: 419A000C  beq cr6, 0x825d6b40
	if ctx.cr[6].eq {
	pc = 0x825D6B40; continue 'dispatch;
	}
	// 825D6B38: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6B3C: 48000008  b 0x825d6b44
	pc = 0x825D6B44; continue 'dispatch;
	// 825D6B40: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6B44: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6B48: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 825D6B4C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D6B50: 41980074  blt cr6, 0x825d6bc4
	if ctx.cr[6].lt {
	pc = 0x825D6BC4; continue 'dispatch;
	}
	// 825D6B54: 552A2036  slwi r10, r9, 4
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D6B58: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 825D6B5C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6B60: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825D6B64: 419A000C  beq cr6, 0x825d6b70
	if ctx.cr[6].eq {
	pc = 0x825D6B70; continue 'dispatch;
	}
	// 825D6B68: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825D6B6C: 4800000C  b 0x825d6b78
	pc = 0x825D6B78; continue 'dispatch;
	// 825D6B70: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825D6B74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6B78: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825D6B7C: 419A0030  beq cr6, 0x825d6bac
	if ctx.cr[6].eq {
	pc = 0x825D6BAC; continue 'dispatch;
	}
	// 825D6B80: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 825D6B84: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 825D6B88: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825D6B8C: 419A0010  beq cr6, 0x825d6b9c
	if ctx.cr[6].eq {
	pc = 0x825D6B9C; continue 'dispatch;
	}
	// 825D6B90: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D6B94: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D6B98: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 825D6B9C: A0AB0006  lhz r5, 6(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 825D6BA0: 2B050003  cmplwi cr6, r5, 3
	ctx.cr[6].compare_u32(ctx.r[5].u32, 3 as u32, &mut ctx.xer);
	// 825D6BA4: 419A0034  beq cr6, 0x825d6bd8
	if ctx.cr[6].eq {
	pc = 0x825D6BD8; continue 'dispatch;
	}
	// 825D6BA8: B0CB0006  sth r6, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[6].u16 ) };
	// 825D6BAC: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825D6BB0: 394AFFF0  addi r10, r10, -0x10
	ctx.r[10].s64 = ctx.r[10].s64 + -16;
	// 825D6BB4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D6BB8: 4098FFA4  bge cr6, 0x825d6b5c
	if !ctx.cr[6].lt {
	pc = 0x825D6B5C; continue 'dispatch;
	}
	// 825D6BBC: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 825D6BC0: 409A0028  bne cr6, 0x825d6be8
	if !ctx.cr[6].eq {
	pc = 0x825D6BE8; continue 'dispatch;
	}
	// 825D6BC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D6BC8: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 825D6BCC: 99750000  stb r11, 0(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825D6BD0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825D6BD4: 4BF5E518  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
	// 825D6BD8: 9AD50000  stb r22, 0(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[22].u8 ) };
	// 825D6BDC: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 825D6BE0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825D6BE4: 4BF5E508  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
	// 825D6BE8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6BEC: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825D6BF0: 419A000C  beq cr6, 0x825d6bfc
	if ctx.cr[6].eq {
	pc = 0x825D6BFC; continue 'dispatch;
	}
	// 825D6BF4: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6BF8: 48000008  b 0x825d6c00
	pc = 0x825D6C00; continue 'dispatch;
	// 825D6BFC: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6C00: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6C04: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 825D6C08: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 825D6C0C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825D6C10: 4198007C  blt cr6, 0x825d6c8c
	if ctx.cr[6].lt {
	pc = 0x825D6C8C; continue 'dispatch;
	}
	// 825D6C14: 55092036  slwi r9, r8, 4
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825D6C18: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 825D6C1C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6C20: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825D6C24: 419A000C  beq cr6, 0x825d6c30
	if ctx.cr[6].eq {
	pc = 0x825D6C30; continue 'dispatch;
	}
	// 825D6C28: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 825D6C2C: 4800000C  b 0x825d6c38
	pc = 0x825D6C38; continue 'dispatch;
	// 825D6C30: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825D6C34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6C38: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825D6C3C: 419A0040  beq cr6, 0x825d6c7c
	if ctx.cr[6].eq {
	pc = 0x825D6C7C; continue 'dispatch;
	}
	// 825D6C40: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 825D6C44: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825D6C48: 409A0010  bne cr6, 0x825d6c58
	if !ctx.cr[6].eq {
	pc = 0x825D6C58; continue 'dispatch;
	}
	// 825D6C4C: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D6C50: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D6C54: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 825D6C58: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 825D6C5C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825D6C60: 41980018  blt cr6, 0x825d6c78
	if ctx.cr[6].lt {
	pc = 0x825D6C78; continue 'dispatch;
	}
	// 825D6C64: 419AFF74  beq cr6, 0x825d6bd8
	if ctx.cr[6].eq {
	pc = 0x825D6BD8; continue 'dispatch;
	}
	// 825D6C68: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 825D6C6C: 409A0010  bne cr6, 0x825d6c7c
	if !ctx.cr[6].eq {
	pc = 0x825D6C7C; continue 'dispatch;
	}
	// 825D6C70: B0CB0006  sth r6, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[6].u16 ) };
	// 825D6C74: 48000008  b 0x825d6c7c
	pc = 0x825D6C7C; continue 'dispatch;
	// 825D6C78: B30B0006  sth r24, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[24].u16 ) };
	// 825D6C7C: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 825D6C80: 3929FFF0  addi r9, r9, -0x10
	ctx.r[9].s64 = ctx.r[9].s64 + -16;
	// 825D6C84: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825D6C88: 4098FF94  bge cr6, 0x825d6c1c
	if !ctx.cr[6].lt {
	pc = 0x825D6C1C; continue 'dispatch;
	}
	// 825D6C8C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6C90: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 825D6C94: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825D6C98: 419A000C  beq cr6, 0x825d6ca4
	if ctx.cr[6].eq {
	pc = 0x825D6CA4; continue 'dispatch;
	}
	// 825D6C9C: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6CA0: 48000008  b 0x825d6ca8
	pc = 0x825D6CA8; continue 'dispatch;
	// 825D6CA4: 838B0004  lwz r28, 4(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6CA8: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6CAC: 3BABFFFF  addi r29, r11, -1
	ctx.r[29].s64 = ctx.r[11].s64 + -1;
	// 825D6CB0: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825D6CB4: 419800EC  blt cr6, 0x825d6da0
	if ctx.cr[6].lt {
	pc = 0x825D6DA0; continue 'dispatch;
	}
	// 825D6CB8: 57BE2036  slwi r30, r29, 4
	ctx.r[30].u32 = ctx.r[29].u32.wrapping_shl(4);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 825D6CBC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6CC0: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825D6CC4: 419A000C  beq cr6, 0x825d6cd0
	if ctx.cr[6].eq {
	pc = 0x825D6CD0; continue 'dispatch;
	}
	// 825D6CC8: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825D6CCC: 4800000C  b 0x825d6cd8
	pc = 0x825D6CD8; continue 'dispatch;
	// 825D6CD0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825D6CD4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6CD8: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825D6CDC: 419A00B4  beq cr6, 0x825d6d90
	if ctx.cr[6].eq {
	pc = 0x825D6D90; continue 'dispatch;
	}
	// 825D6CE0: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 825D6CE4: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825D6CE8: 419A000C  beq cr6, 0x825d6cf4
	if ctx.cr[6].eq {
	pc = 0x825D6CF4; continue 'dispatch;
	}
	// 825D6CEC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825D6CF0: 48000010  b 0x825d6d00
	pc = 0x825D6D00; continue 'dispatch;
	// 825D6CF4: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D6CF8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D6CFC: 7FEBBA14  add r31, r11, r23
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 825D6D00: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 825D6D04: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825D6D08: 409A003C  bne cr6, 0x825d6d44
	if !ctx.cr[6].eq {
	pc = 0x825D6D44; continue 'dispatch;
	}
	// 825D6D0C: 7CCB0774  extsb r11, r6
	ctx.r[11].s64 = ctx.r[6].s8 as i64;
	// 825D6D10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D6D14: 419A0028  beq cr6, 0x825d6d3c
	if ctx.cr[6].eq {
	pc = 0x825D6D3C; continue 'dispatch;
	}
	// 825D6D18: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825D6D1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D6D20: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825D6D24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D6D28: 4BFFFC41  bl 0x825d6968
	ctx.lr = 0x825D6D2C;
	sub_825D6968(ctx, base);
	// 825D6D2C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6D30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D6D34: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825D6D38: 409A0008  bne cr6, 0x825d6d40
	if !ctx.cr[6].eq {
	pc = 0x825D6D40; continue 'dispatch;
	}
	// 825D6D3C: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 825D6D40: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 825D6D44: A17F0002  lhz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D6D48: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D6D4C: 7CABBA14  add r5, r11, r23
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 825D6D50: A1650006  lhz r11, 6(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(6 as u32) ) } as u64;
	// 825D6D54: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 825D6D58: 409A0038  bne cr6, 0x825d6d90
	if !ctx.cr[6].eq {
	pc = 0x825D6D90; continue 'dispatch;
	}
	// 825D6D5C: 7CCB0774  extsb r11, r6
	ctx.r[11].s64 = ctx.r[6].s8 as i64;
	// 825D6D60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D6D64: 419A0024  beq cr6, 0x825d6d88
	if ctx.cr[6].eq {
	pc = 0x825D6D88; continue 'dispatch;
	}
	// 825D6D68: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 825D6D6C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825D6D70: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 825D6D74: 4BFFFBF5  bl 0x825d6968
	ctx.lr = 0x825D6D78;
	sub_825D6968(ctx, base);
	// 825D6D78: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6D7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D6D80: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825D6D84: 409A0008  bne cr6, 0x825d6d8c
	if !ctx.cr[6].eq {
	pc = 0x825D6D8C; continue 'dispatch;
	}
	// 825D6D88: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 825D6D8C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 825D6D90: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 825D6D94: 3BDEFFF0  addi r30, r30, -0x10
	ctx.r[30].s64 = ctx.r[30].s64 + -16;
	// 825D6D98: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825D6D9C: 4098FF20  bge cr6, 0x825d6cbc
	if !ctx.cr[6].lt {
	pc = 0x825D6CBC; continue 'dispatch;
	}
	// 825D6DA0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6DA4: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825D6DA8: 419A000C  beq cr6, 0x825d6db4
	if ctx.cr[6].eq {
	pc = 0x825D6DB4; continue 'dispatch;
	}
	// 825D6DAC: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6DB0: 48000008  b 0x825d6db8
	pc = 0x825D6DB8; continue 'dispatch;
	// 825D6DB4: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6DB8: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6DBC: 3BCBFFFF  addi r30, r11, -1
	ctx.r[30].s64 = ctx.r[11].s64 + -1;
	// 825D6DC0: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825D6DC4: 41980168  blt cr6, 0x825d6f2c
	if ctx.cr[6].lt {
	pc = 0x825D6F2C; continue 'dispatch;
	}
	// 825D6DC8: 57DF2036  slwi r31, r30, 4
	ctx.r[31].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 825D6DCC: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6DD0: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825D6DD4: 419A000C  beq cr6, 0x825d6de0
	if ctx.cr[6].eq {
	pc = 0x825D6DE0; continue 'dispatch;
	}
	// 825D6DD8: 7D6AF82E  lwzx r11, r10, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 825D6DDC: 4800000C  b 0x825d6de8
	pc = 0x825D6DE8; continue 'dispatch;
	// 825D6DE0: 7D6AFA14  add r11, r10, r31
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825D6DE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6DE8: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825D6DEC: 419A0130  beq cr6, 0x825d6f1c
	if ctx.cr[6].eq {
	pc = 0x825D6F1C; continue 'dispatch;
	}
	// 825D6DF0: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 825D6DF4: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825D6DF8: 419A000C  beq cr6, 0x825d6e04
	if ctx.cr[6].eq {
	pc = 0x825D6E04; continue 'dispatch;
	}
	// 825D6DFC: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 825D6E00: 48000010  b 0x825d6e10
	pc = 0x825D6E10; continue 'dispatch;
	// 825D6E04: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D6E08: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D6E0C: 7CABBA14  add r5, r11, r23
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 825D6E10: A1650006  lhz r11, 6(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(6 as u32) ) } as u64;
	// 825D6E14: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 825D6E18: 409A0104  bne cr6, 0x825d6f1c
	if !ctx.cr[6].eq {
	pc = 0x825D6F1C; continue 'dispatch;
	}
	// 825D6E1C: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 825D6E20: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825D6E24: 419A000C  beq cr6, 0x825d6e30
	if ctx.cr[6].eq {
	pc = 0x825D6E30; continue 'dispatch;
	}
	// 825D6E28: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6E2C: 48000008  b 0x825d6e34
	pc = 0x825D6E34; continue 'dispatch;
	// 825D6E30: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6E34: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6E38: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 825D6E3C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D6E40: 41980050  blt cr6, 0x825d6e90
	if ctx.cr[6].lt {
	pc = 0x825D6E90; continue 'dispatch;
	}
	// 825D6E44: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D6E48: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825D6E4C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825D6E50: 419A000C  beq cr6, 0x825d6e5c
	if ctx.cr[6].eq {
	pc = 0x825D6E5C; continue 'dispatch;
	}
	// 825D6E54: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6E58: 48000008  b 0x825d6e60
	pc = 0x825D6E60; continue 'dispatch;
	// 825D6E5C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6E60: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825D6E64: 419A0014  beq cr6, 0x825d6e78
	if ctx.cr[6].eq {
	pc = 0x825D6E78; continue 'dispatch;
	}
	// 825D6E68: A08B0006  lhz r4, 6(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 825D6E6C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 825D6E70: 2B040002  cmplwi cr6, r4, 2
	ctx.cr[6].compare_u32(ctx.r[4].u32, 2 as u32, &mut ctx.xer);
	// 825D6E74: 409A0018  bne cr6, 0x825d6e8c
	if !ctx.cr[6].eq {
	pc = 0x825D6E8C; continue 'dispatch;
	}
	// 825D6E78: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825D6E7C: 394AFFF0  addi r10, r10, -0x10
	ctx.r[10].s64 = ctx.r[10].s64 + -16;
	// 825D6E80: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D6E84: 4098FFC8  bge cr6, 0x825d6e4c
	if !ctx.cr[6].lt {
	pc = 0x825D6E4C; continue 'dispatch;
	}
	// 825D6E88: 48000008  b 0x825d6e90
	pc = 0x825D6E90; continue 'dispatch;
	// 825D6E8C: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 825D6E90: 81390008  lwz r9, 8(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D6E94: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 825D6E98: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 825D6E9C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D6EA0: 40990030  ble cr6, 0x825d6ed0
	if !ctx.cr[6].gt {
	pc = 0x825D6ED0; continue 'dispatch;
	}
	// 825D6EA4: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6EA8: 394A0006  addi r10, r10, 6
	ctx.r[10].s64 = ctx.r[10].s64 + 6;
	// 825D6EAC: A08A0000  lhz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6EB0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825D6EB4: 419A0018  beq cr6, 0x825d6ecc
	if ctx.cr[6].eq {
	pc = 0x825D6ECC; continue 'dispatch;
	}
	// 825D6EB8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D6EBC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825D6EC0: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825D6EC4: 4198FFE8  blt cr6, 0x825d6eac
	if ctx.cr[6].lt {
	pc = 0x825D6EAC; continue 'dispatch;
	}
	// 825D6EC8: 48000008  b 0x825d6ed0
	pc = 0x825D6ED0; continue 'dispatch;
	// 825D6ECC: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 825D6ED0: 7CEB0774  extsb r11, r7
	ctx.r[11].s64 = ctx.r[7].s8 as i64;
	// 825D6ED4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D6ED8: 419A0044  beq cr6, 0x825d6f1c
	if ctx.cr[6].eq {
	pc = 0x825D6F1C; continue 'dispatch;
	}
	// 825D6EDC: 7D0B0774  extsb r11, r8
	ctx.r[11].s64 = ctx.r[8].s8 as i64;
	// 825D6EE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D6EE4: 419A0038  beq cr6, 0x825d6f1c
	if ctx.cr[6].eq {
	pc = 0x825D6F1C; continue 'dispatch;
	}
	// 825D6EE8: 7CCB0774  extsb r11, r6
	ctx.r[11].s64 = ctx.r[6].s8 as i64;
	// 825D6EEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D6EF0: 419A0024  beq cr6, 0x825d6f14
	if ctx.cr[6].eq {
	pc = 0x825D6F14; continue 'dispatch;
	}
	// 825D6EF4: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 825D6EF8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825D6EFC: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 825D6F00: 4BFFFA69  bl 0x825d6968
	ctx.lr = 0x825D6F04;
	sub_825D6968(ctx, base);
	// 825D6F04: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6F08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D6F0C: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825D6F10: 409A0008  bne cr6, 0x825d6f18
	if !ctx.cr[6].eq {
	pc = 0x825D6F18; continue 'dispatch;
	}
	// 825D6F14: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 825D6F18: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 825D6F1C: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 825D6F20: 3BFFFFF0  addi r31, r31, -0x10
	ctx.r[31].s64 = ctx.r[31].s64 + -16;
	// 825D6F24: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825D6F28: 4098FEA4  bge cr6, 0x825d6dcc
	if !ctx.cr[6].lt {
	pc = 0x825D6DCC; continue 'dispatch;
	}
	// 825D6F2C: 81390008  lwz r9, 8(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D6F30: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D6F34: 40990044  ble cr6, 0x825d6f78
	if !ctx.cr[6].gt {
	pc = 0x825D6F78; continue 'dispatch;
	}
	// 825D6F38: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 825D6F3C: 7CCA0774  extsb r10, r6
	ctx.r[10].s64 = ctx.r[6].s8 as i64;
	// 825D6F40: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D6F44: 419A001C  beq cr6, 0x825d6f60
	if ctx.cr[6].eq {
	pc = 0x825D6F60; continue 'dispatch;
	}
	// 825D6F48: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6F4C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825D6F50: A14A0006  lhz r10, 6(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 825D6F54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825D6F58: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 825D6F5C: 409A0008  bne cr6, 0x825d6f64
	if !ctx.cr[6].eq {
	pc = 0x825D6F64; continue 'dispatch;
	}
	// 825D6F60: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	// 825D6F64: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825D6F68: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 825D6F6C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825D6F70: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825D6F74: 409AFFC8  bne cr6, 0x825d6f3c
	if !ctx.cr[6].eq {
	pc = 0x825D6F3C; continue 'dispatch;
	}
	// 825D6F78: 98D50000  stb r6, 0(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[6].u8 ) };
	// 825D6F7C: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 825D6F80: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825D6F84: 4BF5E168  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D6F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D6F88 size=232
    let mut pc: u32 = 0x825D6F88;
    'dispatch: loop {
        match pc {
            0x825D6F88 => {
    //   block [0x825D6F88..0x825D7070)
	// 825D6F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D6F8C: 4BF5E111  bl 0x8253509c
	ctx.lr = 0x825D6F90;
	sub_82535080(ctx, base);
	// 825D6F90: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D6F94: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 825D6F98: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 825D6F9C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 825D6FA0: 81760008  lwz r11, 8(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D6FA4: 83160004  lwz r24, 4(r22)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6FA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D6FAC: 409900BC  ble cr6, 0x825d7068
	if !ctx.cr[6].gt {
	pc = 0x825D7068; continue 'dispatch;
	}
	// 825D6FB0: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 825D6FB4: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6FB8: 7D75582A  ldx r11, r21, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[11].u32)) };
	// 825D6FBC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825D6FC0: A1610054  lhz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D6FC4: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D6FC8: 4098008C  bge cr6, 0x825d7054
	if !ctx.cr[6].lt {
	pc = 0x825D7054; continue 'dispatch;
	}
	// 825D6FCC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D6FD0: 7D6BC214  add r11, r11, r24
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 825D6FD4: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6FD8: 7F195000  cmpw cr6, r25, r10
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825D6FDC: 40980078  bge cr6, 0x825d7054
	if !ctx.cr[6].lt {
	pc = 0x825D7054; continue 'dispatch;
	}
	// 825D6FE0: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 825D6FE4: A36B0000  lhz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6FE8: 3BF7000C  addi r31, r23, 0xc
	ctx.r[31].s64 = ctx.r[23].s64 + 12;
	// 825D6FEC: A3810050  lhz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D6FF0: 554B183E  rotlwi r11, r10, 3
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825D6FF4: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6FF8: 7F4BC22E  lhzx r26, r11, r24
	ctx.r[26].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 825D6FFC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D7000: 3BBE0001  addi r29, r30, 1
	ctx.r[29].s64 = ctx.r[30].s64 + 1;
	// 825D7004: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D7008: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 825D700C: 40980024  bge cr6, 0x825d7030
	if !ctx.cr[6].lt {
	pc = 0x825D7030; continue 'dispatch;
	}
	// 825D7010: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D7014: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D7018: 41980008  blt cr6, 0x825d7020
	if ctx.cr[6].lt {
	pc = 0x825D7020; continue 'dispatch;
	}
	// 825D701C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825D7020: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 825D7024: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825D7028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D702C: 4BE9729D  bl 0x8246e2c8
	ctx.lr = 0x825D7030;
	sub_8246E2C8(ctx, base);
	// 825D7030: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D7034: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7038: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825D703C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 825D7040: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D7044: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825D7048: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825D704C: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 825D7050: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 825D7054: 81760008  lwz r11, 8(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D7058: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 825D705C: 3AB50008  addi r21, r21, 8
	ctx.r[21].s64 = ctx.r[21].s64 + 8;
	// 825D7060: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D7064: 4198FF50  blt cr6, 0x825d6fb4
	if ctx.cr[6].lt {
	pc = 0x825D6FB4; continue 'dispatch;
	}
	// 825D7068: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825D706C: 4BF5E080  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D7070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D7070 size=132
    let mut pc: u32 = 0x825D7070;
    'dispatch: loop {
        match pc {
            0x825D7070 => {
    //   block [0x825D7070..0x825D70F4)
	// 825D7070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D7074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D7078: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D707C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D7080: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D7084: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D7088: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 825D708C: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 825D7090: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 825D7094: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D7098: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 825D709C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825D70A0: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 825D70A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D70A8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825D70AC: 4BFFE6B5  bl 0x825d5760
	ctx.lr = 0x825D70B0;
	sub_825D5760(ctx, base);
	// 825D70B0: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D70B4: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825D70B8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D70BC: 409A0020  bne cr6, 0x825d70dc
	if !ctx.cr[6].eq {
	pc = 0x825D70DC; continue 'dispatch;
	}
	// 825D70C0: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D70C4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825D70C8: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825D70CC: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825D70D0: 55652834  slwi r5, r11, 5
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825D70D4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825D70D8: 4BE8CFE1  bl 0x824640b8
	ctx.lr = 0x825D70DC;
	sub_824640B8(ctx, base);
	// 825D70DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D70E0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825D70E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D70E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D70EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D70F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D70F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D70F8 size=1208
    let mut pc: u32 = 0x825D70F8;
    'dispatch: loop {
        match pc {
            0x825D70F8 => {
    //   block [0x825D70F8..0x825D75B0)
	// 825D70F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D70FC: 4BF5DFA1  bl 0x8253509c
	ctx.lr = 0x825D7100;
	sub_82535080(ctx, base);
	// 825D7100: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D7104: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825D7108: 82CD0000  lwz r22, 0(r13)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D710C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 825D7110: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825D7114: 3AE00010  li r23, 0x10
	ctx.r[23].s64 = 16;
	// 825D7118: 3FE08000  lis r31, -0x8000
	ctx.r[31].s64 = -2147483648;
	// 825D711C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825D7120: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 825D7124: 939A0008  stw r28, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 825D7128: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 825D712C: 83DB0008  lwz r30, 8(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D7130: 7C77B02E  lwzx r3, r23, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 825D7134: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 825D7138: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 825D713C: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 825D7140: 55640836  rlwinm r4, r11, 1, 0, 0x1b
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 825D7144: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 825D7148: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 825D714C: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 825D7150: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825D7154: 4199000C  bgt cr6, 0x825d7160
	if ctx.cr[6].gt {
	pc = 0x825D7160; continue 'dispatch;
	}
	// 825D7158: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 825D715C: 48000018  b 0x825d7174
	pc = 0x825D7174; continue 'dispatch;
	// 825D7160: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7164: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825D7168: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D716C: 4E800421  bctrl
	ctx.lr = 0x825D7170;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D7170: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D7174: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825D7178: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825D717C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825D7180: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 825D7184: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 825D7188: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 825D718C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825D7190: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 825D7194: 7FC9FB78  or r9, r30, r31
	ctx.r[9].u64 = ctx.r[30].u64 | ctx.r[31].u64;
	// 825D7198: 888A0000  lbz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D719C: 91210078  stw r9, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 825D71A0: 4BFFF359  bl 0x825d64f8
	ctx.lr = 0x825D71A4;
	sub_825D64F8(ctx, base);
	// 825D71A4: 7C77B02E  lwzx r3, r23, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 825D71A8: 83DD0008  lwz r30, 8(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D71AC: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 825D71B0: 395E0008  addi r10, r30, 8
	ctx.r[10].s64 = ctx.r[30].s64 + 8;
	// 825D71B4: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 825D71B8: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 825D71BC: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 825D71C0: 55440836  rlwinm r4, r10, 1, 0, 0x1b
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x7FFFFFFFu64;
	// 825D71C4: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 825D71C8: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 825D71CC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825D71D0: 4199000C  bgt cr6, 0x825d71dc
	if ctx.cr[6].gt {
	pc = 0x825D71DC; continue 'dispatch;
	}
	// 825D71D4: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 825D71D8: 48000018  b 0x825d71f0
	pc = 0x825D71F0; continue 'dispatch;
	// 825D71DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D71E0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825D71E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D71E8: 4E800421  bctrl
	ctx.lr = 0x825D71EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D71EC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D71F0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825D71F4: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 825D71F8: 7FC9FB78  or r9, r30, r31
	ctx.r[9].u64 = ctx.r[30].u64 | ctx.r[31].u64;
	// 825D71FC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825D7200: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825D7204: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825D7208: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 825D720C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D7210: 888A0000  lbz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7214: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 825D7218: 4BFFF2E1  bl 0x825d64f8
	ctx.lr = 0x825D721C;
	sub_825D64F8(ctx, base);
	// 825D721C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D7220: 3BFA0004  addi r31, r26, 4
	ctx.r[31].s64 = ctx.r[26].s64 + 4;
	// 825D7224: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D7228: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825D722C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825D7230: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825D7234: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D7238: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D723C: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 825D7240: 40980010  bge cr6, 0x825d7250
	if !ctx.cr[6].lt {
	pc = 0x825D7250; continue 'dispatch;
	}
	// 825D7244: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825D7248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D724C: 4BE9707D  bl 0x8246e2c8
	ctx.lr = 0x825D7250;
	sub_8246E2C8(ctx, base);
	// 825D7250: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D7254: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825D7258: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D725C: 409900C0  ble cr6, 0x825d731c
	if !ctx.cr[6].gt {
	pc = 0x825D731C; continue 'dispatch;
	}
	// 825D7260: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825D7264: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7268: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 825D726C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7270: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D7274: A10A0000  lhz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7278: B10B0008  sth r8, 8(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u16 ) };
	// 825D727C: A10A0004  lhz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D7280: 80BB0004  lwz r5, 4(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D7284: 5508183E  rotlwi r8, r8, 3
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(3)) as u64;
	// 825D7288: 7D082A2E  lhzx r8, r8, r5
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 825D728C: B10B000C  sth r8, 0xc(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u16 ) };
	// 825D7290: A1090000  lhz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7294: B10B000E  sth r8, 0xe(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(14 as u32), ctx.r[8].u16 ) };
	// 825D7298: A1290002  lhz r9, 2(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D729C: 811B0004  lwz r8, 4(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D72A0: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825D72A4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825D72A8: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 825D72AC: 81210070  lwz r9, 0x70(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825D72B0: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 825D72B4: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D72B8: 7D4A4A2E  lhzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 825D72BC: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 825D72C0: 409A000C  bne cr6, 0x825d72cc
	if !ctx.cr[6].eq {
	pc = 0x825D72CC; continue 'dispatch;
	}
	// 825D72C4: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 825D72C8: 48000010  b 0x825d72d8
	pc = 0x825D72D8; continue 'dispatch;
	// 825D72CC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D72D0: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D72D4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825D72D8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D72DC: 5509083C  slwi r9, r8, 1
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825D72E0: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D72E4: 7D49522E  lhzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825D72E8: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 825D72EC: 409A000C  bne cr6, 0x825d72f8
	if !ctx.cr[6].eq {
	pc = 0x825D72F8; continue 'dispatch;
	}
	// 825D72F0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 825D72F4: 48000010  b 0x825d7304
	pc = 0x825D7304; continue 'dispatch;
	// 825D72F8: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D72FC: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D7300: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825D7304: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D7308: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 825D730C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D7310: 38E70010  addi r7, r7, 0x10
	ctx.r[7].s64 = ctx.r[7].s64 + 16;
	// 825D7314: 7F065800  cmpw cr6, r6, r11
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D7318: 4198FF4C  blt cr6, 0x825d7264
	if ctx.cr[6].lt {
	pc = 0x825D7264; continue 'dispatch;
	}
	// 825D731C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D7320: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 825D7324: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7328: 3B6BFFFF  addi r27, r11, -1
	ctx.r[27].s64 = ctx.r[11].s64 + -1;
	// 825D732C: 81190000  lwz r8, 0(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7330: 831A0008  lwz r24, 8(r26)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D7334: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 825D7338: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 825D733C: 419801C4  blt cr6, 0x825d7500
	if ctx.cr[6].lt {
	pc = 0x825D7500; continue 'dispatch;
	}
	// 825D7340: 577E2036  slwi r30, r27, 4
	ctx.r[30].u32 = ctx.r[27].u32.wrapping_shl(4);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 825D7344: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D7348: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D734C: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 825D7350: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7354: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D7358: 80BA0008  lwz r5, 8(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D735C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825D7360: 7CEA4A14  add r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825D7364: 54CA003E  slwi r10, r6, 0
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D7368: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825D736C: 3AAA0001  addi r21, r10, 1
	ctx.r[21].s64 = ctx.r[10].s64 + 1;
	// 825D7370: 809A0008  lwz r4, 8(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D7374: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D7378: 7CCA4A14  add r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825D737C: 92BF0004  stw r21, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[21].u32 ) };
	// 825D7380: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7384: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7388: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825D738C: 409A00B0  bne cr6, 0x825d743c
	if !ctx.cr[6].eq {
	pc = 0x825D743C; continue 'dispatch;
	}
	// 825D7390: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D7394: A12A0006  lhz r9, 6(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 825D7398: 3929FFFE  addi r9, r9, -2
	ctx.r[9].s64 = ctx.r[9].s64 + -2;
	// 825D739C: 7D290034  cntlzw r9, r9
	ctx.r[9].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 825D73A0: 5529DFFE  rlwinm r9, r9, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 825D73A4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D73A8: 419A000C  beq cr6, 0x825d73b4
	if ctx.cr[6].eq {
	pc = 0x825D73B4; continue 'dispatch;
	}
	// 825D73AC: A10A0002  lhz r8, 2(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D73B0: 48000008  b 0x825d73b8
	pc = 0x825D73B8; continue 'dispatch;
	// 825D73B4: 811A0008  lwz r8, 8(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D73B8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D73BC: 419A0014  beq cr6, 0x825d73d0
	if ctx.cr[6].eq {
	pc = 0x825D73D0; continue 'dispatch;
	}
	// 825D73C0: A14A0002  lhz r10, 2(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D73C4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825D73C8: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 825D73CC: 4800001C  b 0x825d73e8
	pc = 0x825D73E8; continue 'dispatch;
	// 825D73D0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D73D4: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D73D8: 3AAA0001  addi r21, r10, 1
	ctx.r[21].s64 = ctx.r[10].s64 + 1;
	// 825D73DC: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D73E0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825D73E4: 92BF0004  stw r21, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[21].u32 ) };
	// 825D73E8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D73EC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825D73F0: A1290000  lhz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D73F4: B0870004  sth r4, 4(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[4].u16 ) };
	// 825D73F8: B0670002  sth r3, 2(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(2 as u32), ctx.r[3].u16 ) };
	// 825D73FC: B1270000  sth r9, 0(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 825D7400: 419A0008  beq cr6, 0x825d7408
	if ctx.cr[6].eq {
	pc = 0x825D7408; continue 'dispatch;
	}
	// 825D7404: B0BC0002  sth r5, 2(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(2 as u32), ctx.r[5].u16 ) };
	// 825D7408: 5509043E  clrlwi r9, r8, 0x10
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x0000FFFFu64;
	// 825D740C: A10B000E  lhz r8, 0xe(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(14 as u32) ) } as u64;
	// 825D7410: B0AA0004  sth r5, 4(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[5].u16 ) };
	// 825D7414: B10A0000  sth r8, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 825D7418: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D741C: 7D1D4050  subf r8, r29, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[29].s64;
	// 825D7420: 7D081E70  srawi r8, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 825D7424: B10A0002  sth r8, 2(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(2 as u32), ctx.r[8].u16 ) };
	// 825D7428: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D742C: B12A0002  sth r9, 2(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(2 as u32), ctx.r[9].u16 ) };
	// 825D7430: A14B0008  lhz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D7434: B1260004  sth r9, 4(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 825D7438: 480000A8  b 0x825d74e0
	pc = 0x825D74E0; continue 'dispatch;
	// 825D743C: A12A0006  lhz r9, 6(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 825D7440: 3929FFFE  addi r9, r9, -2
	ctx.r[9].s64 = ctx.r[9].s64 + -2;
	// 825D7444: 7D290034  cntlzw r9, r9
	ctx.r[9].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 825D7448: 5529DFFE  rlwinm r9, r9, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 825D744C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D7450: 419A000C  beq cr6, 0x825d745c
	if ctx.cr[6].eq {
	pc = 0x825D745C; continue 'dispatch;
	}
	// 825D7454: A10A0002  lhz r8, 2(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D7458: 48000008  b 0x825d7460
	pc = 0x825D7460; continue 'dispatch;
	// 825D745C: 811A0008  lwz r8, 8(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D7460: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D7464: 419A0014  beq cr6, 0x825d7478
	if ctx.cr[6].eq {
	pc = 0x825D7478; continue 'dispatch;
	}
	// 825D7468: A14A0002  lhz r10, 2(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D746C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825D7470: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 825D7474: 4800001C  b 0x825d7490
	pc = 0x825D7490; continue 'dispatch;
	// 825D7478: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D747C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7480: 3AAA0001  addi r21, r10, 1
	ctx.r[21].s64 = ctx.r[10].s64 + 1;
	// 825D7484: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D7488: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825D748C: 92BF0004  stw r21, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[21].u32 ) };
	// 825D7490: 5509043E  clrlwi r9, r8, 0x10
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x0000FFFFu64;
	// 825D7494: A10B000E  lhz r8, 0xe(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(14 as u32) ) } as u64;
	// 825D7498: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825D749C: B0670002  sth r3, 2(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(2 as u32), ctx.r[3].u16 ) };
	// 825D74A0: B1070000  sth r8, 0(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 825D74A4: B1270004  sth r9, 4(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 825D74A8: 419A0008  beq cr6, 0x825d74b0
	if ctx.cr[6].eq {
	pc = 0x825D74B0; continue 'dispatch;
	}
	// 825D74AC: B0BC0002  sth r5, 2(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(2 as u32), ctx.r[5].u16 ) };
	// 825D74B0: A10B000C  lhz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D74B4: B08A0004  sth r4, 4(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u16 ) };
	// 825D74B8: B10A0000  sth r8, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 825D74BC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D74C0: 7D1D4050  subf r8, r29, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[29].s64;
	// 825D74C4: 7D081E70  srawi r8, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 825D74C8: B10A0002  sth r8, 2(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(2 as u32), ctx.r[8].u16 ) };
	// 825D74CC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D74D0: B12A0002  sth r9, 2(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(2 as u32), ctx.r[9].u16 ) };
	// 825D74D4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D74D8: A14A0000  lhz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D74DC: B0A60004  sth r5, 4(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[5].u16 ) };
	// 825D74E0: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 825D74E4: B1460000  sth r10, 0(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 825D74E8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825D74EC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825D74F0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 825D74F4: 3BDEFFF0  addi r30, r30, -0x10
	ctx.r[30].s64 = ctx.r[30].s64 + -16;
	// 825D74F8: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 825D74FC: 4098FE48  bge cr6, 0x825d7344
	if !ctx.cr[6].lt {
	pc = 0x825D7344; continue 'dispatch;
	}
	// 825D7500: 570B1838  slwi r11, r24, 3
	ctx.r[11].u32 = ctx.r[24].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D7504: B31C0002  sth r24, 2(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(2 as u32), ctx.r[24].u16 ) };
	// 825D7508: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825D750C: B06B0002  sth r3, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[3].u16 ) };
	// 825D7510: 7C77B02E  lwzx r3, r23, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 825D7514: 8081006C  lwz r4, 0x6c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825D7518: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825D751C: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 825D7520: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825D7524: 409A0014  bne cr6, 0x825d7538
	if !ctx.cr[6].eq {
	pc = 0x825D7538; continue 'dispatch;
	}
	// 825D7528: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D752C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825D7530: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D7534: 4E800421  bctrl
	ctx.lr = 0x825D7538;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D7538: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825D753C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825D7540: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D7544: 409A0018  bne cr6, 0x825d755c
	if !ctx.cr[6].eq {
	pc = 0x825D755C; continue 'dispatch;
	}
	// 825D7548: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825D754C: 7C77B02E  lwzx r3, r23, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 825D7550: 5565087C  rlwinm r5, r11, 1, 1, 0x1e
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 825D7554: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D7558: 4BE8CB61  bl 0x824640b8
	ctx.lr = 0x825D755C;
	sub_824640B8(ctx, base);
	// 825D755C: 7C77B02E  lwzx r3, r23, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 825D7560: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825D7564: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825D7568: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 825D756C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825D7570: 409A0014  bne cr6, 0x825d7584
	if !ctx.cr[6].eq {
	pc = 0x825D7584; continue 'dispatch;
	}
	// 825D7574: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7578: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825D757C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D7580: 4E800421  bctrl
	ctx.lr = 0x825D7584;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D7584: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 825D7588: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825D758C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D7590: 409A0018  bne cr6, 0x825d75a8
	if !ctx.cr[6].eq {
	pc = 0x825D75A8; continue 'dispatch;
	}
	// 825D7594: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825D7598: 7C77B02E  lwzx r3, r23, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 825D759C: 5565087C  rlwinm r5, r11, 1, 1, 0x1e
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 825D75A0: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825D75A4: 4BE8CB15  bl 0x824640b8
	ctx.lr = 0x825D75A8;
	sub_824640B8(ctx, base);
	// 825D75A8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825D75AC: 4BF5DB40  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D75B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D75B0 size=344
    let mut pc: u32 = 0x825D75B0;
    'dispatch: loop {
        match pc {
            0x825D75B0 => {
    //   block [0x825D75B0..0x825D7708)
	// 825D75B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D75B4: 4BF5DADD  bl 0x82535090
	ctx.lr = 0x825D75B8;
	sub_82535080(ctx, base);
	// 825D75B8: DBC1FF78  stfd f30, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 825D75BC: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 825D75C0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D75C4: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 825D75C8: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 825D75CC: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 825D75D0: 7CF23B78  mr r18, r7
	ctx.r[18].u64 = ctx.r[7].u64;
	// 825D75D4: 7D144378  mr r20, r8
	ctx.r[20].u64 = ctx.r[8].u64;
	// 825D75D8: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D75DC: 7D334B78  mr r19, r9
	ctx.r[19].u64 = ctx.r[9].u64;
	// 825D75E0: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 825D75E4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825D75E8: 419A0110  beq cr6, 0x825d76f8
	if ctx.cr[6].eq {
	pc = 0x825D76F8; continue 'dispatch;
	}
	// 825D75EC: A1720002  lhz r11, 2(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[18].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D75F0: 54D8043E  clrlwi r24, r6, 0x10
	ctx.r[24].u64 = ctx.r[6].u32 as u64 & 0x0000FFFFu64;
	// 825D75F4: 83790004  lwz r27, 4(r25)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D75F8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D75FC: 82F90000  lwz r23, 0(r25)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7600: 7F4BDA14  add r26, r11, r27
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 825D7604: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D7608: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 825D760C: C3CB294C  lfs f30, 0x294c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10572 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825D7610: A17F0000  lhz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7614: 556A203E  rotlwi r10, r11, 4
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(4)) as u64;
	// 825D7618: 7F0BC040  cmplw cr6, r11, r24
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[24].u32, &mut ctx.xer);
	// 825D761C: 7C8ABA14  add r4, r10, r23
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[23].u64;
	// 825D7620: 409A000C  bne cr6, 0x825d762c
	if !ctx.cr[6].eq {
	pc = 0x825D762C; continue 'dispatch;
	}
	// 825D7624: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 825D7628: 4800001C  b 0x825d7644
	pc = 0x825D7644; continue 'dispatch;
	// 825D762C: 7E679B78  mr r7, r19
	ctx.r[7].u64 = ctx.r[19].u64;
	// 825D7630: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 825D7634: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 825D7638: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 825D763C: 4BFFAF1D  bl 0x825d2558
	ctx.lr = 0x825D7640;
	sub_825D2558(ctx, base);
	// 825D7640: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825D7644: 839D0004  lwz r28, 4(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D7648: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D764C: 3BDC0001  addi r30, r28, 1
	ctx.r[30].s64 = ctx.r[28].s64 + 1;
	// 825D7650: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D7654: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 825D7658: 40980024  bge cr6, 0x825d767c
	if !ctx.cr[6].lt {
	pc = 0x825D767C; continue 'dispatch;
	}
	// 825D765C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D7660: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D7664: 41980008  blt cr6, 0x825d766c
	if ctx.cr[6].lt {
	pc = 0x825D766C; continue 'dispatch;
	}
	// 825D7668: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825D766C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825D7670: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825D7674: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D7678: 4BE96C51  bl 0x8246e2c8
	ctx.lr = 0x825D767C;
	sub_8246E2C8(ctx, base);
	// 825D767C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7680: 578B1838  slwi r11, r28, 3
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D7684: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825D7688: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825D768C: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D7690: D3EB0004  stfs f31, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825D7694: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D7698: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D769C: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 825D76A0: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D76A4: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D76A8: 7FEBDA14  add r31, r11, r27
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 825D76AC: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825D76B0: 409AFF60  bne cr6, 0x825d7610
	if !ctx.cr[6].eq {
	pc = 0x825D7610; continue 'dispatch;
	}
	// 825D76B4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D76B8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825D76BC: 4099001C  ble cr6, 0x825d76d8
	if !ctx.cr[6].gt {
	pc = 0x825D76D8; continue 'dispatch;
	}
	// 825D76C0: 3D40825D  lis r10, -0x7da3
	ctx.r[10].s64 = -2107834368;
	// 825D76C4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D76C8: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 825D76CC: 38CA2B88  addi r6, r10, 0x2b88
	ctx.r[6].s64 = ctx.r[10].s64 + 11144;
	// 825D76D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D76D4: 480014F5  bl 0x825d8bc8
	ctx.lr = 0x825D76D8;
	sub_825D8BC8(ctx, base);
	// 825D76D8: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 825D76DC: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 825D76E0: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 825D76E4: 7E469378  mr r6, r18
	ctx.r[6].u64 = ctx.r[18].u64;
	// 825D76E8: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 825D76EC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825D76F0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 825D76F4: 4BFFEF85  bl 0x825d6678
	ctx.lr = 0x825D76F8;
	sub_825D6678(ctx, base);
	// 825D76F8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825D76FC: CBC1FF78  lfd f30, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 825D7700: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 825D7704: 4BF5D9DC  b 0x825350e0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D7708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D7708 size=436
    let mut pc: u32 = 0x825D7708;
    'dispatch: loop {
        match pc {
            0x825D7708 => {
    //   block [0x825D7708..0x825D78BC)
	// 825D7708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D770C: 4BF5D98D  bl 0x82535098
	ctx.lr = 0x825D7710;
	sub_82535080(ctx, base);
	// 825D7710: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D7714: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 825D7718: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 825D771C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 825D7720: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 825D7724: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825D7728: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D772C: 7F54D378  mr r20, r26
	ctx.r[20].u64 = ctx.r[26].u64;
	// 825D7730: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D7734: 4099017C  ble cr6, 0x825d78b0
	if !ctx.cr[6].gt {
	pc = 0x825D78B0; continue 'dispatch;
	}
	// 825D7738: 7F55D378  mr r21, r26
	ctx.r[21].u64 = ctx.r[26].u64;
	// 825D773C: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 825D7740: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D7744: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 825D7748: 81560000  lwz r10, 0(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D774C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D7750: 7F755214  add r27, r21, r10
	ctx.r[27].u64 = ctx.r[21].u64 + ctx.r[10].u64;
	// 825D7754: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825D7758: 40980020  bge cr6, 0x825d7778
	if !ctx.cr[6].lt {
	pc = 0x825D7778; continue 'dispatch;
	}
	// 825D775C: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 825D7760: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 825D7764: 41990008  bgt cr6, 0x825d776c
	if ctx.cr[6].gt {
	pc = 0x825D776C; continue 'dispatch;
	}
	// 825D7768: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825D776C: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 825D7770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D7774: 4BE96B55  bl 0x8246e2c8
	ctx.lr = 0x825D7778;
	sub_8246E2C8(ctx, base);
	// 825D7778: 933F0004  stw r25, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 825D777C: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7780: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7784: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D7788: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D778C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D7790: 83DB0008  lwz r30, 8(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D7794: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825D7798: 419A0104  beq cr6, 0x825d789c
	if ctx.cr[6].eq {
	pc = 0x825D789C; continue 'dispatch;
	}
	// 825D779C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D77A0: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D77A4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825D77A8: 409A0028  bne cr6, 0x825d77d0
	if !ctx.cr[6].eq {
	pc = 0x825D77D0; continue 'dispatch;
	}
	// 825D77AC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D77B0: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D77B4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825D77B8: 409A0018  bne cr6, 0x825d77d0
	if !ctx.cr[6].eq {
	pc = 0x825D77D0; continue 'dispatch;
	}
	// 825D77BC: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D77C0: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D77C4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825D77C8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 825D77CC: 419A0008  beq cr6, 0x825d77d4
	if ctx.cr[6].eq {
	pc = 0x825D77D4; continue 'dispatch;
	}
	// 825D77D0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 825D77D4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825D77D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D77DC: 419A005C  beq cr6, 0x825d7838
	if ctx.cr[6].eq {
	pc = 0x825D7838; continue 'dispatch;
	}
	// 825D77E0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825D77E4: 9B210050  stb r25, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u8 ) };
	// 825D77E8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825D77EC: 80B70004  lwz r5, 4(r23)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D77F0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825D77F4: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 825D77F8: 88CB0000  lbz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D77FC: 4BFFF2D5  bl 0x825d6ad0
	ctx.lr = 0x825D7800;
	sub_825D6AD0(ctx, base);
	// 825D7800: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825D7804: 9B410050  stb r26, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u8 ) };
	// 825D7808: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825D780C: 80B80004  lwz r5, 4(r24)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D7810: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 825D7814: 38610052  addi r3, r1, 0x52
	ctx.r[3].s64 = ctx.r[1].s64 + 82;
	// 825D7818: 88CB0000  lbz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D781C: 4BFFF2B5  bl 0x825d6ad0
	ctx.lr = 0x825D7820;
	sub_825D6AD0(ctx, base);
	// 825D7820: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 825D7824: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D7828: 419A0010  beq cr6, 0x825d7838
	if ctx.cr[6].eq {
	pc = 0x825D7838; continue 'dispatch;
	}
	// 825D782C: 89610052  lbz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 825D7830: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D7834: 409A0080  bne cr6, 0x825d78b4
	if !ctx.cr[6].eq {
	pc = 0x825D78B4; continue 'dispatch;
	}
	// 825D7838: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D783C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D7840: 3BBC0001  addi r29, r28, 1
	ctx.r[29].s64 = ctx.r[28].s64 + 1;
	// 825D7844: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D7848: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 825D784C: 40980024  bge cr6, 0x825d7870
	if !ctx.cr[6].lt {
	pc = 0x825D7870; continue 'dispatch;
	}
	// 825D7850: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D7854: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D7858: 41980008  blt cr6, 0x825d7860
	if ctx.cr[6].lt {
	pc = 0x825D7860; continue 'dispatch;
	}
	// 825D785C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825D7860: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 825D7864: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825D7868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D786C: 4BE96A5D  bl 0x8246e2c8
	ctx.lr = 0x825D7870;
	sub_8246E2C8(ctx, base);
	// 825D7870: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7874: 578B2036  slwi r11, r28, 4
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D7878: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825D787C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825D7880: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7884: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D7888: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D788C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D7890: 83DE0008  lwz r30, 8(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D7894: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825D7898: 409AFF04  bne cr6, 0x825d779c
	if !ctx.cr[6].eq {
	pc = 0x825D779C; continue 'dispatch;
	}
	// 825D789C: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D78A0: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 825D78A4: 3AB50014  addi r21, r21, 0x14
	ctx.r[21].s64 = ctx.r[21].s64 + 20;
	// 825D78A8: 7F145800  cmpw cr6, r20, r11
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D78AC: 4198FE94  blt cr6, 0x825d7740
	if ctx.cr[6].lt {
	pc = 0x825D7740; continue 'dispatch;
	}
	// 825D78B0: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 825D78B4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825D78B8: 4BF5D830  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D78C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D78C0 size=2048
    let mut pc: u32 = 0x825D78C0;
    'dispatch: loop {
        match pc {
            0x825D78C0 => {
    //   block [0x825D78C0..0x825D80C0)
	// 825D78C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D78C4: 4BF5D7BD  bl 0x82535080
	ctx.lr = 0x825D78C8;
	sub_82535080(ctx, base);
	// 825D78C8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825D78CC: 4BF5E71D  bl 0x82535fe8
	ctx.lr = 0x825D78D0;
	sub_82535FB0(ctx, base);
	// 825D78D0: 3980FF20  li r12, -0xe0
	ctx.r[12].s64 = -224;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D80C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D80C0 size=1296
    let mut pc: u32 = 0x825D80C0;
    'dispatch: loop {
        match pc {
            0x825D80C0 => {
    //   block [0x825D80C0..0x825D85D0)
	// 825D80C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D80C4: 4BF5CFDD  bl 0x825350a0
	ctx.lr = 0x825D80C8;
	sub_82535080(ctx, base);
	// 825D80C8: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 825D80CC: 9421F700  stwu r1, -0x900(r1)
	ea = ctx.r[1].u32.wrapping_add(-2304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D80D0: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 825D80D4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825D80D8: 3B170001  addi r24, r23, 1
	ctx.r[24].s64 = ctx.r[23].s64 + 1;
	// 825D80DC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D80E0: 7D7FC050  subf r11, r31, r24
	ctx.r[11].s64 = ctx.r[24].s64 - ctx.r[31].s64;
	// 825D80E4: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 825D80E8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825D80EC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825D80F0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825D80F4: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 825D80F8: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 825D80FC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825D8100: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825D8104: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825D8108: 4198009C  blt cr6, 0x825d81a4
	if ctx.cr[6].lt {
	pc = 0x825D81A4; continue 'dispatch;
	}
	// 825D810C: 7D3FC050  subf r9, r31, r24
	ctx.r[9].s64 = ctx.r[24].s64 - ctx.r[31].s64;
	// 825D8110: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8114: 57EB2036  slwi r11, r31, 4
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D8118: 3929FFFC  addi r9, r9, -4
	ctx.r[9].s64 = ctx.r[9].s64 + -4;
	// 825D811C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825D8120: 552AF0BE  srwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D8124: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 825D8128: 390A0001  addi r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 1;
	// 825D812C: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D8130: 7CEAFA14  add r7, r10, r31
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825D8134: C00BFFF0  lfs f0, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D8138: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 825D813C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825D8140: 419A0008  beq cr6, 0x825d8148
	if ctx.cr[6].eq {
	pc = 0x825D8148; continue 'dispatch;
	}
	// 825D8144: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825D8148: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D814C: 7D2ADA14  add r9, r10, r27
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 825D8150: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825D8154: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 825D8158: 419A0008  beq cr6, 0x825d8160
	if ctx.cr[6].eq {
	pc = 0x825D8160; continue 'dispatch;
	}
	// 825D815C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825D8160: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D8164: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825D8168: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825D816C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 825D8170: 419A0008  beq cr6, 0x825d8178
	if ctx.cr[6].eq {
	pc = 0x825D8178; continue 'dispatch;
	}
	// 825D8174: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825D8178: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D817C: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825D8180: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825D8184: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 825D8188: 419A0008  beq cr6, 0x825d8190
	if ctx.cr[6].eq {
	pc = 0x825D8190; continue 'dispatch;
	}
	// 825D818C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825D8190: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 825D8194: 7F6A4A14  add r27, r10, r9
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825D8198: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 825D819C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825D81A0: 409AFF94  bne cr6, 0x825d8134
	if !ctx.cr[6].eq {
	pc = 0x825D8134; continue 'dispatch;
	}
	// 825D81A4: 7F07C000  cmpw cr6, r7, r24
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[24].s32, &mut ctx.xer);
	// 825D81A8: 40980040  bge cr6, 0x825d81e8
	if !ctx.cr[6].lt {
	pc = 0x825D81E8; continue 'dispatch;
	}
	// 825D81AC: 81390000  lwz r9, 0(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D81B0: 54EA2036  slwi r10, r7, 4
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D81B4: 7D67C050  subf r11, r7, r24
	ctx.r[11].s64 = ctx.r[24].s64 - ctx.r[7].s64;
	// 825D81B8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825D81BC: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 825D81C0: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D81C4: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 825D81C8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825D81CC: 419A0008  beq cr6, 0x825d81d4
	if ctx.cr[6].eq {
	pc = 0x825D81D4; continue 'dispatch;
	}
	// 825D81D0: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 825D81D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825D81D8: 7F69DA14  add r27, r9, r27
	ctx.r[27].u64 = ctx.r[9].u64 + ctx.r[27].u64;
	// 825D81DC: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825D81E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D81E4: 409AFFDC  bne cr6, 0x825d81c0
	if !ctx.cr[6].eq {
	pc = 0x825D81C0; continue 'dispatch;
	}
	// 825D81E8: 2F1B0003  cmpwi cr6, r27, 3
	ctx.cr[6].compare_i32(ctx.r[27].s32, 3, &mut ctx.xer);
	// 825D81EC: 409902DC  ble cr6, 0x825d84c8
	if !ctx.cr[6].gt {
	pc = 0x825D84C8; continue 'dispatch;
	}
	// 825D81F0: 7D7FBA14  add r11, r31, r23
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[23].u64;
	// 825D81F4: 38610490  addi r3, r1, 0x490
	ctx.r[3].s64 = ctx.r[1].s64 + 1168;
	// 825D81F8: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825D81FC: 7FCB0194  addze r30, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[30].s64 = tmp.s64;
	// 825D8200: 48001119  bl 0x825d9318
	ctx.lr = 0x825D8204;
	sub_825D9318(ctx, base);
	// 825D8204: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8208: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D820C: 91610490  stw r11, 0x490(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1168 as u32), ctx.r[11].u32 ) };
	// 825D8210: 48001109  bl 0x825d9318
	ctx.lr = 0x825D8214;
	sub_825D9318(ctx, base);
	// 825D8214: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8218: 3B7E0001  addi r27, r30, 1
	ctx.r[27].s64 = ctx.r[30].s64 + 1;
	// 825D821C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 825D8220: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 825D8224: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 825D8228: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825D822C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D8230: 419A0044  beq cr6, 0x825d8274
	if ctx.cr[6].eq {
	pc = 0x825D8274; continue 'dispatch;
	}
	// 825D8234: 38E10490  addi r7, r1, 0x490
	ctx.r[7].s64 = ctx.r[1].s64 + 1168;
	// 825D8238: 93A10498  stw r29, 0x498(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1176 as u32), ctx.r[29].u32 ) };
	// 825D823C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825D8240: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D8244: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825D8248: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D824C: 4BFFFE75  bl 0x825d80c0
	ctx.lr = 0x825D8250;
	sub_825D80C0(ctx, base);
	// 825D8250: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825D8254: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 825D8258: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D825C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D8260: 38610490  addi r3, r1, 0x490
	ctx.r[3].s64 = ctx.r[1].s64 + 1168;
	// 825D8264: 4BFFBB45  bl 0x825d3da8
	ctx.lr = 0x825D8268;
	sub_825D3DA8(ctx, base);
	// 825D8268: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D826C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D8270: 409AFFC4  bne cr6, 0x825d8234
	if !ctx.cr[6].eq {
	pc = 0x825D8234; continue 'dispatch;
	}
	// 825D8274: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 825D8278: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 825D827C: 93A10088  stw r29, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[29].u32 ) };
	// 825D8280: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 825D8284: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825D8288: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825D828C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D8290: 4BFFFE31  bl 0x825d80c0
	ctx.lr = 0x825D8294;
	sub_825D80C0(ctx, base);
	// 825D8294: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825D8298: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 825D829C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 825D82A0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825D82A4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D82A8: 4BFFBB01  bl 0x825d3da8
	ctx.lr = 0x825D82AC;
	sub_825D3DA8(ctx, base);
	// 825D82AC: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D82B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D82B4: 409AFFC4  bne cr6, 0x825d8278
	if !ctx.cr[6].eq {
	pc = 0x825D8278; continue 'dispatch;
	}
	// 825D82B8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825D82BC: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 825D82C0: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 825D82C4: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 825D82C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D82CC: 38610490  addi r3, r1, 0x490
	ctx.r[3].s64 = ctx.r[1].s64 + 1168;
	// 825D82D0: 4BFFBAD9  bl 0x825d3da8
	ctx.lr = 0x825D82D4;
	sub_825D3DA8(ctx, base);
	// 825D82D4: 38E10051  addi r7, r1, 0x51
	ctx.r[7].s64 = ctx.r[1].s64 + 81;
	// 825D82D8: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 825D82DC: 9B810051  stb r28, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[28].u8 ) };
	// 825D82E0: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 825D82E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D82E8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D82EC: 4BFFBABD  bl 0x825d3da8
	ctx.lr = 0x825D82F0;
	sub_825D3DA8(ctx, base);
	// 825D82F0: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D82F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D82F8: 409A0014  bne cr6, 0x825d830c
	if !ctx.cr[6].eq {
	pc = 0x825D830C; continue 'dispatch;
	}
	// 825D82FC: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 825D8300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D8304: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825D8308: 419A0008  beq cr6, 0x825d8310
	if ctx.cr[6].eq {
	pc = 0x825D8310; continue 'dispatch;
	}
	// 825D830C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 825D8310: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 825D8314: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 825D8318: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D831C: 409AFF0C  bne cr6, 0x825d8228
	if !ctx.cr[6].eq {
	pc = 0x825D8228; continue 'dispatch;
	}
	// 825D8320: 81610498  lwz r11, 0x498(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1176 as u32) ) } as u64;
	// 825D8324: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D8328: 409A0094  bne cr6, 0x825d83bc
	if !ctx.cr[6].eq {
	pc = 0x825D83BC; continue 'dispatch;
	}
	// 825D832C: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 825D8330: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 825D8334: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D8338: 40990130  ble cr6, 0x825d8468
	if !ctx.cr[6].gt {
	pc = 0x825D8468; continue 'dispatch;
	}
	// 825D833C: 3BF60004  addi r31, r22, 4
	ctx.r[31].s64 = ctx.r[22].s64 + 4;
	// 825D8340: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825D8344: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D8348: 7FDD5A14  add r30, r29, r11
	ctx.r[30].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D834C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8350: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 825D8354: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825D8358: 409A0010  bne cr6, 0x825d8368
	if !ctx.cr[6].eq {
	pc = 0x825D8368; continue 'dispatch;
	}
	// 825D835C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825D8360: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8364: 4BE95FED  bl 0x8246e350
	ctx.lr = 0x825D8368;
	sub_8246E350(ctx, base);
	// 825D8368: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D836C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 825D8370: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8374: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 825D8378: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D837C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825D8380: A15E0000  lhz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8384: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 825D8388: A15E0002  lhz r10, 2(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D838C: B14B0002  sth r10, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[10].u16 ) };
	// 825D8390: A15E0004  lhz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8394: B14B0004  sth r10, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 825D8398: A15E0006  lhz r10, 6(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 825D839C: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 825D83A0: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 825D83A4: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D83A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D83AC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D83B0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825D83B4: 4198FF8C  blt cr6, 0x825d8340
	if ctx.cr[6].lt {
	pc = 0x825D8340; continue 'dispatch;
	}
	// 825D83B8: 480000B0  b 0x825d8468
	pc = 0x825D8468; continue 'dispatch;
	// 825D83BC: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 825D83C0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D83C4: 409A0090  bne cr6, 0x825d8454
	if !ctx.cr[6].eq {
	pc = 0x825D8454; continue 'dispatch;
	}
	// 825D83C8: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 825D83CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D83D0: 40990098  ble cr6, 0x825d8468
	if !ctx.cr[6].gt {
	pc = 0x825D8468; continue 'dispatch;
	}
	// 825D83D4: 3BF60004  addi r31, r22, 4
	ctx.r[31].s64 = ctx.r[22].s64 + 4;
	// 825D83D8: 81610494  lwz r11, 0x494(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1172 as u32) ) } as u64;
	// 825D83DC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D83E0: 7FDD5A14  add r30, r29, r11
	ctx.r[30].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D83E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D83E8: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 825D83EC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825D83F0: 409A0010  bne cr6, 0x825d8400
	if !ctx.cr[6].eq {
	pc = 0x825D8400; continue 'dispatch;
	}
	// 825D83F4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825D83F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D83FC: 4BE95F55  bl 0x8246e350
	ctx.lr = 0x825D8400;
	sub_8246E350(ctx, base);
	// 825D8400: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8404: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 825D8408: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D840C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 825D8410: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D8414: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825D8418: A15E0000  lhz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D841C: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 825D8420: A15E0002  lhz r10, 2(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D8424: B14B0002  sth r10, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[10].u16 ) };
	// 825D8428: A15E0004  lhz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D842C: B14B0004  sth r10, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 825D8430: A15E0006  lhz r10, 6(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 825D8434: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 825D8438: 81610498  lwz r11, 0x498(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1176 as u32) ) } as u64;
	// 825D843C: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D8440: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8444: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D8448: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825D844C: 4198FF8C  blt cr6, 0x825d83d8
	if ctx.cr[6].lt {
	pc = 0x825D83D8; continue 'dispatch;
	}
	// 825D8450: 48000018  b 0x825d8468
	pc = 0x825D8468; continue 'dispatch;
	// 825D8454: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 825D8458: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 825D845C: 38810490  addi r4, r1, 0x490
	ctx.r[4].s64 = ctx.r[1].s64 + 1168;
	// 825D8460: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D8464: 4BFFF45D  bl 0x825d78c0
	ctx.lr = 0x825D8468;
	sub_825D78C0(ctx, base);
	// 825D8468: 81760008  lwz r11, 8(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D846C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D8470: 409A0010  bne cr6, 0x825d8480
	if !ctx.cr[6].eq {
	pc = 0x825D8480; continue 'dispatch;
	}
	// 825D8474: 38810494  addi r4, r1, 0x494
	ctx.r[4].s64 = ctx.r[1].s64 + 1172;
	// 825D8478: 38760004  addi r3, r22, 4
	ctx.r[3].s64 = ctx.r[22].s64 + 4;
	// 825D847C: 4800089D  bl 0x825d8d18
	ctx.lr = 0x825D8480;
	sub_825D8D18(ctx, base);
	// 825D8480: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825D8484: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825D8488: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D848C: 409A0020  bne cr6, 0x825d84ac
	if !ctx.cr[6].eq {
	pc = 0x825D84AC; continue 'dispatch;
	}
	// 825D8490: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8494: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825D8498: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825D849C: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825D84A0: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825D84A4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825D84A8: 4BE8BC11  bl 0x824640b8
	ctx.lr = 0x825D84AC;
	sub_824640B8(ctx, base);
	// 825D84AC: 8161049C  lwz r11, 0x49c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1180 as u32) ) } as u64;
	// 825D84B0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825D84B4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D84B8: 409A010C  bne cr6, 0x825d85c4
	if !ctx.cr[6].eq {
	pc = 0x825D85C4; continue 'dispatch;
	}
	// 825D84BC: 80810494  lwz r4, 0x494(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1172 as u32) ) } as u64;
	// 825D84C0: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825D84C4: 480000EC  b 0x825d85b0
	pc = 0x825D85B0; continue 'dispatch;
	// 825D84C8: 3D208000  lis r9, -0x8000
	ctx.r[9].s64 = -2147483648;
	// 825D84CC: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D84D0: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 825D84D4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825D84D8: 61290003  ori r9, r9, 3
	ctx.r[9].u64 = ctx.r[9].u64 | 3;
	// 825D84DC: 7F1FC000  cmpw cr6, r31, r24
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[24].s32, &mut ctx.xer);
	// 825D84E0: 91560000  stw r10, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D84E4: 90810060  stw r4, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[4].u32 ) };
	// 825D84E8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825D84EC: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 825D84F0: 40980068  bge cr6, 0x825d8558
	if !ctx.cr[6].lt {
	pc = 0x825D8558; continue 'dispatch;
	}
	// 825D84F4: 57FE2036  slwi r30, r31, 4
	ctx.r[30].u32 = ctx.r[31].u32.wrapping_shl(4);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 825D84F8: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D84FC: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 825D8500: C00A000C  lfs f0, 0xc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D8504: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825D8508: 409A0040  bne cr6, 0x825d8548
	if !ctx.cr[6].eq {
	pc = 0x825D8548; continue 'dispatch;
	}
	// 825D850C: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825D8510: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 825D8514: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825D8518: 409A0018  bne cr6, 0x825d8530
	if !ctx.cr[6].eq {
	pc = 0x825D8530; continue 'dispatch;
	}
	// 825D851C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 825D8520: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D8524: 4BE95E2D  bl 0x8246e350
	ctx.lr = 0x825D8528;
	sub_8246E350(ctx, base);
	// 825D8528: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D852C: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D8530: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D8534: 7FEB212E  stwx r31, r11, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), ctx.r[31].u32) };
	// 825D8538: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D853C: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D8540: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D8544: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825D8548: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825D854C: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 825D8550: 7F1FC000  cmpw cr6, r31, r24
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[24].s32, &mut ctx.xer);
	// 825D8554: 4198FFA4  blt cr6, 0x825d84f8
	if ctx.cr[6].lt {
	pc = 0x825D84F8; continue 'dispatch;
	}
	// 825D8558: 2B1B0001  cmplwi cr6, r27, 1
	ctx.cr[6].compare_u32(ctx.r[27].u32, 1 as u32, &mut ctx.xer);
	// 825D855C: 41980040  blt cr6, 0x825d859c
	if ctx.cr[6].lt {
	pc = 0x825D859C; continue 'dispatch;
	}
	// 825D8560: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 825D8564: 419A002C  beq cr6, 0x825d8590
	if ctx.cr[6].eq {
	pc = 0x825D8590; continue 'dispatch;
	}
	// 825D8568: 80A40004  lwz r5, 4(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D856C: 2B1B0003  cmplwi cr6, r27, 3
	ctx.cr[6].compare_u32(ctx.r[27].u32, 3 as u32, &mut ctx.xer);
	// 825D8570: 41980014  blt cr6, 0x825d8584
	if ctx.cr[6].lt {
	pc = 0x825D8584; continue 'dispatch;
	}
	// 825D8574: 80C40008  lwz r6, 8(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D8578: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D857C: 480009ED  bl 0x825d8f68
	ctx.lr = 0x825D8580;
	sub_825D8F68(ctx, base);
	// 825D8580: 48000018  b 0x825d8598
	pc = 0x825D8598; continue 'dispatch;
	// 825D8584: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8588: 48000911  bl 0x825d8e98
	ctx.lr = 0x825D858C;
	sub_825D8E98(ctx, base);
	// 825D858C: 4800000C  b 0x825d8598
	pc = 0x825D8598; continue 'dispatch;
	// 825D8590: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8594: 48000885  bl 0x825d8e18
	ctx.lr = 0x825D8598;
	sub_825D8E18(ctx, base);
	// 825D8598: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D859C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825D85A0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825D85A4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D85A8: 409A001C  bne cr6, 0x825d85c4
	if !ctx.cr[6].eq {
	pc = 0x825D85C4; continue 'dispatch;
	}
	// 825D85AC: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825D85B0: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D85B4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825D85B8: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825D85BC: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825D85C0: 4BE8BAF9  bl 0x824640b8
	ctx.lr = 0x825D85C4;
	sub_824640B8(ctx, base);
	// 825D85C4: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825D85C8: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 825D85CC: 4BF5CB24  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D85D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D85D0 size=496
    let mut pc: u32 = 0x825D85D0;
    'dispatch: loop {
        match pc {
            0x825D85D0 => {
    //   block [0x825D85D0..0x825D87C0)
	// 825D85D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D85D4: 4BF5CADD  bl 0x825350b0
	ctx.lr = 0x825D85D8;
	sub_82535080(ctx, base);
	// 825D85D8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 825D85DC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D85E0: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 825D85E4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 825D85E8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825D85EC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825D85F0: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825D85F4: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 825D85F8: 4099005C  ble cr6, 0x825d8654
	if !ctx.cr[6].gt {
	pc = 0x825D8654; continue 'dispatch;
	}
	// 825D85FC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825D8600: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825D8604: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D8608: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D860C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D8610: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D8614: 409A0010  bne cr6, 0x825d8624
	if !ctx.cr[6].eq {
	pc = 0x825D8624; continue 'dispatch;
	}
	// 825D8618: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 825D861C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8620: 4BE95D31  bl 0x8246e350
	ctx.lr = 0x825D8624;
	sub_8246E350(ctx, base);
	// 825D8624: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8628: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 825D862C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8630: 556A2036  slwi r10, r11, 4
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D8634: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 825D8638: 7D6A4A14  add r11, r10, r9
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825D863C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825D8640: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D87C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D87C0 size=1028
    let mut pc: u32 = 0x825D87C0;
    'dispatch: loop {
        match pc {
            0x825D87C0 => {
    //   block [0x825D87C0..0x825D8BC4)
	// 825D87C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D87C4: 4BF5C8E5  bl 0x825350a8
	ctx.lr = 0x825D87C8;
	sub_82535080(ctx, base);
	// 825D87C8: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 825D87CC: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 825D87D0: 9421EAC0  stwu r1, -0x1540(r1)
	ea = ctx.r[1].u32.wrapping_add(-5440 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D87D4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825D87D8: 3947FFFE  addi r10, r7, -2
	ctx.r[10].s64 = ctx.r[7].s64 + -2;
	// 825D87DC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825D87E0: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 825D87E4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825D87E8: C00BA074  lfs f0, -0x5f8c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24460 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D87EC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825D87F0: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825D87F4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 825D87F8: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 825D87FC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825D8800: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825D8804: 9BC10060  stb r30, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u8 ) };
	// 825D8808: 9BC10061  stb r30, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[30].u8 ) };
	// 825D880C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 825D8810: C3EB2150  lfs f31, 0x2150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8528 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825D8814: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825D8818: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825D881C: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825D8820: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825D8824: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 825D8828: C1AB2298  lfs f13, 0x2298(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8856 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D882C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D8830: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825D8834: D1A1008C  stfs f13, 0x8c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 825D8838: C18B2954  lfs f12, 0x2954(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10580 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D883C: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825D8840: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 825D8844: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825D8848: 61590040  ori r25, r10, 0x40
	ctx.r[25].u64 = ctx.r[10].u64 | 64;
	// 825D884C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825D8850: 99610062  stb r11, 0x62(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[11].u8 ) };
	// 825D8854: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 825D8858: 932100B8  stw r25, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[25].u32 ) };
	// 825D885C: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 825D8860: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825D8864: C18B2784  lfs f12, 0x2784(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10116 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D8868: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825D886C: D1810080  stfs f12, 0x80(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 825D8870: C18A20AC  lfs f12, 0x20ac(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8364 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D8874: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825D8878: D1810088  stfs f12, 0x88(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 825D887C: 916100B4  stw r11, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 825D8880: C00AA070  lfs f0, -0x5f90(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24464 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D8884: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825D8888: 40990084  ble cr6, 0x825d890c
	if !ctx.cr[6].gt {
	pc = 0x825D890C; continue 'dispatch;
	}
	// 825D888C: 7F1AC378  mr r26, r24
	ctx.r[26].u64 = ctx.r[24].u64;
	// 825D8890: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 825D8894: 48000008  b 0x825d889c
	pc = 0x825D889C; continue 'dispatch;
	// 825D8898: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 825D889C: 814100B8  lwz r10, 0xb8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 825D88A0: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 825D88A4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825D88A8: 409A0014  bne cr6, 0x825d88bc
	if !ctx.cr[6].eq {
	pc = 0x825D88BC; continue 'dispatch;
	}
	// 825D88AC: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 825D88B0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825D88B4: 4BE95A9D  bl 0x8246e350
	ctx.lr = 0x825D88B8;
	sub_8246E350(ctx, base);
	// 825D88B8: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 825D88BC: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 825D88C0: 556A2036  slwi r10, r11, 4
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D88C4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8BC8 size=336
    let mut pc: u32 = 0x825D8BC8;
    'dispatch: loop {
        match pc {
            0x825D8BC8 => {
    //   block [0x825D8BC8..0x825D8D18)
	// 825D8BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D8BCC: 4BF5C4E1  bl 0x825350ac
	ctx.lr = 0x825D8BD0;
	sub_82535080(ctx, base);
	// 825D8BD0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8BD4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825D8BD8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825D8BDC: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 825D8BE0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825D8BE4: 7D7ACA14  add r11, r26, r25
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[25].u64;
	// 825D8BE8: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 825D8BEC: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825D8BF0: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 825D8BF4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D8BF8: 7D6BD82A  ldx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) };
	// 825D8BFC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 825D8C00: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D8C04: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825D8C08: 7FCBDA14  add r30, r11, r27
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 825D8C0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D8C10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D8C14: 7F8903A6  mtctr r28
	ctx.ctr.u64 = ctx.r[28].u64;
	// 825D8C18: 4E800421  bctrl
	ctx.lr = 0x825D8C1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D8C1C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8C20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D8C24: 419A002C  beq cr6, 0x825d8c50
	if ctx.cr[6].eq {
	pc = 0x825D8C50; continue 'dispatch;
	}
	// 825D8C28: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825D8C2C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825D8C30: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825D8C34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D8C38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D8C3C: 7F8903A6  mtctr r28
	ctx.ctr.u64 = ctx.r[28].u64;
	// 825D8C40: 4E800421  bctrl
	ctx.lr = 0x825D8C44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D8C44: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8C48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D8C4C: 409AFFDC  bne cr6, 0x825d8c28
	if !ctx.cr[6].eq {
	pc = 0x825D8C28; continue 'dispatch;
	}
	// 825D8C50: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D8C54: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825D8C58: 7FCBDA14  add r30, r11, r27
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 825D8C5C: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 825D8C60: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D8C64: 7F8903A6  mtctr r28
	ctx.ctr.u64 = ctx.r[28].u64;
	// 825D8C68: 4E800421  bctrl
	ctx.lr = 0x825D8C6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D8C6C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8C70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D8C74: 419A002C  beq cr6, 0x825d8ca0
	if ctx.cr[6].eq {
	pc = 0x825D8CA0; continue 'dispatch;
	}
	// 825D8C78: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 825D8C7C: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 825D8C80: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825D8C84: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 825D8C88: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D8C8C: 7F8903A6  mtctr r28
	ctx.ctr.u64 = ctx.r[28].u64;
	// 825D8C90: 4E800421  bctrl
	ctx.lr = 0x825D8C94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D8C94: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8C98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D8C9C: 409AFFDC  bne cr6, 0x825d8c78
	if !ctx.cr[6].eq {
	pc = 0x825D8C78; continue 'dispatch;
	}
	// 825D8CA0: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 825D8CA4: 41980040  blt cr6, 0x825d8ce4
	if ctx.cr[6].lt {
	pc = 0x825D8CE4; continue 'dispatch;
	}
	// 825D8CA8: 419A002C  beq cr6, 0x825d8cd4
	if ctx.cr[6].eq {
	pc = 0x825D8CD4; continue 'dispatch;
	}
	// 825D8CAC: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D8CB0: 57EA1838  slwi r10, r31, 3
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D8CB4: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 825D8CB8: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 825D8CBC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8CC0: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 825D8CC4: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825D8CC8: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8CCC: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825D8CD0: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 825D8CD4: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 825D8CD8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825D8CDC: 7F1DF800  cmpw cr6, r29, r31
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[31].s32, &mut ctx.xer);
	// 825D8CE0: 4099FF20  ble cr6, 0x825d8c00
	if !ctx.cr[6].gt {
	pc = 0x825D8C00; continue 'dispatch;
	}
	// 825D8CE4: 7F1AF800  cmpw cr6, r26, r31
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[31].s32, &mut ctx.xer);
	// 825D8CE8: 40980018  bge cr6, 0x825d8d00
	if !ctx.cr[6].lt {
	pc = 0x825D8D00; continue 'dispatch;
	}
	// 825D8CEC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825D8CF0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D8CF4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825D8CF8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825D8CFC: 4BFFFECD  bl 0x825d8bc8
	ctx.lr = 0x825D8D00;
	sub_825D8BC8(ctx, base);
	// 825D8D00: 7F1DC800  cmpw cr6, r29, r25
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[25].s32, &mut ctx.xer);
	// 825D8D04: 4098000C  bge cr6, 0x825d8d10
	if !ctx.cr[6].lt {
	pc = 0x825D8D10; continue 'dispatch;
	}
	// 825D8D08: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 825D8D0C: 4BFFFED8  b 0x825d8be4
	pc = 0x825D8BE4; continue 'dispatch;
	// 825D8D10: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825D8D14: 4BF5C3E8  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8D18 size=252
    let mut pc: u32 = 0x825D8D18;
    'dispatch: loop {
        match pc {
            0x825D8D18 => {
    //   block [0x825D8D18..0x825D8E14)
	// 825D8D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D8D1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D8D20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D8D24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D8D28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8D2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D8D30: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D8D34: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D8D38: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8D3C: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D8D40: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825D8D44: 40980060  bge cr6, 0x825d8da4
	if !ctx.cr[6].lt {
	pc = 0x825D8DA4; continue 'dispatch;
	}
	// 825D8D48: 556B0000  rlwinm r11, r11, 0, 0, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825D8D4C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D8D50: 409A0020  bne cr6, 0x825d8d70
	if !ctx.cr[6].eq {
	pc = 0x825D8D70; continue 'dispatch;
	}
	// 825D8D54: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8D58: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825D8D5C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825D8D60: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8D64: 55451838  slwi r5, r10, 3
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825D8D68: 7C69582E  lwzx r3, r9, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825D8D6C: 4BE8B34D  bl 0x824640b8
	ctx.lr = 0x825D8D70;
	sub_824640B8(ctx, base);
	// 825D8D70: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8D74: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 825D8D78: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8D7C: 38A00017  li r5, 0x17
	ctx.r[5].s64 = 23;
	// 825D8D80: 55241838  slwi r4, r9, 3
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 825D8D84: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825D8D88: 4BE8B2B1  bl 0x82464038
	ctx.lr = 0x825D8D8C;
	sub_82464038(ctx, base);
	// 825D8D8C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D8D90: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 825D8D94: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8D98: 556B0042  rlwinm r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825D8D9C: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 825D8DA0: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825D8DA4: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8DA8: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8DAC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825D8DB0: 911E0004  stw r8, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825D8DB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8DB8: 40990040  ble cr6, 0x825d8df8
	if !ctx.cr[6].gt {
	pc = 0x825D8DF8; continue 'dispatch;
	}
	// 825D8DBC: 7CE95850  subf r7, r9, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825D8DC0: 7D474A14  add r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 825D8DC4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825D8DC8: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 825D8DCC: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 825D8DD0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825D8DD4: A0CA0000  lhz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8DD8: B0CB0000  sth r6, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u16 ) };
	// 825D8DDC: A0CA0002  lhz r6, 2(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D8DE0: B0CB0002  sth r6, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[6].u16 ) };
	// 825D8DE4: A0CA0004  lhz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8DE8: B0CB0004  sth r6, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u16 ) };
	// 825D8DEC: A14A0006  lhz r10, 6(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 825D8DF0: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 825D8DF4: 409AFFCC  bne cr6, 0x825d8dc0
	if !ctx.cr[6].eq {
	pc = 0x825D8DC0; continue 'dispatch;
	}
	// 825D8DF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D8DFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D8E00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D8E04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D8E08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D8E0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D8E10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8E18 size=124
    let mut pc: u32 = 0x825D8E18;
    'dispatch: loop {
        match pc {
            0x825D8E18 => {
    //   block [0x825D8E18..0x825D8E94)
	// 825D8E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D8E1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D8E20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D8E24: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8E28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D8E2C: B0810050  sth r4, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u16 ) };
	// 825D8E30: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 825D8E34: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825D8E38: B1610052  sth r11, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	// 825D8E3C: B1610054  sth r11, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u16 ) };
	// 825D8E40: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D8E44: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8E48: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D8E4C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D8E50: 409A0010  bne cr6, 0x825d8e60
	if !ctx.cr[6].eq {
	pc = 0x825D8E60; continue 'dispatch;
	}
	// 825D8E54: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825D8E58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8E5C: 4BE954F5  bl 0x8246e350
	ctx.lr = 0x825D8E60;
	sub_8246E350(ctx, base);
	// 825D8E60: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8E64: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825D8E68: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8E6C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D8E70: 7D4B492A  stdx r10, r11, r9
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u64) };
	// 825D8E74: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8E78: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D8E7C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825D8E80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D8E84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D8E88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D8E8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D8E90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8E98 size=204
    let mut pc: u32 = 0x825D8E98;
    'dispatch: loop {
        match pc {
            0x825D8E98 => {
    //   block [0x825D8E98..0x825D8F64)
	// 825D8E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D8E9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D8EA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D8EA4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8EA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D8EAC: B0810050  sth r4, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u16 ) };
	// 825D8EB0: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 825D8EB4: B0A10058  sth r5, 0x58(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u16 ) };
	// 825D8EB8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D8EBC: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825D8EC0: B161005A  sth r11, 0x5a(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u16 ) };
	// 825D8EC4: B161005C  sth r11, 0x5c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u16 ) };
	// 825D8EC8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D8ECC: B1410052  sth r10, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u16 ) };
	// 825D8ED0: B1410054  sth r10, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u16 ) };
	// 825D8ED4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D8ED8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8EDC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D8EE0: 409A0010  bne cr6, 0x825d8ef0
	if !ctx.cr[6].eq {
	pc = 0x825D8EF0; continue 'dispatch;
	}
	// 825D8EE4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825D8EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8EEC: 4BE95465  bl 0x8246e350
	ctx.lr = 0x825D8EF0;
	sub_8246E350(ctx, base);
	// 825D8EF0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8EF4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8EF8: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825D8EFC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D8F00: 7D2B512A  stdx r9, r11, r10
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u64) };
	// 825D8F04: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8F08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D8F0C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825D8F10: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D8F14: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8F18: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D8F1C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D8F20: 409A0010  bne cr6, 0x825d8f30
	if !ctx.cr[6].eq {
	pc = 0x825D8F30; continue 'dispatch;
	}
	// 825D8F24: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825D8F28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8F2C: 4BE95425  bl 0x8246e350
	ctx.lr = 0x825D8F30;
	sub_8246E350(ctx, base);
	// 825D8F30: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8F34: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825D8F38: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8F3C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D8F40: 7D4B492A  stdx r10, r11, r9
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u64) };
	// 825D8F44: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8F48: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D8F4C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825D8F50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D8F54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D8F58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D8F5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D8F60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8F68 size=944
    let mut pc: u32 = 0x825D8F68;
    'dispatch: loop {
        match pc {
            0x825D8F68 => {
    //   block [0x825D8F68..0x825D9318)
	// 825D8F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D8F6C: 4BF5C13D  bl 0x825350a8
	ctx.lr = 0x825D8F70;
	sub_82535080(ctx, base);
	// 825D8F70: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8F74: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 825D8F78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8F7C: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 825D8F80: 550A2036  slwi r10, r8, 4
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D8F84: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825D8F88: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825D8F8C: 54DF2036  slwi r31, r6, 4
	ctx.r[31].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 825D8F90: 553D2036  slwi r29, r9, 4
	ctx.r[29].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 825D8F94: 7FFF5A14  add r31, r31, r11
	ctx.r[31].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 825D8F98: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 825D8F9C: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D8FA0: EBAA0000  ld r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 825D8FA4: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 825D8FA8: EB0A0008  ld r24, 8(r10)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 825D8FAC: 3B810068  addi r28, r1, 0x68
	ctx.r[28].s64 = ctx.r[1].s64 + 104;
	// 825D8FB0: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 825D8FB4: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9318 size=112
    let mut pc: u32 = 0x825D9318;
    'dispatch: loop {
        match pc {
            0x825D9318 => {
    //   block [0x825D9318..0x825D9388)
	// 825D9318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D931C: 4BF5BDA1  bl 0x825350bc
	ctx.lr = 0x825D9320;
	sub_82535080(ctx, base);
	// 825D9320: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9324: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D9328: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 825D932C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D9330: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 825D9334: 616B0080  ori r11, r11, 0x80
	ctx.r[11].u64 = ctx.r[11].u64 | 128;
	// 825D9338: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 825D933C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825D9340: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825D9344: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825D9348: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D934C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D9350: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D9354: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D9358: 40980020  bge cr6, 0x825d9378
	if !ctx.cr[6].lt {
	pc = 0x825D9378; continue 'dispatch;
	}
	// 825D935C: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 825D9360: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 825D9364: 41990008  bgt cr6, 0x825d936c
	if ctx.cr[6].gt {
	pc = 0x825D936C; continue 'dispatch;
	}
	// 825D9368: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D936C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825D9370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9374: 4BE94F55  bl 0x8246e2c8
	ctx.lr = 0x825D9378;
	sub_8246E2C8(ctx, base);
	// 825D9378: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D937C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825D9380: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D9384: 4BF5BD88  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9388 size=276
    let mut pc: u32 = 0x825D9388;
    'dispatch: loop {
        match pc {
            0x825D9388 => {
    //   block [0x825D9388..0x825D949C)
	// 825D9388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D938C: 4BF5BD29  bl 0x825350b4
	ctx.lr = 0x825D9390;
	sub_82535080(ctx, base);
	// 825D9390: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 825D9394: 9421EF70  stwu r1, -0x1090(r1)
	ea = ctx.r[1].u32.wrapping_add(-4240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9398: 3961005C  addi r11, r1, 0x5c
	ctx.r[11].s64 = ctx.r[1].s64 + 92;
	// 825D939C: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D93A0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825D93A4: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 825D93A8: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 825D93AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825D93B0: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 825D93B4: 616B0400  ori r11, r11, 0x400
	ctx.r[11].u64 = ctx.r[11].u64 | 1024;
	// 825D93B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825D93BC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D93C0: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D93C4: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D93C8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825D93CC: 838BFFFC  lwz r28, -4(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 825D93D0: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 825D93D4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D93D8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 825D93DC: A16B0004  lhz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D93E0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D93E4: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825D93E8: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825D93EC: B36B0006  sth r27, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[27].u16 ) };
	// 825D93F0: 409AFFEC  bne cr6, 0x825d93dc
	if !ctx.cr[6].eq {
	pc = 0x825D93DC; continue 'dispatch;
	}
	// 825D93F4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D93F8: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 825D93FC: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D9400: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D9404: 7FEBEA14  add r31, r11, r29
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825D9408: A17F0002  lhz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D940C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825D9410: 7FCBEA14  add r30, r11, r29
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825D9414: A17E0006  lhz r11, 6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 825D9418: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D941C: 409A003C  bne cr6, 0x825d9458
	if !ctx.cr[6].eq {
	pc = 0x825D9458; continue 'dispatch;
	}
	// 825D9420: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825D9424: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825D9428: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D942C: 409A0014  bne cr6, 0x825d9440
	if !ctx.cr[6].eq {
	pc = 0x825D9440; continue 'dispatch;
	}
	// 825D9430: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 825D9434: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D9438: 4BE94F19  bl 0x8246e350
	ctx.lr = 0x825D943C;
	sub_8246E350(ctx, base);
	// 825D943C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D9440: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D9444: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D9448: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 825D944C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D9450: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 825D9454: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825D9458: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825D945C: 409AFFA0  bne cr6, 0x825d93fc
	if !ctx.cr[6].eq {
	pc = 0x825D93FC; continue 'dispatch;
	}
	// 825D9460: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D9464: 409AFF5C  bne cr6, 0x825d93c0
	if !ctx.cr[6].eq {
	pc = 0x825D93C0; continue 'dispatch;
	}
	// 825D9468: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825D946C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825D9470: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D9474: 409A0020  bne cr6, 0x825d9494
	if !ctx.cr[6].eq {
	pc = 0x825D9494; continue 'dispatch;
	}
	// 825D9478: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D947C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825D9480: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825D9484: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D9488: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825D948C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825D9490: 4BE8AC29  bl 0x824640b8
	ctx.lr = 0x825D9494;
	sub_824640B8(ctx, base);
	// 825D9494: 38211090  addi r1, r1, 0x1090
	ctx.r[1].s64 = ctx.r[1].s64 + 4240;
	// 825D9498: 4BF5BC6C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D94A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D94A0 size=536
    let mut pc: u32 = 0x825D94A0;
    'dispatch: loop {
        match pc {
            0x825D94A0 => {
    //   block [0x825D94A0..0x825D96B8)
	// 825D94A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D94A4: 4BF5BC19  bl 0x825350bc
	ctx.lr = 0x825D94A8;
	sub_82535080(ctx, base);
	// 825D94A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D94AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D94B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D94B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D94B8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D94BC: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D94C0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825D94C4: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D94C8: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825D94CC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825D94D0: 409900E8  ble cr6, 0x825d95b8
	if !ctx.cr[6].gt {
	pc = 0x825D95B8; continue 'dispatch;
	}
	// 825D94D4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825D94D8: 38E60002  addi r7, r6, 2
	ctx.r[7].s64 = ctx.r[6].s64 + 2;
	// 825D94DC: A1070000  lhz r8, 0(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D94E0: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825D94E4: 41980010  blt cr6, 0x825d94f4
	if ctx.cr[6].lt {
	pc = 0x825D94F4; continue 'dispatch;
	}
	// 825D94E8: 7F082800  cmpw cr6, r8, r5
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825D94EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D94F0: 41980008  blt cr6, 0x825d94f8
	if ctx.cr[6].lt {
	pc = 0x825D94F8; continue 'dispatch;
	}
	// 825D94F4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825D94F8: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 825D94FC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D9500: 419A0014  beq cr6, 0x825d9514
	if ctx.cr[6].eq {
	pc = 0x825D9514; continue 'dispatch;
	}
	// 825D9504: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825D9508: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D950C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D9510: 409A0008  bne cr6, 0x825d9518
	if !ctx.cr[6].eq {
	pc = 0x825D9518; continue 'dispatch;
	}
	// 825D9514: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825D9518: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825D951C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D9520: 419A001C  beq cr6, 0x825d953c
	if ctx.cr[6].eq {
	pc = 0x825D953C; continue 'dispatch;
	}
	// 825D9524: 550B1838  slwi r11, r8, 3
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D9528: 7D6B3214  add r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 825D952C: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D9530: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825D9534: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D9538: 419A0008  beq cr6, 0x825d9540
	if ctx.cr[6].eq {
	pc = 0x825D9540; continue 'dispatch;
	}
	// 825D953C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825D9540: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D9544: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 825D9548: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 825D954C: 7F0A2800  cmpw cr6, r10, r5
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825D9550: 4198FF8C  blt cr6, 0x825d94dc
	if ctx.cr[6].lt {
	pc = 0x825D94DC; continue 'dispatch;
	}
	// 825D9554: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825D9558: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825D955C: 4099005C  ble cr6, 0x825d95b8
	if !ctx.cr[6].gt {
	pc = 0x825D95B8; continue 'dispatch;
	}
	// 825D9560: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825D9564: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825D9568: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 825D956C: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 825D9570: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D9574: 419A002C  beq cr6, 0x825d95a0
	if ctx.cr[6].eq {
	pc = 0x825D95A0; continue 'dispatch;
	}
	// 825D9578: A14B0002  lhz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D957C: A10B0000  lhz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9580: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825D9584: 7D4A3214  add r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 825D9588: A14A0004  lhz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D958C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825D9590: 7D4A322E  lhzx r10, r10, r6
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 825D9594: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825D9598: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D959C: 419A0008  beq cr6, 0x825d95a4
	if ctx.cr[6].eq {
	pc = 0x825D95A4; continue 'dispatch;
	}
	// 825D95A0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825D95A4: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825D95A8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825D95AC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825D95B0: 409AFFBC  bne cr6, 0x825d956c
	if !ctx.cr[6].eq {
	pc = 0x825D956C; continue 'dispatch;
	}
	// 825D95B4: 995E0000  stb r10, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825D95B8: 2F050002  cmpwi cr6, r5, 2
	ctx.cr[6].compare_i32(ctx.r[5].s32, 2, &mut ctx.xer);
	// 825D95BC: 40990064  ble cr6, 0x825d9620
	if !ctx.cr[6].gt {
	pc = 0x825D9620; continue 'dispatch;
	}
	// 825D95C0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825D95C4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825D95C8: 40990058  ble cr6, 0x825d9620
	if !ctx.cr[6].gt {
	pc = 0x825D9620; continue 'dispatch;
	}
	// 825D95CC: 893E0000  lbz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D95D0: 39460004  addi r10, r6, 4
	ctx.r[10].s64 = ctx.r[6].s64 + 4;
	// 825D95D4: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 825D95D8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D95DC: 419A002C  beq cr6, 0x825d9608
	if ctx.cr[6].eq {
	pc = 0x825D9608; continue 'dispatch;
	}
	// 825D95E0: A12A0000  lhz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D95E4: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825D95E8: 7D293214  add r9, r9, r6
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[6].u64;
	// 825D95EC: A1290004  lhz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D95F0: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825D95F4: 7D293214  add r9, r9, r6
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[6].u64;
	// 825D95F8: A1290004  lhz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D95FC: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825D9600: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825D9604: 419A0008  beq cr6, 0x825d960c
	if ctx.cr[6].eq {
	pc = 0x825D960C; continue 'dispatch;
	}
	// 825D9608: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 825D960C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D9610: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825D9614: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825D9618: 4198FFBC  blt cr6, 0x825d95d4
	if ctx.cr[6].lt {
	pc = 0x825D95D4; continue 'dispatch;
	}
	// 825D961C: 993E0000  stb r9, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 825D9620: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825D9624: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825D9628: 40990028  ble cr6, 0x825d9650
	if !ctx.cr[6].gt {
	pc = 0x825D9650; continue 'dispatch;
	}
	// 825D962C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825D9630: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D9634: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D9638: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825D963C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825D9640: B3A90006  sth r29, 6(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(6 as u32), ctx.r[29].u16 ) };
	// 825D9644: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D9648: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825D964C: 4198FFE4  blt cr6, 0x825d9630
	if ctx.cr[6].lt {
	pc = 0x825D9630; continue 'dispatch;
	}
	// 825D9650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9654: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D9658: 4BFFFD31  bl 0x825d9388
	ctx.lr = 0x825D965C;
	sub_825D9388(ctx, base);
	// 825D965C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D9660: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D9664: 40990048  ble cr6, 0x825d96ac
	if !ctx.cr[6].gt {
	pc = 0x825D96AC; continue 'dispatch;
	}
	// 825D9668: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D966C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825D9670: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 825D9674: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D9678: 419A001C  beq cr6, 0x825d9694
	if ctx.cr[6].eq {
	pc = 0x825D9694; continue 'dispatch;
	}
	// 825D967C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D9680: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825D9684: A14A0006  lhz r10, 6(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 825D9688: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825D968C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D9690: 419A0008  beq cr6, 0x825d9698
	if ctx.cr[6].eq {
	pc = 0x825D9698; continue 'dispatch;
	}
	// 825D9694: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825D9698: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825D969C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825D96A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825D96A4: 409AFFCC  bne cr6, 0x825d9670
	if !ctx.cr[6].eq {
	pc = 0x825D9670; continue 'dispatch;
	}
	// 825D96A8: 995E0000  stb r10, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825D96AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D96B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D96B4: 4BF5BA58  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D96B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D96B8 size=1184
    let mut pc: u32 = 0x825D96B8;
    'dispatch: loop {
        match pc {
            0x825D96B8 => {
    //   block [0x825D96B8..0x825D9B58)
	// 825D96B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D96BC: 4BF5B9C5  bl 0x82535080
	ctx.lr = 0x825D96C0;
	sub_82535080(ctx, base);
	// 825D96C0: 550B1838  slwi r11, r8, 3
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D96C4: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 825D96C8: 90C1002C  stw r6, 0x2c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(44 as u32), ctx.r[6].u32 ) };
	// 825D96CC: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 825D96D0: 90E10034  stw r7, 0x34(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(52 as u32), ctx.r[7].u32 ) };
	// 825D96D4: 7F4B3A14  add r26, r11, r7
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 825D96D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D96DC: 81050000  lwz r8, 0(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D96E0: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825D96E4: 40990234  ble cr6, 0x825d9918
	if !ctx.cr[6].gt {
	pc = 0x825D9918; continue 'dispatch;
	}
	// 825D96E8: 83650010  lwz r27, 0x10(r5)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 825D96EC: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825D96F0: 40980214  bge cr6, 0x825d9904
	if !ctx.cr[6].lt {
	pc = 0x825D9904; continue 'dispatch;
	}
	// 825D96F4: 39630024  addi r11, r3, 0x24
	ctx.r[11].s64 = ctx.r[3].s64 + 36;
	// 825D96F8: 81050018  lwz r8, 0x18(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) } as u64;
	// 825D96FC: 83E50014  lwz r31, 0x14(r5)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) } as u64;
	// 825D9700: 80EB0040  lwz r7, 0x40(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 825D9704: 80CB0044  lwz r6, 0x44(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 825D9708: 7CE7F850  subf r7, r7, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[7].s64;
	// 825D970C: 808B0020  lwz r4, 0x20(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 825D9710: 7CC64050  subf r6, r6, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[6].s64;
	// 825D9714: 838B0024  lwz r28, 0x24(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825D9718: 83C50004  lwz r30, 4(r5)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D971C: 7C84F850  subf r4, r4, r31
	ctx.r[4].s64 = ctx.r[31].s64 - ctx.r[4].s64;
	// 825D9720: 832B0050  lwz r25, 0x50(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D9724: 7CE73378  or r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 825D9728: 830B0004  lwz r24, 4(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D972C: 7F9C4050  subf r28, r28, r8
	ctx.r[28].s64 = ctx.r[8].s64 - ctx.r[28].s64;
	// 825D9730: 82EB0010  lwz r23, 0x10(r11)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825D9734: 7CDEC850  subf r6, r30, r25
	ctx.r[6].s64 = ctx.r[25].s64 - ctx.r[30].s64;
	// 825D9738: 82CB0030  lwz r22, 0x30(r11)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825D973C: 7F384050  subf r25, r24, r8
	ctx.r[25].s64 = ctx.r[8].s64 - ctx.r[24].s64;
	// 825D9740: 83A50008  lwz r29, 8(r5)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D9744: 7F1EB850  subf r24, r30, r23
	ctx.r[24].s64 = ctx.r[23].s64 - ctx.r[30].s64;
	// 825D9748: 82AB0054  lwz r21, 0x54(r11)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D974C: 7C84E378  or r4, r4, r28
	ctx.r[4].u64 = ctx.r[4].u64 | ctx.r[28].u64;
	// 825D9750: 828BFFE0  lwz r20, -0x20(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32 as u32) ) } as u64;
	// 825D9754: 7CE73378  or r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 825D9758: 826BFFE4  lwz r19, -0x1c(r11)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) } as u64;
	// 825D975C: 7F9EB050  subf r28, r30, r22
	ctx.r[28].s64 = ctx.r[22].s64 - ctx.r[30].s64;
	// 825D9760: 824B0014  lwz r18, 0x14(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825D9764: 7CDDA850  subf r6, r29, r21
	ctx.r[6].s64 = ctx.r[21].s64 - ctx.r[29].s64;
	// 825D9768: 822B0034  lwz r17, 0x34(r11)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 825D976C: 7D134050  subf r8, r19, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[19].s64;
	// 825D9770: 820BFFF0  lwz r16, -0x10(r11)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 825D9774: 7EF4F850  subf r23, r20, r31
	ctx.r[23].s64 = ctx.r[31].s64 - ctx.r[20].s64;
	// 825D9778: 7F39C378  or r25, r25, r24
	ctx.r[25].u64 = ctx.r[25].u64 | ctx.r[24].u64;
	// 825D977C: 81EB0000  lwz r15, 0(r11)
	ctx.r[15].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9780: 7C84E378  or r4, r4, r28
	ctx.r[4].u64 = ctx.r[4].u64 | ctx.r[28].u64;
	// 825D9784: 81CBFFF4  lwz r14, -0xc(r11)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825D9788: 7F1D9050  subf r24, r29, r18
	ctx.r[24].s64 = ctx.r[18].s64 - ctx.r[29].s64;
	// 825D978C: 7CE73378  or r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 825D9790: 7F9D8850  subf r28, r29, r17
	ctx.r[28].s64 = ctx.r[17].s64 - ctx.r[29].s64;
	// 825D9794: 7CDE8050  subf r6, r30, r16
	ctx.r[6].s64 = ctx.r[16].s64 - ctx.r[30].s64;
	// 825D9798: 7EE84378  or r8, r23, r8
	ctx.r[8].u64 = ctx.r[23].u64 | ctx.r[8].u64;
	// 825D979C: 7F3EC378  or r30, r25, r24
	ctx.r[30].u64 = ctx.r[25].u64 | ctx.r[24].u64;
	// 825D97A0: 7FEFF850  subf r31, r15, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[15].s64;
	// 825D97A4: 7C84E378  or r4, r4, r28
	ctx.r[4].u64 = ctx.r[4].u64 | ctx.r[28].u64;
	// 825D97A8: 54FC0000  rlwinm r28, r7, 0, 0, 0
	ctx.r[28].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 825D97AC: 7D083378  or r8, r8, r6
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[6].u64;
	// 825D97B0: 7CFD7050  subf r7, r29, r14
	ctx.r[7].s64 = ctx.r[14].s64 - ctx.r[29].s64;
	// 825D97B4: 7FC6FB78  or r6, r30, r31
	ctx.r[6].u64 = ctx.r[30].u64 | ctx.r[31].u64;
	// 825D97B8: 549E0000  rlwinm r30, r4, 0, 0, 0
	ctx.r[30].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 825D97BC: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 825D97C0: 54DF0000  rlwinm r31, r6, 0, 0, 0
	ctx.r[31].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 825D97C4: 7F87F038  and r7, r28, r30
	ctx.r[7].u64 = ctx.r[28].u64 & ctx.r[30].u64;
	// 825D97C8: 55080000  rlwinm r8, r8, 0, 0, 0
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 825D97CC: 7CE7F838  and r7, r7, r31
	ctx.r[7].u64 = ctx.r[7].u64 & ctx.r[31].u64;
	// 825D97D0: 7CE74038  and r7, r7, r8
	ctx.r[7].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 825D97D4: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 825D97D8: 409A0118  bne cr6, 0x825d98f0
	if !ctx.cr[6].eq {
	pc = 0x825D98F0; continue 'dispatch;
	}
	// 825D97DC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825D97E0: 409A0038  bne cr6, 0x825d9818
	if !ctx.cr[6].eq {
	pc = 0x825D9818; continue 'dispatch;
	}
	// 825D97E4: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 825D97E8: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825D97EC: 4098001C  bge cr6, 0x825d9808
	if !ctx.cr[6].lt {
	pc = 0x825D9808; continue 'dispatch;
	}
	// 825D97F0: 80EBFFE8  lwz r7, -0x18(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) } as u64;
	// 825D97F4: 390A0008  addi r8, r10, 8
	ctx.r[8].s64 = ctx.r[10].s64 + 8;
	// 825D97F8: 80C5000C  lwz r6, 0xc(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D97FC: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825D9800: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825D9804: 48000010  b 0x825d9814
	pc = 0x825D9814; continue 'dispatch;
	// 825D9808: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D980C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D9810: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D9814: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 825D9818: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D981C: 409A0044  bne cr6, 0x825d9860
	if !ctx.cr[6].eq {
	pc = 0x825D9860; continue 'dispatch;
	}
	// 825D9820: 810BFFFC  lwz r8, -4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 825D9824: 7F08D840  cmplw cr6, r8, r27
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825D9828: 41990038  bgt cr6, 0x825d9860
	if ctx.cr[6].gt {
	pc = 0x825D9860; continue 'dispatch;
	}
	// 825D982C: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 825D9830: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825D9834: 4098001C  bge cr6, 0x825d9850
	if !ctx.cr[6].lt {
	pc = 0x825D9850; continue 'dispatch;
	}
	// 825D9838: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D983C: 390A0008  addi r8, r10, 8
	ctx.r[8].s64 = ctx.r[10].s64 + 8;
	// 825D9840: 80C5000C  lwz r6, 0xc(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D9844: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825D9848: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825D984C: 48000010  b 0x825d985c
	pc = 0x825D985C; continue 'dispatch;
	// 825D9850: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9854: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D9858: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D985C: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 825D9860: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825D9864: 409A0044  bne cr6, 0x825d98a8
	if !ctx.cr[6].eq {
	pc = 0x825D98A8; continue 'dispatch;
	}
	// 825D9868: 810B001C  lwz r8, 0x1c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 825D986C: 7F08D840  cmplw cr6, r8, r27
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825D9870: 41990038  bgt cr6, 0x825d98a8
	if ctx.cr[6].gt {
	pc = 0x825D98A8; continue 'dispatch;
	}
	// 825D9874: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 825D9878: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825D987C: 4098001C  bge cr6, 0x825d9898
	if !ctx.cr[6].lt {
	pc = 0x825D9898; continue 'dispatch;
	}
	// 825D9880: 80EB0028  lwz r7, 0x28(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825D9884: 390A0008  addi r8, r10, 8
	ctx.r[8].s64 = ctx.r[10].s64 + 8;
	// 825D9888: 80C5000C  lwz r6, 0xc(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D988C: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825D9890: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825D9894: 48000010  b 0x825d98a4
	pc = 0x825D98A4; continue 'dispatch;
	// 825D9898: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D989C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D98A0: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D98A4: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 825D98A8: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 825D98AC: 409A0044  bne cr6, 0x825d98f0
	if !ctx.cr[6].eq {
	pc = 0x825D98F0; continue 'dispatch;
	}
	// 825D98B0: 810B003C  lwz r8, 0x3c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 825D98B4: 7F08D840  cmplw cr6, r8, r27
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825D98B8: 41990038  bgt cr6, 0x825d98f0
	if ctx.cr[6].gt {
	pc = 0x825D98F0; continue 'dispatch;
	}
	// 825D98BC: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 825D98C0: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825D98C4: 4098001C  bge cr6, 0x825d98e0
	if !ctx.cr[6].lt {
	pc = 0x825D98E0; continue 'dispatch;
	}
	// 825D98C8: 80EB0048  lwz r7, 0x48(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825D98CC: 390A0008  addi r8, r10, 8
	ctx.r[8].s64 = ctx.r[10].s64 + 8;
	// 825D98D0: 80C5000C  lwz r6, 0xc(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D98D4: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825D98D8: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825D98DC: 48000010  b 0x825d98ec
	pc = 0x825D98EC; continue 'dispatch;
	// 825D98E0: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D98E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D98E8: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D98EC: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 825D98F0: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 825D98F4: 810BFFDC  lwz r8, -0x24(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-36 as u32) ) } as u64;
	// 825D98F8: 7F08D840  cmplw cr6, r8, r27
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825D98FC: 4198FDFC  blt cr6, 0x825d96f8
	if ctx.cr[6].lt {
	pc = 0x825D96F8; continue 'dispatch;
	}
	// 825D9900: 80E10034  lwz r7, 0x34(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(52 as u32) ) } as u64;
	// 825D9904: 8161002C  lwz r11, 0x2c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(44 as u32) ) } as u64;
	// 825D9908: 38A50020  addi r5, r5, 0x20
	ctx.r[5].s64 = ctx.r[5].s64 + 32;
	// 825D990C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825D9910: 9161002C  stw r11, 0x2c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 825D9914: 48000230  b 0x825d9b44
	pc = 0x825D9B44; continue 'dispatch;
	// 825D9918: 83830010  lwz r28, 0x10(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825D991C: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825D9920: 40980214  bge cr6, 0x825d9b34
	if !ctx.cr[6].lt {
	pc = 0x825D9B34; continue 'dispatch;
	}
	// 825D9924: 39650024  addi r11, r5, 0x24
	ctx.r[11].s64 = ctx.r[5].s64 + 36;
	// 825D9928: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 825D992C: 83E30014  lwz r31, 0x14(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 825D9930: 80EB0040  lwz r7, 0x40(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 825D9934: 80CB0044  lwz r6, 0x44(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 825D9938: 808B0020  lwz r4, 0x20(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 825D993C: 7CE7F850  subf r7, r7, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[7].s64;
	// 825D9940: 836B0024  lwz r27, 0x24(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825D9944: 7CC64050  subf r6, r6, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[6].s64;
	// 825D9948: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D994C: 7C84F850  subf r4, r4, r31
	ctx.r[4].s64 = ctx.r[31].s64 - ctx.r[4].s64;
	// 825D9950: 832B0050  lwz r25, 0x50(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D9954: 7F7B4050  subf r27, r27, r8
	ctx.r[27].s64 = ctx.r[8].s64 - ctx.r[27].s64;
	// 825D9958: 830B0004  lwz r24, 4(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D995C: 7CE73378  or r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 825D9960: 83A30008  lwz r29, 8(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D9964: 7CDEC850  subf r6, r30, r25
	ctx.r[6].s64 = ctx.r[25].s64 - ctx.r[30].s64;
	// 825D9968: 82EB0014  lwz r23, 0x14(r11)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825D996C: 7F384050  subf r25, r24, r8
	ctx.r[25].s64 = ctx.r[8].s64 - ctx.r[24].s64;
	// 825D9970: 82CB0030  lwz r22, 0x30(r11)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825D9974: 7C84DB78  or r4, r4, r27
	ctx.r[4].u64 = ctx.r[4].u64 | ctx.r[27].u64;
	// 825D9978: 82AB0054  lwz r21, 0x54(r11)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D997C: 7F1DB850  subf r24, r29, r23
	ctx.r[24].s64 = ctx.r[23].s64 - ctx.r[29].s64;
	// 825D9980: 828BFFE0  lwz r20, -0x20(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32 as u32) ) } as u64;
	// 825D9984: 7F7EB050  subf r27, r30, r22
	ctx.r[27].s64 = ctx.r[22].s64 - ctx.r[30].s64;
	// 825D9988: 826BFFE4  lwz r19, -0x1c(r11)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) } as u64;
	// 825D998C: 7CE73378  or r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 825D9990: 824B0010  lwz r18, 0x10(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825D9994: 7CDDA850  subf r6, r29, r21
	ctx.r[6].s64 = ctx.r[21].s64 - ctx.r[29].s64;
	// 825D9998: 822B0034  lwz r17, 0x34(r11)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 825D999C: 7D134050  subf r8, r19, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[19].s64;
	// 825D99A0: 820BFFF4  lwz r16, -0xc(r11)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825D99A4: 7EF4F850  subf r23, r20, r31
	ctx.r[23].s64 = ctx.r[31].s64 - ctx.r[20].s64;
	// 825D99A8: 7F39C378  or r25, r25, r24
	ctx.r[25].u64 = ctx.r[25].u64 | ctx.r[24].u64;
	// 825D99AC: 81EB0000  lwz r15, 0(r11)
	ctx.r[15].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D99B0: 7C84DB78  or r4, r4, r27
	ctx.r[4].u64 = ctx.r[4].u64 | ctx.r[27].u64;
	// 825D99B4: 81CBFFF0  lwz r14, -0x10(r11)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 825D99B8: 7F1E9050  subf r24, r30, r18
	ctx.r[24].s64 = ctx.r[18].s64 - ctx.r[30].s64;
	// 825D99BC: 7F7D8850  subf r27, r29, r17
	ctx.r[27].s64 = ctx.r[17].s64 - ctx.r[29].s64;
	// 825D99C0: 7CE73378  or r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 825D99C4: 7EE84378  or r8, r23, r8
	ctx.r[8].u64 = ctx.r[23].u64 | ctx.r[8].u64;
	// 825D99C8: 7CDD8050  subf r6, r29, r16
	ctx.r[6].s64 = ctx.r[16].s64 - ctx.r[29].s64;
	// 825D99CC: 7FEFF850  subf r31, r15, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[15].s64;
	// 825D99D0: 7F39C378  or r25, r25, r24
	ctx.r[25].u64 = ctx.r[25].u64 | ctx.r[24].u64;
	// 825D99D4: 7C84DB78  or r4, r4, r27
	ctx.r[4].u64 = ctx.r[4].u64 | ctx.r[27].u64;
	// 825D99D8: 54FD0000  rlwinm r29, r7, 0, 0, 0
	ctx.r[29].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 825D99DC: 7D083378  or r8, r8, r6
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[6].u64;
	// 825D99E0: 7CFE7050  subf r7, r30, r14
	ctx.r[7].s64 = ctx.r[14].s64 - ctx.r[30].s64;
	// 825D99E4: 7F26FB78  or r6, r25, r31
	ctx.r[6].u64 = ctx.r[25].u64 | ctx.r[31].u64;
	// 825D99E8: 549E0000  rlwinm r30, r4, 0, 0, 0
	ctx.r[30].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 825D99EC: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 825D99F0: 54DF0000  rlwinm r31, r6, 0, 0, 0
	ctx.r[31].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 825D99F4: 7FA7F038  and r7, r29, r30
	ctx.r[7].u64 = ctx.r[29].u64 & ctx.r[30].u64;
	// 825D99F8: 55080000  rlwinm r8, r8, 0, 0, 0
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 825D99FC: 7CE7F838  and r7, r7, r31
	ctx.r[7].u64 = ctx.r[7].u64 & ctx.r[31].u64;
	// 825D9A00: 7CE74038  and r7, r7, r8
	ctx.r[7].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 825D9A04: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 825D9A08: 409A0118  bne cr6, 0x825d9b20
	if !ctx.cr[6].eq {
	pc = 0x825D9B20; continue 'dispatch;
	}
	// 825D9A0C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825D9A10: 409A0038  bne cr6, 0x825d9a48
	if !ctx.cr[6].eq {
	pc = 0x825D9A48; continue 'dispatch;
	}
	// 825D9A14: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 825D9A18: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825D9A1C: 4098001C  bge cr6, 0x825d9a38
	if !ctx.cr[6].lt {
	pc = 0x825D9A38; continue 'dispatch;
	}
	// 825D9A20: 80E3000C  lwz r7, 0xc(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D9A24: 390A0008  addi r8, r10, 8
	ctx.r[8].s64 = ctx.r[10].s64 + 8;
	// 825D9A28: 80CBFFE8  lwz r6, -0x18(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) } as u64;
	// 825D9A2C: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825D9A30: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825D9A34: 48000010  b 0x825d9a44
	pc = 0x825D9A44; continue 'dispatch;
	// 825D9A38: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9A3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D9A40: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D9A44: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 825D9A48: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D9A4C: 409A0044  bne cr6, 0x825d9a90
	if !ctx.cr[6].eq {
	pc = 0x825D9A90; continue 'dispatch;
	}
	// 825D9A50: 810BFFFC  lwz r8, -4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 825D9A54: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825D9A58: 41990038  bgt cr6, 0x825d9a90
	if ctx.cr[6].gt {
	pc = 0x825D9A90; continue 'dispatch;
	}
	// 825D9A5C: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 825D9A60: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825D9A64: 4098001C  bge cr6, 0x825d9a80
	if !ctx.cr[6].lt {
	pc = 0x825D9A80; continue 'dispatch;
	}
	// 825D9A68: 80E3000C  lwz r7, 0xc(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D9A6C: 390A0008  addi r8, r10, 8
	ctx.r[8].s64 = ctx.r[10].s64 + 8;
	// 825D9A70: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D9A74: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825D9A78: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825D9A7C: 48000010  b 0x825d9a8c
	pc = 0x825D9A8C; continue 'dispatch;
	// 825D9A80: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9A84: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D9A88: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D9A8C: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 825D9A90: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825D9A94: 409A0044  bne cr6, 0x825d9ad8
	if !ctx.cr[6].eq {
	pc = 0x825D9AD8; continue 'dispatch;
	}
	// 825D9A98: 810B001C  lwz r8, 0x1c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 825D9A9C: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825D9AA0: 41990038  bgt cr6, 0x825d9ad8
	if ctx.cr[6].gt {
	pc = 0x825D9AD8; continue 'dispatch;
	}
	// 825D9AA4: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 825D9AA8: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825D9AAC: 4098001C  bge cr6, 0x825d9ac8
	if !ctx.cr[6].lt {
	pc = 0x825D9AC8; continue 'dispatch;
	}
	// 825D9AB0: 80E3000C  lwz r7, 0xc(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D9AB4: 390A0008  addi r8, r10, 8
	ctx.r[8].s64 = ctx.r[10].s64 + 8;
	// 825D9AB8: 80CB0028  lwz r6, 0x28(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825D9ABC: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825D9AC0: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825D9AC4: 48000010  b 0x825d9ad4
	pc = 0x825D9AD4; continue 'dispatch;
	// 825D9AC8: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9ACC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D9AD0: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D9AD4: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 825D9AD8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825D9ADC: 409A0044  bne cr6, 0x825d9b20
	if !ctx.cr[6].eq {
	pc = 0x825D9B20; continue 'dispatch;
	}
	// 825D9AE0: 810B003C  lwz r8, 0x3c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 825D9AE4: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825D9AE8: 41990038  bgt cr6, 0x825d9b20
	if ctx.cr[6].gt {
	pc = 0x825D9B20; continue 'dispatch;
	}
	// 825D9AEC: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 825D9AF0: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825D9AF4: 4098001C  bge cr6, 0x825d9b10
	if !ctx.cr[6].lt {
	pc = 0x825D9B10; continue 'dispatch;
	}
	// 825D9AF8: 80E3000C  lwz r7, 0xc(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D9AFC: 390A0008  addi r8, r10, 8
	ctx.r[8].s64 = ctx.r[10].s64 + 8;
	// 825D9B00: 80CB0048  lwz r6, 0x48(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825D9B04: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825D9B08: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825D9B0C: 48000010  b 0x825d9b1c
	pc = 0x825D9B1C; continue 'dispatch;
	// 825D9B10: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9B14: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D9B18: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D9B1C: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 825D9B20: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 825D9B24: 810BFFDC  lwz r8, -0x24(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-36 as u32) ) } as u64;
	// 825D9B28: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825D9B2C: 4198FDFC  blt cr6, 0x825d9928
	if ctx.cr[6].lt {
	pc = 0x825D9928; continue 'dispatch;
	}
	// 825D9B30: 80E10034  lwz r7, 0x34(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(52 as u32) ) } as u64;
	// 825D9B34: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 825D9B38: 38630020  addi r3, r3, 0x20
	ctx.r[3].s64 = ctx.r[3].s64 + 32;
	// 825D9B3C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825D9B40: 9161001C  stw r11, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 825D9B44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D9B48: 4199FB90  bgt cr6, 0x825d96d8
	if ctx.cr[6].gt {
	pc = 0x825D96D8; continue 'dispatch;
	}
	// 825D9B4C: 7D675050  subf r11, r7, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 825D9B50: 7D631E70  srawi r3, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825D9B54: 4BF5B57C  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D9B58 size=2328
    let mut pc: u32 = 0x825D9B58;
    'dispatch: loop {
        match pc {
            0x825D9B58 => {
    //   block [0x825D9B58..0x825D9D64)
	// 825D9B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D9B5C: 4BF5B53D  bl 0x82535098
	ctx.lr = 0x825D9B60;
	sub_82535080(ctx, base);
	// 825D9B60: 9421FCE0  stwu r1, -0x320(r1)
	ea = ctx.r[1].u32.wrapping_add(-800 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9B64: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D9B68: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825D9B6C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D9B70: 895D0040  lbz r10, 0x40(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 825D9B74: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9B78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825D9B7C: 409A08EC  bne cr6, 0x825da468
	if !ctx.cr[6].eq {
	pc = 0x825DA468; continue 'dispatch;
	}
	// 825D9B80: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825D9B84: 3F208293  lis r25, -0x7d6d
	ctx.r[25].s64 = -2104295424;
	// 825D9B88: 3B6AA5A4  addi r27, r10, -0x5a5c
	ctx.r[27].s64 = ctx.r[10].s64 + -23132;
	// 825D9B8C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825D9B90: 3B4AA1D8  addi r26, r10, -0x5e28
	ctx.r[26].s64 = ctx.r[10].s64 + -24104;
	// 825D9B94: 2B0B006B  cmplwi cr6, r11, 0x6b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 107 as u32, &mut ctx.xer);
	// 825D9B98: 41990860  bgt cr6, 0x825da3f8
	if ctx.cr[6].gt {
	pc = 0x825DA3F8; continue 'dispatch;
	}
	// 825D9B9C: 3D80825E  lis r12, -0x7da2
	ctx.r[12].s64 = -2107768832;
	// 825D9BA0: 398C9BB4  addi r12, r12, -0x644c
	ctx.r[12].s64 = ctx.r[12].s64 + -25676;
	// 825D9BA4: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825D9BA8: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825D9BAC: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825D9BB0: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825DA468; continue 'dispatch;
		},
		1 => {
	pc = 0x825DA168; continue 'dispatch;
		},
		2 => {
	pc = 0x825DA168; continue 'dispatch;
		},
		3 => {
	pc = 0x825DA168; continue 'dispatch;
		},
		4 => {
	pc = 0x825DA168; continue 'dispatch;
		},
		5 => {
	pc = 0x825DA114; continue 'dispatch;
		},
		6 => {
	pc = 0x825DA124; continue 'dispatch;
		},
		7 => {
	pc = 0x825DA140; continue 'dispatch;
		},
		8 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		9 => {
	pc = 0x825DA27C; continue 'dispatch;
		},
		10 => {
	pc = 0x825DA2B4; continue 'dispatch;
		},
		11 => {
	pc = 0x825DA2F8; continue 'dispatch;
		},
		12 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		13 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		14 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		15 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		16 => {
	pc = 0x825D9F60; continue 'dispatch;
		},
		17 => {
	pc = 0x825D9F60; continue 'dispatch;
		},
		18 => {
	pc = 0x825D9F60; continue 'dispatch;
		},
		19 => {
	pc = 0x825D9D64; continue 'dispatch;
		},
		20 => {
	pc = 0x825D9D94; continue 'dispatch;
		},
		21 => {
	pc = 0x825D9DC8; continue 'dispatch;
		},
		22 => {
	pc = 0x825D9DF8; continue 'dispatch;
		},
		23 => {
	pc = 0x825D9E2C; continue 'dispatch;
		},
		24 => {
	pc = 0x825D9E5C; continue 'dispatch;
		},
		25 => {
	pc = 0x825D9E90; continue 'dispatch;
		},
		26 => {
	pc = 0x825D9EA8; continue 'dispatch;
		},
		27 => {
	pc = 0x825D9ECC; continue 'dispatch;
		},
		28 => {
	pc = 0x825D9EF0; continue 'dispatch;
		},
		29 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		30 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		31 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		32 => {
	pc = 0x825D9FB0; continue 'dispatch;
		},
		33 => {
	pc = 0x825D9FB0; continue 'dispatch;
		},
		34 => {
	pc = 0x825D9FB0; continue 'dispatch;
		},
		35 => {
	pc = 0x825D9FFC; continue 'dispatch;
		},
		36 => {
	pc = 0x825D9FFC; continue 'dispatch;
		},
		37 => {
	pc = 0x825D9FFC; continue 'dispatch;
		},
		38 => {
	pc = 0x825DA074; continue 'dispatch;
		},
		39 => {
	pc = 0x825DA074; continue 'dispatch;
		},
		40 => {
	pc = 0x825DA074; continue 'dispatch;
		},
		41 => {
	pc = 0x825DA0AC; continue 'dispatch;
		},
		42 => {
	pc = 0x825DA0AC; continue 'dispatch;
		},
		43 => {
	pc = 0x825DA0AC; continue 'dispatch;
		},
		44 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		45 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		46 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		47 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		48 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		49 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		50 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		51 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		52 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		53 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		54 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		55 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		56 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		57 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		58 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		59 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		60 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		61 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		62 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		63 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		64 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		65 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		66 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		67 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		68 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		69 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		70 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		71 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		72 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		73 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		74 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		75 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		76 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		77 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		78 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		79 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		80 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		81 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		82 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		83 => {
	pc = 0x825DA460; continue 'dispatch;
		},
		84 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		85 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		86 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		87 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		88 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		89 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		90 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		91 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		92 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		93 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		94 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		95 => {
	pc = 0x825DA3F8; continue 'dispatch;
		},
		96 => {
	pc = 0x825DA34C; continue 'dispatch;
		},
		97 => {
	pc = 0x825DA34C; continue 'dispatch;
		},
		98 => {
	pc = 0x825DA34C; continue 'dispatch;
		},
		99 => {
	pc = 0x825DA34C; continue 'dispatch;
		},
		100 => {
	pc = 0x825DA368; continue 'dispatch;
		},
		101 => {
	pc = 0x825DA368; continue 'dispatch;
		},
		102 => {
	pc = 0x825DA368; continue 'dispatch;
		},
		103 => {
	pc = 0x825DA368; continue 'dispatch;
		},
		104 => {
	pc = 0x825DA390; continue 'dispatch;
		},
		105 => {
	pc = 0x825DA390; continue 'dispatch;
		},
		106 => {
	pc = 0x825DA390; continue 'dispatch;
		},
		107 => {
	pc = 0x825DA390; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825D9BB4: 825DA468  lwz r18, -0x5b98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23448 as u32) ) } as u64;
	// 825D9BB8: 825DA168  lwz r18, -0x5e98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24216 as u32) ) } as u64;
	// 825D9BBC: 825DA168  lwz r18, -0x5e98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24216 as u32) ) } as u64;
	// 825D9BC0: 825DA168  lwz r18, -0x5e98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24216 as u32) ) } as u64;
	// 825D9BC4: 825DA168  lwz r18, -0x5e98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24216 as u32) ) } as u64;
	// 825D9BC8: 825DA114  lwz r18, -0x5eec(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24300 as u32) ) } as u64;
	// 825D9BCC: 825DA124  lwz r18, -0x5edc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24284 as u32) ) } as u64;
	// 825D9BD0: 825DA140  lwz r18, -0x5ec0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24256 as u32) ) } as u64;
	// 825D9BD4: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9BD8: 825DA27C  lwz r18, -0x5d84(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23940 as u32) ) } as u64;
	// 825D9BDC: 825DA2B4  lwz r18, -0x5d4c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23884 as u32) ) } as u64;
	// 825D9BE0: 825DA2F8  lwz r18, -0x5d08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23816 as u32) ) } as u64;
	// 825D9BE4: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9BE8: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9BEC: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9BF0: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9BF4: 825D9F60  lwz r18, -0x60a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24736 as u32) ) } as u64;
	// 825D9BF8: 825D9F60  lwz r18, -0x60a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24736 as u32) ) } as u64;
	// 825D9BFC: 825D9F60  lwz r18, -0x60a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24736 as u32) ) } as u64;
	// 825D9C00: 825D9D64  lwz r18, -0x629c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25244 as u32) ) } as u64;
	// 825D9C04: 825D9D94  lwz r18, -0x626c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25196 as u32) ) } as u64;
	// 825D9C08: 825D9DC8  lwz r18, -0x6238(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25144 as u32) ) } as u64;
	// 825D9C0C: 825D9DF8  lwz r18, -0x6208(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25096 as u32) ) } as u64;
	// 825D9C10: 825D9E2C  lwz r18, -0x61d4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25044 as u32) ) } as u64;
	// 825D9C14: 825D9E5C  lwz r18, -0x61a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24996 as u32) ) } as u64;
	// 825D9C18: 825D9E90  lwz r18, -0x6170(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24944 as u32) ) } as u64;
	// 825D9C1C: 825D9EA8  lwz r18, -0x6158(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24920 as u32) ) } as u64;
	// 825D9C20: 825D9ECC  lwz r18, -0x6134(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24884 as u32) ) } as u64;
	// 825D9C24: 825D9EF0  lwz r18, -0x6110(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24848 as u32) ) } as u64;
	// 825D9C28: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9C2C: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9C30: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9C34: 825D9FB0  lwz r18, -0x6050(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24656 as u32) ) } as u64;
	// 825D9C38: 825D9FB0  lwz r18, -0x6050(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24656 as u32) ) } as u64;
	// 825D9C3C: 825D9FB0  lwz r18, -0x6050(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24656 as u32) ) } as u64;
	// 825D9C40: 825D9FFC  lwz r18, -0x6004(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24580 as u32) ) } as u64;
	// 825D9C44: 825D9FFC  lwz r18, -0x6004(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24580 as u32) ) } as u64;
	// 825D9C48: 825D9FFC  lwz r18, -0x6004(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24580 as u32) ) } as u64;
	// 825D9C4C: 825DA074  lwz r18, -0x5f8c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24460 as u32) ) } as u64;
	// 825D9C50: 825DA074  lwz r18, -0x5f8c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24460 as u32) ) } as u64;
	// 825D9C54: 825DA074  lwz r18, -0x5f8c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24460 as u32) ) } as u64;
	// 825D9C58: 825DA0AC  lwz r18, -0x5f54(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24404 as u32) ) } as u64;
	// 825D9C5C: 825DA0AC  lwz r18, -0x5f54(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24404 as u32) ) } as u64;
	// 825D9C60: 825DA0AC  lwz r18, -0x5f54(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24404 as u32) ) } as u64;
	// 825D9C64: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9C68: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9C6C: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9C70: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9C74: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9C78: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9C7C: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9C80: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9C84: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9C88: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9C8C: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9C90: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9C94: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9C98: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9C9C: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CA0: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CA4: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CA8: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CAC: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CB0: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CB4: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CB8: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CBC: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CC0: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CC4: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CC8: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CCC: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CD0: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CD4: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CD8: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CDC: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CE0: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CE4: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CE8: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CEC: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CF0: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CF4: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CF8: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9CFC: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9D00: 825DA460  lwz r18, -0x5ba0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23456 as u32) ) } as u64;
	// 825D9D04: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9D08: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9D0C: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9D10: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9D14: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9D18: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9D1C: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9D20: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9D24: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9D28: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9D2C: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9D30: 825DA3F8  lwz r18, -0x5c08(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23560 as u32) ) } as u64;
	// 825D9D34: 825DA34C  lwz r18, -0x5cb4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23732 as u32) ) } as u64;
	// 825D9D38: 825DA34C  lwz r18, -0x5cb4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23732 as u32) ) } as u64;
	// 825D9D3C: 825DA34C  lwz r18, -0x5cb4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23732 as u32) ) } as u64;
	// 825D9D40: 825DA34C  lwz r18, -0x5cb4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23732 as u32) ) } as u64;
	// 825D9D44: 825DA368  lwz r18, -0x5c98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23704 as u32) ) } as u64;
	// 825D9D48: 825DA368  lwz r18, -0x5c98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23704 as u32) ) } as u64;
	// 825D9D4C: 825DA368  lwz r18, -0x5c98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23704 as u32) ) } as u64;
	// 825D9D50: 825DA368  lwz r18, -0x5c98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23704 as u32) ) } as u64;
	// 825D9D54: 825DA390  lwz r18, -0x5c70(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23664 as u32) ) } as u64;
	// 825D9D58: 825DA390  lwz r18, -0x5c70(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23664 as u32) ) } as u64;
	// 825D9D5C: 825DA390  lwz r18, -0x5c70(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23664 as u32) ) } as u64;
	// 825D9D60: 825DA390  lwz r18, -0x5c70(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-23664 as u32) ) } as u64;
            }
            0x825D9D64 => {
    //   block [0x825D9D64..0x825D9D94)
	// 825D9D64: 80FE0024  lwz r7, 0x24(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 825D9D68: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 825D9D6C: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 825D9D70: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825D9D74: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825D9D78: 7D670E70  srawi r7, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825D9D7C: 88DF0002  lbz r6, 2(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D9D80: 5528083E  rotlwi r8, r9, 1
	ctx.r[8].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825D9D84: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 825D9D88: 54C9083E  rotlwi r9, r6, 1
	ctx.r[9].u64 = ((ctx.r[6].u32).rotate_left(1)) as u64;
	// 825D9D8C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D9D90: 48000198  b 0x825d9f28
	pc = 0x825D9F28; continue 'dispatch;
            }
            0x825D9D94 => {
    //   block [0x825D9D94..0x825D9DC8)
	// 825D9D94: 813E0028  lwz r9, 0x28(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 825D9D98: 815E0024  lwz r10, 0x24(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 825D9D9C: 88FF0002  lbz r7, 2(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D9DA0: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 825D9DA4: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 825D9DA8: 54E9083E  rotlwi r9, r7, 1
	ctx.r[9].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 825D9DAC: 891F0001  lbz r8, 1(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825D9DB0: 7D670E70  srawi r7, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825D9DB4: 5508083E  rotlwi r8, r8, 1
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 825D9DB8: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 825D9DBC: 394A00FF  addi r10, r10, 0xff
	ctx.r[10].s64 = ctx.r[10].s64 + 255;
	// 825D9DC0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D9DC4: 48000164  b 0x825d9f28
	pc = 0x825D9F28; continue 'dispatch;
            }
            0x825D9DC8 => {
    //   block [0x825D9DC8..0x825D9DF8)
	// 825D9DC8: 80FE0020  lwz r7, 0x20(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 825D9DCC: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 825D9DD0: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 825D9DD4: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825D9DD8: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825D9DDC: 7D670E70  srawi r7, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825D9DE0: 88DF0002  lbz r6, 2(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D9DE4: 5528083E  rotlwi r8, r9, 1
	ctx.r[8].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825D9DE8: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 825D9DEC: 54C9083E  rotlwi r9, r6, 1
	ctx.r[9].u64 = ((ctx.r[6].u32).rotate_left(1)) as u64;
	// 825D9DF0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D9DF4: 48000134  b 0x825d9f28
	pc = 0x825D9F28; continue 'dispatch;
            }
            0x825D9DF8 => {
    //   block [0x825D9DF8..0x825D9E2C)
	// 825D9DF8: 813E0028  lwz r9, 0x28(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 825D9DFC: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 825D9E00: 88FF0002  lbz r7, 2(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D9E04: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 825D9E08: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 825D9E0C: 54E9083E  rotlwi r9, r7, 1
	ctx.r[9].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 825D9E10: 891F0001  lbz r8, 1(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825D9E14: 7D670E70  srawi r7, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825D9E18: 5508083E  rotlwi r8, r8, 1
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 825D9E1C: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 825D9E20: 394A00FF  addi r10, r10, 0xff
	ctx.r[10].s64 = ctx.r[10].s64 + 255;
	// 825D9E24: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D9E28: 48000100  b 0x825d9f28
	pc = 0x825D9F28; continue 'dispatch;
            }
            0x825D9E2C => {
    //   block [0x825D9E2C..0x825D9E5C)
	// 825D9E2C: 80FE0020  lwz r7, 0x20(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 825D9E30: 815E0024  lwz r10, 0x24(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 825D9E34: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 825D9E38: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825D9E3C: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825D9E40: 7D670E70  srawi r7, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825D9E44: 88DF0002  lbz r6, 2(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D9E48: 5528083E  rotlwi r8, r9, 1
	ctx.r[8].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825D9E4C: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 825D9E50: 54C9083E  rotlwi r9, r6, 1
	ctx.r[9].u64 = ((ctx.r[6].u32).rotate_left(1)) as u64;
	// 825D9E54: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D9E58: 480000D0  b 0x825d9f28
	pc = 0x825D9F28; continue 'dispatch;
            }
            0x825D9E5C => {
    //   block [0x825D9E5C..0x825D9E90)
	// 825D9E5C: 813E0024  lwz r9, 0x24(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 825D9E60: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 825D9E64: 88FF0002  lbz r7, 2(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D9E68: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 825D9E6C: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 825D9E70: 54E9083E  rotlwi r9, r7, 1
	ctx.r[9].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 825D9E74: 891F0001  lbz r8, 1(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825D9E78: 7D670E70  srawi r7, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825D9E7C: 5508083E  rotlwi r8, r8, 1
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 825D9E80: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 825D9E84: 394A00FF  addi r10, r10, 0xff
	ctx.r[10].s64 = ctx.r[10].s64 + 255;
	// 825D9E88: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825D9E8C: 4800009C  b 0x825d9f28
	pc = 0x825D9F28; continue 'dispatch;
            }
            0x825D9E90 => {
    //   block [0x825D9E90..0x825D9EA8)
	// 825D9E90: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 825D9E94: 811E0024  lwz r8, 0x24(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 825D9E98: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 825D9E9C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825D9EA0: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825D9EA4: 48000064  b 0x825d9f08
	pc = 0x825D9F08; continue 'dispatch;
            }
            0x825D9EA8 => {
    //   block [0x825D9EA8..0x825D9ECC)
	// 825D9EA8: 811E0028  lwz r8, 0x28(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 825D9EAC: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 825D9EB0: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 825D9EB4: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 825D9EB8: 811E002C  lwz r8, 0x2c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 825D9EBC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825D9EC0: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D9EC4: 394A00FF  addi r10, r10, 0xff
	ctx.r[10].s64 = ctx.r[10].s64 + 255;
	// 825D9EC8: 48000048  b 0x825d9f10
	pc = 0x825D9F10; continue 'dispatch;
            }
            0x825D9ECC => {
    //   block [0x825D9ECC..0x825D9EF0)
	// 825D9ECC: 811E0024  lwz r8, 0x24(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 825D9ED0: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 825D9ED4: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 825D9ED8: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 825D9EDC: 811E002C  lwz r8, 0x2c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 825D9EE0: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825D9EE4: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D9EE8: 394A00FF  addi r10, r10, 0xff
	ctx.r[10].s64 = ctx.r[10].s64 + 255;
	// 825D9EEC: 48000024  b 0x825d9f10
	pc = 0x825D9F10; continue 'dispatch;
            }
            0x825D9EF0 => {
    //   block [0x825D9EF0..0x825D9F60)
	// 825D9EF0: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 825D9EF4: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 825D9EF8: 811E0024  lwz r8, 0x24(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 825D9EFC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825D9F00: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 825D9F04: 394A01FE  addi r10, r10, 0x1fe
	ctx.r[10].s64 = ctx.r[10].s64 + 510;
	// 825D9F08: 80DE002C  lwz r6, 0x2c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 825D9F0C: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D9F10: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825D9F14: 88FF0002  lbz r7, 2(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D9F18: 5528083E  rotlwi r8, r9, 1
	ctx.r[8].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825D9F1C: 54E6083E  rotlwi r6, r7, 1
	ctx.r[6].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 825D9F20: 7D094214  add r8, r9, r8
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825D9F24: 7D273214  add r9, r7, r6
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 825D9F28: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825D9F2C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825D9F30: 7F074800  cmpw cr6, r7, r9
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825D9F34: 40990514  ble cr6, 0x825da448
	if !ctx.cr[6].gt {
	pc = 0x825DA448; continue 'dispatch;
	}
	// 825D9F38: 893FFFFF  lbz r9, -1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825D9F3C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825D9F40: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D9F44: 7FE9FA14  add r31, r9, r31
	ctx.r[31].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 825D9F48: 40980500  bge cr6, 0x825da448
	if !ctx.cr[6].lt {
	pc = 0x825DA448; continue 'dispatch;
	}
	// 825D9F4C: 7CA9F850  subf r5, r9, r31
	ctx.r[5].s64 = ctx.r[31].s64 - ctx.r[9].s64;
	// 825D9F50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D9F54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D9F58: 4BFFFC01  bl 0x825d9b58
	ctx.lr = 0x825D9F5C;
	sub_825D9B58(ctx, base);
	// 825D9F5C: 480004EC  b 0x825da448
	pc = 0x825DA448; continue 'dispatch;
            }
            0x825D9F60 => {
    //   block [0x825D9F60..0x825D9FB0)
	// 825D9F60: 390BFFF0  addi r8, r11, -0x10
	ctx.r[8].s64 = ctx.r[11].s64 + -16;
	// 825D9F64: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825D9F68: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825D9F6C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825D9F70: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825D9F74: 7D08F02E  lwzx r8, r8, r30
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825D9F78: 7F085000  cmpw cr6, r8, r10
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825D9F7C: 409904CC  ble cr6, 0x825da448
	if !ctx.cr[6].gt {
	pc = 0x825DA448; continue 'dispatch;
	}
	// 825D9F80: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 825D9F84: 895FFFFF  lbz r10, -1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825D9F88: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D9F8C: 7FEAFA14  add r31, r10, r31
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825D9F90: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825D9F94: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825D9F98: 409804B0  bge cr6, 0x825da448
	if !ctx.cr[6].lt {
	pc = 0x825DA448; continue 'dispatch;
	}
	// 825D9F9C: 7CAAF850  subf r5, r10, r31
	ctx.r[5].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 825D9FA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D9FA4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D9FA8: 4BFFFBB1  bl 0x825d9b58
	ctx.lr = 0x825D9FAC;
	sub_825D9B58(ctx, base);
	// 825D9FAC: 4800049C  b 0x825da448
	pc = 0x825DA448; continue 'dispatch;
            }
            0x825D9FB0 => {
    //   block [0x825D9FB0..0x825D9FFC)
	// 825D9FB0: 394BFFE0  addi r10, r11, -0x20
	ctx.r[10].s64 = ctx.r[11].s64 + -32;
	// 825D9FB4: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825D9FB8: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825D9FBC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D9FC0: 7D4AF02E  lwzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825D9FC4: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825D9FC8: 40990480  ble cr6, 0x825da448
	if !ctx.cr[6].gt {
	pc = 0x825DA448; continue 'dispatch;
	}
	// 825D9FCC: 396BFFE4  addi r11, r11, -0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + -28;
	// 825D9FD0: 895FFFFF  lbz r10, -1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825D9FD4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D9FD8: 7FEAFA14  add r31, r10, r31
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825D9FDC: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825D9FE0: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825D9FE4: 41990464  bgt cr6, 0x825da448
	if ctx.cr[6].gt {
	pc = 0x825DA448; continue 'dispatch;
	}
	// 825D9FE8: 7CAAF850  subf r5, r10, r31
	ctx.r[5].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 825D9FEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D9FF0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D9FF4: 4BFFFB65  bl 0x825d9b58
	ctx.lr = 0x825D9FF8;
	sub_825D9B58(ctx, base);
	// 825D9FF8: 48000450  b 0x825da448
	pc = 0x825DA448; continue 'dispatch;
            }
            0x825D9FFC => {
    //   block [0x825D9FFC..0x825DA074)
	// 825D9FFC: 394BFFDD  addi r10, r11, -0x23
	ctx.r[10].s64 = ctx.r[11].s64 + -35;
	// 825DA000: 891F0003  lbz r8, 3(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DA004: 88FF0004  lbz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA008: 5545103A  slwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825DA00C: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DA010: 5508403E  rotlwi r8, r8, 8
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(8)) as u64;
	// 825DA014: 88DF0001  lbz r6, 1(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DA018: 395F0007  addi r10, r31, 7
	ctx.r[10].s64 = ctx.r[31].s64 + 7;
	// 825DA01C: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 825DA020: 7CE5F02E  lwzx r7, r5, r30
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DA024: 7F074800  cmpw cr6, r7, r9
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825DA028: 4199000C  bgt cr6, 0x825da034
	if ctx.cr[6].gt {
	pc = 0x825DA034; continue 'dispatch;
	}
	// 825DA02C: 7FE85214  add r31, r8, r10
	ctx.r[31].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825DA030: 48000418  b 0x825da448
	pc = 0x825DA448; continue 'dispatch;
	// 825DA034: 88EAFFFE  lbz r7, -2(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-2 as u32) ) } as u64;
	// 825DA038: 38ABFFE1  addi r5, r11, -0x1f
	ctx.r[5].s64 = ctx.r[11].s64 + -31;
	// 825DA03C: 892AFFFF  lbz r9, -1(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DA040: 54EB403E  rotlwi r11, r7, 8
	ctx.r[11].u64 = ((ctx.r[7].u32).rotate_left(8)) as u64;
	// 825DA044: 54A7103A  slwi r7, r5, 2
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825DA048: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DA04C: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DA050: 7D27F02E  lwzx r9, r7, r30
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DA054: 7F093000  cmpw cr6, r9, r6
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[6].s32, &mut ctx.xer);
	// 825DA058: 409803F0  bge cr6, 0x825da448
	if !ctx.cr[6].lt {
	pc = 0x825DA448; continue 'dispatch;
	}
	// 825DA05C: 7D6B4050  subf r11, r11, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 825DA060: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DA064: 7CABFA14  add r5, r11, r31
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DA068: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825DA06C: 4BFFFAED  bl 0x825d9b58
	ctx.lr = 0x825DA070;
	sub_825D9B58(ctx, base);
	// 825DA070: 480003D8  b 0x825da448
	pc = 0x825DA448; continue 'dispatch;
            }
            0x825DA074 => {
    //   block [0x825DA074..0x825DA0AC)
	// 825DA074: 394BFFDA  addi r10, r11, -0x26
	ctx.r[10].s64 = ctx.r[11].s64 + -38;
	// 825DA078: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DA07C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825DA080: 7D4AF02E  lwzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DA084: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825DA088: 419803E0  blt cr6, 0x825da468
	if ctx.cr[6].lt {
	pc = 0x825DA468; continue 'dispatch;
	}
	// 825DA08C: 396BFFDE  addi r11, r11, -0x22
	ctx.r[11].s64 = ctx.r[11].s64 + -34;
	// 825DA090: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DA094: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DA098: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DA09C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825DA0A0: 409803C8  bge cr6, 0x825da468
	if !ctx.cr[6].lt {
	pc = 0x825DA468; continue 'dispatch;
	}
	// 825DA0A4: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825DA0A8: 480003A0  b 0x825da448
	pc = 0x825DA448; continue 'dispatch;
            }
            0x825DA0AC => {
    //   block [0x825DA0AC..0x825DA114)
	// 825DA0AC: 394BFFDB  addi r10, r11, -0x25
	ctx.r[10].s64 = ctx.r[11].s64 + -37;
	// 825DA0B0: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DA0B4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825DA0B8: 5528403E  rotlwi r8, r9, 8
	ctx.r[8].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825DA0BC: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DA0C0: 7CEAE82E  lwzx r7, r10, r29
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 825DA0C4: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DA0C8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825DA0CC: 554A402E  slwi r10, r10, 8
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825DA0D0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825DA0D4: 7F075000  cmpw cr6, r7, r10
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825DA0D8: 41980390  blt cr6, 0x825da468
	if ctx.cr[6].lt {
	pc = 0x825DA468; continue 'dispatch;
	}
	// 825DA0DC: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA0E0: 390BFFDF  addi r8, r11, -0x21
	ctx.r[8].s64 = ctx.r[11].s64 + -33;
	// 825DA0E4: 893F0005  lbz r9, 5(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(5 as u32) ) } as u64;
	// 825DA0E8: 554B403E  rotlwi r11, r10, 8
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825DA0EC: 895F0006  lbz r10, 6(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 825DA0F0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825DA0F4: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825DA0F8: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DA0FC: 7D28E82E  lwzx r9, r8, r29
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 825DA100: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DA104: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825DA108: 41990360  bgt cr6, 0x825da468
	if ctx.cr[6].gt {
	pc = 0x825DA468; continue 'dispatch;
	}
	// 825DA10C: 3BFF0007  addi r31, r31, 7
	ctx.r[31].s64 = ctx.r[31].s64 + 7;
	// 825DA110: 48000338  b 0x825da448
	pc = 0x825DA448; continue 'dispatch;
            }
            0x825DA114 => {
    //   block [0x825DA114..0x825DA124)
	// 825DA114: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DA118: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DA11C: 3BEB0002  addi r31, r11, 2
	ctx.r[31].s64 = ctx.r[11].s64 + 2;
	// 825DA120: 48000328  b 0x825da448
	pc = 0x825DA448; continue 'dispatch;
            }
            0x825DA124 => {
    //   block [0x825DA124..0x825DA140)
	// 825DA124: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DA128: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DA12C: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DA130: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DA134: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DA138: 3BEB0003  addi r31, r11, 3
	ctx.r[31].s64 = ctx.r[11].s64 + 3;
	// 825DA13C: 4800030C  b 0x825da448
	pc = 0x825DA448; continue 'dispatch;
            }
            0x825DA140 => {
    //   block [0x825DA140..0x825DA168)
	// 825DA140: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DA144: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DA148: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DA14C: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DA150: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DA154: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DA158: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DA15C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DA160: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 825DA164: 480002E4  b 0x825da448
	pc = 0x825DA448; continue 'dispatch;
            }
            0x825DA168 => {
    //   block [0x825DA168..0x825DA27C)
	// 825DA168: 813E0030  lwz r9, 0x30(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 825DA16C: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DA170: 80DD0020  lwz r6, 0x20(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DA174: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825DA178: 80BD0024  lwz r5, 0x24(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 825DA17C: 809D0028  lwz r4, 0x28(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 825DA180: 807D0010  lwz r3, 0x10(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DA184: 839D0014  lwz r28, 0x14(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 825DA188: 831D0018  lwz r24, 0x18(r29)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DA18C: 82FD0030  lwz r23, 0x30(r29)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 825DA190: 82DD0034  lwz r22, 0x34(r29)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 825DA194: 82BD0038  lwz r21, 0x38(r29)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 825DA198: 829D003C  lwz r20, 0x3c(r29)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 825DA19C: 7D4A5830  slw r10, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825DA1A0: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 825DA1A4: 811E0034  lwz r8, 0x34(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 825DA1A8: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DA1AC: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825DA1B0: 7D295830  slw r9, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825DA1B4: 91210084  stw r9, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 825DA1B8: 80FE0038  lwz r7, 0x38(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 825DA1BC: 891F0003  lbz r8, 3(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DA1C0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DA1C4: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 825DA1C8: 7D085830  slw r8, r8, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[8].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825DA1CC: 91010088  stw r8, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[8].u32 ) };
	// 825DA1D0: 80FE0040  lwz r7, 0x40(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 825DA1D4: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 825DA1D8: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 825DA1DC: 216B0010  subfic r11, r11, 0x10
	ctx.xer.ca = ctx.r[11].u32 <= 16 as u32;
	ctx.r[11].s64 = (16 as i64) - ctx.r[11].s64;
	// 825DA1E0: 7CC75E30  sraw r7, r6, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 825DA1E4: 7CEA3850  subf r7, r10, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 825DA1E8: 90E10060  stw r7, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[7].u32 ) };
	// 825DA1EC: 7CA75E30  sraw r7, r5, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[5].s32 >> tmp.u32) as i64;
	// 825DA1F0: 7CE93850  subf r7, r9, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 825DA1F4: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 825DA1F8: 7C875E30  sraw r7, r4, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[4].s32 >> tmp.u32) as i64;
	// 825DA1FC: 7CE83850  subf r7, r8, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 825DA200: 90E10068  stw r7, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[7].u32 ) };
	// 825DA204: 7C675E30  sraw r7, r3, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[3].s32 >> tmp.u32) as i64;
	// 825DA208: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 825DA20C: 7CEA3850  subf r7, r10, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 825DA210: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 825DA214: 7F875E30  sraw r7, r28, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[28].s32 < 0) && ((ctx.r[28].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[28].s32 >> tmp.u32) as i64;
	// 825DA218: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 825DA21C: 7CE93850  subf r7, r9, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 825DA220: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 825DA224: 7F075E30  sraw r7, r24, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[24].s32 < 0) && ((ctx.r[24].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[24].s32 >> tmp.u32) as i64;
	// 825DA228: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 825DA22C: 7CE83850  subf r7, r8, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 825DA230: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 825DA234: 7EE75E30  sraw r7, r23, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[23].s32 < 0) && ((ctx.r[23].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[23].s32 >> tmp.u32) as i64;
	// 825DA238: 7D4A3850  subf r10, r10, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 825DA23C: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 825DA240: 7ECA5E30  sraw r10, r22, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[22].s32 < 0) && ((ctx.r[22].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[22].s32 >> tmp.u32) as i64;
	// 825DA244: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 825DA248: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 825DA24C: 7EAA5E30  sraw r10, r21, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[21].s32 < 0) && ((ctx.r[21].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[21].s32 >> tmp.u32) as i64;
	// 825DA250: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825DA254: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 825DA258: 7E8B5E30  sraw r11, r20, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[20].s32 < 0) && ((ctx.r[20].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[20].s32 >> tmp.u32) as i64;
	// 825DA25C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DA260: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 825DA264: 817E0044  lwz r11, 0x44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 825DA268: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 825DA26C: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 825DA270: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825DA274: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 825DA278: 480001D0  b 0x825da448
	pc = 0x825DA448; continue 'dispatch;
            }
            0x825DA27C => {
    //   block [0x825DA27C..0x825DA2B4)
	// 825DA27C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825DA280: 8B9F0001  lbz r28, 1(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DA284: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DA288: 419A0018  beq cr6, 0x825da2a0
	if ctx.cr[6].eq {
	pc = 0x825DA2A0; continue 'dispatch;
	}
	// 825DA28C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA290: 38A00048  li r5, 0x48
	ctx.r[5].s64 = 72;
	// 825DA294: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DA298: 4BF5A8B9  bl 0x82534b50
	ctx.lr = 0x825DA29C;
	sub_82534B50(ctx, base);
	// 825DA29C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825DA2A0: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825DA2A4: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825DA2A8: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 825DA2AC: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 825DA2B0: 48000198  b 0x825da448
	pc = 0x825DA448; continue 'dispatch;
            }
            0x825DA2B4 => {
    //   block [0x825DA2B4..0x825DA2F8)
	// 825DA2B4: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DA2B8: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 825DA2BC: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DA2C0: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DA2C4: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825DA2C8: 7F8B5214  add r28, r11, r10
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DA2CC: 419A0018  beq cr6, 0x825da2e4
	if ctx.cr[6].eq {
	pc = 0x825DA2E4; continue 'dispatch;
	}
	// 825DA2D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA2D4: 38A00048  li r5, 0x48
	ctx.r[5].s64 = 72;
	// 825DA2D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DA2DC: 4BF5A875  bl 0x82534b50
	ctx.lr = 0x825DA2E0;
	sub_82534B50(ctx, base);
	// 825DA2E0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825DA2E4: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825DA2E8: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825DA2EC: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 825DA2F0: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 825DA2F4: 48000154  b 0x825da448
	pc = 0x825DA448; continue 'dispatch;
            }
            0x825DA2F8 => {
    //   block [0x825DA2F8..0x825DA34C)
	// 825DA2F8: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DA2FC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825DA300: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DA304: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DA308: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DA30C: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA310: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825DA314: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825DA318: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DA31C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DA320: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DA324: 7F8B5214  add r28, r11, r10
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DA328: 419A0018  beq cr6, 0x825da340
	if ctx.cr[6].eq {
	pc = 0x825DA340; continue 'dispatch;
	}
	// 825DA32C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA330: 38A00048  li r5, 0x48
	ctx.r[5].s64 = 72;
	// 825DA334: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DA338: 4BF5A819  bl 0x82534b50
	ctx.lr = 0x825DA33C;
	sub_82534B50(ctx, base);
	// 825DA33C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825DA340: 9381008C  stw r28, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[28].u32 ) };
	// 825DA344: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825DA348: 48000100  b 0x825da448
	pc = 0x825DA448; continue 'dispatch;
            }
            0x825DA34C => {
    //   block [0x825DA34C..0x825DA368)
	// 825DA34C: 396BFFA0  addi r11, r11, -0x60
	ctx.r[11].s64 = ctx.r[11].s64 + -96;
	// 825DA350: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DA354: 39210094  addi r9, r1, 0x94
	ctx.r[9].s64 = ctx.r[1].s64 + 148;
	// 825DA358: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DA35C: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825DA360: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 825DA364: 48000068  b 0x825da3cc
	pc = 0x825DA3CC; continue 'dispatch;
            }
            0x825DA368 => {
    //   block [0x825DA368..0x825DA390)
	// 825DA368: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DA36C: 390BFF9C  addi r8, r11, -0x64
	ctx.r[8].s64 = ctx.r[11].s64 + -100;
	// 825DA370: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DA374: 38E10094  addi r7, r1, 0x94
	ctx.r[7].s64 = ctx.r[1].s64 + 148;
	// 825DA378: 552B403E  rotlwi r11, r9, 8
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825DA37C: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825DA380: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DA384: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825DA388: 7D69392E  stwx r11, r9, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 825DA38C: 48000040  b 0x825da3cc
	pc = 0x825DA3CC; continue 'dispatch;
            }
            0x825DA390 => {
    //   block [0x825DA390..0x825DA3F8)
	// 825DA390: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DA394: 38EBFF98  addi r7, r11, -0x68
	ctx.r[7].s64 = ctx.r[11].s64 + -104;
	// 825DA398: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DA39C: 38C10094  addi r6, r1, 0x94
	ctx.r[6].s64 = ctx.r[1].s64 + 148;
	// 825DA3A0: 554B403E  rotlwi r11, r10, 8
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825DA3A4: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DA3A8: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA3AC: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825DA3B0: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825DA3B4: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825DA3B8: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DA3BC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DA3C0: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DA3C4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DA3C8: 7D67312E  stwx r11, r7, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 825DA3CC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825DA3D0: 83810094  lwz r28, 0x94(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825DA3D4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DA3D8: 419A0018  beq cr6, 0x825da3f0
	if ctx.cr[6].eq {
	pc = 0x825DA3F0; continue 'dispatch;
	}
	// 825DA3DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA3E0: 38A00048  li r5, 0x48
	ctx.r[5].s64 = 72;
	// 825DA3E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DA3E8: 4BF5A769  bl 0x82534b50
	ctx.lr = 0x825DA3EC;
	sub_82534B50(ctx, base);
	// 825DA3EC: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825DA3F0: 93810094  stw r28, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[28].u32 ) };
	// 825DA3F4: 48000054  b 0x825da448
	pc = 0x825DA448; continue 'dispatch;
            }
            0x825DA3F8 => {
    //   block [0x825DA3F8..0x825DA460)
	// 825DA3F8: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 825DA3FC: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 825DA400: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825DA404: 4BE8E9F5  bl 0x82468df8
	ctx.lr = 0x825DA408;
	sub_82468DF8(ctx, base);
	// 825DA408: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825DA40C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825DA410: 4BE8DE91  bl 0x824682a0
	ctx.lr = 0x825DA414;
	sub_824682A0(ctx, base);
	// 825DA414: 80799190  lwz r3, -0x6e70(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-28272 as u32) ) } as u64;
	// 825DA418: 3CA01298  lis r5, 0x1298
	ctx.r[5].s64 = 311951360;
	// 825DA41C: 39000156  li r8, 0x156
	ctx.r[8].s64 = 342;
	// 825DA420: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825DA424: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 825DA428: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA42C: 60A5FEDD  ori r5, r5, 0xfedd
	ctx.r[5].u64 = ctx.r[5].u64 | 65245;
	// 825DA430: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825DA434: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DA438: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DA43C: 4E800421  bctrl
	ctx.lr = 0x825DA440;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DA440: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825DA444: 4BE8E49D  bl 0x824688e0
	ctx.lr = 0x825DA448;
	sub_824688E0(ctx, base);
	// 825DA448: 895D0040  lbz r10, 0x40(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 825DA44C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA450: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825DA454: 419AF740  beq cr6, 0x825d9b94
	if ctx.cr[6].eq {
	pc = 0x825D9B94; continue 'dispatch;
	}
	// 825DA458: 38210320  addi r1, r1, 0x320
	ctx.r[1].s64 = ctx.r[1].s64 + 800;
	// 825DA45C: 4BF5AC8C  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            0x825DA460 => {
    //   block [0x825DA460..0x825DA468)
	// 825DA460: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825DA464: 997D0040  stb r11, 0x40(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
	pc = 0x825DA468; continue 'dispatch;
            }
            0x825DA468 => {
    //   block [0x825DA468..0x825DA470)
	// 825DA468: 38210320  addi r1, r1, 0x320
	ctx.r[1].s64 = ctx.r[1].s64 + 800;
	// 825DA46C: 4BF5AC7C  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DA470 size=800
    let mut pc: u32 = 0x825DA470;
    'dispatch: loop {
        match pc {
            0x825DA470 => {
    //   block [0x825DA470..0x825DA790)
	// 825DA470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA474: 4BF5AC21  bl 0x82535094
	ctx.lr = 0x825DA478;
	sub_82535080(ctx, base);
	// 825DA478: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA790 size=168
    let mut pc: u32 = 0x825DA790;
    'dispatch: loop {
        match pc {
            0x825DA790 => {
    //   block [0x825DA790..0x825DA838)
	// 825DA790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA794: 4BF5A919  bl 0x825350ac
	ctx.lr = 0x825DA798;
	sub_82535080(ctx, base);
	// 825DA798: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA79C: 3F80829A  lis r28, -0x7d66
	ctx.r[28].s64 = -2103836672;
	// 825DA7A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DA7A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825DA7A8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825DA7AC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825DA7B0: 897C3E88  lbz r11, 0x3e88(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(16008 as u32) ) } as u64;
	// 825DA7B4: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 825DA7B8: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 825DA7BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DA7C0: 409A002C  bne cr6, 0x825da7ec
	if !ctx.cr[6].eq {
	pc = 0x825DA7EC; continue 'dispatch;
	}
	// 825DA7C4: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825DA7C8: 4BF1E979  bl 0x824f9140
	ctx.lr = 0x825DA7CC;
	sub_824F9140(ctx, base);
	// 825DA7CC: 7C6B0774  extsb r11, r3
	ctx.r[11].s64 = ctx.r[3].s8 as i64;
	// 825DA7D0: 987C3E88  stb r3, 0x3e88(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(16008 as u32), ctx.r[3].u8 ) };
	// 825DA7D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DA7D8: 409A0014  bne cr6, 0x825da7ec
	if !ctx.cr[6].eq {
	pc = 0x825DA7EC; continue 'dispatch;
	}
	// 825DA7DC: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825DA7E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DA7E4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825DA7E8: 4BF5A914  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
	// 825DA7EC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825DA7F0: 93BF0044  stw r29, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[29].u32 ) };
	// 825DA7F4: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 825DA7F8: 83BD0020  lwz r29, 0x20(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DA7FC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825DA800: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825DA804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DA808: 4BFFFC69  bl 0x825da470
	ctx.lr = 0x825DA80C;
	sub_825DA470(ctx, base);
	// 825DA80C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DA810: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825DA814: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825DA818: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 825DA81C: 997F0040  stb r11, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
	// 825DA820: 4BFFF339  bl 0x825d9b58
	ctx.lr = 0x825DA824;
	sub_825D9B58(ctx, base);
	// 825DA824: 897F0040  lbz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 825DA828: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DA82C: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825DA830: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825DA834: 4BF5A8C8  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DA838 size=2488
    let mut pc: u32 = 0x825DA838;
    'dispatch: loop {
        match pc {
            0x825DA838 => {
    //   block [0x825DA838..0x825DAA60)
	// 825DA838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA83C: 4BF5A875  bl 0x825350b0
	ctx.lr = 0x825DA840;
	sub_82535080(ctx, base);
	// 825DA840: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA844: 3FA0829A  lis r29, -0x7d66
	ctx.r[29].s64 = -2103836672;
	// 825DA848: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825DA84C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DA850: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DA854: 897D3E89  lbz r11, 0x3e89(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(16009 as u32) ) } as u64;
	// 825DA858: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DA85C: 409A001C  bne cr6, 0x825da878
	if !ctx.cr[6].eq {
	pc = 0x825DA878; continue 'dispatch;
	}
	// 825DA860: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825DA864: 4BF1E8DD  bl 0x824f9140
	ctx.lr = 0x825DA868;
	sub_824F9140(ctx, base);
	// 825DA868: 7C6B0774  extsb r11, r3
	ctx.r[11].s64 = ctx.r[3].s8 as i64;
	// 825DA86C: 987D3E89  stb r3, 0x3e89(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(16009 as u32), ctx.r[3].u8 ) };
	// 825DA870: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DA874: 419A0974  beq cr6, 0x825db1e8
	if ctx.cr[6].eq {
	pc = 0x825DB1E8; continue 'dispatch;
	}
	// 825DA878: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825DA87C: 3F408293  lis r26, -0x7d6d
	ctx.r[26].s64 = -2104295424;
	// 825DA880: 3BABA5E4  addi r29, r11, -0x5a1c
	ctx.r[29].s64 = ctx.r[11].s64 + -23068;
	// 825DA884: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825DA888: 3B6BA1D8  addi r27, r11, -0x5e28
	ctx.r[27].s64 = ctx.r[11].s64 + -24104;
	// 825DA88C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA890: 2B0B006B  cmplwi cr6, r11, 0x6b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 107 as u32, &mut ctx.xer);
	// 825DA894: 41990850  bgt cr6, 0x825db0e4
	if ctx.cr[6].gt {
	pc = 0x825DB0E4; continue 'dispatch;
	}
	// 825DA898: 3D80825E  lis r12, -0x7da2
	ctx.r[12].s64 = -2107768832;
	// 825DA89C: 398CA8B0  addi r12, r12, -0x5750
	ctx.r[12].s64 = ctx.r[12].s64 + -22352;
	// 825DA8A0: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825DA8A4: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825DA8A8: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825DA8AC: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825DB1E8; continue 'dispatch;
		},
		1 => {
	pc = 0x825DAE84; continue 'dispatch;
		},
		2 => {
	pc = 0x825DAE84; continue 'dispatch;
		},
		3 => {
	pc = 0x825DAE84; continue 'dispatch;
		},
		4 => {
	pc = 0x825DAE84; continue 'dispatch;
		},
		5 => {
	pc = 0x825DAE30; continue 'dispatch;
		},
		6 => {
	pc = 0x825DAE40; continue 'dispatch;
		},
		7 => {
	pc = 0x825DAE5C; continue 'dispatch;
		},
		8 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		9 => {
	pc = 0x825DAF28; continue 'dispatch;
		},
		10 => {
	pc = 0x825DAF70; continue 'dispatch;
		},
		11 => {
	pc = 0x825DAFC4; continue 'dispatch;
		},
		12 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		13 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		14 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		15 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		16 => {
	pc = 0x825DAC78; continue 'dispatch;
		},
		17 => {
	pc = 0x825DAC78; continue 'dispatch;
		},
		18 => {
	pc = 0x825DAC78; continue 'dispatch;
		},
		19 => {
	pc = 0x825DAA60; continue 'dispatch;
		},
		20 => {
	pc = 0x825DAA90; continue 'dispatch;
		},
		21 => {
	pc = 0x825DAAC4; continue 'dispatch;
		},
		22 => {
	pc = 0x825DAAF4; continue 'dispatch;
		},
		23 => {
	pc = 0x825DAB28; continue 'dispatch;
		},
		24 => {
	pc = 0x825DAB58; continue 'dispatch;
		},
		25 => {
	pc = 0x825DAB8C; continue 'dispatch;
		},
		26 => {
	pc = 0x825DABC4; continue 'dispatch;
		},
		27 => {
	pc = 0x825DAC00; continue 'dispatch;
		},
		28 => {
	pc = 0x825DAC3C; continue 'dispatch;
		},
		29 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		30 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		31 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		32 => {
	pc = 0x825DACC8; continue 'dispatch;
		},
		33 => {
	pc = 0x825DACC8; continue 'dispatch;
		},
		34 => {
	pc = 0x825DACC8; continue 'dispatch;
		},
		35 => {
	pc = 0x825DAD18; continue 'dispatch;
		},
		36 => {
	pc = 0x825DAD18; continue 'dispatch;
		},
		37 => {
	pc = 0x825DAD18; continue 'dispatch;
		},
		38 => {
	pc = 0x825DAD90; continue 'dispatch;
		},
		39 => {
	pc = 0x825DAD90; continue 'dispatch;
		},
		40 => {
	pc = 0x825DAD90; continue 'dispatch;
		},
		41 => {
	pc = 0x825DADC8; continue 'dispatch;
		},
		42 => {
	pc = 0x825DADC8; continue 'dispatch;
		},
		43 => {
	pc = 0x825DADC8; continue 'dispatch;
		},
		44 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		45 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		46 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		47 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		48 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		49 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		50 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		51 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		52 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		53 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		54 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		55 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		56 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		57 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		58 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		59 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		60 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		61 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		62 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		63 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		64 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		65 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		66 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		67 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		68 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		69 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		70 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		71 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		72 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		73 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		74 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		75 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		76 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		77 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		78 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		79 => {
	pc = 0x825DB1A0; continue 'dispatch;
		},
		80 => {
	pc = 0x825DB138; continue 'dispatch;
		},
		81 => {
	pc = 0x825DB140; continue 'dispatch;
		},
		82 => {
	pc = 0x825DB154; continue 'dispatch;
		},
		83 => {
	pc = 0x825DB174; continue 'dispatch;
		},
		84 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		85 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		86 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		87 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		88 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		89 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		90 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		91 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		92 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		93 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		94 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		95 => {
	pc = 0x825DB0E4; continue 'dispatch;
		},
		96 => {
	pc = 0x825DB028; continue 'dispatch;
		},
		97 => {
	pc = 0x825DB028; continue 'dispatch;
		},
		98 => {
	pc = 0x825DB028; continue 'dispatch;
		},
		99 => {
	pc = 0x825DB028; continue 'dispatch;
		},
		100 => {
	pc = 0x825DB044; continue 'dispatch;
		},
		101 => {
	pc = 0x825DB044; continue 'dispatch;
		},
		102 => {
	pc = 0x825DB044; continue 'dispatch;
		},
		103 => {
	pc = 0x825DB044; continue 'dispatch;
		},
		104 => {
	pc = 0x825DB06C; continue 'dispatch;
		},
		105 => {
	pc = 0x825DB06C; continue 'dispatch;
		},
		106 => {
	pc = 0x825DB06C; continue 'dispatch;
		},
		107 => {
	pc = 0x825DB06C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825DA8B0: 825DB1E8  lwz r18, -0x4e18(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-19992 as u32) ) } as u64;
	// 825DA8B4: 825DAE84  lwz r18, -0x517c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20860 as u32) ) } as u64;
	// 825DA8B8: 825DAE84  lwz r18, -0x517c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20860 as u32) ) } as u64;
	// 825DA8BC: 825DAE84  lwz r18, -0x517c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20860 as u32) ) } as u64;
	// 825DA8C0: 825DAE84  lwz r18, -0x517c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20860 as u32) ) } as u64;
	// 825DA8C4: 825DAE30  lwz r18, -0x51d0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20944 as u32) ) } as u64;
	// 825DA8C8: 825DAE40  lwz r18, -0x51c0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20928 as u32) ) } as u64;
	// 825DA8CC: 825DAE5C  lwz r18, -0x51a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20900 as u32) ) } as u64;
	// 825DA8D0: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DA8D4: 825DAF28  lwz r18, -0x50d8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20696 as u32) ) } as u64;
	// 825DA8D8: 825DAF70  lwz r18, -0x5090(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20624 as u32) ) } as u64;
	// 825DA8DC: 825DAFC4  lwz r18, -0x503c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20540 as u32) ) } as u64;
	// 825DA8E0: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DA8E4: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DA8E8: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DA8EC: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DA8F0: 825DAC78  lwz r18, -0x5388(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21384 as u32) ) } as u64;
	// 825DA8F4: 825DAC78  lwz r18, -0x5388(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21384 as u32) ) } as u64;
	// 825DA8F8: 825DAC78  lwz r18, -0x5388(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21384 as u32) ) } as u64;
	// 825DA8FC: 825DAA60  lwz r18, -0x55a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21920 as u32) ) } as u64;
	// 825DA900: 825DAA90  lwz r18, -0x5570(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21872 as u32) ) } as u64;
	// 825DA904: 825DAAC4  lwz r18, -0x553c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21820 as u32) ) } as u64;
	// 825DA908: 825DAAF4  lwz r18, -0x550c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21772 as u32) ) } as u64;
	// 825DA90C: 825DAB28  lwz r18, -0x54d8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21720 as u32) ) } as u64;
	// 825DA910: 825DAB58  lwz r18, -0x54a8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21672 as u32) ) } as u64;
	// 825DA914: 825DAB8C  lwz r18, -0x5474(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21620 as u32) ) } as u64;
	// 825DA918: 825DABC4  lwz r18, -0x543c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21564 as u32) ) } as u64;
	// 825DA91C: 825DAC00  lwz r18, -0x5400(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21504 as u32) ) } as u64;
	// 825DA920: 825DAC3C  lwz r18, -0x53c4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21444 as u32) ) } as u64;
	// 825DA924: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DA928: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DA92C: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DA930: 825DACC8  lwz r18, -0x5338(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21304 as u32) ) } as u64;
	// 825DA934: 825DACC8  lwz r18, -0x5338(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21304 as u32) ) } as u64;
	// 825DA938: 825DACC8  lwz r18, -0x5338(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21304 as u32) ) } as u64;
	// 825DA93C: 825DAD18  lwz r18, -0x52e8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21224 as u32) ) } as u64;
	// 825DA940: 825DAD18  lwz r18, -0x52e8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21224 as u32) ) } as u64;
	// 825DA944: 825DAD18  lwz r18, -0x52e8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21224 as u32) ) } as u64;
	// 825DA948: 825DAD90  lwz r18, -0x5270(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21104 as u32) ) } as u64;
	// 825DA94C: 825DAD90  lwz r18, -0x5270(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21104 as u32) ) } as u64;
	// 825DA950: 825DAD90  lwz r18, -0x5270(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21104 as u32) ) } as u64;
	// 825DA954: 825DADC8  lwz r18, -0x5238(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21048 as u32) ) } as u64;
	// 825DA958: 825DADC8  lwz r18, -0x5238(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21048 as u32) ) } as u64;
	// 825DA95C: 825DADC8  lwz r18, -0x5238(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-21048 as u32) ) } as u64;
	// 825DA960: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DA964: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DA968: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DA96C: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DA970: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA974: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA978: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA97C: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA980: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA984: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA988: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA98C: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA990: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA994: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA998: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA99C: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9A0: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9A4: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9A8: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9AC: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9B0: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9B4: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9B8: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9BC: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9C0: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9C4: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9C8: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9CC: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9D0: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9D4: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9D8: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9DC: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9E0: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9E4: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9E8: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9EC: 825DB1A0  lwz r18, -0x4e60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20064 as u32) ) } as u64;
	// 825DA9F0: 825DB138  lwz r18, -0x4ec8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20168 as u32) ) } as u64;
	// 825DA9F4: 825DB140  lwz r18, -0x4ec0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20160 as u32) ) } as u64;
	// 825DA9F8: 825DB154  lwz r18, -0x4eac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20140 as u32) ) } as u64;
	// 825DA9FC: 825DB174  lwz r18, -0x4e8c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20108 as u32) ) } as u64;
	// 825DAA00: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DAA04: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DAA08: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DAA0C: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DAA10: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DAA14: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DAA18: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DAA1C: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DAA20: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DAA24: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DAA28: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DAA2C: 825DB0E4  lwz r18, -0x4f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20252 as u32) ) } as u64;
	// 825DAA30: 825DB028  lwz r18, -0x4fd8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20440 as u32) ) } as u64;
	// 825DAA34: 825DB028  lwz r18, -0x4fd8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20440 as u32) ) } as u64;
	// 825DAA38: 825DB028  lwz r18, -0x4fd8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20440 as u32) ) } as u64;
	// 825DAA3C: 825DB028  lwz r18, -0x4fd8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20440 as u32) ) } as u64;
	// 825DAA40: 825DB044  lwz r18, -0x4fbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20412 as u32) ) } as u64;
	// 825DAA44: 825DB044  lwz r18, -0x4fbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20412 as u32) ) } as u64;
	// 825DAA48: 825DB044  lwz r18, -0x4fbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20412 as u32) ) } as u64;
	// 825DAA4C: 825DB044  lwz r18, -0x4fbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20412 as u32) ) } as u64;
	// 825DAA50: 825DB06C  lwz r18, -0x4f94(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20372 as u32) ) } as u64;
	// 825DAA54: 825DB06C  lwz r18, -0x4f94(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20372 as u32) ) } as u64;
	// 825DAA58: 825DB06C  lwz r18, -0x4f94(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20372 as u32) ) } as u64;
	// 825DAA5C: 825DB06C  lwz r18, -0x4f94(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-20372 as u32) ) } as u64;
            }
            0x825DAA60 => {
    //   block [0x825DAA60..0x825DAA90)
	// 825DAA60: 80FE0004  lwz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAA64: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DAA68: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DAA6C: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825DAA70: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DAA74: 7D670E70  srawi r7, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825DAA78: 88DF0002  lbz r6, 2(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DAA7C: 5528083E  rotlwi r8, r9, 1
	ctx.r[8].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825DAA80: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 825DAA84: 54C9083E  rotlwi r9, r6, 1
	ctx.r[9].u64 = ((ctx.r[6].u32).rotate_left(1)) as u64;
	// 825DAA88: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DAA8C: 48000204  b 0x825dac90
	pc = 0x825DAC90; continue 'dispatch;
            }
            0x825DAA90 => {
    //   block [0x825DAA90..0x825DAAC4)
	// 825DAA90: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DAA94: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAA98: 88FF0002  lbz r7, 2(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DAA9C: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DAAA0: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 825DAAA4: 54E9083E  rotlwi r9, r7, 1
	ctx.r[9].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 825DAAA8: 891F0001  lbz r8, 1(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DAAAC: 7D670E70  srawi r7, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825DAAB0: 5508083E  rotlwi r8, r8, 1
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 825DAAB4: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 825DAAB8: 394A00FF  addi r10, r10, 0xff
	ctx.r[10].s64 = ctx.r[10].s64 + 255;
	// 825DAABC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DAAC0: 480001D0  b 0x825dac90
	pc = 0x825DAC90; continue 'dispatch;
            }
            0x825DAAC4 => {
    //   block [0x825DAAC4..0x825DAAF4)
	// 825DAAC4: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAAC8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DAACC: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DAAD0: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825DAAD4: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DAAD8: 7D670E70  srawi r7, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825DAADC: 88DF0002  lbz r6, 2(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DAAE0: 5528083E  rotlwi r8, r9, 1
	ctx.r[8].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825DAAE4: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 825DAAE8: 54C9083E  rotlwi r9, r6, 1
	ctx.r[9].u64 = ((ctx.r[6].u32).rotate_left(1)) as u64;
	// 825DAAEC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DAAF0: 480001A0  b 0x825dac90
	pc = 0x825DAC90; continue 'dispatch;
            }
            0x825DAAF4 => {
    //   block [0x825DAAF4..0x825DAB28)
	// 825DAAF4: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DAAF8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAAFC: 88FF0002  lbz r7, 2(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DAB00: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DAB04: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 825DAB08: 54E9083E  rotlwi r9, r7, 1
	ctx.r[9].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 825DAB0C: 891F0001  lbz r8, 1(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DAB10: 7D670E70  srawi r7, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825DAB14: 5508083E  rotlwi r8, r8, 1
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 825DAB18: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 825DAB1C: 394A00FF  addi r10, r10, 0xff
	ctx.r[10].s64 = ctx.r[10].s64 + 255;
	// 825DAB20: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DAB24: 4800016C  b 0x825dac90
	pc = 0x825DAC90; continue 'dispatch;
            }
            0x825DAB28 => {
    //   block [0x825DAB28..0x825DAB58)
	// 825DAB28: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAB2C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAB30: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DAB34: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825DAB38: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DAB3C: 7D670E70  srawi r7, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825DAB40: 88DF0002  lbz r6, 2(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DAB44: 5528083E  rotlwi r8, r9, 1
	ctx.r[8].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825DAB48: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 825DAB4C: 54C9083E  rotlwi r9, r6, 1
	ctx.r[9].u64 = ((ctx.r[6].u32).rotate_left(1)) as u64;
	// 825DAB50: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DAB54: 4800013C  b 0x825dac90
	pc = 0x825DAC90; continue 'dispatch;
            }
            0x825DAB58 => {
    //   block [0x825DAB58..0x825DAB8C)
	// 825DAB58: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAB5C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAB60: 88FF0002  lbz r7, 2(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DAB64: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DAB68: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 825DAB6C: 54E9083E  rotlwi r9, r7, 1
	ctx.r[9].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 825DAB70: 891F0001  lbz r8, 1(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DAB74: 7D670E70  srawi r7, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825DAB78: 5508083E  rotlwi r8, r8, 1
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 825DAB7C: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 825DAB80: 394A00FF  addi r10, r10, 0xff
	ctx.r[10].s64 = ctx.r[10].s64 + 255;
	// 825DAB84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DAB88: 48000108  b 0x825dac90
	pc = 0x825DAC90; continue 'dispatch;
            }
            0x825DAB8C => {
    //   block [0x825DAB8C..0x825DABC4)
	// 825DAB8C: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAB90: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DAB94: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAB98: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825DAB9C: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DABA0: 80DE000C  lwz r6, 0xc(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DABA4: 88FF0002  lbz r7, 2(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DABA8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DABAC: 5528083E  rotlwi r8, r9, 1
	ctx.r[8].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825DABB0: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DABB4: 54E6083E  rotlwi r6, r7, 1
	ctx.r[6].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 825DABB8: 7D094214  add r8, r9, r8
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825DABBC: 7D273214  add r9, r7, r6
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 825DABC0: 480000D0  b 0x825dac90
	pc = 0x825DAC90; continue 'dispatch;
            }
            0x825DABC4 => {
    //   block [0x825DABC4..0x825DAC00)
	// 825DABC4: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DABC8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DABCC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DABD0: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 825DABD4: 811E000C  lwz r8, 0xc(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DABD8: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DABDC: 88FF0002  lbz r7, 2(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DABE0: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DABE4: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DABE8: 5528083E  rotlwi r8, r9, 1
	ctx.r[8].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825DABEC: 54E6083E  rotlwi r6, r7, 1
	ctx.r[6].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 825DABF0: 7D094214  add r8, r9, r8
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825DABF4: 394A00FF  addi r10, r10, 0xff
	ctx.r[10].s64 = ctx.r[10].s64 + 255;
	// 825DABF8: 7D273214  add r9, r7, r6
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 825DABFC: 48000094  b 0x825dac90
	pc = 0x825DAC90; continue 'dispatch;
            }
            0x825DAC00 => {
    //   block [0x825DAC00..0x825DAC3C)
	// 825DAC00: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAC04: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DAC08: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAC0C: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 825DAC10: 811E000C  lwz r8, 0xc(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DAC14: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DAC18: 88FF0002  lbz r7, 2(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DAC1C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DAC20: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DAC24: 5528083E  rotlwi r8, r9, 1
	ctx.r[8].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825DAC28: 54E6083E  rotlwi r6, r7, 1
	ctx.r[6].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 825DAC2C: 7D094214  add r8, r9, r8
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825DAC30: 394A00FF  addi r10, r10, 0xff
	ctx.r[10].s64 = ctx.r[10].s64 + 255;
	// 825DAC34: 7D273214  add r9, r7, r6
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 825DAC38: 48000058  b 0x825dac90
	pc = 0x825DAC90; continue 'dispatch;
            }
            0x825DAC3C => {
    //   block [0x825DAC3C..0x825DAC78)
	// 825DAC3C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DAC40: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAC44: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAC48: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825DAC4C: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DAC50: 80DE000C  lwz r6, 0xc(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DAC54: 88FF0002  lbz r7, 2(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DAC58: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 825DAC5C: 5528083E  rotlwi r8, r9, 1
	ctx.r[8].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825DAC60: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DAC64: 54E6083E  rotlwi r6, r7, 1
	ctx.r[6].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 825DAC68: 7D094214  add r8, r9, r8
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825DAC6C: 394A01FE  addi r10, r10, 0x1fe
	ctx.r[10].s64 = ctx.r[10].s64 + 510;
	// 825DAC70: 7D273214  add r9, r7, r6
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 825DAC74: 4800001C  b 0x825dac90
	pc = 0x825DAC90; continue 'dispatch;
            }
            0x825DAC78 => {
    //   block [0x825DAC78..0x825DACC8)
	// 825DAC78: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 825DAC7C: 891F0001  lbz r8, 1(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DAC80: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DAC84: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825DAC88: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DAC8C: 7D4AF02E  lwzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DAC90: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DAC94: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DAC98: 7F074800  cmpw cr6, r7, r9
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825DAC9C: 4198FBF0  blt cr6, 0x825da88c
	if ctx.cr[6].lt {
	pc = 0x825DA88C; continue 'dispatch;
	}
	// 825DACA0: 893FFFFF  lbz r9, -1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DACA4: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825DACA8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825DACAC: 7FE9FA14  add r31, r9, r31
	ctx.r[31].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 825DACB0: 4199FBDC  bgt cr6, 0x825da88c
	if ctx.cr[6].gt {
	pc = 0x825DA88C; continue 'dispatch;
	}
	// 825DACB4: 7CA9F850  subf r5, r9, r31
	ctx.r[5].s64 = ctx.r[31].s64 - ctx.r[9].s64;
	// 825DACB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DACBC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825DACC0: 4BFFFB79  bl 0x825da838
	ctx.lr = 0x825DACC4;
	sub_825DA838(ctx, base);
	// 825DACC4: 4BFFFBC8  b 0x825da88c
	pc = 0x825DA88C; continue 'dispatch;
            }
            0x825DACC8 => {
    //   block [0x825DACC8..0x825DAD18)
	// 825DACC8: 392BFFE0  addi r9, r11, -0x20
	ctx.r[9].s64 = ctx.r[11].s64 + -32;
	// 825DACCC: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DACD0: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DACD4: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825DACD8: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825DACDC: 7D29F02E  lwzx r9, r9, r30
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DACE0: 7D0B4A14  add r8, r11, r9
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DACE4: 7F085000  cmpw cr6, r8, r10
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825DACE8: 4198FBA4  blt cr6, 0x825da88c
	if ctx.cr[6].lt {
	pc = 0x825DA88C; continue 'dispatch;
	}
	// 825DACEC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DACF0: 891FFFFF  lbz r8, -1(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DACF4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DACF8: 7FE8FA14  add r31, r8, r31
	ctx.r[31].u64 = ctx.r[8].u64 + ctx.r[31].u64;
	// 825DACFC: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825DAD00: 4199FB8C  bgt cr6, 0x825da88c
	if ctx.cr[6].gt {
	pc = 0x825DA88C; continue 'dispatch;
	}
	// 825DAD04: 7CA8F850  subf r5, r8, r31
	ctx.r[5].s64 = ctx.r[31].s64 - ctx.r[8].s64;
	// 825DAD08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DAD0C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825DAD10: 4BFFFB29  bl 0x825da838
	ctx.lr = 0x825DAD14;
	sub_825DA838(ctx, base);
	// 825DAD14: 4BFFFB78  b 0x825da88c
	pc = 0x825DA88C; continue 'dispatch;
            }
            0x825DAD18 => {
    //   block [0x825DAD18..0x825DAD90)
	// 825DAD18: 396BFFDD  addi r11, r11, -0x23
	ctx.r[11].s64 = ctx.r[11].s64 + -35;
	// 825DAD1C: 88FF0004  lbz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAD20: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DAD24: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825DAD28: 897F0003  lbz r11, 3(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DAD2C: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DAD30: 5569403E  rotlwi r9, r11, 8
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DAD34: 88DF0001  lbz r6, 1(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DAD38: 397F0007  addi r11, r31, 7
	ctx.r[11].s64 = ctx.r[31].s64 + 7;
	// 825DAD3C: 7CE93A14  add r7, r9, r7
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 825DAD40: 7D25F02E  lwzx r9, r5, r30
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DAD44: 7CAA4A14  add r5, r10, r9
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825DAD48: 7F054000  cmpw cr6, r5, r8
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[8].s32, &mut ctx.xer);
	// 825DAD4C: 4098000C  bge cr6, 0x825dad58
	if !ctx.cr[6].lt {
	pc = 0x825DAD58; continue 'dispatch;
	}
	// 825DAD50: 7FE75A14  add r31, r7, r11
	ctx.r[31].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 825DAD54: 4BFFFB38  b 0x825da88c
	pc = 0x825DA88C; continue 'dispatch;
	// 825DAD58: 88ABFFFE  lbz r5, -2(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 825DAD5C: 7CCA3214  add r6, r10, r6
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 825DAD60: 890BFFFF  lbz r8, -1(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DAD64: 54AA403E  rotlwi r10, r5, 8
	ctx.r[10].u64 = ((ctx.r[5].u32).rotate_left(8)) as u64;
	// 825DAD68: 7F093000  cmpw cr6, r9, r6
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[6].s32, &mut ctx.xer);
	// 825DAD6C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825DAD70: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825DAD74: 4199FB18  bgt cr6, 0x825da88c
	if ctx.cr[6].gt {
	pc = 0x825DA88C; continue 'dispatch;
	}
	// 825DAD78: 7D6A3850  subf r11, r10, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 825DAD7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DAD80: 7CABFA14  add r5, r11, r31
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DAD84: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825DAD88: 4BFFFAB1  bl 0x825da838
	ctx.lr = 0x825DAD8C;
	sub_825DA838(ctx, base);
	// 825DAD8C: 4BFFFB00  b 0x825da88c
	pc = 0x825DA88C; continue 'dispatch;
            }
            0x825DAD90 => {
    //   block [0x825DAD90..0x825DADC8)
	// 825DAD90: 394BFFDA  addi r10, r11, -0x26
	ctx.r[10].s64 = ctx.r[11].s64 + -38;
	// 825DAD94: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DAD98: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DAD9C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825DADA0: 7D4AF02E  lwzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DADA4: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DADA8: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825DADAC: 4198043C  blt cr6, 0x825db1e8
	if ctx.cr[6].lt {
	pc = 0x825DB1E8; continue 'dispatch;
	}
	// 825DADB0: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DADB4: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825DADB8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825DADBC: 4199042C  bgt cr6, 0x825db1e8
	if ctx.cr[6].gt {
	pc = 0x825DB1E8; continue 'dispatch;
	}
	// 825DADC0: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825DADC4: 4BFFFAC8  b 0x825da88c
	pc = 0x825DA88C; continue 'dispatch;
            }
            0x825DADC8 => {
    //   block [0x825DADC8..0x825DAE30)
	// 825DADC8: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DADCC: 396BFFDB  addi r11, r11, -0x25
	ctx.r[11].s64 = ctx.r[11].s64 + -37;
	// 825DADD0: 88FF0002  lbz r7, 2(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DADD4: 5529403E  rotlwi r9, r9, 8
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825DADD8: 891F0003  lbz r8, 3(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DADDC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DADE0: 815C001C  lwz r10, 0x1c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 825DADE4: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 825DADE8: 5529402E  slwi r9, r9, 8
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825DADEC: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 825DADF0: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825DADF4: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825DADF8: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825DADFC: 419803EC  blt cr6, 0x825db1e8
	if ctx.cr[6].lt {
	pc = 0x825DB1E8; continue 'dispatch;
	}
	// 825DAE00: 893F0004  lbz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAE04: 88FF0005  lbz r7, 5(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(5 as u32) ) } as u64;
	// 825DAE08: 5529403E  rotlwi r9, r9, 8
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825DAE0C: 891F0006  lbz r8, 6(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 825DAE10: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 825DAE14: 5529402E  slwi r9, r9, 8
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825DAE18: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825DAE1C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 825DAE20: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825DAE24: 419903C4  bgt cr6, 0x825db1e8
	if ctx.cr[6].gt {
	pc = 0x825DB1E8; continue 'dispatch;
	}
	// 825DAE28: 3BFF0007  addi r31, r31, 7
	ctx.r[31].s64 = ctx.r[31].s64 + 7;
	// 825DAE2C: 4BFFFA60  b 0x825da88c
	pc = 0x825DA88C; continue 'dispatch;
            }
            0x825DAE30 => {
    //   block [0x825DAE30..0x825DAE40)
	// 825DAE30: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DAE34: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DAE38: 3BEB0002  addi r31, r11, 2
	ctx.r[31].s64 = ctx.r[11].s64 + 2;
	// 825DAE3C: 4BFFFA50  b 0x825da88c
	pc = 0x825DA88C; continue 'dispatch;
            }
            0x825DAE40 => {
    //   block [0x825DAE40..0x825DAE5C)
	// 825DAE40: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DAE44: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DAE48: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DAE4C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DAE50: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DAE54: 3BEB0003  addi r31, r11, 3
	ctx.r[31].s64 = ctx.r[11].s64 + 3;
	// 825DAE58: 4BFFFA34  b 0x825da88c
	pc = 0x825DA88C; continue 'dispatch;
            }
            0x825DAE5C => {
    //   block [0x825DAE5C..0x825DAE84)
	// 825DAE5C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DAE60: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DAE64: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DAE68: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DAE6C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DAE70: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DAE74: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DAE78: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DAE7C: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 825DAE80: 4BFFFA0C  b 0x825da88c
	pc = 0x825DA88C; continue 'dispatch;
            }
            0x825DAE84 => {
    //   block [0x825DAE84..0x825DAF28)
	// 825DAE84: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DAE88: 80FC0010  lwz r7, 0x10(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DAE8C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825DAE90: 80DC0014  lwz r6, 0x14(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 825DAE94: 80BC0018  lwz r5, 0x18(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DAE98: 809C001C  lwz r4, 0x1c(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 825DAE9C: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 825DAEA0: 811E0010  lwz r8, 0x10(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DAEA4: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DAEA8: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825DAEAC: 7CE75630  sraw r7, r7, r10
	tmp.u32 = ctx.r[10].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 825DAEB0: 7D295830  slw r9, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825DAEB4: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 825DAEB8: 7CC65630  sraw r6, r6, r10
	tmp.u32 = ctx.r[10].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 825DAEBC: 7CA55630  sraw r5, r5, r10
	tmp.u32 = ctx.r[10].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[5].s32 >> tmp.u32) as i64;
	// 825DAEC0: 7C885630  sraw r8, r4, r10
	tmp.u32 = ctx.r[10].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[4].s32 >> tmp.u32) as i64;
	// 825DAEC4: 7D493850  subf r10, r9, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 825DAEC8: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 825DAECC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825DAED0: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825DAED4: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DAED8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825DAEDC: 7D4A5830  slw r10, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825DAEE0: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 825DAEE4: 7D4A3050  subf r10, r10, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825DAEE8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825DAEEC: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DAEF0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DAEF4: 813E0018  lwz r9, 0x18(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DAEF8: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 825DAEFC: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825DAF00: 7D4B5830  slw r11, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825DAF04: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825DAF08: 7D6B2850  subf r11, r11, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 825DAF0C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825DAF10: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 825DAF14: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825DAF18: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 825DAF1C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825DAF20: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825DAF24: 4BFFF968  b 0x825da88c
	pc = 0x825DA88C; continue 'dispatch;
            }
            0x825DAF28 => {
    //   block [0x825DAF28..0x825DAF70)
	// 825DAF28: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825DAF2C: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DAF30: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DAF34: 419A0028  beq cr6, 0x825daf5c
	if ctx.cr[6].eq {
	pc = 0x825DAF5C; continue 'dispatch;
	}
	// 825DAF38: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825DAF3C: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 825DAF40: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825DAF44: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAF48: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825DAF4C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DAF50: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825DAF54: 4200FFF0  bdnz 0x825daf44
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825DAF44; continue 'dispatch;
	}
	// 825DAF58: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825DAF5C: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825DAF60: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825DAF64: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825DAF68: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825DAF6C: 4BFFF920  b 0x825da88c
	pc = 0x825DA88C; continue 'dispatch;
            }
            0x825DAF70 => {
    //   block [0x825DAF70..0x825DAFC4)
	// 825DAF70: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DAF74: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 825DAF78: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DAF7C: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DAF80: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825DAF84: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DAF88: 419A0028  beq cr6, 0x825dafb0
	if ctx.cr[6].eq {
	pc = 0x825DAFB0; continue 'dispatch;
	}
	// 825DAF8C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825DAF90: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 825DAF94: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825DAF98: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAF9C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825DAFA0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DAFA4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825DAFA8: 4200FFF0  bdnz 0x825daf98
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825DAF98; continue 'dispatch;
	}
	// 825DAFAC: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825DAFB0: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825DAFB4: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825DAFB8: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825DAFBC: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825DAFC0: 4BFFF8CC  b 0x825da88c
	pc = 0x825DA88C; continue 'dispatch;
            }
            0x825DAFC4 => {
    //   block [0x825DAFC4..0x825DB028)
	// 825DAFC4: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DAFC8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825DAFCC: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DAFD0: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DAFD4: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DAFD8: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAFDC: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825DAFE0: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825DAFE4: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DAFE8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DAFEC: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DAFF0: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DAFF4: 419A0028  beq cr6, 0x825db01c
	if ctx.cr[6].eq {
	pc = 0x825DB01C; continue 'dispatch;
	}
	// 825DAFF8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825DAFFC: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 825DB000: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825DB004: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB008: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825DB00C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DB010: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825DB014: 4200FFF0  bdnz 0x825db004
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825DB004; continue 'dispatch;
	}
	// 825DB018: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825DB01C: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 825DB020: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825DB024: 4BFFF868  b 0x825da88c
	pc = 0x825DA88C; continue 'dispatch;
            }
            0x825DB028 => {
    //   block [0x825DB028..0x825DB044)
	// 825DB028: 396BFFA0  addi r11, r11, -0x60
	ctx.r[11].s64 = ctx.r[11].s64 + -96;
	// 825DB02C: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DB030: 39210074  addi r9, r1, 0x74
	ctx.r[9].s64 = ctx.r[1].s64 + 116;
	// 825DB034: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DB038: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825DB03C: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 825DB040: 48000068  b 0x825db0a8
	pc = 0x825DB0A8; continue 'dispatch;
            }
            0x825DB044 => {
    //   block [0x825DB044..0x825DB06C)
	// 825DB044: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DB048: 390BFF9C  addi r8, r11, -0x64
	ctx.r[8].s64 = ctx.r[11].s64 + -100;
	// 825DB04C: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DB050: 38E10074  addi r7, r1, 0x74
	ctx.r[7].s64 = ctx.r[1].s64 + 116;
	// 825DB054: 552B403E  rotlwi r11, r9, 8
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825DB058: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825DB05C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DB060: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825DB064: 7D69392E  stwx r11, r9, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 825DB068: 48000040  b 0x825db0a8
	pc = 0x825DB0A8; continue 'dispatch;
            }
            0x825DB06C => {
    //   block [0x825DB06C..0x825DB0E4)
	// 825DB06C: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DB070: 38EBFF98  addi r7, r11, -0x68
	ctx.r[7].s64 = ctx.r[11].s64 + -104;
	// 825DB074: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DB078: 38C10074  addi r6, r1, 0x74
	ctx.r[6].s64 = ctx.r[1].s64 + 116;
	// 825DB07C: 554B403E  rotlwi r11, r10, 8
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825DB080: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DB084: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB088: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825DB08C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825DB090: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825DB094: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DB098: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DB09C: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DB0A0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DB0A4: 7D67312E  stwx r11, r7, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 825DB0A8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825DB0AC: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825DB0B0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DB0B4: 419A0028  beq cr6, 0x825db0dc
	if ctx.cr[6].eq {
	pc = 0x825DB0DC; continue 'dispatch;
	}
	// 825DB0B8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825DB0BC: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 825DB0C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825DB0C4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB0C8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825DB0CC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DB0D0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825DB0D4: 4200FFF0  bdnz 0x825db0c4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825DB0C4; continue 'dispatch;
	}
	// 825DB0D8: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825DB0DC: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 825DB0E0: 4BFFF7AC  b 0x825da88c
	pc = 0x825DA88C; continue 'dispatch;
            }
            0x825DB0E4 => {
    //   block [0x825DB0E4..0x825DB138)
	// 825DB0E4: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 825DB0E8: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 825DB0EC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825DB0F0: 4BE8DD09  bl 0x82468df8
	ctx.lr = 0x825DB0F4;
	sub_82468DF8(ctx, base);
	// 825DB0F4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825DB0F8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825DB0FC: 4BE8D1A5  bl 0x824682a0
	ctx.lr = 0x825DB100;
	sub_824682A0(ctx, base);
	// 825DB100: 807A9190  lwz r3, -0x6e70(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-28272 as u32) ) } as u64;
	// 825DB104: 3CA01298  lis r5, 0x1298
	ctx.r[5].s64 = 311951360;
	// 825DB108: 39000124  li r8, 0x124
	ctx.r[8].s64 = 292;
	// 825DB10C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825DB110: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 825DB114: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB118: 60A5FEDD  ori r5, r5, 0xfedd
	ctx.r[5].u64 = ctx.r[5].u64 | 65245;
	// 825DB11C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825DB120: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DB124: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DB128: 4E800421  bctrl
	ctx.lr = 0x825DB12C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DB12C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825DB130: 4BE8D7B1  bl 0x824688e0
	ctx.lr = 0x825DB134;
	sub_824688E0(ctx, base);
	// 825DB134: 4BFFF758  b 0x825da88c
	pc = 0x825DA88C; continue 'dispatch;
            }
            0x825DB138 => {
    //   block [0x825DB138..0x825DB140)
	// 825DB138: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DB13C: 48000068  b 0x825db1a4
	pc = 0x825DB1A4; continue 'dispatch;
            }
            0x825DB140 => {
    //   block [0x825DB140..0x825DB154)
	// 825DB140: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DB144: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DB148: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DB14C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DB150: 48000054  b 0x825db1a4
	pc = 0x825DB1A4; continue 'dispatch;
            }
            0x825DB154 => {
    //   block [0x825DB154..0x825DB174)
	// 825DB154: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DB158: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DB15C: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DB160: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DB164: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DB168: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DB16C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DB170: 48000034  b 0x825db1a4
	pc = 0x825DB1A4; continue 'dispatch;
            }
            0x825DB174 => {
    //   block [0x825DB174..0x825DB1A0)
	// 825DB174: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DB178: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DB17C: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DB180: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DB184: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB188: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825DB18C: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DB190: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DB194: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DB198: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DB19C: 48000008  b 0x825db1a4
	pc = 0x825DB1A4; continue 'dispatch;
            }
            0x825DB1A0 => {
    //   block [0x825DB1A0..0x825DB1E8)
	// 825DB1A0: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 825DB1A4: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB1A8: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 825DB1AC: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825DB1B0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB1B4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB1B8: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825DB1BC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825DB1C0: 409A0010  bne cr6, 0x825db1d0
	if !ctx.cr[6].eq {
	pc = 0x825DB1D0; continue 'dispatch;
	}
	// 825DB1C4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 825DB1C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DB1CC: 4BE93185  bl 0x8246e350
	ctx.lr = 0x825DB1D0;
	sub_8246E350(ctx, base);
	// 825DB1D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB1D4: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB1D8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825DB1DC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DB1E0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825DB1E4: 7FCA492E  stwx r30, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[30].u32) };
	pc = 0x825DB1E8; continue 'dispatch;
            }
            0x825DB1E8 => {
    //   block [0x825DB1E8..0x825DB1F0)
	// 825DB1E8: 382102D0  addi r1, r1, 0x2d0
	ctx.r[1].s64 = ctx.r[1].s64 + 720;
	// 825DB1EC: 4BF59F14  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DB1F0 size=300
    let mut pc: u32 = 0x825DB1F0;
    'dispatch: loop {
        match pc {
            0x825DB1F0 => {
    //   block [0x825DB1F0..0x825DB31C)
	// 825DB1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DB1F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DB1F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DB1FC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825DB200: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 825DB204: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 825DB208: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825DB20C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 825DB210: 80AB0020  lwz r5, 0x20(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DB214: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825DB218: 90C30000  stw r6, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 825DB21C: C1AB0010  lfs f13, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DB220: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DB224: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825DB228: C1AB001C  lfs f13, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DB22C: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 825DB230: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 825DB234: 91210078  stw r9, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 825DB238: 9121007C  stw r9, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[9].u32 ) };
	// 825DB23C: 91210084  stw r9, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 825DB240: 90E10080  stw r7, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[7].u32 ) };
	// 825DB244: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DB248: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 825DB24C: 7C0047AE  stfiwx f0, 0, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 825DB250: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DB254: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 825DB258: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825DB25C: 91230010  stw r9, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 825DB260: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DB264: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DB268: A1230010  lhz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DB26C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825DB270: C1AB001C  lfs f13, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DB274: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 825DB278: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 825DB27C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DB280: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 825DB284: 7C0047AE  stfiwx f0, 0, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 825DB288: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DB28C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 825DB290: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825DB294: 91230014  stw r9, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 825DB298: C1AB0018  lfs f13, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DB29C: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DB2A0: A1230014  lhz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 825DB2A4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825DB2A8: C1AB001C  lfs f13, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DB2AC: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 825DB2B0: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 825DB2B4: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DB2B8: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 825DB2BC: 7C0047AE  stfiwx f0, 0, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 825DB2C0: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DB2C4: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 825DB2C8: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825DB2CC: 91230018  stw r9, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 825DB2D0: C1AB001C  lfs f13, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DB2D4: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DB2D8: A1630018  lhz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DB2DC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DB2E0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 825DB2E4: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825DB2E8: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 825DB2EC: 7C0047AE  stfiwx f0, 0, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 825DB2F0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DB2F4: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 825DB2F8: 7D6A8670  srawi r10, r11, 0x10
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 16) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 16) as i64;
	// 825DB2FC: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 825DB300: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 825DB304: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825DB308: 4BFFF531  bl 0x825da838
	ctx.lr = 0x825DB30C;
	sub_825DA838(ctx, base);
	// 825DB30C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825DB310: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DB314: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DB318: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825DB320 size=36
    let mut pc: u32 = 0x825DB320;
    'dispatch: loop {
        match pc {
            0x825DB320 => {
    //   block [0x825DB320..0x825DB344)
	// 825DB320: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DB324: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 825DB328: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DB32C: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825DB330: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DB334: D0080000  stfs f0, 0(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825DB338: D02B0000  stfs f1, 0(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825DB33C: D04B0004  stfs f2, 4(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825DB340: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825DB348 size=20
    let mut pc: u32 = 0x825DB348;
    'dispatch: loop {
        match pc {
            0x825DB348 => {
    //   block [0x825DB348..0x825DB35C)
	// 825DB348: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DB34C: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 825DB350: 7C2B1C2E  lfsx f1, r11, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825DB354: 7C0B1D2E  stfsx f0, r11, r3
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), tmp.u32) };
	// 825DB358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825DB360 size=24
    let mut pc: u32 = 0x825DB360;
    'dispatch: loop {
        match pc {
            0x825DB360 => {
    //   block [0x825DB360..0x825DB378)
	// 825DB360: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DB364: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 825DB368: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 825DB36C: C02B0004  lfs f1, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825DB370: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825DB374: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DB378 size=96
    let mut pc: u32 = 0x825DB378;
    'dispatch: loop {
        match pc {
            0x825DB378 => {
    //   block [0x825DB378..0x825DB3D8)
	// 825DB378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DB37C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DB380: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DB384: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DB388: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DB38C: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 825DB390: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DB394: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 825DB398: 9883006D  stb r4, 0x6d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(109 as u32), ctx.r[4].u8 ) };
	// 825DB39C: 419A0008  beq cr6, 0x825db3a4
	if ctx.cr[6].eq {
	pc = 0x825DB3A4; continue 'dispatch;
	}
	// 825DB3A0: 90A30068  stw r5, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[5].u32 ) };
	// 825DB3A4: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 825DB3A8: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 825DB3AC: 38A00068  li r5, 0x68
	ctx.r[5].s64 = 104;
	// 825DB3B0: 9963006C  stb r11, 0x6c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[11].u8 ) };
	// 825DB3B4: 4BF5979D  bl 0x82534b50
	ctx.lr = 0x825DB3B8;
	sub_82534B50(ctx, base);
	// 825DB3B8: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 825DB3BC: 396B0070  addi r11, r11, 0x70
	ctx.r[11].s64 = ctx.r[11].s64 + 112;
	// 825DB3C0: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 825DB3C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DB3C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DB3CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DB3D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DB3D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DB3D8 size=44
    let mut pc: u32 = 0x825DB3D8;
    'dispatch: loop {
        match pc {
            0x825DB3D8 => {
    //   block [0x825DB3D8..0x825DB404)
	// 825DB3D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DB3DC: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 825DB3E0: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 825DB3E4: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 825DB3E8: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 825DB3EC: 9143003C  stw r10, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 825DB3F0: 996300B0  stb r11, 0xb0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), ctx.r[11].u8 ) };
	// 825DB3F4: 912300B4  stw r9, 0xb4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), ctx.r[9].u32 ) };
	// 825DB3F8: 996300B8  stb r11, 0xb8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), ctx.r[11].u8 ) };
	// 825DB3FC: 916300BC  stw r11, 0xbc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 825DB400: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DB408 size=16
    let mut pc: u32 = 0x825DB408;
    'dispatch: loop {
        match pc {
            0x825DB408 => {
    //   block [0x825DB408..0x825DB418)
	// 825DB408: 8163003C  lwz r11, 0x3c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 825DB40C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825DB410: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825DB414: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DB418 size=28
    let mut pc: u32 = 0x825DB418;
    'dispatch: loop {
        match pc {
            0x825DB418 => {
    //   block [0x825DB418..0x825DB434)
	// 825DB418: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB41C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825DB420: 80830034  lwz r4, 0x34(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 825DB424: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825DB428: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825DB42C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825DB430: 4BE88C88  b 0x824640b8
	sub_824640B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB434(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DB434 size=4
    let mut pc: u32 = 0x825DB434;
    'dispatch: loop {
        match pc {
            0x825DB434 => {
    //   block [0x825DB434..0x825DB438)
	// 825DB434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DB438 size=308
    let mut pc: u32 = 0x825DB438;
    'dispatch: loop {
        match pc {
            0x825DB438 => {
    //   block [0x825DB438..0x825DB56C)
	// 825DB438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DB43C: 4BF59C79  bl 0x825350b4
	ctx.lr = 0x825DB440;
	sub_82535080(ctx, base);
	// 825DB440: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DB444: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DB448: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825DB44C: 3BBF0034  addi r29, r31, 0x34
	ctx.r[29].s64 = ctx.r[31].s64 + 52;
	// 825DB450: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DB454: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825DB458: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB45C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825DB460: 40990030  ble cr6, 0x825db490
	if !ctx.cr[6].gt {
	pc = 0x825DB490; continue 'dispatch;
	}
	// 825DB464: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB468: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB46C: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825DB470: 419A0018  beq cr6, 0x825db488
	if ctx.cr[6].eq {
	pc = 0x825DB488; continue 'dispatch;
	}
	// 825DB474: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DB478: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825DB47C: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825DB480: 4198FFE8  blt cr6, 0x825db468
	if ctx.cr[6].lt {
	pc = 0x825DB468; continue 'dispatch;
	}
	// 825DB484: 4800000C  b 0x825db490
	pc = 0x825DB490; continue 'dispatch;
	// 825DB488: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 825DB48C: 409A00C8  bne cr6, 0x825db554
	if !ctx.cr[6].eq {
	pc = 0x825DB554; continue 'dispatch;
	}
	// 825DB490: 897F00B8  lbz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 825DB494: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825DB498: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DB49C: 419A0014  beq cr6, 0x825db4b0
	if ctx.cr[6].eq {
	pc = 0x825DB4B0; continue 'dispatch;
	}
	// 825DB4A0: 815F00BC  lwz r10, 0xbc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 825DB4A4: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 825DB4A8: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825DB4AC: 419A0008  beq cr6, 0x825db4b4
	if ctx.cr[6].eq {
	pc = 0x825DB4B4; continue 'dispatch;
	}
	// 825DB4B0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825DB4B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DB4B8: 419A0010  beq cr6, 0x825db4c8
	if ctx.cr[6].eq {
	pc = 0x825DB4C8; continue 'dispatch;
	}
	// 825DB4BC: 7FCB0774  extsb r11, r30
	ctx.r[11].s64 = ctx.r[30].s8 as i64;
	// 825DB4C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DB4C4: 419A0054  beq cr6, 0x825db518
	if ctx.cr[6].eq {
	pc = 0x825DB518; continue 'dispatch;
	}
	// 825DB4C8: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 825DB4CC: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 825DB4D0: 38A00068  li r5, 0x68
	ctx.r[5].s64 = 104;
	// 825DB4D4: 9B63006D  stb r27, 0x6d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(109 as u32), ctx.r[27].u8 ) };
	// 825DB4D8: 93830068  stw r28, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 825DB4DC: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 825DB4E0: 9963006C  stb r11, 0x6c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[11].u8 ) };
	// 825DB4E4: 4BF5966D  bl 0x82534b50
	ctx.lr = 0x825DB4E8;
	sub_82534B50(ctx, base);
	// 825DB4E8: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 825DB4EC: 895F00B0  lbz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 825DB4F0: 396B0070  addi r11, r11, 0x70
	ctx.r[11].s64 = ctx.r[11].s64 + 112;
	// 825DB4F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825DB4F8: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 825DB4FC: 409A0014  bne cr6, 0x825db510
	if !ctx.cr[6].eq {
	pc = 0x825DB510; continue 'dispatch;
	}
	// 825DB500: 7FCB0774  extsb r11, r30
	ctx.r[11].s64 = ctx.r[30].s8 as i64;
	// 825DB504: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DB508: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DB50C: 419A0008  beq cr6, 0x825db514
	if ctx.cr[6].eq {
	pc = 0x825DB514; continue 'dispatch;
	}
	// 825DB510: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 825DB514: 997F00B0  stb r11, 0xb0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[11].u8 ) };
	// 825DB518: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB51C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB520: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825DB524: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825DB528: 409A0010  bne cr6, 0x825db538
	if !ctx.cr[6].eq {
	pc = 0x825DB538; continue 'dispatch;
	}
	// 825DB52C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 825DB530: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825DB534: 4BE92E1D  bl 0x8246e350
	ctx.lr = 0x825DB538;
	sub_8246E350(ctx, base);
	// 825DB538: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB53C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB540: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DB544: 7F8B512E  stwx r28, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[28].u32) };
	// 825DB548: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB54C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DB550: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825DB554: 897F00B0  lbz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 825DB558: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DB55C: 419A0008  beq cr6, 0x825db564
	if ctx.cr[6].eq {
	pc = 0x825DB564; continue 'dispatch;
	}
	// 825DB560: 9B7F00C0  stb r27, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[27].u8 ) };
	// 825DB564: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DB568: 4BF59B9C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DB570 size=4024
    let mut pc: u32 = 0x825DB570;
    'dispatch: loop {
        match pc {
            0x825DB570 => {
    //   block [0x825DB570..0x825DB784)
	// 825DB570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DB574: 4BF59B35  bl 0x825350a8
	ctx.lr = 0x825DB578;
	sub_82535080(ctx, base);
	// 825DB578: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 825DB57C: 4BF5AA6D  bl 0x82535fe8
	ctx.lr = 0x825DB580;
	sub_82535FB0(ctx, base);
	// 825DB580: 9421FCF0  stwu r1, -0x310(r1)
	ea = ctx.r[1].u32.wrapping_add(-784 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DB584: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825DB588: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DB58C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DB590: 895D00C0  lbz r10, 0xc0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(192 as u32) ) } as u64;
	// 825DB594: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB598: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825DB59C: 409A0F7C  bne cr6, 0x825dc518
	if !ctx.cr[6].eq {
	pc = 0x825DC518; continue 'dispatch;
	}
	// 825DB5A0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825DB5A4: 3F408293  lis r26, -0x7d6d
	ctx.r[26].s64 = -2104295424;
	// 825DB5A8: 3B8AA61C  addi r28, r10, -0x59e4
	ctx.r[28].s64 = ctx.r[10].s64 + -23012;
	// 825DB5AC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825DB5B0: 3B6AA1D8  addi r27, r10, -0x5e28
	ctx.r[27].s64 = ctx.r[10].s64 + -24104;
	// 825DB5B4: 2B0B006B  cmplwi cr6, r11, 0x6b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 107 as u32, &mut ctx.xer);
	// 825DB5B8: 41990458  bgt cr6, 0x825dba10
	if ctx.cr[6].gt {
	pc = 0x825DBA10; continue 'dispatch;
	}
	// 825DB5BC: 3D80825E  lis r12, -0x7da2
	ctx.r[12].s64 = -2107768832;
	// 825DB5C0: 398CB5D4  addi r12, r12, -0x4a2c
	ctx.r[12].s64 = ctx.r[12].s64 + -18988;
	// 825DB5C4: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825DB5C8: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825DB5CC: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825DB5D0: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825DB7D8; continue 'dispatch;
		},
		1 => {
	pc = 0x825DB7D8; continue 'dispatch;
		},
		2 => {
	pc = 0x825DB7D8; continue 'dispatch;
		},
		3 => {
	pc = 0x825DB7D8; continue 'dispatch;
		},
		4 => {
	pc = 0x825DB7D8; continue 'dispatch;
		},
		5 => {
	pc = 0x825DB784; continue 'dispatch;
		},
		6 => {
	pc = 0x825DB794; continue 'dispatch;
		},
		7 => {
	pc = 0x825DB7B0; continue 'dispatch;
		},
		8 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		9 => {
	pc = 0x825DB854; continue 'dispatch;
		},
		10 => {
	pc = 0x825DB89C; continue 'dispatch;
		},
		11 => {
	pc = 0x825DB8F0; continue 'dispatch;
		},
		12 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		13 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		14 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		15 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		16 => {
	pc = 0x825DC090; continue 'dispatch;
		},
		17 => {
	pc = 0x825DC090; continue 'dispatch;
		},
		18 => {
	pc = 0x825DC090; continue 'dispatch;
		},
		19 => {
	pc = 0x825DBA80; continue 'dispatch;
		},
		20 => {
	pc = 0x825DBB10; continue 'dispatch;
		},
		21 => {
	pc = 0x825DBBA8; continue 'dispatch;
		},
		22 => {
	pc = 0x825DBC38; continue 'dispatch;
		},
		23 => {
	pc = 0x825DBCD0; continue 'dispatch;
		},
		24 => {
	pc = 0x825DBD60; continue 'dispatch;
		},
		25 => {
	pc = 0x825DBDF8; continue 'dispatch;
		},
		26 => {
	pc = 0x825DBE98; continue 'dispatch;
		},
		27 => {
	pc = 0x825DBF40; continue 'dispatch;
		},
		28 => {
	pc = 0x825DBFE8; continue 'dispatch;
		},
		29 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		30 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		31 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		32 => {
	pc = 0x825DC0E4; continue 'dispatch;
		},
		33 => {
	pc = 0x825DC0E4; continue 'dispatch;
		},
		34 => {
	pc = 0x825DC0E4; continue 'dispatch;
		},
		35 => {
	pc = 0x825DC154; continue 'dispatch;
		},
		36 => {
	pc = 0x825DC154; continue 'dispatch;
		},
		37 => {
	pc = 0x825DC154; continue 'dispatch;
		},
		38 => {
	pc = 0x825DC240; continue 'dispatch;
		},
		39 => {
	pc = 0x825DC240; continue 'dispatch;
		},
		40 => {
	pc = 0x825DC240; continue 'dispatch;
		},
		41 => {
	pc = 0x825DC374; continue 'dispatch;
		},
		42 => {
	pc = 0x825DC374; continue 'dispatch;
		},
		43 => {
	pc = 0x825DC374; continue 'dispatch;
		},
		44 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		45 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		46 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		47 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		48 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		49 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		50 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		51 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		52 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		53 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		54 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		55 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		56 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		57 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		58 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		59 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		60 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		61 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		62 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		63 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		64 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		65 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		66 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		67 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		68 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		69 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		70 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		71 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		72 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		73 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		74 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		75 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		76 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		77 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		78 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		79 => {
	pc = 0x825DC4EC; continue 'dispatch;
		},
		80 => {
	pc = 0x825DC4AC; continue 'dispatch;
		},
		81 => {
	pc = 0x825DC4B4; continue 'dispatch;
		},
		82 => {
	pc = 0x825DC4C8; continue 'dispatch;
		},
		83 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		84 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		85 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		86 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		87 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		88 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		89 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		90 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		91 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		92 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		93 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		94 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		95 => {
	pc = 0x825DBA10; continue 'dispatch;
		},
		96 => {
	pc = 0x825DB954; continue 'dispatch;
		},
		97 => {
	pc = 0x825DB954; continue 'dispatch;
		},
		98 => {
	pc = 0x825DB954; continue 'dispatch;
		},
		99 => {
	pc = 0x825DB954; continue 'dispatch;
		},
		100 => {
	pc = 0x825DB970; continue 'dispatch;
		},
		101 => {
	pc = 0x825DB970; continue 'dispatch;
		},
		102 => {
	pc = 0x825DB970; continue 'dispatch;
		},
		103 => {
	pc = 0x825DB970; continue 'dispatch;
		},
		104 => {
	pc = 0x825DB998; continue 'dispatch;
		},
		105 => {
	pc = 0x825DB998; continue 'dispatch;
		},
		106 => {
	pc = 0x825DB998; continue 'dispatch;
		},
		107 => {
	pc = 0x825DB998; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825DB5D4: 825DB7D8  lwz r18, -0x4828(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18472 as u32) ) } as u64;
	// 825DB5D8: 825DB7D8  lwz r18, -0x4828(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18472 as u32) ) } as u64;
	// 825DB5DC: 825DB7D8  lwz r18, -0x4828(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18472 as u32) ) } as u64;
	// 825DB5E0: 825DB7D8  lwz r18, -0x4828(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18472 as u32) ) } as u64;
	// 825DB5E4: 825DB7D8  lwz r18, -0x4828(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18472 as u32) ) } as u64;
	// 825DB5E8: 825DB784  lwz r18, -0x487c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18556 as u32) ) } as u64;
	// 825DB5EC: 825DB794  lwz r18, -0x486c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18540 as u32) ) } as u64;
	// 825DB5F0: 825DB7B0  lwz r18, -0x4850(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18512 as u32) ) } as u64;
	// 825DB5F4: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB5F8: 825DB854  lwz r18, -0x47ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18348 as u32) ) } as u64;
	// 825DB5FC: 825DB89C  lwz r18, -0x4764(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18276 as u32) ) } as u64;
	// 825DB600: 825DB8F0  lwz r18, -0x4710(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18192 as u32) ) } as u64;
	// 825DB604: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB608: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB60C: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB610: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB614: 825DC090  lwz r18, -0x3f70(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-16240 as u32) ) } as u64;
	// 825DB618: 825DC090  lwz r18, -0x3f70(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-16240 as u32) ) } as u64;
	// 825DB61C: 825DC090  lwz r18, -0x3f70(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-16240 as u32) ) } as u64;
	// 825DB620: 825DBA80  lwz r18, -0x4580(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17792 as u32) ) } as u64;
	// 825DB624: 825DBB10  lwz r18, -0x44f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17648 as u32) ) } as u64;
	// 825DB628: 825DBBA8  lwz r18, -0x4458(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17496 as u32) ) } as u64;
	// 825DB62C: 825DBC38  lwz r18, -0x43c8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17352 as u32) ) } as u64;
	// 825DB630: 825DBCD0  lwz r18, -0x4330(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17200 as u32) ) } as u64;
	// 825DB634: 825DBD60  lwz r18, -0x42a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17056 as u32) ) } as u64;
	// 825DB638: 825DBDF8  lwz r18, -0x4208(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-16904 as u32) ) } as u64;
	// 825DB63C: 825DBE98  lwz r18, -0x4168(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-16744 as u32) ) } as u64;
	// 825DB640: 825DBF40  lwz r18, -0x40c0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-16576 as u32) ) } as u64;
	// 825DB644: 825DBFE8  lwz r18, -0x4018(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-16408 as u32) ) } as u64;
	// 825DB648: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB64C: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB650: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB654: 825DC0E4  lwz r18, -0x3f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-16156 as u32) ) } as u64;
	// 825DB658: 825DC0E4  lwz r18, -0x3f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-16156 as u32) ) } as u64;
	// 825DB65C: 825DC0E4  lwz r18, -0x3f1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-16156 as u32) ) } as u64;
	// 825DB660: 825DC154  lwz r18, -0x3eac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-16044 as u32) ) } as u64;
	// 825DB664: 825DC154  lwz r18, -0x3eac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-16044 as u32) ) } as u64;
	// 825DB668: 825DC154  lwz r18, -0x3eac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-16044 as u32) ) } as u64;
	// 825DB66C: 825DC240  lwz r18, -0x3dc0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15808 as u32) ) } as u64;
	// 825DB670: 825DC240  lwz r18, -0x3dc0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15808 as u32) ) } as u64;
	// 825DB674: 825DC240  lwz r18, -0x3dc0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15808 as u32) ) } as u64;
	// 825DB678: 825DC374  lwz r18, -0x3c8c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15500 as u32) ) } as u64;
	// 825DB67C: 825DC374  lwz r18, -0x3c8c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15500 as u32) ) } as u64;
	// 825DB680: 825DC374  lwz r18, -0x3c8c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15500 as u32) ) } as u64;
	// 825DB684: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB688: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB68C: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB690: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB694: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB698: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB69C: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6A0: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6A4: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6A8: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6AC: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6B0: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6B4: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6B8: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6BC: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6C0: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6C4: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6C8: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6CC: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6D0: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6D4: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6D8: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6DC: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6E0: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6E4: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6E8: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6EC: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6F0: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6F4: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6F8: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB6FC: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB700: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB704: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB708: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB70C: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB710: 825DC4EC  lwz r18, -0x3b14(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15124 as u32) ) } as u64;
	// 825DB714: 825DC4AC  lwz r18, -0x3b54(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15188 as u32) ) } as u64;
	// 825DB718: 825DC4B4  lwz r18, -0x3b4c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15180 as u32) ) } as u64;
	// 825DB71C: 825DC4C8  lwz r18, -0x3b38(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-15160 as u32) ) } as u64;
	// 825DB720: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB724: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB728: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB72C: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB730: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB734: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB738: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB73C: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB740: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB744: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB748: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB74C: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB750: 825DBA10  lwz r18, -0x45f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17904 as u32) ) } as u64;
	// 825DB754: 825DB954  lwz r18, -0x46ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18092 as u32) ) } as u64;
	// 825DB758: 825DB954  lwz r18, -0x46ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18092 as u32) ) } as u64;
	// 825DB75C: 825DB954  lwz r18, -0x46ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18092 as u32) ) } as u64;
	// 825DB760: 825DB954  lwz r18, -0x46ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18092 as u32) ) } as u64;
	// 825DB764: 825DB970  lwz r18, -0x4690(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18064 as u32) ) } as u64;
	// 825DB768: 825DB970  lwz r18, -0x4690(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18064 as u32) ) } as u64;
	// 825DB76C: 825DB970  lwz r18, -0x4690(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18064 as u32) ) } as u64;
	// 825DB770: 825DB970  lwz r18, -0x4690(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18064 as u32) ) } as u64;
	// 825DB774: 825DB998  lwz r18, -0x4668(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18024 as u32) ) } as u64;
	// 825DB778: 825DB998  lwz r18, -0x4668(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18024 as u32) ) } as u64;
	// 825DB77C: 825DB998  lwz r18, -0x4668(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18024 as u32) ) } as u64;
	// 825DB780: 825DB998  lwz r18, -0x4668(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18024 as u32) ) } as u64;
            }
            0x825DB784 => {
    //   block [0x825DB784..0x825DB794)
	// 825DB784: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DB788: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DB78C: 3BEB0002  addi r31, r11, 2
	ctx.r[31].s64 = ctx.r[11].s64 + 2;
	// 825DB790: 480002D0  b 0x825dba60
	pc = 0x825DBA60; continue 'dispatch;
            }
            0x825DB794 => {
    //   block [0x825DB794..0x825DB7B0)
	// 825DB794: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DB798: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DB79C: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DB7A0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DB7A4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DB7A8: 3BEB0003  addi r31, r11, 3
	ctx.r[31].s64 = ctx.r[11].s64 + 3;
	// 825DB7AC: 480002B4  b 0x825dba60
	pc = 0x825DBA60; continue 'dispatch;
            }
            0x825DB7B0 => {
    //   block [0x825DB7B0..0x825DB7D8)
	// 825DB7B0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DB7B4: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DB7B8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DB7BC: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DB7C0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DB7C4: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DB7C8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DB7CC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DB7D0: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 825DB7D4: 4800028C  b 0x825dba60
	pc = 0x825DBA60; continue 'dispatch;
            }
            0x825DB7D8 => {
    //   block [0x825DB7D8..0x825DB854)
	// 825DB7D8: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DB7DC: 891F0001  lbz r8, 1(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DB7E0: 214A0010  subfic r10, r10, 0x10
	ctx.xer.ca = ctx.r[10].u32 <= 16 as u32;
	ctx.r[10].s64 = (16 as i64) - ctx.r[10].s64;
	// 825DB7E4: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB7E8: 7D0A5030  slw r10, r8, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[8].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DB7EC: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825DB7F0: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 825DB7F4: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DB7F8: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DB7FC: 214A0010  subfic r10, r10, 0x10
	ctx.xer.ca = ctx.r[10].u32 <= 16 as u32;
	ctx.r[10].s64 = (16 as i64) - ctx.r[10].s64;
	// 825DB800: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB804: 7D0A5030  slw r10, r8, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[8].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DB808: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825DB80C: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 825DB810: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DB814: 891F0003  lbz r8, 3(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DB818: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DB81C: 214A0010  subfic r10, r10, 0x10
	ctx.xer.ca = ctx.r[10].u32 <= 16 as u32;
	ctx.r[10].s64 = (16 as i64) - ctx.r[10].s64;
	// 825DB820: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB824: 7D0A5030  slw r10, r8, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[8].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DB828: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825DB82C: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 825DB830: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DB834: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825DB838: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 825DB83C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825DB840: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 825DB844: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DB848: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 825DB84C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 825DB850: 48000210  b 0x825dba60
	pc = 0x825DBA60; continue 'dispatch;
            }
            0x825DB854 => {
    //   block [0x825DB854..0x825DB89C)
	// 825DB854: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 825DB858: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DB85C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DB860: 419A0028  beq cr6, 0x825db888
	if ctx.cr[6].eq {
	pc = 0x825DB888; continue 'dispatch;
	}
	// 825DB864: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 825DB868: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825DB86C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825DB870: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB874: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825DB878: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DB87C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825DB880: 4200FFF0  bdnz 0x825db870
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825DB870; continue 'dispatch;
	}
	// 825DB884: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 825DB888: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 825DB88C: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825DB890: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825DB894: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 825DB898: 480001C8  b 0x825dba60
	pc = 0x825DBA60; continue 'dispatch;
            }
            0x825DB89C => {
    //   block [0x825DB89C..0x825DB8F0)
	// 825DB89C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DB8A0: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 825DB8A4: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DB8A8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DB8AC: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825DB8B0: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DB8B4: 419A0028  beq cr6, 0x825db8dc
	if ctx.cr[6].eq {
	pc = 0x825DB8DC; continue 'dispatch;
	}
	// 825DB8B8: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 825DB8BC: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825DB8C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825DB8C4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB8C8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825DB8CC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DB8D0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825DB8D4: 4200FFF0  bdnz 0x825db8c4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825DB8C4; continue 'dispatch;
	}
	// 825DB8D8: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 825DB8DC: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 825DB8E0: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825DB8E4: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825DB8E8: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 825DB8EC: 48000174  b 0x825dba60
	pc = 0x825DBA60; continue 'dispatch;
            }
            0x825DB8F0 => {
    //   block [0x825DB8F0..0x825DB954)
	// 825DB8F0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DB8F4: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 825DB8F8: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DB8FC: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DB900: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DB904: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB908: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825DB90C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825DB910: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DB914: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DB918: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DB91C: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DB920: 419A0028  beq cr6, 0x825db948
	if ctx.cr[6].eq {
	pc = 0x825DB948; continue 'dispatch;
	}
	// 825DB924: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 825DB928: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825DB92C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825DB930: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB934: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825DB938: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DB93C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825DB940: 4200FFF0  bdnz 0x825db930
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825DB930; continue 'dispatch;
	}
	// 825DB944: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 825DB948: 91210080  stw r9, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 825DB94C: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825DB950: 48000110  b 0x825dba60
	pc = 0x825DBA60; continue 'dispatch;
            }
            0x825DB954 => {
    //   block [0x825DB954..0x825DB970)
	// 825DB954: 396BFFA0  addi r11, r11, -0x60
	ctx.r[11].s64 = ctx.r[11].s64 + -96;
	// 825DB958: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DB95C: 39210084  addi r9, r1, 0x84
	ctx.r[9].s64 = ctx.r[1].s64 + 132;
	// 825DB960: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DB964: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825DB968: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 825DB96C: 48000068  b 0x825db9d4
	pc = 0x825DB9D4; continue 'dispatch;
            }
            0x825DB970 => {
    //   block [0x825DB970..0x825DB998)
	// 825DB970: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DB974: 390BFF9C  addi r8, r11, -0x64
	ctx.r[8].s64 = ctx.r[11].s64 + -100;
	// 825DB978: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DB97C: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
	// 825DB980: 552B403E  rotlwi r11, r9, 8
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825DB984: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825DB988: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DB98C: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825DB990: 7D69392E  stwx r11, r9, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 825DB994: 48000040  b 0x825db9d4
	pc = 0x825DB9D4; continue 'dispatch;
            }
            0x825DB998 => {
    //   block [0x825DB998..0x825DBA10)
	// 825DB998: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DB99C: 38EBFF98  addi r7, r11, -0x68
	ctx.r[7].s64 = ctx.r[11].s64 + -104;
	// 825DB9A0: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DB9A4: 38C10084  addi r6, r1, 0x84
	ctx.r[6].s64 = ctx.r[1].s64 + 132;
	// 825DB9A8: 554B403E  rotlwi r11, r10, 8
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825DB9AC: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DB9B0: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB9B4: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825DB9B8: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825DB9BC: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825DB9C0: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DB9C4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DB9C8: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DB9CC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DB9D0: 7D67312E  stwx r11, r7, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 825DB9D4: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 825DB9D8: 81210084  lwz r9, 0x84(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825DB9DC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DB9E0: 419A0028  beq cr6, 0x825dba08
	if ctx.cr[6].eq {
	pc = 0x825DBA08; continue 'dispatch;
	}
	// 825DB9E4: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 825DB9E8: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825DB9EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825DB9F0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB9F4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825DB9F8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DB9FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825DBA00: 4200FFF0  bdnz 0x825db9f0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825DB9F0; continue 'dispatch;
	}
	// 825DBA04: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 825DBA08: 91210084  stw r9, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 825DBA0C: 48000054  b 0x825dba60
	pc = 0x825DBA60; continue 'dispatch;
            }
            0x825DBA10 => {
    //   block [0x825DBA10..0x825DBA80)
	// 825DBA10: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 825DBA14: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 825DBA18: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825DBA1C: 4BE8D3DD  bl 0x82468df8
	ctx.lr = 0x825DBA20;
	sub_82468DF8(ctx, base);
	// 825DBA20: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825DBA24: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825DBA28: 4BE8C879  bl 0x824682a0
	ctx.lr = 0x825DBA2C;
	sub_824682A0(ctx, base);
	// 825DBA2C: 807A9190  lwz r3, -0x6e70(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-28272 as u32) ) } as u64;
	// 825DBA30: 3CA01298  lis r5, 0x1298
	ctx.r[5].s64 = 311951360;
	// 825DBA34: 39000251  li r8, 0x251
	ctx.r[8].s64 = 593;
	// 825DBA38: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825DBA3C: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 825DBA40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBA44: 60A5FEDD  ori r5, r5, 0xfedd
	ctx.r[5].u64 = ctx.r[5].u64 | 65245;
	// 825DBA48: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825DBA4C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DBA50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DBA54: 4E800421  bctrl
	ctx.lr = 0x825DBA58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DBA58: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825DBA5C: 4BE8CE85  bl 0x824688e0
	ctx.lr = 0x825DBA60;
	sub_824688E0(ctx, base);
	// 825DBA60: 895D00C0  lbz r10, 0xc0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(192 as u32) ) } as u64;
	// 825DBA64: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBA68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825DBA6C: 419AFB48  beq cr6, 0x825db5b4
	if ctx.cr[6].eq {
	pc = 0x825DB5B4; continue 'dispatch;
	}
	// 825DBA70: 38210310  addi r1, r1, 0x310
	ctx.r[1].s64 = ctx.r[1].s64 + 784;
	// 825DBA74: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 825DBA78: 4BF5A5BD  bl 0x82536034
	ctx.lr = 0x825DBA7C;
	sub_82535FFC(ctx, base);
	// 825DBA7C: 4BF5967C  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x825DBA80 => {
    //   block [0x825DBA80..0x825DBB10)
	// 825DBA80: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DBA84: C1BD0010  lfs f13, 0x10(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DBA88: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DBA8C: 3B600003  li r27, 3
	ctx.r[27].s64 = 3;
	// 825DBA90: 891F0001  lbz r8, 1(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DBA94: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825DBA98: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DBA9C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DBAA0: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DBAA4: 5508083E  rotlwi r8, r8, 1
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 825DBAA8: 214A0010  subfic r10, r10, 0x10
	ctx.xer.ca = ctx.r[10].u32 <= 16 as u32;
	ctx.r[10].s64 = (16 as i64) - ctx.r[10].s64;
	// 825DBAAC: 5529083E  rotlwi r9, r9, 1
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825DBAB0: 7D6707B4  extsw r7, r11
	ctx.r[7].s64 = ctx.r[11].s32 as i64;
	// 825DBAB4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825DBAB8: F8E10068  std r7, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[7].u64 ) };
	// 825DBABC: 8BEBFFFF  lbz r31, -1(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DBAC0: 7D085030  slw r8, r8, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[8].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DBAC4: 7D2A5030  slw r10, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[9].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DBAC8: 7D0907B4  extsw r9, r8
	ctx.r[9].s64 = ctx.r[8].s32 as i64;
	// 825DBACC: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825DBAD0: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 825DBAD4: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825DBAD8: C8010068  lfd f0, 0x68(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 825DBADC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825DBAE0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825DBAE4: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825DBAE8: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DBAEC: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825DBAF0: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825DBAF4: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825DBAF8: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825DBAFC: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DBB00: ED6B002A  fadds f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DBB04: EC0C0372  fmuls f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DBB08: EFEB0372  fmuls f31, f11, f13
	ctx.f[31].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DBB0C: 480006CC  b 0x825dc1d8
	pc = 0x825DC1D8; continue 'dispatch;
            }
            0x825DBB10 => {
    //   block [0x825DBB10..0x825DBBA8)
	// 825DBB10: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DBB14: C1BD0010  lfs f13, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DBB18: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DBB1C: 3B600004  li r27, 4
	ctx.r[27].s64 = 4;
	// 825DBB20: 214B0010  subfic r10, r11, 0x10
	ctx.xer.ca = ctx.r[11].u32 <= 16 as u32;
	ctx.r[10].s64 = (16 as i64) - ctx.r[11].s64;
	// 825DBB24: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DBB28: 891F0001  lbz r8, 1(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DBB2C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825DBB30: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 825DBB34: 88FF0002  lbz r7, 2(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DBB38: 5509083E  rotlwi r9, r8, 1
	ctx.r[9].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 825DBB3C: 7D6807B4  extsw r8, r11
	ctx.r[8].s64 = ctx.r[11].s32 as i64;
	// 825DBB40: 54EB083E  rotlwi r11, r7, 1
	ctx.r[11].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 825DBB44: 3929FF01  addi r9, r9, -0xff
	ctx.r[9].s64 = ctx.r[9].s64 + -255;
	// 825DBB48: 38EBFF01  addi r7, r11, -0xff
	ctx.r[7].s64 = ctx.r[11].s64 + -255;
	// 825DBB4C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825DBB50: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 825DBB54: 8BEBFFFF  lbz r31, -1(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DBB58: 7D295030  slw r9, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DBB5C: 7CEA5030  slw r10, r7, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[7].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DBB60: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 825DBB64: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825DBB68: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 825DBB6C: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 825DBB70: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DBB74: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825DBB78: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825DBB7C: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825DBB80: C9610068  lfd f11, 0x68(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 825DBB84: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825DBB88: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825DBB8C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825DBB90: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825DBB94: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DBB98: ED6B002A  fadds f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DBB9C: EC0C0372  fmuls f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DBBA0: EFEB0372  fmuls f31, f11, f13
	ctx.f[31].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DBBA4: 48000634  b 0x825dc1d8
	pc = 0x825DC1D8; continue 'dispatch;
            }
            0x825DBBA8 => {
    //   block [0x825DBBA8..0x825DBC38)
	// 825DBBA8: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBBAC: C1BD0010  lfs f13, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DBBB0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DBBB4: 3B600005  li r27, 5
	ctx.r[27].s64 = 5;
	// 825DBBB8: 891F0001  lbz r8, 1(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DBBBC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825DBBC0: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DBBC4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DBBC8: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DBBCC: 5508083E  rotlwi r8, r8, 1
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 825DBBD0: 214A0010  subfic r10, r10, 0x10
	ctx.xer.ca = ctx.r[10].u32 <= 16 as u32;
	ctx.r[10].s64 = (16 as i64) - ctx.r[10].s64;
	// 825DBBD4: 5529083E  rotlwi r9, r9, 1
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825DBBD8: 7D6707B4  extsw r7, r11
	ctx.r[7].s64 = ctx.r[11].s32 as i64;
	// 825DBBDC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825DBBE0: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 825DBBE4: 8BEBFFFF  lbz r31, -1(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DBBE8: 7D085030  slw r8, r8, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[8].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DBBEC: 7D2A5030  slw r10, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[9].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DBBF0: 7D0907B4  extsw r9, r8
	ctx.r[9].s64 = ctx.r[8].s32 as i64;
	// 825DBBF4: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825DBBF8: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 825DBBFC: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 825DBC00: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DBC04: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825DBC08: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825DBC0C: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825DBC10: C9610068  lfd f11, 0x68(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 825DBC14: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825DBC18: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825DBC1C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825DBC20: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825DBC24: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DBC28: ED6B002A  fadds f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DBC2C: EC0C0372  fmuls f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DBC30: EFEB0372  fmuls f31, f11, f13
	ctx.f[31].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DBC34: 480005A4  b 0x825dc1d8
	pc = 0x825DC1D8; continue 'dispatch;
            }
            0x825DBC38 => {
    //   block [0x825DBC38..0x825DBCD0)
	// 825DBC38: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DBC3C: C1BD0010  lfs f13, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DBC40: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBC44: 3B600006  li r27, 6
	ctx.r[27].s64 = 6;
	// 825DBC48: 214B0010  subfic r10, r11, 0x10
	ctx.xer.ca = ctx.r[11].u32 <= 16 as u32;
	ctx.r[10].s64 = (16 as i64) - ctx.r[11].s64;
	// 825DBC4C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DBC50: 891F0001  lbz r8, 1(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DBC54: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825DBC58: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 825DBC5C: 88FF0002  lbz r7, 2(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DBC60: 5509083E  rotlwi r9, r8, 1
	ctx.r[9].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 825DBC64: 7D6807B4  extsw r8, r11
	ctx.r[8].s64 = ctx.r[11].s32 as i64;
	// 825DBC68: 54EB083E  rotlwi r11, r7, 1
	ctx.r[11].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 825DBC6C: 3929FF01  addi r9, r9, -0xff
	ctx.r[9].s64 = ctx.r[9].s64 + -255;
	// 825DBC70: 38EBFF01  addi r7, r11, -0xff
	ctx.r[7].s64 = ctx.r[11].s64 + -255;
	// 825DBC74: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825DBC78: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 825DBC7C: 8BEBFFFF  lbz r31, -1(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DBC80: 7D295030  slw r9, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DBC84: 7CEA5030  slw r10, r7, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[7].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DBC88: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 825DBC8C: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825DBC90: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 825DBC94: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 825DBC98: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DBC9C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825DBCA0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825DBCA4: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825DBCA8: C9610068  lfd f11, 0x68(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 825DBCAC: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825DBCB0: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825DBCB4: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825DBCB8: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825DBCBC: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DBCC0: ED6B002A  fadds f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DBCC4: EC0C0372  fmuls f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DBCC8: EFEB0372  fmuls f31, f11, f13
	ctx.f[31].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DBCCC: 4800050C  b 0x825dc1d8
	pc = 0x825DC1D8; continue 'dispatch;
            }
            0x825DBCD0 => {
    //   block [0x825DBCD0..0x825DBD60)
	// 825DBCD0: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBCD4: C1BD0010  lfs f13, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DBCD8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DBCDC: 3B600007  li r27, 7
	ctx.r[27].s64 = 7;
	// 825DBCE0: 891F0001  lbz r8, 1(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DBCE4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825DBCE8: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DBCEC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DBCF0: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DBCF4: 5508083E  rotlwi r8, r8, 1
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 825DBCF8: 214A0010  subfic r10, r10, 0x10
	ctx.xer.ca = ctx.r[10].u32 <= 16 as u32;
	ctx.r[10].s64 = (16 as i64) - ctx.r[10].s64;
	// 825DBCFC: 5529083E  rotlwi r9, r9, 1
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825DBD00: 7D6707B4  extsw r7, r11
	ctx.r[7].s64 = ctx.r[11].s32 as i64;
	// 825DBD04: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825DBD08: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 825DBD0C: 8BEBFFFF  lbz r31, -1(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DBD10: 7D085030  slw r8, r8, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[8].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DBD14: 7D2A5030  slw r10, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[9].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DBD18: 7D0907B4  extsw r9, r8
	ctx.r[9].s64 = ctx.r[8].s32 as i64;
	// 825DBD1C: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825DBD20: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 825DBD24: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 825DBD28: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DBD2C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825DBD30: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825DBD34: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825DBD38: C9610068  lfd f11, 0x68(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 825DBD3C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825DBD40: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825DBD44: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825DBD48: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825DBD4C: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DBD50: ED6B002A  fadds f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DBD54: EC0C0372  fmuls f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DBD58: EFEB0372  fmuls f31, f11, f13
	ctx.f[31].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DBD5C: 4800047C  b 0x825dc1d8
	pc = 0x825DC1D8; continue 'dispatch;
            }
            0x825DBD60 => {
    //   block [0x825DBD60..0x825DBDF8)
	// 825DBD60: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DBD64: C1BD0010  lfs f13, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DBD68: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBD6C: 3B600008  li r27, 8
	ctx.r[27].s64 = 8;
	// 825DBD70: 214B0010  subfic r10, r11, 0x10
	ctx.xer.ca = ctx.r[11].u32 <= 16 as u32;
	ctx.r[10].s64 = (16 as i64) - ctx.r[11].s64;
	// 825DBD74: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DBD78: 891F0001  lbz r8, 1(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DBD7C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825DBD80: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 825DBD84: 88FF0002  lbz r7, 2(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DBD88: 5509083E  rotlwi r9, r8, 1
	ctx.r[9].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 825DBD8C: 7D6807B4  extsw r8, r11
	ctx.r[8].s64 = ctx.r[11].s32 as i64;
	// 825DBD90: 54EB083E  rotlwi r11, r7, 1
	ctx.r[11].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 825DBD94: 3929FF01  addi r9, r9, -0xff
	ctx.r[9].s64 = ctx.r[9].s64 + -255;
	// 825DBD98: 38EBFF01  addi r7, r11, -0xff
	ctx.r[7].s64 = ctx.r[11].s64 + -255;
	// 825DBD9C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825DBDA0: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 825DBDA4: 8BEBFFFF  lbz r31, -1(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DBDA8: 7D295030  slw r9, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DBDAC: 7CEA5030  slw r10, r7, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[7].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DBDB0: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 825DBDB4: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825DBDB8: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 825DBDBC: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 825DBDC0: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DBDC4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825DBDC8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825DBDCC: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825DBDD0: C9610068  lfd f11, 0x68(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 825DBDD4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825DBDD8: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825DBDDC: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825DBDE0: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825DBDE4: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DBDE8: ED6B002A  fadds f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DBDEC: EC0C0372  fmuls f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DBDF0: EFEB0372  fmuls f31, f11, f13
	ctx.f[31].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DBDF4: 480003E4  b 0x825dc1d8
	pc = 0x825DC1D8; continue 'dispatch;
            }
            0x825DBDF8 => {
    //   block [0x825DBDF8..0x825DBE98)
	// 825DBDF8: 80FE0008  lwz r7, 8(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DBDFC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825DBE00: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DBE04: C1BD0010  lfs f13, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DBE08: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBE0C: 3B600009  li r27, 9
	ctx.r[27].s64 = 9;
	// 825DBE10: 7CE72A14  add r7, r7, r5
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[5].u64;
	// 825DBE14: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DBE18: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DBE1C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825DBE20: 7CE73214  add r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 825DBE24: 811E000C  lwz r8, 0xc(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DBE28: 5546083E  rotlwi r6, r10, 1
	ctx.r[6].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825DBE2C: 8BEBFFFF  lbz r31, -1(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DBE30: 7CE707B4  extsw r7, r7
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 825DBE34: 21080010  subfic r8, r8, 0x10
	ctx.xer.ca = ctx.r[8].u32 <= 16 as u32;
	ctx.r[8].s64 = (16 as i64) - ctx.r[8].s64;
	// 825DBE38: 7D4A3214  add r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 825DBE3C: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 825DBE40: 5527083E  rotlwi r7, r9, 1
	ctx.r[7].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825DBE44: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 825DBE48: 7D4A4030  slw r10, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825DBE4C: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825DBE50: 7D294030  slw r9, r9, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825DBE54: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 825DBE58: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 825DBE5C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DBE60: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825DBE64: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825DBE68: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825DBE6C: C9610060  lfd f11, 0x60(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825DBE70: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825DBE74: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825DBE78: ED6B002A  fadds f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DBE7C: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DBE80: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825DBE84: EFEB0372  fmuls f31, f11, f13
	ctx.f[31].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DBE88: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825DBE8C: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DBE90: EC0C0372  fmuls f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DBE94: 48000344  b 0x825dc1d8
	pc = 0x825DC1D8; continue 'dispatch;
            }
            0x825DBE98 => {
    //   block [0x825DBE98..0x825DBF40)
	// 825DBE98: 80FE0004  lwz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DBE9C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825DBEA0: 80BE0008  lwz r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DBEA4: C1BD0010  lfs f13, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DBEA8: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBEAC: 3B60000A  li r27, 0xa
	ctx.r[27].s64 = 10;
	// 825DBEB0: 7CE53850  subf r7, r5, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[5].s64;
	// 825DBEB4: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DBEB8: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DBEBC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825DBEC0: 7CE73214  add r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 825DBEC4: 811E000C  lwz r8, 0xc(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DBEC8: 394AFFAB  addi r10, r10, -0x55
	ctx.r[10].s64 = ctx.r[10].s64 + -85;
	// 825DBECC: 8BEBFFFF  lbz r31, -1(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DBED0: 7CE707B4  extsw r7, r7
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 825DBED4: 3929FFAB  addi r9, r9, -0x55
	ctx.r[9].s64 = ctx.r[9].s64 + -85;
	// 825DBED8: 5546083C  slwi r6, r10, 1
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 825DBEDC: 21080010  subfic r8, r8, 0x10
	ctx.xer.ca = ctx.r[8].u32 <= 16 as u32;
	ctx.r[8].s64 = (16 as i64) - ctx.r[8].s64;
	// 825DBEE0: 7D4A3214  add r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 825DBEE4: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 825DBEE8: 5527083C  slwi r7, r9, 1
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825DBEEC: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 825DBEF0: 7D4A4030  slw r10, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825DBEF4: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825DBEF8: 7D294030  slw r9, r9, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825DBEFC: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 825DBF00: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 825DBF04: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DBF08: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825DBF0C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825DBF10: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825DBF14: C9610060  lfd f11, 0x60(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825DBF18: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825DBF1C: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825DBF20: ED6B002A  fadds f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DBF24: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DBF28: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825DBF2C: EFEB0372  fmuls f31, f11, f13
	ctx.f[31].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DBF30: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825DBF34: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DBF38: EC0C0372  fmuls f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DBF3C: 4800029C  b 0x825dc1d8
	pc = 0x825DC1D8; continue 'dispatch;
            }
            0x825DBF40 => {
    //   block [0x825DBF40..0x825DBFE8)
	// 825DBF40: 80FE0008  lwz r7, 8(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DBF44: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825DBF48: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DBF4C: C1BD0010  lfs f13, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DBF50: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBF54: 3B60000B  li r27, 0xb
	ctx.r[27].s64 = 11;
	// 825DBF58: 7CE53850  subf r7, r5, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[5].s64;
	// 825DBF5C: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DBF60: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DBF64: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825DBF68: 7CE73214  add r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 825DBF6C: 811E000C  lwz r8, 0xc(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DBF70: 394AFFAB  addi r10, r10, -0x55
	ctx.r[10].s64 = ctx.r[10].s64 + -85;
	// 825DBF74: 8BEBFFFF  lbz r31, -1(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DBF78: 7CE707B4  extsw r7, r7
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 825DBF7C: 3929FFAB  addi r9, r9, -0x55
	ctx.r[9].s64 = ctx.r[9].s64 + -85;
	// 825DBF80: 5546083C  slwi r6, r10, 1
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 825DBF84: 21080010  subfic r8, r8, 0x10
	ctx.xer.ca = ctx.r[8].u32 <= 16 as u32;
	ctx.r[8].s64 = (16 as i64) - ctx.r[8].s64;
	// 825DBF88: 7D4A3214  add r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 825DBF8C: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 825DBF90: 5527083C  slwi r7, r9, 1
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825DBF94: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 825DBF98: 7D4A4030  slw r10, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825DBF9C: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825DBFA0: 7D294030  slw r9, r9, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825DBFA4: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 825DBFA8: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 825DBFAC: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DBFB0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825DBFB4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825DBFB8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825DBFBC: C9610060  lfd f11, 0x60(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825DBFC0: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825DBFC4: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825DBFC8: ED6B002A  fadds f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DBFCC: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DBFD0: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825DBFD4: EFEB0372  fmuls f31, f11, f13
	ctx.f[31].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DBFD8: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825DBFDC: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DBFE0: EC0C0372  fmuls f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DBFE4: 480001F4  b 0x825dc1d8
	pc = 0x825DC1D8; continue 'dispatch;
            }
            0x825DBFE8 => {
    //   block [0x825DBFE8..0x825DC090)
	// 825DBFE8: 80DE0008  lwz r6, 8(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DBFEC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825DBFF0: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBFF4: C1BD0010  lfs f13, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DBFF8: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DBFFC: 3B60000C  li r27, 0xc
	ctx.r[27].s64 = 12;
	// 825DC000: 7CE63850  subf r7, r6, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[6].s64;
	// 825DC004: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DC008: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DC00C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825DC010: 7CE53850  subf r7, r5, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[5].s64;
	// 825DC014: 811E000C  lwz r8, 0xc(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DC018: 394AFF56  addi r10, r10, -0xaa
	ctx.r[10].s64 = ctx.r[10].s64 + -170;
	// 825DC01C: 8BEBFFFF  lbz r31, -1(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DC020: 7CE707B4  extsw r7, r7
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 825DC024: 3929FF56  addi r9, r9, -0xaa
	ctx.r[9].s64 = ctx.r[9].s64 + -170;
	// 825DC028: 5546083C  slwi r6, r10, 1
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 825DC02C: 21080010  subfic r8, r8, 0x10
	ctx.xer.ca = ctx.r[8].u32 <= 16 as u32;
	ctx.r[8].s64 = (16 as i64) - ctx.r[8].s64;
	// 825DC030: 7D4A3214  add r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 825DC034: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 825DC038: 5527083C  slwi r7, r9, 1
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825DC03C: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 825DC040: 7D4A4030  slw r10, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825DC044: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825DC048: 7D294030  slw r9, r9, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825DC04C: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 825DC050: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 825DC054: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DC058: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825DC05C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825DC060: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825DC064: C9610060  lfd f11, 0x60(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825DC068: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825DC06C: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825DC070: ED6B002A  fadds f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DC074: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DC078: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825DC07C: EFEB0372  fmuls f31, f11, f13
	ctx.f[31].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DC080: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825DC084: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DC088: EC0C0372  fmuls f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DC08C: 4800014C  b 0x825dc1d8
	pc = 0x825DC1D8; continue 'dispatch;
            }
            0x825DC090 => {
    //   block [0x825DC090..0x825DC0E4)
	// 825DC090: 3B6BFFF0  addi r27, r11, -0x10
	ctx.r[27].s64 = ctx.r[11].s64 + -16;
	// 825DC094: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DC098: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DC09C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825DC0A0: 214B0010  subfic r10, r11, 0x10
	ctx.xer.ca = ctx.r[11].u32 <= 16 as u32;
	ctx.r[10].s64 = (16 as i64) - ctx.r[11].s64;
	// 825DC0A4: 88FF0002  lbz r7, 2(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DC0A8: 5766103A  slwi r6, r27, 2
	ctx.r[6].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 825DC0AC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825DC0B0: 8BEBFFFF  lbz r31, -1(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DC0B4: 7D285030  slw r8, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[9].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DC0B8: 7CE95030  slw r9, r7, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[7].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DC0BC: 7D46F02E  lwzx r10, r6, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DC0C0: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825DC0C4: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 825DC0C8: 7D0907B4  extsw r9, r8
	ctx.r[9].s64 = ctx.r[8].s32 as i64;
	// 825DC0CC: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825DC0D0: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 825DC0D4: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 825DC0D8: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DC0DC: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825DC0E0: 480000DC  b 0x825dc1bc
	pc = 0x825DC1BC; continue 'dispatch;
            }
            0x825DC0E4 => {
    //   block [0x825DC0E4..0x825DC154)
	// 825DC0E4: 3B6BFFE0  addi r27, r11, -0x20
	ctx.r[27].s64 = ctx.r[11].s64 + -32;
	// 825DC0E8: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DC0EC: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DC0F0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825DC0F4: 214B0010  subfic r10, r11, 0x10
	ctx.xer.ca = ctx.r[11].u32 <= 16 as u32;
	ctx.r[10].s64 = (16 as i64) - ctx.r[11].s64;
	// 825DC0F8: C01D0010  lfs f0, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DC0FC: 5767103A  slwi r7, r27, 2
	ctx.r[7].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825DC100: 397F0003  addi r11, r31, 3
	ctx.r[11].s64 = ctx.r[31].s64 + 3;
	// 825DC104: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825DC108: 8BEBFFFF  lbz r31, -1(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DC10C: 7D085030  slw r8, r8, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[8].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DC110: 7D295030  slw r9, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DC114: 7D47F02E  lwzx r10, r7, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DC118: 7D0807B4  extsw r8, r8
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 825DC11C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 825DC120: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825DC124: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 825DC128: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 825DC12C: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DC130: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825DC134: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825DC138: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825DC13C: FD606818  frsp f11, f13
	ctx.f[11].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825DC140: FDA06018  frsp f13, f12
	ctx.f[13].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825DC144: ED8B682A  fadds f12, f11, f13
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 825DC148: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DC14C: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 825DC150: 48000088  b 0x825dc1d8
	pc = 0x825DC1D8; continue 'dispatch;
            }
            0x825DC154 => {
    //   block [0x825DC154..0x825DC240)
	// 825DC154: 3B6BFFDD  addi r27, r11, -0x23
	ctx.r[27].s64 = ctx.r[11].s64 + -35;
	// 825DC158: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DC15C: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DC160: 88FF0001  lbz r7, 1(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DC164: 214B0010  subfic r10, r11, 0x10
	ctx.xer.ca = ctx.r[11].u32 <= 16 as u32;
	ctx.r[10].s64 = (16 as i64) - ctx.r[11].s64;
	// 825DC168: 88DF0002  lbz r6, 2(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DC16C: 5529403E  rotlwi r9, r9, 8
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825DC170: 891F0004  lbz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DC174: 5765103A  slwi r5, r27, 2
	ctx.r[5].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825DC178: 397F0007  addi r11, r31, 7
	ctx.r[11].s64 = ctx.r[31].s64 + 7;
	// 825DC17C: 7F894214  add r28, r9, r8
	ctx.r[28].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825DC180: 7CE85030  slw r8, r7, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[7].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DC184: 88EBFFFE  lbz r7, -2(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 825DC188: 7CC95030  slw r9, r6, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[6].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825DC18C: 7D45F02E  lwzx r10, r5, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DC190: 88CBFFFF  lbz r6, -1(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DC194: 54E7403E  rotlwi r7, r7, 8
	ctx.r[7].u64 = ((ctx.r[7].u32).rotate_left(8)) as u64;
	// 825DC198: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825DC19C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 825DC1A0: 7D0907B4  extsw r9, r8
	ctx.r[9].s64 = ctx.r[8].s32 as i64;
	// 825DC1A4: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825DC1A8: 7FE73214  add r31, r7, r6
	ctx.r[31].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 825DC1AC: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 825DC1B0: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 825DC1B4: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DC1B8: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825DC1BC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825DC1C0: C1BD0010  lfs f13, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DC1C4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825DC1C8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825DC1CC: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825DC1D0: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DC1D4: EFEC0372  fmuls f31, f12, f13
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DC1D8: 3B3D0044  addi r25, r29, 0x44
	ctx.r[25].s64 = ctx.r[29].s64 + 68;
	// 825DC1DC: 577A1838  slwi r26, r27, 3
	ctx.r[26].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 825DC1E0: 7F1C5A14  add r24, r28, r11
	ctx.r[24].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 825DC1E4: 7D7ACA14  add r11, r26, r25
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[25].u64;
	// 825DC1E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DC1EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825DC1F0: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 825DC1F4: C3CB0004  lfs f30, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825DC1F8: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825DC1FC: 4BFFF375  bl 0x825db570
	ctx.lr = 0x825DC200;
	sub_825DB570(ctx, base);
	// 825DC200: 395B0009  addi r10, r27, 9
	ctx.r[10].s64 = ctx.r[27].s64 + 9;
	// 825DC204: 7D7CF850  subf r11, r28, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[28].s64;
	// 825DC208: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825DC20C: 7CABC214  add r5, r11, r24
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 825DC210: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DC214: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825DC218: 7FCAED2E  stfsx f30, r10, r29
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32), tmp.u32) };
	// 825DC21C: 7FDACC2E  lfsx f30, r26, r25
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825DC220: 7FFACD2E  stfsx f31, r26, r25
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32), tmp.u32) };
	// 825DC224: 4BFFF34D  bl 0x825db570
	ctx.lr = 0x825DC228;
	sub_825DB570(ctx, base);
	// 825DC228: 7D7AEA14  add r11, r26, r29
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[29].u64;
	// 825DC22C: D3CB0044  stfs f30, 0x44(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 825DC230: 38210310  addi r1, r1, 0x310
	ctx.r[1].s64 = ctx.r[1].s64 + 784;
	// 825DC234: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 825DC238: 4BF59DFD  bl 0x82536034
	ctx.lr = 0x825DC23C;
	sub_82535FFC(ctx, base);
	// 825DC23C: 4BF58EBC  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x825DC240 => {
    //   block [0x825DC240..0x825DC374)
	// 825DC240: 3B6BFFDA  addi r27, r11, -0x26
	ctx.r[27].s64 = ctx.r[11].s64 + -38;
	// 825DC244: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DC248: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DC24C: C01D0010  lfs f0, 0x10(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DC250: 216B0010  subfic r11, r11, 0x10
	ctx.xer.ca = ctx.r[11].u32 <= 16 as u32;
	ctx.r[11].s64 = (16 as i64) - ctx.r[11].s64;
	// 825DC254: 88FF0002  lbz r7, 2(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DC258: 5766103A  slwi r6, r27, 2
	ctx.r[6].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 825DC25C: 815D00B4  lwz r10, 0xb4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(180 as u32) ) } as u64;
	// 825DC260: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825DC264: 7D285830  slw r8, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825DC268: 7CE95830  slw r9, r7, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[7].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825DC26C: 7D66F02E  lwzx r11, r6, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DC270: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 825DC274: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825DC278: 7D0907B4  extsw r9, r8
	ctx.r[9].s64 = ctx.r[8].s32 as i64;
	// 825DC27C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825DC280: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 825DC284: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 825DC288: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DC28C: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825DC290: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825DC294: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825DC298: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825DC29C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825DC2A0: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825DC2A4: EFCC0032  fmuls f30, f12, f0
	ctx.f[30].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 825DC2A8: 419A0014  beq cr6, 0x825dc2bc
	if ctx.cr[6].eq {
	pc = 0x825DC2BC; continue 'dispatch;
	}
	// 825DC2AC: 817D00AC  lwz r11, 0xac(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(172 as u32) ) } as u64;
	// 825DC2B0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825DC2B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DC2B8: 40980008  bge cr6, 0x825dc2c0
	if !ctx.cr[6].lt {
	pc = 0x825DC2C0; continue 'dispatch;
	}
	// 825DC2BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825DC2C0: 7D7A0774  extsb r26, r11
	ctx.r[26].s64 = ctx.r[11].s8 as i64;
	// 825DC2C4: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825DC2C8: 419A0020  beq cr6, 0x825dc2e8
	if ctx.cr[6].eq {
	pc = 0x825DC2E8; continue 'dispatch;
	}
	// 825DC2CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825DC2D0: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 825DC2D4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825DC2D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825DC2DC: 99410058  stb r10, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u8 ) };
	// 825DC2E0: 888B0000  lbz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DC2E4: 4BFFF095  bl 0x825db378
	ctx.lr = 0x825DC2E8;
	sub_825DB378(ctx, base);
	// 825DC2E8: 3B9D0044  addi r28, r29, 0x44
	ctx.r[28].s64 = ctx.r[29].s64 + 68;
	// 825DC2EC: 577B1838  slwi r27, r27, 3
	ctx.r[27].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 825DC2F0: 38BF0003  addi r5, r31, 3
	ctx.r[5].s64 = ctx.r[31].s64 + 3;
	// 825DC2F4: 7D7CDA14  add r11, r28, r27
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[27].u64;
	// 825DC2F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DC2FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825DC300: 7FBCDC2E  lfsx f29, r28, r27
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[27].u32)) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825DC304: C38B0004  lfs f28, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 825DC308: 7FFCDD2E  stfsx f31, r28, r27
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[27].u32), tmp.u32) };
	// 825DC30C: D3CB0004  stfs f30, 4(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825DC310: 817D00AC  lwz r11, 0xac(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(172 as u32) ) } as u64;
	// 825DC314: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DC318: 917D00AC  stw r11, 0xac(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 825DC31C: 4BFFF255  bl 0x825db570
	ctx.lr = 0x825DC320;
	sub_825DB570(ctx, base);
	// 825DC320: 817D00AC  lwz r11, 0xac(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(172 as u32) ) } as u64;
	// 825DC324: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825DC328: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825DC32C: 917D00AC  stw r11, 0xac(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 825DC330: 419A0028  beq cr6, 0x825dc358
	if ctx.cr[6].eq {
	pc = 0x825DC358; continue 'dispatch;
	}
	// 825DC334: 897D00B8  lbz r11, 0xb8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 825DC338: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DC33C: 419A001C  beq cr6, 0x825dc358
	if ctx.cr[6].eq {
	pc = 0x825DC358; continue 'dispatch;
	}
	// 825DC340: 897D00C0  lbz r11, 0xc0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(192 as u32) ) } as u64;
	// 825DC344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DC348: 409A0010  bne cr6, 0x825dc358
	if !ctx.cr[6].eq {
	pc = 0x825DC358; continue 'dispatch;
	}
	// 825DC34C: 817D0040  lwz r11, 0x40(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 825DC350: 396BFF90  addi r11, r11, -0x70
	ctx.r[11].s64 = ctx.r[11].s64 + -112;
	// 825DC354: 917D0040  stw r11, 0x40(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 825DC358: 7D7CDA14  add r11, r28, r27
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[27].u64;
	// 825DC35C: 7FBCDD2E  stfsx f29, r28, r27
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[27].u32), tmp.u32) };
	// 825DC360: D38B0004  stfs f28, 4(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825DC364: 38210310  addi r1, r1, 0x310
	ctx.r[1].s64 = ctx.r[1].s64 + 784;
	// 825DC368: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 825DC36C: 4BF59CC9  bl 0x82536034
	ctx.lr = 0x825DC370;
	sub_82535FFC(ctx, base);
	// 825DC370: 4BF58D88  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x825DC374 => {
    //   block [0x825DC374..0x825DC4AC)
	// 825DC374: 3B6BFFD7  addi r27, r11, -0x29
	ctx.r[27].s64 = ctx.r[11].s64 + -41;
	// 825DC378: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DC37C: 893F0004  lbz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DC380: C01D0010  lfs f0, 0x10(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DC384: 5568403E  rotlwi r8, r11, 8
	ctx.r[8].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DC388: 88FF0002  lbz r7, 2(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DC38C: 897F0005  lbz r11, 5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(5 as u32) ) } as u64;
	// 825DC390: 5529403E  rotlwi r9, r9, 8
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825DC394: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 825DC398: 88FF0003  lbz r7, 3(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DC39C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DC3A0: 893F0006  lbz r9, 6(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 825DC3A4: 5508402E  slwi r8, r8, 8
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(8);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825DC3A8: 815D00B4  lwz r10, 0xb4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(180 as u32) ) } as u64;
	// 825DC3AC: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DC3B0: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 825DC3B4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DC3B8: 7D0907B4  extsw r9, r8
	ctx.r[9].s64 = ctx.r[8].s32 as i64;
	// 825DC3BC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825DC3C0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825DC3C4: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 825DC3C8: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 825DC3CC: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DC3D0: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825DC3D4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825DC3D8: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825DC3DC: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825DC3E0: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825DC3E4: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825DC3E8: EFCC0032  fmuls f30, f12, f0
	ctx.f[30].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 825DC3EC: 419A0014  beq cr6, 0x825dc400
	if ctx.cr[6].eq {
	pc = 0x825DC400; continue 'dispatch;
	}
	// 825DC3F0: 817D00AC  lwz r11, 0xac(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(172 as u32) ) } as u64;
	// 825DC3F4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825DC3F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DC3FC: 40980008  bge cr6, 0x825dc404
	if !ctx.cr[6].lt {
	pc = 0x825DC404; continue 'dispatch;
	}
	// 825DC400: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825DC404: 7D7A0774  extsb r26, r11
	ctx.r[26].s64 = ctx.r[11].s8 as i64;
	// 825DC408: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825DC40C: 419A0020  beq cr6, 0x825dc42c
	if ctx.cr[6].eq {
	pc = 0x825DC42C; continue 'dispatch;
	}
	// 825DC410: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825DC414: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 825DC418: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825DC41C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825DC420: 99410058  stb r10, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u8 ) };
	// 825DC424: 888B0000  lbz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DC428: 4BFFEF51  bl 0x825db378
	ctx.lr = 0x825DC42C;
	sub_825DB378(ctx, base);
	// 825DC42C: 3B9D0044  addi r28, r29, 0x44
	ctx.r[28].s64 = ctx.r[29].s64 + 68;
	// 825DC430: 577B1838  slwi r27, r27, 3
	ctx.r[27].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 825DC434: 38BF0007  addi r5, r31, 7
	ctx.r[5].s64 = ctx.r[31].s64 + 7;
	// 825DC438: 7D7BE214  add r11, r27, r28
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[28].u64;
	// 825DC43C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DC440: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825DC444: 7FBBE42E  lfsx f29, r27, r28
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[28].u32)) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825DC448: C38B0004  lfs f28, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 825DC44C: 7FFBE52E  stfsx f31, r27, r28
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[28].u32), tmp.u32) };
	// 825DC450: D3CB0004  stfs f30, 4(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825DC454: 817D00AC  lwz r11, 0xac(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(172 as u32) ) } as u64;
	// 825DC458: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DC45C: 917D00AC  stw r11, 0xac(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 825DC460: 4BFFF111  bl 0x825db570
	ctx.lr = 0x825DC464;
	sub_825DB570(ctx, base);
	// 825DC464: 817D00AC  lwz r11, 0xac(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(172 as u32) ) } as u64;
	// 825DC468: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825DC46C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825DC470: 917D00AC  stw r11, 0xac(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 825DC474: 419A001C  beq cr6, 0x825dc490
	if ctx.cr[6].eq {
	pc = 0x825DC490; continue 'dispatch;
	}
	// 825DC478: 897D00B8  lbz r11, 0xb8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 825DC47C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DC480: 419A0010  beq cr6, 0x825dc490
	if ctx.cr[6].eq {
	pc = 0x825DC490; continue 'dispatch;
	}
	// 825DC484: 817D0040  lwz r11, 0x40(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 825DC488: 396BFF90  addi r11, r11, -0x70
	ctx.r[11].s64 = ctx.r[11].s64 + -112;
	// 825DC48C: 917D0040  stw r11, 0x40(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 825DC490: 7D7BE214  add r11, r27, r28
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[28].u64;
	// 825DC494: 7FBBE52E  stfsx f29, r27, r28
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[28].u32), tmp.u32) };
	// 825DC498: D38B0004  stfs f28, 4(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825DC49C: 38210310  addi r1, r1, 0x310
	ctx.r[1].s64 = ctx.r[1].s64 + 784;
	// 825DC4A0: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 825DC4A4: 4BF59B91  bl 0x82536034
	ctx.lr = 0x825DC4A8;
	sub_82535FFC(ctx, base);
	// 825DC4A8: 4BF58C50  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x825DC4AC => {
    //   block [0x825DC4AC..0x825DC4B4)
	// 825DC4AC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DC4B0: 48000040  b 0x825dc4f0
	pc = 0x825DC4F0; continue 'dispatch;
            }
            0x825DC4B4 => {
    //   block [0x825DC4B4..0x825DC4C8)
	// 825DC4B4: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DC4B8: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DC4BC: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DC4C0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825DC4C4: 4800002C  b 0x825dc4f0
	pc = 0x825DC4F0; continue 'dispatch;
            }
            0x825DC4C8 => {
    //   block [0x825DC4C8..0x825DC4EC)
	// 825DC4C8: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DC4CC: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DC4D0: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DC4D4: 554A803E  rotlwi r10, r10, 0x10
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(16)) as u64;
	// 825DC4D8: 917D0030  stw r11, 0x30(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 825DC4DC: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DC4E0: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825DC4E4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DC4E8: 48000008  b 0x825dc4f0
	pc = 0x825DC4F0; continue 'dispatch;
            }
            0x825DC4EC => {
    //   block [0x825DC4EC..0x825DC528)
	// 825DC4EC: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 825DC4F0: 917D0030  stw r11, 0x30(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 825DC4F4: 38BE0014  addi r5, r30, 0x14
	ctx.r[5].s64 = ctx.r[30].s64 + 20;
	// 825DC4F8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DC4FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825DC500: 815D0030  lwz r10, 0x30(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 825DC504: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DC508: 909D0030  stw r4, 0x30(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), ctx.r[4].u32 ) };
	// 825DC50C: 4BFFEF2D  bl 0x825db438
	ctx.lr = 0x825DC510;
	sub_825DB438(ctx, base);
	// 825DC510: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 825DC514: 917D0030  stw r11, 0x30(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 825DC518: 38210310  addi r1, r1, 0x310
	ctx.r[1].s64 = ctx.r[1].s64 + 784;
	// 825DC51C: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 825DC520: 4BF59B15  bl 0x82536034
	ctx.lr = 0x825DC524;
	sub_82535FFC(ctx, base);
	// 825DC524: 4BF58BD4  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DC528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DC528 size=240
    let mut pc: u32 = 0x825DC528;
    'dispatch: loop {
        match pc {
            0x825DC528 => {
    //   block [0x825DC528..0x825DC618)
	// 825DC528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DC52C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DC530: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DC534: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DC538: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825DC53C: 90C30040  stw r6, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[6].u32 ) };
	// 825DC540: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 825DC544: C1A4001C  lfs f13, 0x1c(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DC548: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 825DC54C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DC550: 394300B0  addi r10, r3, 0xb0
	ctx.r[10].s64 = ctx.r[3].s64 + 176;
	// 825DC554: C0091850  lfs f0, 0x1850(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DC558: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 825DC55C: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 825DC560: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DC618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DC618 size=1352
    let mut pc: u32 = 0x825DC618;
    'dispatch: loop {
        match pc {
            0x825DC618 => {
    //   block [0x825DC618..0x825DC818)
	// 825DC618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DC61C: 4BF58A91  bl 0x825350ac
	ctx.lr = 0x825DC620;
	sub_82535080(ctx, base);
	// 825DC620: 9421FD50  stwu r1, -0x2b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-688 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DC624: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825DC628: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825DC62C: 3B6BA65C  addi r27, r11, -0x59a4
	ctx.r[27].s64 = ctx.r[11].s64 + -22948;
	// 825DC630: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825DC634: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DC638: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DC63C: 3F208293  lis r25, -0x7d6d
	ctx.r[25].s64 = -2104295424;
	// 825DC640: 3B4BA1D8  addi r26, r11, -0x5e28
	ctx.r[26].s64 = ctx.r[11].s64 + -24104;
	// 825DC644: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DC648: 2B0B006B  cmplwi cr6, r11, 0x6b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 107 as u32, &mut ctx.xer);
	// 825DC64C: 41990408  bgt cr6, 0x825dca54
	if ctx.cr[6].gt {
	pc = 0x825DCA54; continue 'dispatch;
	}
	// 825DC650: 3D80825E  lis r12, -0x7da2
	ctx.r[12].s64 = -2107768832;
	// 825DC654: 398CC668  addi r12, r12, -0x3998
	ctx.r[12].s64 = ctx.r[12].s64 + -14744;
	// 825DC658: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825DC65C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825DC660: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825DC664: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825DCB58; continue 'dispatch;
		},
		1 => {
	pc = 0x825DC8F0; continue 'dispatch;
		},
		2 => {
	pc = 0x825DC8F0; continue 'dispatch;
		},
		3 => {
	pc = 0x825DC8F0; continue 'dispatch;
		},
		4 => {
	pc = 0x825DC8F0; continue 'dispatch;
		},
		5 => {
	pc = 0x825DC89C; continue 'dispatch;
		},
		6 => {
	pc = 0x825DC8AC; continue 'dispatch;
		},
		7 => {
	pc = 0x825DC8C8; continue 'dispatch;
		},
		8 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		9 => {
	pc = 0x825DC8F8; continue 'dispatch;
		},
		10 => {
	pc = 0x825DC928; continue 'dispatch;
		},
		11 => {
	pc = 0x825DC964; continue 'dispatch;
		},
		12 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		13 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		14 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		15 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		16 => {
	pc = 0x825DC818; continue 'dispatch;
		},
		17 => {
	pc = 0x825DC818; continue 'dispatch;
		},
		18 => {
	pc = 0x825DC818; continue 'dispatch;
		},
		19 => {
	pc = 0x825DC818; continue 'dispatch;
		},
		20 => {
	pc = 0x825DC818; continue 'dispatch;
		},
		21 => {
	pc = 0x825DC818; continue 'dispatch;
		},
		22 => {
	pc = 0x825DC818; continue 'dispatch;
		},
		23 => {
	pc = 0x825DC818; continue 'dispatch;
		},
		24 => {
	pc = 0x825DC818; continue 'dispatch;
		},
		25 => {
	pc = 0x825DC818; continue 'dispatch;
		},
		26 => {
	pc = 0x825DC818; continue 'dispatch;
		},
		27 => {
	pc = 0x825DC818; continue 'dispatch;
		},
		28 => {
	pc = 0x825DC818; continue 'dispatch;
		},
		29 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		30 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		31 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		32 => {
	pc = 0x825DC838; continue 'dispatch;
		},
		33 => {
	pc = 0x825DC838; continue 'dispatch;
		},
		34 => {
	pc = 0x825DC838; continue 'dispatch;
		},
		35 => {
	pc = 0x825DC858; continue 'dispatch;
		},
		36 => {
	pc = 0x825DC858; continue 'dispatch;
		},
		37 => {
	pc = 0x825DC858; continue 'dispatch;
		},
		38 => {
	pc = 0x825DC95C; continue 'dispatch;
		},
		39 => {
	pc = 0x825DC95C; continue 'dispatch;
		},
		40 => {
	pc = 0x825DC95C; continue 'dispatch;
		},
		41 => {
	pc = 0x825DC894; continue 'dispatch;
		},
		42 => {
	pc = 0x825DC894; continue 'dispatch;
		},
		43 => {
	pc = 0x825DC894; continue 'dispatch;
		},
		44 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		45 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		46 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		47 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		48 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		49 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		50 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		51 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		52 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		53 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		54 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		55 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		56 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		57 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		58 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		59 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		60 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		61 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		62 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		63 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		64 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		65 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		66 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		67 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		68 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		69 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		70 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		71 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		72 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		73 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		74 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		75 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		76 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		77 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		78 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		79 => {
	pc = 0x825DCB10; continue 'dispatch;
		},
		80 => {
	pc = 0x825DCAA8; continue 'dispatch;
		},
		81 => {
	pc = 0x825DCAB0; continue 'dispatch;
		},
		82 => {
	pc = 0x825DCAC4; continue 'dispatch;
		},
		83 => {
	pc = 0x825DCAE4; continue 'dispatch;
		},
		84 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		85 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		86 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		87 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		88 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		89 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		90 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		91 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		92 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		93 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		94 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		95 => {
	pc = 0x825DCA54; continue 'dispatch;
		},
		96 => {
	pc = 0x825DC9B0; continue 'dispatch;
		},
		97 => {
	pc = 0x825DC9B0; continue 'dispatch;
		},
		98 => {
	pc = 0x825DC9B0; continue 'dispatch;
		},
		99 => {
	pc = 0x825DC9B0; continue 'dispatch;
		},
		100 => {
	pc = 0x825DC9CC; continue 'dispatch;
		},
		101 => {
	pc = 0x825DC9CC; continue 'dispatch;
		},
		102 => {
	pc = 0x825DC9CC; continue 'dispatch;
		},
		103 => {
	pc = 0x825DC9CC; continue 'dispatch;
		},
		104 => {
	pc = 0x825DC9F4; continue 'dispatch;
		},
		105 => {
	pc = 0x825DC9F4; continue 'dispatch;
		},
		106 => {
	pc = 0x825DC9F4; continue 'dispatch;
		},
		107 => {
	pc = 0x825DC9F4; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825DC668: 825DCB58  lwz r18, -0x34a8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13480 as u32) ) } as u64;
	// 825DC66C: 825DC8F0  lwz r18, -0x3710(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14096 as u32) ) } as u64;
	// 825DC670: 825DC8F0  lwz r18, -0x3710(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14096 as u32) ) } as u64;
	// 825DC674: 825DC8F0  lwz r18, -0x3710(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14096 as u32) ) } as u64;
	// 825DC678: 825DC8F0  lwz r18, -0x3710(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14096 as u32) ) } as u64;
	// 825DC67C: 825DC89C  lwz r18, -0x3764(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14180 as u32) ) } as u64;
	// 825DC680: 825DC8AC  lwz r18, -0x3754(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14164 as u32) ) } as u64;
	// 825DC684: 825DC8C8  lwz r18, -0x3738(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14136 as u32) ) } as u64;
	// 825DC688: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC68C: 825DC8F8  lwz r18, -0x3708(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14088 as u32) ) } as u64;
	// 825DC690: 825DC928  lwz r18, -0x36d8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14040 as u32) ) } as u64;
	// 825DC694: 825DC964  lwz r18, -0x369c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13980 as u32) ) } as u64;
	// 825DC698: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC69C: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC6A0: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC6A4: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC6A8: 825DC818  lwz r18, -0x37e8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14312 as u32) ) } as u64;
	// 825DC6AC: 825DC818  lwz r18, -0x37e8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14312 as u32) ) } as u64;
	// 825DC6B0: 825DC818  lwz r18, -0x37e8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14312 as u32) ) } as u64;
	// 825DC6B4: 825DC818  lwz r18, -0x37e8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14312 as u32) ) } as u64;
	// 825DC6B8: 825DC818  lwz r18, -0x37e8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14312 as u32) ) } as u64;
	// 825DC6BC: 825DC818  lwz r18, -0x37e8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14312 as u32) ) } as u64;
	// 825DC6C0: 825DC818  lwz r18, -0x37e8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14312 as u32) ) } as u64;
	// 825DC6C4: 825DC818  lwz r18, -0x37e8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14312 as u32) ) } as u64;
	// 825DC6C8: 825DC818  lwz r18, -0x37e8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14312 as u32) ) } as u64;
	// 825DC6CC: 825DC818  lwz r18, -0x37e8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14312 as u32) ) } as u64;
	// 825DC6D0: 825DC818  lwz r18, -0x37e8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14312 as u32) ) } as u64;
	// 825DC6D4: 825DC818  lwz r18, -0x37e8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14312 as u32) ) } as u64;
	// 825DC6D8: 825DC818  lwz r18, -0x37e8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14312 as u32) ) } as u64;
	// 825DC6DC: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC6E0: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC6E4: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC6E8: 825DC838  lwz r18, -0x37c8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14280 as u32) ) } as u64;
	// 825DC6EC: 825DC838  lwz r18, -0x37c8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14280 as u32) ) } as u64;
	// 825DC6F0: 825DC838  lwz r18, -0x37c8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14280 as u32) ) } as u64;
	// 825DC6F4: 825DC858  lwz r18, -0x37a8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14248 as u32) ) } as u64;
	// 825DC6F8: 825DC858  lwz r18, -0x37a8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14248 as u32) ) } as u64;
	// 825DC6FC: 825DC858  lwz r18, -0x37a8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14248 as u32) ) } as u64;
	// 825DC700: 825DC95C  lwz r18, -0x36a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13988 as u32) ) } as u64;
	// 825DC704: 825DC95C  lwz r18, -0x36a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13988 as u32) ) } as u64;
	// 825DC708: 825DC95C  lwz r18, -0x36a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13988 as u32) ) } as u64;
	// 825DC70C: 825DC894  lwz r18, -0x376c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14188 as u32) ) } as u64;
	// 825DC710: 825DC894  lwz r18, -0x376c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14188 as u32) ) } as u64;
	// 825DC714: 825DC894  lwz r18, -0x376c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-14188 as u32) ) } as u64;
	// 825DC718: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC71C: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC720: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC724: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC728: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC72C: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC730: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC734: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC738: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC73C: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC740: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC744: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC748: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC74C: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC750: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC754: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC758: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC75C: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC760: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC764: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC768: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC76C: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC770: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC774: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC778: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC77C: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC780: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC784: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC788: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC78C: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC790: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC794: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC798: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC79C: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC7A0: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC7A4: 825DCB10  lwz r18, -0x34f0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13552 as u32) ) } as u64;
	// 825DC7A8: 825DCAA8  lwz r18, -0x3558(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13656 as u32) ) } as u64;
	// 825DC7AC: 825DCAB0  lwz r18, -0x3550(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13648 as u32) ) } as u64;
	// 825DC7B0: 825DCAC4  lwz r18, -0x353c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13628 as u32) ) } as u64;
	// 825DC7B4: 825DCAE4  lwz r18, -0x351c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13596 as u32) ) } as u64;
	// 825DC7B8: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC7BC: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC7C0: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC7C4: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC7C8: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC7CC: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC7D0: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC7D4: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC7D8: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC7DC: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC7E0: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC7E4: 825DCA54  lwz r18, -0x35ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13740 as u32) ) } as u64;
	// 825DC7E8: 825DC9B0  lwz r18, -0x3650(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13904 as u32) ) } as u64;
	// 825DC7EC: 825DC9B0  lwz r18, -0x3650(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13904 as u32) ) } as u64;
	// 825DC7F0: 825DC9B0  lwz r18, -0x3650(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13904 as u32) ) } as u64;
	// 825DC7F4: 825DC9B0  lwz r18, -0x3650(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13904 as u32) ) } as u64;
	// 825DC7F8: 825DC9CC  lwz r18, -0x3634(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13876 as u32) ) } as u64;
	// 825DC7FC: 825DC9CC  lwz r18, -0x3634(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13876 as u32) ) } as u64;
	// 825DC800: 825DC9CC  lwz r18, -0x3634(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13876 as u32) ) } as u64;
	// 825DC804: 825DC9CC  lwz r18, -0x3634(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13876 as u32) ) } as u64;
	// 825DC808: 825DC9F4  lwz r18, -0x360c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13836 as u32) ) } as u64;
	// 825DC80C: 825DC9F4  lwz r18, -0x360c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13836 as u32) ) } as u64;
	// 825DC810: 825DC9F4  lwz r18, -0x360c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13836 as u32) ) } as u64;
	// 825DC814: 825DC9F4  lwz r18, -0x360c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-13836 as u32) ) } as u64;
            }
            0x825DC818 => {
    //   block [0x825DC818..0x825DC838)
	// 825DC818: 8BDF0003  lbz r30, 3(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DC81C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DC820: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DC824: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825DC828: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DC82C: 4BFFFDED  bl 0x825dc618
	ctx.lr = 0x825DC830;
	sub_825DC618(ctx, base);
	// 825DC830: 7FFEFA14  add r31, r30, r31
	ctx.r[31].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 825DC834: 4BFFFE10  b 0x825dc644
	pc = 0x825DC644; continue 'dispatch;
            }
            0x825DC838 => {
    //   block [0x825DC838..0x825DC858)
	// 825DC838: 8BDF0002  lbz r30, 2(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DC83C: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825DC840: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DC844: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825DC848: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DC84C: 4BFFFDCD  bl 0x825dc618
	ctx.lr = 0x825DC850;
	sub_825DC618(ctx, base);
	// 825DC850: 7FFEFA14  add r31, r30, r31
	ctx.r[31].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 825DC854: 4BFFFDF0  b 0x825dc644
	pc = 0x825DC644; continue 'dispatch;
            }
            0x825DC858 => {
    //   block [0x825DC858..0x825DC894)
	// 825DC858: 897F0003  lbz r11, 3(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DC85C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DC860: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DC864: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825DC868: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DC86C: 891F0005  lbz r8, 5(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(5 as u32) ) } as u64;
	// 825DC870: 893F0006  lbz r9, 6(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 825DC874: 3BFF0007  addi r31, r31, 7
	ctx.r[31].s64 = ctx.r[31].s64 + 7;
	// 825DC878: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DC87C: 550A403E  rotlwi r10, r8, 8
	ctx.r[10].u64 = ((ctx.r[8].u32).rotate_left(8)) as u64;
	// 825DC880: 7CABFA14  add r5, r11, r31
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DC884: 7FCA4A14  add r30, r10, r9
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825DC888: 4BFFFD91  bl 0x825dc618
	ctx.lr = 0x825DC88C;
	sub_825DC618(ctx, base);
	// 825DC88C: 7FFEFA14  add r31, r30, r31
	ctx.r[31].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 825DC890: 4BFFFDB4  b 0x825dc644
	pc = 0x825DC644; continue 'dispatch;
            }
            0x825DC894 => {
    //   block [0x825DC894..0x825DC89C)
	// 825DC894: 3BFF0007  addi r31, r31, 7
	ctx.r[31].s64 = ctx.r[31].s64 + 7;
	// 825DC898: 4BFFFDAC  b 0x825dc644
	pc = 0x825DC644; continue 'dispatch;
            }
            0x825DC89C => {
    //   block [0x825DC89C..0x825DC8AC)
	// 825DC89C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DC8A0: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DC8A4: 3BEB0002  addi r31, r11, 2
	ctx.r[31].s64 = ctx.r[11].s64 + 2;
	// 825DC8A8: 4BFFFD9C  b 0x825dc644
	pc = 0x825DC644; continue 'dispatch;
            }
            0x825DC8AC => {
    //   block [0x825DC8AC..0x825DC8C8)
	// 825DC8AC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DC8B0: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DC8B4: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DC8B8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DC8BC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DC8C0: 3BEB0003  addi r31, r11, 3
	ctx.r[31].s64 = ctx.r[11].s64 + 3;
	// 825DC8C4: 4BFFFD80  b 0x825dc644
	pc = 0x825DC644; continue 'dispatch;
            }
            0x825DC8C8 => {
    //   block [0x825DC8C8..0x825DC8F0)
	// 825DC8C8: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DC8CC: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DC8D0: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DC8D4: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DC8D8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DC8DC: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DC8E0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DC8E4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DC8E8: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 825DC8EC: 4BFFFD58  b 0x825dc644
	pc = 0x825DC644; continue 'dispatch;
            }
            0x825DC8F0 => {
    //   block [0x825DC8F0..0x825DC8F8)
	// 825DC8F0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DC8F4: 4BFFFD50  b 0x825dc644
	pc = 0x825DC644; continue 'dispatch;
            }
            0x825DC8F8 => {
    //   block [0x825DC8F8..0x825DC928)
	// 825DC8F8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825DC8FC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DC900: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825DC904: 419A0010  beq cr6, 0x825dc914
	if ctx.cr[6].eq {
	pc = 0x825DC914; continue 'dispatch;
	}
	// 825DC908: E95D0000  ld r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 825DC90C: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 825DC910: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825DC914: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DC918: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825DC91C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825DC920: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825DC924: 4BFFFD20  b 0x825dc644
	pc = 0x825DC644; continue 'dispatch;
            }
            0x825DC928 => {
    //   block [0x825DC928..0x825DC95C)
	// 825DC928: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DC92C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 825DC930: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DC934: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DC938: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825DC93C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DC940: 419A0010  beq cr6, 0x825dc950
	if ctx.cr[6].eq {
	pc = 0x825DC950; continue 'dispatch;
	}
	// 825DC944: E95D0000  ld r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 825DC948: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 825DC94C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825DC950: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DC954: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DC958: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x825DC95C; continue 'dispatch;
            }
            0x825DC95C => {
    //   block [0x825DC95C..0x825DC964)
	// 825DC95C: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825DC960: 4BFFFCE4  b 0x825dc644
	pc = 0x825DC644; continue 'dispatch;
            }
            0x825DC964 => {
    //   block [0x825DC964..0x825DC9B0)
	// 825DC964: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DC968: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825DC96C: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DC970: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DC974: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DC978: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DC97C: 7F1D3840  cmplw cr6, r29, r7
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825DC980: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825DC984: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DC988: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DC98C: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DC990: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DC994: 419A0010  beq cr6, 0x825dc9a4
	if ctx.cr[6].eq {
	pc = 0x825DC9A4; continue 'dispatch;
	}
	// 825DC998: E95D0000  ld r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 825DC99C: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 825DC9A0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825DC9A4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825DC9A8: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825DC9AC: 4BFFFC98  b 0x825dc644
	pc = 0x825DC644; continue 'dispatch;
            }
            0x825DC9B0 => {
    //   block [0x825DC9B0..0x825DC9CC)
	// 825DC9B0: 396BFFA0  addi r11, r11, -0x60
	ctx.r[11].s64 = ctx.r[11].s64 + -96;
	// 825DC9B4: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DC9B8: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 825DC9BC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DC9C0: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825DC9C4: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 825DC9C8: 48000068  b 0x825dca30
	pc = 0x825DCA30; continue 'dispatch;
            }
            0x825DC9CC => {
    //   block [0x825DC9CC..0x825DC9F4)
	// 825DC9CC: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DC9D0: 390BFF9C  addi r8, r11, -0x64
	ctx.r[8].s64 = ctx.r[11].s64 + -100;
	// 825DC9D4: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DC9D8: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 825DC9DC: 552B403E  rotlwi r11, r9, 8
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825DC9E0: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825DC9E4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DC9E8: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825DC9EC: 7D69392E  stwx r11, r9, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 825DC9F0: 48000040  b 0x825dca30
	pc = 0x825DCA30; continue 'dispatch;
            }
            0x825DC9F4 => {
    //   block [0x825DC9F4..0x825DCA54)
	// 825DC9F4: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DC9F8: 38EBFF98  addi r7, r11, -0x68
	ctx.r[7].s64 = ctx.r[11].s64 + -104;
	// 825DC9FC: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DCA00: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825DCA04: 554B403E  rotlwi r11, r10, 8
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825DCA08: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DCA0C: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DCA10: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825DCA14: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825DCA18: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825DCA1C: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DCA20: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DCA24: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DCA28: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DCA2C: 7D67312E  stwx r11, r7, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 825DCA30: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825DCA34: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DCA38: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825DCA3C: 419A0010  beq cr6, 0x825dca4c
	if ctx.cr[6].eq {
	pc = 0x825DCA4C; continue 'dispatch;
	}
	// 825DCA40: E95D0000  ld r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 825DCA44: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 825DCA48: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825DCA4C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825DCA50: 4BFFFBF4  b 0x825dc644
	pc = 0x825DC644; continue 'dispatch;
            }
            0x825DCA54 => {
    //   block [0x825DCA54..0x825DCAA8)
	// 825DCA54: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 825DCA58: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825DCA5C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DCA60: 4BE8C399  bl 0x82468df8
	ctx.lr = 0x825DCA64;
	sub_82468DF8(ctx, base);
	// 825DCA64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DCA68: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825DCA6C: 4BE8B835  bl 0x824682a0
	ctx.lr = 0x825DCA70;
	sub_824682A0(ctx, base);
	// 825DCA70: 80799190  lwz r3, -0x6e70(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-28272 as u32) ) } as u64;
	// 825DCA74: 3CA01298  lis r5, 0x1298
	ctx.r[5].s64 = 311951360;
	// 825DCA78: 39000071  li r8, 0x71
	ctx.r[8].s64 = 113;
	// 825DCA7C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825DCA80: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 825DCA84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DCA88: 60A5FEDD  ori r5, r5, 0xfedd
	ctx.r[5].u64 = ctx.r[5].u64 | 65245;
	// 825DCA8C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825DCA90: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DCA94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DCA98: 4E800421  bctrl
	ctx.lr = 0x825DCA9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DCA9C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DCAA0: 4BE8BE41  bl 0x824688e0
	ctx.lr = 0x825DCAA4;
	sub_824688E0(ctx, base);
	// 825DCAA4: 4BFFFBA0  b 0x825dc644
	pc = 0x825DC644; continue 'dispatch;
            }
            0x825DCAA8 => {
    //   block [0x825DCAA8..0x825DCAB0)
	// 825DCAA8: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DCAAC: 48000068  b 0x825dcb14
	pc = 0x825DCB14; continue 'dispatch;
            }
            0x825DCAB0 => {
    //   block [0x825DCAB0..0x825DCAC4)
	// 825DCAB0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DCAB4: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DCAB8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DCABC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DCAC0: 48000054  b 0x825dcb14
	pc = 0x825DCB14; continue 'dispatch;
            }
            0x825DCAC4 => {
    //   block [0x825DCAC4..0x825DCAE4)
	// 825DCAC4: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DCAC8: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DCACC: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DCAD0: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DCAD4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DCAD8: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DCADC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DCAE0: 48000034  b 0x825dcb14
	pc = 0x825DCB14; continue 'dispatch;
            }
            0x825DCAE4 => {
    //   block [0x825DCAE4..0x825DCB10)
	// 825DCAE4: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DCAE8: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DCAEC: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DCAF0: 891F0003  lbz r8, 3(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DCAF4: 893F0004  lbz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DCAF8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DCAFC: 550A403E  rotlwi r10, r8, 8
	ctx.r[10].u64 = ((ctx.r[8].u32).rotate_left(8)) as u64;
	// 825DCB00: 556B801E  slwi r11, r11, 0x10
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(16);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DCB04: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825DCB08: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825DCB0C: 48000008  b 0x825dcb14
	pc = 0x825DCB14; continue 'dispatch;
            }
            0x825DCB10 => {
    //   block [0x825DCB10..0x825DCB58)
	// 825DCB10: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 825DCB14: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DCB18: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DCB1C: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825DCB20: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DCB24: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DCB28: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825DCB2C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825DCB30: 409A0010  bne cr6, 0x825dcb40
	if !ctx.cr[6].eq {
	pc = 0x825DCB40; continue 'dispatch;
	}
	// 825DCB34: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 825DCB38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DCB3C: 4BE91815  bl 0x8246e350
	ctx.lr = 0x825DCB40;
	sub_8246E350(ctx, base);
	// 825DCB40: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DCB44: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DCB48: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825DCB4C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DCB50: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825DCB54: 7FCA492E  stwx r30, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[30].u32) };
	pc = 0x825DCB58; continue 'dispatch;
            }
            0x825DCB58 => {
    //   block [0x825DCB58..0x825DCB60)
	// 825DCB58: 382102B0  addi r1, r1, 0x2b0
	ctx.r[1].s64 = ctx.r[1].s64 + 688;
	// 825DCB5C: 4BF585A0  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DCB60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DCB60 size=1288
    let mut pc: u32 = 0x825DCB60;
    'dispatch: loop {
        match pc {
            0x825DCB60 => {
    //   block [0x825DCB60..0x825DCD60)
	// 825DCB60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DCB64: 4BF5854D  bl 0x825350b0
	ctx.lr = 0x825DCB68;
	sub_82535080(ctx, base);
	// 825DCB68: 9421FD50  stwu r1, -0x2b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-688 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DCB6C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825DCB70: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825DCB74: 3BABA65C  addi r29, r11, -0x59a4
	ctx.r[29].s64 = ctx.r[11].s64 + -22948;
	// 825DCB78: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825DCB7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DCB80: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DCB84: 3F608293  lis r27, -0x7d6d
	ctx.r[27].s64 = -2104295424;
	// 825DCB88: 3B8BA1D8  addi r28, r11, -0x5e28
	ctx.r[28].s64 = ctx.r[11].s64 + -24104;
	// 825DCB8C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DCB90: 2B0B006B  cmplwi cr6, r11, 0x6b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 107 as u32, &mut ctx.xer);
	// 825DCB94: 419903C8  bgt cr6, 0x825dcf5c
	if ctx.cr[6].gt {
	pc = 0x825DCF5C; continue 'dispatch;
	}
	// 825DCB98: 3D80825E  lis r12, -0x7da2
	ctx.r[12].s64 = -2107768832;
	// 825DCB9C: 398CCBB0  addi r12, r12, -0x3450
	ctx.r[12].s64 = ctx.r[12].s64 + -13392;
	// 825DCBA0: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825DCBA4: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825DCBA8: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825DCBAC: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825DD060; continue 'dispatch;
		},
		1 => {
	pc = 0x825DCDF8; continue 'dispatch;
		},
		2 => {
	pc = 0x825DCDF8; continue 'dispatch;
		},
		3 => {
	pc = 0x825DCDF8; continue 'dispatch;
		},
		4 => {
	pc = 0x825DCDF8; continue 'dispatch;
		},
		5 => {
	pc = 0x825DCDA4; continue 'dispatch;
		},
		6 => {
	pc = 0x825DCDB4; continue 'dispatch;
		},
		7 => {
	pc = 0x825DCDD0; continue 'dispatch;
		},
		8 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		9 => {
	pc = 0x825DCE00; continue 'dispatch;
		},
		10 => {
	pc = 0x825DCE30; continue 'dispatch;
		},
		11 => {
	pc = 0x825DCE6C; continue 'dispatch;
		},
		12 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		13 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		14 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		15 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		16 => {
	pc = 0x825DCD60; continue 'dispatch;
		},
		17 => {
	pc = 0x825DCD60; continue 'dispatch;
		},
		18 => {
	pc = 0x825DCD60; continue 'dispatch;
		},
		19 => {
	pc = 0x825DCD60; continue 'dispatch;
		},
		20 => {
	pc = 0x825DCD60; continue 'dispatch;
		},
		21 => {
	pc = 0x825DCD60; continue 'dispatch;
		},
		22 => {
	pc = 0x825DCD60; continue 'dispatch;
		},
		23 => {
	pc = 0x825DCD60; continue 'dispatch;
		},
		24 => {
	pc = 0x825DCD60; continue 'dispatch;
		},
		25 => {
	pc = 0x825DCD60; continue 'dispatch;
		},
		26 => {
	pc = 0x825DCD60; continue 'dispatch;
		},
		27 => {
	pc = 0x825DCD60; continue 'dispatch;
		},
		28 => {
	pc = 0x825DCD60; continue 'dispatch;
		},
		29 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		30 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		31 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		32 => {
	pc = 0x825DCD70; continue 'dispatch;
		},
		33 => {
	pc = 0x825DCD70; continue 'dispatch;
		},
		34 => {
	pc = 0x825DCD70; continue 'dispatch;
		},
		35 => {
	pc = 0x825DCD80; continue 'dispatch;
		},
		36 => {
	pc = 0x825DCD80; continue 'dispatch;
		},
		37 => {
	pc = 0x825DCD80; continue 'dispatch;
		},
		38 => {
	pc = 0x825DCE64; continue 'dispatch;
		},
		39 => {
	pc = 0x825DCE64; continue 'dispatch;
		},
		40 => {
	pc = 0x825DCE64; continue 'dispatch;
		},
		41 => {
	pc = 0x825DCD9C; continue 'dispatch;
		},
		42 => {
	pc = 0x825DCD9C; continue 'dispatch;
		},
		43 => {
	pc = 0x825DCD9C; continue 'dispatch;
		},
		44 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		45 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		46 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		47 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		48 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		49 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		50 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		51 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		52 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		53 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		54 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		55 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		56 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		57 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		58 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		59 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		60 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		61 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		62 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		63 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		64 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		65 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		66 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		67 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		68 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		69 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		70 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		71 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		72 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		73 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		74 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		75 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		76 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		77 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		78 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		79 => {
	pc = 0x825DD018; continue 'dispatch;
		},
		80 => {
	pc = 0x825DCFB0; continue 'dispatch;
		},
		81 => {
	pc = 0x825DCFB8; continue 'dispatch;
		},
		82 => {
	pc = 0x825DCFCC; continue 'dispatch;
		},
		83 => {
	pc = 0x825DCFEC; continue 'dispatch;
		},
		84 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		85 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		86 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		87 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		88 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		89 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		90 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		91 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		92 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		93 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		94 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		95 => {
	pc = 0x825DCF5C; continue 'dispatch;
		},
		96 => {
	pc = 0x825DCEB8; continue 'dispatch;
		},
		97 => {
	pc = 0x825DCEB8; continue 'dispatch;
		},
		98 => {
	pc = 0x825DCEB8; continue 'dispatch;
		},
		99 => {
	pc = 0x825DCEB8; continue 'dispatch;
		},
		100 => {
	pc = 0x825DCED4; continue 'dispatch;
		},
		101 => {
	pc = 0x825DCED4; continue 'dispatch;
		},
		102 => {
	pc = 0x825DCED4; continue 'dispatch;
		},
		103 => {
	pc = 0x825DCED4; continue 'dispatch;
		},
		104 => {
	pc = 0x825DCEFC; continue 'dispatch;
		},
		105 => {
	pc = 0x825DCEFC; continue 'dispatch;
		},
		106 => {
	pc = 0x825DCEFC; continue 'dispatch;
		},
		107 => {
	pc = 0x825DCEFC; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825DCBB0: 825DD060  lwz r18, -0x2fa0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12192 as u32) ) } as u64;
	// 825DCBB4: 825DCDF8  lwz r18, -0x3208(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12808 as u32) ) } as u64;
	// 825DCBB8: 825DCDF8  lwz r18, -0x3208(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12808 as u32) ) } as u64;
	// 825DCBBC: 825DCDF8  lwz r18, -0x3208(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12808 as u32) ) } as u64;
	// 825DCBC0: 825DCDF8  lwz r18, -0x3208(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12808 as u32) ) } as u64;
	// 825DCBC4: 825DCDA4  lwz r18, -0x325c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12892 as u32) ) } as u64;
	// 825DCBC8: 825DCDB4  lwz r18, -0x324c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12876 as u32) ) } as u64;
	// 825DCBCC: 825DCDD0  lwz r18, -0x3230(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12848 as u32) ) } as u64;
	// 825DCBD0: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCBD4: 825DCE00  lwz r18, -0x3200(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12800 as u32) ) } as u64;
	// 825DCBD8: 825DCE30  lwz r18, -0x31d0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12752 as u32) ) } as u64;
	// 825DCBDC: 825DCE6C  lwz r18, -0x3194(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12692 as u32) ) } as u64;
	// 825DCBE0: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCBE4: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCBE8: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCBEC: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCBF0: 825DCD60  lwz r18, -0x32a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12960 as u32) ) } as u64;
	// 825DCBF4: 825DCD60  lwz r18, -0x32a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12960 as u32) ) } as u64;
	// 825DCBF8: 825DCD60  lwz r18, -0x32a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12960 as u32) ) } as u64;
	// 825DCBFC: 825DCD60  lwz r18, -0x32a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12960 as u32) ) } as u64;
	// 825DCC00: 825DCD60  lwz r18, -0x32a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12960 as u32) ) } as u64;
	// 825DCC04: 825DCD60  lwz r18, -0x32a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12960 as u32) ) } as u64;
	// 825DCC08: 825DCD60  lwz r18, -0x32a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12960 as u32) ) } as u64;
	// 825DCC0C: 825DCD60  lwz r18, -0x32a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12960 as u32) ) } as u64;
	// 825DCC10: 825DCD60  lwz r18, -0x32a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12960 as u32) ) } as u64;
	// 825DCC14: 825DCD60  lwz r18, -0x32a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12960 as u32) ) } as u64;
	// 825DCC18: 825DCD60  lwz r18, -0x32a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12960 as u32) ) } as u64;
	// 825DCC1C: 825DCD60  lwz r18, -0x32a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12960 as u32) ) } as u64;
	// 825DCC20: 825DCD60  lwz r18, -0x32a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12960 as u32) ) } as u64;
	// 825DCC24: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCC28: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCC2C: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCC30: 825DCD70  lwz r18, -0x3290(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12944 as u32) ) } as u64;
	// 825DCC34: 825DCD70  lwz r18, -0x3290(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12944 as u32) ) } as u64;
	// 825DCC38: 825DCD70  lwz r18, -0x3290(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12944 as u32) ) } as u64;
	// 825DCC3C: 825DCD80  lwz r18, -0x3280(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12928 as u32) ) } as u64;
	// 825DCC40: 825DCD80  lwz r18, -0x3280(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12928 as u32) ) } as u64;
	// 825DCC44: 825DCD80  lwz r18, -0x3280(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12928 as u32) ) } as u64;
	// 825DCC48: 825DCE64  lwz r18, -0x319c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12700 as u32) ) } as u64;
	// 825DCC4C: 825DCE64  lwz r18, -0x319c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12700 as u32) ) } as u64;
	// 825DCC50: 825DCE64  lwz r18, -0x319c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12700 as u32) ) } as u64;
	// 825DCC54: 825DCD9C  lwz r18, -0x3264(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12900 as u32) ) } as u64;
	// 825DCC58: 825DCD9C  lwz r18, -0x3264(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12900 as u32) ) } as u64;
	// 825DCC5C: 825DCD9C  lwz r18, -0x3264(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12900 as u32) ) } as u64;
	// 825DCC60: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCC64: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCC68: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCC6C: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCC70: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCC74: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCC78: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCC7C: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCC80: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCC84: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCC88: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCC8C: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCC90: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCC94: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCC98: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCC9C: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCA0: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCA4: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCA8: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCAC: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCB0: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCB4: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCB8: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCBC: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCC0: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCC4: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCC8: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCCC: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCD0: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCD4: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCD8: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCDC: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCE0: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCE4: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCE8: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCEC: 825DD018  lwz r18, -0x2fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12264 as u32) ) } as u64;
	// 825DCCF0: 825DCFB0  lwz r18, -0x3050(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12368 as u32) ) } as u64;
	// 825DCCF4: 825DCFB8  lwz r18, -0x3048(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12360 as u32) ) } as u64;
	// 825DCCF8: 825DCFCC  lwz r18, -0x3034(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12340 as u32) ) } as u64;
	// 825DCCFC: 825DCFEC  lwz r18, -0x3014(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12308 as u32) ) } as u64;
	// 825DCD00: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCD04: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCD08: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCD0C: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCD10: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCD14: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCD18: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCD1C: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCD20: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCD24: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCD28: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCD2C: 825DCF5C  lwz r18, -0x30a4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12452 as u32) ) } as u64;
	// 825DCD30: 825DCEB8  lwz r18, -0x3148(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12616 as u32) ) } as u64;
	// 825DCD34: 825DCEB8  lwz r18, -0x3148(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12616 as u32) ) } as u64;
	// 825DCD38: 825DCEB8  lwz r18, -0x3148(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12616 as u32) ) } as u64;
	// 825DCD3C: 825DCEB8  lwz r18, -0x3148(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12616 as u32) ) } as u64;
	// 825DCD40: 825DCED4  lwz r18, -0x312c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12588 as u32) ) } as u64;
	// 825DCD44: 825DCED4  lwz r18, -0x312c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12588 as u32) ) } as u64;
	// 825DCD48: 825DCED4  lwz r18, -0x312c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12588 as u32) ) } as u64;
	// 825DCD4C: 825DCED4  lwz r18, -0x312c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12588 as u32) ) } as u64;
	// 825DCD50: 825DCEFC  lwz r18, -0x3104(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12548 as u32) ) } as u64;
	// 825DCD54: 825DCEFC  lwz r18, -0x3104(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12548 as u32) ) } as u64;
	// 825DCD58: 825DCEFC  lwz r18, -0x3104(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12548 as u32) ) } as u64;
	// 825DCD5C: 825DCEFC  lwz r18, -0x3104(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12548 as u32) ) } as u64;
            }
            0x825DCD60 => {
    //   block [0x825DCD60..0x825DCD70)
	// 825DCD60: 897F0003  lbz r11, 3(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DCD64: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DCD68: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 825DCD6C: 4BFFFE20  b 0x825dcb8c
	pc = 0x825DCB8C; continue 'dispatch;
            }
            0x825DCD70 => {
    //   block [0x825DCD70..0x825DCD80)
	// 825DCD70: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DCD74: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DCD78: 3BEB0003  addi r31, r11, 3
	ctx.r[31].s64 = ctx.r[11].s64 + 3;
	// 825DCD7C: 4BFFFE10  b 0x825dcb8c
	pc = 0x825DCB8C; continue 'dispatch;
            }
            0x825DCD80 => {
    //   block [0x825DCD80..0x825DCD9C)
	// 825DCD80: 897F0005  lbz r11, 5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(5 as u32) ) } as u64;
	// 825DCD84: 895F0006  lbz r10, 6(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 825DCD88: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DCD8C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DCD90: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DCD94: 3BEB0007  addi r31, r11, 7
	ctx.r[31].s64 = ctx.r[11].s64 + 7;
	// 825DCD98: 4BFFFDF4  b 0x825dcb8c
	pc = 0x825DCB8C; continue 'dispatch;
            }
            0x825DCD9C => {
    //   block [0x825DCD9C..0x825DCDA4)
	// 825DCD9C: 3BFF0007  addi r31, r31, 7
	ctx.r[31].s64 = ctx.r[31].s64 + 7;
	// 825DCDA0: 4BFFFDEC  b 0x825dcb8c
	pc = 0x825DCB8C; continue 'dispatch;
            }
            0x825DCDA4 => {
    //   block [0x825DCDA4..0x825DCDB4)
	// 825DCDA4: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DCDA8: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DCDAC: 3BEB0002  addi r31, r11, 2
	ctx.r[31].s64 = ctx.r[11].s64 + 2;
	// 825DCDB0: 4BFFFDDC  b 0x825dcb8c
	pc = 0x825DCB8C; continue 'dispatch;
            }
            0x825DCDB4 => {
    //   block [0x825DCDB4..0x825DCDD0)
	// 825DCDB4: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DCDB8: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DCDBC: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DCDC0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DCDC4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DCDC8: 3BEB0003  addi r31, r11, 3
	ctx.r[31].s64 = ctx.r[11].s64 + 3;
	// 825DCDCC: 4BFFFDC0  b 0x825dcb8c
	pc = 0x825DCB8C; continue 'dispatch;
            }
            0x825DCDD0 => {
    //   block [0x825DCDD0..0x825DCDF8)
	// 825DCDD0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DCDD4: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DCDD8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DCDDC: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DCDE0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DCDE4: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DCDE8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DCDEC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DCDF0: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 825DCDF4: 4BFFFD98  b 0x825dcb8c
	pc = 0x825DCB8C; continue 'dispatch;
            }
            0x825DCDF8 => {
    //   block [0x825DCDF8..0x825DCE00)
	// 825DCDF8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DCDFC: 4BFFFD90  b 0x825dcb8c
	pc = 0x825DCB8C; continue 'dispatch;
            }
            0x825DCE00 => {
    //   block [0x825DCE00..0x825DCE30)
	// 825DCE00: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825DCE04: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DCE08: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825DCE0C: 419A0010  beq cr6, 0x825dce1c
	if ctx.cr[6].eq {
	pc = 0x825DCE1C; continue 'dispatch;
	}
	// 825DCE10: E95E0000  ld r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825DCE14: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825DCE18: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825DCE1C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DCE20: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825DCE24: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825DCE28: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825DCE2C: 4BFFFD60  b 0x825dcb8c
	pc = 0x825DCB8C; continue 'dispatch;
            }
            0x825DCE30 => {
    //   block [0x825DCE30..0x825DCE64)
	// 825DCE30: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DCE34: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 825DCE38: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DCE3C: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DCE40: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825DCE44: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DCE48: 419A0010  beq cr6, 0x825dce58
	if ctx.cr[6].eq {
	pc = 0x825DCE58; continue 'dispatch;
	}
	// 825DCE4C: E95E0000  ld r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825DCE50: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825DCE54: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825DCE58: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DCE5C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DCE60: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x825DCE64; continue 'dispatch;
            }
            0x825DCE64 => {
    //   block [0x825DCE64..0x825DCE6C)
	// 825DCE64: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825DCE68: 4BFFFD24  b 0x825dcb8c
	pc = 0x825DCB8C; continue 'dispatch;
            }
            0x825DCE6C => {
    //   block [0x825DCE6C..0x825DCEB8)
	// 825DCE6C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DCE70: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825DCE74: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DCE78: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DCE7C: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DCE80: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DCE84: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825DCE88: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825DCE8C: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DCE90: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DCE94: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DCE98: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DCE9C: 419A0010  beq cr6, 0x825dceac
	if ctx.cr[6].eq {
	pc = 0x825DCEAC; continue 'dispatch;
	}
	// 825DCEA0: E95E0000  ld r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825DCEA4: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825DCEA8: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825DCEAC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825DCEB0: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825DCEB4: 4BFFFCD8  b 0x825dcb8c
	pc = 0x825DCB8C; continue 'dispatch;
            }
            0x825DCEB8 => {
    //   block [0x825DCEB8..0x825DCED4)
	// 825DCEB8: 396BFFA0  addi r11, r11, -0x60
	ctx.r[11].s64 = ctx.r[11].s64 + -96;
	// 825DCEBC: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DCEC0: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 825DCEC4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DCEC8: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825DCECC: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 825DCED0: 48000068  b 0x825dcf38
	pc = 0x825DCF38; continue 'dispatch;
            }
            0x825DCED4 => {
    //   block [0x825DCED4..0x825DCEFC)
	// 825DCED4: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DCED8: 390BFF9C  addi r8, r11, -0x64
	ctx.r[8].s64 = ctx.r[11].s64 + -100;
	// 825DCEDC: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DCEE0: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 825DCEE4: 552B403E  rotlwi r11, r9, 8
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825DCEE8: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825DCEEC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DCEF0: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825DCEF4: 7D69392E  stwx r11, r9, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 825DCEF8: 48000040  b 0x825dcf38
	pc = 0x825DCF38; continue 'dispatch;
            }
            0x825DCEFC => {
    //   block [0x825DCEFC..0x825DCF5C)
	// 825DCEFC: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DCF00: 38EBFF98  addi r7, r11, -0x68
	ctx.r[7].s64 = ctx.r[11].s64 + -104;
	// 825DCF04: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DCF08: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825DCF0C: 554B403E  rotlwi r11, r10, 8
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825DCF10: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DCF14: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DCF18: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825DCF1C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825DCF20: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825DCF24: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DCF28: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DCF2C: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DCF30: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DCF34: 7D67312E  stwx r11, r7, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 825DCF38: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825DCF3C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DCF40: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825DCF44: 419A0010  beq cr6, 0x825dcf54
	if ctx.cr[6].eq {
	pc = 0x825DCF54; continue 'dispatch;
	}
	// 825DCF48: E95E0000  ld r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825DCF4C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825DCF50: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825DCF54: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825DCF58: 4BFFFC34  b 0x825dcb8c
	pc = 0x825DCB8C; continue 'dispatch;
            }
            0x825DCF5C => {
    //   block [0x825DCF5C..0x825DCFB0)
	// 825DCF5C: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 825DCF60: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825DCF64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DCF68: 4BE8BE91  bl 0x82468df8
	ctx.lr = 0x825DCF6C;
	sub_82468DF8(ctx, base);
	// 825DCF6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DCF70: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825DCF74: 4BE8B32D  bl 0x824682a0
	ctx.lr = 0x825DCF78;
	sub_824682A0(ctx, base);
	// 825DCF78: 807B9190  lwz r3, -0x6e70(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-28272 as u32) ) } as u64;
	// 825DCF7C: 3CA01298  lis r5, 0x1298
	ctx.r[5].s64 = 311951360;
	// 825DCF80: 390000D3  li r8, 0xd3
	ctx.r[8].s64 = 211;
	// 825DCF84: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825DCF88: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 825DCF8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DCF90: 60A5FEDD  ori r5, r5, 0xfedd
	ctx.r[5].u64 = ctx.r[5].u64 | 65245;
	// 825DCF94: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825DCF98: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DCF9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DCFA0: 4E800421  bctrl
	ctx.lr = 0x825DCFA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DCFA4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DCFA8: 4BE8B939  bl 0x824688e0
	ctx.lr = 0x825DCFAC;
	sub_824688E0(ctx, base);
	// 825DCFAC: 4BFFFBE0  b 0x825dcb8c
	pc = 0x825DCB8C; continue 'dispatch;
            }
            0x825DCFB0 => {
    //   block [0x825DCFB0..0x825DCFB8)
	// 825DCFB0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DCFB4: 48000068  b 0x825dd01c
	pc = 0x825DD01C; continue 'dispatch;
            }
            0x825DCFB8 => {
    //   block [0x825DCFB8..0x825DCFCC)
	// 825DCFB8: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DCFBC: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DCFC0: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DCFC4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DCFC8: 48000054  b 0x825dd01c
	pc = 0x825DD01C; continue 'dispatch;
            }
            0x825DCFCC => {
    //   block [0x825DCFCC..0x825DCFEC)
	// 825DCFCC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DCFD0: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DCFD4: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DCFD8: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DCFDC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DCFE0: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DCFE4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DCFE8: 48000034  b 0x825dd01c
	pc = 0x825DD01C; continue 'dispatch;
            }
            0x825DCFEC => {
    //   block [0x825DCFEC..0x825DD018)
	// 825DCFEC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DCFF0: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DCFF4: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DCFF8: 891F0003  lbz r8, 3(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DCFFC: 893F0004  lbz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DD000: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DD004: 550A403E  rotlwi r10, r8, 8
	ctx.r[10].u64 = ((ctx.r[8].u32).rotate_left(8)) as u64;
	// 825DD008: 556B801E  slwi r11, r11, 0x10
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(16);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DD00C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825DD010: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825DD014: 48000008  b 0x825dd01c
	pc = 0x825DD01C; continue 'dispatch;
            }
            0x825DD018 => {
    //   block [0x825DD018..0x825DD060)
	// 825DD018: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 825DD01C: 83FA0000  lwz r31, 0(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD020: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD024: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825DD028: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD02C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DD030: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825DD034: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825DD038: 409A0010  bne cr6, 0x825dd048
	if !ctx.cr[6].eq {
	pc = 0x825DD048; continue 'dispatch;
	}
	// 825DD03C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 825DD040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DD044: 4BE9130D  bl 0x8246e350
	ctx.lr = 0x825DD048;
	sub_8246E350(ctx, base);
	// 825DD048: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DD04C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD050: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825DD054: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DD058: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825DD05C: 7FCA492E  stwx r30, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[30].u32) };
	pc = 0x825DD060; continue 'dispatch;
            }
            0x825DD060 => {
    //   block [0x825DD060..0x825DD068)
	// 825DD060: 382102B0  addi r1, r1, 0x2b0
	ctx.r[1].s64 = ctx.r[1].s64 + 688;
	// 825DD064: 4BF5809C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DD068 size=1256
    let mut pc: u32 = 0x825DD068;
    'dispatch: loop {
        match pc {
            0x825DD068 => {
    //   block [0x825DD068..0x825DD268)
	// 825DD068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DD06C: 4BF58045  bl 0x825350b0
	ctx.lr = 0x825DD070;
	sub_82535080(ctx, base);
	// 825DD070: 9421FD50  stwu r1, -0x2b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-688 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DD074: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825DD078: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825DD07C: 3BABA65C  addi r29, r11, -0x59a4
	ctx.r[29].s64 = ctx.r[11].s64 + -22948;
	// 825DD080: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825DD084: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DD088: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DD08C: 3F608293  lis r27, -0x7d6d
	ctx.r[27].s64 = -2104295424;
	// 825DD090: 3B8BA1D8  addi r28, r11, -0x5e28
	ctx.r[28].s64 = ctx.r[11].s64 + -24104;
	// 825DD094: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD098: 2B0B006B  cmplwi cr6, r11, 0x6b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 107 as u32, &mut ctx.xer);
	// 825DD09C: 419903A8  bgt cr6, 0x825dd444
	if ctx.cr[6].gt {
	pc = 0x825DD444; continue 'dispatch;
	}
	// 825DD0A0: 3D80825E  lis r12, -0x7da2
	ctx.r[12].s64 = -2107768832;
	// 825DD0A4: 398CD0B8  addi r12, r12, -0x2f48
	ctx.r[12].s64 = ctx.r[12].s64 + -12104;
	// 825DD0A8: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825DD0AC: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825DD0B0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825DD0B4: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825DD548; continue 'dispatch;
		},
		1 => {
	pc = 0x825DD268; continue 'dispatch;
		},
		2 => {
	pc = 0x825DD268; continue 'dispatch;
		},
		3 => {
	pc = 0x825DD268; continue 'dispatch;
		},
		4 => {
	pc = 0x825DD268; continue 'dispatch;
		},
		5 => {
	pc = 0x825DD294; continue 'dispatch;
		},
		6 => {
	pc = 0x825DD2A4; continue 'dispatch;
		},
		7 => {
	pc = 0x825DD2C0; continue 'dispatch;
		},
		8 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		9 => {
	pc = 0x825DD2E8; continue 'dispatch;
		},
		10 => {
	pc = 0x825DD318; continue 'dispatch;
		},
		11 => {
	pc = 0x825DD354; continue 'dispatch;
		},
		12 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		13 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		14 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		15 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		16 => {
	pc = 0x825DD268; continue 'dispatch;
		},
		17 => {
	pc = 0x825DD268; continue 'dispatch;
		},
		18 => {
	pc = 0x825DD268; continue 'dispatch;
		},
		19 => {
	pc = 0x825DD268; continue 'dispatch;
		},
		20 => {
	pc = 0x825DD268; continue 'dispatch;
		},
		21 => {
	pc = 0x825DD268; continue 'dispatch;
		},
		22 => {
	pc = 0x825DD268; continue 'dispatch;
		},
		23 => {
	pc = 0x825DD268; continue 'dispatch;
		},
		24 => {
	pc = 0x825DD268; continue 'dispatch;
		},
		25 => {
	pc = 0x825DD268; continue 'dispatch;
		},
		26 => {
	pc = 0x825DD268; continue 'dispatch;
		},
		27 => {
	pc = 0x825DD268; continue 'dispatch;
		},
		28 => {
	pc = 0x825DD268; continue 'dispatch;
		},
		29 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		30 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		31 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		32 => {
	pc = 0x825DD34C; continue 'dispatch;
		},
		33 => {
	pc = 0x825DD34C; continue 'dispatch;
		},
		34 => {
	pc = 0x825DD34C; continue 'dispatch;
		},
		35 => {
	pc = 0x825DD270; continue 'dispatch;
		},
		36 => {
	pc = 0x825DD270; continue 'dispatch;
		},
		37 => {
	pc = 0x825DD270; continue 'dispatch;
		},
		38 => {
	pc = 0x825DD34C; continue 'dispatch;
		},
		39 => {
	pc = 0x825DD34C; continue 'dispatch;
		},
		40 => {
	pc = 0x825DD34C; continue 'dispatch;
		},
		41 => {
	pc = 0x825DD28C; continue 'dispatch;
		},
		42 => {
	pc = 0x825DD28C; continue 'dispatch;
		},
		43 => {
	pc = 0x825DD28C; continue 'dispatch;
		},
		44 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		45 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		46 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		47 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		48 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		49 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		50 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		51 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		52 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		53 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		54 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		55 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		56 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		57 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		58 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		59 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		60 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		61 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		62 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		63 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		64 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		65 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		66 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		67 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		68 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		69 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		70 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		71 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		72 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		73 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		74 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		75 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		76 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		77 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		78 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		79 => {
	pc = 0x825DD500; continue 'dispatch;
		},
		80 => {
	pc = 0x825DD498; continue 'dispatch;
		},
		81 => {
	pc = 0x825DD4A0; continue 'dispatch;
		},
		82 => {
	pc = 0x825DD4B4; continue 'dispatch;
		},
		83 => {
	pc = 0x825DD4D4; continue 'dispatch;
		},
		84 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		85 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		86 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		87 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		88 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		89 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		90 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		91 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		92 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		93 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		94 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		95 => {
	pc = 0x825DD444; continue 'dispatch;
		},
		96 => {
	pc = 0x825DD3A0; continue 'dispatch;
		},
		97 => {
	pc = 0x825DD3A0; continue 'dispatch;
		},
		98 => {
	pc = 0x825DD3A0; continue 'dispatch;
		},
		99 => {
	pc = 0x825DD3A0; continue 'dispatch;
		},
		100 => {
	pc = 0x825DD3BC; continue 'dispatch;
		},
		101 => {
	pc = 0x825DD3BC; continue 'dispatch;
		},
		102 => {
	pc = 0x825DD3BC; continue 'dispatch;
		},
		103 => {
	pc = 0x825DD3BC; continue 'dispatch;
		},
		104 => {
	pc = 0x825DD3E4; continue 'dispatch;
		},
		105 => {
	pc = 0x825DD3E4; continue 'dispatch;
		},
		106 => {
	pc = 0x825DD3E4; continue 'dispatch;
		},
		107 => {
	pc = 0x825DD3E4; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825DD0B8: 825DD548  lwz r18, -0x2ab8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-10936 as u32) ) } as u64;
	// 825DD0BC: 825DD268  lwz r18, -0x2d98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825DD0C0: 825DD268  lwz r18, -0x2d98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825DD0C4: 825DD268  lwz r18, -0x2d98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825DD0C8: 825DD268  lwz r18, -0x2d98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825DD0CC: 825DD294  lwz r18, -0x2d6c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11628 as u32) ) } as u64;
	// 825DD0D0: 825DD2A4  lwz r18, -0x2d5c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11612 as u32) ) } as u64;
	// 825DD0D4: 825DD2C0  lwz r18, -0x2d40(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11584 as u32) ) } as u64;
	// 825DD0D8: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD0DC: 825DD2E8  lwz r18, -0x2d18(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11544 as u32) ) } as u64;
	// 825DD0E0: 825DD318  lwz r18, -0x2ce8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11496 as u32) ) } as u64;
	// 825DD0E4: 825DD354  lwz r18, -0x2cac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11436 as u32) ) } as u64;
	// 825DD0E8: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD0EC: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD0F0: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD0F4: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD0F8: 825DD268  lwz r18, -0x2d98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825DD0FC: 825DD268  lwz r18, -0x2d98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825DD100: 825DD268  lwz r18, -0x2d98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825DD104: 825DD268  lwz r18, -0x2d98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825DD108: 825DD268  lwz r18, -0x2d98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825DD10C: 825DD268  lwz r18, -0x2d98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825DD110: 825DD268  lwz r18, -0x2d98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825DD114: 825DD268  lwz r18, -0x2d98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825DD118: 825DD268  lwz r18, -0x2d98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825DD11C: 825DD268  lwz r18, -0x2d98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825DD120: 825DD268  lwz r18, -0x2d98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825DD124: 825DD268  lwz r18, -0x2d98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825DD128: 825DD268  lwz r18, -0x2d98(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825DD12C: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD130: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD134: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD138: 825DD34C  lwz r18, -0x2cb4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11444 as u32) ) } as u64;
	// 825DD13C: 825DD34C  lwz r18, -0x2cb4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11444 as u32) ) } as u64;
	// 825DD140: 825DD34C  lwz r18, -0x2cb4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11444 as u32) ) } as u64;
	// 825DD144: 825DD270  lwz r18, -0x2d90(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11664 as u32) ) } as u64;
	// 825DD148: 825DD270  lwz r18, -0x2d90(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11664 as u32) ) } as u64;
	// 825DD14C: 825DD270  lwz r18, -0x2d90(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11664 as u32) ) } as u64;
	// 825DD150: 825DD34C  lwz r18, -0x2cb4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11444 as u32) ) } as u64;
	// 825DD154: 825DD34C  lwz r18, -0x2cb4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11444 as u32) ) } as u64;
	// 825DD158: 825DD34C  lwz r18, -0x2cb4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11444 as u32) ) } as u64;
	// 825DD15C: 825DD28C  lwz r18, -0x2d74(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11636 as u32) ) } as u64;
	// 825DD160: 825DD28C  lwz r18, -0x2d74(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11636 as u32) ) } as u64;
	// 825DD164: 825DD28C  lwz r18, -0x2d74(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11636 as u32) ) } as u64;
	// 825DD168: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD16C: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD170: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD174: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD178: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD17C: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD180: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD184: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD188: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD18C: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD190: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD194: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD198: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD19C: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1A0: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1A4: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1A8: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1AC: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1B0: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1B4: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1B8: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1BC: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1C0: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1C4: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1C8: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1CC: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1D0: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1D4: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1D8: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1DC: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1E0: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1E4: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1E8: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1EC: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1F0: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1F4: 825DD500  lwz r18, -0x2b00(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11008 as u32) ) } as u64;
	// 825DD1F8: 825DD498  lwz r18, -0x2b68(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11112 as u32) ) } as u64;
	// 825DD1FC: 825DD4A0  lwz r18, -0x2b60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11104 as u32) ) } as u64;
	// 825DD200: 825DD4B4  lwz r18, -0x2b4c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11084 as u32) ) } as u64;
	// 825DD204: 825DD4D4  lwz r18, -0x2b2c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11052 as u32) ) } as u64;
	// 825DD208: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD20C: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD210: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD214: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD218: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD21C: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD220: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD224: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD228: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD22C: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD230: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD234: 825DD444  lwz r18, -0x2bbc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11196 as u32) ) } as u64;
	// 825DD238: 825DD3A0  lwz r18, -0x2c60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11360 as u32) ) } as u64;
	// 825DD23C: 825DD3A0  lwz r18, -0x2c60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11360 as u32) ) } as u64;
	// 825DD240: 825DD3A0  lwz r18, -0x2c60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11360 as u32) ) } as u64;
	// 825DD244: 825DD3A0  lwz r18, -0x2c60(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11360 as u32) ) } as u64;
	// 825DD248: 825DD3BC  lwz r18, -0x2c44(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11332 as u32) ) } as u64;
	// 825DD24C: 825DD3BC  lwz r18, -0x2c44(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11332 as u32) ) } as u64;
	// 825DD250: 825DD3BC  lwz r18, -0x2c44(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11332 as u32) ) } as u64;
	// 825DD254: 825DD3BC  lwz r18, -0x2c44(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11332 as u32) ) } as u64;
	// 825DD258: 825DD3E4  lwz r18, -0x2c1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11292 as u32) ) } as u64;
	// 825DD25C: 825DD3E4  lwz r18, -0x2c1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11292 as u32) ) } as u64;
	// 825DD260: 825DD3E4  lwz r18, -0x2c1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11292 as u32) ) } as u64;
	// 825DD264: 825DD3E4  lwz r18, -0x2c1c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11292 as u32) ) } as u64;
            }
            0x825DD268 => {
    //   block [0x825DD268..0x825DD270)
	// 825DD268: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DD26C: 4BFFFE28  b 0x825dd094
	pc = 0x825DD094; continue 'dispatch;
            }
            0x825DD270 => {
    //   block [0x825DD270..0x825DD28C)
	// 825DD270: 897F0003  lbz r11, 3(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DD274: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DD278: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DD27C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DD280: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DD284: 3BEB0007  addi r31, r11, 7
	ctx.r[31].s64 = ctx.r[11].s64 + 7;
	// 825DD288: 4BFFFE0C  b 0x825dd094
	pc = 0x825DD094; continue 'dispatch;
            }
            0x825DD28C => {
    //   block [0x825DD28C..0x825DD294)
	// 825DD28C: 3BFF0007  addi r31, r31, 7
	ctx.r[31].s64 = ctx.r[31].s64 + 7;
	// 825DD290: 4BFFFE04  b 0x825dd094
	pc = 0x825DD094; continue 'dispatch;
            }
            0x825DD294 => {
    //   block [0x825DD294..0x825DD2A4)
	// 825DD294: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD298: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DD29C: 3BEB0002  addi r31, r11, 2
	ctx.r[31].s64 = ctx.r[11].s64 + 2;
	// 825DD2A0: 4BFFFDF4  b 0x825dd094
	pc = 0x825DD094; continue 'dispatch;
            }
            0x825DD2A4 => {
    //   block [0x825DD2A4..0x825DD2C0)
	// 825DD2A4: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD2A8: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DD2AC: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DD2B0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DD2B4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DD2B8: 3BEB0003  addi r31, r11, 3
	ctx.r[31].s64 = ctx.r[11].s64 + 3;
	// 825DD2BC: 4BFFFDD8  b 0x825dd094
	pc = 0x825DD094; continue 'dispatch;
            }
            0x825DD2C0 => {
    //   block [0x825DD2C0..0x825DD2E8)
	// 825DD2C0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD2C4: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DD2C8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DD2CC: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DD2D0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DD2D4: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DD2D8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DD2DC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DD2E0: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 825DD2E4: 4BFFFDB0  b 0x825dd094
	pc = 0x825DD094; continue 'dispatch;
            }
            0x825DD2E8 => {
    //   block [0x825DD2E8..0x825DD318)
	// 825DD2E8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825DD2EC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD2F0: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825DD2F4: 419A0010  beq cr6, 0x825dd304
	if ctx.cr[6].eq {
	pc = 0x825DD304; continue 'dispatch;
	}
	// 825DD2F8: E95E0000  ld r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825DD2FC: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825DD300: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825DD304: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DD308: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825DD30C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825DD310: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825DD314: 4BFFFD80  b 0x825dd094
	pc = 0x825DD094; continue 'dispatch;
            }
            0x825DD318 => {
    //   block [0x825DD318..0x825DD34C)
	// 825DD318: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD31C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 825DD320: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DD324: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DD328: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825DD32C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DD330: 419A0010  beq cr6, 0x825dd340
	if ctx.cr[6].eq {
	pc = 0x825DD340; continue 'dispatch;
	}
	// 825DD334: E95E0000  ld r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825DD338: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825DD33C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825DD340: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DD344: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DD348: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x825DD34C; continue 'dispatch;
            }
            0x825DD34C => {
    //   block [0x825DD34C..0x825DD354)
	// 825DD34C: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825DD350: 4BFFFD44  b 0x825dd094
	pc = 0x825DD094; continue 'dispatch;
            }
            0x825DD354 => {
    //   block [0x825DD354..0x825DD3A0)
	// 825DD354: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD358: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825DD35C: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DD360: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DD364: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DD368: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DD36C: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825DD370: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825DD374: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DD378: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DD37C: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DD380: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DD384: 419A0010  beq cr6, 0x825dd394
	if ctx.cr[6].eq {
	pc = 0x825DD394; continue 'dispatch;
	}
	// 825DD388: E95E0000  ld r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825DD38C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825DD390: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825DD394: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825DD398: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825DD39C: 4BFFFCF8  b 0x825dd094
	pc = 0x825DD094; continue 'dispatch;
            }
            0x825DD3A0 => {
    //   block [0x825DD3A0..0x825DD3BC)
	// 825DD3A0: 396BFFA0  addi r11, r11, -0x60
	ctx.r[11].s64 = ctx.r[11].s64 + -96;
	// 825DD3A4: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD3A8: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 825DD3AC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DD3B0: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825DD3B4: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 825DD3B8: 48000068  b 0x825dd420
	pc = 0x825DD420; continue 'dispatch;
            }
            0x825DD3BC => {
    //   block [0x825DD3BC..0x825DD3E4)
	// 825DD3BC: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD3C0: 390BFF9C  addi r8, r11, -0x64
	ctx.r[8].s64 = ctx.r[11].s64 + -100;
	// 825DD3C4: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DD3C8: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 825DD3CC: 552B403E  rotlwi r11, r9, 8
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825DD3D0: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825DD3D4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DD3D8: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825DD3DC: 7D69392E  stwx r11, r9, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 825DD3E0: 48000040  b 0x825dd420
	pc = 0x825DD420; continue 'dispatch;
            }
            0x825DD3E4 => {
    //   block [0x825DD3E4..0x825DD444)
	// 825DD3E4: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD3E8: 38EBFF98  addi r7, r11, -0x68
	ctx.r[7].s64 = ctx.r[11].s64 + -104;
	// 825DD3EC: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DD3F0: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825DD3F4: 554B403E  rotlwi r11, r10, 8
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825DD3F8: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DD3FC: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DD400: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825DD404: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825DD408: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825DD40C: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DD410: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DD414: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DD418: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DD41C: 7D67312E  stwx r11, r7, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 825DD420: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825DD424: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DD428: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825DD42C: 419A0010  beq cr6, 0x825dd43c
	if ctx.cr[6].eq {
	pc = 0x825DD43C; continue 'dispatch;
	}
	// 825DD430: E95E0000  ld r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825DD434: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825DD438: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825DD43C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825DD440: 4BFFFC54  b 0x825dd094
	pc = 0x825DD094; continue 'dispatch;
            }
            0x825DD444 => {
    //   block [0x825DD444..0x825DD498)
	// 825DD444: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 825DD448: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825DD44C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DD450: 4BE8B9A9  bl 0x82468df8
	ctx.lr = 0x825DD454;
	sub_82468DF8(ctx, base);
	// 825DD454: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DD458: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825DD45C: 4BE8AE45  bl 0x824682a0
	ctx.lr = 0x825DD460;
	sub_824682A0(ctx, base);
	// 825DD460: 807B9190  lwz r3, -0x6e70(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-28272 as u32) ) } as u64;
	// 825DD464: 3CA01298  lis r5, 0x1298
	ctx.r[5].s64 = 311951360;
	// 825DD468: 39000131  li r8, 0x131
	ctx.r[8].s64 = 305;
	// 825DD46C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825DD470: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 825DD474: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD478: 60A5FEDD  ori r5, r5, 0xfedd
	ctx.r[5].u64 = ctx.r[5].u64 | 65245;
	// 825DD47C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825DD480: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DD484: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DD488: 4E800421  bctrl
	ctx.lr = 0x825DD48C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DD48C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DD490: 4BE8B451  bl 0x824688e0
	ctx.lr = 0x825DD494;
	sub_824688E0(ctx, base);
	// 825DD494: 4BFFFC00  b 0x825dd094
	pc = 0x825DD094; continue 'dispatch;
            }
            0x825DD498 => {
    //   block [0x825DD498..0x825DD4A0)
	// 825DD498: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD49C: 48000068  b 0x825dd504
	pc = 0x825DD504; continue 'dispatch;
            }
            0x825DD4A0 => {
    //   block [0x825DD4A0..0x825DD4B4)
	// 825DD4A0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD4A4: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DD4A8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DD4AC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DD4B0: 48000054  b 0x825dd504
	pc = 0x825DD504; continue 'dispatch;
            }
            0x825DD4B4 => {
    //   block [0x825DD4B4..0x825DD4D4)
	// 825DD4B4: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD4B8: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DD4BC: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DD4C0: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DD4C4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DD4C8: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DD4CC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DD4D0: 48000034  b 0x825dd504
	pc = 0x825DD504; continue 'dispatch;
            }
            0x825DD4D4 => {
    //   block [0x825DD4D4..0x825DD500)
	// 825DD4D4: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD4D8: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DD4DC: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DD4E0: 891F0003  lbz r8, 3(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DD4E4: 893F0004  lbz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DD4E8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DD4EC: 550A403E  rotlwi r10, r8, 8
	ctx.r[10].u64 = ((ctx.r[8].u32).rotate_left(8)) as u64;
	// 825DD4F0: 556B801E  slwi r11, r11, 0x10
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(16);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DD4F4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825DD4F8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825DD4FC: 48000008  b 0x825dd504
	pc = 0x825DD504; continue 'dispatch;
            }
            0x825DD500 => {
    //   block [0x825DD500..0x825DD548)
	// 825DD500: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 825DD504: 83FA0000  lwz r31, 0(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD508: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD50C: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825DD510: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DD514: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DD518: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825DD51C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825DD520: 409A0010  bne cr6, 0x825dd530
	if !ctx.cr[6].eq {
	pc = 0x825DD530; continue 'dispatch;
	}
	// 825DD524: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 825DD528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DD52C: 4BE90E25  bl 0x8246e350
	ctx.lr = 0x825DD530;
	sub_8246E350(ctx, base);
	// 825DD530: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DD534: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD538: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825DD53C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DD540: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825DD544: 7FCA492E  stwx r30, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[30].u32) };
	pc = 0x825DD548; continue 'dispatch;
            }
            0x825DD548 => {
    //   block [0x825DD548..0x825DD550)
	// 825DD548: 382102B0  addi r1, r1, 0x2b0
	ctx.r[1].s64 = ctx.r[1].s64 + 688;
	// 825DD54C: 4BF57BB4  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DD550 size=2920
    let mut pc: u32 = 0x825DD550;
    'dispatch: loop {
        match pc {
            0x825DD550 => {
    //   block [0x825DD550..0x825DD758)
	// 825DD550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DD554: 4BF57B4D  bl 0x825350a0
	ctx.lr = 0x825DD558;
	sub_82535080(ctx, base);
	// 825DD558: 9421FCF0  stwu r1, -0x310(r1)
	ea = ctx.r[1].u32.wrapping_add(-784 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DD55C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825DD560: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 825DD564: 3BABA694  addi r29, r11, -0x596c
	ctx.r[29].s64 = ctx.r[11].s64 + -22892;
	// 825DD568: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825DD56C: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 825DD570: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825DD574: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825DD578: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 825DD57C: 3F608293  lis r27, -0x7d6d
	ctx.r[27].s64 = -2104295424;
	// 825DD580: 3B8BA1D8  addi r28, r11, -0x5e28
	ctx.r[28].s64 = ctx.r[11].s64 + -24104;
	// 825DD584: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD588: 2B0B006B  cmplwi cr6, r11, 0x6b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 107 as u32, &mut ctx.xer);
	// 825DD58C: 41990574  bgt cr6, 0x825ddb00
	if ctx.cr[6].gt {
	pc = 0x825DDB00; continue 'dispatch;
	}
	// 825DD590: 3D80825E  lis r12, -0x7da2
	ctx.r[12].s64 = -2107768832;
	// 825DD594: 398CD5A8  addi r12, r12, -0x2a58
	ctx.r[12].s64 = ctx.r[12].s64 + -10840;
	// 825DD598: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825DD59C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825DD5A0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825DD5A4: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825DE0A4; continue 'dispatch;
		},
		1 => {
	pc = 0x825DD870; continue 'dispatch;
		},
		2 => {
	pc = 0x825DD870; continue 'dispatch;
		},
		3 => {
	pc = 0x825DD870; continue 'dispatch;
		},
		4 => {
	pc = 0x825DD870; continue 'dispatch;
		},
		5 => {
	pc = 0x825DD7F8; continue 'dispatch;
		},
		6 => {
	pc = 0x825DD808; continue 'dispatch;
		},
		7 => {
	pc = 0x825DD824; continue 'dispatch;
		},
		8 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		9 => {
	pc = 0x825DD944; continue 'dispatch;
		},
		10 => {
	pc = 0x825DD98C; continue 'dispatch;
		},
		11 => {
	pc = 0x825DD9E0; continue 'dispatch;
		},
		12 => {
	pc = 0x825DD84C; continue 'dispatch;
		},
		13 => {
	pc = 0x825DDA3C; continue 'dispatch;
		},
		14 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		15 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		16 => {
	pc = 0x825DDE14; continue 'dispatch;
		},
		17 => {
	pc = 0x825DDE14; continue 'dispatch;
		},
		18 => {
	pc = 0x825DDE14; continue 'dispatch;
		},
		19 => {
	pc = 0x825DDB54; continue 'dispatch;
		},
		20 => {
	pc = 0x825DDB8C; continue 'dispatch;
		},
		21 => {
	pc = 0x825DDBCC; continue 'dispatch;
		},
		22 => {
	pc = 0x825DDC04; continue 'dispatch;
		},
		23 => {
	pc = 0x825DDC44; continue 'dispatch;
		},
		24 => {
	pc = 0x825DDC7C; continue 'dispatch;
		},
		25 => {
	pc = 0x825DDCBC; continue 'dispatch;
		},
		26 => {
	pc = 0x825DDD0C; continue 'dispatch;
		},
		27 => {
	pc = 0x825DDD64; continue 'dispatch;
		},
		28 => {
	pc = 0x825DDDBC; continue 'dispatch;
		},
		29 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		30 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		31 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		32 => {
	pc = 0x825DDE30; continue 'dispatch;
		},
		33 => {
	pc = 0x825DDE30; continue 'dispatch;
		},
		34 => {
	pc = 0x825DDE30; continue 'dispatch;
		},
		35 => {
	pc = 0x825DDE64; continue 'dispatch;
		},
		36 => {
	pc = 0x825DDE64; continue 'dispatch;
		},
		37 => {
	pc = 0x825DDE64; continue 'dispatch;
		},
		38 => {
	pc = 0x825DD758; continue 'dispatch;
		},
		39 => {
	pc = 0x825DD758; continue 'dispatch;
		},
		40 => {
	pc = 0x825DD758; continue 'dispatch;
		},
		41 => {
	pc = 0x825DD790; continue 'dispatch;
		},
		42 => {
	pc = 0x825DD790; continue 'dispatch;
		},
		43 => {
	pc = 0x825DD790; continue 'dispatch;
		},
		44 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		45 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		46 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		47 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		48 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		49 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		50 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		51 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		52 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		53 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		54 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		55 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		56 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		57 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		58 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		59 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		60 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		61 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		62 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		63 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		64 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		65 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		66 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		67 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		68 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		69 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		70 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		71 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		72 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		73 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		74 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		75 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		76 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		77 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		78 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		79 => {
	pc = 0x825DE064; continue 'dispatch;
		},
		80 => {
	pc = 0x825DDFFC; continue 'dispatch;
		},
		81 => {
	pc = 0x825DE004; continue 'dispatch;
		},
		82 => {
	pc = 0x825DE018; continue 'dispatch;
		},
		83 => {
	pc = 0x825DE038; continue 'dispatch;
		},
		84 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		85 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		86 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		87 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		88 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		89 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		90 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		91 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		92 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		93 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		94 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		95 => {
	pc = 0x825DDB00; continue 'dispatch;
		},
		96 => {
	pc = 0x825DDA44; continue 'dispatch;
		},
		97 => {
	pc = 0x825DDA44; continue 'dispatch;
		},
		98 => {
	pc = 0x825DDA44; continue 'dispatch;
		},
		99 => {
	pc = 0x825DDA44; continue 'dispatch;
		},
		100 => {
	pc = 0x825DDA60; continue 'dispatch;
		},
		101 => {
	pc = 0x825DDA60; continue 'dispatch;
		},
		102 => {
	pc = 0x825DDA60; continue 'dispatch;
		},
		103 => {
	pc = 0x825DDA60; continue 'dispatch;
		},
		104 => {
	pc = 0x825DDA88; continue 'dispatch;
		},
		105 => {
	pc = 0x825DDA88; continue 'dispatch;
		},
		106 => {
	pc = 0x825DDA88; continue 'dispatch;
		},
		107 => {
	pc = 0x825DDA88; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825DD5A8: 825DE0A4  lwz r18, -0x1f5c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8028 as u32) ) } as u64;
	// 825DD5AC: 825DD870  lwz r18, -0x2790(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-10128 as u32) ) } as u64;
	// 825DD5B0: 825DD870  lwz r18, -0x2790(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-10128 as u32) ) } as u64;
	// 825DD5B4: 825DD870  lwz r18, -0x2790(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-10128 as u32) ) } as u64;
	// 825DD5B8: 825DD870  lwz r18, -0x2790(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-10128 as u32) ) } as u64;
	// 825DD5BC: 825DD7F8  lwz r18, -0x2808(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-10248 as u32) ) } as u64;
	// 825DD5C0: 825DD808  lwz r18, -0x27f8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-10232 as u32) ) } as u64;
	// 825DD5C4: 825DD824  lwz r18, -0x27dc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-10204 as u32) ) } as u64;
	// 825DD5C8: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD5CC: 825DD944  lwz r18, -0x26bc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9916 as u32) ) } as u64;
	// 825DD5D0: 825DD98C  lwz r18, -0x2674(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9844 as u32) ) } as u64;
	// 825DD5D4: 825DD9E0  lwz r18, -0x2620(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9760 as u32) ) } as u64;
	// 825DD5D8: 825DD84C  lwz r18, -0x27b4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-10164 as u32) ) } as u64;
	// 825DD5DC: 825DDA3C  lwz r18, -0x25c4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9668 as u32) ) } as u64;
	// 825DD5E0: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD5E4: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD5E8: 825DDE14  lwz r18, -0x21ec(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8684 as u32) ) } as u64;
	// 825DD5EC: 825DDE14  lwz r18, -0x21ec(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8684 as u32) ) } as u64;
	// 825DD5F0: 825DDE14  lwz r18, -0x21ec(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8684 as u32) ) } as u64;
	// 825DD5F4: 825DDB54  lwz r18, -0x24ac(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9388 as u32) ) } as u64;
	// 825DD5F8: 825DDB8C  lwz r18, -0x2474(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9332 as u32) ) } as u64;
	// 825DD5FC: 825DDBCC  lwz r18, -0x2434(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9268 as u32) ) } as u64;
	// 825DD600: 825DDC04  lwz r18, -0x23fc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9212 as u32) ) } as u64;
	// 825DD604: 825DDC44  lwz r18, -0x23bc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9148 as u32) ) } as u64;
	// 825DD608: 825DDC7C  lwz r18, -0x2384(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9092 as u32) ) } as u64;
	// 825DD60C: 825DDCBC  lwz r18, -0x2344(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9028 as u32) ) } as u64;
	// 825DD610: 825DDD0C  lwz r18, -0x22f4(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8948 as u32) ) } as u64;
	// 825DD614: 825DDD64  lwz r18, -0x229c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8860 as u32) ) } as u64;
	// 825DD618: 825DDDBC  lwz r18, -0x2244(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8772 as u32) ) } as u64;
	// 825DD61C: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD620: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD624: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD628: 825DDE30  lwz r18, -0x21d0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8656 as u32) ) } as u64;
	// 825DD62C: 825DDE30  lwz r18, -0x21d0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8656 as u32) ) } as u64;
	// 825DD630: 825DDE30  lwz r18, -0x21d0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8656 as u32) ) } as u64;
	// 825DD634: 825DDE64  lwz r18, -0x219c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8604 as u32) ) } as u64;
	// 825DD638: 825DDE64  lwz r18, -0x219c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8604 as u32) ) } as u64;
	// 825DD63C: 825DDE64  lwz r18, -0x219c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8604 as u32) ) } as u64;
	// 825DD640: 825DD758  lwz r18, -0x28a8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-10408 as u32) ) } as u64;
	// 825DD644: 825DD758  lwz r18, -0x28a8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-10408 as u32) ) } as u64;
	// 825DD648: 825DD758  lwz r18, -0x28a8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-10408 as u32) ) } as u64;
	// 825DD64C: 825DD790  lwz r18, -0x2870(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-10352 as u32) ) } as u64;
	// 825DD650: 825DD790  lwz r18, -0x2870(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-10352 as u32) ) } as u64;
	// 825DD654: 825DD790  lwz r18, -0x2870(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-10352 as u32) ) } as u64;
	// 825DD658: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD65C: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD660: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD664: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD668: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD66C: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD670: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD674: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD678: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD67C: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD680: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD684: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD688: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD68C: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD690: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD694: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD698: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD69C: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD6A0: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD6A4: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD6A8: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD6AC: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD6B0: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD6B4: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD6B8: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD6BC: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD6C0: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD6C4: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD6C8: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD6CC: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD6D0: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD6D4: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD6D8: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD6DC: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD6E0: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD6E4: 825DE064  lwz r18, -0x1f9c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 825DD6E8: 825DDFFC  lwz r18, -0x2004(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8196 as u32) ) } as u64;
	// 825DD6EC: 825DE004  lwz r18, -0x1ffc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8188 as u32) ) } as u64;
	// 825DD6F0: 825DE018  lwz r18, -0x1fe8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8168 as u32) ) } as u64;
	// 825DD6F4: 825DE038  lwz r18, -0x1fc8(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8136 as u32) ) } as u64;
	// 825DD6F8: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD6FC: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD700: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD704: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD708: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD70C: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD710: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD714: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD718: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD71C: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD720: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD724: 825DDB00  lwz r18, -0x2500(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9472 as u32) ) } as u64;
	// 825DD728: 825DDA44  lwz r18, -0x25bc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9660 as u32) ) } as u64;
	// 825DD72C: 825DDA44  lwz r18, -0x25bc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9660 as u32) ) } as u64;
	// 825DD730: 825DDA44  lwz r18, -0x25bc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9660 as u32) ) } as u64;
	// 825DD734: 825DDA44  lwz r18, -0x25bc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9660 as u32) ) } as u64;
	// 825DD738: 825DDA60  lwz r18, -0x25a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9632 as u32) ) } as u64;
	// 825DD73C: 825DDA60  lwz r18, -0x25a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9632 as u32) ) } as u64;
	// 825DD740: 825DDA60  lwz r18, -0x25a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9632 as u32) ) } as u64;
	// 825DD744: 825DDA60  lwz r18, -0x25a0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9632 as u32) ) } as u64;
	// 825DD748: 825DDA88  lwz r18, -0x2578(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9592 as u32) ) } as u64;
	// 825DD74C: 825DDA88  lwz r18, -0x2578(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9592 as u32) ) } as u64;
	// 825DD750: 825DDA88  lwz r18, -0x2578(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9592 as u32) ) } as u64;
	// 825DD754: 825DDA88  lwz r18, -0x2578(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9592 as u32) ) } as u64;
            }
            0x825DD758 => {
    //   block [0x825DD758..0x825DD790)
	// 825DD758: 394BFFDA  addi r10, r11, -0x26
	ctx.r[10].s64 = ctx.r[11].s64 + -38;
	// 825DD75C: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD760: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825DD764: 7D4AF02E  lwzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DD768: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825DD76C: 41980774  blt cr6, 0x825ddee0
	if ctx.cr[6].lt {
	pc = 0x825DDEE0; continue 'dispatch;
	}
	// 825DD770: 396BFFDE  addi r11, r11, -0x22
	ctx.r[11].s64 = ctx.r[11].s64 + -34;
	// 825DD774: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DD778: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DD77C: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DD780: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825DD784: 4098075C  bge cr6, 0x825ddee0
	if !ctx.cr[6].lt {
	pc = 0x825DDEE0; continue 'dispatch;
	}
	// 825DD788: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825DD78C: 4BFFFDF8  b 0x825dd584
	pc = 0x825DD584; continue 'dispatch;
            }
            0x825DD790 => {
    //   block [0x825DD790..0x825DD7F8)
	// 825DD790: 394BFFDB  addi r10, r11, -0x25
	ctx.r[10].s64 = ctx.r[11].s64 + -37;
	// 825DD794: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD798: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825DD79C: 5528403E  rotlwi r8, r9, 8
	ctx.r[8].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825DD7A0: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DD7A4: 7CEAC82E  lwzx r7, r10, r25
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 825DD7A8: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DD7AC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825DD7B0: 554A402E  slwi r10, r10, 8
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825DD7B4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825DD7B8: 7F075000  cmpw cr6, r7, r10
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825DD7BC: 41980724  blt cr6, 0x825ddee0
	if ctx.cr[6].lt {
	pc = 0x825DDEE0; continue 'dispatch;
	}
	// 825DD7C0: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DD7C4: 390BFFDF  addi r8, r11, -0x21
	ctx.r[8].s64 = ctx.r[11].s64 + -33;
	// 825DD7C8: 893F0005  lbz r9, 5(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(5 as u32) ) } as u64;
	// 825DD7CC: 554B403E  rotlwi r11, r10, 8
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825DD7D0: 895F0006  lbz r10, 6(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 825DD7D4: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825DD7D8: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825DD7DC: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DD7E0: 7D28C82E  lwzx r9, r8, r25
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 825DD7E4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DD7E8: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825DD7EC: 419906F4  bgt cr6, 0x825ddee0
	if ctx.cr[6].gt {
	pc = 0x825DDEE0; continue 'dispatch;
	}
	// 825DD7F0: 3BFF0007  addi r31, r31, 7
	ctx.r[31].s64 = ctx.r[31].s64 + 7;
	// 825DD7F4: 4BFFFD90  b 0x825dd584
	pc = 0x825DD584; continue 'dispatch;
            }
            0x825DD7F8 => {
    //   block [0x825DD7F8..0x825DD808)
	// 825DD7F8: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD7FC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DD800: 3BEB0002  addi r31, r11, 2
	ctx.r[31].s64 = ctx.r[11].s64 + 2;
	// 825DD804: 4BFFFD80  b 0x825dd584
	pc = 0x825DD584; continue 'dispatch;
            }
            0x825DD808 => {
    //   block [0x825DD808..0x825DD824)
	// 825DD808: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD80C: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DD810: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DD814: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DD818: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DD81C: 3BEB0003  addi r31, r11, 3
	ctx.r[31].s64 = ctx.r[11].s64 + 3;
	// 825DD820: 4BFFFD64  b 0x825dd584
	pc = 0x825DD584; continue 'dispatch;
            }
            0x825DD824 => {
    //   block [0x825DD824..0x825DD84C)
	// 825DD824: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD828: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DD82C: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DD830: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DD834: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DD838: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DD83C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DD840: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DD844: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 825DD848: 4BFFFD3C  b 0x825dd584
	pc = 0x825DD584; continue 'dispatch;
            }
            0x825DD84C => {
    //   block [0x825DD84C..0x825DD870)
	// 825DD84C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD850: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DD854: 81390030  lwz r9, 0x30(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 825DD858: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DD85C: 7D785378  or r24, r11, r10
	ctx.r[24].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 825DD860: 570A482C  slwi r10, r24, 9
	ctx.r[10].u32 = ctx.r[24].u32.wrapping_shl(9);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825DD864: 81690020  lwz r11, 0x20(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DD868: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DD86C: 4BFFFD18  b 0x825dd584
	pc = 0x825DD584; continue 'dispatch;
            }
            0x825DD870 => {
    //   block [0x825DD870..0x825DD944)
	// 825DD870: 813E0020  lwz r9, 0x20(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DD874: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD878: 80D90020  lwz r6, 0x20(r25)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DD87C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825DD880: 80B90024  lwz r5, 0x24(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 825DD884: 80990028  lwz r4, 0x28(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(40 as u32) ) } as u64;
	// 825DD888: 80790010  lwz r3, 0x10(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DD88C: 83590014  lwz r26, 0x14(r25)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 825DD890: 82D90018  lwz r22, 0x18(r25)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DD894: 7D4A5830  slw r10, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825DD898: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 825DD89C: 811E0024  lwz r8, 0x24(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 825DD8A0: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DD8A4: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825DD8A8: 7D295830  slw r9, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825DD8AC: 91210084  stw r9, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 825DD8B0: 80FE0028  lwz r7, 0x28(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 825DD8B4: 891F0003  lbz r8, 3(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DD8B8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DD8BC: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 825DD8C0: 7D085830  slw r8, r8, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[8].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825DD8C4: 91010088  stw r8, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[8].u32 ) };
	// 825DD8C8: 80FE0030  lwz r7, 0x30(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 825DD8CC: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 825DD8D0: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 825DD8D4: 216B0010  subfic r11, r11, 0x10
	ctx.xer.ca = ctx.r[11].u32 <= 16 as u32;
	ctx.r[11].s64 = (16 as i64) - ctx.r[11].s64;
	// 825DD8D8: 7CC75E30  sraw r7, r6, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 825DD8DC: 7CEA3850  subf r7, r10, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 825DD8E0: 90E10070  stw r7, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[7].u32 ) };
	// 825DD8E4: 7CA75E30  sraw r7, r5, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[5].s32 >> tmp.u32) as i64;
	// 825DD8E8: 7CE93850  subf r7, r9, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 825DD8EC: 90E10074  stw r7, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[7].u32 ) };
	// 825DD8F0: 7C875E30  sraw r7, r4, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[4].s32 >> tmp.u32) as i64;
	// 825DD8F4: 7CE83850  subf r7, r8, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 825DD8F8: 90E10078  stw r7, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[7].u32 ) };
	// 825DD8FC: 7C675E30  sraw r7, r3, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[3].s32 >> tmp.u32) as i64;
	// 825DD900: 7D4A3850  subf r10, r10, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 825DD904: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825DD908: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825DD90C: 7F4A5E30  sraw r10, r26, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[26].s32 < 0) && ((ctx.r[26].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[26].s32 >> tmp.u32) as i64;
	// 825DD910: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 825DD914: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825DD918: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 825DD91C: 7ECB5E30  sraw r11, r22, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[22].s32 < 0) && ((ctx.r[22].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[22].s32 >> tmp.u32) as i64;
	// 825DD920: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 825DD924: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DD928: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825DD92C: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 825DD930: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 825DD934: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 825DD938: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 825DD93C: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 825DD940: 4BFFFC44  b 0x825dd584
	pc = 0x825DD584; continue 'dispatch;
            }
            0x825DD944 => {
    //   block [0x825DD944..0x825DD98C)
	// 825DD944: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825DD948: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD94C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DD950: 419A0028  beq cr6, 0x825dd978
	if ctx.cr[6].eq {
	pc = 0x825DD978; continue 'dispatch;
	}
	// 825DD954: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825DD958: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 825DD95C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825DD960: E95E0000  ld r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825DD964: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825DD968: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 825DD96C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825DD970: 4200FFF0  bdnz 0x825dd960
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825DD960; continue 'dispatch;
	}
	// 825DD974: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 825DD978: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825DD97C: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825DD980: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825DD984: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 825DD988: 4BFFFBFC  b 0x825dd584
	pc = 0x825DD584; continue 'dispatch;
            }
            0x825DD98C => {
    //   block [0x825DD98C..0x825DD9E0)
	// 825DD98C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD990: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 825DD994: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DD998: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DD99C: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825DD9A0: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DD9A4: 419A0028  beq cr6, 0x825dd9cc
	if ctx.cr[6].eq {
	pc = 0x825DD9CC; continue 'dispatch;
	}
	// 825DD9A8: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825DD9AC: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 825DD9B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825DD9B4: E95E0000  ld r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825DD9B8: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825DD9BC: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 825DD9C0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825DD9C4: 4200FFF0  bdnz 0x825dd9b4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825DD9B4; continue 'dispatch;
	}
	// 825DD9C8: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 825DD9CC: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825DD9D0: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825DD9D4: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825DD9D8: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 825DD9DC: 4BFFFBA8  b 0x825dd584
	pc = 0x825DD584; continue 'dispatch;
            }
            0x825DD9E0 => {
    //   block [0x825DD9E0..0x825DDA3C)
	// 825DD9E0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DD9E4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 825DD9E8: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DD9EC: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DD9F0: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DD9F4: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DD9F8: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825DD9FC: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825DDA00: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DDA04: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DDA08: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DDA0C: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DDA10: 419A0028  beq cr6, 0x825dda38
	if ctx.cr[6].eq {
	pc = 0x825DDA38; continue 'dispatch;
	}
	// 825DDA14: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825DDA18: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 825DDA1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825DDA20: E95E0000  ld r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825DDA24: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825DDA28: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 825DDA2C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825DDA30: 4200FFF0  bdnz 0x825dda20
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825DDA20; continue 'dispatch;
	}
	// 825DDA34: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 825DDA38: 9121008C  stw r9, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[9].u32 ) };
	pc = 0x825DDA3C; continue 'dispatch;
            }
            0x825DDA3C => {
    //   block [0x825DDA3C..0x825DDA44)
	// 825DDA3C: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825DDA40: 4BFFFB44  b 0x825dd584
	pc = 0x825DD584; continue 'dispatch;
            }
            0x825DDA44 => {
    //   block [0x825DDA44..0x825DDA60)
	// 825DDA44: 396BFFA0  addi r11, r11, -0x60
	ctx.r[11].s64 = ctx.r[11].s64 + -96;
	// 825DDA48: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DDA4C: 39210094  addi r9, r1, 0x94
	ctx.r[9].s64 = ctx.r[1].s64 + 148;
	// 825DDA50: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DDA54: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825DDA58: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 825DDA5C: 48000068  b 0x825ddac4
	pc = 0x825DDAC4; continue 'dispatch;
            }
            0x825DDA60 => {
    //   block [0x825DDA60..0x825DDA88)
	// 825DDA60: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DDA64: 390BFF9C  addi r8, r11, -0x64
	ctx.r[8].s64 = ctx.r[11].s64 + -100;
	// 825DDA68: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DDA6C: 38E10094  addi r7, r1, 0x94
	ctx.r[7].s64 = ctx.r[1].s64 + 148;
	// 825DDA70: 552B403E  rotlwi r11, r9, 8
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825DDA74: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825DDA78: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DDA7C: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825DDA80: 7D69392E  stwx r11, r9, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 825DDA84: 48000040  b 0x825ddac4
	pc = 0x825DDAC4; continue 'dispatch;
            }
            0x825DDA88 => {
    //   block [0x825DDA88..0x825DDB00)
	// 825DDA88: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DDA8C: 38EBFF98  addi r7, r11, -0x68
	ctx.r[7].s64 = ctx.r[11].s64 + -104;
	// 825DDA90: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DDA94: 38C10094  addi r6, r1, 0x94
	ctx.r[6].s64 = ctx.r[1].s64 + 148;
	// 825DDA98: 554B403E  rotlwi r11, r10, 8
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825DDA9C: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DDAA0: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DDAA4: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825DDAA8: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825DDAAC: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825DDAB0: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DDAB4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DDAB8: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DDABC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DDAC0: 7D67312E  stwx r11, r7, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 825DDAC4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825DDAC8: 81210094  lwz r9, 0x94(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825DDACC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DDAD0: 419A0028  beq cr6, 0x825ddaf8
	if ctx.cr[6].eq {
	pc = 0x825DDAF8; continue 'dispatch;
	}
	// 825DDAD4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825DDAD8: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 825DDADC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825DDAE0: E95E0000  ld r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825DDAE4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825DDAE8: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 825DDAEC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825DDAF0: 4200FFF0  bdnz 0x825ddae0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825DDAE0; continue 'dispatch;
	}
	// 825DDAF4: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 825DDAF8: 91210094  stw r9, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 825DDAFC: 4BFFFA88  b 0x825dd584
	pc = 0x825DD584; continue 'dispatch;
            }
            0x825DDB00 => {
    //   block [0x825DDB00..0x825DDB54)
	// 825DDB00: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 825DDB04: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 825DDB08: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825DDB0C: 4BE8B2ED  bl 0x82468df8
	ctx.lr = 0x825DDB10;
	sub_82468DF8(ctx, base);
	// 825DDB10: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825DDB14: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825DDB18: 4BE8A789  bl 0x824682a0
	ctx.lr = 0x825DDB1C;
	sub_824682A0(ctx, base);
	// 825DDB1C: 807B9190  lwz r3, -0x6e70(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-28272 as u32) ) } as u64;
	// 825DDB20: 3CA01298  lis r5, 0x1298
	ctx.r[5].s64 = 311951360;
	// 825DDB24: 3900011B  li r8, 0x11b
	ctx.r[8].s64 = 283;
	// 825DDB28: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825DDB2C: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 825DDB30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDB34: 60A5FEDD  ori r5, r5, 0xfedd
	ctx.r[5].u64 = ctx.r[5].u64 | 65245;
	// 825DDB38: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825DDB3C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DDB40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DDB44: 4E800421  bctrl
	ctx.lr = 0x825DDB48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DDB48: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825DDB4C: 4BE8AD95  bl 0x824688e0
	ctx.lr = 0x825DDB50;
	sub_824688E0(ctx, base);
	// 825DDB50: 4BFFFA34  b 0x825dd584
	pc = 0x825DD584; continue 'dispatch;
            }
            0x825DDB54 => {
    //   block [0x825DDB54..0x825DDB8C)
	// 825DDB54: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DDB58: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825DDB5C: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DDB60: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DDB64: 5569083E  rotlwi r9, r11, 1
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825DDB68: 811E0018  lwz r8, 0x18(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DDB6C: 80DE0014  lwz r6, 0x14(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825DDB70: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825DDB74: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDB78: 80FE0004  lwz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DDB7C: 7D083214  add r8, r8, r6
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 825DDB80: 8B5FFFFF  lbz r26, -1(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DDB84: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 825DDB88: 48000320  b 0x825ddea8
	pc = 0x825DDEA8; continue 'dispatch;
            }
            0x825DDB8C => {
    //   block [0x825DDB8C..0x825DDBCC)
	// 825DDB8C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DDB90: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825DDB94: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DDB98: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DDB9C: 556B083E  rotlwi r11, r11, 1
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825DDBA0: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825DDBA4: 80FE0008  lwz r7, 8(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDBA8: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825DDBAC: 392BFF01  addi r9, r11, -0xff
	ctx.r[9].s64 = ctx.r[11].s64 + -255;
	// 825DDBB0: 80DE0004  lwz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DDBB4: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DDBB8: 394AFF01  addi r10, r10, -0xff
	ctx.r[10].s64 = ctx.r[10].s64 + -255;
	// 825DDBBC: 8B5FFFFF  lbz r26, -1(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DDBC0: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 825DDBC4: 7D6B3050  subf r11, r11, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 825DDBC8: 480002E0  b 0x825ddea8
	pc = 0x825DDEA8; continue 'dispatch;
            }
            0x825DDBCC => {
    //   block [0x825DDBCC..0x825DDC04)
	// 825DDBCC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DDBD0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825DDBD4: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DDBD8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DDBDC: 5569083E  rotlwi r9, r11, 1
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825DDBE0: 811E0018  lwz r8, 0x18(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DDBE4: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DDBE8: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825DDBEC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDBF0: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDBF4: 7D083214  add r8, r8, r6
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 825DDBF8: 8B5FFFFF  lbz r26, -1(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DDBFC: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 825DDC00: 480002A8  b 0x825ddea8
	pc = 0x825DDEA8; continue 'dispatch;
            }
            0x825DDC04 => {
    //   block [0x825DDC04..0x825DDC44)
	// 825DDC04: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DDC08: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825DDC0C: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DDC10: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DDC14: 556B083E  rotlwi r11, r11, 1
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825DDC18: 811E0010  lwz r8, 0x10(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DDC1C: 80FE0008  lwz r7, 8(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDC20: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825DDC24: 392BFF01  addi r9, r11, -0xff
	ctx.r[9].s64 = ctx.r[11].s64 + -255;
	// 825DDC28: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDC2C: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DDC30: 394AFF01  addi r10, r10, -0xff
	ctx.r[10].s64 = ctx.r[10].s64 + -255;
	// 825DDC34: 8B5FFFFF  lbz r26, -1(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DDC38: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 825DDC3C: 7D6B3050  subf r11, r11, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 825DDC40: 48000268  b 0x825ddea8
	pc = 0x825DDEA8; continue 'dispatch;
            }
            0x825DDC44 => {
    //   block [0x825DDC44..0x825DDC7C)
	// 825DDC44: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DDC48: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825DDC4C: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DDC50: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DDC54: 5569083E  rotlwi r9, r11, 1
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825DDC58: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825DDC5C: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DDC60: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825DDC64: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DDC68: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDC6C: 7D083214  add r8, r8, r6
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 825DDC70: 8B5FFFFF  lbz r26, -1(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DDC74: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 825DDC78: 48000230  b 0x825ddea8
	pc = 0x825DDEA8; continue 'dispatch;
            }
            0x825DDC7C => {
    //   block [0x825DDC7C..0x825DDCBC)
	// 825DDC7C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DDC80: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825DDC84: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DDC88: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DDC8C: 556B083E  rotlwi r11, r11, 1
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825DDC90: 811E0010  lwz r8, 0x10(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DDC94: 80FE0004  lwz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DDC98: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825DDC9C: 392BFF01  addi r9, r11, -0xff
	ctx.r[9].s64 = ctx.r[11].s64 + -255;
	// 825DDCA0: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDCA4: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825DDCA8: 394AFF01  addi r10, r10, -0xff
	ctx.r[10].s64 = ctx.r[10].s64 + -255;
	// 825DDCAC: 8B5FFFFF  lbz r26, -1(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DDCB0: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 825DDCB4: 7D6B3050  subf r11, r11, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 825DDCB8: 480001F0  b 0x825ddea8
	pc = 0x825DDEA8; continue 'dispatch;
            }
            0x825DDCBC => {
    //   block [0x825DDCBC..0x825DDD0C)
	// 825DDCBC: 813E0018  lwz r9, 0x18(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DDCC0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825DDCC4: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825DDCC8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDCCC: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DDCD0: 7D094214  add r8, r9, r8
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825DDCD4: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDCD8: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 825DDCDC: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DDCE0: 88FF0002  lbz r7, 2(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DDCE4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DDCE8: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DDCEC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DDCF0: 5549083E  rotlwi r9, r10, 1
	ctx.r[9].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825DDCF4: 7D083214  add r8, r8, r6
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 825DDCF8: 54E6083E  rotlwi r6, r7, 1
	ctx.r[6].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 825DDCFC: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825DDD00: 8B5FFFFF  lbz r26, -1(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DDD04: 7D473214  add r10, r7, r6
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 825DDD08: 480001A0  b 0x825ddea8
	pc = 0x825DDEA8; continue 'dispatch;
            }
            0x825DDD0C => {
    //   block [0x825DDD0C..0x825DDD64)
	// 825DDD0C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DDD10: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825DDD14: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DDD18: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DDD1C: 394BFFAB  addi r10, r11, -0x55
	ctx.r[10].s64 = ctx.r[11].s64 + -85;
	// 825DDD20: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825DDD24: 38E9FFAB  addi r7, r9, -0x55
	ctx.r[7].s64 = ctx.r[9].s64 + -85;
	// 825DDD28: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDD2C: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DDD30: 809E0018  lwz r4, 0x18(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DDD34: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825DDD38: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDD3C: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 825DDD40: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DDD44: 8B5FFFFF  lbz r26, -1(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DDD48: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DDD4C: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825DDD50: 7D083214  add r8, r8, r6
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 825DDD54: 54E6083C  slwi r6, r7, 1
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 825DDD58: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825DDD5C: 7D473214  add r10, r7, r6
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 825DDD60: 48000148  b 0x825ddea8
	pc = 0x825DDEA8; continue 'dispatch;
            }
            0x825DDD64 => {
    //   block [0x825DDD64..0x825DDDBC)
	// 825DDD64: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DDD68: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825DDD6C: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DDD70: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DDD74: 394BFFAB  addi r10, r11, -0x55
	ctx.r[10].s64 = ctx.r[11].s64 + -85;
	// 825DDD78: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DDD7C: 38E9FFAB  addi r7, r9, -0x55
	ctx.r[7].s64 = ctx.r[9].s64 + -85;
	// 825DDD80: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DDD84: 80BE0008  lwz r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDD88: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825DDD8C: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825DDD90: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDD94: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 825DDD98: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DDD9C: 8B5FFFFF  lbz r26, -1(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DDDA0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DDDA4: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825DDDA8: 7D083214  add r8, r8, r6
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 825DDDAC: 54E6083C  slwi r6, r7, 1
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 825DDDB0: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825DDDB4: 7D473214  add r10, r7, r6
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 825DDDB8: 480000F0  b 0x825ddea8
	pc = 0x825DDEA8; continue 'dispatch;
            }
            0x825DDDBC => {
    //   block [0x825DDDBC..0x825DDE14)
	// 825DDDBC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DDDC0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825DDDC4: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DDDC8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DDDCC: 394BFF56  addi r10, r11, -0xaa
	ctx.r[10].s64 = ctx.r[11].s64 + -170;
	// 825DDDD0: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DDDD4: 38E9FF56  addi r7, r9, -0xaa
	ctx.r[7].s64 = ctx.r[9].s64 + -170;
	// 825DDDD8: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDDDC: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDDE0: 80DE0018  lwz r6, 0x18(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DDDE4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825DDDE8: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DDDEC: 80BE0014  lwz r5, 0x14(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825DDDF0: 7CC64050  subf r6, r6, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[6].s64;
	// 825DDDF4: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825DDDF8: 8B5FFFFF  lbz r26, -1(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DDDFC: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825DDE00: 7D653050  subf r11, r5, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[5].s64;
	// 825DDE04: 54E6083C  slwi r6, r7, 1
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 825DDE08: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825DDE0C: 7D473214  add r10, r7, r6
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 825DDE10: 48000098  b 0x825ddea8
	pc = 0x825DDEA8; continue 'dispatch;
            }
            0x825DDE14 => {
    //   block [0x825DDE14..0x825DDE30)
	// 825DDE14: 390BFFF4  addi r8, r11, -0xc
	ctx.r[8].s64 = ctx.r[11].s64 + -12;
	// 825DDE18: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DDE1C: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DDE20: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 825DDE24: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825DDE28: 7D08F02E  lwzx r8, r8, r30
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DDE2C: 48000020  b 0x825dde4c
	pc = 0x825DDE4C; continue 'dispatch;
            }
            0x825DDE30 => {
    //   block [0x825DDE30..0x825DDE64)
	// 825DDE30: 392BFFE4  addi r9, r11, -0x1c
	ctx.r[9].s64 = ctx.r[11].s64 + -28;
	// 825DDE34: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DDE38: 396BFFE0  addi r11, r11, -0x20
	ctx.r[11].s64 = ctx.r[11].s64 + -32;
	// 825DDE3C: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825DDE40: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 825DDE44: 7D09F02E  lwzx r8, r9, r30
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DDE48: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 825DDE4C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DDE50: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DDE54: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825DDE58: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DDE5C: 8B5FFFFF  lbz r26, -1(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825DDE60: 48000048  b 0x825ddea8
	pc = 0x825DDEA8; continue 'dispatch;
            }
            0x825DDE64 => {
    //   block [0x825DDE64..0x825DDFFC)
	// 825DDE64: 394BFFE1  addi r10, r11, -0x1f
	ctx.r[10].s64 = ctx.r[11].s64 + -31;
	// 825DDE68: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DDE6C: 396BFFDD  addi r11, r11, -0x23
	ctx.r[11].s64 = ctx.r[11].s64 + -35;
	// 825DDE70: 88BF0005  lbz r5, 5(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(5 as u32) ) } as u64;
	// 825DDE74: 5544103A  slwi r4, r10, 2
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 825DDE78: 88DF0004  lbz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DDE7C: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 825DDE80: 88FF0006  lbz r7, 6(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 825DDE84: 5528403E  rotlwi r8, r9, 8
	ctx.r[8].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825DDE88: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DDE8C: 54AB403E  rotlwi r11, r5, 8
	ctx.r[11].u64 = ((ctx.r[5].u32).rotate_left(8)) as u64;
	// 825DDE90: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DDE94: 7FA83214  add r29, r8, r6
	ctx.r[29].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 825DDE98: 7F4B3A14  add r26, r11, r7
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 825DDE9C: 7D04F02E  lwzx r8, r4, r30
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DDEA0: 7D63F02E  lwzx r11, r3, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825DDEA4: 3BFF0007  addi r31, r31, 7
	ctx.r[31].s64 = ctx.r[31].s64 + 7;
	// 825DDEA8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825DDEAC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825DDEB0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825DDEB4: 41990040  bgt cr6, 0x825ddef4
	if ctx.cr[6].gt {
	pc = 0x825DDEF4; continue 'dispatch;
	}
	// 825DDEB8: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825DDEBC: 40980024  bge cr6, 0x825ddee0
	if !ctx.cr[6].lt {
	pc = 0x825DDEE0; continue 'dispatch;
	}
	// 825DDEC0: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 825DDEC4: 7CDDFA14  add r6, r29, r31
	ctx.r[6].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 825DDEC8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825DDECC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825DDED0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DDED4: 4BFFF67D  bl 0x825dd550
	ctx.lr = 0x825DDED8;
	sub_825DD550(ctx, base);
	// 825DDED8: 8B830000  lbz r28, 0(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDEDC: 48000064  b 0x825ddf40
	pc = 0x825DDF40; continue 'dispatch;
	// 825DDEE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DDEE4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 825DDEE8: 99770000  stb r11, 0(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825DDEEC: 38210310  addi r1, r1, 0x310
	ctx.r[1].s64 = ctx.r[1].s64 + 784;
	// 825DDEF0: 4BF57200  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
	// 825DDEF4: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825DDEF8: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 825DDEFC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825DDF00: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825DDF04: 4198000C  blt cr6, 0x825ddf10
	if ctx.cr[6].lt {
	pc = 0x825DDF10; continue 'dispatch;
	}
	// 825DDF08: 38610052  addi r3, r1, 0x52
	ctx.r[3].s64 = ctx.r[1].s64 + 82;
	// 825DDF0C: 48000028  b 0x825ddf34
	pc = 0x825DDF34; continue 'dispatch;
	// 825DDF10: 7CDDFA14  add r6, r29, r31
	ctx.r[6].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 825DDF14: 38610053  addi r3, r1, 0x53
	ctx.r[3].s64 = ctx.r[1].s64 + 83;
	// 825DDF18: 4BFFF639  bl 0x825dd550
	ctx.lr = 0x825DDF1C;
	sub_825DD550(ctx, base);
	// 825DDF1C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825DDF20: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 825DDF24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825DDF28: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825DDF2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DDF30: 8B8B0000  lbz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDF34: 7CDAFA14  add r6, r26, r31
	ctx.r[6].u64 = ctx.r[26].u64 + ctx.r[31].u64;
	// 825DDF38: 4BFFF619  bl 0x825dd550
	ctx.lr = 0x825DDF3C;
	sub_825DD550(ctx, base);
	// 825DDF3C: 8B630000  lbz r27, 0(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDF40: 7F9E0774  extsb r30, r28
	ctx.r[30].s64 = ctx.r[28].s8 as i64;
	// 825DDF44: 7F7C0774  extsb r28, r27
	ctx.r[28].s64 = ctx.r[27].s8 as i64;
	// 825DDF48: 7FCB0034  cntlzw r11, r30
	ctx.r[11].u64 = if ctx.r[30].u32 == 0 { 32 } else { ctx.r[30].u32.leading_zeros() as u64 };
	// 825DDF4C: 7F8A0034  cntlzw r10, r28
	ctx.r[10].u64 = if ctx.r[28].u32 == 0 { 32 } else { ctx.r[28].u32.leading_zeros() as u64 };
	// 825DDF50: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825DDF54: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825DDF58: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 825DDF5C: 7D6B5038  and r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 825DDF60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DDF64: 419A0028  beq cr6, 0x825ddf8c
	if ctx.cr[6].eq {
	pc = 0x825DDF8C; continue 'dispatch;
	}
	// 825DDF68: 81790030  lwz r11, 0x30(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 825DDF6C: 80790044  lwz r3, 0x44(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(68 as u32) ) } as u64;
	// 825DDF70: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DDF74: 7D6BE850  subf r11, r11, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 825DDF78: 7C8BFA14  add r4, r11, r31
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DDF7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDF80: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDF84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DDF88: 4E800421  bctrl
	ctx.lr = 0x825DDF8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DDF8C: 7F8B0034  cntlzw r11, r28
	ctx.r[11].u64 = if ctx.r[28].u32 == 0 { 32 } else { ctx.r[28].u32.leading_zeros() as u64 };
	// 825DDF90: 7FCA0034  cntlzw r10, r30
	ctx.r[10].u64 = if ctx.r[30].u32 == 0 { 32 } else { ctx.r[30].u32.leading_zeros() as u64 };
	// 825DDF94: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825DDF98: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825DDF9C: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 825DDFA0: 7D4B5838  and r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 & ctx.r[11].u64;
	// 825DDFA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DDFA8: 419A0028  beq cr6, 0x825ddfd0
	if ctx.cr[6].eq {
	pc = 0x825DDFD0; continue 'dispatch;
	}
	// 825DDFAC: 81790030  lwz r11, 0x30(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 825DDFB0: 80790044  lwz r3, 0x44(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(68 as u32) ) } as u64;
	// 825DDFB4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DDFB8: 7D6BD050  subf r11, r11, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[11].s64;
	// 825DDFBC: 7C8BFA14  add r4, r11, r31
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825DDFC0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DDFC4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DDFC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DDFCC: 4E800421  bctrl
	ctx.lr = 0x825DDFD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DDFD0: 7FCB0034  cntlzw r11, r30
	ctx.r[11].u64 = if ctx.r[30].u32 == 0 { 32 } else { ctx.r[30].u32.leading_zeros() as u64 };
	// 825DDFD4: 7F8A0034  cntlzw r10, r28
	ctx.r[10].u64 = if ctx.r[28].u32 == 0 { 32 } else { ctx.r[28].u32.leading_zeros() as u64 };
	// 825DDFD8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825DDFDC: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825DDFE0: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 825DDFE4: 694A0001  xori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 ^ 1;
	// 825DDFE8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 825DDFEC: 7D6B5038  and r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 825DDFF0: 99770000  stb r11, 0(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825DDFF4: 38210310  addi r1, r1, 0x310
	ctx.r[1].s64 = ctx.r[1].s64 + 784;
	// 825DDFF8: 4BF570F8  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x825DDFFC => {
    //   block [0x825DDFFC..0x825DE004)
	// 825DDFFC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DE000: 48000068  b 0x825de068
	pc = 0x825DE068; continue 'dispatch;
            }
            0x825DE004 => {
    //   block [0x825DE004..0x825DE018)
	// 825DE004: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DE008: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DE00C: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DE010: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DE014: 48000054  b 0x825de068
	pc = 0x825DE068; continue 'dispatch;
            }
            0x825DE018 => {
    //   block [0x825DE018..0x825DE038)
	// 825DE018: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DE01C: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DE020: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DE024: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DE028: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DE02C: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DE030: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DE034: 48000034  b 0x825de068
	pc = 0x825DE068; continue 'dispatch;
            }
            0x825DE038 => {
    //   block [0x825DE038..0x825DE064)
	// 825DE038: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825DE03C: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825DE040: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825DE044: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825DE048: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DE04C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825DE050: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DE054: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825DE058: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DE05C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DE060: 48000008  b 0x825de068
	pc = 0x825DE068; continue 'dispatch;
            }
            0x825DE064 => {
    //   block [0x825DE064..0x825DE0A4)
	// 825DE064: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 825DE068: 81190048  lwz r8, 0x48(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(72 as u32) ) } as u64;
	// 825DE06C: 5709402E  slwi r9, r24, 8
	ctx.r[9].u32 = ctx.r[24].u32.wrapping_shl(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825DE070: 815E002C  lwz r10, 0x2c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 825DE074: 38DE0034  addi r6, r30, 0x34
	ctx.r[6].s64 = ctx.r[30].s64 + 52;
	// 825DE078: 80990044  lwz r4, 0x44(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(68 as u32) ) } as u64;
	// 825DE07C: 7D094838  and r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 825DE080: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825DE084: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 825DE088: 7D255B78  or r5, r9, r11
	ctx.r[5].u64 = ctx.r[9].u64 | ctx.r[11].u64;
	// 825DE08C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE090: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DE094: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DE098: 4E800421  bctrl
	ctx.lr = 0x825DE09C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DE09C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE0A0: 99790040  stb r11, 0x40(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
            }
            0x825DE0A4 => {
    //   block [0x825DE0A4..0x825DE0B8)
	// 825DE0A4: 89790040  lbz r11, 0x40(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(64 as u32) ) } as u64;
	// 825DE0A8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 825DE0AC: 99770000  stb r11, 0(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825DE0B0: 38210310  addi r1, r1, 0x310
	ctx.r[1].s64 = ctx.r[1].s64 + 784;
	// 825DE0B4: 4BF5703C  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE0B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DE0B8 size=536
    let mut pc: u32 = 0x825DE0B8;
    'dispatch: loop {
        match pc {
            0x825DE0B8 => {
    //   block [0x825DE0B8..0x825DE2D0)
	// 825DE0B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE0BC: 4BF56FF9  bl 0x825350b4
	ctx.lr = 0x825DE0C0;
	sub_82535080(ctx, base);
	// 825DE0C0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE0C4: 3FC0829A  lis r30, -0x7d66
	ctx.r[30].s64 = -2103836672;
	// 825DE0C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE0CC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DE0D0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825DE0D4: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825DE0D8: 897E3E8A  lbz r11, 0x3e8a(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(16010 as u32) ) } as u64;
	// 825DE0DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DE0E0: 409A001C  bne cr6, 0x825de0fc
	if !ctx.cr[6].eq {
	pc = 0x825DE0FC; continue 'dispatch;
	}
	// 825DE0E4: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825DE0E8: 4BF1B059  bl 0x824f9140
	ctx.lr = 0x825DE0EC;
	sub_824F9140(ctx, base);
	// 825DE0EC: 7C6B0774  extsb r11, r3
	ctx.r[11].s64 = ctx.r[3].s8 as i64;
	// 825DE0F0: 987E3E8A  stb r3, 0x3e8a(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(16010 as u32), ctx.r[3].u8 ) };
	// 825DE0F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DE0F8: 419A01D0  beq cr6, 0x825de2c8
	if ctx.cr[6].eq {
	pc = 0x825DE2C8; continue 'dispatch;
	}
	// 825DE0FC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825DE100: 93BF0030  stw r29, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[29].u32 ) };
	// 825DE104: 937F0044  stw r27, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[27].u32 ) };
	// 825DE108: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 825DE10C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825DE110: C1BD0010  lfs f13, 0x10(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DE114: C19C0000  lfs f12, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825DE118: ED8C6828  fsubs f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 825DE11C: C01D001C  lfs f0, 0x1c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DE120: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 825DE124: FD80601E  fctiwz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 825DE128: 7D805FAE  stfiwx f12, 0, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 825DE12C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DE130: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 825DE134: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825DE138: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 825DE13C: C19C0010  lfs f12, 0x10(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825DE140: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 825DE144: A13F0020  lhz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DE148: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825DE14C: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 825DE150: 7DA057AE  stfiwx f13, 0, r10
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 825DE154: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DE158: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 825DE15C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DE160: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825DE164: C1BD0014  lfs f13, 0x14(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DE168: C19C0004  lfs f12, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825DE16C: A17F0010  lhz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DE170: ED8C6828  fsubs f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 825DE174: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 825DE178: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DE17C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 825DE180: FD80601E  fctiwz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 825DE184: 7D8057AE  stfiwx f12, 0, r10
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 825DE188: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DE18C: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 825DE190: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 825DE194: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 825DE198: C19C0014  lfs f12, 0x14(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825DE19C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 825DE1A0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825DE1A4: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 825DE1A8: 7DA047AE  stfiwx f13, 0, r8
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 825DE1AC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DE1B0: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 825DE1B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825DE1B8: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 825DE1BC: C1BD0018  lfs f13, 0x18(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DE1C0: C19C0008  lfs f12, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825DE1C4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825DE1C8: ED8C6828  fsubs f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 825DE1CC: 7D2A0734  extsh r10, r9
	ctx.r[10].s64 = ctx.r[9].s16 as i64;
	// 825DE1D0: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 825DE1D4: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 825DE1D8: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 825DE1DC: FD80601E  fctiwz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 825DE1E0: 7D8047AE  stfiwx f12, 0, r8
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 825DE1E4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DE1E8: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 825DE1EC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825DE1F0: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 825DE1F4: C19C0018  lfs f12, 0x18(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825DE1F8: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 825DE1FC: A13F0028  lhz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 825DE200: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825DE204: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 825DE208: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 825DE20C: A15F0024  lhz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 825DE210: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 825DE214: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 825DE218: A15F0014  lhz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825DE21C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DE220: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DE224: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 825DE228: 7D6B8670  srawi r11, r11, 0x10
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 16) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 16) as i64;
	// 825DE22C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DE230: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825DE234: 7D4B0734  extsh r11, r10
	ctx.r[11].s64 = ctx.r[10].s16 as i64;
	// 825DE238: 7D2A0734  extsh r10, r9
	ctx.r[10].s64 = ctx.r[9].s16 as i64;
	// 825DE23C: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 825DE240: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DE244: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 825DE248: 93C10088  stw r30, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 825DE24C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825DE250: 93C1008C  stw r30, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 825DE254: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825DE258: 93C10090  stw r30, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[30].u32 ) };
	// 825DE25C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DE260: 93C10094  stw r30, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 825DE264: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DE268: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825DE26C: 80DD0020  lwz r6, 0x20(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DE270: 89660000  lbz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE274: 396BFFF3  addi r11, r11, -0xd
	ctx.r[11].s64 = ctx.r[11].s64 + -13;
	// 825DE278: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825DE27C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825DE280: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 825DE284: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 825DE288: 4BFFF2C9  bl 0x825dd550
	ctx.lr = 0x825DE28C;
	sub_825DD550(ctx, base);
	// 825DE28C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DE290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DE294: 419A0034  beq cr6, 0x825de2c8
	if ctx.cr[6].eq {
	pc = 0x825DE2C8; continue 'dispatch;
	}
	// 825DE298: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 825DE29C: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 825DE2A0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DE2A4: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE2A8: 2B0B000D  cmplwi cr6, r11, 0xd
	ctx.cr[6].compare_u32(ctx.r[11].u32, 13 as u32, &mut ctx.xer);
	// 825DE2AC: 419A0008  beq cr6, 0x825de2b4
	if ctx.cr[6].eq {
	pc = 0x825DE2B4; continue 'dispatch;
	}
	// 825DE2B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DE2B4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE2B8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825DE2BC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DE2C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DE2C4: 4E800421  bctrl
	ctx.lr = 0x825DE2C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DE2C8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825DE2CC: 4BF56E38  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DE2D0 size=4
    let mut pc: u32 = 0x825DE2D0;
    'dispatch: loop {
        match pc {
            0x825DE2D0 => {
    //   block [0x825DE2D0..0x825DE2D4)
	// 825DE2D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE2D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825DE2D8 size=52
    let mut pc: u32 = 0x825DE2D8;
    'dispatch: loop {
        match pc {
            0x825DE2D8 => {
    //   block [0x825DE2D8..0x825DE30C)
	// 825DE2D8: 3D603E39  lis r11, 0x3e39
	ctx.r[11].s64 = 1043922944;
	// 825DE2DC: 616BB193  ori r11, r11, 0xb193
	ctx.r[11].u64 = ctx.r[11].u64 | 45459;
	// 825DE2E0: 7D6359D6  mullw r11, r3, r11
	ctx.r[11].s64 = (ctx.r[3].s32 as i64) * (ctx.r[11].s32 as i64);
	// 825DE2E4: 216B3039  subfic r11, r11, 0x3039
	ctx.xer.ca = ctx.r[11].u32 <= 12345 as u32;
	ctx.r[11].s64 = (12345 as i64) - ctx.r[11].s64;
	// 825DE2E8: 556B007E  clrlwi r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 825DE2EC: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 825DE2F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825DE2F4: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DE2F8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825DE2FC: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825DE300: C00B2A78  lfs f0, 0x2a78(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10872 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DE304: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825DE308: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DE310 size=4
    let mut pc: u32 = 0x825DE310;
    'dispatch: loop {
        match pc {
            0x825DE310 => {
    //   block [0x825DE310..0x825DE314)
	// 825DE310: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825DE318 size=92
    let mut pc: u32 = 0x825DE318;
    'dispatch: loop {
        match pc {
            0x825DE318 => {
    //   block [0x825DE318..0x825DE374)
	// 825DE318: 3D603E39  lis r11, 0x3e39
	ctx.r[11].s64 = 1043922944;
	// 825DE31C: EC020828  fsubs f0, f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[2].f64 - ctx.f[1].f64) as f32) as f64);
	// 825DE320: 616BB193  ori r11, r11, 0xb193
	ctx.r[11].u64 = ctx.r[11].u64 | 45459;
	// 825DE324: 7D6359D6  mullw r11, r3, r11
	ctx.r[11].s64 = (ctx.r[3].s32 as i64) * (ctx.r[11].s32 as i64);
	// 825DE328: 216B3039  subfic r11, r11, 0x3039
	ctx.xer.ca = ctx.r[11].u32 <= 12345 as u32;
	ctx.r[11].s64 = (12345 as i64) - ctx.r[11].s64;
	// 825DE32C: 556B007E  clrlwi r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 825DE330: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 825DE334: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825DE338: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DE33C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825DE340: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825DE344: C1AB2A78  lfs f13, 0x2a78(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10872 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DE348: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 825DE34C: ED8D082A  fadds f12, f13, f1
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64;
	// 825DE350: ED6D082A  fadds f11, f13, f1
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64;
	// 825DE354: EDAD082A  fadds f13, f13, f1
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64;
	// 825DE358: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 825DE35C: D1860000  stfs f12, 0(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825DE360: ED8B0032  fmuls f12, f11, f0
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 825DE364: D1860004  stfs f12, 4(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825DE368: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825DE36C: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825DE370: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE378 size=240
    let mut pc: u32 = 0x825DE378;
    'dispatch: loop {
        match pc {
            0x825DE378 => {
    //   block [0x825DE378..0x825DE468)
	// 825DE378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE37C: 4BF56D31  bl 0x825350ac
	ctx.lr = 0x825DE380;
	sub_82535080(ctx, base);
	// 825DE380: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE384: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE388: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825DE38C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DE390: 3B9E0010  addi r28, r30, 0x10
	ctx.r[28].s64 = ctx.r[30].s64 + 16;
	// 825DE394: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DE398: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825DE39C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DE3A0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825DE3A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DE3A8: 4E800421  bctrl
	ctx.lr = 0x825DE3AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DE3AC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DE468 size=64
    let mut pc: u32 = 0x825DE468;
    'dispatch: loop {
        match pc {
            0x825DE468 => {
    //   block [0x825DE468..0x825DE4A8)
	// 825DE468: 8143006C  lwz r10, 0x6c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE4A8 size=304
    let mut pc: u32 = 0x825DE4A8;
    'dispatch: loop {
        match pc {
            0x825DE4A8 => {
    //   block [0x825DE4A8..0x825DE5D8)
	// 825DE4A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE4AC: 4BF56C11  bl 0x825350bc
	ctx.lr = 0x825DE4B0;
	sub_82535080(ctx, base);
	// 825DE4B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE4B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DE4B8: 1100038C  vspltisw v8, 0
	for i in 0..4 {
		ctx.v[8].u32[i] = 0;
	}
	// 825DE4BC: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825DE4C0: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825DE4C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825DE4C8: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 825DE4CC: 396B9F50  addi r11, r11, -0x60b0
	ctx.r[11].s64 = ctx.r[11].s64 + -24752;
	// 825DE4D0: 81440010  lwz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DE5D8 size=404
    let mut pc: u32 = 0x825DE5D8;
    'dispatch: loop {
        match pc {
            0x825DE5D8 => {
    //   block [0x825DE5D8..0x825DE76C)
	// 825DE5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE5DC: 4BF56ACD  bl 0x825350a8
	ctx.lr = 0x825DE5E0;
	sub_82535080(ctx, base);
	// 825DE5E0: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 825DE5E4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE5E8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825DE5EC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825DE5F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE5F4: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 825DE5F8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825DE5FC: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825DE600: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825DE604: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 825DE608: 3B4B9F50  addi r26, r11, -0x60b0
	ctx.r[26].s64 = ctx.r[11].s64 + -24752;
	// 825DE60C: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 825DE610: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 825DE614: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DE618: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825DE61C: 815F0068  lwz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 825DE620: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DE770 size=228
    let mut pc: u32 = 0x825DE770;
    'dispatch: loop {
        match pc {
            0x825DE770 => {
    //   block [0x825DE770..0x825DE854)
	// 825DE770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE774: 4BF56941  bl 0x825350b4
	ctx.lr = 0x825DE778;
	sub_82535080(ctx, base);
	// 825DE778: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE77C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825DE780: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DE784: 396BFA60  addi r11, r11, -0x5a0
	ctx.r[11].s64 = ctx.r[11].s64 + -1440;
	// 825DE788: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825DE78C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825DE790: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DE858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DE858 size=2304
    let mut pc: u32 = 0x825DE858;
    'dispatch: loop {
        match pc {
            0x825DE858 => {
    //   block [0x825DE858..0x825DE8F4)
	// 825DE858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DE85C: 4BF5682D  bl 0x82535088
	ctx.lr = 0x825DE860;
	sub_82535080(ctx, base);
	// 825DE860: DBC1FF68  stfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[30].u64 ) };
	// 825DE864: DBE1FF70  stfd f31, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 825DE868: 9421FC70  stwu r1, -0x390(r1)
	ea = ctx.r[1].u32.wrapping_add(-912 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DE86C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DE870: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825DE874: 7CB02B78  mr r16, r5
	ctx.r[16].u64 = ctx.r[5].u64;
	// 825DE878: 3B60FFFF  li r27, -1
	ctx.r[27].s64 = -1;
	// 825DE87C: 3B9F006C  addi r28, r31, 0x6c
	ctx.r[28].s64 = ctx.r[31].s64 + 108;
	// 825DE880: 811F006C  lwz r8, 0x6c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 825DE884: 2B080004  cmplwi cr6, r8, 4
	ctx.cr[6].compare_u32(ctx.r[8].u32, 4 as u32, &mut ctx.xer);
	// 825DE888: 419908B4  bgt cr6, 0x825df13c
	if ctx.cr[6].gt {
	pc = 0x825DF13C; continue 'dispatch;
	}
	// 825DE88C: 3D608283  lis r11, -0x7d7d
	ctx.r[11].s64 = -2105344000;
	// 825DE890: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825DE894: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825DE898: 3A6B2690  addi r19, r11, 0x2690
	ctx.r[19].s64 = ctx.r[11].s64 + 9872;
	// 825DE89C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825DE8A0: 3B200010  li r25, 0x10
	ctx.r[25].s64 = 16;
	// 825DE8A4: C3C91850  lfs f30, 0x1850(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6224 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825DE8A8: 3B0BFA60  addi r24, r11, -0x5a0
	ctx.r[24].s64 = ctx.r[11].s64 + -1440;
	// 825DE8AC: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825DE8B0: 3AA00020  li r21, 0x20
	ctx.r[21].s64 = 32;
	// 825DE8B4: 3A200030  li r17, 0x30
	ctx.r[17].s64 = 48;
	// 825DE8B8: 3A400003  li r18, 3
	ctx.r[18].s64 = 3;
	// 825DE8BC: 3A800002  li r20, 2
	ctx.r[20].s64 = 2;
	// 825DE8C0: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 825DE8C4: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 825DE8C8: 3D80825E  lis r12, -0x7da2
	ctx.r[12].s64 = -2107768832;
	// 825DE8CC: 398CE8E0  addi r12, r12, -0x1720
	ctx.r[12].s64 = ctx.r[12].s64 + -5920;
	// 825DE8D0: 5500103A  slwi r0, r8, 2
	ctx.r[0].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825DE8D4: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825DE8D8: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825DE8DC: 4E800420  bctr
	match ctx.r[8].u64 {
		0 => {
	pc = 0x825DEA44; continue 'dispatch;
		},
		1 => {
	pc = 0x825DEA14; continue 'dispatch;
		},
		2 => {
	pc = 0x825DE9DC; continue 'dispatch;
		},
		3 => {
	pc = 0x825DE97C; continue 'dispatch;
		},
		4 => {
	pc = 0x825DE8F4; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825DE8E0: 825DEA44  lwz r18, -0x15bc(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-5564 as u32) ) } as u64;
	// 825DE8E4: 825DEA14  lwz r18, -0x15ec(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-5612 as u32) ) } as u64;
	// 825DE8E8: 825DE9DC  lwz r18, -0x1624(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-5668 as u32) ) } as u64;
	// 825DE8EC: 825DE97C  lwz r18, -0x1684(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-5764 as u32) ) } as u64;
	// 825DE8F0: 825DE8F4  lwz r18, -0x170c(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-5900 as u32) ) } as u64;
            }
            0x825DE8F4 => {
    //   block [0x825DE8F4..0x825DE97C)
	// 825DE8F4: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 825DE8F8: 390100D0  addi r8, r1, 0xd0
	ctx.r[8].s64 = ctx.r[1].s64 + 208;
	// 825DE8FC: 39410074  addi r10, r1, 0x74
	ctx.r[10].s64 = ctx.r[1].s64 + 116;
	// 825DE900: 3921008C  addi r9, r1, 0x8c
	ctx.r[9].s64 = ctx.r[1].s64 + 140;
	pc = 0x825DE97C; continue 'dispatch;
            }
            0x825DE97C => {
    //   block [0x825DE97C..0x825DE9DC)
	// 825DE97C: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 825DE980: 3941007C  addi r10, r1, 0x7c
	ctx.r[10].s64 = ctx.r[1].s64 + 124;
	pc = 0x825DE9DC; continue 'dispatch;
            }
            0x825DE9DC => {
    //   block [0x825DE9DC..0x825DEA14)
	// 825DE9DC: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 825DE9E0: 39410084  addi r10, r1, 0x84
	ctx.r[10].s64 = ctx.r[1].s64 + 132;
	pc = 0x825DEA14; continue 'dispatch;
            }
            0x825DEA14 => {
    //   block [0x825DEA14..0x825DEA44)
	// 825DEA14: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 825DEA18: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	pc = 0x825DEA44; continue 'dispatch;
            }
            0x825DEA44 => {
    //   block [0x825DEA44..0x825DF158)
	// 825DEA44: 397F0030  addi r11, r31, 0x30
	ctx.r[11].s64 = ctx.r[31].s64 + 48;
	// 825DEA48: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 825DEA4C: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DF158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DF158 size=552
    let mut pc: u32 = 0x825DF158;
    'dispatch: loop {
        match pc {
            0x825DF158 => {
    //   block [0x825DF158..0x825DF380)
	// 825DF158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DF15C: 4BF55F4D  bl 0x825350a8
	ctx.lr = 0x825DF160;
	sub_82535080(ctx, base);
	// 825DF160: DBA1FFA0  stfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[29].u64 ) };
	// 825DF164: DBC1FFA8  stfd f30, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 825DF168: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 825DF16C: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 825DF170: E981E000  ld r12, -0x2000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8192 as u32) ) };
	// 825DF174: 9421D070  stwu r1, -0x2f90(r1)
	ea = ctx.r[1].u32.wrapping_add(-12176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DF178: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 825DF17C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825DF180: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825DF184: 3D003E39  lis r8, 0x3e39
	ctx.r[8].s64 = 1043922944;
	// 825DF188: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DF18C: C3C968E8  lfs f30, 0x68e8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(26856 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825DF190: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 825DF194: C3EA20AC  lfs f31, 0x20ac(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8364 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825DF198: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825DF19C: C3AB2A78  lfs f29, 0x2a78(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10872 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825DF1A0: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 825DF1A4: 611AB193  ori r26, r8, 0xb193
	ctx.r[26].u64 = ctx.r[8].u64 | 45459;
	// 825DF1A8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DF1AC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825DF1B0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825DF1B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF1B8: 4BFFF6A1  bl 0x825de858
	ctx.lr = 0x825DF1BC;
	sub_825DE858(ctx, base);
	// 825DF1BC: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 825DF1C0: 409A0014  bne cr6, 0x825df1d4
	if !ctx.cr[6].eq {
	pc = 0x825DF1D4; continue 'dispatch;
	}
	// 825DF1C4: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DF1C8: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 825DF1CC: 409A019C  bne cr6, 0x825df368
	if !ctx.cr[6].eq {
	pc = 0x825DF368; continue 'dispatch;
	}
	// 825DF1D0: 480000F0  b 0x825df2c0
	pc = 0x825DF2C0; continue 'dispatch;
	// 825DF1D4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825DF1D8: 80DF0068  lwz r6, 0x68(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 825DF1DC: 80BF0064  lwz r5, 0x64(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 825DF1E0: 809F0060  lwz r4, 0x60(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 825DF1E4: 48000735  bl 0x825df918
	ctx.lr = 0x825DF1E8;
	sub_825DF918(ctx, base);
	// 825DF1E8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825DF1EC: 480008CD  bl 0x825dfab8
	ctx.lr = 0x825DF1F0;
	sub_825DFAB8(ctx, base);
	// 825DF1F0: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 825DF1F4: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 825DF1F8: 556A3032  slwi r10, r11, 6
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825DF1FC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825DF200: 7FCA4A14  add r30, r10, r9
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825DF204: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825DF208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF20C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DF210: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825DF214: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 825DF218: 937E0030  stw r27, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[27].u32 ) };
	// 825DF21C: 4BFFF15D  bl 0x825de378
	ctx.lr = 0x825DF220;
	sub_825DE378(ctx, base);
	// 825DF220: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825DF224: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825DF228: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825DF22C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825DF230: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF234: 4BFFF275  bl 0x825de4a8
	ctx.lr = 0x825DF238;
	sub_825DE4A8(ctx, base);
	// 825DF238: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 825DF23C: 419A0078  beq cr6, 0x825df2b4
	if ctx.cr[6].eq {
	pc = 0x825DF2B4; continue 'dispatch;
	}
	// 825DF240: 83810088  lwz r28, 0x88(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 825DF244: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 825DF248: 2F1C0037  cmpwi cr6, r28, 0x37
	ctx.cr[6].compare_i32(ctx.r[28].s32, 55, &mut ctx.xer);
	// 825DF24C: 41980008  blt cr6, 0x825df254
	if ctx.cr[6].lt {
	pc = 0x825DF254; continue 'dispatch;
	}
	// 825DF250: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 825DF254: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825DF258: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DF25C: 419A00F4  beq cr6, 0x825df350
	if ctx.cr[6].eq {
	pc = 0x825DF350; continue 'dispatch;
	}
	// 825DF260: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825DF264: 48000855  bl 0x825dfab8
	ctx.lr = 0x825DF268;
	sub_825DFAB8(ctx, base);
	// 825DF268: 578B3032  slwi r11, r28, 6
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DF26C: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 825DF270: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825DF274: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825DF278: 397C0001  addi r11, r28, 1
	ctx.r[11].s64 = ctx.r[28].s64 + 1;
	// 825DF27C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF280: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DF284: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825DF288: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 825DF28C: 937E0030  stw r27, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[27].u32 ) };
	// 825DF290: 4BFFF0E9  bl 0x825de378
	ctx.lr = 0x825DF294;
	sub_825DE378(ctx, base);
	// 825DF294: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825DF298: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825DF29C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825DF2A0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825DF2A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DF2A8: 4BFFF201  bl 0x825de4a8
	ctx.lr = 0x825DF2AC;
	sub_825DE4A8(ctx, base);
	// 825DF2AC: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 825DF2B0: 409AFF90  bne cr6, 0x825df240
	if !ctx.cr[6].eq {
	pc = 0x825DF240; continue 'dispatch;
	}
	// 825DF2B4: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DF2B8: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 825DF2BC: 409A0098  bne cr6, 0x825df354
	if !ctx.cr[6].eq {
	pc = 0x825DF354; continue 'dispatch;
	}
	// 825DF2C0: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 825DF2C4: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 825DF2C8: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 825DF2CC: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825DF2D0: 409A000C  bne cr6, 0x825df2dc
	if !ctx.cr[6].eq {
	pc = 0x825DF2DC; continue 'dispatch;
	}
	// 825DF2D4: 933F006C  stw r25, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[25].u32 ) };
	// 825DF2D8: 4BFFFED0  b 0x825df1a8
	pc = 0x825DF1A8; continue 'dispatch;
	// 825DF2DC: 2F0A0014  cmpwi cr6, r10, 0x14
	ctx.cr[6].compare_i32(ctx.r[10].s32, 20, &mut ctx.xer);
	// 825DF2E0: 40980088  bge cr6, 0x825df368
	if !ctx.cr[6].lt {
	pc = 0x825DF368; continue 'dispatch;
	}
	// 825DF2E4: 7D4AD1D6  mullw r10, r10, r26
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[26].s32 as i64);
	// 825DF2E8: 937F006C  stw r27, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 825DF2EC: 214A3039  subfic r10, r10, 0x3039
	ctx.xer.ca = ctx.r[10].u32 <= 12345 as u32;
	ctx.r[10].s64 = (12345 as i64) - ctx.r[10].s64;
	// 825DF2F0: 397F0030  addi r11, r31, 0x30
	ctx.r[11].s64 = ctx.r[31].s64 + 48;
	// 825DF2F4: 554A007E  clrlwi r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x7FFFFFFFu64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DF380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DF380 size=324
    let mut pc: u32 = 0x825DF380;
    'dispatch: loop {
        match pc {
            0x825DF380 => {
    //   block [0x825DF380..0x825DF4C4)
	// 825DF380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DF384: 4BF55D25  bl 0x825350a8
	ctx.lr = 0x825DF388;
	sub_82535080(ctx, base);
	// 825DF388: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DF38C: 830D0000  lwz r24, 0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DF390: 3B200014  li r25, 0x14
	ctx.r[25].s64 = 20;
	// 825DF394: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 825DF398: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 825DF39C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DF3A0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DF3A4: 7D79C02E  lwzx r11, r25, r24
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 825DF3A8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DF3AC: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DF3B0: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DF3B4: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825DF3B8: 40980020  bge cr6, 0x825df3d8
	if !ctx.cr[6].lt {
	pc = 0x825DF3D8; continue 'dispatch;
	}
	// 825DF3BC: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 825DF3C0: 38E7A6E4  addi r7, r7, -0x591c
	ctx.r[7].s64 = ctx.r[7].s64 + -22812;
	// 825DF3C4: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825DF3C8: 7CEC42E6  mftb r7, 0x10c
	ctx.r[7].u64 = crate::rt::rdtsc_u64();
	// 825DF3CC: 38C8000C  addi r6, r8, 0xc
	ctx.r[6].s64 = ctx.r[8].s64 + 12;
	// 825DF3D0: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825DF3D4: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825DF3D8: D0210090  stfs f1, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 825DF3DC: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 825DF3E0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DF4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DF4C8 size=1100
    let mut pc: u32 = 0x825DF4C8;
    'dispatch: loop {
        match pc {
            0x825DF4C8 => {
    //   block [0x825DF4C8..0x825DF914)
	// 825DF4C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DF4CC: 4BF55BB5  bl 0x82535080
	ctx.lr = 0x825DF4D0;
	sub_82535080(ctx, base);
	// 825DF4D0: DBC1FF58  stfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 825DF4D4: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 825DF4D8: 3980FF20  li r12, -0xe0
	ctx.r[12].s64 = -224;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DF918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DF918 size=140
    let mut pc: u32 = 0x825DF918;
    'dispatch: loop {
        match pc {
            0x825DF918 => {
    //   block [0x825DF918..0x825DF9A4)
	// 825DF918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DF91C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DF920: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DF924: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DF928: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DF92C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DF930: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 825DF934: 397E0020  addi r11, r30, 0x20
	ctx.r[11].s64 = ctx.r[30].s64 + 32;
	// 825DF938: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 825DF93C: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 825DF940: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DF944: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DF9A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DF9A8 size=72
    let mut pc: u32 = 0x825DF9A8;
    'dispatch: loop {
        match pc {
            0x825DF9A8 => {
    //   block [0x825DF9A8..0x825DF9F0)
	// 825DF9A8: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DF9F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825DF9F0 size=44
    let mut pc: u32 = 0x825DF9F0;
    'dispatch: loop {
        match pc {
            0x825DF9F0 => {
    //   block [0x825DF9F0..0x825DFA1C)
	// 825DF9F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825DF9F4: C00BA6E0  lfs f0, -0x5920(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22816 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DF9F8: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 825DF9FC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825DFA00: 40990008  ble cr6, 0x825dfa08
	if !ctx.cr[6].gt {
	pc = 0x825DFA08; continue 'dispatch;
	}
	// 825DFA04: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825DFA08: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 825DFA0C: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DFA10: C1A60000  lfs f13, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DFA14: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825DFA18: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFA1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DFA1C size=8
    let mut pc: u32 = 0x825DFA1C;
    'dispatch: loop {
        match pc {
            0x825DFA1C => {
    //   block [0x825DFA1C..0x825DFA24)
	// 825DFA1C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825DFA20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DFA28 size=144
    let mut pc: u32 = 0x825DFA28;
    'dispatch: loop {
        match pc {
            0x825DFA28 => {
    //   block [0x825DFA28..0x825DFAB8)
	// 825DFA28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DFA2C: 4BF55689  bl 0x825350b4
	ctx.lr = 0x825DFA30;
	sub_82535080(ctx, base);
	// 825DFA30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DFA34: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825DFA38: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825DFA3C: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 825DFA40: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825DFA44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DFA48: C00BA6E0  lfs f0, -0x5920(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22816 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DFA4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825DFA50: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DFA54: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825DFA58: 915B0000  stw r10, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DFA5C: 38DF0004  addi r6, r31, 4
	ctx.r[6].s64 = ctx.r[31].s64 + 4;
	// 825DFA60: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DFA64: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DFA68: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825DFA6C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DFA70: C1AB8CB4  lfs f13, -0x734c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DFA74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DFA78: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825DFA7C: 4BFFFF2D  bl 0x825df9a8
	ctx.lr = 0x825DFA80;
	sub_825DF9A8(ctx, base);
	// 825DFA80: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 825DFA84: 907E0044  stw r3, 0x44(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(68 as u32), ctx.r[3].u32 ) };
	// 825DFA88: 409A0024  bne cr6, 0x825dfaac
	if !ctx.cr[6].eq {
	pc = 0x825DFAAC; continue 'dispatch;
	}
	// 825DFA8C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825DFA90: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825DFA94: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825DFA98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DFA9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DFAA0: 48000981  bl 0x825e0420
	ctx.lr = 0x825DFAA4;
	sub_825E0420(ctx, base);
	// 825DFAA4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DFAA8: 4BF5565C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
	// 825DFAAC: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 825DFAB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DFAB4: 4BF55650  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFAB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825DFAB8 size=148
    let mut pc: u32 = 0x825DFAB8;
    'dispatch: loop {
        match pc {
            0x825DFAB8 => {
    //   block [0x825DFAB8..0x825DFB4C)
	// 825DFAB8: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DFABC: 39630F70  addi r11, r3, 0xf70
	ctx.r[11].s64 = ctx.r[3].s64 + 3952;
	// 825DFAC0: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 825DFAC4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825DFAC8: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 825DFACC: C00B0040  lfs f0, 0x40(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DFAD0: 2F090004  cmpwi cr6, r9, 4
	ctx.cr[6].compare_i32(ctx.r[9].s32, 4, &mut ctx.xer);
	// 825DFAD4: 41980070  blt cr6, 0x825dfb44
	if ctx.cr[6].lt {
	pc = 0x825DFB44; continue 'dispatch;
	}
	// 825DFAD8: 5529F0BE  srwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825DFADC: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825DFAE0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825DFAE4: C1AB0090  lfs f13, 0x90(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DFAE8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825DFAEC: 4098000C  bge cr6, 0x825dfaf8
	if !ctx.cr[6].lt {
	pc = 0x825DFAF8; continue 'dispatch;
	}
	// 825DFAF0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 825DFAF4: 386B0050  addi r3, r11, 0x50
	ctx.r[3].s64 = ctx.r[11].s64 + 80;
	// 825DFAF8: C1AB00E0  lfs f13, 0xe0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DFAFC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825DFB00: 4098000C  bge cr6, 0x825dfb0c
	if !ctx.cr[6].lt {
	pc = 0x825DFB0C; continue 'dispatch;
	}
	// 825DFB04: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 825DFB08: 386B00A0  addi r3, r11, 0xa0
	ctx.r[3].s64 = ctx.r[11].s64 + 160;
	// 825DFB0C: C1AB0130  lfs f13, 0x130(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DFB10: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825DFB14: 4098000C  bge cr6, 0x825dfb20
	if !ctx.cr[6].lt {
	pc = 0x825DFB20; continue 'dispatch;
	}
	// 825DFB18: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 825DFB1C: 386B00F0  addi r3, r11, 0xf0
	ctx.r[3].s64 = ctx.r[11].s64 + 240;
	// 825DFB20: C1AB0180  lfs f13, 0x180(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(384 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DFB24: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825DFB28: 4098000C  bge cr6, 0x825dfb34
	if !ctx.cr[6].lt {
	pc = 0x825DFB34; continue 'dispatch;
	}
	// 825DFB2C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 825DFB30: 386B0140  addi r3, r11, 0x140
	ctx.r[3].s64 = ctx.r[11].s64 + 320;
	// 825DFB34: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825DFB38: 396B0140  addi r11, r11, 0x140
	ctx.r[11].s64 = ctx.r[11].s64 + 320;
	// 825DFB3C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825DFB40: 409AFFA4  bne cr6, 0x825dfae4
	if !ctx.cr[6].eq {
	pc = 0x825DFAE4; continue 'dispatch;
	}
	// 825DFB44: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825DFB48: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFB4C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825DFB4C size=40
    let mut pc: u32 = 0x825DFB4C;
    'dispatch: loop {
        match pc {
            0x825DFB4C => {
    //   block [0x825DFB4C..0x825DFB74)
	// 825DFB4C: 396B0050  addi r11, r11, 0x50
	ctx.r[11].s64 = ctx.r[11].s64 + 80;
	// 825DFB50: C1AB0040  lfs f13, 0x40(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DFB54: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825DFB58: 4098000C  bge cr6, 0x825dfb64
	if !ctx.cr[6].lt {
	pc = 0x825DFB64; continue 'dispatch;
	}
	// 825DFB5C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 825DFB60: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825DFB64: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 825DFB68: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825DFB6C: 4098FFE0  bge cr6, 0x825dfb4c
	if !ctx.cr[6].lt {
	pc = 0x825DFB4C; continue 'dispatch;
	}
	// 825DFB70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DFB78 size=276
    let mut pc: u32 = 0x825DFB78;
    'dispatch: loop {
        match pc {
            0x825DFB78 => {
    //   block [0x825DFB78..0x825DFC8C)
	// 825DFB78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DFB7C: 4BF5553D  bl 0x825350b8
	ctx.lr = 0x825DFB80;
	sub_82535080(ctx, base);
	// 825DFB80: 81450010  lwz r10, 0x10(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DFB84: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825DFB88: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DFB8C: 81240014  lwz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 825DFB90: 83E40018  lwz r31, 0x18(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DFB94: 83A50014  lwz r29, 0x14(r5)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) } as u64;
	// 825DFB98: 80A50018  lwz r5, 0x18(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DFB9C: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFBA0: A14A0000  lhz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFBA4: A0890000  lhz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFBA8: A13F0000  lhz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFBAC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825DFBB0: A3FD0000  lhz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFBB4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825DFBB8: A0A50000  lhz r5, 0(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFBBC: 9BC30000  stb r30, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 825DFBC0: 409A004C  bne cr6, 0x825dfc0c
	if !ctx.cr[6].eq {
	pc = 0x825DFC0C; continue 'dispatch;
	}
	// 825DFBC4: 7F04F800  cmpw cr6, r4, r31
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[31].s32, &mut ctx.xer);
	// 825DFBC8: 419A000C  beq cr6, 0x825dfbd4
	if ctx.cr[6].eq {
	pc = 0x825DFBD4; continue 'dispatch;
	}
	// 825DFBCC: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825DFBD0: 409A0018  bne cr6, 0x825dfbe8
	if !ctx.cr[6].eq {
	pc = 0x825DFBE8; continue 'dispatch;
	}
	// 825DFBD4: 8B860000  lbz r28, 0(r6)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFBD8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825DFBDC: 419A0008  beq cr6, 0x825dfbe4
	if ctx.cr[6].eq {
	pc = 0x825DFBE4; continue 'dispatch;
	}
	// 825DFBE0: 9BA30000  stb r29, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825DFBE4: 9BC60000  stb r30, 0(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 825DFBE8: 7F09F800  cmpw cr6, r9, r31
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[31].s32, &mut ctx.xer);
	// 825DFBEC: 419A000C  beq cr6, 0x825dfbf8
	if ctx.cr[6].eq {
	pc = 0x825DFBF8; continue 'dispatch;
	}
	// 825DFBF0: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825DFBF4: 409A0018  bne cr6, 0x825dfc0c
	if !ctx.cr[6].eq {
	pc = 0x825DFC0C; continue 'dispatch;
	}
	// 825DFBF8: 8B870000  lbz r28, 0(r7)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFBFC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825DFC00: 419A0008  beq cr6, 0x825dfc08
	if ctx.cr[6].eq {
	pc = 0x825DFC08; continue 'dispatch;
	}
	// 825DFC04: 9BA30000  stb r29, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825DFC08: 9BC70000  stb r30, 0(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 825DFC0C: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 825DFC10: 409A003C  bne cr6, 0x825dfc4c
	if !ctx.cr[6].eq {
	pc = 0x825DFC4C; continue 'dispatch;
	}
	// 825DFC14: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825DFC18: 409A0018  bne cr6, 0x825dfc30
	if !ctx.cr[6].eq {
	pc = 0x825DFC30; continue 'dispatch;
	}
	// 825DFC1C: 89660000  lbz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFC20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DFC24: 419A0008  beq cr6, 0x825dfc2c
	if ctx.cr[6].eq {
	pc = 0x825DFC2C; continue 'dispatch;
	}
	// 825DFC28: 9BA30000  stb r29, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825DFC2C: 9BC60000  stb r30, 0(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 825DFC30: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825DFC34: 409A0018  bne cr6, 0x825dfc4c
	if !ctx.cr[6].eq {
	pc = 0x825DFC4C; continue 'dispatch;
	}
	// 825DFC38: 89670000  lbz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFC3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DFC40: 419A0008  beq cr6, 0x825dfc48
	if ctx.cr[6].eq {
	pc = 0x825DFC48; continue 'dispatch;
	}
	// 825DFC44: 9BA30000  stb r29, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825DFC48: 9BC70000  stb r30, 0(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 825DFC4C: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825DFC50: 409A0014  bne cr6, 0x825dfc64
	if !ctx.cr[6].eq {
	pc = 0x825DFC64; continue 'dispatch;
	}
	// 825DFC54: 7F09F800  cmpw cr6, r9, r31
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[31].s32, &mut ctx.xer);
	// 825DFC58: 419A001C  beq cr6, 0x825dfc74
	if ctx.cr[6].eq {
	pc = 0x825DFC74; continue 'dispatch;
	}
	// 825DFC5C: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825DFC60: 419A0014  beq cr6, 0x825dfc74
	if ctx.cr[6].eq {
	pc = 0x825DFC74; continue 'dispatch;
	}
	// 825DFC64: 7F04F800  cmpw cr6, r4, r31
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[31].s32, &mut ctx.xer);
	// 825DFC68: 409A0020  bne cr6, 0x825dfc88
	if !ctx.cr[6].eq {
	pc = 0x825DFC88; continue 'dispatch;
	}
	// 825DFC6C: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825DFC70: 409A0018  bne cr6, 0x825dfc88
	if !ctx.cr[6].eq {
	pc = 0x825DFC88; continue 'dispatch;
	}
	// 825DFC74: 89680000  lbz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFC78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DFC7C: 419A0008  beq cr6, 0x825dfc84
	if ctx.cr[6].eq {
	pc = 0x825DFC84; continue 'dispatch;
	}
	// 825DFC80: 9BA30000  stb r29, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825DFC84: 9BC80000  stb r30, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 825DFC88: 4BF55480  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFC90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DFC90 size=316
    let mut pc: u32 = 0x825DFC90;
    'dispatch: loop {
        match pc {
            0x825DFC90 => {
    //   block [0x825DFC90..0x825DFDCC)
	// 825DFC90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DFC94: 4BF55425  bl 0x825350b8
	ctx.lr = 0x825DFC98;
	sub_82535080(ctx, base);
	// 825DFC98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825DFC9C: 83C60004  lwz r30, 4(r6)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DFCA0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DFCA4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825DFCA8: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825DFCAC: 7F1FF000  cmpw cr6, r31, r30
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[30].s32, &mut ctx.xer);
	// 825DFCB0: 40980118  bge cr6, 0x825dfdc8
	if !ctx.cr[6].lt {
	pc = 0x825DFDC8; continue 'dispatch;
	}
	// 825DFCB4: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFCB8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825DFCBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DFCC0: 419A0074  beq cr6, 0x825dfd34
	if ctx.cr[6].eq {
	pc = 0x825DFD34; continue 'dispatch;
	}
	// 825DFCC4: 80E40004  lwz r7, 4(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DFCC8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825DFCCC: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 825DFCD0: 40980064  bge cr6, 0x825dfd34
	if !ctx.cr[6].lt {
	pc = 0x825DFD34; continue 'dispatch;
	}
	// 825DFCD4: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFCD8: 3B81FFD0  addi r28, r1, -0x30
	ctx.r[28].s64 = ctx.r[1].s64 + -48;
	// 825DFCDC: 83A40000  lwz r29, 0(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFCE0: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DFDD0 size=264
    let mut pc: u32 = 0x825DFDD0;
    'dispatch: loop {
        match pc {
            0x825DFDD0 => {
    //   block [0x825DFDD0..0x825DFED8)
	// 825DFDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DFDD4: 4BF552D5  bl 0x825350a8
	ctx.lr = 0x825DFDD8;
	sub_82535080(ctx, base);
	// 825DFDD8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DFDDC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825DFDE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825DFDE4: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 825DFDE8: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 825DFDEC: 38610052  addi r3, r1, 0x52
	ctx.r[3].s64 = ctx.r[1].s64 + 82;
	// 825DFDF0: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 825DFDF4: 997A0000  stb r11, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825DFDF8: 4BFFFE99  bl 0x825dfc90
	ctx.lr = 0x825DFDFC;
	sub_825DFC90(ctx, base);
	// 825DFDFC: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFE00: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 825DFE04: 83B90004  lwz r29, 4(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DFE08: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825DFE0C: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 825DFE10: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825DFE14: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825DFE18: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825DFE1C: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 825DFE20: 997A0000  stb r11, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825DFE24: 409900A8  ble cr6, 0x825dfecc
	if !ctx.cr[6].gt {
	pc = 0x825DFECC; continue 'dispatch;
	}
	// 825DFE28: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
	// 825DFE2C: 9B010050  stb r24, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u8 ) };
	// 825DFE30: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 825DFE34: 9B010051  stb r24, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[24].u8 ) };
	// 825DFE38: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825DFE3C: 9B010052  stb r24, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[24].u8 ) };
	// 825DFE40: 40990040  ble cr6, 0x825dfe80
	if !ctx.cr[6].gt {
	pc = 0x825DFE80; continue 'dispatch;
	}
	// 825DFE44: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 825DFE48: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 825DFE4C: 419A0024  beq cr6, 0x825dfe70
	if ctx.cr[6].eq {
	pc = 0x825DFE70; continue 'dispatch;
	}
	// 825DFE50: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFE54: 39010052  addi r8, r1, 0x52
	ctx.r[8].s64 = ctx.r[1].s64 + 82;
	// 825DFE58: 38E10051  addi r7, r1, 0x51
	ctx.r[7].s64 = ctx.r[1].s64 + 81;
	// 825DFE5C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825DFE60: 38610053  addi r3, r1, 0x53
	ctx.r[3].s64 = ctx.r[1].s64 + 83;
	// 825DFE64: 7CBE5A14  add r5, r30, r11
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 825DFE68: 7C9B5A14  add r4, r27, r11
	ctx.r[4].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 825DFE6C: 4BFFFD0D  bl 0x825dfb78
	ctx.lr = 0x825DFE70;
	sub_825DFB78(ctx, base);
	// 825DFE70: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825DFE74: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 825DFE78: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 825DFE7C: 4198FFCC  blt cr6, 0x825dfe48
	if ctx.cr[6].lt {
	pc = 0x825DFE48; continue 'dispatch;
	}
	// 825DFE80: 897A0000  lbz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFE84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DFE88: 419A002C  beq cr6, 0x825dfeb4
	if ctx.cr[6].eq {
	pc = 0x825DFEB4; continue 'dispatch;
	}
	// 825DFE8C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DFE90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DFE94: 419A0020  beq cr6, 0x825dfeb4
	if ctx.cr[6].eq {
	pc = 0x825DFEB4; continue 'dispatch;
	}
	// 825DFE98: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 825DFE9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DFEA0: 419A0014  beq cr6, 0x825dfeb4
	if ctx.cr[6].eq {
	pc = 0x825DFEB4; continue 'dispatch;
	}
	// 825DFEA4: 89610052  lbz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 825DFEA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DFEAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825DFEB0: 409A0008  bne cr6, 0x825dfeb8
	if !ctx.cr[6].eq {
	pc = 0x825DFEB8; continue 'dispatch;
	}
	// 825DFEB4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825DFEB8: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 825DFEBC: 997A0000  stb r11, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825DFEC0: 3B7B0020  addi r27, r27, 0x20
	ctx.r[27].s64 = ctx.r[27].s64 + 32;
	// 825DFEC4: 7F1CE800  cmpw cr6, r28, r29
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[29].s32, &mut ctx.xer);
	// 825DFEC8: 4198FF64  blt cr6, 0x825dfe2c
	if ctx.cr[6].lt {
	pc = 0x825DFE2C; continue 'dispatch;
	}
	// 825DFECC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825DFED0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825DFED4: 4BF55224  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DFED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DFED8 size=664
    let mut pc: u32 = 0x825DFED8;
    'dispatch: loop {
        match pc {
            0x825DFED8 => {
    //   block [0x825DFED8..0x825E0170)
	// 825DFED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DFEDC: 4BF551C5  bl 0x825350a0
	ctx.lr = 0x825DFEE0;
	sub_82535080(ctx, base);
	// 825DFEE0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DFEE4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825DFEE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825DFEEC: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 825DFEF0: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 825DFEF4: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 825DFEF8: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 825DFEFC: 38610052  addi r3, r1, 0x52
	ctx.r[3].s64 = ctx.r[1].s64 + 82;
	// 825DFF00: 997C0000  stb r11, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825DFF04: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 825DFF08: 4BFFFD89  bl 0x825dfc90
	ctx.lr = 0x825DFF0C;
	sub_825DFC90(ctx, base);
	// 825DFF0C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DFF10: 835B0004  lwz r26, 4(r27)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DFF14: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 825DFF18: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825DFF1C: 7ED9B378  mr r25, r22
	ctx.r[25].u64 = ctx.r[22].u64;
	// 825DFF20: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825DFF24: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825DFF28: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825DFF2C: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 825DFF30: 997C0000  stb r11, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825DFF34: 409901F0  ble cr6, 0x825e0124
	if !ctx.cr[6].gt {
	pc = 0x825E0124; continue 'dispatch;
	}
	// 825DFF38: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 825DFF3C: 3D60829A  lis r11, -0x7d66
	ctx.r[11].s64 = -2103836672;
	// 825DFF40: 394A0E30  addi r10, r10, 0xe30
	ctx.r[10].s64 = ctx.r[10].s64 + 3632;
	// 825DFF44: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 825DFF48: 396B3D80  addi r11, r11, 0x3d80
	ctx.r[11].s64 = ctx.r[11].s64 + 15744;
	// 825DFF4C: 7EDDB378  mr r29, r22
	ctx.r[29].u64 = ctx.r[22].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E0170 size=524
    let mut pc: u32 = 0x825E0170;
    'dispatch: loop {
        match pc {
            0x825E0170 => {
    //   block [0x825E0170..0x825E037C)
	// 825E0170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E0174: 4BF54F3D  bl 0x825350b0
	ctx.lr = 0x825E0178;
	sub_82535080(ctx, base);
	// 825E0178: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 825E017C: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E0180: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E0184: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 825E0188: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825E018C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825E0190: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 825E0194: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 825E0198: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 825E019C: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 825E01A0: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 825E01A4: C3FB0014  lfs f31, 0x14(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825E01A8: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 825E01AC: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 825E01B0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825E01B4: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825E01B8: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 825E01BC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825E01C0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825E01C4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825E01C8: 40990060  ble cr6, 0x825e0228
	if !ctx.cr[6].gt {
	pc = 0x825E0228; continue 'dispatch;
	}
	// 825E01CC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825E01D0: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825E01D4: 48000008  b 0x825e01dc
	pc = 0x825E01DC; continue 'dispatch;
	// 825E01D8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E01DC: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825E01E0: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 825E01E4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825E01E8: 409A0014  bne cr6, 0x825e01fc
	if !ctx.cr[6].eq {
	pc = 0x825E01FC; continue 'dispatch;
	}
	// 825E01EC: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 825E01F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825E01F4: 4BE8E15D  bl 0x8246e350
	ctx.lr = 0x825E01F8;
	sub_8246E350(ctx, base);
	// 825E01F8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825E01FC: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825E0200: 556A2036  slwi r10, r11, 4
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825E0204: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E0380 size=4
    let mut pc: u32 = 0x825E0380;
    'dispatch: loop {
        match pc {
            0x825E0380 => {
    //   block [0x825E0380..0x825E0384)
	// 825E0380: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E0388 size=4
    let mut pc: u32 = 0x825E0388;
    'dispatch: loop {
        match pc {
            0x825E0388 => {
    //   block [0x825E0388..0x825E038C)
	// 825E0388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E0390 size=144
    let mut pc: u32 = 0x825E0390;
    'dispatch: loop {
        match pc {
            0x825E0390 => {
    //   block [0x825E0390..0x825E0420)
	// 825E0390: 81430020  lwz r10, 0x20(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 825E0394: 3921FFE0  addi r9, r1, -0x20
	ctx.r[9].s64 = ctx.r[1].s64 + -32;
	// 825E0398: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825E039C: 81030030  lwz r8, 0x30(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E0420 size=352
    let mut pc: u32 = 0x825E0420;
    'dispatch: loop {
        match pc {
            0x825E0420 => {
    //   block [0x825E0420..0x825E0580)
	// 825E0420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E0424: 4BF54C85  bl 0x825350a8
	ctx.lr = 0x825E0428;
	sub_82535080(ctx, base);
	// 825E0428: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E042C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825E0430: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825E0434: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825E0438: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825E043C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825E0440: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 825E0444: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825E0448: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 825E044C: 3B7A0018  addi r27, r26, 0x18
	ctx.r[27].s64 = ctx.r[26].s64 + 24;
	// 825E0450: 3B0BA6F8  addi r24, r11, -0x5908
	ctx.r[24].s64 = ctx.r[11].s64 + -22792;
	// 825E0454: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E0458: 8089000C  lwz r4, 0xc(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 825E045C: 39040044  addi r8, r4, 0x44
	ctx.r[8].s64 = ctx.r[4].s64 + 68;
	// 825E0460: 81640044  lwz r11, 0x44(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(68 as u32) ) } as u64;
	// 825E0464: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E0468: 409A00B0  bne cr6, 0x825e0518
	if !ctx.cr[6].eq {
	pc = 0x825E0518; continue 'dispatch;
	}
	// 825E046C: 80E40010  lwz r7, 0x10(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825E0580 size=640
    let mut pc: u32 = 0x825E0580;
    'dispatch: loop {
        match pc {
            0x825E0580 => {
    //   block [0x825E0580..0x825E0800)
	// 825E0580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E0584: 4BF54B21  bl 0x825350a4
	ctx.lr = 0x825E0588;
	sub_82535080(ctx, base);
	// 825E0588: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825E058C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 825E0590: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825E0594: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 825E0598: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 825E059C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 825E05A0: 419A004C  beq cr6, 0x825e05ec
	if ctx.cr[6].eq {
	pc = 0x825E05EC; continue 'dispatch;
	}
	// 825E05A4: 39480378  addi r10, r8, 0x378
	ctx.r[10].s64 = ctx.r[8].s64 + 888;
	// 825E05A8: 3921FE20  addi r9, r1, -0x1e0
	ctx.r[9].s64 = ctx.r[1].s64 + -480;
	// 825E05AC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825E05B0: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 825E05B4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825E05B8: 41980034  blt cr6, 0x825e05ec
	if ctx.cr[6].lt {
	pc = 0x825E05EC; continue 'dispatch;
	}
	// 825E05BC: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825E05C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825E05C4: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E05C8: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 825E05CC: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 825E05D0: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 825E05D4: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 825E05D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E05DC: 93C90000  stw r30, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825E05E0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 825E05E4: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825E05E8: 409AFFCC  bne cr6, 0x825e05b4
	if !ctx.cr[6].eq {
	pc = 0x825E05B4; continue 'dispatch;
	}
	// 825E05EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E05F0: 4099004C  ble cr6, 0x825e063c
	if !ctx.cr[6].gt {
	pc = 0x825E063C; continue 'dispatch;
	}
	// 825E05F4: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825E05F8: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825E05FC: 3901FE20  addi r8, r1, -0x1e0
	ctx.r[8].s64 = ctx.r[1].s64 + -480;
	// 825E0600: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825E0604: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825E0608: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825E060C: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825E0610: 550A2036  slwi r10, r8, 4
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825E0614: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 825E0618: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825E061C: 7D081A14  add r8, r8, r3
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[3].u64;
	// 825E0620: 394A0050  addi r10, r10, 0x50
	ctx.r[10].s64 = ctx.r[10].s64 + 80;
	// 825E0624: 39080F70  addi r8, r8, 0xf70
	ctx.r[8].s64 = ctx.r[8].s64 + 3952;
	// 825E0628: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E062C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825E0630: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 825E0634: 409AFFE0  bne cr6, 0x825e0614
	if !ctx.cr[6].eq {
	pc = 0x825E0614; continue 'dispatch;
	}
	// 825E0638: 90E30010  stw r7, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 825E063C: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 825E0640: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 825E0644: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 825E0648: 40990144  ble cr6, 0x825e078c
	if !ctx.cr[6].gt {
	pc = 0x825E078C; continue 'dispatch;
	}
	// 825E064C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825E0650: 8341FE20  lwz r26, -0x1e0(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-480 as u32) ) } as u64;
	// 825E0654: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825E0658: 3B81FE24  addi r28, r1, -0x1dc
	ctx.r[28].s64 = ctx.r[1].s64 + -476;
	// 825E065C: C1A81850  lfs f13, 0x1850(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E0660: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E0664: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825E0668: 419A0190  beq cr6, 0x825e07f8
	if ctx.cr[6].eq {
	pc = 0x825E07F8; continue 'dispatch;
	}
	// 825E066C: 3B690001  addi r27, r9, 1
	ctx.r[27].s64 = ctx.r[9].s64 + 1;
	// 825E0670: 817CFFFC  lwz r11, -4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-4 as u32) ) } as u64;
	// 825E0674: 7F1B2000  cmpw cr6, r27, r4
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[4].s32, &mut ctx.xer);
	// 825E0678: 4098000C  bge cr6, 0x825e0684
	if !ctx.cr[6].lt {
	pc = 0x825E0684; continue 'dispatch;
	}
	// 825E067C: 83DC0000  lwz r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E0680: 48000008  b 0x825e0688
	pc = 0x825E0688; continue 'dispatch;
	// 825E0684: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 825E0688: 392B0030  addi r9, r11, 0x30
	ctx.r[9].s64 = ctx.r[11].s64 + 48;
	// 825E068C: 916B001C  stw r11, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 825E0690: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 825E0694: 916B002C  stw r11, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 825E0698: 38EB0020  addi r7, r11, 0x20
	ctx.r[7].s64 = ctx.r[11].s64 + 32;
	// 825E069C: 916B003C  stw r11, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 825E06A0: 3B1E0020  addi r24, r30, 0x20
	ctx.r[24].s64 = ctx.r[30].s64 + 32;
	// 825E06A4: 3AE1FDF0  addi r23, r1, -0x210
	ctx.r[23].s64 = ctx.r[1].s64 + -528;
	// 825E06A8: 912B0024  stw r9, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 825E06AC: 3BAA0004  addi r29, r10, 4
	ctx.r[29].s64 = ctx.r[10].s64 + 4;
	// 825E06B0: 910B0034  stw r8, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[8].u32 ) };
	// 825E06B4: 90EB0014  stw r7, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 825E06B8: 83EA0004  lwz r31, 4(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E06BC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E06C0: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E06C4: 90CB0030  stw r6, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[6].u32 ) };
	// 825E06C8: 90EB0020  stw r7, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 825E06CC: 93EB0010  stw r31, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 825E06D0: 910A0008  stw r8, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825E06D4: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 825E06D8: 913E0028  stw r9, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 825E06DC: 930B0038  stw r24, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[24].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E0800 size=556
    let mut pc: u32 = 0x825E0800;
    'dispatch: loop {
        match pc {
            0x825E0800 => {
    //   block [0x825E0800..0x825E0A2C)
	// 825E0800: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 825E0804: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 825E0808: 3BE30F70  addi r31, r3, 0xf70
	ctx.r[31].s64 = ctx.r[3].s64 + 3952;
	// 825E080C: 388310B0  addi r4, r3, 0x10b0
	ctx.r[4].s64 = ctx.r[3].s64 + 4272;
	// 825E0810: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825E0814: 91230010  stw r9, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 825E0818: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 825E081C: 394BA700  addi r10, r11, -0x5900
	ctx.r[10].s64 = ctx.r[11].s64 + -22784;
	// 825E0820: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 825E0824: 419A0078  beq cr6, 0x825e089c
	if ctx.cr[6].eq {
	pc = 0x825E089C; continue 'dispatch;
	}
	// 825E0828: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825E082C: 39690010  addi r11, r9, 0x10
	ctx.r[11].s64 = ctx.r[9].s64 + 16;
	// 825E0830: 90A90044  stw r5, 0x44(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(68 as u32), ctx.r[5].u32 ) };
	// 825E0834: 39090020  addi r8, r9, 0x20
	ctx.r[8].s64 = ctx.r[9].s64 + 32;
	// 825E0838: 38E90030  addi r7, r9, 0x30
	ctx.r[7].s64 = ctx.r[9].s64 + 48;
	// 825E083C: 38C90040  addi r6, r9, 0x40
	ctx.r[6].s64 = ctx.r[9].s64 + 64;
	// 825E0840: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825E0844: 91690034  stw r11, 0x34(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 825E0848: 91090014  stw r8, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 825E084C: 90E90024  stw r7, 0x24(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), ctx.r[7].u32 ) };
	// 825E0850: 40980040  bge cr6, 0x825e0890
	if !ctx.cr[6].lt {
	pc = 0x825E0890; continue 'dispatch;
	}
	// 825E0854: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 825E0858: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E085C: 7D081A14  add r8, r8, r3
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[3].u64;
	// 825E0860: 39080020  addi r8, r8, 0x20
	ctx.r[8].s64 = ctx.r[8].s64 + 32;
	// 825E0864: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825E0868: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825E086C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E0870: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 825E0874: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 825E0878: 7D081A14  add r8, r8, r3
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[3].u64;
	// 825E087C: 39080F80  addi r8, r8, 0xf80
	ctx.r[8].s64 = ctx.r[8].s64 + 3968;
	// 825E0880: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825E0884: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825E0888: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825E088C: 4198FFC8  blt cr6, 0x825e0854
	if ctx.cr[6].lt {
	pc = 0x825E0854; continue 'dispatch;
	}
	// 825E0890: 39290050  addi r9, r9, 0x50
	ctx.r[9].s64 = ctx.r[9].s64 + 80;
	// 825E0894: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 825E0898: 409AFF94  bne cr6, 0x825e082c
	if !ctx.cr[6].eq {
	pc = 0x825E082C; continue 'dispatch;
	}
	// 825E089C: 39631060  addi r11, r3, 0x1060
	ctx.r[11].s64 = ctx.r[3].s64 + 4192;
	// 825E08A0: 38C1FFC0  addi r6, r1, -0x40
	ctx.r[6].s64 = ctx.r[1].s64 + -64;
	// 825E08A4: 39430060  addi r10, r3, 0x60
	ctx.r[10].s64 = ctx.r[3].s64 + 96;
	// 825E08A8: 39230020  addi r9, r3, 0x20
	ctx.r[9].s64 = ctx.r[3].s64 + 32;
	// 825E08AC: 38A1FFC0  addi r5, r1, -0x40
	ctx.r[5].s64 = ctx.r[1].s64 + -64;
	// 825E08B0: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825E08B4: 80EB0020  lwz r7, 0x20(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 825E08B8: 808B0030  lwz r4, 0x30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E0A30 size=332
    let mut pc: u32 = 0x825E0A30;
    'dispatch: loop {
        match pc {
            0x825E0A30 => {
    //   block [0x825E0A30..0x825E0B7C)
	// 825E0A30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E0A34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E0A38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825E0A3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E0A40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E0A44: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825E0A48: 48000381  bl 0x825e0dc8
	ctx.lr = 0x825E0A4C;
	sub_825E0DC8(ctx, base);
	// 825E0A4C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825E0A50: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825E0A54: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825E0A58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825E0A5C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825E0A60: C1698E24  lfs f11, -0x71dc(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-29148 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825E0A64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825E0A68: C18A1FF8  lfs f12, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825E0A6C: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 825E0A70: C1ABA790  lfs f13, -0x5870(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22640 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E0A74: 7CCB0774  extsb r11, r6
	ctx.r[11].s64 = ctx.r[6].s8 as i64;
	// 825E0A78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E0A7C: 409A00E8  bne cr6, 0x825e0b64
	if !ctx.cr[6].eq {
	pc = 0x825E0B64; continue 'dispatch;
	}
	// 825E0A80: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825E0A84: 90A30044  stw r5, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[5].u32 ) };
	// 825E0A88: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 825E0A8C: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825E0A90: 419A0098  beq cr6, 0x825e0b28
	if ctx.cr[6].eq {
	pc = 0x825E0B28; continue 'dispatch;
	}
	// 825E0A94: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825E0A98: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825E0A9C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825E0AA0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825E0AA4: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825E0B80 size=580
    let mut pc: u32 = 0x825E0B80;
    'dispatch: loop {
        match pc {
            0x825E0B80 => {
    //   block [0x825E0B80..0x825E0DC4)
	// 825E0B80: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 825E0B84: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 825E0B88: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825E0B8C: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825E0B90: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 825E0B94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E0B98: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825E0B9C: C0AA8CB4  lfs f5, -0x734c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-29516 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 825E0BA0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825E0BA4: C12B1850  lfs f9, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 825E0BA8: C0EA1FF8  lfs f7, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 825E0BAC: D0E1FFD4  stfs f7, -0x2c(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-44 as u32), tmp.u32 ) };
	// 825E0BB0: D0E1FFD8  stfs f7, -0x28(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), tmp.u32 ) };
	// 825E0BB4: 41980190  blt cr6, 0x825e0d44
	if ctx.cr[6].lt {
	pc = 0x825E0D44; continue 'dispatch;
	}
	// 825E0BB8: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825E0BBC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 825E0BC0: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 825E0BC4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825E0BC8: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825E0BCC: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 825E0BD0: C109BFFC  lfs f8, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 825E0BD4: 386B0FB0  addi r3, r11, 0xfb0
	ctx.r[3].s64 = ctx.r[11].s64 + 4016;
	// 825E0BD8: C0CA2280  lfs f6, 0x2280(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8832 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 825E0BDC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825E0BE0: C08B2048  lfs f4, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 825E0BE4: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E0BE8: 3903FFC0  addi r8, r3, -0x40
	ctx.r[8].s64 = ctx.r[3].s64 + -64;
	// 825E0BEC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 825E0BF0: FF002800  fcmpu cr6, f0, f5
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[5].f64);
	// 825E0BF4: 41990140  bgt cr6, 0x825e0d34
	if ctx.cr[6].gt {
	pc = 0x825E0D34; continue 'dispatch;
	}
	// 825E0BF8: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 825E0BFC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825E0C00: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825E0C04: 41980130  blt cr6, 0x825e0d34
	if ctx.cr[6].lt {
	pc = 0x825E0D34; continue 'dispatch;
	}
	// 825E0C08: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825E0C0C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 825E0C10: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825E0C14: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825E0C18: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 825E0C1C: 396B0F70  addi r11, r11, 0xf70
	ctx.r[11].s64 = ctx.r[11].s64 + 3952;
	// 825E0C20: C00B0040  lfs f0, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E0C24: 394B0040  addi r10, r11, 0x40
	ctx.r[10].s64 = ctx.r[11].s64 + 64;
	// 825E0C28: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 825E0C2C: FF002800  fcmpu cr6, f0, f5
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[5].f64);
	// 825E0C30: 419900F4  bgt cr6, 0x825e0d24
	if ctx.cr[6].gt {
	pc = 0x825E0D24; continue 'dispatch;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E0DC8 size=64
    let mut pc: u32 = 0x825E0DC8;
    'dispatch: loop {
        match pc {
            0x825E0DC8 => {
    //   block [0x825E0DC8..0x825E0E08)
	// 825E0DC8: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825E0DCC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825E0DD0: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 825E0DD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E0DD8: 40990020  ble cr6, 0x825e0df8
	if !ctx.cr[6].gt {
	pc = 0x825E0DF8; continue 'dispatch;
	}
	// 825E0DDC: 39630FB4  addi r11, r3, 0xfb4
	ctx.r[11].s64 = ctx.r[3].s64 + 4020;
	// 825E0DE0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E0DE4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E0DE8: 81030010  lwz r8, 0x10(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825E0DEC: 396B0050  addi r11, r11, 0x50
	ctx.r[11].s64 = ctx.r[11].s64 + 80;
	// 825E0DF0: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 825E0DF4: 4198FFEC  blt cr6, 0x825e0de0
	if ctx.cr[6].lt {
	pc = 0x825E0DE0; continue 'dispatch;
	}
	// 825E0DF8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825E0DFC: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 825E0E00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E0E04: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E0E08 size=32
    let mut pc: u32 = 0x825E0E08;
    'dispatch: loop {
        match pc {
            0x825E0E08 => {
    //   block [0x825E0E08..0x825E0E28)
	// 825E0E08: 39630050  addi r11, r3, 0x50
	ctx.r[11].s64 = ctx.r[3].s64 + 80;
	// 825E0E0C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E0E10: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E0E14: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825E0E18: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 825E0E1C: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 825E0E20: 4198FFEC  blt cr6, 0x825e0e0c
	if ctx.cr[6].lt {
	pc = 0x825E0E0C; continue 'dispatch;
	}
	// 825E0E24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E0E28 size=312
    let mut pc: u32 = 0x825E0E28;
    'dispatch: loop {
        match pc {
            0x825E0E28 => {
    //   block [0x825E0E28..0x825E0F60)
	// 825E0E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E0E2C: 4BF54285  bl 0x825350b0
	ctx.lr = 0x825E0E30;
	sub_82535080(ctx, base);
	// 825E0E30: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E0E34: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825E0E38: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825E0E3C: 396BFA60  addi r11, r11, -0x5a0
	ctx.r[11].s64 = ctx.r[11].s64 + -1440;
	// 825E0E40: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825E0E44: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825E0E48: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E0F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E0F60 size=804
    let mut pc: u32 = 0x825E0F60;
    'dispatch: loop {
        match pc {
            0x825E0F60 => {
    //   block [0x825E0F60..0x825E1284)
	// 825E0F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E0F64: 4BF54141  bl 0x825350a4
	ctx.lr = 0x825E0F68;
	sub_82535080(ctx, base);
	// 825E0F68: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 825E0F6C: 4BF55079  bl 0x82535fe4
	ctx.lr = 0x825E0F70;
	sub_82535FB0(ctx, base);
	// 825E0F70: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E1288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E1288 size=640
    let mut pc: u32 = 0x825E1288;
    'dispatch: loop {
        match pc {
            0x825E1288 => {
    //   block [0x825E1288..0x825E1508)
	// 825E1288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E128C: 4BF53E25  bl 0x825350b0
	ctx.lr = 0x825E1290;
	sub_82535080(ctx, base);
	// 825E1290: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 825E1294: 4BF54D4D  bl 0x82535fe0
	ctx.lr = 0x825E1298;
	sub_82535FB0(ctx, base);
	// 825E1298: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E129C: C0030090  lfs f0, 0x90(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E12A0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825E12A4: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825E12A8: 39000040  li r8, 0x40
	ctx.r[8].s64 = 64;
	// 825E12AC: C003009C  lfs f0, 0x9c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E12B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825E12B4: D004005C  stfs f0, 0x5c(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825E12B8: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 825E12BC: C00300A0  lfs f0, 0xa0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E12C0: 3BE10054  addi r31, r1, 0x54
	ctx.r[31].s64 = ctx.r[1].s64 + 84;
	// 825E12C4: D00400C0  stfs f0, 0xc0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 825E12C8: 39630030  addi r11, r3, 0x30
	ctx.r[11].s64 = ctx.r[3].s64 + 48;
	// 825E12CC: C003009C  lfs f0, 0x9c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E12D0: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 825E12D4: C3EA1850  lfs f31, 0x1850(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825E12D8: 39440004  addi r10, r4, 4
	ctx.r[10].s64 = ctx.r[4].s64 + 4;
	// 825E12DC: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 825E12E0: D0040060  stfs f0, 0x60(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825E12E4: C00300A0  lfs f0, 0xa0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E12E8: 3BC00050  li r30, 0x50
	ctx.r[30].s64 = 80;
	// 825E12EC: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 825E12F0: D00400C4  stfs f0, 0xc4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 825E12F4: C0030094  lfs f0, 0x94(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E12F8: 3923009C  addi r9, r3, 0x9c
	ctx.r[9].s64 = ctx.r[3].s64 + 156;
	// 825E12FC: C1A40060  lfs f13, 0x60(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E1300: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 825E1304: D0040050  stfs f0, 0x50(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825E1308: C0030098  lfs f0, 0x98(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E130C: C1A400C4  lfs f13, 0xc4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E1310: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 825E1314: D00400B4  stfs f0, 0xb4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 825E1318: C0040050  lfs f0, 0x50(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E131C: C1A400B4  lfs f13, 0xb4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(180 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E1320: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 825E1324: EDBF6824  fdivs f13, f31, f13
	ctx.f[13].f64 = ((ctx.f[31].f64 / ctx.f[13].f64) as f32) as f64;
	// 825E1328: D0040054  stfs f0, 0x54(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825E132C: D1A400B8  stfs f13, 0xb8(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(184 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E1508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825E1508 size=72
    let mut pc: u32 = 0x825E1508;
    'dispatch: loop {
        match pc {
            0x825E1508 => {
    //   block [0x825E1508..0x825E1550)
	// 825E1508: C1A40084  lfs f13, 0x84(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E150C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825E1510: C0040094  lfs f0, 0x94(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E1514: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 825E1518: C1A40080  lfs f13, 0x80(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E151C: C1840090  lfs f12, 0x90(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825E1520: ED2C0372  fmuls f9, f12, f13
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 825E1524: D006001C  stfs f0, 0x1c(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 825E1528: C14B1850  lfs f10, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825E152C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825E1530: D1260020  stfs f9, 0x20(r6)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 825E1534: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 825E1538: EDA96A7A  fmadds f13, f9, f9, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64);
	// 825E153C: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 825E1540: 40980010  bge cr6, 0x825e1550
	if !ctx.cr[6].lt {
		sub_825E1550(ctx, base);
		return;
	}
	// 825E1544: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E1548: D0040098  stfs f0, 0x98(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 825E154C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E1550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825E1550 size=232
    let mut pc: u32 = 0x825E1550;
    'dispatch: loop {
        match pc {
            0x825E1550 => {
    //   block [0x825E1550..0x825E1638)
	// 825E1550: C1A50044  lfs f13, 0x44(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E1554: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825E1558: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825E155C: C1850000  lfs f12, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825E1560: ED8C0272  fmuls f12, f12, f9
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[9].f64) as f32) as f64);
	// 825E1564: C16B1FF8  lfs f11, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825E1568: FCC05890  fmr f6, f11
	ctx.f[6].f64 = ctx.f[11].f64;
	// 825E156C: FD005890  fmr f8, f11
	ctx.f[8].f64 = ctx.f[11].f64;
	// 825E1570: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 825E1574: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 825E1578: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 825E157C: 41990044  bgt cr6, 0x825e15c0
	if ctx.cr[6].gt {
	pc = 0x825E15C0; continue 'dispatch;
	}
	// 825E1580: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 825E1584: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825E1588: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825E158C: 2F0A0010  cmpwi cr6, r10, 0x10
	ctx.cr[6].compare_i32(ctx.r[10].s32, 16, &mut ctx.xer);
	// 825E1590: 40980030  bge cr6, 0x825e15c0
	if !ctx.cr[6].lt {
	pc = 0x825E15C0; continue 'dispatch;
	}
	// 825E1594: C1050040  lfs f8, 0x40(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(64 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 825E1598: FD600090  fmr f11, f0
	ctx.f[11].f64 = ctx.f[0].f64;
	// 825E159C: EC080032  fmuls f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 825E15A0: C0EB0000  lfs f7, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 825E15A4: FD006890  fmr f8, f13
	ctx.f[8].f64 = ctx.f[13].f64;
	// 825E15A8: FCC06090  fmr f6, f12
	ctx.f[6].f64 = ctx.f[12].f64;
	// 825E15AC: ED870272  fmuls f12, f7, f9
	ctx.f[12].f64 = (((ctx.f[7].f64 * ctx.f[9].f64) as f32) as f64);
	// 825E15B0: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 825E15B4: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 825E15B8: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 825E15BC: 4099FFC8  ble cr6, 0x825e1584
	if !ctx.cr[6].gt {
	pc = 0x825E1584; continue 'dispatch;
	}
	// 825E15C0: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 825E15C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825E15C8: ED00402C  fsqrts f8, f8
	ctx.f[8].f64 = ((ctx.f[8].f64).sqrt() as f32) as f64;
	// 825E15CC: ED2D5028  fsubs f9, f13, f10
	ctx.f[9].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 825E15D0: ED085028  fsubs f8, f8, f10
	ctx.f[8].f64 = (((ctx.f[8].f64 - ctx.f[10].f64) as f32) as f64);
	// 825E15D4: C0EB2280  lfs f7, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 825E15D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825E15DC: EDA94028  fsubs f13, f9, f8
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[8].f64) as f32) as f64);
	// 825E15E0: FCA06A10  fabs f5, f13
	ctx.f[5].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 825E15E4: FF053800  fcmpu cr6, f5, f7
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[7].f64);
	// 825E15E8: 41980008  blt cr6, 0x825e15f0
	if ctx.cr[6].lt {
	pc = 0x825E15F0; continue 'dispatch;
	}
	// 825E15EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E15F0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825E15F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E15F8: 419A0008  beq cr6, 0x825e1600
	if ctx.cr[6].eq {
	pc = 0x825E1600; continue 'dispatch;
	}
	// 825E15FC: FDA03890  fmr f13, f7
	ctx.f[13].f64 = ctx.f[7].f64;
	// 825E1600: EDAA6824  fdivs f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 / ctx.f[13].f64) as f32) as f64;
	// 825E1604: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825E1608: ED0D0232  fmuls f8, f13, f8
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[8].f64) as f32) as f64);
	// 825E160C: ED2D0272  fmuls f9, f13, f9
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[9].f64) as f32) as f64);
	// 825E1610: C1ABA7C8  lfs f13, -0x5838(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22584 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E1614: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825E1618: FD004050  fneg f8, f8
	ctx.f[8].u64 = ctx.f[8].u64 ^ 0x8000_0000_0000_0000u64;
	// 825E161C: EC080032  fmuls f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 825E1620: EC0902FA  fmadds f0, f9, f11, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 825E1624: C16B2278  lfs f11, 0x2278(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8824 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825E1628: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825E162C: 4098000C  bge cr6, 0x825e1638
	if !ctx.cr[6].lt {
		sub_825E1638(ctx, base);
		return;
	}
	// 825E1630: FCE06890  fmr f7, f13
	ctx.f[7].f64 = ctx.f[13].f64;
	// 825E1634: 48000018  b 0x825e164c
	sub_825E1648(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E1638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E1638 size=16
    let mut pc: u32 = 0x825E1638;
    'dispatch: loop {
        match pc {
            0x825E1638 => {
    //   block [0x825E1638..0x825E1648)
	// 825E1638: FF005800  fcmpu cr6, f0, f11
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 825E163C: 4099000C  ble cr6, 0x825e1648
	if !ctx.cr[6].gt {
		sub_825E1648(ctx, base);
		return;
	}
	// 825E1640: FCE05890  fmr f7, f11
	ctx.f[7].f64 = ctx.f[11].f64;
	// 825E1644: 48000008  b 0x825e164c
	sub_825E1648(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E1648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E1648 size=28
    let mut pc: u32 = 0x825E1648;
    'dispatch: loop {
        match pc {
            0x825E1648 => {
    //   block [0x825E1648..0x825E1664)
	// 825E1648: FCE00090  fmr f7, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[7].f64 = ctx.f[0].f64;
	// 825E164C: EC0901B2  fmuls f0, f9, f6
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[6].f64) as f32) as f64);
	// 825E1650: ED08033A  fmadds f8, f8, f12, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 825E1654: FF086800  fcmpu cr6, f8, f13
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[13].f64);
	// 825E1658: 4098000C  bge cr6, 0x825e1664
	if !ctx.cr[6].lt {
		sub_825E1664(ctx, base);
		return;
	}
	// 825E165C: FD006890  fmr f8, f13
	ctx.f[8].f64 = ctx.f[13].f64;
	// 825E1660: 48000010  b 0x825e1670
	sub_825E1664(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E1664(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825E1664 size=124
    let mut pc: u32 = 0x825E1664;
    'dispatch: loop {
        match pc {
            0x825E1664 => {
    //   block [0x825E1664..0x825E16E0)
	// 825E1664: FF085800  fcmpu cr6, f8, f11
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[11].f64);
	// 825E1668: 40990008  ble cr6, 0x825e1670
	if !ctx.cr[6].gt {
	pc = 0x825E1670; continue 'dispatch;
	}
	// 825E166C: FD005890  fmr f8, f11
	ctx.f[8].f64 = ctx.f[11].f64;
	// 825E1670: C004008C  lfs f0, 0x8c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825E1674: C0640074  lfs f3, 0x74(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(116 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825E1678: ED2001F2  fmuls f9, f0, f7
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[7].f64) as f32) as f64);
	// 825E167C: C1640068  lfs f11, 0x68(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(104 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825E1680: ECE30032  fmuls f7, f3, f0
	ctx.f[7].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 825E1684: EC0B02F2  fmuls f0, f11, f11
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 825E1688: C1840060  lfs f12, 0x60(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825E168C: C1A40088  lfs f13, 0x88(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825E1690: ED0D0232  fmuls f8, f13, f8
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[8].f64) as f32) as f64);
	// 825E1694: C0A40080  lfs f5, 0x80(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(128 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 825E1698: C084007C  lfs f4, 0x7c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(124 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 825E169C: C0C40084  lfs f6, 0x84(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(132 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 825E16A0: D1240084  stfs f9, 0x84(r4)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 825E16A4: D1040080  stfs f8, 0x80(r4)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 825E16A8: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 825E16AC: ED864828  fsubs f12, f6, f9
	ctx.f[12].f64 = (((ctx.f[6].f64 - ctx.f[9].f64) as f32) as f64);
	// 825E16B0: ED6A0024  fdivs f11, f10, f0
	ctx.f[11].f64 = ((ctx.f[10].f64 / ctx.f[0].f64) as f32) as f64;
	// 825E16B4: EC054028  fsubs f0, f5, f8
	ctx.f[0].f64 = (((ctx.f[5].f64 - ctx.f[8].f64) as f32) as f64);
	// 825E16B8: D0040098  stfs f0, 0x98(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 825E16BC: EC040032  fmuls f0, f4, f0
	ctx.f[0].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 825E16C0: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 825E16C4: EDA70332  fmuls f13, f7, f12
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 825E16C8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 825E16CC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 825E16D0: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 825E16D4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 825E16D8: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825E16DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E16E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825E16E0 size=3040
    let mut pc: u32 = 0x825E16E0;
    'dispatch: loop {
        match pc {
            0x825E16E0 => {
    //   block [0x825E16E0..0x825E22C0)
	// 825E16E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E16E4: 4BF5399D  bl 0x82535080
	ctx.lr = 0x825E16E8;
	sub_82535080(ctx, base);
	// 825E16E8: DBA1FF50  stfd f29, -0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.f[29].u64 ) };
	// 825E16EC: DBC1FF58  stfd f30, -0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 825E16F0: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 825E16F4: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E16F8: 3FE0829A  lis r31, -0x7d66
	ctx.r[31].s64 = -2103836672;
	// 825E16FC: 90610274  stw r3, 0x274(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(628 as u32), ctx.r[3].u32 ) };
	// 825E1700: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825E1704: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825E1708: 7CB12B78  mr r17, r5
	ctx.r[17].u64 = ctx.r[5].u64;
	// 825E170C: 897F3E8B  lbz r11, 0x3e8b(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16011 as u32) ) } as u64;
	// 825E1710: 93C1027C  stw r30, 0x27c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(636 as u32), ctx.r[30].u32 ) };
	// 825E1714: 93A1028C  stw r29, 0x28c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(652 as u32), ctx.r[29].u32 ) };
	// 825E1718: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E171C: 409A001C  bne cr6, 0x825e1738
	if !ctx.cr[6].eq {
	pc = 0x825E1738; continue 'dispatch;
	}
	// 825E1720: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 825E1724: 4BF17A1D  bl 0x824f9140
	ctx.lr = 0x825E1728;
	sub_824F9140(ctx, base);
	// 825E1728: 7C6B0774  extsb r11, r3
	ctx.r[11].s64 = ctx.r[3].s8 as i64;
	// 825E172C: 987F3E8B  stb r3, 0x3e8b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16011 as u32), ctx.r[3].u8 ) };
	// 825E1730: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825E1734: 419A0B78  beq cr6, 0x825e22ac
	if ctx.cr[6].eq {
	pc = 0x825E22AC; continue 'dispatch;
	}
	// 825E1738: 39510150  addi r10, r17, 0x150
	ctx.r[10].s64 = ctx.r[17].s64 + 336;
	// 825E173C: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 825E1740: 393D0018  addi r9, r29, 0x18
	ctx.r[9].s64 = ctx.r[29].s64 + 24;
	// 825E1744: 10A0038C  vspltisw v5, 0
	for i in 0..4 {
		ctx.v[5].u32[i] = 0;
	}
	// 825E1748: 39F100D0  addi r15, r17, 0xd0
	ctx.r[15].s64 = ctx.r[17].s64 + 208;
	// 825E174C: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 825E1750: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 825E1754: 1080030A  vcfux v4, v0, 0
	// vcfux/vcuxwfp128: ctx.v[4].f32[i] = ( ctx.v[0].u32[i] as f32 ) * (2.0f32).powi(0);
	for i in 0..4 { ctx.v[4].f32[i] = (ctx.v[0].u32[i] as f32) * (2.0f32).powi(0); }
	// 825E1758: 3B2A0010  addi r25, r10, 0x10
	ctx.r[25].s64 = ctx.r[10].s64 + 16;
	// 825E175C: 3ACA0020  addi r22, r10, 0x20
	ctx.r[22].s64 = ctx.r[10].s64 + 32;
	// 825E1760: 3AAA0030  addi r21, r10, 0x30
	ctx.r[21].s64 = ctx.r[10].s64 + 48;
	// 825E1764: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 825E1768: C3C61850  lfs f30, 0x1850(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(6224 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825E176C: 7DFD7B78  mr r29, r15
	ctx.r[29].u64 = ctx.r[15].u64;
	// 825E1770: C0C72280  lfs f6, 0x2280(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8832 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 825E1774: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825E1778: 3BFE0054  addi r31, r30, 0x54
	ctx.r[31].s64 = ctx.r[30].s64 + 84;
	// 825E177C: 39110020  addi r8, r17, 0x20
	ctx.r[8].s64 = ctx.r[17].s64 + 32;
	// 825E1780: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 825E1784: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 825E1788: 3A7D0040  addi r19, r29, 0x40
	ctx.r[19].s64 = ctx.r[29].s64 + 64;
	// 825E178C: 3A5D0001  addi r18, r29, 1
	ctx.r[18].s64 = ctx.r[29].s64 + 1;
	// 825E1790: 3A899F60  addi r20, r9, -0x60a0
	ctx.r[20].s64 = ctx.r[9].s64 + -24736;
	// 825E1794: 3A000040  li r16, 0x40
	ctx.r[16].s64 = 64;
	// 825E1798: 3AE00010  li r23, 0x10
	ctx.r[23].s64 = 16;
	// 825E179C: 3B000020  li r24, 0x20
	ctx.r[24].s64 = 32;
	// 825E17A0: 3B600030  li r27, 0x30
	ctx.r[27].s64 = 48;
	// 825E17A4: 38C0FFE0  li r6, -0x20
	ctx.r[6].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E22C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E22C0 size=4
    let mut pc: u32 = 0x825E22C0;
    'dispatch: loop {
        match pc {
            0x825E22C0 => {
    //   block [0x825E22C0..0x825E22C4)
	// 825E22C0: 7D8300D0  neg r12, r3
	ctx.r[12].s64 = -ctx.r[3].s64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E22C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E22C4 size=16
    let mut pc: u32 = 0x825E22C4;
    'dispatch: loop {
        match pc {
            0x825E22C4 => {
    //   block [0x825E22C4..0x825E22D4)
	// 825E22C4: 7D6C00D0  neg r11, r12
	ctx.r[11].s64 = -ctx.r[12].s64;
	// 825E22C8: 380B0FFF  addi r0, r11, 0xfff
	ctx.r[0].s64 = ctx.r[11].s64 + 4095;
	// 825E22CC: 7C006671  srawi. r0, r0, 0xc
	ctx.xer.ca = (ctx.r[0].s32 < 0) && ((ctx.r[0].u32 & ((1u32 << 12) - 1)) != 0);
	ctx.r[0].s64 = (ctx.r[0].s32 >> 12) as i64;
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 825E22D0: 4C810020  blelr
	if !ctx.cr[0].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E22D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E22D4 size=20
    let mut pc: u32 = 0x825E22D4;
    'dispatch: loop {
        match pc {
            0x825E22D4 => {
    //   block [0x825E22D4..0x825E22E8)
	// 825E22D4: 7C2B0B78  mr r11, r1
	ctx.r[11].u64 = ctx.r[1].u64;
	// 825E22D8: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825E22DC: 840BF000  lwzu r0, -0x1000(r11)
	ea = ctx.r[11].u32.wrapping_add(-4096 as u32);
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ea) } as u64;
	ctx.r[11].u32 = ea;
	// 825E22E0: 4200FFFC  bdnz 0x825e22dc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825E22DC; continue 'dispatch;
	}
	// 825E22E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E22F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E22F0 size=788
    let mut pc: u32 = 0x825E22F0;
    'dispatch: loop {
        match pc {
            0x825E22F0 => {
    //   block [0x825E22F0..0x825E2604)
	// 825E22F0: 7C0802A6  mflr r0
	ctx.r[0].u64 = ctx.lr;
	// 825E22F4: 9421FFB0  stwu r1, -0x50(r1)
	ea = ctx.r[1].u32.wrapping_add(-80 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E22F8: 90010008  stw r0, 8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(8 as u32), ctx.r[0].u32 ) };
	// 825E22FC: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825E2300: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 825E2304: 80030138  lwz r0, 0x138(r3)
	ctx.r[0].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(312 as u32) ) } as u64;
	// 825E2308: 2C800000  cmpwi cr1, r0, 0
	ctx.cr[1].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 825E230C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 825E2310: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825E2314: 40820008  bne 0x825e231c
	if !ctx.cr[0].eq {
	pc = 0x825E231C; continue 'dispatch;
	}
	// 825E2318: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825E231C: 408602C0  bne cr1, 0x825e25dc
	if !ctx.cr[1].eq {
	pc = 0x825E25DC; continue 'dispatch;
	}
	// 825E2320: 80670134  lwz r3, 0x134(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(308 as u32) ) } as u64;
	// 825E2324: 80870090  lwz r4, 0x90(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(144 as u32) ) } as u64;
	// 825E2328: 4BF63A79  bl 0x82545da0
	ctx.lr = 0x825E232C;
	sub_82545DA0(ctx, base);
	// 825E232C: C9C70000  lfd f14, 0(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[14].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 825E2330: C9E70008  lfd f15, 8(r7)
	ctx.f[15].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 825E2334: CA070010  lfd f16, 0x10(r7)
	ctx.f[16].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) };
	// 825E2338: CA270018  lfd f17, 0x18(r7)
	ctx.f[17].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) };
	// 825E233C: CA470020  lfd f18, 0x20(r7)
	ctx.f[18].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(32 as u32) ) };
	// 825E2340: CA670028  lfd f19, 0x28(r7)
	ctx.f[19].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(40 as u32) ) };
	// 825E2344: CA870030  lfd f20, 0x30(r7)
	ctx.f[20].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	// 825E2348: CAA70038  lfd f21, 0x38(r7)
	ctx.f[21].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(56 as u32) ) };
	// 825E234C: CAC70040  lfd f22, 0x40(r7)
	ctx.f[22].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(64 as u32) ) };
	// 825E2350: CAE70048  lfd f23, 0x48(r7)
	ctx.f[23].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(72 as u32) ) };
	// 825E2354: CB070050  lfd f24, 0x50(r7)
	ctx.f[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(80 as u32) ) };
	// 825E2358: CB270058  lfd f25, 0x58(r7)
	ctx.f[25].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(88 as u32) ) };
	// 825E235C: CB470060  lfd f26, 0x60(r7)
	ctx.f[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(96 as u32) ) };
	// 825E2360: CB670068  lfd f27, 0x68(r7)
	ctx.f[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(104 as u32) ) };
	// 825E2364: CB870070  lfd f28, 0x70(r7)
	ctx.f[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(112 as u32) ) };
	// 825E2368: CBA70078  lfd f29, 0x78(r7)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(120 as u32) ) };
	// 825E236C: CBC70080  lfd f30, 0x80(r7)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(128 as u32) ) };
	// 825E2370: CBE70088  lfd f31, 0x88(r7)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(136 as u32) ) };
	// 825E2374: E9A70098  ld r13, 0x98(r7)
	ctx.r[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(152 as u32) ) };
	// 825E2378: E9C700A0  ld r14, 0xa0(r7)
	ctx.r[14].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(160 as u32) ) };
	// 825E237C: E9E700A8  ld r15, 0xa8(r7)
	ctx.r[15].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(168 as u32) ) };
	// 825E2380: EA0700B0  ld r16, 0xb0(r7)
	ctx.r[16].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(176 as u32) ) };
	// 825E2384: EA2700B8  ld r17, 0xb8(r7)
	ctx.r[17].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(184 as u32) ) };
	// 825E2388: EA4700C0  ld r18, 0xc0(r7)
	ctx.r[18].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(192 as u32) ) };
	// 825E238C: EA6700C8  ld r19, 0xc8(r7)
	ctx.r[19].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(200 as u32) ) };
	// 825E2390: EA8700D0  ld r20, 0xd0(r7)
	ctx.r[20].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(208 as u32) ) };
	// 825E2394: EAA700D8  ld r21, 0xd8(r7)
	ctx.r[21].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(216 as u32) ) };
	// 825E2398: EAC700E0  ld r22, 0xe0(r7)
	ctx.r[22].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(224 as u32) ) };
	// 825E239C: EAE700E8  ld r23, 0xe8(r7)
	ctx.r[23].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(232 as u32) ) };
	// 825E23A0: EB0700F0  ld r24, 0xf0(r7)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(240 as u32) ) };
	// 825E23A4: EB2700F8  ld r25, 0xf8(r7)
	ctx.r[25].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(248 as u32) ) };
	// 825E23A8: EB470100  ld r26, 0x100(r7)
	ctx.r[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(256 as u32) ) };
	// 825E23AC: EB670108  ld r27, 0x108(r7)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(264 as u32) ) };
	// 825E23B0: EB870110  ld r28, 0x110(r7)
	ctx.r[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(272 as u32) ) };
	// 825E23B4: EBA70118  ld r29, 0x118(r7)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(280 as u32) ) };
	// 825E23B8: EBC70120  ld r30, 0x120(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(288 as u32) ) };
	// 825E23BC: EBE70128  ld r31, 0x128(r7)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(296 as u32) ) };
	// 825E23C0: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E2610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E2610 size=20
    let mut pc: u32 = 0x825E2610;
    'dispatch: loop {
        match pc {
            0x825E2610 => {
    //   block [0x825E2610..0x825E2624)
	// 825E2610: 3C808313  lis r4, -0x7ced
	ctx.r[4].s64 = -2095906816;
	// 825E2614: 80043CD4  lwz r0, 0x3cd4(r4)
	ctx.r[0].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(15572 as u32) ) } as u64;
	// 825E2618: 2C000000  cmpwi r0, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 825E261C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825E2620: 4C820420  bnectr
	if !ctx.cr[0].eq {
		crate::rt::call_indirect(ctx.ctr.u32);
		return;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E2624(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E2624 size=696
    let mut pc: u32 = 0x825E2624;
    'dispatch: loop {
        match pc {
            0x825E2624 => {
    //   block [0x825E2624..0x825E28DC)
	// 825E2624: 7C0802A6  mflr r0
	ctx.r[0].u64 = ctx.lr;
	// 825E2628: 7C800026  mfcr r4
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[4].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 825E262C: D9C30000  stfd f14, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.f[14].u64 ) };
	// 825E2630: D9E30008  stfd f15, 8(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.f[15].u64 ) };
	// 825E2634: DA030010  stfd f16, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.f[16].u64 ) };
	// 825E2638: DA230018  stfd f17, 0x18(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.f[17].u64 ) };
	// 825E263C: DA430020  stfd f18, 0x20(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.f[18].u64 ) };
	// 825E2640: DA630028  stfd f19, 0x28(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.f[19].u64 ) };
	// 825E2644: DA830030  stfd f20, 0x30(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.f[20].u64 ) };
	// 825E2648: DAA30038  stfd f21, 0x38(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.f[21].u64 ) };
	// 825E264C: DAC30040  stfd f22, 0x40(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.f[22].u64 ) };
	// 825E2650: DAE30048  stfd f23, 0x48(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.f[23].u64 ) };
	// 825E2654: DB030050  stfd f24, 0x50(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.f[24].u64 ) };
	// 825E2658: DB230058  stfd f25, 0x58(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.f[25].u64 ) };
	// 825E265C: DB430060  stfd f26, 0x60(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.f[26].u64 ) };
	// 825E2660: DB630068  stfd f27, 0x68(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.f[27].u64 ) };
	// 825E2664: DB830070  stfd f28, 0x70(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.f[28].u64 ) };
	// 825E2668: DBA30078  stfd f29, 0x78(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.f[29].u64 ) };
	// 825E266C: DBC30080  stfd f30, 0x80(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.f[30].u64 ) };
	// 825E2670: DBE30088  stfd f31, 0x88(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.f[31].u64 ) };
	// 825E2674: F9A30098  std r13, 0x98(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[13].u64 ) };
	// 825E2678: F9C300A0  std r14, 0xa0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[14].u64 ) };
	// 825E267C: F9E300A8  std r15, 0xa8(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), ctx.r[15].u64 ) };
	// 825E2680: FA0300B0  std r16, 0xb0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), ctx.r[16].u64 ) };
	// 825E2684: FA2300B8  std r17, 0xb8(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), ctx.r[17].u64 ) };
	// 825E2688: FA4300C0  std r18, 0xc0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[18].u64 ) };
	// 825E268C: FA6300C8  std r19, 0xc8(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), ctx.r[19].u64 ) };
	// 825E2690: FA8300D0  std r20, 0xd0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), ctx.r[20].u64 ) };
	// 825E2694: FAA300D8  std r21, 0xd8(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(216 as u32), ctx.r[21].u64 ) };
	// 825E2698: FAC300E0  std r22, 0xe0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), ctx.r[22].u64 ) };
	// 825E269C: FAE300E8  std r23, 0xe8(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(232 as u32), ctx.r[23].u64 ) };
	// 825E26A0: FB0300F0  std r24, 0xf0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(240 as u32), ctx.r[24].u64 ) };
	// 825E26A4: FB2300F8  std r25, 0xf8(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(248 as u32), ctx.r[25].u64 ) };
	// 825E26A8: FB430100  std r26, 0x100(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), ctx.r[26].u64 ) };
	// 825E26AC: FB630108  std r27, 0x108(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(264 as u32), ctx.r[27].u64 ) };
	// 825E26B0: FB830110  std r28, 0x110(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(272 as u32), ctx.r[28].u64 ) };
	// 825E26B4: FBA30118  std r29, 0x118(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(280 as u32), ctx.r[29].u64 ) };
	// 825E26B8: FBC30120  std r30, 0x120(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(288 as u32), ctx.r[30].u64 ) };
	// 825E26BC: FBE30128  std r31, 0x128(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(296 as u32), ctx.r[31].u64 ) };
	// 825E26C0: 38A00140  li r5, 0x140
	ctx.r[5].s64 = 320;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E28E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E28E0 size=176
    let mut pc: u32 = 0x825E28E0;
    'dispatch: loop {
        match pc {
            0x825E28E0 => {
    //   block [0x825E28E0..0x825E2990)
	// 825E28E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E28E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E28E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825E28EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E28F0: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 825E28F4: 3BEBA080  addi r31, r11, -0x5f80
	ctx.r[31].s64 = ctx.r[11].s64 + -24448;
	// 825E28F8: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825E28FC: 4BDB765D  bl 0x82399f58
	ctx.lr = 0x825E2900;
	sub_82399F58(ctx, base);
	// 825E2900: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 825E2904: 816BBECC  lwz r11, -0x4134(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16692 as u32) ) } as u64;
	// 825E2908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825E290C: 409A0024  bne cr6, 0x825e2930
	if !ctx.cr[6].eq {
	pc = 0x825E2930; continue 'dispatch;
	}
	// 825E2910: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 825E2914: 38604000  li r3, 0x4000
	ctx.r[3].s64 = 16384;
	// 825E2918: 814BBED0  lwz r10, -0x4130(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16688 as u32) ) } as u64;
	// 825E291C: 394A4000  addi r10, r10, 0x4000
	ctx.r[10].s64 = ctx.r[10].s64 + 16384;
	// 825E2920: 914BBED0  stw r10, -0x4130(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16688 as u32), ctx.r[10].u32 ) };
	// 825E2924: 4BF5134D  bl 0x82533c70
	ctx.lr = 0x825E2928;
	sub_82533C70(ctx, base);
	// 825E2928: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825E292C: 48000008  b 0x825e2934
	pc = 0x825E2934; continue 'dispatch;
	// 825E2930: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E2934: 3D408271  lis r10, -0x7d8f
	ctx.r[10].s64 = -2106523648;
	// 825E2938: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 825E293C: 386ABE98  addi r3, r10, -0x4168
	ctx.r[3].s64 = ctx.r[10].s64 + -16744;
	// 825E2940: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 825E2944: 916A3C3C  stw r11, 0x3c3c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15420 as u32), ctx.r[11].u32 ) };
	// 825E2948: 39404000  li r10, 0x4000
	ctx.r[10].s64 = 16384;
	// 825E294C: 91493C40  stw r10, 0x3c40(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(15424 as u32), ctx.r[10].u32 ) };
	// 825E2950: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 825E2954: 916A3C38  stw r11, 0x3c38(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15416 as u32), ctx.r[11].u32 ) };
	// 825E2958: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 825E295C: 39604000  li r11, 0x4000
	ctx.r[11].s64 = 16384;
	// 825E2960: 916A3C34  stw r11, 0x3c34(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15412 as u32), ctx.r[11].u32 ) };
	// 825E2964: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 825E2968: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E296C: 916A3C30  stw r11, 0x3c30(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15408 as u32), ctx.r[11].u32 ) };
	// 825E2970: 3D60829A  lis r11, -0x7d66
	ctx.r[11].s64 = -2103836672;
	// 825E2974: 93EB3E94  stw r31, 0x3e94(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16020 as u32), ctx.r[31].u32 ) };
	// 825E2978: 4BF501C1  bl 0x82532b38
	ctx.lr = 0x825E297C;
	sub_82532B38(ctx, base);
	// 825E297C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825E2980: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E2984: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E2988: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825E298C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E2990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E2990 size=108
    let mut pc: u32 = 0x825E2990;
    'dispatch: loop {
        match pc {
            0x825E2990 => {
    //   block [0x825E2990..0x825E29FC)
	// 825E2990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E2994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E2998: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E299C: 38600038  li r3, 0x38
	ctx.r[3].s64 = 56;
	// 825E29A0: 4BE22429  bl 0x82404dc8
	ctx.lr = 0x825E29A4;
	sub_82404DC8(ctx, base);
	// 825E29A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825E29A8: 419A0038  beq cr6, 0x825e29e0
	if ctx.cr[6].eq {
	pc = 0x825E29E0; continue 'dispatch;
	}
	// 825E29AC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825E29B0: 394BDE48  addi r10, r11, -0x21b8
	ctx.r[10].s64 = ctx.r[11].s64 + -8632;
	// 825E29B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E29B8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825E29BC: 99630004  stb r11, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 825E29C0: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 825E29C4: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 825E29C8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 825E29CC: 906BBFE4  stw r3, -0x401c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16412 as u32), ctx.r[3].u32 ) };
	// 825E29D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825E29D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E29D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E29DC: 4E800020  blr
	return;
	// 825E29E0: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 825E29E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E29E8: 916ABFE4  stw r11, -0x401c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-16412 as u32), ctx.r[11].u32 ) };
	// 825E29EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825E29F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E29F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E29F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E2A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825E2A00 size=52
    let mut pc: u32 = 0x825E2A00;
    'dispatch: loop {
        match pc {
            0x825E2A00 => {
    //   block [0x825E2A00..0x825E2A34)
	// 825E2A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825E2A04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825E2A08: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825E2A0C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 825E2A10: 386BBFF0  addi r3, r11, -0x4010
	ctx.r[3].s64 = ctx.r[11].s64 + -16400;
	// 825E2A14: 4BB3A6FD  bl 0x8211d110
	ctx.lr = 0x825E2A18;
	sub_8211D110(ctx, base);
	// 825E2A18: 3D608271  lis r11, -0x7d8f
	ctx.r[11].s64 = -2106523648;
	// 825E2A1C: 386BBEC8  addi r3, r11, -0x4138
	ctx.r[3].s64 = ctx.r[11].s64 + -16696;
	// 825E2A20: 4BF50119  bl 0x82532b38
	ctx.lr = 0x825E2A24;
	sub_82532B38(ctx, base);
	// 825E2A24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825E2A28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825E2A2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825E2A30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E2A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E2A38 size=68
    let mut pc: u32 = 0x825E2A38;
    'dispatch: loop {
        match pc {
            0x825E2A38 => {
    //   block [0x825E2A38..0x825E2A7C)
	// 825E2A38: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 825E2A3C: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825E2A40: 396BA0CC  addi r11, r11, -0x5f34
	ctx.r[11].s64 = ctx.r[11].s64 + -24372;
	// 825E2A44: 3909E088  addi r8, r9, -0x1f78
	ctx.r[8].s64 = ctx.r[9].s64 + -8056;
	// 825E2A48: 39400021  li r10, 0x21
	ctx.r[10].s64 = 33;
	// 825E2A4C: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 825E2A50: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825E2A54: 910BFFFC  stw r8, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[8].u32 ) };
	// 825E2A58: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 825E2A5C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825E2A60: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825E2A64: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825E2A68: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825E2A6C: 4098FFE8  bge cr6, 0x825e2a54
	if !ctx.cr[6].lt {
	pc = 0x825E2A54; continue 'dispatch;
	}
	// 825E2A70: 3D608271  lis r11, -0x7d8f
	ctx.r[11].s64 = -2106523648;
	// 825E2A74: 386BBEF0  addi r3, r11, -0x4110
	ctx.r[3].s64 = ctx.r[11].s64 + -16656;
	// 825E2A78: 4BF500C0  b 0x82532b38
	sub_82532B38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E2A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E2A80 size=16
    let mut pc: u32 = 0x825E2A80;
    'dispatch: loop {
        match pc {
            0x825E2A80 => {
    //   block [0x825E2A80..0x825E2A90)
	// 825E2A80: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 825E2A84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E2A88: 916AB930  stw r11, -0x46d0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-18128 as u32), ctx.r[11].u32 ) };
	// 825E2A8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825E2A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825E2A90 size=16
    let mut pc: u32 = 0x825E2A90;
    'dispatch: loop {
        match pc {
            0x825E2A90 => {
    //   block [0x825E2A90..0x825E2AA0)
	// 825E2A90: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 825E2A94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825E2A98: 916AB930  stw r11, -0x46d0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-18128 as u32), ctx.r[11].u32 ) };
	// 825E2A9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


