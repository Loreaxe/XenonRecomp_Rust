pub fn sub_823FAED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FAED0 size=108
    let mut pc: u32 = 0x823FAED0;
    'dispatch: loop {
        match pc {
            0x823FAED0 => {
    //   block [0x823FAED0..0x823FAF3C)
	// 823FAED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FAED4: 4813A1E9  bl 0x825350bc
	ctx.lr = 0x823FAED8;
	sub_82535080(ctx, base);
	// 823FAED8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FAEDC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FAEE0: B0E10054  sth r7, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u16 ) };
	// 823FAEE4: 5509043E  clrlwi r9, r8, 0x10
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x0000FFFFu64;
	// 823FAEE8: 90A10060  stw r5, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u32 ) };
	// 823FAEEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FAEF0: 90C10064  stw r6, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[6].u32 ) };
	// 823FAEF4: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 823FAEF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823FAEFC: 3BEB7310  addi r31, r11, 0x7310
	ctx.r[31].s64 = ctx.r[11].s64 + 29456;
	// 823FAF00: 9143003C  stw r10, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 823FAF04: 91230040  stw r9, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[9].u32 ) };
	// 823FAF08: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 823FAF0C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FAF10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823FAF14: A8BE0000  lha r5, 0(r30)
	ctx.r[5].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 823FAF18: 5564063E  clrlwi r4, r11, 0x18
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823FAF1C: 480013AD  bl 0x823fc2c8
	ctx.lr = 0x823FAF20;
	sub_823FC2C8(ctx, base);
	// 823FAF20: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 823FAF24: 397F0022  addi r11, r31, 0x22
	ctx.r[11].s64 = ctx.r[31].s64 + 34;
	// 823FAF28: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 823FAF2C: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FAF30: 4198FFDC  blt cr6, 0x823faf0c
	if ctx.cr[6].lt {
	pc = 0x823FAF0C; continue 'dispatch;
	}
	// 823FAF34: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823FAF38: 4813A1D4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FAF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FAF40 size=152
    let mut pc: u32 = 0x823FAF40;
    'dispatch: loop {
        match pc {
            0x823FAF40 => {
    //   block [0x823FAF40..0x823FAFD8)
	// 823FAF40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FAF44: 4813A16D  bl 0x825350b0
	ctx.lr = 0x823FAF48;
	sub_82535080(ctx, base);
	// 823FAF48: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FAF4C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823FAF50: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823FAF54: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 823FAF58: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823FAF5C: 3B7E0004  addi r27, r30, 4
	ctx.r[27].s64 = ctx.r[30].s64 + 4;
	// 823FAF60: C05E0004  lfs f2, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823FAF64: 3B5F0004  addi r26, r31, 4
	ctx.r[26].s64 = ctx.r[31].s64 + 4;
	// 823FAF68: C03C0038  lfs f1, 0x38(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FAF6C: C07F0004  lfs f3, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 823FAF70: 48001B49  bl 0x823fcab8
	ctx.lr = 0x823FAF74;
	sub_823FCAB8(ctx, base);
	// 823FAF74: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 823FAF78: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 823FAF7C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 823FAF80: C03C0038  lfs f1, 0x38(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FAF84: 48001BB5  bl 0x823fcb38
	ctx.lr = 0x823FAF88;
	sub_823FCB38(ctx, base);
	// 823FAF88: C03F0000  lfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FAF8C: 48001A45  bl 0x823fc9d0
	ctx.lr = 0x823FAF90;
	sub_823FC9D0(ctx, base);
	// 823FAF90: 907D0008  stw r3, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 823FAF94: 48001AD5  bl 0x823fca68
	ctx.lr = 0x823FAF98;
	sub_823FCA68(ctx, base);
	// 823FAF98: D03F0000  stfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FAF9C: C03E0010  lfs f1, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FAFA0: 480019D9  bl 0x823fc978
	ctx.lr = 0x823FAFA4;
	sub_823FC978(ctx, base);
	// 823FAFA4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823FAFA8: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 823FAFAC: 389D000C  addi r4, r29, 0xc
	ctx.r[4].s64 = ctx.r[29].s64 + 12;
	// 823FAFB0: 387E0014  addi r3, r30, 0x14
	ctx.r[3].s64 = ctx.r[30].s64 + 20;
	// 823FAFB4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FAFB8: C03F0004  lfs f1, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FAFBC: 48001725  bl 0x823fc6e0
	ctx.lr = 0x823FAFC0;
	sub_823FC6E0(ctx, base);
	// 823FAFC0: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FAFC4: D01C0038  stfs f0, 0x38(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 823FAFC8: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FAFCC: D01C003C  stfs f0, 0x3c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 823FAFD0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823FAFD4: 4813A12C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FAFD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FAFD8 size=300
    let mut pc: u32 = 0x823FAFD8;
    'dispatch: loop {
        match pc {
            0x823FAFD8 => {
    //   block [0x823FAFD8..0x823FB104)
	// 823FAFD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FAFDC: 4813A0D5  bl 0x825350b0
	ctx.lr = 0x823FAFE0;
	sub_82535080(ctx, base);
	// 823FAFE0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 823FAFE4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FAFE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823FAFEC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 823FAFF0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823FAFF4: 409A000C  bne cr6, 0x823fb000
	if !ctx.cr[6].eq {
	pc = 0x823FB000; continue 'dispatch;
	}
	// 823FAFF8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FAFFC: 480000FC  b 0x823fb0f8
	pc = 0x823FB0F8; continue 'dispatch;
	// 823FB000: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823FB004: 3FA08288  lis r29, -0x7d78
	ctx.r[29].s64 = -2105016320;
	// 823FB008: 38800058  li r4, 0x58
	ctx.r[4].s64 = 88;
	// 823FB00C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FB010: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 823FB014: 817D37A8  lwz r11, 0x37a8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FB018: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FB01C: 4E800421  bctrl
	ctx.lr = 0x823FB020;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FB020: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823FB024: 4182FFD4  beq 0x823faff8
	if ctx.cr[0].eq {
	pc = 0x823FAFF8; continue 'dispatch;
	}
	// 823FB028: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 823FB02C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823FB030: 935F0040  stw r26, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[26].u32 ) };
	// 823FB034: 38800028  li r4, 0x28
	ctx.r[4].s64 = 40;
	// 823FB038: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FB03C: 937F0044  stw r27, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[27].u32 ) };
	// 823FB040: 817D37A8  lwz r11, 0x37a8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FB044: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FB048: 4E800421  bctrl
	ctx.lr = 0x823FB04C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FB04C: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FB050: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 823FB054: 4182FFA4  beq 0x823faff8
	if ctx.cr[0].eq {
	pc = 0x823FAFF8; continue 'dispatch;
	}
	// 823FB058: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823FB05C: B38B001C  sth r28, 0x1c(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[28].u16 ) };
	// 823FB060: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823FB064: B38B0024  sth r28, 0x24(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[28].u16 ) };
	// 823FB068: 38600173  li r3, 0x173
	ctx.r[3].s64 = 371;
	// 823FB06C: C00A1850  lfs f0, 0x1850(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB070: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FB074: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 823FB078: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 823FB07C: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 823FB080: D00B0020  stfs f0, 0x20(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 823FB084: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FB088: D3EB0018  stfs f31, 0x18(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 823FB08C: 48002745  bl 0x823fd7d0
	ctx.lr = 0x823FB090;
	sub_823FD7D0(ctx, base);
	// 823FB090: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823FB094: 4082FF64  bne 0x823faff8
	if !ctx.cr[0].eq {
	pc = 0x823FAFF8; continue 'dispatch;
	}
	// 823FB098: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 823FB09C: D3FF0008  stfs f31, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 823FB0A0: 48002669  bl 0x823fd708
	ctx.lr = 0x823FB0A4;
	sub_823FD708(ctx, base);
	// 823FB0A4: 546B043F  clrlwi. r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FB0A8: 4082FF50  bne 0x823faff8
	if !ctx.cr[0].eq {
	pc = 0x823FAFF8; continue 'dispatch;
	}
	// 823FB0AC: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 823FB0B0: 48001DA1  bl 0x823fce50
	ctx.lr = 0x823FB0B4;
	sub_823FCE50(ctx, base);
	// 823FB0B4: 546B043F  clrlwi. r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FB0B8: 4082FF40  bne 0x823faff8
	if !ctx.cr[0].eq {
	pc = 0x823FAFF8; continue 'dispatch;
	}
	// 823FB0BC: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 823FB0C0: 48001CE1  bl 0x823fcda0
	ctx.lr = 0x823FB0C4;
	sub_823FCDA0(ctx, base);
	// 823FB0C4: 7C6B0735  extsh. r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FB0C8: 4082FF30  bne 0x823faff8
	if !ctx.cr[0].eq {
	pc = 0x823FAFF8; continue 'dispatch;
	}
	// 823FB0CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB0D0: D3FF001C  stfs f31, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 823FB0D4: D3FF0030  stfs f31, 0x30(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 823FB0D8: 937F0020  stw r27, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[27].u32 ) };
	// 823FB0DC: D3FF0038  stfs f31, 0x38(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 823FB0E0: 937F0028  stw r27, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[27].u32 ) };
	// 823FB0E4: 939F004C  stw r28, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[28].u32 ) };
	// 823FB0E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FB0EC: C00B2094  lfs f0, 0x2094(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB0F0: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 823FB0F4: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 823FB0F8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823FB0FC: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 823FB100: 4813A000  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FB108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FB108 size=144
    let mut pc: u32 = 0x823FB108;
    'dispatch: loop {
        match pc {
            0x823FB108 => {
    //   block [0x823FB108..0x823FB198)
	// 823FB108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FB10C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FB110: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823FB114: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FB118: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FB11C: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FB120: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FB124: 41820058  beq 0x823fb17c
	if ctx.cr[0].eq {
	pc = 0x823FB17C; continue 'dispatch;
	}
	// 823FB128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FB12C: 48004E3D  bl 0x823fff68
	ctx.lr = 0x823FB130;
	sub_823FFF68(ctx, base);
	// 823FB130: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 823FB134: 4800264D  bl 0x823fd780
	ctx.lr = 0x823FB138;
	sub_823FD780(ctx, base);
	// 823FB138: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 823FB13C: 48001DBD  bl 0x823fcef8
	ctx.lr = 0x823FB140;
	sub_823FCEF8(ctx, base);
	// 823FB140: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 823FB144: 4800263D  bl 0x823fd780
	ctx.lr = 0x823FB148;
	sub_823FD780(ctx, base);
	// 823FB148: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 823FB14C: 3FC08288  lis r30, -0x7d78
	ctx.r[30].s64 = -2105016320;
	// 823FB150: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FB154: 41820018  beq 0x823fb16c
	if ctx.cr[0].eq {
	pc = 0x823FB16C; continue 'dispatch;
	}
	// 823FB158: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FB15C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FB160: 4E800421  bctrl
	ctx.lr = 0x823FB164;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FB164: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FB168: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 823FB16C: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FB170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FB174: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FB178: 4E800421  bctrl
	ctx.lr = 0x823FB17C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FB17C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FB180: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FB184: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FB188: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FB18C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823FB190: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FB194: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FB198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FB198 size=232
    let mut pc: u32 = 0x823FB198;
    'dispatch: loop {
        match pc {
            0x823FB198 => {
    //   block [0x823FB198..0x823FB280)
	// 823FB198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FB19C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FB1A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823FB1A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FB1A8: 9421F2F0  stwu r1, -0xd10(r1)
	ea = ctx.r[1].u32.wrapping_add(-3344 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FB1AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823FB1B0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823FB1B4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 823FB1B8: 38A00123  li r5, 0x123
	ctx.r[5].s64 = 291;
	// 823FB1BC: 38800091  li r4, 0x91
	ctx.r[4].s64 = 145;
	// 823FB1C0: 480027A1  bl 0x823fd960
	ctx.lr = 0x823FB1C4;
	sub_823FD960(ctx, base);
	// 823FB1C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FB1C8: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 823FB1CC: 396B7338  addi r11, r11, 0x7338
	ctx.r[11].s64 = ctx.r[11].s64 + 29496;
	// 823FB1D0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823FB1D4: 38E00091  li r7, 0x91
	ctx.r[7].s64 = 145;
	// 823FB1D8: 390104D8  addi r8, r1, 0x4d8
	ctx.r[8].s64 = ctx.r[1].s64 + 1240;
	// 823FB1DC: C1AA0000  lfs f13, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB1E0: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823FB1E4: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB1E8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FB1EC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FB1F0: D1A90000  stfs f13, 0(r9)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB1F4: C1A80000  lfs f13, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB1F8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FB1FC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FB200: D0080000  stfs f0, 0(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB204: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FB208: 3908FFFC  addi r8, r8, -4
	ctx.r[8].s64 = ctx.r[8].s64 + -4;
	// 823FB20C: 4181FFD0  bgt 0x823fb1dc
	if ctx.cr[0].gt {
	pc = 0x823FB1DC; continue 'dispatch;
	}
	// 823FB210: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB214: 38A00123  li r5, 0x123
	ctx.r[5].s64 = 291;
	// 823FB218: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB21C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823FB220: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823FB224: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FB228: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB22C: 480029ED  bl 0x823fdc18
	ctx.lr = 0x823FB230;
	sub_823FDC18(ctx, base);
	// 823FB230: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FB234: 38E108F0  addi r7, r1, 0x8f0
	ctx.r[7].s64 = ctx.r[1].s64 + 2288;
	// 823FB238: 38C104E0  addi r6, r1, 0x4e0
	ctx.r[6].s64 = ctx.r[1].s64 + 1248;
	// 823FB23C: 38A00009  li r5, 9
	ctx.r[5].s64 = 9;
	// 823FB240: 38800123  li r4, 0x123
	ctx.r[4].s64 = 291;
	// 823FB244: C00B7584  lfs f0, 0x7584(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30084 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823FB24C: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FB250: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB254: 4800286D  bl 0x823fdac0
	ctx.lr = 0x823FB258;
	sub_823FDAC0(ctx, base);
	// 823FB258: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823FB25C: 388108F0  addi r4, r1, 0x8f0
	ctx.r[4].s64 = ctx.r[1].s64 + 2288;
	// 823FB260: 386104E0  addi r3, r1, 0x4e0
	ctx.r[3].s64 = ctx.r[1].s64 + 1248;
	// 823FB264: 48002275  bl 0x823fd4d8
	ctx.lr = 0x823FB268;
	sub_823FD4D8(ctx, base);
	// 823FB268: 38210D10  addi r1, r1, 0xd10
	ctx.r[1].s64 = ctx.r[1].s64 + 3344;
	// 823FB26C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FB270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FB274: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823FB278: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FB27C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FB280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FB280 size=444
    let mut pc: u32 = 0x823FB280;
    'dispatch: loop {
        match pc {
            0x823FB280 => {
    //   block [0x823FB280..0x823FB43C)
	// 823FB280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FB284: 48139E19  bl 0x8253509c
	ctx.lr = 0x823FB288;
	sub_82535080(ctx, base);
	// 823FB288: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 823FB28C: 4813AD5D  bl 0x82535fe8
	ctx.lr = 0x823FB290;
	sub_82535FB0(ctx, base);
	// 823FB290: 9421FA00  stwu r1, -0x600(r1)
	ea = ctx.r[1].u32.wrapping_add(-1536 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FB294: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 823FB298: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 823FB29C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823FB2A0: 3976FFFF  addi r11, r22, -1
	ctx.r[11].s64 = ctx.r[22].s64 + -1;
	// 823FB2A4: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 823FB2A8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FB2AC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823FB2B0: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FB2B4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FB2B8: FF800018  frsp f28, f0
	ctx.f[28].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FB2BC: EC1CF024  fdivs f0, f28, f30
	ctx.f[0].f64 = ((ctx.f[28].f64 / ctx.f[30].f64) as f32) as f64;
	// 823FB2C0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FB2C4: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 823FB2C8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FB2CC: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 823FB2D0: 2F1D0050  cmpwi cr6, r29, 0x50
	ctx.cr[6].compare_i32(ctx.r[29].s32, 80, &mut ctx.xer);
	// 823FB2D4: 40990008  ble cr6, 0x823fb2dc
	if !ctx.cr[6].gt {
	pc = 0x823FB2DC; continue 'dispatch;
	}
	// 823FB2D8: 3BA00050  li r29, 0x50
	ctx.r[29].s64 = 80;
	// 823FB2DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB2E0: 57BB103A  slwi r27, r29, 2
	ctx.r[27].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 823FB2E4: 57AA1838  slwi r10, r29, 3
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FB2E8: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 823FB2EC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823FB2F0: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FB2F4: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 823FB2F8: 7FCA4A14  add r30, r10, r9
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823FB2FC: 7FFB5A14  add r31, r27, r11
	ctx.r[31].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 823FB300: 4099005C  ble cr6, 0x823fb35c
	if !ctx.cr[6].gt {
	pc = 0x823FB35C; continue 'dispatch;
	}
	// 823FB304: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 823FB308: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 823FB30C: 7F1E5850  subf r24, r30, r11
	ctx.r[24].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 823FB310: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB314: 7EFEF850  subf r23, r30, r31
	ctx.r[23].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 823FB318: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 823FB31C: C3ABBFFC  lfs f29, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 823FB320: EC1FE82A  fadds f0, f31, f29
	ctx.f[0].f64 = ((ctx.f[31].f64 + ctx.f[29].f64) as f32) as f64;
	// 823FB324: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823FB328: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FB32C: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 823FB330: 83210050  lwz r25, 0x50(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FB334: 572B103A  slwi r11, r25, 2
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FB338: 7C2BAC2E  lfsx f1, r11, r21
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[21].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FB33C: 48002E2D  bl 0x823fe168
	ctx.lr = 0x823FB340;
	sub_823FE168(ctx, base);
	// 823FB340: 7C38E52E  stfsx f1, r24, r28
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[24].u32.wrapping_add(ctx.r[28].u32), tmp.u32) };
	// 823FB344: 933C0000  stw r25, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 823FB348: 7FF7E52E  stfsx f31, r23, r28
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[23].u32.wrapping_add(ctx.r[28].u32), tmp.u32) };
	// 823FB34C: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 823FB350: EFFFF02A  fadds f31, f31, f30
	ctx.f[31].f64 = ((ctx.f[31].f64 + ctx.f[30].f64) as f32) as f64;
	// 823FB354: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 823FB358: 4082FFC8  bne 0x823fb320
	if !ctx.cr[0].eq {
	pc = 0x823FB320; continue 'dispatch;
	}
	// 823FB35C: 56CB103A  slwi r11, r22, 2
	ctx.r[11].u32 = ctx.r[22].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FB360: 7D6BAA14  add r11, r11, r21
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[21].u64;
	// 823FB364: C02BFFFC  lfs f1, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FB368: 48002E01  bl 0x823fe168
	ctx.lr = 0x823FB36C;
	sub_823FE168(ctx, base);
	// 823FB36C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 823FB370: 395D0001  addi r10, r29, 1
	ctx.r[10].s64 = ctx.r[29].s64 + 1;
	// 823FB374: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 823FB378: 7C3B5D2E  stfsx f1, r27, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 823FB37C: 7EDBF12E  stwx r22, r27, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[30].u32), ctx.r[22].u32) };
	// 823FB380: 7F9BFD2E  stfsx f28, r27, r31
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 823FB384: 409900A8  ble cr6, 0x823fb42c
	if !ctx.cr[6].gt {
	pc = 0x823FB42C; continue 'dispatch;
	}
	// 823FB388: 38CAFFFF  addi r6, r10, -1
	ctx.r[6].s64 = ctx.r[10].s64 + -1;
	// 823FB38C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823FB390: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 823FB394: 38E10064  addi r7, r1, 0x64
	ctx.r[7].s64 = ctx.r[1].s64 + 100;
	// 823FB398: 391E0004  addi r8, r30, 4
	ctx.r[8].s64 = ctx.r[30].s64 + 4;
	// 823FB39C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 823FB3A0: C14A1850  lfs f10, 0x1850(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FB3A4: 7FDFF050  subf r30, r31, r30
	ctx.r[30].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 823FB3A8: 7CBF4850  subf r5, r31, r9
	ctx.r[5].s64 = ctx.r[9].s64 - ctx.r[31].s64;
	// 823FB3AC: 7C9F3850  subf r4, r31, r7
	ctx.r[4].s64 = ctx.r[7].s64 - ctx.r[31].s64;
	// 823FB3B0: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB3B4: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823FB3B8: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB3BC: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FB3C0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FB3C4: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 823FB3C8: 7F0A3800  cmpw cr6, r10, r7
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[7].s32, &mut ctx.xer);
	// 823FB3CC: ED6A0024  fdivs f11, f10, f0
	ctx.f[11].f64 = ((ctx.f[10].f64 / ctx.f[0].f64) as f32) as f64;
	// 823FB3D0: 4098004C  bge cr6, 0x823fb41c
	if !ctx.cr[6].lt {
	pc = 0x823FB41C; continue 'dispatch;
	}
	// 823FB3D4: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FB3D8: 7C055C2E  lfsx f0, r5, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB3DC: 7D845C2E  lfsx f12, r4, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FB3E0: 7D69AA14  add r11, r9, r21
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[21].u64;
	// 823FB3E4: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FB3E8: 7D4907B4  extsw r9, r10
	ctx.r[9].s64 = ctx.r[10].s32 as i64;
	// 823FB3EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823FB3F0: 7F0A3800  cmpw cr6, r10, r7
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[7].s32, &mut ctx.xer);
	// 823FB3F4: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 823FB3F8: C9210050  lfd f9, 0x50(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FB3FC: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 823FB400: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 823FB404: ED296828  fsubs f9, f9, f13
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FB408: ED290332  fmuls f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FB40C: ED2902FA  fmadds f9, f9, f11, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 823FB410: D12B0000  stfs f9, 0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB414: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FB418: 4198FFD0  blt cr6, 0x823fb3e8
	if ctx.cr[6].lt {
	pc = 0x823FB3E8; continue 'dispatch;
	}
	// 823FB41C: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 823FB420: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823FB424: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FB428: 4082FF88  bne 0x823fb3b0
	if !ctx.cr[0].eq {
	pc = 0x823FB3B0; continue 'dispatch;
	}
	// 823FB42C: 38210600  addi r1, r1, 0x600
	ctx.r[1].s64 = ctx.r[1].s64 + 1536;
	// 823FB430: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 823FB434: 4813AC01  bl 0x82536034
	ctx.lr = 0x823FB438;
	sub_82535FFC(ctx, base);
	// 823FB438: 48139CB4  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FB440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FB440 size=632
    let mut pc: u32 = 0x823FB440;
    'dispatch: loop {
        match pc {
            0x823FB440 => {
    //   block [0x823FB440..0x823FB6B8)
	// 823FB440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FB444: 48139C65  bl 0x825350a8
	ctx.lr = 0x823FB448;
	sub_82535080(ctx, base);
	// 823FB448: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 823FB44C: 9421F390  stwu r1, -0xc70(r1)
	ea = ctx.r[1].u32.wrapping_add(-3184 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FB450: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 823FB454: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 823FB458: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 823FB45C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 823FB460: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 823FB464: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 823FB468: 83FD0048  lwz r31, 0x48(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 823FB46C: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 823FB470: 39200064  li r9, 0x64
	ctx.r[9].s64 = 100;
	// 823FB474: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 823FB478: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 823FB47C: 38C10600  addi r6, r1, 0x600
	ctx.r[6].s64 = ctx.r[1].s64 + 1536;
	// 823FB480: 38A10200  addi r5, r1, 0x200
	ctx.r[5].s64 = ctx.r[1].s64 + 512;
	// 823FB484: 3BDB0008  addi r30, r27, 8
	ctx.r[30].s64 = ctx.r[27].s64 + 8;
	// 823FB488: 48003BB9  bl 0x823ff040
	ctx.lr = 0x823FB48C;
	sub_823FF040(ctx, base);
	// 823FB48C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FB490: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB494: 39200064  li r9, 0x64
	ctx.r[9].s64 = 100;
	// 823FB498: 38E10200  addi r7, r1, 0x200
	ctx.r[7].s64 = ctx.r[1].s64 + 512;
	// 823FB49C: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FB4A0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 823FB4A4: 38810600  addi r4, r1, 0x600
	ctx.r[4].s64 = ctx.r[1].s64 + 1536;
	// 823FB4A8: C00B7588  lfs f0, 0x7588(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30088 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB4AC: 38610200  addi r3, r1, 0x200
	ctx.r[3].s64 = ctx.r[1].s64 + 512;
	// 823FB4B0: EFE06824  fdivs f31, f0, f13
	ctx.f[31].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 823FB4B4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823FB4B8: 48003901  bl 0x823fedb8
	ctx.lr = 0x823FB4BC;
	sub_823FEDB8(ctx, base);
	// 823FB4BC: 3B5E0004  addi r26, r30, 4
	ctx.r[26].s64 = ctx.r[30].s64 + 4;
	// 823FB4C0: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FB4C4: 39400064  li r10, 0x64
	ctx.r[10].s64 = 100;
	// 823FB4C8: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 823FB4CC: 38E10600  addi r7, r1, 0x600
	ctx.r[7].s64 = ctx.r[1].s64 + 1536;
	// 823FB4D0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823FB4D4: 38810200  addi r4, r1, 0x200
	ctx.r[4].s64 = ctx.r[1].s64 + 512;
	// 823FB4D8: 387D0008  addi r3, r29, 8
	ctx.r[3].s64 = ctx.r[29].s64 + 8;
	// 823FB4DC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 823FB4E0: 48002EA1  bl 0x823fe380
	ctx.lr = 0x823FB4E4;
	sub_823FE380(ctx, base);
	// 823FB4E4: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823FB4E8: 38810200  addi r4, r1, 0x200
	ctx.r[4].s64 = ctx.r[1].s64 + 512;
	// 823FB4EC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823FB4F0: 4BFFFD91  bl 0x823fb280
	ctx.lr = 0x823FB4F4;
	sub_823FB280(ctx, base);
	// 823FB4F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FB4F8: C19F0020  lfs f12, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FB4FC: A0FF001C  lhz r7, 0x1c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823FB500: C00B1850  lfs f0, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB504: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB508: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 823FB50C: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FB510: 409A000C  bne cr6, 0x823fb51c
	if !ctx.cr[6].eq {
	pc = 0x823FB51C; continue 'dispatch;
	}
	// 823FB514: 7CEB0735  extsh. r11, r7
	ctx.r[11].s64 = ctx.r[7].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FB518: 418200FC  beq 0x823fb614
	if ctx.cr[0].eq {
	pc = 0x823FB614; continue 'dispatch;
	}
	// 823FB51C: A8DF0024  lha r6, 0x24(r31)
	ctx.r[6].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as i16) as i64;
	// 823FB520: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	// 823FB524: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 823FB528: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823FB52C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FB530: 7D0B07B4  extsw r11, r8
	ctx.r[11].s64 = ctx.r[8].s32 as i64;
	// 823FB534: 7F083000  cmpw cr6, r8, r6
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FB538: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 823FB53C: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823FB540: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 823FB544: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 823FB548: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FB54C: FD60581E  fctiwz f11, f11
	ctx.f[11].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 823FB550: D9610060  stfd f11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[11].u64 ) };
	// 823FB554: A1610066  lhz r11, 0x66(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(102 as u32) ) } as u64;
	// 823FB558: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 823FB55C: 41980038  blt cr6, 0x823fb594
	if ctx.cr[6].lt {
	pc = 0x823FB594; continue 'dispatch;
	}
	// 823FB560: 7D6B0735  extsh. r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FB564: 2F0B0100  cmpwi cr6, r11, 0x100
	ctx.cr[6].compare_i32(ctx.r[11].s32, 256, &mut ctx.xer);
	// 823FB568: 41800020  blt 0x823fb588
	if ctx.cr[0].lt {
	pc = 0x823FB588; continue 'dispatch;
	}
	// 823FB56C: 40980020  bge cr6, 0x823fb58c
	if !ctx.cr[6].lt {
	pc = 0x823FB58C; continue 'dispatch;
	}
	// 823FB570: 39210790  addi r9, r1, 0x790
	ctx.r[9].s64 = ctx.r[1].s64 + 1936;
	// 823FB574: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 823FB578: 7D6A4A14  add r11, r10, r9
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823FB57C: 39210200  addi r9, r1, 0x200
	ctx.r[9].s64 = ctx.r[1].s64 + 512;
	// 823FB580: 7D654C2E  lfsx f11, r5, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FB584: 48000020  b 0x823fb5a4
	pc = 0x823FB5A4; continue 'dispatch;
	// 823FB588: 4198000C  blt cr6, 0x823fb594
	if ctx.cr[6].lt {
	pc = 0x823FB594; continue 'dispatch;
	}
	// 823FB58C: C16105FC  lfs f11, 0x5fc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1532 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FB590: 4800000C  b 0x823fb59c
	pc = 0x823FB59C; continue 'dispatch;
	// 823FB594: 39210200  addi r9, r1, 0x200
	ctx.r[9].s64 = ctx.r[1].s64 + 512;
	// 823FB598: 7D6A4C2E  lfsx f11, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FB59C: 39610790  addi r11, r1, 0x790
	ctx.r[11].s64 = ctx.r[1].s64 + 1936;
	// 823FB5A0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823FB5A4: 39210200  addi r9, r1, 0x200
	ctx.r[9].s64 = ctx.r[1].s64 + 512;
	// 823FB5A8: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB5AC: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FB5B0: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 823FB5B4: 7D6A4C2E  lfsx f11, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FB5B8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FB5BC: EDAB682A  fadds f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 823FB5C0: 2F0A0400  cmpwi cr6, r10, 0x400
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1024, &mut ctx.xer);
	// 823FB5C4: 4198FF6C  blt cr6, 0x823fb530
	if ctx.cr[6].lt {
	pc = 0x823FB530; continue 'dispatch;
	}
	// 823FB5C8: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FB5CC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823FB5D0: 39610790  addi r11, r1, 0x790
	ctx.r[11].s64 = ctx.r[1].s64 + 1936;
	// 823FB5D4: 39400100  li r10, 0x100
	ctx.r[10].s64 = 256;
	// 823FB5D8: C00929A4  lfs f0, 0x29a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10660 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB5DC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FB5E0: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB5E4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FB5E8: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FB5EC: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB5F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FB5F4: 4082FFEC  bne 0x823fb5e0
	if !ctx.cr[0].eq {
	pc = 0x823FB5E0; continue 'dispatch;
	}
	// 823FB5F8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823FB5FC: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823FB600: 38810790  addi r4, r1, 0x790
	ctx.r[4].s64 = ctx.r[1].s64 + 1936;
	// 823FB604: 38610200  addi r3, r1, 0x200
	ctx.r[3].s64 = ctx.r[1].s64 + 512;
	// 823FB608: 816B37B4  lwz r11, 0x37b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FB60C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FB610: 4E800421  bctrl
	ctx.lr = 0x823FB614;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FB614: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 823FB618: 38C10600  addi r6, r1, 0x600
	ctx.r[6].s64 = ctx.r[1].s64 + 1536;
	// 823FB61C: 38BB0010  addi r5, r27, 0x10
	ctx.r[5].s64 = ctx.r[27].s64 + 16;
	// 823FB620: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 823FB624: 38610200  addi r3, r1, 0x200
	ctx.r[3].s64 = ctx.r[1].s64 + 512;
	// 823FB628: 48003321  bl 0x823fe948
	ctx.lr = 0x823FB62C;
	sub_823FE948(ctx, base);
	// 823FB62C: 38BB0014  addi r5, r27, 0x14
	ctx.r[5].s64 = ctx.r[27].s64 + 20;
	// 823FB630: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 823FB634: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 823FB638: 480032C9  bl 0x823fe900
	ctx.lr = 0x823FB63C;
	sub_823FE900(ctx, base);
	// 823FB63C: 38C10790  addi r6, r1, 0x790
	ctx.r[6].s64 = ctx.r[1].s64 + 1936;
	// 823FB640: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823FB644: 38980091  addi r4, r24, 0x91
	ctx.r[4].s64 = ctx.r[24].s64 + 145;
	// 823FB648: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 823FB64C: 48002315  bl 0x823fd960
	ctx.lr = 0x823FB650;
	sub_823FD960(ctx, base);
	// 823FB650: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB654: 38C10790  addi r6, r1, 0x790
	ctx.r[6].s64 = ctx.r[1].s64 + 1936;
	// 823FB658: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823FB65C: 38610790  addi r3, r1, 0x790
	ctx.r[3].s64 = ctx.r[1].s64 + 1936;
	// 823FB660: C02B2068  lfs f1, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FB664: 4800261D  bl 0x823fdc80
	ctx.lr = 0x823FB668;
	sub_823FDC80(ctx, base);
	// 823FB668: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823FB66C: 38610790  addi r3, r1, 0x790
	ctx.r[3].s64 = ctx.r[1].s64 + 1936;
	// 823FB670: 48002841  bl 0x823fdeb0
	ctx.lr = 0x823FB674;
	sub_823FDEB0(ctx, base);
	// 823FB674: 83E10CC4  lwz r31, 0xcc4(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(3268 as u32) ) } as u64;
	// 823FB678: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823FB67C: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FB680: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 823FB684: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 823FB688: 38610790  addi r3, r1, 0x790
	ctx.r[3].s64 = ctx.r[1].s64 + 1936;
	// 823FB68C: 48003095  bl 0x823fe720
	ctx.lr = 0x823FB690;
	sub_823FE720(ctx, base);
	// 823FB690: C0BD0034  lfs f5, 0x34(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 823FB694: C09E0000  lfs f4, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 823FB698: C07D0030  lfs f3, 0x30(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 823FB69C: C05A0000  lfs f2, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823FB6A0: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FB6A4: 48002C0D  bl 0x823fe2b0
	ctx.lr = 0x823FB6A8;
	sub_823FE2B0(ctx, base);
	// 823FB6A8: D03A0000  stfs f1, 0(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB6AC: 38210C70  addi r1, r1, 0xc70
	ctx.r[1].s64 = ctx.r[1].s64 + 3184;
	// 823FB6B0: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 823FB6B4: 48139A44  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FB6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FB6B8 size=528
    let mut pc: u32 = 0x823FB6B8;
    'dispatch: loop {
        match pc {
            0x823FB6B8 => {
    //   block [0x823FB6B8..0x823FB8C8)
	// 823FB6B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FB6BC: 481399ED  bl 0x825350a8
	ctx.lr = 0x823FB6C0;
	sub_82535080(ctx, base);
	// 823FB6C0: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 823FB6C4: 9421EF00  stwu r1, -0x1100(r1)
	ea = ctx.r[1].u32.wrapping_add(-4352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FB6C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FB6CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823FB6D0: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 823FB6D4: 3B9A0008  addi r28, r26, 8
	ctx.r[28].s64 = ctx.r[26].s64 + 8;
	// 823FB6D8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 823FB6DC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823FB6E0: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 823FB6E4: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FB6E8: 831F0048  lwz r24, 0x48(r31)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 823FB6EC: 7D6B5039  and. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FB6F0: 4082000C  bne 0x823fb6fc
	if !ctx.cr[0].eq {
	pc = 0x823FB6FC; continue 'dispatch;
	}
	// 823FB6F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FB6F8: 480001C8  b 0x823fb8c0
	pc = 0x823FB8C0; continue 'dispatch;
	// 823FB6FC: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 823FB700: 396000A0  li r11, 0xa0
	ctx.r[11].s64 = 160;
	// 823FB704: A9230000  lha r9, 0(r3)
	ctx.r[9].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 823FB708: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FB70C: 38630002  addi r3, r3, 2
	ctx.r[3].s64 = ctx.r[3].s64 + 2;
	// 823FB710: F9210068  std r9, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 823FB714: C8010068  lfd f0, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 823FB718: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FB71C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FB720: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB724: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FB728: 4181FFDC  bgt 0x823fb704
	if ctx.cr[0].gt {
	pc = 0x823FB704; continue 'dispatch;
	}
	// 823FB72C: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 823FB730: 38A000A0  li r5, 0xa0
	ctx.r[5].s64 = 160;
	// 823FB734: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FB738: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823FB73C: 48002105  bl 0x823fd840
	ctx.lr = 0x823FB740;
	sub_823FD840(ctx, base);
	// 823FB740: 3B3F002C  addi r25, r31, 0x2c
	ctx.r[25].s64 = ctx.r[31].s64 + 44;
	// 823FB744: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823FB748: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823FB74C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 823FB750: 4BFFFA49  bl 0x823fb198
	ctx.lr = 0x823FB754;
	sub_823FB198(ctx, base);
	// 823FB754: D03C0000  stfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB758: 837F0018  lwz r27, 0x18(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FB75C: 48002965  bl 0x823fe0c0
	ctx.lr = 0x823FB760;
	sub_823FE0C0(ctx, base);
	// 823FB760: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823FB764: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 823FB768: 38A00091  li r5, 0x91
	ctx.r[5].s64 = 145;
	// 823FB76C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823FB770: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823FB774: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 823FB778: 48001421  bl 0x823fcb98
	ctx.lr = 0x823FB77C;
	sub_823FCB98(ctx, base);
	// 823FB77C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 823FB780: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 823FB784: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823FB788: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823FB78C: 389B0091  addi r4, r27, 0x91
	ctx.r[4].s64 = ctx.r[27].s64 + 145;
	// 823FB790: 480021D1  bl 0x823fd960
	ctx.lr = 0x823FB794;
	sub_823FD960(ctx, base);
	// 823FB794: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB798: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 823FB79C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FB7A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823FB7A4: C02B2068  lfs f1, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FB7A8: 480024D9  bl 0x823fdc80
	ctx.lr = 0x823FB7AC;
	sub_823FDC80(ctx, base);
	// 823FB7AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FB7B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823FB7B4: 480026FD  bl 0x823fdeb0
	ctx.lr = 0x823FB7B8;
	sub_823FDEB0(ctx, base);
	// 823FB7B8: 38E10490  addi r7, r1, 0x490
	ctx.r[7].s64 = ctx.r[1].s64 + 1168;
	// 823FB7BC: 38C108A0  addi r6, r1, 0x8a0
	ctx.r[6].s64 = ctx.r[1].s64 + 2208;
	// 823FB7C0: 38A00009  li r5, 9
	ctx.r[5].s64 = 9;
	// 823FB7C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FB7C8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823FB7CC: 480022F5  bl 0x823fdac0
	ctx.lr = 0x823FB7D0;
	sub_823FDAC0(ctx, base);
	// 823FB7D0: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 823FB7D4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 823FB7D8: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 823FB7DC: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 823FB7E0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 823FB7E4: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 823FB7E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823FB7EC: 38A10490  addi r5, r1, 0x490
	ctx.r[5].s64 = ctx.r[1].s64 + 1168;
	// 823FB7F0: 388108A0  addi r4, r1, 0x8a0
	ctx.r[4].s64 = ctx.r[1].s64 + 2208;
	// 823FB7F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823FB7F8: 4BFFFC49  bl 0x823fb440
	ctx.lr = 0x823FB7FC;
	sub_823FB440(ctx, base);
	// 823FB7FC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 823FB800: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823FB804: C0210068  lfs f1, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FB808: 38A000E1  li r5, 0xe1
	ctx.r[5].s64 = 225;
	// 823FB80C: 7D660734  extsh r6, r11
	ctx.r[6].s64 = ctx.r[11].s16 as i64;
	// 823FB810: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 823FB814: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FB818: 48003CA1  bl 0x823ff4b8
	ctx.lr = 0x823FB81C;
	sub_823FF4B8(ctx, base);
	// 823FB81C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 823FB820: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB824: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 823FB828: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 823FB82C: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB830: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FB834: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 823FB838: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 823FB83C: 41820010  beq 0x823fb84c
	if ctx.cr[0].eq {
	pc = 0x823FB84C; continue 'dispatch;
	}
	// 823FB840: C05C0004  lfs f2, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823FB844: C0390000  lfs f1, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FB848: 48003B09  bl 0x823ff350
	ctx.lr = 0x823FB84C;
	sub_823FF350(ctx, base);
	// 823FB84C: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 823FB850: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FB854: 419A0068  beq cr6, 0x823fb8bc
	if ctx.cr[6].eq {
	pc = 0x823FB8BC; continue 'dispatch;
	}
	// 823FB858: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB85C: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB860: C1B80014  lfs f13, 0x14(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB864: C1580010  lfs f10, 0x10(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FB868: C1380018  lfs f9, 0x18(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FB86C: C178000C  lfs f11, 0xc(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FB870: C18B2C00  lfs f12, 0x2c00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11264 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FB874: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FB878: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 823FB87C: C11C0004  lfs f8, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823FB880: ED6B0232  fmuls f11, f11, f8
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[8].f64) as f32) as f64);
	// 823FB884: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FB888: C1AB7580  lfs f13, 0x7580(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30080 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB88C: EC004ABA  fmadds f0, f0, f10, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64 + ctx.f[9].f64) as f32) as f64);
	// 823FB890: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FB894: 40980008  bge cr6, 0x823fb89c
	if !ctx.cr[6].lt {
	pc = 0x823FB89C; continue 'dispatch;
	}
	// 823FB898: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 823FB89C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB8A0: C1AB204C  lfs f13, 0x204c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8268 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB8A4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FB8A8: 40990008  ble cr6, 0x823fb8b0
	if !ctx.cr[6].gt {
	pc = 0x823FB8B0; continue 'dispatch;
	}
	// 823FB8AC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 823FB8B0: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 823FB8B4: D17C0004  stfs f11, 4(r28)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FB8B8: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB8BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FB8C0: 38211100  addi r1, r1, 0x1100
	ctx.r[1].s64 = ctx.r[1].s64 + 4352;
	// 823FB8C4: 48139834  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FB8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FB8C8 size=496
    let mut pc: u32 = 0x823FB8C8;
    'dispatch: loop {
        match pc {
            0x823FB8C8 => {
    //   block [0x823FB8C8..0x823FBAB8)
	// 823FB8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FB8CC: 481397E9  bl 0x825350b4
	ctx.lr = 0x823FB8D0;
	sub_82535080(ctx, base);
	// 823FB8D0: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 823FB8D4: 4813A70D  bl 0x82535fe0
	ctx.lr = 0x823FB8D8;
	sub_82535FB0(ctx, base);
	// 823FB8D8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FB8DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FB8E0: C3630070  lfs f27, 0x70(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 823FB8E4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 823FB8E8: C383006C  lfs f28, 0x6c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 823FB8EC: C3E3002C  lfs f31, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FB8F0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823FB8F4: C3C3003C  lfs f30, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 823FB8F8: 3BFD0008  addi r31, r29, 8
	ctx.r[31].s64 = ctx.r[29].s64 + 8;
	// 823FB8FC: C3A30030  lfs f29, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 823FB900: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FB904: C3430040  lfs f26, 0x40(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 823FB908: 556A0738  rlwinm r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823FB90C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 823FB910: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 823FB914: 41980008  blt cr6, 0x823fb91c
	if ctx.cr[6].lt {
	pc = 0x823FB91C; continue 'dispatch;
	}
	// 823FB918: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FB91C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 823FB920: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FB924: 3B897590  addi r28, r9, 0x7590
	ctx.r[28].s64 = ctx.r[9].s64 + 30096;
	// 823FB928: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FB92C: 7C0BE42E  lfsx f0, r11, r28
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB930: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FB934: 409A000C  bne cr6, 0x823fb940
	if !ctx.cr[6].eq {
	pc = 0x823FB940; continue 'dispatch;
	}
	// 823FB938: D37D0004  stfs f27, 4(r29)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FB93C: 48000008  b 0x823fb944
	pc = 0x823FB944; continue 'dispatch;
	// 823FB940: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FB944: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FB948: E95E000A  lwa r10, 8(r30)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as i32) as i64;
	// 823FB94C: C00B76FC  lfs f0, 0x76fc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30460 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB950: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 823FB954: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823FB958: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FB95C: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FB960: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823FB964: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823FB968: C1AB76F8  lfs f13, 0x76f8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30456 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB96C: EC2C683C  fnmsubs f1, f12, f0, f13
	ctx.f[1].f64 = -(((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FB970: 48137B29  bl 0x82533498
	ctx.lr = 0x823FB974;
	sub_82533498(ctx, base);
	// 823FB974: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 823FB978: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB97C: C00B2C00  lfs f0, 0x2c00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB980: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FB984: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 823FB988: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 823FB98C: EDADEFFA  fmadds f13, f13, f31, f29
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64 + ctx.f[29].f64) as f32) as f64);
	// 823FB990: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 823FB994: C1AB1848  lfs f13, 0x1848(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB998: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB99C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FB9A0: 40980008  bge cr6, 0x823fb9a8
	if !ctx.cr[6].lt {
	pc = 0x823FB9A8; continue 'dispatch;
	}
	// 823FB9A4: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB9A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB9AC: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB9B0: C00B2ECC  lfs f0, 0x2ecc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11980 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB9B4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FB9B8: 40990008  ble cr6, 0x823fb9c0
	if !ctx.cr[6].gt {
	pc = 0x823FB9C0; continue 'dispatch;
	}
	// 823FB9BC: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB9C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB9C4: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB9C8: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FB9CC: C00B22E8  lfs f0, 0x22e8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8936 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB9D0: EC1C0032  fmuls f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FB9D4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FB9D8: 4199002C  bgt cr6, 0x823fba04
	if ctx.cr[6].gt {
	pc = 0x823FBA04; continue 'dispatch;
	}
	// 823FB9DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB9E0: C00B207C  lfs f0, 0x207c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB9E4: EC1C0032  fmuls f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FB9E8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FB9EC: 41980018  blt cr6, 0x823fba04
	if ctx.cr[6].lt {
	pc = 0x823FBA04; continue 'dispatch;
	}
	// 823FB9F0: EDADE02A  fadds f13, f13, f28
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[28].f64) as f32) as f64;
	// 823FB9F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB9F8: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB9FC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FBA00: 48000060  b 0x823fba60
	pc = 0x823FBA60; continue 'dispatch;
	// 823FBA04: FF1B6000  fcmpu cr6, f27, f12
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[12].f64);
	// 823FBA08: 40990010  ble cr6, 0x823fba18
	if !ctx.cr[6].gt {
	pc = 0x823FBA18; continue 'dispatch;
	}
	// 823FBA0C: FC00E090  fmr f0, f28
	ctx.f[0].f64 = ctx.f[28].f64;
	// 823FBA10: FD80D890  fmr f12, f27
	ctx.f[12].f64 = ctx.f[27].f64;
	// 823FBA14: 48000008  b 0x823fba1c
	pc = 0x823FBA1C; continue 'dispatch;
	// 823FBA18: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 823FBA1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FBA20: C16B76F4  lfs f11, 0x76f4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30452 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FBA24: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 823FBA28: 40980038  bge cr6, 0x823fba60
	if !ctx.cr[6].lt {
	pc = 0x823FBA60; continue 'dispatch;
	}
	// 823FBA2C: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FBA30: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FBA34: C18BBFFC  lfs f12, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FBA38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FBA3C: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FBA40: C18B1850  lfs f12, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FBA44: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 823FBA48: 40980018  bge cr6, 0x823fba60
	if !ctx.cr[6].lt {
	pc = 0x823FBA60; continue 'dispatch;
	}
	// 823FBA4C: FF0DE000  fcmpu cr6, f13, f28
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[28].f64);
	// 823FBA50: 4099000C  ble cr6, 0x823fba5c
	if !ctx.cr[6].gt {
	pc = 0x823FBA5C; continue 'dispatch;
	}
	// 823FBA54: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 823FBA58: 48000008  b 0x823fba60
	pc = 0x823FBA60; continue 'dispatch;
	// 823FBA5C: FC00E090  fmr f0, f28
	ctx.f[0].f64 = ctx.f[28].f64;
	// 823FBA60: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FBA64: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FBA68: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 823FBA6C: 41980008  blt cr6, 0x823fba74
	if ctx.cr[6].lt {
	pc = 0x823FBA74; continue 'dispatch;
	}
	// 823FBA70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FBA74: 395C0020  addi r10, r28, 0x20
	ctx.r[10].s64 = ctx.r[28].s64 + 32;
	// 823FBA78: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FBA7C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 823FBA80: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 823FBA84: 389D0014  addi r4, r29, 0x14
	ctx.r[4].s64 = ctx.r[29].s64 + 20;
	// 823FBA88: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 823FBA8C: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FBA90: D01D0010  stfs f0, 0x10(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 823FBA94: C03F0004  lfs f1, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FBA98: 48003BB1  bl 0x823ff648
	ctx.lr = 0x823FBA9C;
	sub_823FF648(ctx, base);
	// 823FBA9C: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FBAA0: EC0006B2  fmuls f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 823FBAA4: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FBAA8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 823FBAAC: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 823FBAB0: 4813A57D  bl 0x8253602c
	ctx.lr = 0x823FBAB4;
	sub_82535FFC(ctx, base);
	// 823FBAB4: 48139650  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FBAB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FBAB8 size=504
    let mut pc: u32 = 0x823FBAB8;
    'dispatch: loop {
        match pc {
            0x823FBAB8 => {
    //   block [0x823FBAB8..0x823FBCB0)
	// 823FBAB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FBABC: 481395DD  bl 0x82535098
	ctx.lr = 0x823FBAC0;
	sub_82535080(ctx, base);
	// 823FBAC0: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FBAC4: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 823FBAC8: B0E10074  sth r7, 0x74(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[7].u16 ) };
	// 823FBACC: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 823FBAD0: 90C10070  stw r6, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[6].u32 ) };
	// 823FBAD4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 823FBAD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FBADC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FBAE0: A31E0000  lhz r24, 0(r30)
	ctx.r[24].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FBAE4: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 823FBAE8: 8AFD0000  lbz r23, 0(r29)
	ctx.r[23].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FBAEC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 823FBAF0: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 823FBAF4: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 823FBAF8: 829F0004  lwz r20, 4(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FBAFC: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 823FBB00: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 823FBB04: 3ACB76B0  addi r22, r11, 0x76b0
	ctx.r[22].s64 = ctx.r[11].s64 + 30384;
	// 823FBB08: 93A1007C  stw r29, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	// 823FBB0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823FBB10: 7CBCB02E  lwzx r5, r28, r22
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 823FBB14: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823FBB18: 480042D1  bl 0x823ffde8
	ctx.lr = 0x823FBB1C;
	sub_823FFDE8(ctx, base);
	// 823FBB1C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FBB20: 394100E0  addi r10, r1, 0xe0
	ctx.r[10].s64 = ctx.r[1].s64 + 224;
	// 823FBB24: 7D7C512E  stwx r11, r28, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 823FBB28: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 823FBB2C: 2F1C0044  cmpwi cr6, r28, 0x44
	ctx.cr[6].compare_i32(ctx.r[28].s32, 68, &mut ctx.xer);
	// 823FBB30: 4198FFDC  blt cr6, 0x823fbb0c
	if ctx.cr[6].lt {
	pc = 0x823FBB0C; continue 'dispatch;
	}
	// 823FBB34: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 823FBB38: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 823FBB3C: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 823FBB40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FBB44: 4BFFFD85  bl 0x823fb8c8
	ctx.lr = 0x823FBB48;
	sub_823FB8C8(ctx, base);
	// 823FBB48: A17F005C  lhz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 823FBB4C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823FBB50: 409A0028  bne cr6, 0x823fbb78
	if !ctx.cr[6].eq {
	pc = 0x823FBB78; continue 'dispatch;
	}
	// 823FBB54: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 823FBB58: 814101E4  lwz r10, 0x1e4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(484 as u32) ) } as u64;
	// 823FBB5C: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 823FBB60: A11F003A  lhz r8, 0x3a(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(58 as u32) ) } as u64;
	// 823FBB64: A0FF0038  lhz r7, 0x38(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 823FBB68: C05F0034  lfs f2, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823FBB6C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FBB70: C02100A0  lfs f1, 0xa0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FBB74: 48003DFD  bl 0x823ff970
	ctx.lr = 0x823FBB78;
	sub_823FF970(ctx, base);
	// 823FBB78: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 823FBB7C: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 823FBB80: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 823FBB84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FBB88: 48003D41  bl 0x823ff8c8
	ctx.lr = 0x823FBB8C;
	sub_823FF8C8(ctx, base);
	// 823FBB8C: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 823FBB90: C00100A0  lfs f0, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FBB94: 3F808288  lis r28, -0x7d78
	ctx.r[28].s64 = -2105016320;
	// 823FBB98: B17A0000  sth r11, 0(r26)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 823FBB9C: 816101EC  lwz r11, 0x1ec(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(492 as u32) ) } as u64;
	// 823FBBA0: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FBBA4: A17F005C  lhz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 823FBBA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823FBBAC: 409A0028  bne cr6, 0x823fbbd4
	if !ctx.cr[6].eq {
	pc = 0x823FBBD4; continue 'dispatch;
	}
	// 823FBBB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823FBBB4: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823FBBB8: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 823FBBBC: 387F006C  addi r3, r31, 0x6c
	ctx.r[3].s64 = ctx.r[31].s64 + 108;
	// 823FBBC0: B17F005C  sth r11, 0x5c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u16 ) };
	// 823FBBC4: 817C37B4  lwz r11, 0x37b4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FBBC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBBCC: 4E800421  bctrl
	ctx.lr = 0x823FBBD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBBD0: 480000A8  b 0x823fbc78
	pc = 0x823FBC78; continue 'dispatch;
	// 823FBBD4: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823FBBD8: B37F005C  sth r27, 0x5c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[27].u16 ) };
	// 823FBBDC: 3969FFFF  addi r11, r9, -1
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	// 823FBBE0: B31E0000  sth r24, 0(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[24].u16 ) };
	// 823FBBE4: 9AFD0000  stb r23, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[23].u8 ) };
	// 823FBBE8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FBBEC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 823FBBF0: A17F005E  lhz r11, 0x5e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(94 as u32) ) } as u64;
	// 823FBBF4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823FBBF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FBBFC: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823FBC00: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FBC04: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FBC08: C00B1850  lfs f0, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FBC0C: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 823FBC10: 409A0068  bne cr6, 0x823fbc78
	if !ctx.cr[6].eq {
	pc = 0x823FBC78; continue 'dispatch;
	}
	// 823FBC14: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 823FBC18: B37F005E  sth r27, 0x5e(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(94 as u32), ctx.r[27].u16 ) };
	// 823FBC1C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FBC20: 40990058  ble cr6, 0x823fbc78
	if !ctx.cr[6].gt {
	pc = 0x823FBC78; continue 'dispatch;
	}
	// 823FBC24: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	// 823FBC28: A90A0000  lha r8, 0(r10)
	ctx.r[8].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 823FBC2C: 7D6707B4  extsw r7, r11
	ctx.r[7].s64 = ctx.r[11].s32 as i64;
	// 823FBC30: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823FBC34: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 823FBC38: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 823FBC3C: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 823FBC40: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 823FBC44: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823FBC48: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 823FBC4C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823FBC50: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 823FBC54: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823FBC58: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FBC5C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FBC60: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 823FBC64: D9A10068  stfd f13, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[13].u64 ) };
	// 823FBC68: A101006E  lhz r8, 0x6e(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(110 as u32) ) } as u64;
	// 823FBC6C: B10A0000  sth r8, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 823FBC70: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 823FBC74: 4198FFB4  blt cr6, 0x823fbc28
	if ctx.cr[6].lt {
	pc = 0x823FBC28; continue 'dispatch;
	}
	// 823FBC78: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FBC7C: 38A00104  li r5, 0x104
	ctx.r[5].s64 = 260;
	// 823FBC80: 817C37B4  lwz r11, 0x37b4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FBC84: 38940808  addi r4, r20, 0x808
	ctx.r[4].s64 = ctx.r[20].s64 + 2056;
	// 823FBC88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBC8C: 4E800421  bctrl
	ctx.lr = 0x823FBC90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBC90: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823FBC94: 38A00104  li r5, 0x104
	ctx.r[5].s64 = 260;
	// 823FBC98: 817C37B4  lwz r11, 0x37b4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FBC9C: 3894090C  addi r4, r20, 0x90c
	ctx.r[4].s64 = ctx.r[20].s64 + 2316;
	// 823FBCA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBCA4: 4E800421  bctrl
	ctx.lr = 0x823FBCA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBCA8: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 823FBCAC: 4813943C  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FBCB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FBCB0 size=464
    let mut pc: u32 = 0x823FBCB0;
    'dispatch: loop {
        match pc {
            0x823FBCB0 => {
    //   block [0x823FBCB0..0x823FBE80)
	// 823FBCB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FBCB4: 48139405  bl 0x825350b8
	ctx.lr = 0x823FBCB8;
	sub_82535080(ctx, base);
	// 823FBCB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FBCBC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823FBCC0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 823FBCC4: 409A000C  bne cr6, 0x823fbcd0
	if !ctx.cr[6].eq {
	pc = 0x823FBCD0; continue 'dispatch;
	}
	// 823FBCC8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FBCCC: 480001AC  b 0x823fbe78
	pc = 0x823FBE78; continue 'dispatch;
	// 823FBCD0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823FBCD4: 3FA08288  lis r29, -0x7d78
	ctx.r[29].s64 = -2105016320;
	// 823FBCD8: 38800074  li r4, 0x74
	ctx.r[4].s64 = 116;
	// 823FBCDC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FBCE0: 93DC0000  stw r30, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823FBCE4: 817D37A8  lwz r11, 0x37a8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FBCE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBCEC: 4E800421  bctrl
	ctx.lr = 0x823FBCF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBCF0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823FBCF4: 4182FFD4  beq 0x823fbcc8
	if ctx.cr[0].eq {
	pc = 0x823FBCC8; continue 'dispatch;
	}
	// 823FBCF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FBCFC: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823FBD00: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823FBD04: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823FBD08: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 823FBD0C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 823FBD10: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 823FBD14: 38600284  li r3, 0x284
	ctx.r[3].s64 = 644;
	// 823FBD18: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 823FBD1C: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FBD20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FBD24: C16A7700  lfs f11, 0x7700(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(30464 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FBD28: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FBD2C: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 823FBD30: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 823FBD34: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 823FBD38: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 823FBD3C: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 823FBD40: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 823FBD44: C18B2808  lfs f12, 0x2808(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10248 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FBD48: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FBD4C: C14A2094  lfs f10, 0x2094(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8340 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FBD50: 39400064  li r10, 0x64
	ctx.r[10].s64 = 100;
	// 823FBD54: D19F0020  stfs f12, 0x20(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 823FBD58: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 823FBD5C: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 823FBD60: B3DF0038  sth r30, 0x38(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u16 ) };
	// 823FBD64: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 823FBD68: B3DF003A  sth r30, 0x3a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(58 as u32), ctx.r[30].u16 ) };
	// 823FBD6C: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FBD70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823FBD74: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 823FBD78: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 823FBD7C: D1BF0030  stfs f13, 0x30(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 823FBD80: B3DF005E  sth r30, 0x5e(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(94 as u32), ctx.r[30].u16 ) };
	// 823FBD84: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 823FBD88: B15F0060  sth r10, 0x60(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u16 ) };
	// 823FBD8C: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 823FBD90: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 823FBD94: B17F005C  sth r11, 0x5c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u16 ) };
	// 823FBD98: D17F004C  stfs f11, 0x4c(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 823FBD9C: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 823FBDA0: D1BF0050  stfs f13, 0x50(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823FBDA4: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 823FBDA8: D15F006C  stfs f10, 0x6c(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 823FBDAC: 817D37A8  lwz r11, 0x37a8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FBDB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBDB4: 4E800421  bctrl
	ctx.lr = 0x823FBDB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBDB8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBDBC: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 823FBDC0: 4182FF08  beq 0x823fbcc8
	if ctx.cr[0].eq {
	pc = 0x823FBCC8; continue 'dispatch;
	}
	// 823FBDC4: 817D37A8  lwz r11, 0x37a8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FBDC8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 823FBDCC: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 823FBDD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBDD4: 4E800421  bctrl
	ctx.lr = 0x823FBDD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBDD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBDDC: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 823FBDE0: 4182FEE8  beq 0x823fbcc8
	if ctx.cr[0].eq {
	pc = 0x823FBCC8; continue 'dispatch;
	}
	// 823FBDE4: 817D37A8  lwz r11, 0x37a8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FBDE8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 823FBDEC: 38600041  li r3, 0x41
	ctx.r[3].s64 = 65;
	// 823FBDF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBDF4: 4E800421  bctrl
	ctx.lr = 0x823FBDF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBDF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBDFC: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 823FBE00: 4182FEC8  beq 0x823fbcc8
	if ctx.cr[0].eq {
	pc = 0x823FBCC8; continue 'dispatch;
	}
	// 823FBE04: 817D37A8  lwz r11, 0x37a8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FBE08: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 823FBE0C: 38600041  li r3, 0x41
	ctx.r[3].s64 = 65;
	// 823FBE10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBE14: 4E800421  bctrl
	ctx.lr = 0x823FBE18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBE18: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBE1C: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 823FBE20: 4182FEA8  beq 0x823fbcc8
	if ctx.cr[0].eq {
	pc = 0x823FBCC8; continue 'dispatch;
	}
	// 823FBE24: 817D37A8  lwz r11, 0x37a8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FBE28: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 823FBE2C: 38600066  li r3, 0x66
	ctx.r[3].s64 = 102;
	// 823FBE30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBE34: 4E800421  bctrl
	ctx.lr = 0x823FBE38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBE38: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBE3C: 907F0014  stw r3, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 823FBE40: 4182FE88  beq 0x823fbcc8
	if ctx.cr[0].eq {
	pc = 0x823FBCC8; continue 'dispatch;
	}
	// 823FBE44: 817D37A8  lwz r11, 0x37a8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FBE48: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 823FBE4C: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 823FBE50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBE54: 4E800421  bctrl
	ctx.lr = 0x823FBE58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBE58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBE5C: 907F0018  stw r3, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 823FBE60: 4182FE68  beq 0x823fbcc8
	if ctx.cr[0].eq {
	pc = 0x823FBCC8; continue 'dispatch;
	}
	// 823FBE64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FBE68: 48004081  bl 0x823ffee8
	ctx.lr = 0x823FBE6C;
	sub_823FFEE8(ctx, base);
	// 823FBE6C: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 823FBE70: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 823FBE74: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 823FBE78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823FBE7C: 4813928C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FBE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FBE80 size=236
    let mut pc: u32 = 0x823FBE80;
    'dispatch: loop {
        match pc {
            0x823FBE80 => {
    //   block [0x823FBE80..0x823FBF6C)
	// 823FBE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FBE84: 48139239  bl 0x825350bc
	ctx.lr = 0x823FBE88;
	sub_82535080(ctx, base);
	// 823FBE88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FBE8C: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FBE90: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBE94: 418200CC  beq 0x823fbf60
	if ctx.cr[0].eq {
	pc = 0x823FBF60; continue 'dispatch;
	}
	// 823FBE98: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FBE9C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823FBEA0: 3FC08288  lis r30, -0x7d78
	ctx.r[30].s64 = -2105016320;
	// 823FBEA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBEA8: 41820014  beq 0x823fbebc
	if ctx.cr[0].eq {
	pc = 0x823FBEBC; continue 'dispatch;
	}
	// 823FBEAC: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FBEB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBEB4: 4E800421  bctrl
	ctx.lr = 0x823FBEB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBEB8: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 823FBEBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FBEC0: 480040A9  bl 0x823fff68
	ctx.lr = 0x823FBEC4;
	sub_823FFF68(ctx, base);
	// 823FBEC4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FBEC8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBECC: 41820014  beq 0x823fbee0
	if ctx.cr[0].eq {
	pc = 0x823FBEE0; continue 'dispatch;
	}
	// 823FBED0: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FBED4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBED8: 4E800421  bctrl
	ctx.lr = 0x823FBEDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBEDC: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 823FBEE0: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823FBEE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBEE8: 41820014  beq 0x823fbefc
	if ctx.cr[0].eq {
	pc = 0x823FBEFC; continue 'dispatch;
	}
	// 823FBEEC: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FBEF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBEF4: 4E800421  bctrl
	ctx.lr = 0x823FBEF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBEF8: 93BF0010  stw r29, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 823FBEFC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823FBF00: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBF04: 41820014  beq 0x823fbf18
	if ctx.cr[0].eq {
	pc = 0x823FBF18; continue 'dispatch;
	}
	// 823FBF08: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FBF0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBF10: 4E800421  bctrl
	ctx.lr = 0x823FBF14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBF14: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 823FBF18: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FBF1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBF20: 41820014  beq 0x823fbf34
	if ctx.cr[0].eq {
	pc = 0x823FBF34; continue 'dispatch;
	}
	// 823FBF24: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FBF28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBF2C: 4E800421  bctrl
	ctx.lr = 0x823FBF30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBF30: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 823FBF34: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FBF38: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBF3C: 41820014  beq 0x823fbf50
	if ctx.cr[0].eq {
	pc = 0x823FBF50; continue 'dispatch;
	}
	// 823FBF40: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FBF44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBF48: 4E800421  bctrl
	ctx.lr = 0x823FBF4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBF4C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 823FBF50: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FBF54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FBF58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBF5C: 4E800421  bctrl
	ctx.lr = 0x823FBF60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBF60: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FBF64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FBF68: 481391A4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FBF70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FBF70 size=856
    let mut pc: u32 = 0x823FBF70;
    'dispatch: loop {
        match pc {
            0x823FBF70 => {
    //   block [0x823FBF70..0x823FC2C8)
	// 823FBF70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FBF74: 48139139  bl 0x825350ac
	ctx.lr = 0x823FBF78;
	sub_82535080(ctx, base);
	// 823FBF78: DBA1FFA8  stfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[29].u64 ) };
	// 823FBF7C: DBC1FFB0  stfd f30, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 823FBF80: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 823FBF84: 9421F5F0  stwu r1, -0xa10(r1)
	ea = ctx.r[1].u32.wrapping_add(-2576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FBF88: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 823FBF8C: 3FE08288  lis r31, -0x7d78
	ctx.r[31].s64 = -2105016320;
	// 823FBF90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FBF94: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 823FBF98: 7CBB0E70  srawi r27, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 823FBF9C: D0410A64  stfs f2, 0xa64(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2660 as u32), tmp.u32 ) };
	// 823FBFA0: D3A10A6C  stfs f29, 0xa6c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2668 as u32), tmp.u32 ) };
	// 823FBFA4: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 823FBFA8: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 823FBFAC: 817F37B0  lwz r11, 0x37b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FBFB0: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 823FBFB4: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 823FBFB8: 38A00404  li r5, 0x404
	ctx.r[5].s64 = 1028;
	// 823FBFBC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FBFC0: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 823FBFC4: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 823FBFC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBFCC: 4E800421  bctrl
	ctx.lr = 0x823FBFD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBFD0: 817F37B0  lwz r11, 0x37b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FBFD4: 38A00404  li r5, 0x404
	ctx.r[5].s64 = 1028;
	// 823FBFD8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FBFDC: 386105B0  addi r3, r1, 0x5b0
	ctx.r[3].s64 = ctx.r[1].s64 + 1456;
	// 823FBFE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBFE4: 4E800421  bctrl
	ctx.lr = 0x823FBFE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBFE8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823FBFEC: 4099009C  ble cr6, 0x823fc088
	if !ctx.cr[6].gt {
	pc = 0x823FC088; continue 'dispatch;
	}
	// 823FBFF0: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 823FBFF4: 3CC08273  lis r6, -0x7d8d
	ctx.r[6].s64 = -2106392576;
	// 823FBFF8: 3D008273  lis r8, -0x7d8d
	ctx.r[8].s64 = -2106392576;
	// 823FBFFC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 823FC000: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823FC004: C005BFFC  lfs f0, -0x4004(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC008: 7C9DE050  subf r4, r29, r28
	ctx.r[4].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 823FC00C: 80C6D6E4  lwz r6, -0x291c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-10524 as u32) ) } as u64;
	// 823FC010: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 823FC014: 80E8D6E8  lwz r7, -0x2918(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10520 as u32) ) } as u64;
	// 823FC018: C189AC38  lfs f12, -0x53c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-21448 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FC01C: ED5F002A  fadds f10, f31, f0
	ctx.f[10].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FC020: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FC024: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 823FC028: ED6B033A  fmadds f11, f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 823FC02C: 7DA45C2E  lfsx f13, r4, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FC030: 38A101A0  addi r5, r1, 0x1a0
	ctx.r[5].s64 = ctx.r[1].s64 + 416;
	// 823FC034: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FC038: 386105B0  addi r3, r1, 0x5b0
	ctx.r[3].s64 = ctx.r[1].s64 + 1456;
	// 823FC03C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FC040: EFFFF02A  fadds f31, f31, f30
	ctx.f[31].f64 = ((ctx.f[31].f64 + ctx.f[30].f64) as f32) as f64;
	// 823FC044: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FC048: FD40501E  fctiwz f10, f10
	ctx.f[10].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 823FC04C: 7D404FAE  stfiwx f10, 0, r9
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 823FC050: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 823FC054: FD60581E  fctiwz f11, f11
	ctx.f[11].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 823FC058: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 823FC05C: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FC060: 7D6047AE  stfiwx f11, 0, r8
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 823FC064: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FC068: 550815BA  rlwinm r8, r8, 2, 0x16, 0x1d
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x3FFFFFFFu64;
	// 823FC06C: 7D683C2E  lfsx f11, r8, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FC070: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FC074: 7D692D2E  stfsx f11, r9, r5
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32), tmp.u32) };
	// 823FC078: 7D68342E  lfsx f11, r8, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FC07C: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FC080: 7DA91D2E  stfsx f13, r9, r3
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[3].u32), tmp.u32) };
	// 823FC084: 4082FF98  bne 0x823fc01c
	if !ctx.cr[0].eq {
	pc = 0x823FC01C; continue 'dispatch;
	}
	// 823FC088: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 823FC08C: 388105B0  addi r4, r1, 0x5b0
	ctx.r[4].s64 = ctx.r[1].s64 + 1456;
	// 823FC090: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 823FC094: 480019ED  bl 0x823fda80
	ctx.lr = 0x823FC098;
	sub_823FDA80(ctx, base);
	// 823FC098: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823FC09C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FC0A0: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 823FC0A4: C18A1850  lfs f12, 0x1850(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FC0A8: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FC0AC: 40990020  ble cr6, 0x823fc0cc
	if !ctx.cr[6].gt {
	pc = 0x823FC0CC; continue 'dispatch;
	}
	// 823FC0B0: 7F6B07B4  extsw r11, r27
	ctx.r[11].s64 = ctx.r[27].s32 as i64;
	// 823FC0B4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 823FC0B8: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823FC0BC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FC0C0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FC0C4: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 823FC0C8: 48000008  b 0x823fc0d0
	pc = 0x823FC0D0; continue 'dispatch;
	// 823FC0CC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 823FC0D0: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 823FC0D4: 39410500  addi r10, r1, 0x500
	ctx.r[10].s64 = ctx.r[1].s64 + 1280;
	// 823FC0D8: 39210910  addi r9, r1, 0x910
	ctx.r[9].s64 = ctx.r[1].s64 + 2320;
	// 823FC0DC: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 823FC0E0: 39600028  li r11, 0x28
	ctx.r[11].s64 = 40;
	// 823FC0E4: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FC0E8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FC0EC: ED6D02F2  fmuls f11, f13, f11
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FC0F0: C1480000  lfs f10, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FC0F4: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FC0F8: C1290000  lfs f9, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FC0FC: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FC100: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FC104: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FC108: ED6A5B3A  fmadds f11, f10, f12, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 823FC10C: D1670000  stfs f11, 0(r7)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FC110: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FC114: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FC118: ED690372  fmuls f11, f9, f13
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FC11C: C1480000  lfs f10, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FC120: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FC124: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FC128: ED6A5B3A  fmadds f11, f10, f12, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 823FC12C: D1670000  stfs f11, 0(r7)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FC130: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FC134: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FC138: 4082FFAC  bne 0x823fc0e4
	if !ctx.cr[0].eq {
	pc = 0x823FC0E4; continue 'dispatch;
	}
	// 823FC13C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FC140: C00B2808  lfs f0, 0x2808(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC144: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 823FC148: 419A00F8  beq cr6, 0x823fc240
	if ctx.cr[6].eq {
	pc = 0x823FC240; continue 'dispatch;
	}
	// 823FC14C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FC150: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823FC154: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 823FC158: 38E10A64  addi r7, r1, 0xa64
	ctx.r[7].s64 = ctx.r[1].s64 + 2660;
	// 823FC15C: 38C10A64  addi r6, r1, 0xa64
	ctx.r[6].s64 = ctx.r[1].s64 + 2660;
	// 823FC160: C00B2078  lfs f0, 0x2078(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8312 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC164: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 823FC168: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823FC16C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FC2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FC2C8 size=256
    let mut pc: u32 = 0x823FC2C8;
    'dispatch: loop {
        match pc {
            0x823FC2C8 => {
    //   block [0x823FC2C8..0x823FC3C8)
	// 823FC2C8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 823FC2CC: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 823FC2D0: 7C860734  extsh r6, r4
	ctx.r[6].s64 = ctx.r[4].s16 as i64;
	// 823FC2D4: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 823FC2D8: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC2DC: A0E30004  lhz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FC2E0: A12A0000  lhz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC2E4: 888B0000  lbz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC2E8: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 823FC2EC: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FC2F0: 4082000C  bne 0x823fc2fc
	if !ctx.cr[0].eq {
	pc = 0x823FC2FC; continue 'dispatch;
	}
	// 823FC2F4: 98C90000  stb r6, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u8 ) };
	// 823FC2F8: 4800001C  b 0x823fc314
	pc = 0x823FC314; continue 'dispatch;
	// 823FC2FC: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC300: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 823FC304: 8BE90000  lbz r31, 0(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC308: 7C884030  slw r8, r4, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[4].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 823FC30C: 7D08FB78  or r8, r8, r31
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[31].u64;
	// 823FC310: 99090000  stb r8, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 823FC314: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC318: 7D082A14  add r8, r8, r5
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[5].u64;
	// 823FC31C: 5508063E  clrlwi r8, r8, 0x18
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 823FC320: 2B080008  cmplwi cr6, r8, 8
	ctx.cr[6].compare_u32(ctx.r[8].u32, 8 as u32, &mut ctx.xer);
	// 823FC324: 990B0000  stb r8, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 823FC328: 40990060  ble cr6, 0x823fc388
	if !ctx.cr[6].gt {
	pc = 0x823FC388; continue 'dispatch;
	}
	// 823FC32C: A10A0000  lhz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC330: 54E7043E  clrlwi r7, r7, 0x10
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x0000FFFFu64;
	// 823FC334: 38880001  addi r4, r8, 1
	ctx.r[4].s64 = ctx.r[8].s64 + 1;
	// 823FC338: 39090001  addi r8, r9, 1
	ctx.r[8].s64 = ctx.r[9].s64 + 1;
	// 823FC33C: 5489043E  clrlwi r9, r4, 0x10
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x0000FFFFu64;
	// 823FC340: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 823FC344: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 823FC348: B12A0000  sth r9, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 823FC34C: 41980010  blt cr6, 0x823fc35c
	if ctx.cr[6].lt {
	pc = 0x823FC35C; continue 'dispatch;
	}
	// 823FC350: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FC354: B12A0000  sth r9, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 823FC358: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC35C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC360: 7CC90734  extsh r9, r6
	ctx.r[9].s64 = ctx.r[6].s16 as i64;
	// 823FC364: 7D4A2850  subf r10, r10, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 823FC368: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 823FC36C: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 823FC370: 7D2A5630  sraw r10, r9, r10
	tmp.u32 = ctx.r[10].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 823FC374: 99480000  stb r10, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 823FC378: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC37C: 394A00F8  addi r10, r10, 0xf8
	ctx.r[10].s64 = ctx.r[10].s64 + 248;
	// 823FC380: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 823FC384: 4800003C  b 0x823fc3c0
	pc = 0x823FC3C0; continue 'dispatch;
	// 823FC388: 5509063E  clrlwi r9, r8, 0x18
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 823FC38C: 2B090008  cmplwi cr6, r9, 8
	ctx.cr[6].compare_u32(ctx.r[9].u32, 8 as u32, &mut ctx.xer);
	// 823FC390: 409A0030  bne cr6, 0x823fc3c0
	if !ctx.cr[6].eq {
	pc = 0x823FC3C0; continue 'dispatch;
	}
	// 823FC394: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FC398: 54E8043E  clrlwi r8, r7, 0x10
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x0000FFFFu64;
	// 823FC39C: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 823FC3A0: A16A0000  lhz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC3A4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823FC3A8: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 823FC3AC: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 823FC3B0: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823FC3B4: B16A0000  sth r11, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 823FC3B8: 41980008  blt cr6, 0x823fc3c0
	if ctx.cr[6].lt {
	pc = 0x823FC3C0; continue 'dispatch;
	}
	// 823FC3BC: B12A0000  sth r9, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 823FC3C0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 823FC3C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FC3C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FC3C8 size=24
    let mut pc: u32 = 0x823FC3C8;
    'dispatch: loop {
        match pc {
            0x823FC3C8 => {
    //   block [0x823FC3C8..0x823FC3E0)
	// 823FC3C8: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 823FC3CC: 41980008  blt cr6, 0x823fc3d4
	if ctx.cr[6].lt {
	pc = 0x823FC3D4; continue 'dispatch;
	}
	// 823FC3D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823FC3D4: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FC3D8: 7C2B1C2E  lfsx f1, r11, r3
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FC3DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FC3E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FC3E0 size=32
    let mut pc: u32 = 0x823FC3E0;
    'dispatch: loop {
        match pc {
            0x823FC3E0 => {
    //   block [0x823FC3E0..0x823FC400)
	// 823FC3E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FC3E4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 823FC3E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FC3EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FC3F0: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FC3F4: C00B8CB0  lfs f0, -0x7350(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC3F8: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 823FC3FC: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FC400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FC400 size=84
    let mut pc: u32 = 0x823FC400;
    'dispatch: loop {
        match pc {
            0x823FC400 => {
    //   block [0x823FC400..0x823FC454)
	// 823FC400: C1890000  lfs f12, 0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FC404: C1690004  lfs f11, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FC408: 8121FFF0  lwz r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 823FC40C: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC410: 39640004  addi r11, r4, 4
	ctx.r[11].s64 = ctx.r[4].s64 + 4;
	// 823FC414: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 823FC418: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 823FC41C: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FC420: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FC424: EC0A5828  fsubs f0, f10, f11
	ctx.f[0].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 823FC428: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FC42C: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 823FC430: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 823FC434: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 823FC438: 4098000C  bge cr6, 0x823fc444
	if !ctx.cr[6].lt {
	pc = 0x823FC444; continue 'dispatch;
	}
	// 823FC43C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 823FC440: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 823FC444: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823FC448: 7F0A2800  cmpw cr6, r10, r5
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[5].s32, &mut ctx.xer);
	// 823FC44C: 4198FFC0  blt cr6, 0x823fc40c
	if ctx.cr[6].lt {
	pc = 0x823FC40C; continue 'dispatch;
	}
	// 823FC450: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FC458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FC458 size=648
    let mut pc: u32 = 0x823FC458;
    'dispatch: loop {
        match pc {
            0x823FC458 => {
    //   block [0x823FC458..0x823FC6E0)
	// 823FC458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FC45C: 48138C45  bl 0x825350a0
	ctx.lr = 0x823FC460;
	sub_82535080(ctx, base);
	// 823FC460: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FC464: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FC468: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 823FC46C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 823FC470: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 823FC474: 7D565378  mr r22, r10
	ctx.r[22].u64 = ctx.r[10].u64;
	// 823FC478: C08B8CB4  lfs f4, -0x734c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29516 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 823FC47C: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 823FC480: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FC484: 4099004C  ble cr6, 0x823fc4d0
	if !ctx.cr[6].gt {
	pc = 0x823FC4D0; continue 'dispatch;
	}
	// 823FC488: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FC48C: 3C807F7F  lis r4, 0x7f7f
	ctx.r[4].s64 = 2139029504;
	// 823FC490: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 823FC494: 6084FFEE  ori r4, r4, 0xffee
	ctx.r[4].u64 = ctx.r[4].u64 | 65518;
	// 823FC498: 556AF0BF  rlwinm. r10, r11, 0x1e, 2, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FC49C: 41820014  beq 0x823fc4b0
	if ctx.cr[0].eq {
	pc = 0x823FC4B0; continue 'dispatch;
	}
	// 823FC4A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 823FC4A4: 90890000  stw r4, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 823FC4A8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FC4AC: 4200FFF8  bdnz 0x823fc4a4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x823FC4A4; continue 'dispatch;
	}
	// 823FC4B0: 556BF0BF  rlwinm. r11, r11, 0x1e, 2, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FC4B4: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 823FC4B8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FC4BC: 41820014  beq 0x823fc4d0
	if ctx.cr[0].eq {
	pc = 0x823FC4D0; continue 'dispatch;
	}
	// 823FC4C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FC4C4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823FC4C8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FC4CC: 4200FFF8  bdnz 0x823fc4c4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x823FC4C4; continue 'dispatch;
	}
	// 823FC4D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FC4D4: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 823FC4D8: 409900A4  ble cr6, 0x823fc57c
	if !ctx.cr[6].gt {
	pc = 0x823FC57C; continue 'dispatch;
	}
	// 823FC4DC: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FC4E0: C19B0000  lfs f12, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FC4E4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823FC4E8: C17B0004  lfs f11, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FC4EC: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823FC4F0: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC4F4: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FC4F8: C1430004  lfs f10, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FC4FC: C124FFFC  lfs f9, -4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FC500: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 823FC504: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FC508: EC0B5028  fsubs f0, f11, f10
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 823FC50C: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FC510: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 823FC514: 4098005C  bge cr6, 0x823fc570
	if !ctx.cr[6].lt {
	pc = 0x823FC570; continue 'dispatch;
	}
	// 823FC518: 3565FFFF  addic. r11, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FC51C: 40810040  ble 0x823fc55c
	if !ctx.cr[0].gt {
	pc = 0x823FC55C; continue 'dispatch;
	}
	// 823FC520: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FC524: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 823FC528: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 823FC52C: 7DAAFC2E  lfsx f13, r10, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FC530: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FC534: 41990028  bgt cr6, 0x823fc55c
	if ctx.cr[6].gt {
	pc = 0x823FC55C; continue 'dispatch;
	}
	// 823FC538: 3BE10058  addi r31, r1, 0x58
	ctx.r[31].s64 = ctx.r[1].s64 + 88;
	// 823FC53C: 3BC10054  addi r30, r1, 0x54
	ctx.r[30].s64 = ctx.r[1].s64 + 84;
	// 823FC540: 3BA1005C  addi r29, r1, 0x5c
	ctx.r[29].s64 = ctx.r[1].s64 + 92;
	// 823FC544: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FC548: 7FEAF82E  lwzx r31, r10, r31
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823FC54C: 7DAAF52E  stfsx f13, r10, r30
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32), tmp.u32) };
	// 823FC550: 7FEAE92E  stwx r31, r10, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32), ctx.r[31].u32) };
	// 823FC554: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 823FC558: 4181FFD0  bgt 0x823fc528
	if ctx.cr[0].gt {
	pc = 0x823FC528; continue 'dispatch;
	}
	// 823FC55C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FC560: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823FC564: 3BE10058  addi r31, r1, 0x58
	ctx.r[31].s64 = ctx.r[1].s64 + 88;
	// 823FC568: 7C0B552E  stfsx f0, r11, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 823FC56C: 7D2BF92E  stwx r9, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[9].u32) };
	// 823FC570: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823FC574: 7F093000  cmpw cr6, r9, r6
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FC578: 4198FF78  blt cr6, 0x823fc4f0
	if ctx.cr[6].lt {
	pc = 0x823FC4F0; continue 'dispatch;
	}
	// 823FC57C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FC580: 40990140  ble cr6, 0x823fc6c0
	if !ctx.cr[6].gt {
	pc = 0x823FC6C0; continue 'dispatch;
	}
	// 823FC584: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FC588: 8381011C  lwz r28, 0x11c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 823FC58C: 3B410058  addi r26, r1, 0x58
	ctx.r[26].s64 = ctx.r[1].s64 + 88;
	// 823FC590: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 823FC594: C0AB1850  lfs f5, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 823FC598: 83BA0000  lwz r29, 0(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC59C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823FC5A0: 7F1D3040  cmplw cr6, r29, r6
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[6].u32, &mut ctx.xer);
	// 823FC5A4: 41980008  blt cr6, 0x823fc5ac
	if ctx.cr[6].lt {
	pc = 0x823FC5AC; continue 'dispatch;
	}
	// 823FC5A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FC5AC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FC5B0: C11B0004  lfs f8, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823FC5B4: C13B0000  lfs f9, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FC5B8: 57AA1838  slwi r10, r29, 3
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FC5BC: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 823FC5C0: 7FEA4214  add r31, r10, r8
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 823FC5C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FC5C8: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823FC5CC: C0CB0004  lfs f6, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 823FC5D0: C0EB0000  lfs f7, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 823FC5D4: EDA83028  fsubs f13, f8, f6
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[6].f64) as f32) as f64);
	// 823FC5D8: EC093828  fsubs f0, f9, f7
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[7].f64) as f32) as f64);
	// 823FC5DC: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FC5E0: C17F0000  lfs f11, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FC5E4: ED4C0372  fmuls f10, f12, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FC5E8: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FC5EC: EC0B503A  fmadds f0, f11, f0, f10
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 823FC5F0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 823FC5F4: EC0B6378  fmsubs f0, f11, f13, f12
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 823FC5F8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 823FC5FC: 40990024  ble cr6, 0x823fc620
	if !ctx.cr[6].gt {
	pc = 0x823FC620; continue 'dispatch;
	}
	// 823FC600: 81610124  lwz r11, 0x124(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 823FC604: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC608: 7F09E800  cmpw cr6, r9, r29
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[29].s32, &mut ctx.xer);
	// 823FC60C: 419A00CC  beq cr6, 0x823fc6d8
	if ctx.cr[6].eq {
	pc = 0x823FC6D8; continue 'dispatch;
	}
	// 823FC610: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823FC614: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FC618: 7F0AE000  cmpw cr6, r10, r28
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[28].s32, &mut ctx.xer);
	// 823FC61C: 4198FFE8  blt cr6, 0x823fc604
	if ctx.cr[6].lt {
	pc = 0x823FC604; continue 'dispatch;
	}
	// 823FC620: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 823FC624: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 823FC628: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FC62C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823FC630: 4BFFFDB1  bl 0x823fc3e0
	ctx.lr = 0x823FC634;
	sub_823FC3E0(ctx, base);
	// 823FC634: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823FC638: 7F03C040  cmplw cr6, r3, r24
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[24].u32, &mut ctx.xer);
	// 823FC63C: 41980008  blt cr6, 0x823fc644
	if ctx.cr[6].lt {
	pc = 0x823FC644; continue 'dispatch;
	}
	// 823FC640: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FC644: C1BF0004  lfs f13, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FC648: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FC64C: ED4D0372  fmuls f10, f13, f13
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FC650: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC654: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823FC658: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FC65C: EC6D02F2  fmuls f3, f13, f11
	ctx.f[3].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FC660: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FC664: ED6002F2  fmuls f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FC668: ED40503A  fmadds f10, f0, f0, f10
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 823FC66C: EC601B38  fmsubs f3, f0, f12, f3
	ctx.f[3].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 - ctx.f[3].f64) as f32) as f64);
	// 823FC670: ED8D5B3A  fmadds f12, f13, f12, f11
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 823FC674: EC055024  fdivs f0, f5, f10
	ctx.f[0].f64 = ((ctx.f[5].f64 / ctx.f[10].f64) as f32) as f64;
	// 823FC678: EDA30032  fmuls f13, f3, f0
	ctx.f[13].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FC67C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FC680: EDAD382A  fadds f13, f13, f7
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[7].f64) as f32) as f64;
	// 823FC684: ED8C302A  fadds f12, f12, f6
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[6].f64) as f32) as f64;
	// 823FC688: EC096828  fsubs f0, f9, f13
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FC68C: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FC690: EC086028  fsubs f0, f8, f12
	ctx.f[0].f64 = (((ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 823FC694: EC00583A  fmadds f0, f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 823FC698: FF002000  fcmpu cr6, f0, f4
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[4].f64);
	// 823FC69C: 40980018  bge cr6, 0x823fc6b4
	if !ctx.cr[6].lt {
	pc = 0x823FC6B4; continue 'dispatch;
	}
	// 823FC6A0: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823FC6A4: FC800090  fmr f4, f0
	ctx.f[4].f64 = ctx.f[0].f64;
	// 823FC6A8: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 823FC6AC: 93B70000  stw r29, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 823FC6B0: 90770004  stw r3, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 823FC6B4: 3739FFFF  addic. r25, r25, -1
	ctx.xer.ca = (ctx.r[25].u32 > (!(-1 as u32)));
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 823FC6B8: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 823FC6BC: 4082FEDC  bne 0x823fc598
	if !ctx.cr[0].eq {
	pc = 0x823FC598; continue 'dispatch;
	}
	// 823FC6C0: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC6C4: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FC6C8: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC6CC: D01B0004  stfs f0, 4(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FC6D0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 823FC6D4: 48138A1C  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
	// 823FC6D8: 83C10114  lwz r30, 0x114(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 823FC6DC: 4BFFFF48  b 0x823fc624
	pc = 0x823FC624; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FC6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FC6E0 size=660
    let mut pc: u32 = 0x823FC6E0;
    'dispatch: loop {
        match pc {
            0x823FC6E0 => {
    //   block [0x823FC6E0..0x823FC974)
	// 823FC6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FC6E4: 481389A5  bl 0x82535088
	ctx.lr = 0x823FC6E8;
	sub_82535080(ctx, base);
	// 823FC6E8: DBE1FF70  stfd f31, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 823FC6EC: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FC6F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FC6F4: 3D408273  lis r10, -0x7d8d
	ctx.r[10].s64 = -2106392576;
	// 823FC6F8: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 823FC6FC: 7CB42B78  mr r20, r5
	ctx.r[20].u64 = ctx.r[5].u64;
	// 823FC700: 3AEAD670  addi r23, r10, -0x2990
	ctx.r[23].s64 = ctx.r[10].s64 + -10640;
	// 823FC704: C00B207C  lfs f0, 0x207c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC708: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FC70C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FC710: 396B7708  addi r11, r11, 0x7708
	ctx.r[11].s64 = ctx.r[11].s64 + 30472;
	// 823FC714: 40990014  ble cr6, 0x823fc728
	if !ctx.cr[6].gt {
	pc = 0x823FC728; continue 'dispatch;
	}
	// 823FC718: 394B066C  addi r10, r11, 0x66c
	ctx.r[10].s64 = ctx.r[11].s64 + 1644;
	// 823FC71C: 7D755B78  mr r21, r11
	ctx.r[21].u64 = ctx.r[11].u64;
	// 823FC720: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 823FC724: 48000010  b 0x823fc734
	pc = 0x823FC734; continue 'dispatch;
	// 823FC728: 3AAB0030  addi r21, r11, 0x30
	ctx.r[21].s64 = ctx.r[11].s64 + 48;
	// 823FC72C: 39370018  addi r9, r23, 0x18
	ctx.r[9].s64 = ctx.r[23].s64 + 24;
	// 823FC730: 394B0AB8  addi r10, r11, 0xab8
	ctx.r[10].s64 = ctx.r[11].s64 + 2744;
	// 823FC734: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 823FC738: 390B10E4  addi r8, r11, 0x10e4
	ctx.r[8].s64 = ctx.r[11].s64 + 4324;
	// 823FC73C: 394B0E10  addi r10, r11, 0xe10
	ctx.r[10].s64 = ctx.r[11].s64 + 3600;
	// 823FC740: 396B1378  addi r11, r11, 0x1378
	ctx.r[11].s64 = ctx.r[11].s64 + 4984;
	// 823FC744: 2F140000  cmpwi cr6, r20, 0
	ctx.cr[6].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 823FC748: 91010088  stw r8, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[8].u32 ) };
	// 823FC74C: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 823FC750: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 823FC754: 40990034  ble cr6, 0x823fc788
	if !ctx.cr[6].gt {
	pc = 0x823FC788; continue 'dispatch;
	}
	// 823FC758: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 823FC75C: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 823FC760: 7CF55050  subf r7, r21, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[21].s64;
	// 823FC764: 7D159850  subf r8, r21, r19
	ctx.r[8].s64 = ctx.r[19].s64 - ctx.r[21].s64;
	// 823FC768: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 823FC76C: 7C085C2E  lfsx f0, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC770: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FC774: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FC778: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FC77C: 7C075D2E  stfsx f0, r7, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 823FC780: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FC784: 4082FFE8  bne 0x823fc76c
	if !ctx.cr[0].eq {
	pc = 0x823FC76C; continue 'dispatch;
	}
	// 823FC788: 39770030  addi r11, r23, 0x30
	ctx.r[11].s64 = ctx.r[23].s64 + 48;
	// 823FC78C: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 823FC790: 3BABFFF0  addi r29, r11, -0x10
	ctx.r[29].s64 = ctx.r[11].s64 + -16;
	// 823FC794: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FC798: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 823FC79C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 823FC7A0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 823FC7A4: 3BE10090  addi r31, r1, 0x90
	ctx.r[31].s64 = ctx.r[1].s64 + 144;
	// 823FC7A8: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FC7AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FC7B0: 3B810080  addi r28, r1, 0x80
	ctx.r[28].s64 = ctx.r[1].s64 + 128;
	// 823FC7B4: 3B410094  addi r26, r1, 0x94
	ctx.r[26].s64 = ctx.r[1].s64 + 148;
	// 823FC7B8: 7ECA4850  subf r22, r10, r9
	ctx.r[22].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 823FC7BC: 7D76E02E  lwzx r11, r22, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 823FC7C0: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 823FC7C4: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 823FC7C8: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 823FC7CC: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 823FC7D0: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 823FC7D4: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 823FC7D8: 40990024  ble cr6, 0x823fc7fc
	if !ctx.cr[6].gt {
	pc = 0x823FC7FC; continue 'dispatch;
	}
	// 823FC7DC: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 823FC7E0: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 823FC7E4: 7DAA5C2E  lfsx f13, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FC7E8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FC7EC: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FC7F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FC7F4: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 823FC7F8: 4082FFEC  bne 0x823fc7e4
	if !ctx.cr[0].eq {
	pc = 0x823FC7E4; continue 'dispatch;
	}
	// 823FC7FC: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FC800: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823FC804: 7D5B5214  add r10, r27, r10
	ctx.r[10].u64 = ctx.r[27].u64 + ctx.r[10].u64;
	// 823FC808: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FC80C: 4082FFC4  bne 0x823fc7d0
	if !ctx.cr[0].eq {
	pc = 0x823FC7D0; continue 'dispatch;
	}
	// 823FC810: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC814: 2F190004  cmpwi cr6, r25, 4
	ctx.cr[6].compare_i32(ctx.r[25].s32, 4, &mut ctx.xer);
	// 823FC818: C1BA0000  lfs f13, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FC81C: C0410070  lfs f2, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823FC820: C0210074  lfs f1, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FC824: EC001028  fsubs f0, f0, f2
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[2].f64) as f32) as f64);
	// 823FC828: EDAD0828  fsubs f13, f13, f1
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[1].f64) as f32) as f64);
	// 823FC82C: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FC830: D1BA0000  stfs f13, 0(r26)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FC834: 40980048  bge cr6, 0x823fc87c
	if !ctx.cr[6].lt {
	pc = 0x823FC87C; continue 'dispatch;
	}
	// 823FC838: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC83C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 823FC840: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823FC844: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823FC848: 824B001C  lwz r18, 0x1c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 823FC84C: 822B0018  lwz r17, 0x18(r11)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FC850: 820B0014  lwz r16, 0x14(r11)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823FC854: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823FC858: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FC85C: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FC860: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FC864: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC868: 92410064  stw r18, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[18].u32 ) };
	// 823FC86C: 9221005C  stw r17, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[17].u32 ) };
	// 823FC870: 92010054  stw r16, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[16].u32 ) };
	// 823FC874: 4BFFFBE5  bl 0x823fc458
	ctx.lr = 0x823FC878;
	sub_823FC458(ctx, base);
	// 823FC878: 48000058  b 0x823fc8d0
	pc = 0x823FC8D0; continue 'dispatch;
	// 823FC87C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FC884: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC888: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FC88C: 4BFFFB55  bl 0x823fc3e0
	ctx.lr = 0x823FC890;
	sub_823FC3E0(ctx, base);
	// 823FC890: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FC894: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 823FC898: 546A003E  slwi r10, r3, 0
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FC89C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823FC8A0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC8A4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC8A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FC8AC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823FC8B0: 41980008  blt cr6, 0x823fc8b8
	if ctx.cr[6].lt {
	pc = 0x823FC8B8; continue 'dispatch;
	}
	// 823FC8B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FC8B8: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FC8BC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823FC8C0: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC8C4: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FC8C8: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FC8CC: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FC8D0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 823FC8D4: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC8D8: 38D70030  addi r6, r23, 0x30
	ctx.r[6].s64 = ctx.r[23].s64 + 48;
	// 823FC8DC: EC02002A  fadds f0, f2, f0
	ctx.f[0].f64 = ((ctx.f[2].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FC8E0: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FC8E4: 39580001  addi r10, r24, 1
	ctx.r[10].s64 = ctx.r[24].s64 + 1;
	// 823FC8E8: 393B0004  addi r9, r27, 4
	ctx.r[9].s64 = ctx.r[27].s64 + 4;
	// 823FC8EC: 391A0004  addi r8, r26, 4
	ctx.r[8].s64 = ctx.r[26].s64 + 4;
	// 823FC8F0: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC8F4: 38FE0004  addi r7, r30, 4
	ctx.r[7].s64 = ctx.r[30].s64 + 4;
	// 823FC8F8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 823FC8FC: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FC900: 38C60008  addi r6, r6, 8
	ctx.r[6].s64 = ctx.r[6].s64 + 8;
	// 823FC904: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FC908: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 823FC90C: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 823FC910: 3B0A0001  addi r24, r10, 1
	ctx.r[24].s64 = ctx.r[10].s64 + 1;
	// 823FC914: 3B690004  addi r27, r9, 4
	ctx.r[27].s64 = ctx.r[9].s64 + 4;
	// 823FC918: 3B480004  addi r26, r8, 4
	ctx.r[26].s64 = ctx.r[8].s64 + 4;
	// 823FC91C: 3BC70004  addi r30, r7, 4
	ctx.r[30].s64 = ctx.r[7].s64 + 4;
	// 823FC920: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 823FC924: 7F1D3000  cmpw cr6, r29, r6
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FC928: 4198FE94  blt cr6, 0x823fc7bc
	if ctx.cr[6].lt {
	pc = 0x823FC7BC; continue 'dispatch;
	}
	// 823FC92C: 2F140000  cmpwi cr6, r20, 0
	ctx.cr[6].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 823FC930: 40990038  ble cr6, 0x823fc968
	if !ctx.cr[6].gt {
	pc = 0x823FC968; continue 'dispatch;
	}
	// 823FC934: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 823FC938: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 823FC93C: 7D2AA850  subf r9, r10, r21
	ctx.r[9].s64 = ctx.r[21].s64 - ctx.r[10].s64;
	// 823FC940: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 823FC944: 7D089850  subf r8, r8, r19
	ctx.r[8].s64 = ctx.r[19].s64 - ctx.r[8].s64;
	// 823FC948: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 823FC94C: 7C095C2E  lfsx f0, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC950: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FC954: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FC958: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 823FC95C: 7C085D2E  stfsx f0, r8, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 823FC960: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FC964: 4082FFE8  bne 0x823fc94c
	if !ctx.cr[0].eq {
	pc = 0x823FC94C; continue 'dispatch;
	}
	// 823FC968: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 823FC96C: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 823FC970: 48138768  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FC978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FC978 size=84
    let mut pc: u32 = 0x823FC978;
    'dispatch: loop {
        match pc {
            0x823FC978 => {
    //   block [0x823FC978..0x823FC9CC)
	// 823FC978: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FC97C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FC980: 396B8CB8  addi r11, r11, -0x7348
	ctx.r[11].s64 = ctx.r[11].s64 + -29512;
	// 823FC984: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 823FC988: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 823FC98C: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC990: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FC994: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FC998: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC99C: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FC9A0: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FC9A4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FC9A8: 4098000C  bge cr6, 0x823fc9b4
	if !ctx.cr[6].lt {
	pc = 0x823FC9B4; continue 'dispatch;
	}
	// 823FC9AC: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 823FC9B0: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 823FC9B4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FC9B8: 390B0100  addi r8, r11, 0x100
	ctx.r[8].s64 = ctx.r[11].s64 + 256;
	// 823FC9BC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823FC9C0: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 823FC9C4: 4198FFD4  blt cr6, 0x823fc998
	if ctx.cr[6].lt {
	pc = 0x823FC998; continue 'dispatch;
	}
	// 823FC9C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FC9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FC9D0 size=152
    let mut pc: u32 = 0x823FC9D0;
    'dispatch: loop {
        match pc {
            0x823FC9D0 => {
    //   block [0x823FC9D0..0x823FCA68)
	// 823FC9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FC9D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FC9D8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FC9DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FC9E0: C00B1848  lfs f0, 0x1848(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC9E4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FC9E8: 41990008  bgt cr6, 0x823fc9f0
	if ctx.cr[6].gt {
	pc = 0x823FC9F0; continue 'dispatch;
	}
	// 823FC9EC: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 823FC9F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FC9F4: C00B2ECC  lfs f0, 0x2ecc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11980 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC9F8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FC9FC: 40990008  ble cr6, 0x823fca04
	if !ctx.cr[6].gt {
	pc = 0x823FCA04; continue 'dispatch;
	}
	// 823FCA00: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 823FCA04: 481365D5  bl 0x82532fd8
	ctx.lr = 0x823FCA08;
	sub_82532FD8(ctx, base);
	// 823FCA08: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FCA0C: C80B8DC0  lfd f0, -0x7240(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-29248 as u32) ) };
	// 823FCA10: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FCA14: FC000828  fsub f0, f0, f1
	ctx.f[0].f64 = ctx.f[0].f64 - ctx.f[1].f64;
	// 823FCA18: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FCA1C: C00B8DB8  lfs f0, -0x7248(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FCA20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FCA24: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FCA28: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FCA2C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FCA30: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FCA34: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FCA38: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823FCA3C: 4099000C  ble cr6, 0x823fca48
	if !ctx.cr[6].gt {
	pc = 0x823FCA48; continue 'dispatch;
	}
	// 823FCA40: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 823FCA44: 48000008  b 0x823fca4c
	pc = 0x823FCA4C; continue 'dispatch;
	// 823FCA48: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FCA4C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FCA50: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 823FCA54: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FCA58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823FCA5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FCA60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FCA64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FCA68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FCA68 size=76
    let mut pc: u32 = 0x823FCA68;
    'dispatch: loop {
        match pc {
            0x823FCA68 => {
    //   block [0x823FCA68..0x823FCAB4)
	// 823FCA68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FCA6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FCA70: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FCA74: 7C6A07B4  extsw r10, r3
	ctx.r[10].s64 = ctx.r[3].s32 as i64;
	// 823FCA78: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FCA7C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 823FCA80: C00B76FC  lfs f0, 0x76fc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30460 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FCA84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FCA88: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FCA8C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823FCA90: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823FCA94: C1AB76F8  lfs f13, 0x76f8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30456 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FCA98: EC2C683C  fnmsubs f1, f12, f0, f13
	ctx.f[1].f64 = -(((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FCA9C: 481369FD  bl 0x82533498
	ctx.lr = 0x823FCAA0;
	sub_82533498(ctx, base);
	// 823FCAA0: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 823FCAA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823FCAA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FCAAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FCAB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FCAB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FCAB8 size=124
    let mut pc: u32 = 0x823FCAB8;
    'dispatch: loop {
        match pc {
            0x823FCAB8 => {
    //   block [0x823FCAB8..0x823FCB34)
	// 823FCAB8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FCABC: EDA300F2  fmuls f13, f3, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[3].f64 * ctx.f[3].f64) as f32) as f64);
	// 823FCAC0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823FCAC4: 396B8DC8  addi r11, r11, -0x7238
	ctx.r[11].s64 = ctx.r[11].s64 + -29240;
	// 823FCAC8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823FCACC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 823FCAD0: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 823FCAD4: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FCAD8: EC030028  fsubs f0, f3, f0
	ctx.f[0].f64 = (((ctx.f[3].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FCADC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FCAE0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FCAE4: 4098000C  bge cr6, 0x823fcaf0
	if !ctx.cr[6].lt {
	pc = 0x823FCAF0; continue 'dispatch;
	}
	// 823FCAE8: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 823FCAEC: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 823FCAF0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FCAF4: 38CB0020  addi r6, r11, 0x20
	ctx.r[6].s64 = ctx.r[11].s64 + 32;
	// 823FCAF8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823FCAFC: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FCB00: 4198FFD4  blt cr6, 0x823fcad4
	if ctx.cr[6].lt {
	pc = 0x823FCAD4; continue 'dispatch;
	}
	// 823FCB04: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FCB08: EC011028  fsubs f0, f1, f2
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[2].f64) as f32) as f64);
	// 823FCB0C: 7DAA5C2E  lfsx f13, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FCB10: EDAD1028  fsubs f13, f13, f2
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[2].f64) as f32) as f64);
	// 823FCB14: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FCB18: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FCB1C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FCB20: 40980008  bge cr6, 0x823fcb28
	if !ctx.cr[6].lt {
	pc = 0x823FCB28; continue 'dispatch;
	}
	// 823FCB24: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 823FCB28: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FCB2C: 7C6B4214  add r3, r11, r8
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 823FCB30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FCB38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FCB38 size=92
    let mut pc: u32 = 0x823FCB38;
    'dispatch: loop {
        match pc {
            0x823FCB38 => {
    //   block [0x823FCB38..0x823FCB94)
	// 823FCB38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FCB3C: 48138581  bl 0x825350bc
	ctx.lr = 0x823FCB40;
	sub_82535080(ctx, base);
	// 823FCB40: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 823FCB44: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FCB48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823FCB4C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 823FCB50: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 823FCB54: 557F0738  rlwinm r31, r11, 0, 0x1c, 0x1c
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823FCB58: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823FCB5C: 386A8DC8  addi r3, r10, -0x7238
	ctx.r[3].s64 = ctx.r[10].s64 + -29240;
	// 823FCB60: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 823FCB64: 7CBF5850  subf r5, r31, r11
	ctx.r[5].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 823FCB68: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 823FCB6C: 4BFFF85D  bl 0x823fc3c8
	ctx.lr = 0x823FCB70;
	sub_823FC3C8(ctx, base);
	// 823FCB70: D03E0000  stfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FCB74: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823FCB78: 409A000C  bne cr6, 0x823fcb84
	if !ctx.cr[6].eq {
	pc = 0x823FCB84; continue 'dispatch;
	}
	// 823FCB7C: D3FD0000  stfs f31, 0(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FCB80: 48000008  b 0x823fcb88
	pc = 0x823FCB88; continue 'dispatch;
	// 823FCB84: D03D0000  stfs f1, 0(r29)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FCB88: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823FCB8C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 823FCB90: 4813857C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FCB98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FCB98 size=516
    let mut pc: u32 = 0x823FCB98;
    'dispatch: loop {
        match pc {
            0x823FCB98 => {
    //   block [0x823FCB98..0x823FCD9C)
	// 823FCB98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FCB9C: 4813850D  bl 0x825350a8
	ctx.lr = 0x823FCBA0;
	sub_82535080(ctx, base);
	// 823FCBA0: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 823FCBA4: 4813943D  bl 0x82535fe0
	ctx.lr = 0x823FCBA8;
	sub_82535FB0(ctx, base);
	// 823FCBA8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FCBAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FCBB0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823FCBB4: 3B9F0010  addi r28, r31, 0x10
	ctx.r[28].s64 = ctx.r[31].s64 + 16;
	// 823FCBB8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823FCBBC: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 823FCBC0: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 823FCBC4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 823FCBC8: 83DF0028  lwz r30, 0x28(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 823FCBCC: C36A1850  lfs f27, 0x1850(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 823FCBD0: 3B2BFF6A  addi r25, r11, -0x96
	ctx.r[25].s64 = ctx.r[11].s64 + -150;
	// 823FCBD4: C3BF0020  lfs f29, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 823FCBD8: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FCBDC: C39F0024  lfs f28, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 823FCBE0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FCBE4: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 823FCBE8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 823FCBEC: 38A000A1  li r5, 0xa1
	ctx.r[5].s64 = 161;
	// 823FCBF0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823FCBF4: 7FEBFC2E  lfsx f31, r11, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FCBF8: C34A2850  lfs f26, 0x2850(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10320 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 823FCBFC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 823FCC00: 7FCBE42E  lfsx f30, r11, r28
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 823FCC04: 48000D5D  bl 0x823fd960
	ctx.lr = 0x823FCC08;
	sub_823FD960(ctx, base);
	// 823FCC08: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 823FCC0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FCC10: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FCC14: C1898DF0  lfs f12, -0x7210(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-29200 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FCC18: C16B8DEC  lfs f11, -0x7214(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29204 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FCC1C: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FCC20: ED5F0332  fmuls f10, f31, f12
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FCC24: EDA002F2  fmuls f13, f0, f11
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FCC28: C13D0004  lfs f9, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FCC2C: ED1E0332  fmuls f8, f30, f12
	ctx.f[8].f64 = (((ctx.f[30].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FCC30: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 823FCC34: 7F0AC800  cmpw cr6, r10, r25
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[25].s32, &mut ctx.xer);
	// 823FCC38: 7D691670  srawi r9, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 823FCC3C: 7D290194  addze r9, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[9].s64 = tmp.s64;
	// 823FCC40: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FCC44: 7FC95850  subf r30, r9, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 823FCC48: EFE0537A  fmadds f31, f0, f13, f10
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64);
	// 823FCC4C: EFC9437A  fmadds f30, f9, f13, f8
	ctx.f[30].f64 = (((ctx.f[9].f64 * ctx.f[13].f64 + ctx.f[8].f64) as f32) as f64);
	// 823FCC50: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FCC54: 7CEBFC2E  lfsx f7, r11, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 823FCC58: 7CCBE42E  lfsx f6, r11, r28
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 823FCC5C: 7FEBFD2E  stfsx f31, r11, r31
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 823FCC60: 7FCBE52E  stfsx f30, r11, r28
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), tmp.u32) };
	// 823FCC64: EDBC07F2  fmuls f13, f28, f31
	ctx.f[13].f64 = (((ctx.f[28].f64 * ctx.f[31].f64) as f32) as f64);
	// 823FCC68: ED5DF82A  fadds f10, f29, f31
	ctx.f[10].f64 = ((ctx.f[29].f64 + ctx.f[31].f64) as f32) as f64;
	// 823FCC6C: ED3CF02A  fadds f9, f28, f30
	ctx.f[9].f64 = ((ctx.f[28].f64 + ctx.f[30].f64) as f32) as f64;
	// 823FCC70: EC1D07F2  fmuls f0, f29, f31
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[31].f64) as f32) as f64);
	// 823FCC74: EDBD6FB8  fmsubs f13, f29, f30, f13
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FCC78: EFAA3828  fsubs f29, f10, f7
	ctx.f[29].f64 = (((ctx.f[10].f64 - ctx.f[7].f64) as f32) as f64);
	// 823FCC7C: EF893028  fsubs f28, f9, f6
	ctx.f[28].f64 = (((ctx.f[9].f64 - ctx.f[6].f64) as f32) as f64);
	// 823FCC80: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 823FCC84: 41980030  blt cr6, 0x823fccb4
	if ctx.cr[6].lt {
	pc = 0x823FCCB4; continue 'dispatch;
	}
	// 823FCC88: ED4D06F2  fmuls f10, f13, f27
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 823FCC8C: D1410050  stfs f10, 0x50(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823FCC90: ED4006B2  fmuls f10, f0, f26
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 823FCC94: D1410058  stfs f10, 0x58(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 823FCC98: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 823FCC9C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FCCA0: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 823FCCA4: 40990010  ble cr6, 0x823fccb4
	if !ctx.cr[6].gt {
	pc = 0x823FCCB4; continue 'dispatch;
	}
	// 823FCCA8: FF600090  fmr f27, f0
	ctx.f[27].f64 = ctx.f[0].f64;
	// 823FCCAC: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	// 823FCCB0: FF406890  fmr f26, f13
	ctx.f[26].f64 = ctx.f[13].f64;
	// 823FCCB4: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 823FCCB8: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 823FCCBC: 2F0A00A0  cmpwi cr6, r10, 0xa0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 160, &mut ctx.xer);
	// 823FCCC0: 4198FF5C  blt cr6, 0x823fcc1c
	if ctx.cr[6].lt {
	pc = 0x823FCC1C; continue 'dispatch;
	}
	// 823FCCC4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FCCC8: D3BF0020  stfs f29, 0x20(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 823FCCCC: D39F0024  stfs f28, 0x24(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 823FCCD0: 2F1A0050  cmpwi cr6, r26, 0x50
	ctx.cr[6].compare_i32(ctx.r[26].s32, 80, &mut ctx.xer);
	// 823FCCD4: 935F002C  stw r26, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[26].u32 ) };
	// 823FCCD8: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 823FCCDC: C00B8DE8  lfs f0, -0x7218(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FCCE0: 7F0B0E70  srawi r11, r24, 1
	ctx.xer.ca = (ctx.r[24].s32 < 0) && ((ctx.r[24].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[24].s32 >> 1) as i64;
	// 823FCCE4: 7D6BD850  subf r11, r11, r27
	ctx.r[11].s64 = ctx.r[27].s64 - ctx.r[11].s64;
	// 823FCCE8: 40990060  ble cr6, 0x823fcd48
	if !ctx.cr[6].gt {
	pc = 0x823FCD48; continue 'dispatch;
	}
	// 823FCCEC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FCCF0: 213A00A0  subfic r9, r26, 0xa0
	ctx.xer.ca = ctx.r[26].u32 <= 160 as u32;
	ctx.r[9].s64 = (160 as i64) - ctx.r[26].s64;
	// 823FCCF4: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 823FCCF8: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 823FCCFC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823FCD00: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FCD04: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 823FCD08: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823FCD0C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823FCD10: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823FCD14: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FCD18: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 823FCD1C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 823FCD20: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FCD24: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FCD28: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FCD2C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FCD30: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 823FCD34: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 823FCD38: 2F030028  cmpwi cr6, r3, 0x28
	ctx.cr[6].compare_i32(ctx.r[3].s32, 40, &mut ctx.xer);
	// 823FCD3C: 40990050  ble cr6, 0x823fcd8c
	if !ctx.cr[6].gt {
	pc = 0x823FCD8C; continue 'dispatch;
	}
	// 823FCD40: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 823FCD44: 48000048  b 0x823fcd8c
	pc = 0x823FCD8C; continue 'dispatch;
	// 823FCD48: 7D6BD1D6  mullw r11, r11, r26
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[26].s32 as i64);
	// 823FCD4C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FCD50: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823FCD54: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 823FCD58: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823FCD5C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823FCD60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FCD64: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823FCD68: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FCD6C: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FCD70: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FCD74: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 823FCD78: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FCD7C: 7C6B00D0  neg r3, r11
	ctx.r[3].s64 = -ctx.r[11].s64;
	// 823FCD80: 2F03FFD8  cmpwi cr6, r3, -0x28
	ctx.cr[6].compare_i32(ctx.r[3].s32, -40, &mut ctx.xer);
	// 823FCD84: 40980008  bge cr6, 0x823fcd8c
	if !ctx.cr[6].lt {
	pc = 0x823FCD8C; continue 'dispatch;
	}
	// 823FCD88: 3860FFD8  li r3, -0x28
	ctx.r[3].s64 = -40;
	// 823FCD8C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 823FCD90: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 823FCD94: 48139299  bl 0x8253602c
	ctx.lr = 0x823FCD98;
	sub_82535FFC(ctx, base);
	// 823FCD98: 48138360  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FCDA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FCDA0 size=176
    let mut pc: u32 = 0x823FCDA0;
    'dispatch: loop {
        match pc {
            0x823FCDA0 => {
    //   block [0x823FCDA0..0x823FCE50)
	// 823FCDA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FCDA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FCDA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823FCDAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FCDB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FCDB4: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823FCDB8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823FCDBC: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 823FCDC0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FCDC4: 816B37A8  lwz r11, 0x37a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FCDC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FCDCC: 4E800421  bctrl
	ctx.lr = 0x823FCDD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FCDD0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823FCDD4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823FCDD8: 4082000C  bne 0x823fcde4
	if !ctx.cr[0].eq {
	pc = 0x823FCDE4; continue 'dispatch;
	}
	// 823FCDDC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FCDE0: 48000058  b 0x823fce38
	pc = 0x823FCE38; continue 'dispatch;
	// 823FCDE4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FCDE8: 3FC08288  lis r30, -0x7d78
	ctx.r[30].s64 = -2105016320;
	// 823FCDEC: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 823FCDF0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FCDF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FCDF8: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FCDFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FCE00: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 823FCE04: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 823FCE08: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 823FCE0C: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 823FCE10: 817E37B0  lwz r11, 0x37b0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FCE14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FCE18: 4E800421  bctrl
	ctx.lr = 0x823FCE1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FCE1C: 817E37B0  lwz r11, 0x37b0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FCE20: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 823FCE24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FCE28: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 823FCE2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FCE30: 4E800421  bctrl
	ctx.lr = 0x823FCE34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FCE34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FCE38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FCE3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FCE40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FCE44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823FCE48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FCE4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FCE50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FCE50 size=168
    let mut pc: u32 = 0x823FCE50;
    'dispatch: loop {
        match pc {
            0x823FCE50 => {
    //   block [0x823FCE50..0x823FCEF8)
	// 823FCE50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FCE54: 48138269  bl 0x825350bc
	ctx.lr = 0x823FCE58;
	sub_82535080(ctx, base);
	// 823FCE58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FCE5C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823FCE60: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823FCE64: 409A000C  bne cr6, 0x823fce70
	if !ctx.cr[6].eq {
	pc = 0x823FCE70; continue 'dispatch;
	}
	// 823FCE68: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FCE6C: 48000084  b 0x823fcef0
	pc = 0x823FCEF0; continue 'dispatch;
	// 823FCE70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FCE74: 3FC08288  lis r30, -0x7d78
	ctx.r[30].s64 = -2105016320;
	// 823FCE78: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 823FCE7C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FCE80: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FCE84: 817E37A8  lwz r11, 0x37a8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FCE88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FCE8C: 4E800421  bctrl
	ctx.lr = 0x823FCE90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FCE90: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823FCE94: 4182FFD4  beq 0x823fce68
	if ctx.cr[0].eq {
	pc = 0x823FCE68; continue 'dispatch;
	}
	// 823FCE98: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823FCE9C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 823FCEA0: 817E37A8  lwz r11, 0x37a8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FCEA4: 3860000D  li r3, 0xd
	ctx.r[3].s64 = 13;
	// 823FCEA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FCEAC: 4E800421  bctrl
	ctx.lr = 0x823FCEB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FCEB0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FCEB4: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 823FCEB8: 4182FFB0  beq 0x823fce68
	if ctx.cr[0].eq {
	pc = 0x823FCE68; continue 'dispatch;
	}
	// 823FCEBC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FCEC0: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 823FCEC4: 38A00034  li r5, 0x34
	ctx.r[5].s64 = 52;
	// 823FCEC8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FCECC: C00B204C  lfs f0, 0x204c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FCED0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FCED4: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FCED8: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FCEDC: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FCEE0: 816A37B0  lwz r11, 0x37b0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FCEE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FCEE8: 4E800421  bctrl
	ctx.lr = 0x823FCEEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FCEEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FCEF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FCEF4: 48138218  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FCEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FCEF8 size=112
    let mut pc: u32 = 0x823FCEF8;
    'dispatch: loop {
        match pc {
            0x823FCEF8 => {
    //   block [0x823FCEF8..0x823FCF68)
	// 823FCEF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FCEFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FCF00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823FCF04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FCF08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FCF0C: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FCF10: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FCF14: 41820038  beq 0x823fcf4c
	if ctx.cr[0].eq {
	pc = 0x823FCF4C; continue 'dispatch;
	}
	// 823FCF18: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FCF1C: 3FC08288  lis r30, -0x7d78
	ctx.r[30].s64 = -2105016320;
	// 823FCF20: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FCF24: 41820018  beq 0x823fcf3c
	if ctx.cr[0].eq {
	pc = 0x823FCF3C; continue 'dispatch;
	}
	// 823FCF28: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FCF2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FCF30: 4E800421  bctrl
	ctx.lr = 0x823FCF34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FCF34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FCF38: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823FCF3C: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FCF40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FCF44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FCF48: 4E800421  bctrl
	ctx.lr = 0x823FCF4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FCF4C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FCF50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FCF54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FCF58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FCF5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823FCF60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FCF64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FCF68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FCF68 size=124
    let mut pc: u32 = 0x823FCF68;
    'dispatch: loop {
        match pc {
            0x823FCF68 => {
    //   block [0x823FCF68..0x823FCFE4)
	// 823FCF68: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FCF6C: 3564FFFF  addic. r11, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FCF70: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 823FCF74: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FCF78: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 823FCF7C: 41800020  blt 0x823fcf9c
	if ctx.cr[0].lt {
	pc = 0x823FCF9C; continue 'dispatch;
	}
	// 823FCF80: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FCF84: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 823FCF88: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FCF8C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FCF90: ED8D602A  fadds f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 823FCF94: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 823FCF98: 4080FFF0  bge 0x823fcf88
	if !ctx.cr[0].lt {
	pc = 0x823FCF88; continue 'dispatch;
	}
	// 823FCF9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823FCFA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FCFA4: C1AA2954  lfs f13, 0x2954(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10580 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FCFA8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 823FCFAC: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FCFB0: 41980028  blt cr6, 0x823fcfd8
	if ctx.cr[6].lt {
	pc = 0x823FCFD8; continue 'dispatch;
	}
	// 823FCFB4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FCFB8: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 823FCFBC: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FCFC0: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FCFC4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FCFC8: 40980010  bge cr6, 0x823fcfd8
	if !ctx.cr[6].lt {
	pc = 0x823FCFD8; continue 'dispatch;
	}
	// 823FCFCC: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FCFD0: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 823FCFD4: 4080FFE8  bge 0x823fcfbc
	if !ctx.cr[0].lt {
	pc = 0x823FCFBC; continue 'dispatch;
	}
	// 823FCFD8: 386A0002  addi r3, r10, 2
	ctx.r[3].s64 = ctx.r[10].s64 + 2;
	// 823FCFDC: 2F03004C  cmpwi cr6, r3, 0x4c
	ctx.cr[6].compare_i32(ctx.r[3].s32, 76, &mut ctx.xer);
	// 823FCFE0: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FCFE4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823FCFE4 size=8
    let mut pc: u32 = 0x823FCFE4;
    'dispatch: loop {
        match pc {
            0x823FCFE4 => {
    //   block [0x823FCFE4..0x823FCFEC)
	// 823FCFE4: 3860004C  li r3, 0x4c
	ctx.r[3].s64 = 76;
	// 823FCFE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FCFF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FCFF0 size=472
    let mut pc: u32 = 0x823FCFF0;
    'dispatch: loop {
        match pc {
            0x823FCFF0 => {
    //   block [0x823FCFF0..0x823FD1C8)
	// 823FCFF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FCFF4: 481380C1  bl 0x825350b4
	ctx.lr = 0x823FCFF8;
	sub_82535080(ctx, base);
	// 823FCFF8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 823FCFFC: 9421FD50  stwu r1, -0x2b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-688 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FD000: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823FD004: 38C40001  addi r6, r4, 1
	ctx.r[6].s64 = ctx.r[4].s64 + 1;
	// 823FD008: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823FD00C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 823FD010: 3BE10170  addi r31, r1, 0x170
	ctx.r[31].s64 = ctx.r[1].s64 + 368;
	// 823FD014: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FD018: 7CCA0E71  srawi. r10, r6, 1
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[6].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FD01C: 40810034  ble 0x823fd050
	if !ctx.cr[0].gt {
	pc = 0x823FD050; continue 'dispatch;
	}
	// 823FD020: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 823FD024: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 823FD028: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 823FD02C: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD030: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823FD034: C1A80004  lfs f13, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD038: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 823FD03C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD040: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FD044: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD048: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823FD04C: 4082FFE0  bne 0x823fd02c
	if !ctx.cr[0].eq {
	pc = 0x823FD02C; continue 'dispatch;
	}
	// 823FD050: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FD054: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FD058: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FD05C: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FD060: 419A0020  beq cr6, 0x823fd080
	if ctx.cr[6].eq {
	pc = 0x823FD080; continue 'dispatch;
	}
	// 823FD064: 552A1838  slwi r10, r9, 3
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FD068: D3FF0000  stfs f31, 0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD06C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823FD070: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823FD074: 7C0A1C2E  lfsx f0, r10, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD078: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD07C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FD080: 21490041  subfic r10, r9, 0x41
	ctx.xer.ca = ctx.r[9].u32 <= 65 as u32;
	ctx.r[10].s64 = (65 as i64) - ctx.r[9].s64;
	// 823FD084: 3FA08288  lis r29, -0x7d78
	ctx.r[29].s64 = -2105016320;
	// 823FD088: 555E103A  slwi r30, r10, 2
	ctx.r[30].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 823FD08C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 823FD090: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FD094: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823FD098: 817D37B0  lwz r11, 0x37b0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FD09C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FD0A0: 4E800421  bctrl
	ctx.lr = 0x823FD0A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FD0A4: 817D37B0  lwz r11, 0x37b0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FD0A8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823FD0AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FD0B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FD0B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FD0B8: 4E800421  bctrl
	ctx.lr = 0x823FD0BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FD0BC: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 823FD0C0: 38810170  addi r4, r1, 0x170
	ctx.r[4].s64 = ctx.r[1].s64 + 368;
	// 823FD0C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823FD0C8: 48000979  bl 0x823fda40
	ctx.lr = 0x823FD0CC;
	sub_823FDA40(ctx, base);
	// 823FD0CC: 7F8B07B4  extsw r11, r28
	ctx.r[11].s64 = ctx.r[28].s32 as i64;
	// 823FD0D0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823FD0D4: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FD0D8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FD0DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD0E0: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FD0E4: C00B2148  lfs f0, 0x2148(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD0E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FD0EC: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 823FD0F0: C00B72B8  lfs f0, 0x72b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD0F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD0F8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD0FC: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD100: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823FD104: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 823FD108: 4099000C  ble cr6, 0x823fd114
	if !ctx.cr[6].gt {
	pc = 0x823FD114; continue 'dispatch;
	}
	// 823FD10C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 823FD110: 48000008  b 0x823fd118
	pc = 0x823FD118; continue 'dispatch;
	// 823FD114: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FD118: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FD11C: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 823FD120: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FD124: 357CFFFF  addic. r11, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FD128: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823FD12C: 40810044  ble 0x823fd170
	if !ctx.cr[0].gt {
	pc = 0x823FD170; continue 'dispatch;
	}
	// 823FD130: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 823FD134: 39404000  li r10, 0x4000
	ctx.r[10].s64 = 16384;
	// 823FD138: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 823FD13C: 7D487E70  srawi r8, r10, 0xf
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 15) as i64;
	// 823FD140: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 823FD144: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823FD148: 38810170  addi r4, r1, 0x170
	ctx.r[4].s64 = ctx.r[1].s64 + 368;
	// 823FD14C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FD150: 7D4A3214  add r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 823FD154: 7DA82C2E  lfsx f13, r8, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD158: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FD15C: 7C08242E  lfsx f0, r8, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD160: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FD164: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD168: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FD16C: 4082FFD0  bne 0x823fd13c
	if !ctx.cr[0].eq {
	pc = 0x823FD13C; continue 'dispatch;
	}
	// 823FD170: 7D6639D6  mullw r11, r6, r7
	ctx.r[11].s64 = (ctx.r[6].s32 as i64) * (ctx.r[7].s32 as i64);
	// 823FD174: 396B4000  addi r11, r11, 0x4000
	ctx.r[11].s64 = ctx.r[11].s64 + 16384;
	// 823FD178: 7D6B7E70  srawi r11, r11, 0xf
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 15) as i64;
	// 823FD17C: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 823FD180: 41980018  blt cr6, 0x823fd198
	if ctx.cr[6].lt {
	pc = 0x823FD198; continue 'dispatch;
	}
	// 823FD184: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FD188: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 823FD18C: C00BFFFC  lfs f0, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD190: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD194: 48000028  b 0x823fd1bc
	pc = 0x823FD1BC; continue 'dispatch;
	// 823FD198: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FD19C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 823FD1A0: 39210170  addi r9, r1, 0x170
	ctx.r[9].s64 = ctx.r[1].s64 + 368;
	// 823FD1A4: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823FD1A8: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD1AC: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FD1B0: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD1B4: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FD1B8: 7C08DD2E  stfsx f0, r8, r27
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[27].u32), tmp.u32) };
	// 823FD1BC: 382102B0  addi r1, r1, 0x2b0
	ctx.r[1].s64 = ctx.r[1].s64 + 688;
	// 823FD1C0: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 823FD1C4: 48137F40  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FD1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FD1C8 size=348
    let mut pc: u32 = 0x823FD1C8;
    'dispatch: loop {
        match pc {
            0x823FD1C8 => {
    //   block [0x823FD1C8..0x823FD324)
	// 823FD1C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FD1CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FD1D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823FD1D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FD1D8: 9421FD70  stwu r1, -0x290(r1)
	ea = ctx.r[1].u32.wrapping_add(-656 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FD1DC: 7C8B07B4  extsw r11, r4
	ctx.r[11].s64 = ctx.r[4].s32 as i64;
	// 823FD1E0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823FD1E4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 823FD1E8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823FD1EC: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FD1F0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FD1F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD1F8: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FD1FC: C00B260C  lfs f0, 0x260c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9740 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD200: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FD204: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD208: C00B72B8  lfs f0, 0x72b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD20C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD210: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD214: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD218: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD21C: C18BBFFC  lfs f12, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FD220: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823FD224: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FD228: 4099000C  ble cr6, 0x823fd234
	if !ctx.cr[6].gt {
	pc = 0x823FD234; continue 'dispatch;
	}
	// 823FD22C: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 823FD230: 48000008  b 0x823fd238
	pc = 0x823FD238; continue 'dispatch;
	// 823FD234: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 823FD238: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FD23C: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 823FD240: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FD244: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 823FD248: 39610064  addi r11, r1, 0x64
	ctx.r[11].s64 = ctx.r[1].s64 + 100;
	// 823FD24C: 39284000  addi r9, r8, 0x4000
	ctx.r[9].s64 = ctx.r[8].s64 + 16384;
	// 823FD250: 3940003F  li r10, 0x3f
	ctx.r[10].s64 = 63;
	// 823FD254: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FD258: 7D277E70  srawi r7, r9, 0xf
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[9].s32 >> 15) as i64;
	// 823FD25C: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 823FD260: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 823FD264: 7C071C2E  lfsx f0, r7, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD268: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD26C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FD270: 4082FFE4  bne 0x823fd254
	if !ctx.cr[0].eq {
	pc = 0x823FD254; continue 'dispatch;
	}
	// 823FD274: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 823FD278: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD27C: 38A00104  li r5, 0x104
	ctx.r[5].s64 = 260;
	// 823FD280: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FD284: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 823FD288: 816A37B0  lwz r11, 0x37b0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FD28C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FD290: 4E800421  bctrl
	ctx.lr = 0x823FD294;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FD294: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 823FD298: 38810170  addi r4, r1, 0x170
	ctx.r[4].s64 = ctx.r[1].s64 + 368;
	// 823FD29C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823FD2A0: 480007E1  bl 0x823fda80
	ctx.lr = 0x823FD2A4;
	sub_823FDA80(ctx, base);
	// 823FD2A4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823FD2A8: 38DF0001  addi r6, r31, 1
	ctx.r[6].s64 = ctx.r[31].s64 + 1;
	// 823FD2AC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 823FD2B0: 39410170  addi r10, r1, 0x170
	ctx.r[10].s64 = ctx.r[1].s64 + 368;
	// 823FD2B4: 7CC70E71  srawi. r7, r6, 1
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[6].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823FD2B8: C0092384  lfs f0, 0x2384(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD2BC: 40810038  ble 0x823fd2f4
	if !ctx.cr[0].gt {
	pc = 0x823FD2F4; continue 'dispatch;
	}
	// 823FD2C0: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 823FD2C4: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD2C8: 391E0004  addi r8, r30, 4
	ctx.r[8].s64 = ctx.r[30].s64 + 4;
	// 823FD2CC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD2D0: D1BE0000  stfs f13, 0(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD2D4: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD2D8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FD2DC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD2E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FD2E4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FD2E8: D1A80000  stfs f13, 0(r8)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD2EC: 3BC80004  addi r30, r8, 4
	ctx.r[30].s64 = ctx.r[8].s64 + 4;
	// 823FD2F0: 4082FFD4  bne 0x823fd2c4
	if !ctx.cr[0].eq {
	pc = 0x823FD2C4; continue 'dispatch;
	}
	// 823FD2F4: 54EA083C  slwi r10, r7, 1
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FD2F8: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FD2FC: 419A0010  beq cr6, 0x823fd30c
	if ctx.cr[6].eq {
	pc = 0x823FD30C; continue 'dispatch;
	}
	// 823FD300: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD304: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD308: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD30C: 38210290  addi r1, r1, 0x290
	ctx.r[1].s64 = ctx.r[1].s64 + 656;
	// 823FD310: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FD314: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FD318: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823FD31C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FD320: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FD328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FD328 size=428
    let mut pc: u32 = 0x823FD328;
    'dispatch: loop {
        match pc {
            0x823FD328 => {
    //   block [0x823FD328..0x823FD4D4)
	// 823FD328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FD32C: 48137D89  bl 0x825350b4
	ctx.lr = 0x823FD330;
	sub_82535080(ctx, base);
	// 823FD330: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 823FD334: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FD338: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823FD33C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 823FD340: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 823FD344: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FD348: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 823FD34C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 823FD350: 38C0002B  li r6, 0x2b
	ctx.r[6].s64 = 43;
	// 823FD354: 38A00057  li r5, 0x57
	ctx.r[5].s64 = 87;
	// 823FD358: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FD35C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823FD360: 48001C21  bl 0x823fef80
	ctx.lr = 0x823FD364;
	sub_823FEF80(ctx, base);
	// 823FD364: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 823FD368: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823FD36C: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FD370: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FD374: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FD378: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FD37C: C00B9034  lfs f0, -0x6fcc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28620 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD380: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD384: 481375C5  bl 0x82534948
	ctx.lr = 0x823FD388;
	sub_82534948(ctx, base);
	// 823FD388: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823FD38C: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 823FD390: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 823FD394: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FD398: 2F1F0007  cmpwi cr6, r31, 7
	ctx.cr[6].compare_i32(ctx.r[31].s32, 7, &mut ctx.xer);
	// 823FD39C: 40990008  ble cr6, 0x823fd3a4
	if !ctx.cr[6].gt {
	pc = 0x823FD3A4; continue 'dispatch;
	}
	// 823FD3A0: 3BE00007  li r31, 7
	ctx.r[31].s64 = 7;
	// 823FD3A4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 823FD3A8: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 823FD3AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FD3B0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823FD3B4: 4BFFFE15  bl 0x823fd1c8
	ctx.lr = 0x823FD3B8;
	sub_823FD1C8(ctx, base);
	// 823FD3B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD3BC: C1A10080  lfs f13, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD3C0: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 823FD3C4: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 823FD3C8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 823FD3CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823FD3D0: C00B2494  lfs f0, 0x2494(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD3D4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 823FD3D8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD3DC: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 823FD3E0: 48001709  bl 0x823feae8
	ctx.lr = 0x823FD3E4;
	sub_823FEAE8(ctx, base);
	// 823FD3E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD3E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823FD3EC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 823FD3F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823FD3F4: C02B2420  lfs f1, 0x2420(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9248 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FD3F8: 48001D99  bl 0x823ff190
	ctx.lr = 0x823FD3FC;
	sub_823FF190(ctx, base);
	// 823FD3FC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 823FD400: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 823FD404: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823FD408: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823FD40C: 4BFFFBE5  bl 0x823fcff0
	ctx.lr = 0x823FD410;
	sub_823FCFF0(ctx, base);
	// 823FD410: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD414: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 823FD418: C1A10058  lfs f13, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD41C: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FD420: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823FD424: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FD428: C00BD6C8  lfs f0, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD42C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FD430: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD434: C00A9030  lfs f0, -0x6fd0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28624 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD438: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD43C: 4099005C  ble cr6, 0x823fd498
	if !ctx.cr[6].gt {
	pc = 0x823FD498; continue 'dispatch;
	}
	// 823FD440: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 823FD444: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 823FD448: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FD44C: 7F0AF000  cmpw cr6, r10, r30
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[30].s32, &mut ctx.xer);
	// 823FD450: 40980034  bge cr6, 0x823fd484
	if !ctx.cr[6].lt {
	pc = 0x823FD484; continue 'dispatch;
	}
	// 823FD454: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FD458: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 823FD45C: 7D89E42E  lfsx f12, r9, r28
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FD460: 7D692C2E  lfsx f11, r9, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FD464: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FD468: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 823FD46C: 41980018  blt cr6, 0x823fd484
	if ctx.cr[6].lt {
	pc = 0x823FD484; continue 'dispatch;
	}
	// 823FD470: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 823FD474: 40990010  ble cr6, 0x823fd484
	if !ctx.cr[6].gt {
	pc = 0x823FD484; continue 'dispatch;
	}
	// 823FD478: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823FD47C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823FD480: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 823FD484: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FD488: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 823FD48C: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FD490: 7F085000  cmpw cr6, r8, r10
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[10].s32, &mut ctx.xer);
	// 823FD494: 4198FFB4  blt cr6, 0x823fd448
	if ctx.cr[6].lt {
	pc = 0x823FD448; continue 'dispatch;
	}
	// 823FD498: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FD49C: 390B0002  addi r8, r11, 2
	ctx.r[8].s64 = ctx.r[11].s64 + 2;
	// 823FD4A0: 38EB0003  addi r7, r11, 3
	ctx.r[7].s64 = ctx.r[11].s64 + 3;
	// 823FD4A4: 7D2ADA14  add r9, r10, r27
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 823FD4A8: 39407FFF  li r10, 0x7fff
	ctx.r[10].s64 = 32767;
	// 823FD4AC: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823FD4B0: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 823FD4B4: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823FD4B8: 7D48D92E  stwx r10, r8, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[27].u32), ctx.r[10].u32) };
	// 823FD4BC: 7D47D92E  stwx r10, r7, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[27].u32), ctx.r[10].u32) };
	// 823FD4C0: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823FD4C4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FD4C8: 38210260  addi r1, r1, 0x260
	ctx.r[1].s64 = ctx.r[1].s64 + 608;
	// 823FD4CC: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 823FD4D0: 48137C34  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FD4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FD4D8 size=532
    let mut pc: u32 = 0x823FD4D8;
    'dispatch: loop {
        match pc {
            0x823FD4D8 => {
    //   block [0x823FD4D8..0x823FD6EC)
	// 823FD4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FD4DC: 48137BD9  bl 0x825350b4
	ctx.lr = 0x823FD4E0;
	sub_82535080(ctx, base);
	// 823FD4E0: 9421FD00  stwu r1, -0x300(r1)
	ea = ctx.r[1].u32.wrapping_add(-768 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FD4E4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823FD4E8: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 823FD4EC: 38A0005C  li r5, 0x5c
	ctx.r[5].s64 = 92;
	// 823FD4F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823FD4F4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823FD4F8: 48000751  bl 0x823fdc48
	ctx.lr = 0x823FD4FC;
	sub_823FDC48(ctx, base);
	// 823FD4FC: 38C10064  addi r6, r1, 0x64
	ctx.r[6].s64 = ctx.r[1].s64 + 100;
	// 823FD500: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 823FD504: 3880005C  li r4, 0x5c
	ctx.r[4].s64 = 92;
	// 823FD508: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 823FD50C: 4800079D  bl 0x823fdca8
	ctx.lr = 0x823FD510;
	sub_823FDCA8(ctx, base);
	// 823FD510: 38800056  li r4, 0x56
	ctx.r[4].s64 = 86;
	// 823FD514: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 823FD518: 4BFFFA51  bl 0x823fcf68
	ctx.lr = 0x823FD51C;
	sub_823FCF68(ctx, base);
	// 823FD51C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823FD520: 38C10078  addi r6, r1, 0x78
	ctx.r[6].s64 = ctx.r[1].s64 + 120;
	// 823FD524: C0210064  lfs f1, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FD528: 38A10210  addi r5, r1, 0x210
	ctx.r[5].s64 = ctx.r[1].s64 + 528;
	// 823FD52C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 823FD530: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FD534: 4BFFFDF5  bl 0x823fd328
	ctx.lr = 0x823FD538;
	sub_823FD328(ctx, base);
	// 823FD538: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD53C: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD540: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD544: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FD548: 40990014  ble cr6, 0x823fd55c
	if !ctx.cr[6].gt {
	pc = 0x823FD55C; continue 'dispatch;
	}
	// 823FD54C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FD550: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD554: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 823FD558: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 823FD55C: 357EFFFF  addic. r11, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FD560: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 823FD564: 41800038  blt 0x823fd59c
	if ctx.cr[0].lt {
	pc = 0x823FD59C; continue 'dispatch;
	}
	// 823FD568: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FD56C: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 823FD570: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823FD574: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD578: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FD57C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD580: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 823FD584: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 823FD588: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 823FD58C: D1AA0000  stfs f13, 0(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD590: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 823FD594: 4080FFE0  bge 0x823fd574
	if !ctx.cr[0].lt {
	pc = 0x823FD574; continue 'dispatch;
	}
	// 823FD598: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 823FD59C: 39610074  addi r11, r1, 0x74
	ctx.r[11].s64 = ctx.r[1].s64 + 116;
	// 823FD5A0: C05B0004  lfs f2, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823FD5A4: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 823FD5A8: C03B0000  lfs f1, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FD5AC: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 823FD5B0: 80C10078  lwz r6, 0x78(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 823FD5B4: 38A10210  addi r5, r1, 0x210
	ctx.r[5].s64 = ctx.r[1].s64 + 528;
	// 823FD5B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FD5BC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 823FD5C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823FD5C4: 48003365  bl 0x82400928
	ctx.lr = 0x823FD5C8;
	sub_82400928(ctx, base);
	// 823FD5C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FD5CC: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 823FD5D0: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FD5D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823FD5D8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823FD5DC: C02BFFFC  lfs f1, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FD5E0: 48003099  bl 0x82400678
	ctx.lr = 0x823FD5E4;
	sub_82400678(ctx, base);
	// 823FD5E4: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 823FD5E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823FD5EC: 7FEBFB79  or. r11, r31, r31
	ctx.r[11].u64 = ctx.r[31].u64 | ctx.r[31].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FD5F0: 48000034  b 0x823fd624
	pc = 0x823FD624; continue 'dispatch;
	// 823FD5F4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FD5F8: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 823FD5FC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 823FD600: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823FD604: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823FD608: 7C2B542E  lfsx f1, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FD60C: 48002E7D  bl 0x82400488
	ctx.lr = 0x823FD610;
	sub_82400488(ctx, base);
	// 823FD610: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 823FD614: 39210068  addi r9, r1, 0x68
	ctx.r[9].s64 = ctx.r[1].s64 + 104;
	// 823FD618: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FD61C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FD620: 7C2A4D2E  stfsx f1, r10, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 823FD624: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 823FD628: 4080FFCC  bge 0x823fd5f4
	if !ctx.cr[0].lt {
	pc = 0x823FD5F4; continue 'dispatch;
	}
	// 823FD62C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 823FD630: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FD634: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 823FD638: 40980064  bge cr6, 0x823fd69c
	if !ctx.cr[6].lt {
	pc = 0x823FD69C; continue 'dispatch;
	}
	// 823FD63C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 823FD640: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FD644: 394A8F94  addi r10, r10, -0x706c
	ctx.r[10].s64 = ctx.r[10].s64 + -28780;
	// 823FD648: 419A0024  beq cr6, 0x823fd66c
	if ctx.cr[6].eq {
	pc = 0x823FD66C; continue 'dispatch;
	}
	// 823FD64C: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD650: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823FD654: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD658: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 823FD65C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD660: 7DA83C2E  lfsx f13, r8, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD664: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FD668: 41980060  blt cr6, 0x823fd6c8
	if ctx.cr[6].lt {
	pc = 0x823FD6C8; continue 'dispatch;
	}
	// 823FD66C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FD670: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD674: 39010068  addi r8, r1, 0x68
	ctx.r[8].s64 = ctx.r[1].s64 + 104;
	// 823FD678: 57E7103A  slwi r7, r31, 2
	ctx.r[7].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 823FD67C: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 823FD680: 7DA9442E  lfsx f13, r9, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD684: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD688: 7DA7342E  lfsx f13, r7, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD68C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FD690: 40980034  bge cr6, 0x823fd6c4
	if !ctx.cr[6].lt {
	pc = 0x823FD6C4; continue 'dispatch;
	}
	// 823FD694: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 823FD698: 48000030  b 0x823fd6c8
	pc = 0x823FD6C8; continue 'dispatch;
	// 823FD69C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FD6A0: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD6A4: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 823FD6A8: 396B8F94  addi r11, r11, -0x706c
	ctx.r[11].s64 = ctx.r[11].s64 + -28780;
	// 823FD6AC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD6B0: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FD6B4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD6B8: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD6BC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FD6C0: 41980008  blt cr6, 0x823fd6c8
	if ctx.cr[6].lt {
	pc = 0x823FD6C8; continue 'dispatch;
	}
	// 823FD6C4: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 823FD6C8: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FD6CC: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 823FD6D0: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 823FD6D4: 7C2B542E  lfsx f1, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FD6D8: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD6DC: D01B0004  stfs f0, 4(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FD6E0: D03B0000  stfs f1, 0(r27)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD6E4: 38210300  addi r1, r1, 0x300
	ctx.r[1].s64 = ctx.r[1].s64 + 768;
	// 823FD6E8: 48137A1C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FD6F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823FD6F0 size=24
    let mut pc: u32 = 0x823FD6F0;
    'dispatch: loop {
        match pc {
            0x823FD6F0 => {
    //   block [0x823FD6F0..0x823FD708)
	// 823FD6F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FD6F4: 3940004A  li r10, 0x4a
	ctx.r[10].s64 = 74;
	// 823FD6F8: 396B8E38  addi r11, r11, -0x71c8
	ctx.r[11].s64 = ctx.r[11].s64 + -29128;
	// 823FD6FC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FD700: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823FD704: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FD708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FD708 size=116
    let mut pc: u32 = 0x823FD708;
    'dispatch: loop {
        match pc {
            0x823FD708 => {
    //   block [0x823FD708..0x823FD77C)
	// 823FD708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FD70C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FD710: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FD714: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FD718: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823FD71C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FD720: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 823FD724: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FD728: 816B37A8  lwz r11, 0x37a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FD72C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FD730: 4E800421  bctrl
	ctx.lr = 0x823FD734;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FD734: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FD738: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 823FD73C: 4082000C  bne 0x823fd748
	if !ctx.cr[0].eq {
	pc = 0x823FD748; continue 'dispatch;
	}
	// 823FD740: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FD744: 48000024  b 0x823fd768
	pc = 0x823FD768; continue 'dispatch;
	// 823FD748: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD74C: C00B2094  lfs f0, 0x2094(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD750: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD754: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD758: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FD75C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FD760: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD764: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FD768: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823FD76C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FD770: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FD774: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FD778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FD780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FD780 size=80
    let mut pc: u32 = 0x823FD780;
    'dispatch: loop {
        match pc {
            0x823FD780 => {
    //   block [0x823FD780..0x823FD7D0)
	// 823FD780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FD784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FD788: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FD78C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FD790: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FD794: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FD798: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FD79C: 4182001C  beq 0x823fd7b8
	if ctx.cr[0].eq {
	pc = 0x823FD7B8; continue 'dispatch;
	}
	// 823FD7A0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823FD7A4: 816B37AC  lwz r11, 0x37ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FD7A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FD7AC: 4E800421  bctrl
	ctx.lr = 0x823FD7B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FD7B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FD7B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FD7B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FD7BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823FD7C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FD7C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FD7C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FD7CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FD7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FD7D0 size=112
    let mut pc: u32 = 0x823FD7D0;
    'dispatch: loop {
        match pc {
            0x823FD7D0 => {
    //   block [0x823FD7D0..0x823FD840)
	// 823FD7D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FD7D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FD7D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823FD7DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FD7E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FD7E4: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823FD7E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FD7EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FD7F0: 388005D4  li r4, 0x5d4
	ctx.r[4].s64 = 1492;
	// 823FD7F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FD7F8: 816B37A8  lwz r11, 0x37a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FD7FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FD800: 4E800421  bctrl
	ctx.lr = 0x823FD804;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FD804: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FD808: 4082000C  bne 0x823fd814
	if !ctx.cr[0].eq {
	pc = 0x823FD814; continue 'dispatch;
	}
	// 823FD80C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FD810: 48000018  b 0x823fd828
	pc = 0x823FD828; continue 'dispatch;
	// 823FD814: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FD818: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FD81C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FD820: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823FD824: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823FD828: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FD82C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FD830: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FD834: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823FD838: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FD83C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FD840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FD840 size=284
    let mut pc: u32 = 0x823FD840;
    'dispatch: loop {
        match pc {
            0x823FD840 => {
    //   block [0x823FD840..0x823FD95C)
	// 823FD840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FD844: 48137861  bl 0x825350a4
	ctx.lr = 0x823FD848;
	sub_82535080(ctx, base);
	// 823FD848: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FD84C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823FD850: 548B083E  rotlwi r11, r4, 1
	ctx.r[11].u64 = ((ctx.r[4].u32).rotate_left(1)) as u64;
	// 823FD854: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823FD858: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823FD85C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 823FD860: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FD864: 3B5D0008  addi r26, r29, 8
	ctx.r[26].s64 = ctx.r[29].s64 + 8;
	// 823FD868: 82FD0004  lwz r23, 4(r29)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FD86C: 7D44FBD6  divw r10, r4, r31
	ctx.r[10].s32 = ctx.r[4].s32 / ctx.r[31].s32;
	// 823FD870: 7FE95878  andc r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 & !ctx.r[11].u64;
	// 823FD874: 7D6AF9D6  mullw r11, r10, r31
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[31].s32 as i64);
	// 823FD878: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 823FD87C: 0CA9FFFF  twi 5, r9, -1
	// 823FD880: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 823FD884: 0CDF0000  twi 6, r31, 0
	// 823FD888: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823FD88C: 0CDF0000  twi 6, r31, 0
	// 823FD890: 7D2BFBD6  divw r9, r11, r31
	ctx.r[9].s32 = ctx.r[11].s32 / ctx.r[31].s32;
	// 823FD894: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 823FD898: 7D29F9D6  mullw r9, r9, r31
	ctx.r[9].s64 = (ctx.r[9].s32 as i64) * (ctx.r[31].s32 as i64);
	// 823FD89C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 823FD8A0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823FD8A4: 7F8BF850  subf r28, r11, r31
	ctx.r[28].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 823FD8A8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FD8AC: 7FEA5078  andc r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 & !ctx.r[10].u64;
	// 823FD8B0: 7F1CF000  cmpw cr6, r28, r30
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[30].s32, &mut ctx.xer);
	// 823FD8B4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823FD8B8: 0CAAFFFF  twi 5, r10, -1
	// 823FD8BC: 7C6BD214  add r3, r11, r26
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 823FD8C0: 41980014  blt cr6, 0x823fd8d4
	if ctx.cr[6].lt {
	pc = 0x823FD8D4; continue 'dispatch;
	}
	// 823FD8C4: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 823FD8C8: 57C5103A  slwi r5, r30, 2
	ctx.r[5].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 823FD8CC: 816A37B4  lwz r11, 0x37b4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FD8D0: 48000030  b 0x823fd900
	pc = 0x823FD900; continue 'dispatch;
	// 823FD8D4: 3F008288  lis r24, -0x7d78
	ctx.r[24].s64 = -2105016320;
	// 823FD8D8: 5799103A  slwi r25, r28, 2
	ctx.r[25].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 823FD8DC: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 823FD8E0: 817837B4  lwz r11, 0x37b4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FD8E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FD8E8: 4E800421  bctrl
	ctx.lr = 0x823FD8EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FD8EC: 7D7CF050  subf r11, r28, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[28].s64;
	// 823FD8F0: 7C99DA14  add r4, r25, r27
	ctx.r[4].u64 = ctx.r[25].u64 + ctx.r[27].u64;
	// 823FD8F4: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 823FD8F8: 817837B4  lwz r11, 0x37b4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FD8FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823FD900: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FD904: 4E800421  bctrl
	ctx.lr = 0x823FD908;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FD908: 7D7EFBD6  divw r11, r30, r31
	ctx.r[11].s32 = ctx.r[30].s32 / ctx.r[31].s32;
	// 823FD90C: 57CA083E  rotlwi r10, r30, 1
	ctx.r[10].u64 = ((ctx.r[30].u32).rotate_left(1)) as u64;
	// 823FD910: 7D6BF9D6  mullw r11, r11, r31
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[31].s32 as i64);
	// 823FD914: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 823FD918: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823FD91C: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 823FD920: 7FEA5078  andc r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 & !ctx.r[10].u64;
	// 823FD924: 7D2BFA14  add r9, r11, r31
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823FD928: 0CAAFFFF  twi 5, r10, -1
	// 823FD92C: 7D49FBD6  divw r10, r9, r31
	ctx.r[10].s32 = ctx.r[9].s32 / ctx.r[31].s32;
	// 823FD930: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 823FD934: 7D4AF9D6  mullw r10, r10, r31
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[31].s32 as i64);
	// 823FD938: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823FD93C: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 823FD940: 7FEB5878  andc r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 & !ctx.r[11].u64;
	// 823FD944: 0CDF0000  twi 6, r31, 0
	// 823FD948: 0CDF0000  twi 6, r31, 0
	// 823FD94C: 0CABFFFF  twi 5, r11, -1
	// 823FD950: 915D0004  stw r10, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823FD954: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823FD958: 4813779C  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FD960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FD960 size=220
    let mut pc: u32 = 0x823FD960;
    'dispatch: loop {
        match pc {
            0x823FD960 => {
    //   block [0x823FD960..0x823FDA3C)
	// 823FD960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FD964: 4813774D  bl 0x825350b0
	ctx.lr = 0x823FD968;
	sub_82535080(ctx, base);
	// 823FD968: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FD96C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 823FD970: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FD974: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 823FD978: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FD97C: 395F0001  addi r10, r31, 1
	ctx.r[10].s64 = ctx.r[31].s64 + 1;
	// 823FD980: 0CCB0000  twi 6, r11, 0
	// 823FD984: 7D4A0E70  srawi r10, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 823FD988: 0CCB0000  twi 6, r11, 0
	// 823FD98C: 7D4A2214  add r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 823FD990: 3B830008  addi r28, r3, 8
	ctx.r[28].s64 = ctx.r[3].s64 + 8;
	// 823FD994: 7D0A00D0  neg r8, r10
	ctx.r[8].s64 = -ctx.r[10].s64;
	// 823FD998: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823FD99C: 550A083E  rotlwi r10, r8, 1
	ctx.r[10].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 823FD9A0: 7CE85BD6  divw r7, r8, r11
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	// 823FD9A4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823FD9A8: 7D665078  andc r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 & !ctx.r[10].u64;
	// 823FD9AC: 7D4759D6  mullw r10, r7, r11
	ctx.r[10].s64 = (ctx.r[7].s32 as i64) * (ctx.r[11].s32 as i64);
	// 823FD9B0: 7D4A4050  subf r10, r10, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 823FD9B4: 0CA6FFFF  twi 5, r6, -1
	// 823FD9B8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823FD9BC: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823FD9C0: 7D0A5BD6  divw r8, r10, r11
	ctx.r[8].s32 = ctx.r[10].s32 / ctx.r[11].s32;
	// 823FD9C4: 5549083E  rotlwi r9, r10, 1
	ctx.r[9].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 823FD9C8: 7D0859D6  mullw r8, r8, r11
	ctx.r[8].s64 = (ctx.r[8].s32 as i64) * (ctx.r[11].s32 as i64);
	// 823FD9CC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 823FD9D0: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823FD9D4: 7FCA5850  subf r30, r10, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 823FD9D8: 7D694878  andc r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 & !ctx.r[9].u64;
	// 823FD9DC: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FD9E0: 7F1EF800  cmpw cr6, r30, r31
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[31].s32, &mut ctx.xer);
	// 823FD9E4: 0CA9FFFF  twi 5, r9, -1
	// 823FD9E8: 7C8BE214  add r4, r11, r28
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 823FD9EC: 41980014  blt cr6, 0x823fda00
	if ctx.cr[6].lt {
	pc = 0x823FDA00; continue 'dispatch;
	}
	// 823FD9F0: 3D208288  lis r9, -0x7d78
	ctx.r[9].s64 = -2105016320;
	// 823FD9F4: 57E5103A  slwi r5, r31, 2
	ctx.r[5].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 823FD9F8: 816937B4  lwz r11, 0x37b4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FD9FC: 48000030  b 0x823fda2c
	pc = 0x823FDA2C; continue 'dispatch;
	// 823FDA00: 3F408288  lis r26, -0x7d78
	ctx.r[26].s64 = -2105016320;
	// 823FDA04: 57DB103A  slwi r27, r30, 2
	ctx.r[27].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 823FDA08: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 823FDA0C: 817A37B4  lwz r11, 0x37b4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FDA10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FDA14: 4E800421  bctrl
	ctx.lr = 0x823FDA18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FDA18: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 823FDA1C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823FDA20: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 823FDA24: 817A37B4  lwz r11, 0x37b4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FDA28: 7C7BEA14  add r3, r27, r29
	ctx.r[3].u64 = ctx.r[27].u64 + ctx.r[29].u64;
	// 823FDA2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FDA30: 4E800421  bctrl
	ctx.lr = 0x823FDA34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FDA34: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823FDA38: 481376C8  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FDA40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FDA40 size=60
    let mut pc: u32 = 0x823FDA40;
    'dispatch: loop {
        match pc {
            0x823FDA40 => {
    //   block [0x823FDA40..0x823FDA7C)
	// 823FDA40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FDA44: 48137679  bl 0x825350bc
	ctx.lr = 0x823FDA48;
	sub_82535080(ctx, base);
	// 823FDA48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FDA4C: 7CAB0E70  srawi r11, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 823FDA50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FDA54: 7FAB0194  addze r29, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[29].s64 = tmp.s64;
	// 823FDA58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FDA5C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823FDA60: 480034E1  bl 0x82400f40
	ctx.lr = 0x823FDA64;
	sub_82400F40(ctx, base);
	// 823FDA64: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823FDA68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FDA6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FDA70: 48003289  bl 0x82400cf8
	ctx.lr = 0x823FDA74;
	sub_82400CF8(ctx, base);
	// 823FDA74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FDA78: 48137694  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FDA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FDA80 size=60
    let mut pc: u32 = 0x823FDA80;
    'dispatch: loop {
        match pc {
            0x823FDA80 => {
    //   block [0x823FDA80..0x823FDABC)
	// 823FDA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FDA84: 48137639  bl 0x825350bc
	ctx.lr = 0x823FDA88;
	sub_82535080(ctx, base);
	// 823FDA88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FDA8C: 7CAB0E70  srawi r11, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 823FDA90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FDA94: 7FAB0194  addze r29, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[29].s64 = tmp.s64;
	// 823FDA98: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FDA9C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823FDAA0: 48003379  bl 0x82400e18
	ctx.lr = 0x823FDAA4;
	sub_82400E18(ctx, base);
	// 823FDAA4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823FDAA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823FDAAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823FDAB0: 48003491  bl 0x82400f40
	ctx.lr = 0x823FDAB4;
	sub_82400F40(ctx, base);
	// 823FDAB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FDAB8: 48137654  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FDAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FDAC0 size=340
    let mut pc: u32 = 0x823FDAC0;
    'dispatch: loop {
        match pc {
            0x823FDAC0 => {
    //   block [0x823FDAC0..0x823FDC14)
	// 823FDAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FDAC4: 481375F9  bl 0x825350bc
	ctx.lr = 0x823FDAC8;
	sub_82535080(ctx, base);
	// 823FDAC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FDACC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823FDAD0: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 823FDAD4: 7C830E70  srawi r3, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 823FDAD8: 7C8B1671  srawi. r11, r4, 2
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[4].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FDADC: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 823FDAE0: 20CB0100  subfic r6, r11, 0x100
	ctx.xer.ca = ctx.r[11].u32 <= 256 as u32;
	ctx.r[6].s64 = (256 as i64) - ctx.r[11].s64;
	// 823FDAE4: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 823FDAE8: 7D452830  slw r5, r10, r5
	if (ctx.r[5].u8 & 0x20) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = ((ctx.r[10].u32) << ((ctx.r[5].u8 & 0x1F) as u32)) as u64;
	}
	// 823FDAEC: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FDAF0: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 823FDAF4: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 823FDAF8: 40810030  ble 0x823fdb28
	if !ctx.cr[0].gt {
	pc = 0x823FDB28; continue 'dispatch;
	}
	// 823FDAFC: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 823FDB00: C0090000  lfs f0, 0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDB04: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FDB08: D0080000  stfs f0, 0(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDB0C: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823FDB10: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FDB14: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDB18: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FDB1C: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDB20: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FDB24: 4082FFDC  bne 0x823fdb00
	if !ctx.cr[0].eq {
	pc = 0x823FDB00; continue 'dispatch;
	}
	// 823FDB28: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FDB2C: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 823FDB30: 7D0B2050  subf r8, r11, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 823FDB34: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823FDB38: 7D070E71  srawi. r7, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823FDB3C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823FDB40: 40810030  ble 0x823fdb70
	if !ctx.cr[0].gt {
	pc = 0x823FDB70; continue 'dispatch;
	}
	// 823FDB44: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 823FDB48: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDB4C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FDB50: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDB54: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823FDB58: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FDB5C: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDB60: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FDB64: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDB68: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FDB6C: 4082FFDC  bne 0x823fdb48
	if !ctx.cr[0].eq {
	pc = 0x823FDB48; continue 'dispatch;
	}
	// 823FDB70: 5467083C  slwi r7, r3, 1
	ctx.r[7].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 823FDB74: 7F043800  cmpw cr6, r4, r7
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[7].s32, &mut ctx.xer);
	// 823FDB78: 419A0024  beq cr6, 0x823fdb9c
	if ctx.cr[6].eq {
	pc = 0x823FDB9C; continue 'dispatch;
	}
	// 823FDB7C: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FDB80: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823FDB84: D1AA0000  stfs f13, 0(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDB88: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 823FDB8C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FDB90: C0091FF8  lfs f0, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDB94: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDB98: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FDB9C: 7F083000  cmpw cr6, r8, r6
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FDBA0: 40980044  bge cr6, 0x823fdbe4
	if !ctx.cr[6].lt {
	pc = 0x823FDBE4; continue 'dispatch;
	}
	// 823FDBA4: 7D283050  subf r9, r8, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[8].s64;
	// 823FDBA8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823FDBAC: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FDBB0: 5528F0BF  rlwinm. r8, r9, 0x1e, 2, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823FDBB4: 41820014  beq 0x823fdbc8
	if ctx.cr[0].eq {
	pc = 0x823FDBC8; continue 'dispatch;
	}
	// 823FDBB8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 823FDBBC: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 823FDBC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FDBC4: 4200FFF8  bdnz 0x823fdbbc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x823FDBBC; continue 'dispatch;
	}
	// 823FDBC8: 552BF0BF  rlwinm. r11, r9, 0x1e, 2, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FDBCC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FDBD0: 41820014  beq 0x823fdbe4
	if ctx.cr[0].eq {
	pc = 0x823FDBE4; continue 'dispatch;
	}
	// 823FDBD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FDBD8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823FDBDC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FDBE0: 4200FFF8  bdnz 0x823fdbd8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x823FDBD8; continue 'dispatch;
	}
	// 823FDBE4: 7CAB0E70  srawi r11, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 823FDBE8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823FDBEC: 7FEB0194  addze r31, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[31].s64 = tmp.s64;
	// 823FDBF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823FDBF4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823FDBF8: 48003349  bl 0x82400f40
	ctx.lr = 0x823FDBFC;
	sub_82400F40(ctx, base);
	// 823FDBFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823FDC00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823FDC04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823FDC08: 480030F1  bl 0x82400cf8
	ctx.lr = 0x823FDC0C;
	sub_82400CF8(ctx, base);
	// 823FDC0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FDC10: 481374FC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FDC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FDC18 size=16
    let mut pc: u32 = 0x823FDC18;
    'dispatch: loop {
        match pc {
            0x823FDC18 => {
    //   block [0x823FDC18..0x823FDC28)
	// 823FDC18: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FDC1C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FDC20: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FDC24: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FDC28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FDC28 size=32
    let mut pc: u32 = 0x823FDC28;
    'dispatch: loop {
        match pc {
            0x823FDC28 => {
    //   block [0x823FDC28..0x823FDC48)
	// 823FDC28: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDC2C: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FDC30: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FDC34: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 823FDC38: EC200B7A  fmadds f1, f0, f13, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64);
	// 823FDC3C: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 823FDC40: 4181FFE8  bgt 0x823fdc28
	if ctx.cr[0].gt {
	pc = 0x823FDC28; continue 'dispatch;
	}
	// 823FDC44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FDC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823FDC48 size=8
    let mut pc: u32 = 0x823FDC48;
    'dispatch: loop {
        match pc {
            0x823FDC48 => {
    //   block [0x823FDC48..0x823FDC50)
	// 823FDC48: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FDC4C: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FDC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FDC50 size=44
    let mut pc: u32 = 0x823FDC50;
    'dispatch: loop {
        match pc {
            0x823FDC50 => {
    //   block [0x823FDC50..0x823FDC7C)
	// 823FDC50: C1A30000  lfs f13, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FDC54: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FDC58: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FDC5C: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDC60: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 823FDC64: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 823FDC68: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FDC6C: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDC70: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 823FDC74: 4181FFDC  bgt 0x823fdc50
	if ctx.cr[0].gt {
	pc = 0x823FDC50; continue 'dispatch;
	}
	// 823FDC78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FDC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823FDC80 size=8
    let mut pc: u32 = 0x823FDC80;
    'dispatch: loop {
        match pc {
            0x823FDC80 => {
    //   block [0x823FDC80..0x823FDC88)
	// 823FDC80: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823FDC84: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FDC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FDC88 size=32
    let mut pc: u32 = 0x823FDC88;
    'dispatch: loop {
        match pc {
            0x823FDC88 => {
    //   block [0x823FDC88..0x823FDCA8)
	// 823FDC88: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDC8C: 3484FFFF  addic. r4, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823FDC90: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 823FDC94: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDC98: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 823FDC9C: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 823FDCA0: 4181FFE8  bgt 0x823fdc88
	if ctx.cr[0].gt {
	pc = 0x823FDC88; continue 'dispatch;
	}
	// 823FDCA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FDCA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FDCA8 size=520
    let mut pc: u32 = 0x823FDCA8;
    'dispatch: loop {
        match pc {
            0x823FDCA8 => {
    //   block [0x823FDCA8..0x823FDEB0)
	// 823FDCA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FDCAC: 48137411  bl 0x825350bc
	ctx.lr = 0x823FDCB0;
	sub_82535080(ctx, base);
	// 823FDCB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FDCB4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823FDCB8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823FDCBC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823FDCC0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 823FDCC4: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823FDCC8: 40800108  bge 0x823fddd0
	if !ctx.cr[0].lt {
	pc = 0x823FDDD0; continue 'dispatch;
	}
	// 823FDCCC: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 823FDCD0: 38E3000C  addi r7, r3, 0xc
	ctx.r[7].s64 = ctx.r[3].s64 + 12;
	// 823FDCD4: 39280003  addi r9, r8, 3
	ctx.r[9].s64 = ctx.r[8].s64 + 3;
	// 823FDCD8: 7F092000  cmpw cr6, r9, r4
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[4].s32, &mut ctx.xer);
	// 823FDCDC: 419900A8  bgt cr6, 0x823fdd84
	if ctx.cr[6].gt {
	pc = 0x823FDD84; continue 'dispatch;
	}
	// 823FDCE0: 8127FFF8  lwz r9, -8(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FDCE4: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDCE8: 4099000C  ble cr6, 0x823fdcf4
	if !ctx.cr[6].gt {
	pc = 0x823FDCF4; continue 'dispatch;
	}
	// 823FDCEC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDCF0: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 823FDCF4: 7F09F000  cmpw cr6, r9, r30
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[30].s32, &mut ctx.xer);
	// 823FDCF8: 4098000C  bge cr6, 0x823fdd04
	if !ctx.cr[6].lt {
	pc = 0x823FDD04; continue 'dispatch;
	}
	// 823FDCFC: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 823FDD00: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 823FDD04: 8127FFFC  lwz r9, -4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-4 as u32) ) } as u64;
	// 823FDD08: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDD0C: 4099000C  ble cr6, 0x823fdd18
	if !ctx.cr[6].gt {
	pc = 0x823FDD18; continue 'dispatch;
	}
	// 823FDD10: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDD14: 7D1F4378  mr r31, r8
	ctx.r[31].u64 = ctx.r[8].u64;
	// 823FDD18: 7F09F000  cmpw cr6, r9, r30
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[30].s32, &mut ctx.xer);
	// 823FDD1C: 4098000C  bge cr6, 0x823fdd28
	if !ctx.cr[6].lt {
	pc = 0x823FDD28; continue 'dispatch;
	}
	// 823FDD20: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 823FDD24: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 823FDD28: 81270000  lwz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FDD2C: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDD30: 4099000C  ble cr6, 0x823fdd3c
	if !ctx.cr[6].gt {
	pc = 0x823FDD3C; continue 'dispatch;
	}
	// 823FDD34: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDD38: 3BE80001  addi r31, r8, 1
	ctx.r[31].s64 = ctx.r[8].s64 + 1;
	// 823FDD3C: 7F09F000  cmpw cr6, r9, r30
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[30].s32, &mut ctx.xer);
	// 823FDD40: 4098000C  bge cr6, 0x823fdd4c
	if !ctx.cr[6].lt {
	pc = 0x823FDD4C; continue 'dispatch;
	}
	// 823FDD44: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 823FDD48: 3BA80001  addi r29, r8, 1
	ctx.r[29].s64 = ctx.r[8].s64 + 1;
	// 823FDD4C: 81270004  lwz r9, 4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FDD50: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDD54: 4099000C  ble cr6, 0x823fdd60
	if !ctx.cr[6].gt {
	pc = 0x823FDD60; continue 'dispatch;
	}
	// 823FDD58: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDD5C: 3BE80002  addi r31, r8, 2
	ctx.r[31].s64 = ctx.r[8].s64 + 2;
	// 823FDD60: 7F09F000  cmpw cr6, r9, r30
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[30].s32, &mut ctx.xer);
	// 823FDD64: 4098000C  bge cr6, 0x823fdd70
	if !ctx.cr[6].lt {
	pc = 0x823FDD70; continue 'dispatch;
	}
	// 823FDD68: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 823FDD6C: 3BA80002  addi r29, r8, 2
	ctx.r[29].s64 = ctx.r[8].s64 + 2;
	// 823FDD70: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FDD74: 38E70010  addi r7, r7, 0x10
	ctx.r[7].s64 = ctx.r[7].s64 + 16;
	// 823FDD78: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FDD7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FDD80: 4198FF54  blt cr6, 0x823fdcd4
	if ctx.cr[6].lt {
	pc = 0x823FDCD4; continue 'dispatch;
	}
	// 823FDD84: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FDD88: 40980048  bge cr6, 0x823fddd0
	if !ctx.cr[6].lt {
	pc = 0x823FDDD0; continue 'dispatch;
	}
	// 823FDD8C: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FDD90: 7D091A14  add r8, r9, r3
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 823FDD94: 7F0A2000  cmpw cr6, r10, r4
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[4].s32, &mut ctx.xer);
	// 823FDD98: 40980038  bge cr6, 0x823fddd0
	if !ctx.cr[6].lt {
	pc = 0x823FDDD0; continue 'dispatch;
	}
	// 823FDD9C: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FDDA0: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDDA4: 4099000C  ble cr6, 0x823fddb0
	if !ctx.cr[6].gt {
	pc = 0x823FDDB0; continue 'dispatch;
	}
	// 823FDDA8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDDAC: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 823FDDB0: 7F09F000  cmpw cr6, r9, r30
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[30].s32, &mut ctx.xer);
	// 823FDDB4: 4098000C  bge cr6, 0x823fddc0
	if !ctx.cr[6].lt {
	pc = 0x823FDDC0; continue 'dispatch;
	}
	// 823FDDB8: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 823FDDBC: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 823FDDC0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823FDDC4: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FDDC8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FDDCC: 4198FFC8  blt cr6, 0x823fdd94
	if ctx.cr[6].lt {
	pc = 0x823FDD94; continue 'dispatch;
	}
	// 823FDDD0: 38EA0004  addi r7, r10, 4
	ctx.r[7].s64 = ctx.r[10].s64 + 4;
	// 823FDDD4: 7F072000  cmpw cr6, r7, r4
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[4].s32, &mut ctx.xer);
	// 823FDDD8: 41990074  bgt cr6, 0x823fde4c
	if ctx.cr[6].gt {
	pc = 0x823FDE4C; continue 'dispatch;
	}
	// 823FDDDC: 392A0002  addi r9, r10, 2
	ctx.r[9].s64 = ctx.r[10].s64 + 2;
	// 823FDDE0: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FDDE4: 7D091A14  add r8, r9, r3
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 823FDDE8: 8128FFF8  lwz r9, -8(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FDDEC: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDDF0: 4099000C  ble cr6, 0x823fddfc
	if !ctx.cr[6].gt {
	pc = 0x823FDDFC; continue 'dispatch;
	}
	// 823FDDF4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDDF8: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 823FDDFC: 8128FFFC  lwz r9, -4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-4 as u32) ) } as u64;
	// 823FDE00: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDE04: 4099000C  ble cr6, 0x823fde10
	if !ctx.cr[6].gt {
	pc = 0x823FDE10; continue 'dispatch;
	}
	// 823FDE08: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDE0C: 3BEA0001  addi r31, r10, 1
	ctx.r[31].s64 = ctx.r[10].s64 + 1;
	// 823FDE10: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FDE14: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDE18: 4099000C  ble cr6, 0x823fde24
	if !ctx.cr[6].gt {
	pc = 0x823FDE24; continue 'dispatch;
	}
	// 823FDE1C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDE20: 3BEA0002  addi r31, r10, 2
	ctx.r[31].s64 = ctx.r[10].s64 + 2;
	// 823FDE24: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FDE28: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDE2C: 4099000C  ble cr6, 0x823fde38
	if !ctx.cr[6].gt {
	pc = 0x823FDE38; continue 'dispatch;
	}
	// 823FDE30: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDE34: 3BEA0003  addi r31, r10, 3
	ctx.r[31].s64 = ctx.r[10].s64 + 3;
	// 823FDE38: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 823FDE3C: 39080010  addi r8, r8, 0x10
	ctx.r[8].s64 = ctx.r[8].s64 + 16;
	// 823FDE40: 38EA0004  addi r7, r10, 4
	ctx.r[7].s64 = ctx.r[10].s64 + 4;
	// 823FDE44: 7F072000  cmpw cr6, r7, r4
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[4].s32, &mut ctx.xer);
	// 823FDE48: 4099FFA0  ble cr6, 0x823fdde8
	if !ctx.cr[6].gt {
	pc = 0x823FDDE8; continue 'dispatch;
	}
	// 823FDE4C: 7F0A2000  cmpw cr6, r10, r4
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[4].s32, &mut ctx.xer);
	// 823FDE50: 40980030  bge cr6, 0x823fde80
	if !ctx.cr[6].lt {
	pc = 0x823FDE80; continue 'dispatch;
	}
	// 823FDE54: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FDE58: 7D091A14  add r8, r9, r3
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 823FDE5C: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FDE60: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDE64: 4099000C  ble cr6, 0x823fde70
	if !ctx.cr[6].gt {
	pc = 0x823FDE70; continue 'dispatch;
	}
	// 823FDE68: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDE6C: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 823FDE70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823FDE74: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FDE78: 7F0A2000  cmpw cr6, r10, r4
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[4].s32, &mut ctx.xer);
	// 823FDE7C: 4198FFE0  blt cr6, 0x823fde5c
	if ctx.cr[6].lt {
	pc = 0x823FDE5C; continue 'dispatch;
	}
	// 823FDE80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FDE84: 9161FFD0  stw r11, -0x30(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[11].u32 ) };
	// 823FDE88: 4098000C  bge cr6, 0x823fde94
	if !ctx.cr[6].lt {
	pc = 0x823FDE94; continue 'dispatch;
	}
	// 823FDE8C: 93C1FFD0  stw r30, -0x30(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[30].u32 ) };
	// 823FDE90: 4198000C  blt cr6, 0x823fde9c
	if ctx.cr[6].lt {
	pc = 0x823FDE9C; continue 'dispatch;
	}
	// 823FDE94: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 823FDE98: 48000008  b 0x823fdea0
	pc = 0x823FDEA0; continue 'dispatch;
	// 823FDE9C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823FDEA0: C001FFD0  lfs f0, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDEA4: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FDEA8: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDEAC: 48137260  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FDEB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FDEB0 size=524
    let mut pc: u32 = 0x823FDEB0;
    'dispatch: loop {
        match pc {
            0x823FDEB0 => {
    //   block [0x823FDEB0..0x823FE0BC)
	// 823FDEB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FDEB4: 48137205  bl 0x825350b8
	ctx.lr = 0x823FDEB8;
	sub_82535080(ctx, base);
	// 823FDEB8: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 823FDEBC: 4813812D  bl 0x82535fe8
	ctx.lr = 0x823FDEC0;
	sub_82535FB0(ctx, base);
	// 823FDEC0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FDEC4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 823FDEC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FDECC: 7FA907B4  extsw r9, r29
	ctx.r[9].s64 = ctx.r[29].s32 as i64;
	// 823FDED0: 397DFFFF  addi r11, r29, -1
	ctx.r[11].s64 = ctx.r[29].s64 + -1;
	// 823FDED4: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 823FDED8: 7D6807B4  extsw r8, r11
	ctx.r[8].s64 = ctx.r[11].s32 as i64;
	// 823FDEDC: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FDEE0: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 823FDEE4: 7FBC0E70  srawi r28, r29, 1
	ctx.xer.ca = (ctx.r[29].s32 < 0) && ((ctx.r[29].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[29].s32 >> 1) as i64;
	// 823FDEE8: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823FDEEC: 814A37B8  lwz r10, 0x37b8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14264 as u32) ) } as u64;
	// 823FDEF0: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 823FDEF4: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 823FDEF8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FDEFC: C3AB2068  lfs f29, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 823FDF00: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FDF04: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FDF08: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FDF0C: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823FDF10: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823FDF14: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FDF18: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823FDF1C: C1AB2204  lfs f13, 0x2204(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8708 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FDF20: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FDF24: EC1D0024  fdivs f0, f29, f0
	ctx.f[0].f64 = ((ctx.f[29].f64 / ctx.f[0].f64) as f32) as f64;
	// 823FDF28: EC2D6024  fdivs f1, f13, f12
	ctx.f[1].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 823FDF2C: C1AB903C  lfs f13, -0x6fc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28612 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FDF30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FDF34: EF800372  fmuls f28, f0, f13
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FDF38: C1AB9038  lfs f13, -0x6fc8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28616 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FDF3C: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FDF40: FFC0E090  fmr f30, f28
	ctx.f[30].f64 = ctx.f[28].f64;
	// 823FDF44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 823FDF48: 4E800421  bctrl
	ctx.lr = 0x823FDF4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FDF4C: EC1FE028  fsubs f0, f31, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[28].f64) as f32) as f64);
	// 823FDF50: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 823FDF54: C19F0000  lfs f12, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FDF58: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 823FDF5C: 395EFFFC  addi r10, r30, -4
	ctx.r[10].s64 = ctx.r[30].s64 + -4;
	// 823FDF60: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 823FDF64: 2F1C0004  cmpwi cr6, r28, 4
	ctx.cr[6].compare_i32(ctx.r[28].s32, 4, &mut ctx.xer);
	// 823FDF68: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FDF6C: D19F0000  stfs f12, 0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDF70: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FDF74: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FDF78: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDF7C: EC0D0732  fmuls f0, f13, f28
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[28].f64) as f32) as f64);
	// 823FDF80: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FDF84: EDAD0772  fmuls f13, f13, f29
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 823FDF88: ED9F0028  fsubs f12, f31, f0
	ctx.f[12].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FDF8C: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FDF90: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDF94: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FDF98: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FDF9C: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FDFA0: D18A0000  stfs f12, 0(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDFA4: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 823FDFA8: 40990090  ble cr6, 0x823fe038
	if !ctx.cr[6].gt {
	pc = 0x823FE038; continue 'dispatch;
	}
	// 823FDFAC: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 823FDFB0: ED80F378  fmsubs f12, f0, f13, f30
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[30].f64) as f32) as f64);
	// 823FDFB4: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FDFB8: 39080003  addi r8, r8, 3
	ctx.r[8].s64 = ctx.r[8].s64 + 3;
	// 823FDFBC: 39290003  addi r9, r9, 3
	ctx.r[9].s64 = ctx.r[9].s64 + 3;
	// 823FDFC0: 7F08E000  cmpw cr6, r8, r28
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[28].s32, &mut ctx.xer);
	// 823FDFC4: ED7F6028  fsubs f11, f31, f12
	ctx.f[11].f64 = (((ctx.f[31].f64 - ctx.f[12].f64) as f32) as f64);
	// 823FDFC8: EFCC0378  fmsubs f30, f12, f13, f0
	ctx.f[30].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FDFCC: EC0A02F2  fmuls f0, f10, f11
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FDFD0: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDFD4: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDFD8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FDFDC: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FDFE0: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDFE4: ED7FF028  fsubs f11, f31, f30
	ctx.f[11].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 823FDFE8: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 823FDFEC: EC0D67B8  fmsubs f0, f13, f30, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[30].f64 - ctx.f[12].f64) as f32) as f64);
	// 823FDFF0: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FDFF4: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FDFF8: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDFFC: C18A0000  lfs f12, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FE000: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FE004: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FE008: D18A0000  stfs f12, 0(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE00C: ED9F0028  fsubs f12, f31, f0
	ctx.f[12].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FE010: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 823FE014: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FE018: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FE01C: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE020: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FE024: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FE028: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FE02C: D18A0000  stfs f12, 0(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE030: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 823FE034: 4198FF7C  blt cr6, 0x823fdfb0
	if ctx.cr[6].lt {
	pc = 0x823FDFB0; continue 'dispatch;
	}
	// 823FE038: 7F09E000  cmpw cr6, r9, r28
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[28].s32, &mut ctx.xer);
	// 823FE03C: 40980058  bge cr6, 0x823fe094
	if !ctx.cr[6].lt {
	pc = 0x823FE094; continue 'dispatch;
	}
	// 823FE040: ED60F378  fmsubs f11, f0, f13, f30
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[30].f64) as f32) as f64);
	// 823FE044: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FE048: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823FE04C: 7F09E000  cmpw cr6, r9, r28
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[28].s32, &mut ctx.xer);
	// 823FE050: ED9F5828  fsubs f12, f31, f11
	ctx.f[12].f64 = (((ctx.f[31].f64 - ctx.f[11].f64) as f32) as f64);
	// 823FE054: ED4A0332  fmuls f10, f10, f12
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FE058: D14B0000  stfs f10, 0(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE05C: C14A0000  lfs f10, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FE060: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FE064: ED8A0332  fmuls f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FE068: D18A0000  stfs f12, 0(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE06C: 40980028  bge cr6, 0x823fe094
	if !ctx.cr[6].lt {
	pc = 0x823FE094; continue 'dispatch;
	}
	// 823FE070: EC0B0378  fmsubs f0, f11, f13, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FE074: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FE078: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FE07C: EDAC0032  fmuls f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE080: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE084: C1AAFFFC  lfs f13, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE088: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FE08C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE090: D00AFFFC  stfs f0, -4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 823FE094: 57AA07FF  clrlwi. r10, r29, 0x1f
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FE098: 41820014  beq 0x823fe0ac
	if ctx.cr[0].eq {
	pc = 0x823FE0AC; continue 'dispatch;
	}
	// 823FE09C: EC1FE02A  fadds f0, f31, f28
	ctx.f[0].f64 = ((ctx.f[31].f64 + ctx.f[28].f64) as f32) as f64;
	// 823FE0A0: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE0A4: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FE0A8: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE0AC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 823FE0B0: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 823FE0B4: 48137F81  bl 0x82536034
	ctx.lr = 0x823FE0B8;
	sub_82535FFC(ctx, base);
	// 823FE0B8: 48137050  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE0C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE0C0 size=24
    let mut pc: u32 = 0x823FE0C0;
    'dispatch: loop {
        match pc {
            0x823FE0C0 => {
    //   block [0x823FE0C0..0x823FE0D8)
	// 823FE0C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE0C4: C00B2A24  lfs f0, 0x2a24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10788 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE0C8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FE0CC: 4099000C  ble cr6, 0x823fe0d8
	if !ctx.cr[6].gt {
		sub_823FE0D8(ctx, base);
		return;
	}
	// 823FE0D0: 38600105  li r3, 0x105
	ctx.r[3].s64 = 261;
	// 823FE0D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE0D8 size=24
    let mut pc: u32 = 0x823FE0D8;
    'dispatch: loop {
        match pc {
            0x823FE0D8 => {
    //   block [0x823FE0D8..0x823FE0F0)
	// 823FE0D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE0DC: C00B2AA4  lfs f0, 0x2aa4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10916 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE0E0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FE0E4: 4099000C  ble cr6, 0x823fe0f0
	if !ctx.cr[6].gt {
		sub_823FE0F0(ctx, base);
		return;
	}
	// 823FE0E8: 386000F1  li r3, 0xf1
	ctx.r[3].s64 = 241;
	// 823FE0EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE0F0 size=24
    let mut pc: u32 = 0x823FE0F0;
    'dispatch: loop {
        match pc {
            0x823FE0F0 => {
    //   block [0x823FE0F0..0x823FE108)
	// 823FE0F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE0F4: C00B7700  lfs f0, 0x7700(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30464 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE0F8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FE0FC: 4099000C  ble cr6, 0x823fe108
	if !ctx.cr[6].gt {
		sub_823FE108(ctx, base);
		return;
	}
	// 823FE100: 386000DD  li r3, 0xdd
	ctx.r[3].s64 = 221;
	// 823FE104: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE108 size=24
    let mut pc: u32 = 0x823FE108;
    'dispatch: loop {
        match pc {
            0x823FE108 => {
    //   block [0x823FE108..0x823FE120)
	// 823FE108: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE10C: C00B25E8  lfs f0, 0x25e8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9704 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE110: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FE114: 4099000C  ble cr6, 0x823fe120
	if !ctx.cr[6].gt {
		sub_823FE120(ctx, base);
		return;
	}
	// 823FE118: 386000C9  li r3, 0xc9
	ctx.r[3].s64 = 201;
	// 823FE11C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE120 size=24
    let mut pc: u32 = 0x823FE120;
    'dispatch: loop {
        match pc {
            0x823FE120 => {
    //   block [0x823FE120..0x823FE138)
	// 823FE120: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE124: C00B2148  lfs f0, 0x2148(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE128: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FE12C: 4099000C  ble cr6, 0x823fe138
	if !ctx.cr[6].gt {
		sub_823FE138(ctx, base);
		return;
	}
	// 823FE130: 386000B5  li r3, 0xb5
	ctx.r[3].s64 = 181;
	// 823FE134: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE138 size=48
    let mut pc: u32 = 0x823FE138;
    'dispatch: loop {
        match pc {
            0x823FE138 => {
    //   block [0x823FE138..0x823FE168)
	// 823FE138: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE13C: C00B2D90  lfs f0, 0x2d90(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11664 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE140: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FE144: 4199001C  bgt cr6, 0x823fe160
	if ctx.cr[6].gt {
	pc = 0x823FE160; continue 'dispatch;
	}
	// 823FE148: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE14C: C00B478C  lfs f0, 0x478c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE150: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FE154: 4199000C  bgt cr6, 0x823fe160
	if ctx.cr[6].gt {
	pc = 0x823FE160; continue 'dispatch;
	}
	// 823FE158: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE15C: C00B20F0  lfs f0, 0x20f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE160: 386000A1  li r3, 0xa1
	ctx.r[3].s64 = 161;
	// 823FE164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE168 size=96
    let mut pc: u32 = 0x823FE168;
    'dispatch: loop {
        match pc {
            0x823FE168 => {
    //   block [0x823FE168..0x823FE1C8)
	// 823FE168: D021FFF0  stfs f1, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 823FE16C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE170: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE174: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE178: C1AB2068  lfs f13, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE17C: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 823FE180: 556A027E  clrlwi r10, r11, 9
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x007FFFFFu64;
	// 823FE184: 7D6BBE70  srawi r11, r11, 0x17
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 23) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 23) as i64;
	// 823FE188: 654A3F80  oris r10, r10, 0x3f80
	ctx.r[10].u64 = ctx.r[10].u64 | 1065353216;
	// 823FE18C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823FE190: 396BFF81  addi r11, r11, -0x7f
	ctx.r[11].s64 = ctx.r[11].s64 + -127;
	// 823FE194: 9141FFF0  stw r10, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u32 ) };
	// 823FE198: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823FE19C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FE1A0: C161FFF0  lfs f11, -0x10(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FE1A4: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 823FE1A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE1AC: C18B1850  lfs f12, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FE1B0: EC0B6038  fmsubs f0, f11, f0, f12
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 823FE1B4: C981FFF0  lfd f12, -0x10(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FE1B8: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 823FE1BC: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 823FE1C0: EC20637A  fmadds f1, f0, f13, f12
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 823FE1C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE1C8 size=64
    let mut pc: u32 = 0x823FE1C8;
    'dispatch: loop {
        match pc {
            0x823FE1C8 => {
    //   block [0x823FE1C8..0x823FE208)
	// 823FE1C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE1CC: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE1D0: ED600072  fmuls f11, f0, f1
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 823FE1D4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 823FE1D8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 823FE1DC: C0CB1850  lfs f6, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 823FE1E0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE1E4: C06A9050  lfs f3, -0x6fb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28592 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 823FE1E8: FDA03090  fmr f13, f6
	ctx.f[13].f64 = ctx.f[6].f64;
	// 823FE1EC: C0AB277C  lfs f5, 0x277c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10108 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 823FE1F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FE1F4: EC0B282A  fadds f0, f11, f5
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[5].f64) as f32) as f64;
	// 823FE1F8: C18B8E30  lfs f12, -0x71d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29136 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FE1FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE200: C08B2934  lfs f4, 0x2934(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10548 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 823FE204: 4800000C  b 0x823fe210
	sub_823FE208(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE208 size=68
    let mut pc: u32 = 0x823FE208;
    'dispatch: loop {
        match pc {
            0x823FE208 => {
    //   block [0x823FE208..0x823FE24C)
	// 823FE208: EC000132  fmuls f0, f0, f4
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[4].f64) as f32) as f64);
	// 823FE20C: EDAD00F2  fmuls f13, f13, f3
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[3].f64) as f32) as f64);
	// 823FE210: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 823FE214: 4198FFF4  blt cr6, 0x823fe208
	if ctx.cr[6].lt {
	pc = 0x823FE208; continue 'dispatch;
	}
	// 823FE218: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 823FE21C: 3564FFFF  addic. r11, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FE220: C12A904C  lfs f9, -0x6fb4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28596 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FE224: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 823FE228: C10A9048  lfs f8, -0x6fb8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28600 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823FE22C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 823FE230: ED40427C  fnmsubs f10, f0, f9, f8
	ctx.f[10].f64 = -(((ctx.f[0].f64 * ctx.f[9].f64 - ctx.f[8].f64) as f32) as f64);
	// 823FE234: C0EA9044  lfs f7, -0x6fbc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28604 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 823FE238: 39460004  addi r10, r6, 4
	ctx.r[10].s64 = ctx.r[6].s64 + 4;
	// 823FE23C: EC0A383A  fmadds f0, f10, f0, f7
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 823FE240: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FE244: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE248: 4C810020  blelr
	if !ctx.cr[0].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE24C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE24C size=36
    let mut pc: u32 = 0x823FE24C;
    'dispatch: loop {
        match pc {
            0x823FE24C => {
    //   block [0x823FE24C..0x823FE270)
	// 823FE24C: C0090000  lfs f0, 0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE250: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823FE254: ED400072  fmuls f10, f0, f1
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 823FE258: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FE25C: FF0A5800  fcmpu cr6, f10, f11
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[11].f64);
	// 823FE260: 419A0030  beq cr6, 0x823fe290
	if ctx.cr[6].eq {
		sub_823FE290(ctx, base);
		return;
	}
	// 823FE264: EC0A282A  fadds f0, f10, f5
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[5].f64) as f32) as f64;
	// 823FE268: FDA03090  fmr f13, f6
	ctx.f[13].f64 = ctx.f[6].f64;
	// 823FE26C: 4800000C  b 0x823fe278
	sub_823FE270(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823FE270 size=32
    let mut pc: u32 = 0x823FE270;
    'dispatch: loop {
        match pc {
            0x823FE270 => {
    //   block [0x823FE270..0x823FE290)
	// 823FE270: EC000132  fmuls f0, f0, f4
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[4].f64) as f32) as f64);
	// 823FE274: EDAD00F2  fmuls f13, f13, f3
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[3].f64) as f32) as f64);
	// 823FE278: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 823FE27C: 4198FFF4  blt cr6, 0x823fe270
	if ctx.cr[6].lt {
	pc = 0x823FE270; continue 'dispatch;
	}
	// 823FE280: ED60427C  fnmsubs f11, f0, f9, f8
	ctx.f[11].f64 = -(((ctx.f[0].f64 * ctx.f[9].f64 - ctx.f[8].f64) as f32) as f64);
	// 823FE284: EC0B383A  fmadds f0, f11, f0, f7
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 823FE288: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FE28C: 48000008  b 0x823fe294
	sub_823FE290(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE290 size=28
    let mut pc: u32 = 0x823FE290;
    'dispatch: loop {
        match pc {
            0x823FE290 => {
    //   block [0x823FE290..0x823FE2AC)
	// 823FE290: C00AFFFC  lfs f0, -4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE294: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE298: FD605090  fmr f11, f10
	ctx.f[11].f64 = ctx.f[10].f64;
	// 823FE29C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FE2A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FE2A4: 4199FFA8  bgt cr6, 0x823fe24c
	if ctx.cr[6].gt {
		sub_823FE24C(ctx, base);
		return;
	}
	// 823FE2A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE2B0 size=204
    let mut pc: u32 = 0x823FE2B0;
    'dispatch: loop {
        match pc {
            0x823FE2B0 => {
    //   block [0x823FE2B0..0x823FE37C)
	// 823FE2B0: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 823FE2B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE2B8: C1AB20B0  lfs f13, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE2BC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FE2C0: 4199000C  bgt cr6, 0x823fe2cc
	if ctx.cr[6].gt {
	pc = 0x823FE2CC; continue 'dispatch;
	}
	// 823FE2C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE2C8: C04B1FF8  lfs f2, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823FE2CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE2D0: C1AB2284  lfs f13, 0x2284(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8836 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE2D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FE2D8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FE2DC: C18B9054  lfs f12, -0x6fac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28588 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FE2E0: 41980038  blt cr6, 0x823fe318
	if ctx.cr[6].lt {
	pc = 0x823FE318; continue 'dispatch;
	}
	// 823FE2E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE2E8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FE2EC: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE2F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE2F4: EDA40372  fmuls f13, f4, f13
	ctx.f[13].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FE2F8: ED6D0032  fmuls f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE2FC: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE300: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 823FE304: 40980008  bge cr6, 0x823fe30c
	if !ctx.cr[6].lt {
	pc = 0x823FE30C; continue 'dispatch;
	}
	// 823FE308: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 823FE30C: FF001000  fcmpu cr6, f0, f2
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[2].f64);
	// 823FE310: 40990008  ble cr6, 0x823fe318
	if !ctx.cr[6].gt {
	pc = 0x823FE318; continue 'dispatch;
	}
	// 823FE314: FC400090  fmr f2, f0
	ctx.f[2].f64 = ctx.f[0].f64;
	// 823FE318: FF031000  fcmpu cr6, f3, f2
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[2].f64);
	// 823FE31C: 40990058  ble cr6, 0x823fe374
	if !ctx.cr[6].gt {
	pc = 0x823FE374; continue 'dispatch;
	}
	// 823FE320: FF036000  fcmpu cr6, f3, f12
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[12].f64);
	// 823FE324: 41980050  blt cr6, 0x823fe374
	if ctx.cr[6].lt {
	pc = 0x823FE374; continue 'dispatch;
	}
	// 823FE328: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE32C: C00B22E8  lfs f0, 0x22e8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8936 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE330: EC050032  fmuls f0, f5, f0
	ctx.f[0].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE334: FF040000  fcmpu cr6, f4, f0
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[0].f64);
	// 823FE338: 40980030  bge cr6, 0x823fe368
	if !ctx.cr[6].lt {
	pc = 0x823FE368; continue 'dispatch;
	}
	// 823FE33C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE340: C00B207C  lfs f0, 0x207c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE344: EC050032  fmuls f0, f5, f0
	ctx.f[0].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE348: FF040000  fcmpu cr6, f4, f0
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[0].f64);
	// 823FE34C: 4099001C  ble cr6, 0x823fe368
	if !ctx.cr[6].gt {
	pc = 0x823FE368; continue 'dispatch;
	}
	// 823FE350: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE354: C00B20C8  lfs f0, 0x20c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE358: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FE35C: C1AB8E28  lfs f13, -0x71d8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE360: EDA30372  fmuls f13, f3, f13
	ctx.f[13].f64 = (((ctx.f[3].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FE364: EC42683A  fmadds f2, f2, f0, f13
	ctx.f[2].f64 = (((ctx.f[2].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FE368: FF026000  fcmpu cr6, f2, f12
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[12].f64);
	// 823FE36C: 40980008  bge cr6, 0x823fe374
	if !ctx.cr[6].lt {
	pc = 0x823FE374; continue 'dispatch;
	}
	// 823FE370: EC42602A  fadds f2, f2, f12
	ctx.f[2].f64 = ((ctx.f[2].f64 + ctx.f[12].f64) as f32) as f64;
	// 823FE374: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 823FE378: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FE380 size=760
    let mut pc: u32 = 0x823FE380;
    'dispatch: loop {
        match pc {
            0x823FE380 => {
    //   block [0x823FE380..0x823FE678)
	// 823FE380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FE384: 48136D21  bl 0x825350a4
	ctx.lr = 0x823FE388;
	sub_82535080(ctx, base);
	// 823FE388: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 823FE38C: 48137C5D  bl 0x82535fe8
	ctx.lr = 0x823FE390;
	sub_82535FB0(ctx, base);
	// 823FE390: 9421F7F0  stwu r1, -0x810(r1)
	ea = ctx.r[1].u32.wrapping_add(-2064 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FE394: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FE398: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 823FE39C: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	// 823FE3A0: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 823FE3A4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 823FE3A8: C00B905C  lfs f0, -0x6fa4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28580 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE3AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE3B0: C3F90000  lfs f31, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FE3B4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823FE3B8: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE3BC: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 823FE3C0: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 823FE3C4: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 823FE3C8: C1AB7588  lfs f13, 0x7588(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30088 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE3CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE3D0: EDADF824  fdivs f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[31].f64) as f32) as f64;
	// 823FE3D4: C38B1850  lfs f28, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 823FE3D8: ED80E028  fsubs f12, f0, f28
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[28].f64) as f32) as f64);
	// 823FE3DC: FC00602E  fsel f0, f0, f0, f12
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[12].f64 };
	// 823FE3E0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FE3E4: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 823FE3E8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823FE3EC: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 823FE3F0: 40980008  bge cr6, 0x823fe3f8
	if !ctx.cr[6].lt {
	pc = 0x823FE3F8; continue 'dispatch;
	}
	// 823FE3F4: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 823FE3F8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FE3FC: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 823FE400: C8010070  lfd f0, 0x70(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 823FE404: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FE408: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE40C: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FE410: C00B2144  lfs f0, 0x2144(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE414: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FE418: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FE41C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FE420: C1AB9040  lfs f13, -0x6fc0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28608 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE424: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FE428: 40990008  ble cr6, 0x823fe430
	if !ctx.cr[6].gt {
	pc = 0x823FE430; continue 'dispatch;
	}
	// 823FE42C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 823FE430: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE434: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FE438: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FE43C: C3ABBFFC  lfs f29, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 823FE440: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823FE444: EDA0E82A  fadds f13, f0, f29
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 823FE448: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 823FE44C: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 823FE450: 7DA05FAE  stfiwx f13, 0, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 823FE454: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FE458: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 823FE45C: 40990024  ble cr6, 0x823fe480
	if !ctx.cr[6].gt {
	pc = 0x823FE480; continue 'dispatch;
	}
	// 823FE460: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FE464: 7DABDC2E  lfsx f13, r11, r27
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE468: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FE46C: 41990014  bgt cr6, 0x823fe480
	if ctx.cr[6].gt {
	pc = 0x823FE480; continue 'dispatch;
	}
	// 823FE470: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 823FE474: 7F044800  cmpw cr6, r4, r9
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[9].s32, &mut ctx.xer);
	// 823FE478: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 823FE47C: 4198FFE4  blt cr6, 0x823fe460
	if ctx.cr[6].lt {
	pc = 0x823FE460; continue 'dispatch;
	}
	// 823FE480: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FE484: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823FE488: 4099013C  ble cr6, 0x823fe5c4
	if !ctx.cr[6].gt {
	pc = 0x823FE5C4; continue 'dispatch;
	}
	// 823FE48C: 38C1005C  addi r6, r1, 0x5c
	ctx.r[6].s64 = ctx.r[1].s64 + 92;
	// 823FE490: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 823FE494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FE498: 4BFFF811  bl 0x823fdca8
	ctx.lr = 0x823FE49C;
	sub_823FDCA8(ctx, base);
	// 823FE49C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 823FE4A0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 823FE4A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823FE4A8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823FE4AC: 4BFFF7FD  bl 0x823fdca8
	ctx.lr = 0x823FE4B0;
	sub_823FDCA8(ctx, base);
	// 823FE4B0: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE4B4: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE4B8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FE4BC: 4199000C  bgt cr6, 0x823fe4c8
	if ctx.cr[6].gt {
	pc = 0x823FE4C8; continue 'dispatch;
	}
	// 823FE4C0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 823FE4C4: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 823FE4C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE4CC: 396B1FF8  addi r11, r11, 0x1ff8
	ctx.r[11].s64 = ctx.r[11].s64 + 8184;
	// 823FE4D0: C3CB0000  lfs f30, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 823FE4D4: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 823FE4D8: 409A000C  bne cr6, 0x823fe4e4
	if !ctx.cr[6].eq {
	pc = 0x823FE4E4; continue 'dispatch;
	}
	// 823FE4DC: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 823FE4E0: 48000008  b 0x823fe4e8
	pc = 0x823FE4E8; continue 'dispatch;
	// 823FE4E4: EC3C0024  fdivs f1, f28, f0
	ctx.f[1].f64 = ((ctx.f[28].f64 / ctx.f[0].f64) as f32) as f64;
	// 823FE4E8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 823FE4EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FE4F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FE4F4: 4BFFFCD5  bl 0x823fe1c8
	ctx.lr = 0x823FE4F8;
	sub_823FE1C8(ctx, base);
	// 823FE4F8: 38C103A0  addi r6, r1, 0x3a0
	ctx.r[6].s64 = ctx.r[1].s64 + 928;
	// 823FE4FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823FE500: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823FE504: 4BFFFCC5  bl 0x823fe1c8
	ctx.lr = 0x823FE508;
	sub_823FE1C8(ctx, base);
	// 823FE508: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823FE50C: 40990068  ble cr6, 0x823fe574
	if !ctx.cr[6].gt {
	pc = 0x823FE574; continue 'dispatch;
	}
	// 823FE510: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 823FE514: 7D3FD850  subf r9, r31, r27
	ctx.r[9].s64 = ctx.r[27].s64 - ctx.r[31].s64;
	// 823FE518: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 823FE51C: 7C095C2E  lfsx f0, r9, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE520: 39010064  addi r8, r1, 0x64
	ctx.r[8].s64 = ctx.r[1].s64 + 100;
	// 823FE524: EDA0E82A  fadds f13, f0, f29
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 823FE528: 38E103A0  addi r7, r1, 0x3a0
	ctx.r[7].s64 = ctx.r[1].s64 + 928;
	// 823FE52C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823FE530: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE534: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 823FE538: 7DA047AE  stfiwx f13, 0, r8
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 823FE53C: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 823FE540: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823FE544: 7DA83C2E  lfsx f13, r8, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE548: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FE54C: 4098001C  bge cr6, 0x823fe568
	if !ctx.cr[6].lt {
	pc = 0x823FE568; continue 'dispatch;
	}
	// 823FE550: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 823FE554: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FE558: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823FE55C: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FE560: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE564: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE568: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FE56C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FE570: 4082FFAC  bne 0x823fe51c
	if !ctx.cr[0].eq {
	pc = 0x823FE51C; continue 'dispatch;
	}
	// 823FE574: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FE578: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 823FE57C: 39210068  addi r9, r1, 0x68
	ctx.r[9].s64 = ctx.r[1].s64 + 104;
	// 823FE580: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 823FE584: 38E10210  addi r7, r1, 0x210
	ctx.r[7].s64 = ctx.r[1].s64 + 528;
	// 823FE588: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823FE58C: C02B9058  lfs f1, -0x6fa8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28584 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FE590: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823FE594: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FE598: 48000C31  bl 0x823ff1c8
	ctx.lr = 0x823FE59C;
	sub_823FF1C8(ctx, base);
	// 823FE59C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 823FE5A0: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 823FE5A4: 80C10068  lwz r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 823FE5A8: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 823FE5AC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823FE5B0: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 823FE5B4: 38810210  addi r4, r1, 0x210
	ctx.r[4].s64 = ctx.r[1].s64 + 528;
	// 823FE5B8: 48002C81  bl 0x82401238
	ctx.lr = 0x823FE5BC;
	sub_82401238(ctx, base);
	// 823FE5BC: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE5C0: 4800001C  b 0x823fe5dc
	pc = 0x823FE5DC; continue 'dispatch;
	// 823FE5C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE5C8: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 823FE5CC: 396B1FF8  addi r11, r11, 0x1ff8
	ctx.r[11].s64 = ctx.r[11].s64 + 8184;
	// 823FE5D0: C3CB0000  lfs f30, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 823FE5D4: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 823FE5D8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 823FE5DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE5E0: C1980000  lfs f12, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FE5E4: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 823FE5E8: C1AB29D4  lfs f13, 0x29d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10708 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE5EC: EFEC6F7C  fnmsubs f31, f12, f29, f13
	ctx.f[31].f64 = -(((ctx.f[12].f64 * ctx.f[29].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FE5F0: 4199000C  bgt cr6, 0x823fe5fc
	if ctx.cr[6].gt {
	pc = 0x823FE5FC; continue 'dispatch;
	}
	// 823FE5F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE5F8: C00B2150  lfs f0, 0x2150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8528 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE5FC: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 823FE600: 4198000C  blt cr6, 0x823fe60c
	if ctx.cr[6].lt {
	pc = 0x823FE60C; continue 'dispatch;
	}
	// 823FE604: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE608: C00B2498  lfs f0, 0x2498(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE60C: EC3C0028  fsubs f1, f28, f0
	ctx.f[1].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FE610: 48134B49  bl 0x82533158
	ctx.lr = 0x823FE614;
	sub_82533158(ctx, base);
	// 823FE614: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 823FE618: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE61C: C00B2398  lfs f0, 0x2398(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE620: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE624: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 823FE628: 4098000C  bge cr6, 0x823fe634
	if !ctx.cr[6].lt {
	pc = 0x823FE634; continue 'dispatch;
	}
	// 823FE62C: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 823FE630: 48000028  b 0x823fe658
	pc = 0x823FE658; continue 'dispatch;
	// 823FE634: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE638: C1AB3070  lfs f13, 0x3070(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12400 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE63C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FE640: 4099000C  ble cr6, 0x823fe64c
	if !ctx.cr[6].gt {
	pc = 0x823FE64C; continue 'dispatch;
	}
	// 823FE644: FC00E090  fmr f0, f28
	ctx.f[0].f64 = ctx.f[28].f64;
	// 823FE648: 48000010  b 0x823fe658
	pc = 0x823FE658; continue 'dispatch;
	// 823FE64C: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 823FE650: EDADF828  fsubs f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 823FE654: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 823FE658: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE65C: D0180000  stfs f0, 0(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE660: D1B90000  stfs f13, 0(r25)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE664: D0170000  stfs f0, 0(r23)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE668: 38210810  addi r1, r1, 0x810
	ctx.r[1].s64 = ctx.r[1].s64 + 2064;
	// 823FE66C: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 823FE670: 481379C5  bl 0x82536034
	ctx.lr = 0x823FE674;
	sub_82535FFC(ctx, base);
	// 823FE674: 48136A80  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE678 size=64
    let mut pc: u32 = 0x823FE678;
    'dispatch: loop {
        match pc {
            0x823FE678 => {
    //   block [0x823FE678..0x823FE6B8)
	// 823FE678: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE67C: FDA02090  fmr f13, f4
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ctx.f[4].f64;
	// 823FE680: C00B22E8  lfs f0, 0x22e8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8936 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE684: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE688: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 823FE68C: 4199002C  bgt cr6, 0x823fe6b8
	if ctx.cr[6].gt {
		sub_823FE6B8(ctx, base);
		return;
	}
	// 823FE690: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE694: C00B207C  lfs f0, 0x207c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE698: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE69C: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 823FE6A0: 41980018  blt cr6, 0x823fe6b8
	if ctx.cr[6].lt {
		sub_823FE6B8(ctx, base);
		return;
	}
	// 823FE6A4: EDA1102A  fadds f13, f1, f2
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[2].f64) as f32) as f64;
	// 823FE6A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE6AC: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE6B0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE6B4: 48000060  b 0x823fe714
	sub_823FE710(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823FE6B8 size=20
    let mut pc: u32 = 0x823FE6B8;
    'dispatch: loop {
        match pc {
            0x823FE6B8 => {
    //   block [0x823FE6B8..0x823FE6CC)
	// 823FE6B8: FF036800  fcmpu cr6, f3, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[13].f64);
	// 823FE6BC: 40990010  ble cr6, 0x823fe6cc
	if !ctx.cr[6].gt {
		sub_823FE6CC(ctx, base);
		return;
	}
	// 823FE6C0: FC000890  fmr f0, f1
	ctx.f[0].f64 = ctx.f[1].f64;
	// 823FE6C4: FDA01890  fmr f13, f3
	ctx.f[13].f64 = ctx.f[3].f64;
	// 823FE6C8: 48000008  b 0x823fe6d0
	sub_823FE6CC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE6CC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE6CC size=68
    let mut pc: u32 = 0x823FE6CC;
    'dispatch: loop {
        match pc {
            0x823FE6CC => {
    //   block [0x823FE6CC..0x823FE710)
	// 823FE6CC: FC001090  fmr f0, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[2].f64;
	// 823FE6D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE6D4: C18B76F4  lfs f12, 0x76f4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30452 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FE6D8: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 823FE6DC: 40980038  bge cr6, 0x823fe714
	if !ctx.cr[6].lt {
		sub_823FE710(ctx, base);
		return;
	}
	// 823FE6E0: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE6E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE6E8: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE6EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE6F0: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FE6F4: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE6F8: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 823FE6FC: 40980018  bge cr6, 0x823fe714
	if !ctx.cr[6].lt {
		sub_823FE710(ctx, base);
		return;
	}
	// 823FE700: FF020800  fcmpu cr6, f2, f1
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[1].f64);
	// 823FE704: 4099000C  ble cr6, 0x823fe710
	if !ctx.cr[6].gt {
		sub_823FE710(ctx, base);
		return;
	}
	// 823FE708: FC001090  fmr f0, f2
	ctx.f[0].f64 = ctx.f[2].f64;
	// 823FE70C: 48000008  b 0x823fe714
	sub_823FE710(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823FE710 size=12
    let mut pc: u32 = 0x823FE710;
    'dispatch: loop {
        match pc {
            0x823FE710 => {
    //   block [0x823FE710..0x823FE71C)
	// 823FE710: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 823FE714: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 823FE718: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FE720 size=480
    let mut pc: u32 = 0x823FE720;
    'dispatch: loop {
        match pc {
            0x823FE720 => {
    //   block [0x823FE720..0x823FE900)
	// 823FE720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FE724: 48136981  bl 0x825350a4
	ctx.lr = 0x823FE728;
	sub_82535080(ctx, base);
	// 823FE728: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 823FE72C: 481378BD  bl 0x82535fe8
	ctx.lr = 0x823FE730;
	sub_82535FB0(ctx, base);
	// 823FE730: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FE734: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE738: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823FE73C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 823FE740: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 823FE744: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 823FE748: C00BBFFC  lfs f0, -0x4004(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE74C: EDA100BA  fmadds f13, f1, f2, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[2].f64 + ctx.f[0].f64) as f32) as f64);
	// 823FE750: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 823FE754: 7DA057AE  stfiwx f13, 0, r10
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 823FE758: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FE75C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 823FE760: 40990008  ble cr6, 0x823fe768
	if !ctx.cr[6].gt {
	pc = 0x823FE768; continue 'dispatch;
	}
	// 823FE764: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 823FE768: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FE76C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823FE770: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 823FE774: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823FE778: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FE77C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823FE780: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823FE784: ED816828  fsubs f12, f1, f13
	ctx.f[12].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FE788: EDAD082A  fadds f13, f13, f1
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64;
	// 823FE78C: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FE790: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FE794: FDA0601E  fctiwz f13, f12
	ctx.f[13].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 823FE798: 7DA057AE  stfiwx f13, 0, r10
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 823FE79C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FE7A0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FE7A4: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 823FE7A8: 2F1E0008  cmpwi cr6, r30, 8
	ctx.cr[6].compare_i32(ctx.r[30].s32, 8, &mut ctx.xer);
	// 823FE7AC: 40980008  bge cr6, 0x823fe7b4
	if !ctx.cr[6].lt {
	pc = 0x823FE7B4; continue 'dispatch;
	}
	// 823FE7B0: 3BC00008  li r30, 8
	ctx.r[30].s64 = 8;
	// 823FE7B4: 82E10050  lwz r23, 0x50(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FE7B8: 2F1700A0  cmpwi cr6, r23, 0xa0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 160, &mut ctx.xer);
	// 823FE7BC: 40990008  ble cr6, 0x823fe7c4
	if !ctx.cr[6].gt {
	pc = 0x823FE7C4; continue 'dispatch;
	}
	// 823FE7C0: 3AE000A0  li r23, 0xa0
	ctx.r[23].s64 = 160;
	// 823FE7C4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 823FE7C8: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FE7CC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 823FE7D0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823FE7D4: 7F8BDA14  add r28, r11, r27
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 823FE7D8: C3EA9060  lfs f31, -0x6fa0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28576 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FE7DC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FE7E0: 7FBEC850  subf r29, r30, r25
	ctx.r[29].s64 = ctx.r[25].s64 - ctx.r[30].s64;
	// 823FE7E4: C3CA1FF8  lfs f30, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 823FE7E8: FFA0F090  fmr f29, f30
	ctx.f[29].f64 = ctx.f[30].f64;
	// 823FE7EC: FF80F090  fmr f28, f30
	ctx.f[28].f64 = ctx.f[30].f64;
	// 823FE7F0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823FE7F4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823FE7F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823FE7FC: 4BFFF41D  bl 0x823fdc18
	ctx.lr = 0x823FE800;
	sub_823FDC18(ctx, base);
	// 823FE800: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 823FE804: 40990014  ble cr6, 0x823fe818
	if !ctx.cr[6].gt {
	pc = 0x823FE818; continue 'dispatch;
	}
	// 823FE808: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 823FE80C: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 823FE810: FF80E890  fmr f28, f29
	ctx.f[28].f64 = ctx.f[29].f64;
	// 823FE814: 48000014  b 0x823fe828
	pc = 0x823FE828; continue 'dispatch;
	// 823FE818: 397FFFFF  addi r11, r31, -1
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	// 823FE81C: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FE820: 409A0008  bne cr6, 0x823fe828
	if !ctx.cr[6].eq {
	pc = 0x823FE828; continue 'dispatch;
	}
	// 823FE824: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 823FE828: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 823FE82C: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 823FE830: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 823FE834: 7D7FF214  add r11, r31, r30
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 823FE838: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 823FE83C: 7F0BB800  cmpw cr6, r11, r23
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[23].s32, &mut ctx.xer);
	// 823FE840: 4099FFB0  ble cr6, 0x823fe7f0
	if !ctx.cr[6].gt {
	pc = 0x823FE7F0; continue 'dispatch;
	}
	// 823FE844: 7FFAF214  add r31, r26, r30
	ctx.r[31].u64 = ctx.r[26].u64 + ctx.r[30].u64;
	// 823FE848: 7F1FF000  cmpw cr6, r31, r30
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[30].s32, &mut ctx.xer);
	// 823FE84C: 4099003C  ble cr6, 0x823fe888
	if !ctx.cr[6].gt {
	pc = 0x823FE888; continue 'dispatch;
	}
	// 823FE850: 7F1FB800  cmpw cr6, r31, r23
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[23].s32, &mut ctx.xer);
	// 823FE854: 40980034  bge cr6, 0x823fe888
	if !ctx.cr[6].lt {
	pc = 0x823FE888; continue 'dispatch;
	}
	// 823FE858: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 823FE85C: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 823FE860: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 823FE864: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 823FE868: 48000789  bl 0x823feff0
	ctx.lr = 0x823FE86C;
	sub_823FEFF0(ctx, base);
	// 823FE86C: 7FEB07B4  extsw r11, r31
	ctx.r[11].s64 = ctx.r[31].s32 as i64;
	// 823FE870: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823FE874: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FE878: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FE87C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FE880: EFE1002A  fadds f31, f1, f0
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FE884: 4800001C  b 0x823fe8a0
	pc = 0x823FE8A0; continue 'dispatch;
	// 823FE888: 7FEB07B4  extsw r11, r31
	ctx.r[11].s64 = ctx.r[31].s32 as i64;
	// 823FE88C: D3F80000  stfs f31, 0(r24)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE890: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823FE894: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FE898: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FE89C: FFE00018  frsp f31, f0
	ctx.f[31].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FE8A0: 7FDFC850  subf r30, r31, r25
	ctx.r[30].s64 = ctx.r[25].s64 - ctx.r[31].s64;
	// 823FE8A4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823FE8A8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823FE8AC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823FE8B0: 4BFFF369  bl 0x823fdc18
	ctx.lr = 0x823FE8B4;
	sub_823FDC18(ctx, base);
	// 823FE8B4: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FE8B8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823FE8BC: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 823FE8C0: 7C8BDA14  add r4, r11, r27
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 823FE8C4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 823FE8C8: 4BFFF351  bl 0x823fdc18
	ctx.lr = 0x823FE8CC;
	sub_823FDC18(ctx, base);
	// 823FE8CC: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 823FE8D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE8D4: C1980000  lfs f12, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FE8D8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823FE8DC: C1AB2150  lfs f13, 0x2150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8528 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE8E0: EC006FBA  fmadds f0, f0, f30, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FE8E4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 823FE8E8: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 823FE8EC: D0180000  stfs f0, 0(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE8F0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 823FE8F4: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 823FE8F8: 4813773D  bl 0x82536034
	ctx.lr = 0x823FE8FC;
	sub_82535FFC(ctx, base);
	// 823FE8FC: 481367F8  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FE900 size=72
    let mut pc: u32 = 0x823FE900;
    'dispatch: loop {
        match pc {
            0x823FE900 => {
    //   block [0x823FE900..0x823FE948)
	// 823FE900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FE904: 481367B9  bl 0x825350bc
	ctx.lr = 0x823FE908;
	sub_82535080(ctx, base);
	// 823FE908: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FE90C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FE910: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FE914: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823FE918: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823FE91C: 419A0024  beq cr6, 0x823fe940
	if ctx.cr[6].eq {
	pc = 0x823FE940; continue 'dispatch;
	}
	// 823FE920: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FE924: 48137BD5  bl 0x825364f8
	ctx.lr = 0x823FE928;
	sub_825364F8(ctx, base);
	// 823FE928: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 823FE92C: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE930: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823FE934: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823FE938: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 823FE93C: 4082FFE4  bne 0x823fe920
	if !ctx.cr[0].eq {
	pc = 0x823FE920; continue 'dispatch;
	}
	// 823FE940: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FE944: 481367C8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FE948 size=412
    let mut pc: u32 = 0x823FE948;
    'dispatch: loop {
        match pc {
            0x823FE948 => {
    //   block [0x823FE948..0x823FEAE4)
	// 823FE948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FE94C: 48136769  bl 0x825350b4
	ctx.lr = 0x823FE950;
	sub_82535080(ctx, base);
	// 823FE950: 9421FD10  stwu r1, -0x2f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-752 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FE954: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FE958: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FE95C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823FE960: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823FE964: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823FE968: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 823FE96C: 48002B25  bl 0x82401490
	ctx.lr = 0x823FE970;
	sub_82401490(ctx, base);
	// 823FE970: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 823FE974: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 823FE978: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 823FE97C: 3900FFF0  li r8, -0x10
	ctx.r[8].s64 = -16;
	// 823FE980: 38E0FFE0  li r7, -0x20
	ctx.r[7].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FEAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FEAE8 size=320
    let mut pc: u32 = 0x823FEAE8;
    'dispatch: loop {
        match pc {
            0x823FEAE8 => {
    //   block [0x823FEAE8..0x823FEC28)
	// 823FEAE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FEAEC: 481365D1  bl 0x825350bc
	ctx.lr = 0x823FEAF0;
	sub_82535080(ctx, base);
	// 823FEAF0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FEAF4: C1A30000  lfs f13, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FEAF8: C12B1FF8  lfs f9, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FEAFC: FF0D4800  fcmpu cr6, f13, f9
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[9].f64);
	// 823FEB00: 409A000C  bne cr6, 0x823feb0c
	if !ctx.cr[6].eq {
	pc = 0x823FEB0C; continue 'dispatch;
	}
	// 823FEB04: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FEB08: C1AB9068  lfs f13, -0x6f98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FEB0C: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FEB10: 41820010  beq 0x823feb20
	if ctx.cr[0].eq {
	pc = 0x823FEB20; continue 'dispatch;
	}
	// 823FEB14: 3961FF90  addi r11, r1, -0x70
	ctx.r[11].s64 = ctx.r[1].s64 + -112;
	// 823FEB18: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823FEB1C: 4800000C  b 0x823feb28
	pc = 0x823FEB28; continue 'dispatch;
	// 823FEB20: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 823FEB24: 3BA1FF90  addi r29, r1, -0x70
	ctx.r[29].s64 = ctx.r[1].s64 + -112;
	// 823FEB28: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823FEB2C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FEB30: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823FEB34: C14A1850  lfs f10, 0x1850(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FEB38: D15D0000  stfs f10, 0(r29)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FEB3C: D14B0000  stfs f10, 0(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FEB40: 409900E0  ble cr6, 0x823fec20
	if !ctx.cr[6].gt {
	pc = 0x823FEC20; continue 'dispatch;
	}
	// 823FEB44: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 823FEB48: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FEB4C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823FEB50: 3BC30004  addi r30, r3, 4
	ctx.r[30].s64 = ctx.r[3].s64 + 4;
	// 823FEB54: C1682964  lfs f11, 0x2964(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(10596 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FEB58: C18A2968  lfs f12, 0x2968(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10600 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FEB5C: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 823FEB60: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FEB64: 4198002C  blt cr6, 0x823feb90
	if ctx.cr[6].lt {
	pc = 0x823FEB90; continue 'dispatch;
	}
	// 823FEB68: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 823FEB6C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823FEB70: 39490001  addi r10, r9, 1
	ctx.r[10].s64 = ctx.r[9].s64 + 1;
	// 823FEB74: C1080000  lfs f8, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823FEB78: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FEB7C: C0E50000  lfs f7, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 823FEB80: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FEB84: EC0801FA  fmadds f0, f8, f7, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64);
	// 823FEB88: 38A5FFFC  addi r5, r5, -4
	ctx.r[5].s64 = ctx.r[5].s64 + -4;
	// 823FEB8C: 4082FFE8  bne 0x823feb74
	if !ctx.cr[0].eq {
	pc = 0x823FEB74; continue 'dispatch;
	}
	// 823FEB90: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 823FEB94: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 823FEB98: 40990008  ble cr6, 0x823feba0
	if !ctx.cr[6].gt {
	pc = 0x823FEBA0; continue 'dispatch;
	}
	// 823FEB9C: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 823FEBA0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 823FEBA4: 40980008  bge cr6, 0x823febac
	if !ctx.cr[6].lt {
	pc = 0x823FEBAC; continue 'dispatch;
	}
	// 823FEBA8: FC005890  fmr f0, f11
	ctx.f[0].f64 = ctx.f[11].f64;
	// 823FEBAC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 823FEBB0: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FEBB4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823FEBB8: FD000050  fneg f8, f0
	ctx.f[8].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 823FEBBC: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 823FEBC0: 7D1F5A14  add r8, r31, r11
	ctx.r[8].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 823FEBC4: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 823FEBC8: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 823FEBCC: D1080004  stfs f8, 4(r8)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FEBD0: 41980034  blt cr6, 0x823fec04
	if ctx.cr[6].lt {
	pc = 0x823FEC04; continue 'dispatch;
	}
	// 823FEBD4: 7CBF5214  add r5, r31, r10
	ctx.r[5].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 823FEBD8: 7C6B5050  subf r3, r11, r10
	ctx.r[3].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823FEBDC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 823FEBE0: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 823FEBE4: C1050000  lfs f8, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823FEBE8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FEBEC: 7CE3442E  lfsx f7, r3, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 823FEBF0: 38A5FFFC  addi r5, r5, -4
	ctx.r[5].s64 = ctx.r[5].s64 + -4;
	// 823FEBF4: ED08383C  fnmsubs f8, f8, f0, f7
	ctx.f[8].f64 = -(((ctx.f[8].f64 * ctx.f[0].f64 - ctx.f[7].f64) as f32) as f64);
	// 823FEBF8: D1080000  stfs f8, 0(r8)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FEBFC: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FEC00: 4082FFE4  bne 0x823febe4
	if !ctx.cr[0].eq {
	pc = 0x823FEBE4; continue 'dispatch;
	}
	// 823FEC04: EC00503C  fnmsubs f0, f0, f0, f10
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 823FEC08: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823FEC0C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823FEC10: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823FEC14: 7F092000  cmpw cr6, r9, r4
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[4].s32, &mut ctx.xer);
	// 823FEC18: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FEC1C: 4198FF40  blt cr6, 0x823feb5c
	if ctx.cr[6].lt {
	pc = 0x823FEB5C; continue 'dispatch;
	}
	// 823FEC20: D1A70000  stfs f13, 0(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FEC24: 481364E8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FEC28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FEC28 size=400
    let mut pc: u32 = 0x823FEC28;
    'dispatch: loop {
        match pc {
            0x823FEC28 => {
    //   block [0x823FEC28..0x823FEDB8)
	// 823FEC28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FEC2C: 48136491  bl 0x825350bc
	ctx.lr = 0x823FEC30;
	sub_82535080(ctx, base);
	// 823FEC30: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FEC34: C1A50000  lfs f13, 0(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FEC38: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823FEC3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FEC40: C10BBFFC  lfs f8, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823FEC44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FEC48: EC010232  fmuls f0, f1, f8
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[8].f64) as f32) as f64);
	// 823FEC4C: FD400090  fmr f10, f0
	ctx.f[10].f64 = ctx.f[0].f64;
	// 823FEC50: ED60082A  fadds f11, f0, f1
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 823FEC54: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FEC58: 40980024  bge cr6, 0x823fec7c
	if !ctx.cr[6].lt {
	pc = 0x823FEC7C; continue 'dispatch;
	}
	// 823FEC5C: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 823FEC60: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FEC64: 40980018  bge cr6, 0x823fec7c
	if !ctx.cr[6].lt {
	pc = 0x823FEC7C; continue 'dispatch;
	}
	// 823FEC68: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FEC6C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823FEC70: C1A70000  lfs f13, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FEC74: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FEC78: 4198FFE8  blt cr6, 0x823fec60
	if ctx.cr[6].lt {
	pc = 0x823FEC60; continue 'dispatch;
	}
	// 823FEC7C: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 823FEC80: C127227C  lfs f9, 0x227c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8828 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FEC84: ECA90028  fsubs f5, f9, f0
	ctx.f[5].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FEC88: FF002800  fcmpu cr6, f0, f5
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[5].f64);
	// 823FEC8C: 40980128  bge cr6, 0x823fedb4
	if !ctx.cr[6].lt {
	pc = 0x823FEDB4; continue 'dispatch;
	}
	// 823FEC90: 7FC94050  subf r30, r9, r8
	ctx.r[30].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 823FEC94: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 823FEC98: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 823FEC9C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823FECA0: C0C82150  lfs f6, 0x2150(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8528 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 823FECA4: C0E91FF8  lfs f7, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 823FECA8: 7F035000  cmpw cr6, r3, r10
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[10].s32, &mut ctx.xer);
	// 823FECAC: 40980108  bge cr6, 0x823fedb4
	if !ctx.cr[6].lt {
	pc = 0x823FEDB4; continue 'dispatch;
	}
	// 823FECB0: FDA03890  fmr f13, f7
	ctx.f[13].f64 = ctx.f[7].f64;
	// 823FECB4: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FECB8: 40980070  bge cr6, 0x823fed28
	if !ctx.cr[6].lt {
	pc = 0x823FED28; continue 'dispatch;
	}
	// 823FECBC: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FECC0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 823FECC4: 7D892C2E  lfsx f12, r9, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FECC8: 9101FFD0  stw r8, -0x30(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[8].u32 ) };
	// 823FECCC: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 823FECD0: 40980058  bge cr6, 0x823fed28
	if !ctx.cr[6].lt {
	pc = 0x823FED28; continue 'dispatch;
	}
	// 823FECD4: 7D292214  add r9, r9, r4
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[4].u64;
	// 823FECD8: 7FE42850  subf r31, r4, r5
	ctx.r[31].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 823FECDC: 7F083000  cmpw cr6, r8, r6
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FECE0: 40980030  bge cr6, 0x823fed10
	if !ctx.cr[6].lt {
	pc = 0x823FED10; continue 'dispatch;
	}
	// 823FECE4: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FECE8: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 823FECEC: 4098000C  bge cr6, 0x823fecf8
	if !ctx.cr[6].lt {
	pc = 0x823FECF8; continue 'dispatch;
	}
	// 823FECF0: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	// 823FECF4: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 823FECF8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FECFC: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 823FED00: 7D9F4C2E  lfsx f12, r31, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FED04: 9101FFD0  stw r8, -0x30(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[8].u32 ) };
	// 823FED08: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 823FED0C: 4198FFD0  blt cr6, 0x823fecdc
	if ctx.cr[6].lt {
	pc = 0x823FECDC; continue 'dispatch;
	}
	// 823FED10: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 823FED14: 40990014  ble cr6, 0x823fed28
	if !ctx.cr[6].gt {
	pc = 0x823FED28; continue 'dispatch;
	}
	// 823FED18: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FED1C: 7DBE3D2E  stfsx f13, r30, r7
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 823FED20: 7DA92C2E  lfsx f13, r9, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FED24: 48000040  b 0x823fed64
	pc = 0x823FED64; continue 'dispatch;
	// 823FED28: EDAB502A  fadds f13, f11, f10
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64;
	// 823FED2C: 3921FFD0  addi r9, r1, -0x30
	ctx.r[9].s64 = ctx.r[1].s64 + -48;
	// 823FED30: EDAD423A  fmadds f13, f13, f8, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[8].f64 + ctx.f[8].f64) as f32) as f64);
	// 823FED34: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 823FED38: 7DA04FAE  stfiwx f13, 0, r9
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 823FED3C: 8121FFD0  lwz r9, -0x30(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) } as u64;
	// 823FED40: 7D2807B4  extsw r8, r9
	ctx.r[8].s64 = ctx.r[9].s32 as i64;
	// 823FED44: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FED48: F901FFD8  std r8, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[8].u64 ) };
	// 823FED4C: 7DA9EC2E  lfsx f13, r9, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FED50: EDAD302A  fadds f13, f13, f6
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[6].f64) as f32) as f64;
	// 823FED54: 7DBE3D2E  stfsx f13, r30, r7
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 823FED58: C9A1FFD8  lfd f13, -0x28(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 823FED5C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823FED60: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823FED64: ED40682A  fadds f10, f0, f13
	ctx.f[10].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 823FED68: D1A70000  stfs f13, 0(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FED6C: ED6A082A  fadds f11, f10, f1
	ctx.f[11].f64 = ((ctx.f[10].f64 + ctx.f[1].f64) as f32) as f64;
	// 823FED70: FF0B4800  fcmpu cr6, f11, f9
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[9].f64);
	// 823FED74: 40990008  ble cr6, 0x823fed7c
	if !ctx.cr[6].gt {
	pc = 0x823FED7C; continue 'dispatch;
	}
	// 823FED78: FD604890  fmr f11, f9
	ctx.f[11].f64 = ctx.f[9].f64;
	// 823FED7C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FED80: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 823FED84: 7D292A14  add r9, r9, r5
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[5].u64;
	// 823FED88: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FED8C: 48000014  b 0x823feda0
	pc = 0x823FEDA0; continue 'dispatch;
	// 823FED90: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FED94: 40980018  bge cr6, 0x823fedac
	if !ctx.cr[6].lt {
	pc = 0x823FEDAC; continue 'dispatch;
	}
	// 823FED98: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FED9C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823FEDA0: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FEDA4: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 823FEDA8: 4198FFE8  blt cr6, 0x823fed90
	if ctx.cr[6].lt {
	pc = 0x823FED90; continue 'dispatch;
	}
	// 823FEDAC: FF0A2800  fcmpu cr6, f10, f5
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[5].f64);
	// 823FEDB0: 4198FEF8  blt cr6, 0x823feca8
	if ctx.cr[6].lt {
	pc = 0x823FECA8; continue 'dispatch;
	}
	// 823FEDB4: 48136358  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FEDB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FEDB8 size=452
    let mut pc: u32 = 0x823FEDB8;
    'dispatch: loop {
        match pc {
            0x823FEDB8 => {
    //   block [0x823FEDB8..0x823FEF7C)
	// 823FEDB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FEDBC: 481362F5  bl 0x825350b0
	ctx.lr = 0x823FEDC0;
	sub_82535080(ctx, base);
	// 823FEDC0: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 823FEDC4: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 823FEDC8: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 823FEDCC: 9421F9A0  stwu r1, -0x660(r1)
	ea = ctx.r[1].u32.wrapping_add(-1632 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FEDD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FEDD4: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 823FEDD8: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 823FEDDC: 39210210  addi r9, r1, 0x210
	ctx.r[9].s64 = ctx.r[1].s64 + 528;
	// 823FEDE0: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 823FEDE4: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 823FEDE8: C00B1850  lfs f0, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FEDEC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FEDF0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 823FEDF4: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 823FEDF8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 823FEDFC: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 823FEE00: C00B2520  lfs f0, 0x2520(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FEE04: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 823FEE08: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 823FEE0C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 823FEE10: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 823FEE14: 4BFFFE15  bl 0x823fec28
	ctx.lr = 0x823FEE18;
	sub_823FEC28(ctx, base);
	// 823FEE18: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 823FEE1C: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 823FEE20: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FEE24: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823FEE28: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FEF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FEF80 size=108
    let mut pc: u32 = 0x823FEF80;
    'dispatch: loop {
        match pc {
            0x823FEF80 => {
    //   block [0x823FEF80..0x823FEFEC)
	// 823FEF80: 39640001  addi r11, r4, 1
	ctx.r[11].s64 = ctx.r[4].s64 + 1;
	// 823FEF84: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 823FEF88: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FEF8C: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 823FEF90: 40980054  bge cr6, 0x823fefe4
	if !ctx.cr[6].lt {
	pc = 0x823FEFE4; continue 'dispatch;
	}
	// 823FEF94: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FEF98: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 823FEF9C: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FEFA0: C1AAFFFC  lfs f13, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FEFA4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FEFA8: 4198002C  blt cr6, 0x823fefd4
	if ctx.cr[6].lt {
	pc = 0x823FEFD4; continue 'dispatch;
	}
	// 823FEFAC: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FEFB0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FEFB4: 40990020  ble cr6, 0x823fefd4
	if !ctx.cr[6].gt {
	pc = 0x823FEFD4; continue 'dispatch;
	}
	// 823FEFB8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823FEFBC: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FEFC0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FEFC4: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FEFC8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823FEFCC: 7F093000  cmpw cr6, r9, r6
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FEFD0: 419A0014  beq cr6, 0x823fefe4
	if ctx.cr[6].eq {
	pc = 0x823FEFE4; continue 'dispatch;
	}
	// 823FEFD4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823FEFD8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FEFDC: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 823FEFE0: 4198FFBC  blt cr6, 0x823fef9c
	if ctx.cr[6].lt {
	pc = 0x823FEF9C; continue 'dispatch;
	}
	// 823FEFE4: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823FEFE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FEFF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FEFF0 size=76
    let mut pc: u32 = 0x823FEFF0;
    'dispatch: loop {
        match pc {
            0x823FEFF0 => {
    //   block [0x823FEFF0..0x823FF03C)
	// 823FEFF0: EDA1182A  fadds f13, f1, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[3].f64) as f32) as f64;
	// 823FEFF4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FEFF8: ED830828  fsubs f12, f3, f1
	ctx.f[12].f64 = (((ctx.f[3].f64 - ctx.f[1].f64) as f32) as f64);
	// 823FEFFC: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF000: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FF004: EDAD1038  fmsubs f13, f13, f0, f2
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[2].f64) as f32) as f64);
	// 823FF008: C02B1FF8  lfs f1, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FF00C: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FF010: FF0D0800  fcmpu cr6, f13, f1
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[1].f64);
	// 823FF014: 419A0018  beq cr6, 0x823ff02c
	if ctx.cr[6].eq {
	pc = 0x823FF02C; continue 'dispatch;
	}
	// 823FF018: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FF01C: C18B2068  lfs f12, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FF020: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FF024: ED806024  fdivs f12, f0, f12
	ctx.f[12].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 823FF028: FC206050  fneg f1, f12
	ctx.f[1].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 823FF02C: EC01037A  fmadds f0, f1, f13, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 823FF030: EC00107A  fmadds f0, f0, f1, f2
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64 + ctx.f[2].f64) as f32) as f64);
	// 823FF034: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF038: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FF040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FF040 size=332
    let mut pc: u32 = 0x823FF040;
    'dispatch: loop {
        match pc {
            0x823FF040 => {
    //   block [0x823FF040..0x823FF18C)
	// 823FF040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FF044: 48136071  bl 0x825350b4
	ctx.lr = 0x823FF048;
	sub_82535080(ctx, base);
	// 823FF048: 9421FDE0  stwu r1, -0x220(r1)
	ea = ctx.r[1].u32.wrapping_add(-544 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FF04C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823FF050: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 823FF054: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 823FF058: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823FF05C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 823FF060: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 823FF064: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 823FF068: 4BFFEBE1  bl 0x823fdc48
	ctx.lr = 0x823FF06C;
	sub_823FDC48(ctx, base);
	// 823FF06C: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 823FF070: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 823FF074: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 823FF078: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823FF07C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FF080: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823FF084: 4BFFFEFD  bl 0x823fef80
	ctx.lr = 0x823FF088;
	sub_823FEF80(ctx, base);
	// 823FF088: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF08C: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823FF090: 408100A8  ble 0x823ff138
	if !ctx.cr[0].gt {
	pc = 0x823FF138; continue 'dispatch;
	}
	// 823FF094: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 823FF098: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 823FF09C: 7CFF5050  subf r7, r31, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	// 823FF0A0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823FF0A4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FF0A8: 5488003E  slwi r8, r4, 0
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823FF0AC: C1062068  lfs f8, 0x2068(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8296 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823FF0B0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 823FF0B4: 7CBFE050  subf r5, r31, r28
	ctx.r[5].s64 = ctx.r[28].s64 - ctx.r[31].s64;
	// 823FF0B8: C1291FF8  lfs f9, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FF0BC: C14ABFFC  lfs f10, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FF0C0: 7D27582E  lwzx r9, r7, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823FF0C4: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FF0C8: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 823FF0CC: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF0D0: C1AAFFFC  lfs f13, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF0D4: ED8D002A  fadds f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FF0D8: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FF0DC: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FF0E0: EC0C5AB8  fmsubs f0, f12, f10, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 823FF0E4: ED8D02B2  fmuls f12, f13, f10
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 823FF0E8: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 823FF0EC: 419A0014  beq cr6, 0x823ff100
	if ctx.cr[6].eq {
	pc = 0x823FF100; continue 'dispatch;
	}
	// 823FF0F0: EDA00232  fmuls f13, f0, f8
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[8].f64) as f32) as f64);
	// 823FF0F4: EDAC6824  fdivs f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 823FF0F8: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 823FF0FC: 48000008  b 0x823ff104
	pc = 0x823FF104; continue 'dispatch;
	// 823FF100: FDA04890  fmr f13, f9
	ctx.f[13].f64 = ctx.f[9].f64;
	// 823FF104: 7D2A07B4  extsw r10, r9
	ctx.r[10].s64 = ctx.r[9].s32 as i64;
	// 823FF108: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 823FF10C: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823FF110: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 823FF114: EC005B7A  fmadds f0, f0, f13, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 823FF118: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF11C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FF120: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FF124: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FF128: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 823FF12C: 7C055D2E  stfsx f0, r5, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 823FF130: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FF134: 4082FF8C  bne 0x823ff0c0
	if !ctx.cr[0].eq {
	pc = 0x823FF0C0; continue 'dispatch;
	}
	// 823FF138: 2F040003  cmpwi cr6, r4, 3
	ctx.cr[6].compare_i32(ctx.r[4].s32, 3, &mut ctx.xer);
	// 823FF13C: 41990048  bgt cr6, 0x823ff184
	if ctx.cr[6].gt {
	pc = 0x823FF184; continue 'dispatch;
	}
	// 823FF140: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FF144: 393E001C  addi r9, r30, 0x1c
	ctx.r[9].s64 = ctx.r[30].s64 + 28;
	// 823FF148: 7D1FE050  subf r8, r31, r28
	ctx.r[8].s64 = ctx.r[28].s64 - ctx.r[31].s64;
	// 823FF14C: 39400024  li r10, 0x24
	ctx.r[10].s64 = 36;
	// 823FF150: C1AB228C  lfs f13, 0x228c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8844 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF154: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 823FF158: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 823FF15C: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FF160: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FF164: 7C0B452E  stfsx f0, r11, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 823FF168: 3929001C  addi r9, r9, 0x1c
	ctx.r[9].s64 = ctx.r[9].s64 + 28;
	// 823FF16C: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF170: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 823FF174: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FF178: 4082FFE4  bne 0x823ff15c
	if !ctx.cr[0].eq {
	pc = 0x823FF15C; continue 'dispatch;
	}
	// 823FF17C: 39600024  li r11, 0x24
	ctx.r[11].s64 = 36;
	// 823FF180: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FF184: 38210220  addi r1, r1, 0x220
	ctx.r[1].s64 = ctx.r[1].s64 + 544;
	// 823FF188: 48135F7C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FF190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FF190 size=16
    let mut pc: u32 = 0x823FF190;
    'dispatch: loop {
        match pc {
            0x823FF190 => {
    //   block [0x823FF190..0x823FF1A0)
	// 823FF190: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FF194: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FF198: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF19C: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FF1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FF1A0 size=40
    let mut pc: u32 = 0x823FF1A0;
    'dispatch: loop {
        match pc {
            0x823FF1A0 => {
    //   block [0x823FF1A0..0x823FF1C8)
	// 823FF1A0: 39650001  addi r11, r5, 1
	ctx.r[11].s64 = ctx.r[5].s64 + 1;
	// 823FF1A4: C1A30000  lfs f13, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF1A8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FF1AC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FF1B0: D1A40000  stfs f13, 0(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF1B4: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 823FF1B8: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 823FF1BC: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 823FF1C0: 4082FFE4  bne 0x823ff1a4
	if !ctx.cr[0].eq {
	pc = 0x823FF1A4; continue 'dispatch;
	}
	// 823FF1C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FF1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FF1C8 size=392
    let mut pc: u32 = 0x823FF1C8;
    'dispatch: loop {
        match pc {
            0x823FF1C8 => {
    //   block [0x823FF1C8..0x823FF350)
	// 823FF1C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FF1CC: 48135EE9  bl 0x825350b4
	ctx.lr = 0x823FF1D0;
	sub_82535080(ctx, base);
	// 823FF1D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FF1D4: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 823FF1D8: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 823FF1DC: 41990008  bgt cr6, 0x823ff1e4
	if ctx.cr[6].gt {
	pc = 0x823FF1E4; continue 'dispatch;
	}
	// 823FF1E0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 823FF1E4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823FF1E8: 40990034  ble cr6, 0x823ff21c
	if !ctx.cr[6].gt {
	pc = 0x823FF21C; continue 'dispatch;
	}
	// 823FF1EC: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 823FF1F0: 7FC71850  subf r30, r7, r3
	ctx.r[30].s64 = ctx.r[3].s64 - ctx.r[7].s64;
	// 823FF1F4: 7FA72050  subf r29, r7, r4
	ctx.r[29].s64 = ctx.r[4].s64 - ctx.r[7].s64;
	// 823FF1F8: 7F874050  subf r28, r7, r8
	ctx.r[28].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 823FF1FC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 823FF200: 7C1E342E  lfsx f0, r30, r6
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF204: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823FF208: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF20C: 7C1D342E  lfsx f0, r29, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF210: 7C1C352E  stfsx f0, r28, r6
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 823FF214: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 823FF218: 4082FFE8  bne 0x823ff200
	if !ctx.cr[0].eq {
	pc = 0x823FF200; continue 'dispatch;
	}
	// 823FF21C: 7CCB5050  subf r6, r11, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823FF220: 3BC5FFFF  addi r30, r5, -1
	ctx.r[30].s64 = ctx.r[5].s64 + -1;
	// 823FF224: 7F1E3000  cmpw cr6, r30, r6
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FF228: 40990008  ble cr6, 0x823ff230
	if !ctx.cr[6].gt {
	pc = 0x823FF230; continue 'dispatch;
	}
	// 823FF22C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 823FF230: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823FF234: 40990054  ble cr6, 0x823ff288
	if !ctx.cr[6].gt {
	pc = 0x823FF288; continue 'dispatch;
	}
	// 823FF238: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 823FF23C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823FF240: 7FE64214  add r31, r6, r8
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[8].u64;
	// 823FF244: 38C40004  addi r6, r4, 4
	ctx.r[6].s64 = ctx.r[4].s64 + 4;
	// 823FF248: 7F841850  subf r28, r4, r3
	ctx.r[28].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	// 823FF24C: 7F683850  subf r27, r8, r7
	ctx.r[27].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 823FF250: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 823FF254: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF258: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823FF25C: 7C1C342E  lfsx f0, r28, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF260: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 823FF264: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FF268: 7C1BFD2E  stfsx f0, r27, r31
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 823FF26C: C0060000  lfs f0, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF270: C1A6FFFC  lfs f13, -4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF274: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 823FF278: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FF27C: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF280: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823FF284: 4082FFD0  bne 0x823ff254
	if !ctx.cr[0].eq {
	pc = 0x823FF254; continue 'dispatch;
	}
	// 823FF288: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823FF28C: 38A5FFFE  addi r5, r5, -2
	ctx.r[5].s64 = ctx.r[5].s64 + -2;
	// 823FF290: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 823FF294: 40990008  ble cr6, 0x823ff29c
	if !ctx.cr[6].gt {
	pc = 0x823FF29C; continue 'dispatch;
	}
	// 823FF298: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 823FF29C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FF2A0: 40990050  ble cr6, 0x823ff2f0
	if !ctx.cr[6].gt {
	pc = 0x823FF2F0; continue 'dispatch;
	}
	// 823FF2A4: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FF2A8: 7FE83850  subf r31, r8, r7
	ctx.r[31].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 823FF2AC: 7CCA4214  add r6, r10, r8
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 823FF2B0: 39440008  addi r10, r4, 8
	ctx.r[10].s64 = ctx.r[4].s64 + 8;
	// 823FF2B4: 7C841850  subf r4, r4, r3
	ctx.r[4].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	// 823FF2B8: 7D655A14  add r11, r5, r11
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 823FF2BC: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF2C0: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FF2C4: 7C0A242E  lfsx f0, r10, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF2C8: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 823FF2CC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FF2D0: 7C06FD2E  stfsx f0, r6, r31
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 823FF2D4: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF2D8: C1AAFFF8  lfs f13, -8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF2DC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FF2E0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FF2E4: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF2E8: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 823FF2EC: 4082FFD0  bne 0x823ff2bc
	if !ctx.cr[0].eq {
	pc = 0x823FF2BC; continue 'dispatch;
	}
	// 823FF2F0: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 823FF2F4: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FF2F8: 41980054  blt cr6, 0x823ff34c
	if ctx.cr[6].lt {
	pc = 0x823FF34C; continue 'dispatch;
	}
	// 823FF2FC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823FF300: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FF304: 40990044  ble cr6, 0x823ff348
	if !ctx.cr[6].gt {
	pc = 0x823FF348; continue 'dispatch;
	}
	// 823FF308: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 823FF30C: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 823FF310: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 823FF314: 7D083850  subf r8, r8, r7
	ctx.r[8].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 823FF318: C1A42954  lfs f13, 0x2954(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(10580 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF31C: C0070000  lfs f0, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF320: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FF324: 40990018  ble cr6, 0x823ff33c
	if !ctx.cr[6].gt {
	pc = 0x823FF33C; continue 'dispatch;
	}
	// 823FF328: 7C0A452E  stfsx f0, r10, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 823FF32C: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 823FF330: 7C07342E  lfsx f0, r7, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF334: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF338: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FF33C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FF340: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FF344: 4082FFD8  bne 0x823ff31c
	if !ctx.cr[0].eq {
	pc = 0x823FF31C; continue 'dispatch;
	}
	// 823FF348: 90A90000  stw r5, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 823FF34C: 48135DB8  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FF350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FF350 size=360
    let mut pc: u32 = 0x823FF350;
    'dispatch: loop {
        match pc {
            0x823FF350 => {
    //   block [0x823FF350..0x823FF4B8)
	// 823FF350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FF354: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FF358: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823FF35C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FF360: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 823FF364: 48136C85  bl 0x82535fe8
	ctx.lr = 0x823FF368;
	sub_82535FB0(ctx, base);
	// 823FF368: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FF36C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FF370: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 823FF374: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 823FF378: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FF37C: D3FF000C  stfs f31, 0xc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 823FF380: D3BF0010  stfs f29, 0x10(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 823FF384: 4BF8147D  bl 0x82380800
	ctx.lr = 0x823FF388;
	sub_82380800(ctx, base);
	// 823FF388: A15F0018  lhz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FF38C: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 823FF390: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FF394: A97F0016  lha r11, 0x16(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as i16) as i64;
	// 823FF398: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823FF39C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823FF3A0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 823FF3A4: 697E0001  xori r30, r11, 1
	ctx.r[30].u64 = ctx.r[11].u64 ^ 1;
	// 823FF3A8: 4082000C  bne 0x823ff3b4
	if !ctx.cr[0].eq {
	pc = 0x823FF3B4; continue 'dispatch;
	}
	// 823FF3AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823FF3B0: B17F0018  sth r11, 0x18(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u16 ) };
	// 823FF3B4: A17F001A  lhz r11, 0x1a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(26 as u32) ) } as u64;
	// 823FF3B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FF3BC: 4082000C  bne 0x823ff3c8
	if !ctx.cr[0].eq {
	pc = 0x823FF3C8; continue 'dispatch;
	}
	// 823FF3C0: 3960005A  li r11, 0x5a
	ctx.r[11].s64 = 90;
	// 823FF3C4: B17F001A  sth r11, 0x1a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(26 as u32), ctx.r[11].u16 ) };
	// 823FF3C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FF3CC: C00B1850  lfs f0, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF3D0: EC3F002A  fadds f1, f31, f0
	ctx.f[1].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FF3D4: 48133D85  bl 0x82533158
	ctx.lr = 0x823FF3D8;
	sub_82533158(ctx, base);
	// 823FF3D8: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 823FF3DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FF3E0: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FF3E4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823FF3E8: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FF3EC: C00B906C  lfs f0, -0x6f94(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28564 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF3F0: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FF3F4: 480023BD  bl 0x824017b0
	ctx.lr = 0x823FF3F8;
	sub_824017B0(ctx, base);
	// 823FF3F8: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FF3FC: FC40E090  fmr f2, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[28].f64;
	// 823FF400: A0BF0018  lhz r5, 0x18(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FF404: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 823FF408: 48002419  bl 0x82401820
	ctx.lr = 0x823FF40C;
	sub_82401820(ctx, base);
	// 823FF40C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FF410: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823FF414: 48002495  bl 0x824018a8
	ctx.lr = 0x823FF418;
	sub_824018A8(ctx, base);
	// 823FF418: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FF41C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 823FF420: A0BF001A  lhz r5, 0x1a(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(26 as u32) ) } as u64;
	// 823FF424: A09F0018  lhz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FF428: 48002639  bl 0x82401a60
	ctx.lr = 0x823FF42C;
	sub_82401A60(ctx, base);
	// 823FF42C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823FF430: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FF434: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FF438: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 823FF43C: B17F001C  sth r11, 0x1c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u16 ) };
	// 823FF440: 480026F1  bl 0x82401b30
	ctx.lr = 0x823FF444;
	sub_82401B30(ctx, base);
	// 823FF444: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823FF448: 41820044  beq 0x823ff48c
	if ctx.cr[0].eq {
	pc = 0x823FF48C; continue 'dispatch;
	}
	// 823FF44C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FF450: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FF454: C00BBFFC  lfs f0, -0x4004(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF458: EC1E002A  fadds f0, f30, f0
	ctx.f[0].f64 = ((ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FF45C: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 823FF460: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 823FF464: 88610057  lbz r3, 0x57(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 823FF468: 480021E1  bl 0x82401648
	ctx.lr = 0x823FF46C;
	sub_82401648(ctx, base);
	// 823FF46C: 897F001E  lbz r11, 0x1e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(30 as u32) ) } as u64;
	// 823FF470: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FF474: 41820020  beq 0x823ff494
	if ctx.cr[0].eq {
	pc = 0x823FF494; continue 'dispatch;
	}
	// 823FF478: A09F0016  lhz r4, 0x16(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 823FF47C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FF480: 48002081  bl 0x82401500
	ctx.lr = 0x823FF484;
	sub_82401500(ctx, base);
	// 823FF484: B07F0014  sth r3, 0x14(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u16 ) };
	// 823FF488: 4800000C  b 0x823ff494
	pc = 0x823FF494; continue 'dispatch;
	// 823FF48C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FF490: 480022C9  bl 0x82401758
	ctx.lr = 0x823FF494;
	sub_82401758(ctx, base);
	// 823FF494: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FF498: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823FF49C: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 823FF4A0: 48136B95  bl 0x82536034
	ctx.lr = 0x823FF4A4;
	sub_82535FFC(ctx, base);
	// 823FF4A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FF4A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FF4AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823FF4B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FF4B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FF4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FF4B8 size=400
    let mut pc: u32 = 0x823FF4B8;
    'dispatch: loop {
        match pc {
            0x823FF4B8 => {
    //   block [0x823FF4B8..0x823FF648)
	// 823FF4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FF4BC: 48135BF1  bl 0x825350ac
	ctx.lr = 0x823FF4C0;
	sub_82535080(ctx, base);
	// 823FF4C0: DBA1FFA8  stfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[29].u64 ) };
	// 823FF4C4: DBC1FFB0  stfd f30, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 823FF4C8: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 823FF4CC: 9421FB30  stwu r1, -0x4d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1232 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FF4D0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 823FF4D4: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 823FF4D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823FF4DC: 3B3A0008  addi r25, r26, 8
	ctx.r[25].s64 = ctx.r[26].s64 + 8;
	// 823FF4E0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823FF4E4: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 823FF4E8: C07E0030  lfs f3, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 823FF4EC: C03E0034  lfs f1, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FF4F0: C0990004  lfs f4, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 823FF4F4: C0590000  lfs f2, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823FF4F8: 4BFFF181  bl 0x823fe678
	ctx.lr = 0x823FF4FC;
	sub_823FE678(ctx, base);
	// 823FF4FC: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 823FF500: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 823FF504: 409A0010  bne cr6, 0x823ff514
	if !ctx.cr[6].eq {
	pc = 0x823FF514; continue 'dispatch;
	}
	// 823FF508: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FF50C: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF510: EFDE0032  fmuls f30, f30, f0
	ctx.f[30].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FF514: 839E0000  lwz r28, 0(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF518: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 823FF51C: 4BFFEBA5  bl 0x823fe0c0
	ctx.lr = 0x823FF520;
	sub_823FE0C0(ctx, base);
	// 823FF520: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FF524: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 823FF528: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823FF52C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823FF530: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823FF534: 4BFFE42D  bl 0x823fd960
	ctx.lr = 0x823FF538;
	sub_823FD960(ctx, base);
	// 823FF538: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823FF53C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823FF540: 4BFFE971  bl 0x823fdeb0
	ctx.lr = 0x823FF544;
	sub_823FDEB0(ctx, base);
	// 823FF544: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FF548: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 823FF54C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 823FF550: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823FF554: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823FF558: C3EB8E30  lfs f31, -0x71d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29136 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FF55C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 823FF560: 4BFFF1C1  bl 0x823fe720
	ctx.lr = 0x823FF564;
	sub_823FE720(ctx, base);
	// 823FF564: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FF568: D03A0000  stfs f1, 0(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF56C: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 823FF570: C16BBFFC  lfs f11, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FF574: 409A000C  bne cr6, 0x823ff580
	if !ctx.cr[6].eq {
	pc = 0x823FF580; continue 'dispatch;
	}
	// 823FF578: EC0102F2  fmuls f0, f1, f11
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FF57C: D01A0000  stfs f0, 0(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF580: C19E001C  lfs f12, 0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FF584: FD40E890  fmr f10, f29
	ctx.f[10].f64 = ctx.f[29].f64;
	// 823FF588: C0190004  lfs f0, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF58C: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 823FF590: C1BE0030  lfs f13, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF594: 40980008  bge cr6, 0x823ff59c
	if !ctx.cr[6].lt {
	pc = 0x823FF59C; continue 'dispatch;
	}
	// 823FF598: D3FE001C  stfs f31, 0x1c(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 823FF59C: FF1DF800  fcmpu cr6, f29, f31
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[31].f64);
	// 823FF5A0: 40980008  bge cr6, 0x823ff5a8
	if !ctx.cr[6].lt {
	pc = 0x823FF5A8; continue 'dispatch;
	}
	// 823FF5A4: FD40F890  fmr f10, f31
	ctx.f[10].f64 = ctx.f[31].f64;
	// 823FF5A8: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FF5AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FF5B0: FD206210  fabs f9, f12
	ctx.f[9].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 823FF5B4: C18B9070  lfs f12, -0x6f90(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28560 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FF5B8: FF096000  fcmpu cr6, f9, f12
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[12].f64);
	// 823FF5BC: 40980010  bge cr6, 0x823ff5cc
	if !ctx.cr[6].lt {
	pc = 0x823FF5CC; continue 'dispatch;
	}
	// 823FF5C0: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FF5C4: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FF5C8: 4800003C  b 0x823ff604
	pc = 0x823FF604; continue 'dispatch;
	// 823FF5CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FF5D0: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FF5D4: C16B2980  lfs f11, 0x2980(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10624 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FF5D8: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 823FF5DC: 40980014  bge cr6, 0x823ff5f0
	if !ctx.cr[6].lt {
	pc = 0x823FF5F0; continue 'dispatch;
	}
	// 823FF5E0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FF5E4: 41990014  bgt cr6, 0x823ff5f8
	if ctx.cr[6].gt {
	pc = 0x823FF5F8; continue 'dispatch;
	}
	// 823FF5E8: EC005024  fdivs f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 823FF5EC: 48000014  b 0x823ff600
	pc = 0x823FF600; continue 'dispatch;
	// 823FF5F0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FF5F4: 4199FFF4  bgt cr6, 0x823ff5e8
	if ctx.cr[6].gt {
	pc = 0x823FF5E8; continue 'dispatch;
	}
	// 823FF5F8: C01E001C  lfs f0, 0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF5FC: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 823FF600: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FF604: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FF608: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF60C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FF610: 40980008  bge cr6, 0x823ff618
	if !ctx.cr[6].lt {
	pc = 0x823FF618; continue 'dispatch;
	}
	// 823FF614: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 823FF618: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FF61C: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF620: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FF624: 40990008  ble cr6, 0x823ff62c
	if !ctx.cr[6].gt {
	pc = 0x823FF62C; continue 'dispatch;
	}
	// 823FF628: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 823FF62C: D15E001C  stfs f10, 0x1c(r30)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 823FF630: D01A0004  stfs f0, 4(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FF634: 382104D0  addi r1, r1, 0x4d0
	ctx.r[1].s64 = ctx.r[1].s64 + 1232;
	// 823FF638: CBA1FFA8  lfd f29, -0x58(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 823FF63C: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 823FF640: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 823FF644: 48135AB8  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FF648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FF648 size=636
    let mut pc: u32 = 0x823FF648;
    'dispatch: loop {
        match pc {
            0x823FF648 => {
    //   block [0x823FF648..0x823FF8C4)
	// 823FF648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FF64C: 48135A51  bl 0x8253509c
	ctx.lr = 0x823FF650;
	sub_82535080(ctx, base);
	// 823FF650: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FF654: 3D208273  lis r9, -0x7d8d
	ctx.r[9].s64 = -2106392576;
	// 823FF658: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 823FF65C: 3B270140  addi r25, r7, 0x140
	ctx.r[25].s64 = ctx.r[7].s64 + 320;
	// 823FF660: 3B070170  addi r24, r7, 0x170
	ctx.r[24].s64 = ctx.r[7].s64 + 368;
	// 823FF664: C00B207C  lfs f0, 0x207c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF668: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FF66C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FF670: 3B89D6A8  addi r28, r9, -0x2958
	ctx.r[28].s64 = ctx.r[9].s64 + -10584;
	// 823FF674: 396B9078  addi r11, r11, -0x6f88
	ctx.r[11].s64 = ctx.r[11].s64 + -28552;
	// 823FF678: 40990014  ble cr6, 0x823ff68c
	if !ctx.cr[6].gt {
	pc = 0x823FF68C; continue 'dispatch;
	}
	// 823FF67C: 392B066C  addi r9, r11, 0x66c
	ctx.r[9].s64 = ctx.r[11].s64 + 1644;
	// 823FF680: 7D765B78  mr r22, r11
	ctx.r[22].u64 = ctx.r[11].u64;
	// 823FF684: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 823FF688: 48000010  b 0x823ff698
	pc = 0x823FF698; continue 'dispatch;
	// 823FF68C: 3ACB0030  addi r22, r11, 0x30
	ctx.r[22].s64 = ctx.r[11].s64 + 48;
	// 823FF690: 391C0018  addi r8, r28, 0x18
	ctx.r[8].s64 = ctx.r[28].s64 + 24;
	// 823FF694: 392B0AB8  addi r9, r11, 0xab8
	ctx.r[9].s64 = ctx.r[11].s64 + 2744;
	// 823FF698: 9121FF90  stw r9, -0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.r[9].u32 ) };
	// 823FF69C: 393C0030  addi r9, r28, 0x30
	ctx.r[9].s64 = ctx.r[28].s64 + 48;
	// 823FF6A0: 3861FF90  addi r3, r1, -0x70
	ctx.r[3].s64 = ctx.r[1].s64 + -112;
	// 823FF6A4: 38CB10E4  addi r6, r11, 0x10e4
	ctx.r[6].s64 = ctx.r[11].s64 + 4324;
	// 823FF6A8: 38EB0E10  addi r7, r11, 0xe10
	ctx.r[7].s64 = ctx.r[11].s64 + 3600;
	// 823FF6AC: 396B1378  addi r11, r11, 0x1378
	ctx.r[11].s64 = ctx.r[11].s64 + 4984;
	// 823FF6B0: 3BC9FFF0  addi r30, r9, -0x10
	ctx.r[30].s64 = ctx.r[9].s64 + -16;
	// 823FF6B4: 7EE34050  subf r23, r3, r8
	ctx.r[23].s64 = ctx.r[8].s64 - ctx.r[3].s64;
	// 823FF6B8: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 823FF6BC: 90C1FF98  stw r6, -0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.r[6].u32 ) };
	// 823FF6C0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 823FF6C4: 90E1FF94  stw r7, -0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-108 as u32), ctx.r[7].u32 ) };
	// 823FF6C8: 9161FF9C  stw r11, -0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-100 as u32), ctx.r[11].u32 ) };
	// 823FF6CC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 823FF6D0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 823FF6D4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823FF6D8: C1281FF8  lfs f9, 0x1ff8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8184 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FF6DC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 823FF6E0: C1491850  lfs f10, 0x1850(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6224 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FF6E4: 38C1FF90  addi r6, r1, -0x70
	ctx.r[6].s64 = ctx.r[1].s64 + -112;
	// 823FF6E8: 2F1A0004  cmpwi cr6, r26, 4
	ctx.cr[6].compare_i32(ctx.r[26].s32, 4, &mut ctx.xer);
	// 823FF6EC: 409800D0  bge cr6, 0x823ff7bc
	if !ctx.cr[6].lt {
	pc = 0x823FF7BC; continue 'dispatch;
	}
	// 823FF6F0: 81260000  lwz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF6F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FF6F8: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF6FC: 55071838  slwi r7, r8, 3
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 823FF700: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FF704: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 823FF708: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF70C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF710: C0080004  lfs f0, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF714: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FF718: 81090018  lwz r8, 0x18(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FF71C: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823FF720: 40810028  ble 0x823ff748
	if !ctx.cr[0].gt {
	pc = 0x823FF748; continue 'dispatch;
	}
	// 823FF724: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF728: 80E9001C  lwz r7, 0x1c(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 823FF72C: 82A70000  lwz r21, 0(r7)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF730: 7F15F800  cmpw cr6, r21, r31
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[31].s32, &mut ctx.xer);
	// 823FF734: 419A0080  beq cr6, 0x823ff7b4
	if ctx.cr[6].eq {
	pc = 0x823FF7B4; continue 'dispatch;
	}
	// 823FF738: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 823FF73C: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FF740: 7F034000  cmpw cr6, r3, r8
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[8].s32, &mut ctx.xer);
	// 823FF744: 4198FFE8  blt cr6, 0x823ff72c
	if ctx.cr[6].lt {
	pc = 0x823FF72C; continue 'dispatch;
	}
	// 823FF748: 80E90010  lwz r7, 0x10(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 823FF74C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF750: C10B0000  lfs f8, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823FF754: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FF758: C0EB0004  lfs f7, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 823FF75C: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823FF760: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FF764: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 823FF768: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823FF76C: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 823FF770: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF774: ECCD0372  fmuls f6, f13, f13
	ctx.f[6].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FF778: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF77C: C1680004  lfs f11, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FF780: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FF784: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FF788: ECC0303A  fmadds f6, f0, f0, f6
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64);
	// 823FF78C: EDA06B38  fmsubs f13, f0, f12, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FF790: EC0A3024  fdivs f0, f10, f6
	ctx.f[0].f64 = ((ctx.f[10].f64 / ctx.f[6].f64) as f32) as f64;
	// 823FF794: EDAD403A  fmadds f13, f13, f0, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 823FF798: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF79C: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF7A0: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FF7A4: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FF7A8: EDAC6AFA  fmadds f13, f12, f11, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FF7AC: EC0D383A  fmadds f0, f13, f0, f7
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 823FF7B0: 4800002C  b 0x823ff7dc
	pc = 0x823FF7DC; continue 'dispatch;
	// 823FF7B4: 80E90014  lwz r7, 0x14(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 823FF7B8: 4BFFFF94  b 0x823ff74c
	pc = 0x823FF74C; continue 'dispatch;
	// 823FF7BC: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF7C0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF7C4: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FF7C8: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FF7CC: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 823FF7D0: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF7D4: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF7D8: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF7DC: 7D37302E  lwzx r9, r23, r6
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 823FF7E0: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FF7E4: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 823FF7E8: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 823FF7EC: 7D194850  subf r8, r25, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[25].s64;
	// 823FF7F0: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 823FF7F4: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823FF7F8: 40990024  ble cr6, 0x823ff81c
	if !ctx.cr[6].gt {
	pc = 0x823FF81C; continue 'dispatch;
	}
	// 823FF7FC: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 823FF800: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 823FF804: 7DA84C2E  lfsx f13, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF808: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823FF80C: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FF810: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FF814: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 823FF818: 4082FFEC  bne 0x823ff804
	if !ctx.cr[0].eq {
	pc = 0x823FF804; continue 'dispatch;
	}
	// 823FF81C: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF820: 3463FFFF  addic. r3, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 823FF824: 7D1D4214  add r8, r29, r8
	ctx.r[8].u64 = ctx.r[29].u64 + ctx.r[8].u64;
	// 823FF828: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823FF82C: 4082FFC4  bne 0x823ff7f0
	if !ctx.cr[0].eq {
	pc = 0x823FF7F0; continue 'dispatch;
	}
	// 823FF830: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF834: 38FC0030  addi r7, r28, 0x30
	ctx.r[7].s64 = ctx.r[28].s64 + 48;
	// 823FF838: C1B80000  lfs f13, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF83C: 393B0001  addi r9, r27, 1
	ctx.r[9].s64 = ctx.r[27].s64 + 1;
	// 823FF840: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FF844: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF848: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FF84C: C0180004  lfs f0, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF850: 391D0004  addi r8, r29, 4
	ctx.r[8].s64 = ctx.r[29].s64 + 4;
	// 823FF854: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FF858: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823FF85C: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 823FF860: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF864: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 823FF868: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FF86C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF870: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 823FF874: 3B690001  addi r27, r9, 1
	ctx.r[27].s64 = ctx.r[9].s64 + 1;
	// 823FF878: 3BA80004  addi r29, r8, 4
	ctx.r[29].s64 = ctx.r[8].s64 + 4;
	// 823FF87C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FF880: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FF884: 7F1E3800  cmpw cr6, r30, r7
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[7].s32, &mut ctx.xer);
	// 823FF888: 4198FE60  blt cr6, 0x823ff6e8
	if ctx.cr[6].lt {
	pc = 0x823FF6E8; continue 'dispatch;
	}
	// 823FF88C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FF890: 40990030  ble cr6, 0x823ff8c0
	if !ctx.cr[6].gt {
	pc = 0x823FF8C0; continue 'dispatch;
	}
	// 823FF894: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 823FF898: 7D39B050  subf r9, r25, r22
	ctx.r[9].s64 = ctx.r[22].s64 - ctx.r[25].s64;
	// 823FF89C: 7D192050  subf r8, r25, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[25].s64;
	// 823FF8A0: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 823FF8A4: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF8A8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FF8AC: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF8B0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 823FF8B4: 7C0B452E  stfsx f0, r11, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 823FF8B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FF8BC: 4082FFE8  bne 0x823ff8a4
	if !ctx.cr[0].eq {
	pc = 0x823FF8A4; continue 'dispatch;
	}
	// 823FF8C0: 4813582C  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FF8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FF8C8 size=168
    let mut pc: u32 = 0x823FF8C8;
    'dispatch: loop {
        match pc {
            0x823FF8C8 => {
    //   block [0x823FF8C8..0x823FF970)
	// 823FF8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FF8CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FF8D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823FF8D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FF8D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FF8DC: A143005C  lhz r10, 0x5c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) } as u64;
	// 823FF8E0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 823FF8E4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 823FF8E8: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 823FF8EC: 409A0010  bne cr6, 0x823ff8fc
	if !ctx.cr[6].eq {
	pc = 0x823FF8FC; continue 'dispatch;
	}
	// 823FF8F0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FF8F4: C0AABFFC  lfs f5, -0x4004(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 823FF8F8: 48000010  b 0x823ff908
	pc = 0x823FF908; continue 'dispatch;
	// 823FF8FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823FF900: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 823FF904: C0AA1850  lfs f5, 0x1850(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 823FF908: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FF90C: 38E30068  addi r7, r3, 0x68
	ctx.r[7].s64 = ctx.r[3].s64 + 104;
	// 823FF910: 83C30014  lwz r30, 0x14(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 823FF914: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 823FF918: C0830020  lfs f4, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 823FF91C: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 823FF920: C063001C  lfs f3, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 823FF924: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FF928: 80C30008  lwz r6, 8(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FF92C: C04B0004  lfs f2, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823FF930: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FF934: C02B0000  lfs f1, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FF938: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF93C: 90E1007C  stw r7, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 823FF940: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 823FF944: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 823FF948: 48000721  bl 0x82400068
	ctx.lr = 0x823FF94C;
	sub_82400068(ctx, base);
	// 823FF94C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF950: 396B0050  addi r11, r11, 0x50
	ctx.r[11].s64 = ctx.r[11].s64 + 80;
	// 823FF954: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FF958: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823FF95C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FF960: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FF964: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823FF968: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FF96C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FF970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FF970 size=1140
    let mut pc: u32 = 0x823FF970;
    'dispatch: loop {
        match pc {
            0x823FF970 => {
    //   block [0x823FF970..0x823FFDE4)
	// 823FF970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FF974: 48135731  bl 0x825350a4
	ctx.lr = 0x823FF978;
	sub_82535080(ctx, base);
	// 823FF978: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 823FF97C: 4813666D  bl 0x82535fe8
	ctx.lr = 0x823FF980;
	sub_82535FB0(ctx, base);
	// 823FF980: 9421FCD0  stwu r1, -0x330(r1)
	ea = ctx.r[1].u32.wrapping_add(-816 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FF984: 3F608288  lis r27, -0x7d78
	ctx.r[27].s64 = -2105016320;
	// 823FF988: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 823FF98C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823FF990: FF801090  fmr f28, f2
	ctx.f[28].f64 = ctx.f[2].f64;
	// 823FF994: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FF998: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 823FF99C: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	// 823FF9A0: 817B37B0  lwz r11, 0x37b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FF9A4: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 823FF9A8: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 823FF9AC: 3B3E090C  addi r25, r30, 0x90c
	ctx.r[25].s64 = ctx.r[30].s64 + 2316;
	// 823FF9B0: 3B5E0808  addi r26, r30, 0x808
	ctx.r[26].s64 = ctx.r[30].s64 + 2056;
	// 823FF9B4: 38A0090C  li r5, 0x90c
	ctx.r[5].s64 = 2316;
	// 823FF9B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FF9BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823FF9C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FF9C4: 4E800421  bctrl
	ctx.lr = 0x823FF9C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FF9C8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823FF9CC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 823FF9D0: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 823FF9D4: 3CE08273  lis r7, -0x7d8d
	ctx.r[7].s64 = -2106392576;
	// 823FF9D8: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 823FF9DC: C1A9BFFC  lfs f13, -0x4004(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF9E0: C19F0000  lfs f12, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FF9E4: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 823FF9E8: C008AC38  lfs f0, -0x53c8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-21448 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF9EC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FF9F0: EC006B3A  fmadds f0, f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FF9F4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823FF9F8: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FF9FC: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 823FFA00: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FFA04: 552615BA  rlwinm r6, r9, 2, 0x16, 0x1d
	ctx.r[6].u64 = ctx.r[9].u32 as u64 & 0x3FFFFFFFu64;
	// 823FFA08: 8127D6E0  lwz r9, -0x2920(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-10528 as u32) ) } as u64;
	// 823FFA0C: 7C064C2E  lfsx f0, r6, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFA10: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFA14: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FFA18: 4082FFC8  bne 0x823ff9e0
	if !ctx.cr[0].eq {
	pc = 0x823FF9E0; continue 'dispatch;
	}
	// 823FFA1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FFA20: 38BE00E0  addi r5, r30, 0xe0
	ctx.r[5].s64 = ctx.r[30].s64 + 224;
	// 823FFA24: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 823FFA28: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823FFA2C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FFA30: C3CB1850  lfs f30, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 823FFA34: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 823FFA38: D3C50000  stfs f30, 0(r5)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFA3C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 823FFA40: 7C0AF42E  lfsx f0, r10, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFA44: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823FFA48: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 823FFA4C: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 823FFA50: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823FFA54: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 823FFA58: D1A80004  stfs f13, 4(r8)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FFA5C: 41980034  blt cr6, 0x823ffa90
	if ctx.cr[6].lt {
	pc = 0x823FFA90; continue 'dispatch;
	}
	// 823FFA60: 7CCA4A14  add r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823FFA64: 7C8B4850  subf r4, r11, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 823FFA68: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 823FFA6C: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 823FFA70: C1A60000  lfs f13, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FFA74: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FFA78: 7D84442E  lfsx f12, r4, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFA7C: 38C6FFFC  addi r6, r6, -4
	ctx.r[6].s64 = ctx.r[6].s64 + -4;
	// 823FFA80: EDAD603C  fnmsubs f13, f13, f0, f12
	ctx.f[13].f64 = -(((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 823FFA84: D1A80000  stfs f13, 0(r8)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFA88: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FFA8C: 4082FFE4  bne 0x823ffa70
	if !ctx.cr[0].eq {
	pc = 0x823FFA70; continue 'dispatch;
	}
	// 823FFA90: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FFA94: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 823FFA98: 2F0A0030  cmpwi cr6, r10, 0x30
	ctx.cr[6].compare_i32(ctx.r[10].s32, 48, &mut ctx.xer);
	// 823FFA9C: 4198FFA0  blt cr6, 0x823ffa3c
	if ctx.cr[6].lt {
	pc = 0x823FFA3C; continue 'dispatch;
	}
	// 823FFAA0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823FFAA4: 7D3D2850  subf r9, r29, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[29].s64;
	// 823FFAA8: 7D1DF050  subf r8, r29, r30
	ctx.r[8].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 823FFAAC: 7CFDE050  subf r7, r29, r28
	ctx.r[7].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 823FFAB0: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	// 823FFAB4: 7C095C2E  lfsx f0, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFAB8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FFABC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFAC0: 7C085C2E  lfsx f0, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFAC4: 7C075D2E  stfsx f0, r7, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 823FFAC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FFACC: 4082FFE8  bne 0x823ffab4
	if !ctx.cr[0].eq {
	pc = 0x823FFAB4; continue 'dispatch;
	}
	// 823FFAD0: 3BFE0030  addi r31, r30, 0x30
	ctx.r[31].s64 = ctx.r[30].s64 + 48;
	// 823FFAD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823FFAD8: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 823FFADC: 7CDF2850  subf r6, r31, r5
	ctx.r[6].s64 = ctx.r[5].s64 - ctx.r[31].s64;
	// 823FFAE0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 823FFAE4: D3BF0000  stfs f29, 0(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFAE8: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 823FFAEC: 7C0A342E  lfsx f0, r10, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFAF0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823FFAF4: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 823FFAF8: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FFAFC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823FFB00: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823FFB04: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FFB08: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 823FFB0C: 4099002C  ble cr6, 0x823ffb38
	if !ctx.cr[6].gt {
	pc = 0x823FFB38; continue 'dispatch;
	}
	// 823FFB10: 39050004  addi r8, r5, 4
	ctx.r[8].s64 = ctx.r[5].s64 + 4;
	// 823FFB14: 38EAFFFC  addi r7, r10, -4
	ctx.r[7].s64 = ctx.r[10].s64 + -4;
	// 823FFB18: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 823FFB1C: C1A80000  lfs f13, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FFB20: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FFB24: C1870000  lfs f12, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFB28: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FFB2C: EC0D033C  fnmsubs f0, f13, f12, f0
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FFB30: 38E7FFFC  addi r7, r7, -4
	ctx.r[7].s64 = ctx.r[7].s64 + -4;
	// 823FFB34: 4082FFE8  bne 0x823ffb1c
	if !ctx.cr[0].eq {
	pc = 0x823FFB1C; continue 'dispatch;
	}
	// 823FFB38: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823FFB3C: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFB40: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FFB44: 2F0B000C  cmpwi cr6, r11, 0xc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 12, &mut ctx.xer);
	// 823FFB48: 4099FFA0  ble cr6, 0x823ffae8
	if !ctx.cr[6].gt {
	pc = 0x823FFAE8; continue 'dispatch;
	}
	// 823FFB4C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FFB50: 2F0B002B  cmpwi cr6, r11, 0x2b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 43, &mut ctx.xer);
	// 823FFB54: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FFB58: 41990050  bgt cr6, 0x823ffba8
	if ctx.cr[6].gt {
	pc = 0x823FFBA8; continue 'dispatch;
	}
	// 823FFB5C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FFB60: 38E50004  addi r7, r5, 4
	ctx.r[7].s64 = ctx.r[5].s64 + 4;
	// 823FFB64: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 823FFB68: 20CB002C  subfic r6, r11, 0x2c
	ctx.xer.ca = ctx.r[11].u32 <= 44 as u32;
	ctx.r[6].s64 = (44 as i64) - ctx.r[11].s64;
	// 823FFB6C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 823FFB70: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 823FFB74: 390AFFFC  addi r8, r10, -4
	ctx.r[8].s64 = ctx.r[10].s64 + -4;
	// 823FFB78: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 823FFB7C: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FFB80: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FFB84: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFB88: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FFB8C: EC0D033C  fnmsubs f0, f13, f12, f0
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FFB90: 3908FFFC  addi r8, r8, -4
	ctx.r[8].s64 = ctx.r[8].s64 + -4;
	// 823FFB94: 4082FFE8  bne 0x823ffb7c
	if !ctx.cr[0].eq {
	pc = 0x823FFB7C; continue 'dispatch;
	}
	// 823FFB98: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFB9C: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 823FFBA0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FFBA4: 4082FFC8  bne 0x823ffb6c
	if !ctx.cr[0].eq {
	pc = 0x823FFB6C; continue 'dispatch;
	}
	// 823FFBA8: 3D408273  lis r10, -0x7d8d
	ctx.r[10].s64 = -2106392576;
	// 823FFBAC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823FFBB0: 814AD6EC  lwz r10, -0x2914(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10516 as u32) ) } as u64;
	// 823FFBB4: 7D3F5050  subf r9, r31, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	// 823FFBB8: 3940002B  li r10, 0x2b
	ctx.r[10].s64 = 43;
	// 823FFBBC: 7C095C2E  lfsx f0, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFBC0: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FFBC4: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FFBC8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FFBCC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFBD0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FFBD4: 4082FFE8  bne 0x823ffbbc
	if !ctx.cr[0].eq {
	pc = 0x823FFBBC; continue 'dispatch;
	}
	// 823FFBD8: 817B37B0  lwz r11, 0x37b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FFBDC: 38A00104  li r5, 0x104
	ctx.r[5].s64 = 260;
	// 823FFBE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FFBE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823FFBE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FFBEC: 4E800421  bctrl
	ctx.lr = 0x823FFBF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FFBF0: 817B37B0  lwz r11, 0x37b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FFBF4: 38A00104  li r5, 0x104
	ctx.r[5].s64 = 260;
	// 823FFBF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FFBFC: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 823FFC00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FFC04: 4E800421  bctrl
	ctx.lr = 0x823FFC08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FFC08: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 823FFC0C: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 823FFC10: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFC14: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 823FFC18: 396101B0  addi r11, r1, 0x1b0
	ctx.r[11].s64 = ctx.r[1].s64 + 432;
	// 823FFC1C: 38C1015C  addi r6, r1, 0x15c
	ctx.r[6].s64 = ctx.r[1].s64 + 348;
	// 823FFC20: 394102AC  addi r10, r1, 0x2ac
	ctx.r[10].s64 = ctx.r[1].s64 + 684;
	// 823FFC24: C1A4A624  lfs f13, -0x59dc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-23004 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FFC28: 38E10064  addi r7, r1, 0x64
	ctx.r[7].s64 = ctx.r[1].s64 + 100;
	// 823FFC2C: C005A620  lfs f0, -0x59e0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-23008 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFC30: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 823FFC34: 39000015  li r8, 0x15
	ctx.r[8].s64 = 21;
	// 823FFC38: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFC3C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FFC40: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FFC44: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFC48: ED6C0372  fmuls f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FFC4C: D16A0000  stfs f11, 0(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFC50: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823FFC54: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FFC58: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFC5C: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 823FFC60: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FFC64: D1670000  stfs f11, 0(r7)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFC68: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FFC6C: D1860000  stfs f12, 0(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFC70: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FFC74: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FFC78: 38C6FFFC  addi r6, r6, -4
	ctx.r[6].s64 = ctx.r[6].s64 + -4;
	// 823FFC7C: 4082FFBC  bne 0x823ffc38
	if !ctx.cr[0].eq {
	pc = 0x823FFC38; continue 'dispatch;
	}
	// 823FFC80: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFC84: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 823FFC88: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FFC8C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFC90: 388101B0  addi r4, r1, 0x1b0
	ctx.r[4].s64 = ctx.r[1].s64 + 432;
	// 823FFC94: EC0C0372  fmuls f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FFC98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823FFC9C: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFCA0: 4BFFDDA1  bl 0x823fda40
	ctx.lr = 0x823FFCA4;
	sub_823FDA40(ctx, base);
	// 823FFCA4: 7D7EC850  subf r11, r30, r25
	ctx.r[11].s64 = ctx.r[25].s64 - ctx.r[30].s64;
	// 823FFCA8: 39400041  li r10, 0x41
	ctx.r[10].s64 = 65;
	// 823FFCAC: 396BF6F4  addi r11, r11, -0x90c
	ctx.r[11].s64 = ctx.r[11].s64 + -2316;
	// 823FFCB0: 7D39D050  subf r9, r25, r26
	ctx.r[9].s64 = ctx.r[26].s64 - ctx.r[25].s64;
	// 823FFCB4: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 823FFCB8: 38E101B0  addi r7, r1, 0x1b0
	ctx.r[7].s64 = ctx.r[1].s64 + 432;
	// 823FFCBC: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FFCC0: 7C0B442E  lfsx f0, r11, r8
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFCC4: 7DAB3C2E  lfsx f13, r11, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FFCC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FFCCC: 7C09CD2E  stfsx f0, r9, r25
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[25].u32), tmp.u32) };
	// 823FFCD0: D1B90000  stfs f13, 0(r25)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFCD4: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 823FFCD8: 4181FFDC  bgt 0x823ffcb4
	if ctx.cr[0].gt {
	pc = 0x823FFCB4; continue 'dispatch;
	}
	// 823FFCDC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823FFCE0: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 823FFCE4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823FFCE8: 48001E89  bl 0x82401b70
	ctx.lr = 0x823FFCEC;
	sub_82401B70(ctx, base);
	// 823FFCEC: FC00F890  fmr f0, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[31].f64;
	// 823FFCF0: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	// 823FFCF4: FF1CF000  fcmpu cr6, f28, f30
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[30].f64);
	// 823FFCF8: 409A0014  bne cr6, 0x823ffd0c
	if !ctx.cr[6].eq {
	pc = 0x823FFD0C; continue 'dispatch;
	}
	// 823FFCFC: 7EEB0735  extsh. r11, r23
	ctx.r[11].s64 = ctx.r[23].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FFD00: 4082000C  bne 0x823ffd0c
	if !ctx.cr[0].eq {
	pc = 0x823FFD0C; continue 'dispatch;
	}
	// 823FFD04: 7F0B0735  extsh. r11, r24
	ctx.r[11].s64 = ctx.r[24].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FFD08: 418200CC  beq 0x823ffdd4
	if ctx.cr[0].eq {
	pc = 0x823FFDD4; continue 'dispatch;
	}
	// 823FFD0C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FFD10: 7F060734  extsh r6, r24
	ctx.r[6].s64 = ctx.r[24].s16 as i64;
	// 823FFD14: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 823FFD18: 7CFED050  subf r7, r30, r26
	ctx.r[7].s64 = ctx.r[26].s64 - ctx.r[30].s64;
	// 823FFD1C: 7F093000  cmpw cr6, r9, r6
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FFD20: 41980058  blt cr6, 0x823ffd78
	if ctx.cr[6].lt {
	pc = 0x823FFD78; continue 'dispatch;
	}
	// 823FFD24: 7D2A07B4  extsw r10, r9
	ctx.r[10].s64 = ctx.r[9].s32 as i64;
	// 823FFD28: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823FFD2C: 7EE80734  extsh r8, r23
	ctx.r[8].s64 = ctx.r[23].s16 as i64;
	// 823FFD30: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 823FFD34: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823FFD38: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 823FFD3C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 823FFD40: ED8C0732  fmuls f12, f12, f28
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[28].f64) as f32) as f64);
	// 823FFD44: FD80601E  fctiwz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 823FFD48: 7D802FAE  stfiwx f12, 0, r5
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32, tmp.u32) };
	// 823FFD4C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FFD50: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 823FFD54: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823FFD58: 2F0A0040  cmpwi cr6, r10, 0x40
	ctx.cr[6].compare_i32(ctx.r[10].s32, 64, &mut ctx.xer);
	// 823FFD5C: 7D88D42E  lfsx f12, r8, r26
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[26].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFD60: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFD64: 4199000C  bgt cr6, 0x823ffd70
	if ctx.cr[6].gt {
	pc = 0x823FFD70; continue 'dispatch;
	}
	// 823FFD68: 7D88D42E  lfsx f12, r8, r26
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[26].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFD6C: 48000010  b 0x823ffd7c
	pc = 0x823FFD7C; continue 'dispatch;
	// 823FFD70: C19A0100  lfs f12, 0x100(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(256 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFD74: 48000008  b 0x823ffd7c
	pc = 0x823FFD7C; continue 'dispatch;
	// 823FFD78: 7D875C2E  lfsx f12, r7, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFD7C: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFD80: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823FFD84: 7D875C2E  lfsx f12, r7, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFD88: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FFD8C: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FFD90: EDAD582A  fadds f13, f13, f11
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 823FFD94: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FFD98: 2F090041  cmpwi cr6, r9, 0x41
	ctx.cr[6].compare_i32(ctx.r[9].s32, 65, &mut ctx.xer);
	// 823FFD9C: 4198FF80  blt cr6, 0x823ffd1c
	if ctx.cr[6].lt {
	pc = 0x823FFD1C; continue 'dispatch;
	}
	// 823FFDA0: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FFDA4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823FFDA8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 823FFDAC: 7D1AF050  subf r8, r26, r30
	ctx.r[8].s64 = ctx.r[30].s64 - ctx.r[26].s64;
	// 823FFDB0: 39400041  li r10, 0x41
	ctx.r[10].s64 = 65;
	// 823FFDB4: C0092454  lfs f0, 0x2454(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9300 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFDB8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FFDBC: 7DA85C2E  lfsx f13, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FFDC0: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FFDC4: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FFDC8: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFDCC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FFDD0: 4082FFEC  bne 0x823ffdbc
	if !ctx.cr[0].eq {
	pc = 0x823FFDBC; continue 'dispatch;
	}
	// 823FFDD4: 38210330  addi r1, r1, 0x330
	ctx.r[1].s64 = ctx.r[1].s64 + 816;
	// 823FFDD8: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 823FFDDC: 48136259  bl 0x82536034
	ctx.lr = 0x823FFDE0;
	sub_82535FFC(ctx, base);
	// 823FFDE0: 48135314  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FFDE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FFDE8 size=252
    let mut pc: u32 = 0x823FFDE8;
    'dispatch: loop {
        match pc {
            0x823FFDE8 => {
    //   block [0x823FFDE8..0x823FFEE4)
	// 823FFDE8: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 823FFDEC: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 823FFDF0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823FFDF4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FFDF8: 83C3000C  lwz r30, 0xc(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FFDFC: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFE00: A0C30004  lhz r6, 4(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FFE04: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFE08: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 823FFE0C: 7D4A2830  slw r10, r10, r5
	if (ctx.r[5].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[5].u8 & 0x1F) as u32)) as u64;
	}
	// 823FFE10: 3BEAFFFF  addi r31, r10, -1
	ctx.r[31].s64 = ctx.r[10].s64 + -1;
	// 823FFE14: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFE18: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 823FFE1C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 823FFE20: 7CE82A14  add r7, r8, r5
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[5].u64;
	// 823FFE24: 54E50039  rlwinm. r5, r7, 0, 0, 0x1c
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FFE28: 41820068  beq 0x823ffe90
	if ctx.cr[0].eq {
	pc = 0x823FFE90; continue 'dispatch;
	}
	// 823FFE2C: 88A90000  lbz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFE30: 54C6043E  clrlwi r6, r6, 0x10
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0x0000FFFFu64;
	// 823FFE34: 21080008  subfic r8, r8, 8
	ctx.xer.ca = ctx.r[8].u32 <= 8 as u32;
	ctx.r[8].s64 = (8 as i64) - ctx.r[8].s64;
	// 823FFE38: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823FFE3C: 7CAA5430  srw r10, r5, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[5].u32) >> ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 823FFE40: 99440000  stb r10, 0(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 823FFE44: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFE48: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823FFE4C: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 823FFE50: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 823FFE54: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 823FFE58: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 823FFE5C: 41980010  blt cr6, 0x823ffe6c
	if ctx.cr[6].lt {
	pc = 0x823FFE6C; continue 'dispatch;
	}
	// 823FFE60: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FFE64: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 823FFE68: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFE6C: 89690000  lbz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFE70: 7FE94630  sraw r9, r31, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[31].s32 >> tmp.u32) as i64;
	// 823FFE74: 89440000  lbz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFE78: 38E7FFF8  addi r7, r7, -8
	ctx.r[7].s64 = ctx.r[7].s64 + -8;
	// 823FFE7C: 7D2B5838  and r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & ctx.r[11].u64;
	// 823FFE80: 7D6B4030  slw r11, r11, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[11].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 823FFE84: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 823FFE88: 99640000  stb r11, 0(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 823FFE8C: 48000048  b 0x823ffed4
	pc = 0x823FFED4; continue 'dispatch;
	// 823FFE90: 89290000  lbz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFE94: 57E8063E  clrlwi r8, r31, 0x18
	ctx.r[8].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 823FFE98: 2F070008  cmpwi cr6, r7, 8
	ctx.cr[6].compare_i32(ctx.r[7].s32, 8, &mut ctx.xer);
	// 823FFE9C: 7D2A5430  srw r10, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[9].u32) >> ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 823FFEA0: 7D4A4038  and r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[8].u64;
	// 823FFEA4: 99440000  stb r10, 0(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 823FFEA8: 409A002C  bne cr6, 0x823ffed4
	if !ctx.cr[6].eq {
	pc = 0x823FFED4; continue 'dispatch;
	}
	// 823FFEAC: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFEB0: 54C9043E  clrlwi r9, r6, 0x10
	ctx.r[9].u64 = ctx.r[6].u32 as u64 & 0x0000FFFFu64;
	// 823FFEB4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823FFEB8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823FFEBC: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 823FFEC0: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 823FFEC4: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823FFEC8: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 823FFECC: 41980008  blt cr6, 0x823ffed4
	if ctx.cr[6].lt {
	pc = 0x823FFED4; continue 'dispatch;
	}
	// 823FFED0: B0EB0000  sth r7, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 823FFED4: 98FE0000  stb r7, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	// 823FFED8: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FFEDC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 823FFEE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FFEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FFEE8 size=124
    let mut pc: u32 = 0x823FFEE8;
    'dispatch: loop {
        match pc {
            0x823FFEE8 => {
    //   block [0x823FFEE8..0x823FFF64)
	// 823FFEE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FFEEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FFEF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823FFEF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FFEF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FFEFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FFF00: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823FFF04: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823FFF08: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FFF0C: 419A0040  beq cr6, 0x823fff4c
	if ctx.cr[6].eq {
	pc = 0x823FFF4C; continue 'dispatch;
	}
	// 823FFF10: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823FFF14: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823FFF18: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 823FFF1C: 816B37A8  lwz r11, 0x37a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FFF20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FFF24: 4E800421  bctrl
	ctx.lr = 0x823FFF28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FFF28: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FFF2C: 4082000C  bne 0x823fff38
	if !ctx.cr[0].eq {
	pc = 0x823FFF38; continue 'dispatch;
	}
	// 823FFF30: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 823FFF34: 48000014  b 0x823fff48
	pc = 0x823FFF48; continue 'dispatch;
	// 823FFF38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FFF3C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 823FFF40: C00B0828  lfs f0, 0x828(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2088 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFF44: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 823FFF48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823FFF4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FFF50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FFF54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FFF58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823FFF5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FFF60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FFF68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FFF68 size=76
    let mut pc: u32 = 0x823FFF68;
    'dispatch: loop {
        match pc {
            0x823FFF68 => {
    //   block [0x823FFF68..0x823FFFB4)
	// 823FFF68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FFF6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FFF70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FFF74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FFF78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FFF7C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFF80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FFF84: 4182001C  beq 0x823fffa0
	if ctx.cr[0].eq {
	pc = 0x823FFFA0; continue 'dispatch;
	}
	// 823FFF88: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823FFF8C: 816B37AC  lwz r11, 0x37ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FFF90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FFF94: 4E800421  bctrl
	ctx.lr = 0x823FFF98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FFF98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FFF9C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FFFA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823FFFA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FFFA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FFFAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FFFB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FFFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FFFB8 size=140
    let mut pc: u32 = 0x823FFFB8;
    'dispatch: loop {
        match pc {
            0x823FFFB8 => {
    //   block [0x823FFFB8..0x82400044)
	// 823FFFB8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FFFBC: FDA00890  fmr f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ctx.f[1].f64;
	// 823FFFC0: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 823FFFC4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 823FFFC8: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 823FFFCC: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823FFFD0: C00B246C  lfs f0, 0x246c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9324 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFFD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FFFD8: ED820032  fmuls f12, f2, f0
	ctx.f[12].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FFFDC: C009A660  lfs f0, -0x59a0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-22944 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFFE0: FD80601E  fctiwz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 823FFFE4: 7D8047AE  stfiwx f12, 0, r8
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 823FFFE8: 40990050  ble cr6, 0x82400038
	if !ctx.cr[6].gt {
	pc = 0x82400038; continue 'dispatch;
	}
	// 823FFFEC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 823FFFF0: C189A65C  lfs f12, -0x59a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-22948 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFFF4: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FFFF8: 8121FFF0  lwz r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 823FFFFC: ED6B682A  fadds f11, f11, f13
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82400000: D16A0000  stfs f11, 0(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400004: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82400008: EDAD082A  fadds f13, f13, f1
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64;
	// 8240000C: 41980008  blt cr6, 0x82400014
	if ctx.cr[6].lt {
	pc = 0x82400014; continue 'dispatch;
	}
	// 82400010: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82400014: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82400018: 40820010  bne 0x82400028
	if !ctx.cr[0].eq {
	pc = 0x82400028; continue 'dispatch;
	}
	// 8240001C: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82400020: ED6B002A  fadds f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82400024: D16A0000  stfs f11, 0(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400028: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8240002C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82400030: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82400034: 4198FFC0  blt cr6, 0x823ffff4
	if ctx.cr[6].lt {
	pc = 0x823FFFF4; continue 'dispatch;
	}
	// 82400038: 39640003  addi r11, r4, 3
	ctx.r[11].s64 = ctx.r[4].s64 + 3;
	// 8240003C: 7D6A1671  srawi. r10, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82400040: 4C810020  blelr
	if !ctx.cr[0].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82400044(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82400044 size=32
    let mut pc: u32 = 0x82400044;
    'dispatch: loop {
        match pc {
            0x82400044 => {
    //   block [0x82400044..0x82400064)
	// 82400044: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82400068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82400068 size=1052
    let mut pc: u32 = 0x82400068;
    'dispatch: loop {
        match pc {
            0x82400068 => {
    //   block [0x82400068..0x82400484)
	// 82400068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240006C: 48135029  bl 0x82535094
	ctx.lr = 0x82400070;
	sub_82535080(ctx, base);
	// 82400070: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 82400074: 48135F69  bl 0x82535fdc
	ctx.lr = 0x82400078;
	sub_82535FB0(ctx, base);
	// 82400078: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240007C: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82400080: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82400084: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 82400088: FF401890  fmr f26, f3
	ctx.f[26].f64 = ctx.f[3].f64;
	// 8240008C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82400090: FF202090  fmr f25, f4
	ctx.f[25].f64 = ctx.f[4].f64;
	// 82400094: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82400098: FF802890  fmr f28, f5
	ctx.f[28].f64 = ctx.f[5].f64;
	// 8240009C: 7C942378  mr r20, r4
	ctx.r[20].u64 = ctx.r[4].u64;
	// 824000A0: C3CBBFFC  lfs f30, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 824000A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824000A8: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 824000AC: 7CD33378  mr r19, r6
	ctx.r[19].u64 = ctx.r[6].u64;
	// 824000B0: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 824000B4: EDBD07B2  fmuls f13, f29, f30
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[30].f64) as f32) as f64);
	// 824000B8: C00B7588  lfs f0, 0x7588(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30088 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824000BC: EFE0E824  fdivs f31, f0, f29
	ctx.f[31].f64 = ((ctx.f[0].f64 / ctx.f[29].f64) as f32) as f64;
	// 824000C0: FC00681E  fctiwz f0, f13
	ctx.f[0].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 824000C4: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 824000C8: 83E10070  lwz r31, 0x70(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 824000CC: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 824000D0: 7FEB07B4  extsw r11, r31
	ctx.r[11].s64 = ctx.r[31].s32 as i64;
	// 824000D4: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 824000D8: C8010070  lfd f0, 0x70(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 824000DC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 824000E0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 824000E4: EC00F7FA  fmadds f0, f0, f31, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[30].f64) as f32) as f64);
	// 824000E8: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 824000EC: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 824000F0: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 824000F4: 2F0B0100  cmpwi cr6, r11, 0x100
	ctx.cr[6].compare_i32(ctx.r[11].s32, 256, &mut ctx.xer);
	// 824000F8: 41980008  blt cr6, 0x82400100
	if ctx.cr[6].lt {
	pc = 0x82400100; continue 'dispatch;
	}
	// 824000FC: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 82400100: 2F1F0064  cmpwi cr6, r31, 0x64
	ctx.cr[6].compare_i32(ctx.r[31].s32, 100, &mut ctx.xer);
	// 82400104: 40990008  ble cr6, 0x8240010c
	if !ctx.cr[6].gt {
	pc = 0x8240010C; continue 'dispatch;
	}
	// 82400108: 3BE00064  li r31, 0x64
	ctx.r[31].s64 = 100;
	// 8240010C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82400110: C1AB227C  lfs f13, 0x227c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8828 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400114: EC020372  fmuls f0, f2, f13
	ctx.f[0].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 82400118: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8240011C: 40980014  bge cr6, 0x82400130
	if !ctx.cr[6].lt {
	pc = 0x82400130; continue 'dispatch;
	}
	// 82400120: 39600064  li r11, 0x64
	ctx.r[11].s64 = 100;
	// 82400124: 0CDF0000  twi 6, r31, 0
	// 82400128: 7F6BFBD6  divw r27, r11, r31
	ctx.r[27].s32 = ctx.r[11].s32 / ctx.r[31].s32;
	// 8240012C: 48000008  b 0x82400134
	pc = 0x82400134; continue 'dispatch;
	// 82400130: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82400134: 7F6A07B4  extsw r10, r27
	ctx.r[10].s64 = ctx.r[27].s32 as i64;
	// 82400138: EDA00772  fmuls f13, f0, f29
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 8240013C: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82400140: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82400144: 7EFBF9D6  mullw r23, r27, r31
	ctx.r[23].s64 = (ctx.r[27].s32 as i64) * (ctx.r[31].s32 as i64);
	// 82400148: F9410078  std r10, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u64 ) };
	// 8240014C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82400150: 3B0BA628  addi r24, r11, -0x59d8
	ctx.r[24].s64 = ctx.r[11].s64 + -23000;
	// 82400154: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82400158: 3978001C  addi r11, r24, 0x1c
	ctx.r[11].s64 = ctx.r[24].s64 + 28;
	// 8240015C: C00AA668  lfs f0, -0x5998(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-22936 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400160: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82400164: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82400168: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 8240016C: 83A10070  lwz r29, 0x70(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82400170: 7EDDD9D6  mullw r22, r29, r27
	ctx.r[22].s64 = (ctx.r[29].s32 as i64) * (ctx.r[27].s32 as i64);
	// 82400174: C8010078  lfd f0, 0x78(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82400178: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8240017C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82400180: EF7F0024  fdivs f27, f31, f0
	ctx.f[27].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 82400184: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400188: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 8240018C: 4199001C  bgt cr6, 0x824001a8
	if ctx.cr[6].gt {
	pc = 0x824001A8; continue 'dispatch;
	}
	// 82400190: 3958001C  addi r10, r24, 0x1c
	ctx.r[10].s64 = ctx.r[24].s64 + 28;
	// 82400194: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82400198: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 8240019C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 824001A0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824001A4: 4198FFE0  blt cr6, 0x82400184
	if ctx.cr[6].lt {
	pc = 0x82400184; continue 'dispatch;
	}
	// 824001A8: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 824001AC: 4BFFDFBD  bl 0x823fe168
	ctx.lr = 0x824001B0;
	sub_823FE168(ctx, base);
	// 824001B0: 57C6103A  slwi r6, r30, 2
	ctx.r[6].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 824001B4: 83C10184  lwz r30, 0x184(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 824001B8: 39780004  addi r11, r24, 4
	ctx.r[11].s64 = ctx.r[24].s64 + 4;
	// 824001BC: FC80E090  fmr f4, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[4].f64 = ctx.f[28].f64;
	// 824001C0: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 824001C4: 8341018C  lwz r26, 0x18c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(396 as u32) ) } as u64;
	// 824001C8: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 824001CC: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 824001D0: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 824001D4: FC60D890  fmr f3, f27
	ctx.f[3].f64 = ctx.f[27].f64;
	// 824001D8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 824001DC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 824001E0: 7C065C2E  lfsx f0, r6, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824001E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824001E8: EDA107BA  fmadds f13, f1, f30, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 824001EC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 824001F0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 824001F4: C00BA658  lfs f0, -0x59a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22952 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824001F8: EC2D0028  fsubs f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 824001FC: 48001B35  bl 0x82401d30
	ctx.lr = 0x82400200;
	sub_82401D30(ctx, base);
	// 82400200: C1BC0008  lfs f13, 8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400204: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82400208: EDADF82A  fadds f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 8240020C: C19C0000  lfs f12, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400210: C00BA664  lfs f0, -0x599c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22940 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400214: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82400218: EDAD603A  fmadds f13, f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8240021C: C00B2200  lfs f0, 0x2200(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8704 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400220: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82400224: C14B1FF8  lfs f10, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82400228: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 8240022C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82400230: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82400234: 4099000C  ble cr6, 0x82400240
	if !ctx.cr[6].gt {
	pc = 0x82400240; continue 'dispatch;
	}
	// 82400238: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 8240023C: 48000008  b 0x82400244
	pc = 0x82400244; continue 'dispatch;
	// 82400240: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82400244: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82400248: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 8240024C: E9410072  lwa r10, 0x70(r1)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as i32) as i64;
	// 82400250: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82400254: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82400258: D3FC0008  stfs f31, 8(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8240025C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82400260: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82400264: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82400268: F9410078  std r10, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u64 ) };
	// 8240026C: C00B2204  lfs f0, 0x2204(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400270: C9810078  lfd f12, 0x78(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82400274: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82400278: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8240027C: EC2C683C  fnmsubs f1, f12, f0, f13
	ctx.f[1].f64 = -(((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82400280: D03C0000  stfs f1, 0(r28)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400284: 4BFFFD35  bl 0x823fffb8
	ctx.lr = 0x82400288;
	sub_823FFFB8(ctx, base);
	// 82400288: 397FFFFF  addi r11, r31, -1
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	// 8240028C: 3957FFFF  addi r10, r23, -1
	ctx.r[10].s64 = ctx.r[23].s64 + -1;
	// 82400290: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82400294: 41980068  blt cr6, 0x824002fc
	if ctx.cr[6].lt {
	pc = 0x824002FC; continue 'dispatch;
	}
	// 82400298: 7D3D5850  subf r9, r29, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 8240029C: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824002A0: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 824002A4: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824002A8: 5764103A  slwi r4, r27, 2
	ctx.r[4].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 824002AC: 7D29F214  add r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 824002B0: 7CC8F214  add r6, r8, r30
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[30].u64;
	// 824002B4: 7C7ED050  subf r3, r30, r26
	ctx.r[3].s64 = ctx.r[26].s64 - ctx.r[30].s64;
	// 824002B8: 7D675850  subf r11, r7, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 824002BC: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 824002C0: 40990030  ble cr6, 0x824002f0
	if !ctx.cr[6].gt {
	pc = 0x824002F0; continue 'dispatch;
	}
	// 824002C4: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 824002C8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 824002CC: 7D5B5050  subf r10, r27, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[27].s64;
	// 824002D0: 7D244850  subf r9, r4, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[4].s64;
	// 824002D4: 7C061C2E  lfsx f0, r6, r3
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824002D8: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 824002DC: 7C03452E  stfsx f0, r3, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 824002E0: C0060000  lfs f0, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824002E4: D0080000  stfs f0, 0(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824002E8: 3908FFFC  addi r8, r8, -4
	ctx.r[8].s64 = ctx.r[8].s64 + -4;
	// 824002EC: 4082FFE8  bne 0x824002d4
	if !ctx.cr[0].eq {
	pc = 0x824002D4; continue 'dispatch;
	}
	// 824002F0: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 824002F4: 38C6FFFC  addi r6, r6, -4
	ctx.r[6].s64 = ctx.r[6].s64 + -4;
	// 824002F8: 4082FFC4  bne 0x824002bc
	if !ctx.cr[0].eq {
	pc = 0x824002BC; continue 'dispatch;
	}
	// 824002FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82400300: 41980060  blt cr6, 0x82400360
	if ctx.cr[6].lt {
	pc = 0x82400360; continue 'dispatch;
	}
	// 82400304: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82400308: 7CDED050  subf r6, r30, r26
	ctx.r[6].s64 = ctx.r[26].s64 - ctx.r[30].s64;
	// 8240030C: 7CE9F214  add r7, r9, r30
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 82400310: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82400314: 7C07342E  lfsx f0, r7, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400318: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8240031C: 2F1B0001  cmpwi cr6, r27, 1
	ctx.cr[6].compare_i32(ctx.r[27].s32, 1, &mut ctx.xer);
	// 82400320: 7C09D52E  stfsx f0, r9, r26
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[26].u32), tmp.u32) };
	// 82400324: C0070000  lfs f0, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400328: 7C09F52E  stfsx f0, r9, r30
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[30].u32), tmp.u32) };
	// 8240032C: 40990028  ble cr6, 0x82400354
	if !ctx.cr[6].gt {
	pc = 0x82400354; continue 'dispatch;
	}
	// 82400330: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82400334: 393BFFFF  addi r9, r27, -1
	ctx.r[9].s64 = ctx.r[27].s64 + -1;
	// 82400338: 7D08F214  add r8, r8, r30
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[30].u64;
	// 8240033C: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82400340: 7D48352E  stfsx f10, r8, r6
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 82400344: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82400348: D1480000  stfs f10, 0(r8)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8240034C: 3908FFFC  addi r8, r8, -4
	ctx.r[8].s64 = ctx.r[8].s64 + -4;
	// 82400350: 4082FFF0  bne 0x82400340
	if !ctx.cr[0].eq {
	pc = 0x82400340; continue 'dispatch;
	}
	// 82400354: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82400358: 38E7FFFC  addi r7, r7, -4
	ctx.r[7].s64 = ctx.r[7].s64 + -4;
	// 8240035C: 4080FFB4  bge 0x82400310
	if !ctx.cr[0].lt {
	pc = 0x82400310; continue 'dispatch;
	}
	// 82400360: 7F16B800  cmpw cr6, r22, r23
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[23].s32, &mut ctx.xer);
	// 82400364: 40980080  bge cr6, 0x824003e4
	if !ctx.cr[6].lt {
	pc = 0x824003E4; continue 'dispatch;
	}
	// 82400368: 56CA103A  slwi r10, r22, 2
	ctx.r[10].u32 = ctx.r[22].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8240036C: 810101AC  lwz r8, 0x1ac(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(428 as u32) ) } as u64;
	// 82400370: C0180000  lfs f0, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400374: 7D76B850  subf r11, r22, r23
	ctx.r[11].s64 = ctx.r[23].s64 - ctx.r[22].s64;
	// 82400378: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 8240037C: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82400380: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82400384: 5527043E  clrlwi r7, r9, 0x10
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 82400388: 7D298670  srawi r9, r9, 0x10
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 16) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 16) as i64;
	// 8240038C: 1CE741A7  mulli r7, r7, 0x41a7
	ctx.r[7].s64 = ctx.r[7].s64 * 16807;
	// 82400390: 1D2941A7  mulli r9, r9, 0x41a7
	ctx.r[9].s64 = ctx.r[9].s64 * 16807;
	// 82400394: 5525805E  rlwinm r5, r9, 0x10, 1, 0xf
	ctx.r[5].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 82400398: 55268BFE  srwi r6, r9, 0xf
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shr(15);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8240039C: 7D272A14  add r9, r7, r5
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[5].u64;
	// 824003A0: 55250FFE  srwi r5, r9, 0x1f
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shr(31);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824003A4: 5527007E  clrlwi r7, r9, 1
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x7FFFFFFFu64;
	// 824003A8: 7D262A14  add r9, r6, r5
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[5].u64;
	// 824003AC: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 824003B0: 55270FFE  srwi r7, r9, 0x1f
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shr(31);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 824003B4: 7D274A14  add r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 824003B8: 5529007E  clrlwi r9, r9, 1
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x7FFFFFFFu64;
	// 824003BC: 7D2707B4  extsw r7, r9
	ctx.r[7].s64 = ctx.r[9].s32 as i64;
	// 824003C0: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824003C4: F8E10078  std r7, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[7].u64 ) };
	// 824003C8: C9A10078  lfd f13, 0x78(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 824003CC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 824003D0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 824003D4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 824003D8: D1AA0000  stfs f13, 0(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824003DC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824003E0: 4082FF9C  bne 0x8240037c
	if !ctx.cr[0].eq {
	pc = 0x8240037C; continue 'dispatch;
	}
	// 824003E4: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 824003E8: 7EE903A6  mtctr r23
	ctx.ctr.u64 = ctx.r[23].u64;
	// 824003EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824003F0: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 824003F4: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824003F8: 40990050  ble cr6, 0x82400448
	if !ctx.cr[6].gt {
	pc = 0x82400448; continue 'dispatch;
	}
	// 824003FC: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82400400: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82400404: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400408: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240040C: ED4A002A  fadds f10, f10, f0
	ctx.f[10].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82400410: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82400414: 4082FFF0  bne 0x82400404
	if !ctx.cr[0].eq {
	pc = 0x82400404; continue 'dispatch;
	}
	// 82400418: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240041C: C00B2808  lfs f0, 0x2808(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400420: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 82400424: 40990008  ble cr6, 0x8240042c
	if !ctx.cr[6].gt {
	pc = 0x8240042C; continue 'dispatch;
	}
	// 82400428: EDA05024  fdivs f13, f0, f10
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 8240042C: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 82400430: 40990018  ble cr6, 0x82400448
	if !ctx.cr[6].gt {
	pc = 0x82400448; continue 'dispatch;
	}
	// 82400434: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400438: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8240043C: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400440: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82400444: 4200FFF0  bdnz 0x82400434
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82400434; continue 'dispatch;
	}
	// 82400448: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 8240044C: FC60C890  fmr f3, f25
	ctx.f[3].f64 = ctx.f[25].f64;
	// 82400450: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82400454: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 82400458: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 8240045C: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 82400460: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 82400464: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 82400468: 38A000A0  li r5, 0xa0
	ctx.r[5].s64 = 160;
	// 8240046C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82400470: 4BFFBB01  bl 0x823fbf70
	ctx.lr = 0x82400474;
	sub_823FBF70(ctx, base);
	// 82400474: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82400478: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 8240047C: 48135BAD  bl 0x82536028
	ctx.lr = 0x82400480;
	sub_82535FFC(ctx, base);
	// 82400480: 48134C64  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82400488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82400488 size=492
    let mut pc: u32 = 0x82400488;
    'dispatch: loop {
        match pc {
            0x82400488 => {
    //   block [0x82400488..0x82400674)
	// 82400488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240048C: 48134C25  bl 0x825350b0
	ctx.lr = 0x82400490;
	sub_82535080(ctx, base);
	// 82400490: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82400494: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82400498: 3921FFB8  addi r9, r1, -0x48
	ctx.r[9].s64 = ctx.r[1].s64 + -72;
	// 8240049C: 3901FFB0  addi r8, r1, -0x50
	ctx.r[8].s64 = ctx.r[1].s64 + -80;
	// 824004A0: C00B7588  lfs f0, 0x7588(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30088 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824004A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824004A8: F941FFB8  std r10, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.r[10].u64 ) };
	// 824004AC: C981FFB8  lfd f12, -0x48(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 824004B0: EC000824  fdivs f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 824004B4: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 824004B8: C1AB72B8  lfs f13, 0x72b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29368 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824004BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824004C0: C0EB1FF8  lfs f7, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 824004C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824004C8: C18BBFFC  lfs f12, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824004CC: EDA0637A  fmadds f13, f0, f13, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 824004D0: FD805818  frsp f12, f11
	ctx.f[12].f64 = (ctx.f[11].f64 as f32) as f64;
	// 824004D4: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 824004D8: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 824004DC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 824004E0: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 824004E4: 7DA047AE  stfiwx f13, 0, r8
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 824004E8: 83A1FFB0  lwz r29, -0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) } as u64;
	// 824004EC: 8361FFB8  lwz r27, -0x48(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) } as u64;
	// 824004F0: 7FBE0E70  srawi r30, r29, 1
	ctx.xer.ca = (ctx.r[29].s32 < 0) && ((ctx.r[29].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[29].s32 >> 1) as i64;
	// 824004F4: 2F1B0001  cmpwi cr6, r27, 1
	ctx.cr[6].compare_i32(ctx.r[27].s32, 1, &mut ctx.xer);
	// 824004F8: 397E4000  addi r11, r30, 0x4000
	ctx.r[11].s64 = ctx.r[30].s64 + 16384;
	// 824004FC: 7D637E70  srawi r3, r11, 0xf
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[11].s32 >> 15) as i64;
	// 82400500: 4198014C  blt cr6, 0x8240064c
	if ctx.cr[6].lt {
	pc = 0x8240064C; continue 'dispatch;
	}
	// 82400504: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82400508: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8240050C: 38E04000  li r7, 0x4000
	ctx.r[7].s64 = 16384;
	// 82400510: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 82400514: 3B8BAC40  addi r28, r11, -0x53c0
	ctx.r[28].s64 = ctx.r[11].s64 + -21440;
	// 82400518: C0CAAFC0  lfs f6, -0x5040(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20544 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 8240051C: 7CE7EA14  add r7, r7, r29
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[29].u64;
	// 82400520: FC003090  fmr f0, f6
	ctx.f[0].f64 = ctx.f[6].f64;
	// 82400524: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82400528: 7D47F214  add r10, r7, r30
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[30].u64;
	// 8240052C: 55662834  slwi r6, r11, 5
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82400530: 7D437E70  srawi r3, r10, 0xf
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[10].s32 >> 15) as i64;
	// 82400534: 7CE87E70  srawi r8, r7, 0xf
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[7].s32 >> 15) as i64;
	// 82400538: 3947C200  addi r10, r7, -0x3e00
	ctx.r[10].s64 = ctx.r[7].s64 + -15872;
	// 8240053C: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82400540: 7D4A5670  srawi r10, r10, 0xa
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 10) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 10) as i64;
	// 82400544: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82400548: 7D4A3050  subf r10, r10, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8240054C: 7CC92214  add r6, r9, r4
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[4].u64;
	// 82400550: 7D28242E  lfsx f9, r8, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82400554: 7D292A14  add r9, r9, r5
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[5].u64;
	// 82400558: 7D082C2E  lfsx f8, r8, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8240055C: 2F0AFF90  cmpwi cr6, r10, -0x70
	ctx.cr[6].compare_i32(ctx.r[10].s32, -112, &mut ctx.xer);
	// 82400560: 41990040  bgt cr6, 0x824005a0
	if ctx.cr[6].gt {
	pc = 0x824005A0; continue 'dispatch;
	}
	// 82400564: 210AFF90  subfic r8, r10, -0x70
	ctx.xer.ca = ctx.r[10].u32 <= -112 as u32;
	ctx.r[8].s64 = (-112 as i64) - ctx.r[10].s64;
	// 82400568: 5508D97E  srwi r8, r8, 5
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(5);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8240056C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82400570: 551F2834  slwi r31, r8, 5
	ctx.r[31].u32 = ctx.r[8].u32.wrapping_shl(5);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82400574: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82400578: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 8240057C: C1860000  lfs f12, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400580: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82400584: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82400588: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8240058C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82400590: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82400594: EDAD637A  fmadds f13, f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82400598: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8240059C: 4082FFE0  bne 0x8240057c
	if !ctx.cr[0].eq {
	pc = 0x8240057C; continue 'dispatch;
	}
	// 824005A0: FD600090  fmr f11, f0
	ctx.f[11].f64 = ctx.f[0].f64;
	// 824005A4: 2F0A0070  cmpwi cr6, r10, 0x70
	ctx.cr[6].compare_i32(ctx.r[10].s32, 112, &mut ctx.xer);
	// 824005A8: 40980060  bge cr6, 0x82400608
	if !ctx.cr[6].lt {
	pc = 0x82400608; continue 'dispatch;
	}
	// 824005AC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824005B0: 391C01C0  addi r8, r28, 0x1c0
	ctx.r[8].s64 = ctx.r[28].s64 + 448;
	// 824005B4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 824005B8: 7F0B1800  cmpw cr6, r11, r3
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[3].s32, &mut ctx.xer);
	// 824005BC: 40980080  bge cr6, 0x8240063c
	if !ctx.cr[6].lt {
	pc = 0x8240063C; continue 'dispatch;
	}
	// 824005C0: C1860000  lfs f12, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824005C4: 391C0380  addi r8, r28, 0x380
	ctx.r[8].s64 = ctx.r[28].s64 + 896;
	// 824005C8: ECAC0332  fmuls f5, f12, f12
	ctx.f[5].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 824005CC: C14A0000  lfs f10, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 824005D0: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824005D4: ED8A627C  fnmsubs f12, f10, f9, f12
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 824005D8: ED4A6A3C  fnmsubs f10, f10, f8, f13
	ctx.f[10].f64 = -(((ctx.f[10].f64 * ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 824005DC: 394A0080  addi r10, r10, 0x80
	ctx.r[10].s64 = ctx.r[10].s64 + 128;
	// 824005E0: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 824005E4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 824005E8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824005EC: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 824005F0: EDAD2B7A  fmadds f13, f13, f13, f5
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[5].f64) as f32) as f64);
	// 824005F4: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 824005F8: EDAC0332  fmuls f13, f12, f12
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 824005FC: EDAA6ABA  fmadds f13, f10, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64);
	// 82400600: ED6D582A  fadds f11, f13, f11
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 82400604: 4198FFB4  blt cr6, 0x824005b8
	if ctx.cr[6].lt {
	pc = 0x824005B8; continue 'dispatch;
	}
	// 82400608: 7F0B1800  cmpw cr6, r11, r3
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[3].s32, &mut ctx.xer);
	// 8240060C: 40980030  bge cr6, 0x8240063c
	if !ctx.cr[6].lt {
	pc = 0x8240063C; continue 'dispatch;
	}
	// 82400610: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 82400614: C1860000  lfs f12, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400618: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240061C: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82400620: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400624: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82400628: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 8240062C: EDAD637A  fmadds f13, f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82400630: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82400634: ED6B682A  fadds f11, f11, f13
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82400638: 4082FFDC  bne 0x82400614
	if !ctx.cr[0].eq {
	pc = 0x82400614; continue 'dispatch;
	}
	// 8240063C: EC0B0024  fdivs f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 82400640: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82400644: ECE0382A  fadds f7, f0, f7
	ctx.f[7].f64 = ((ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64;
	// 82400648: 4082FED4  bne 0x8240051c
	if !ctx.cr[0].eq {
	pc = 0x8240051C; continue 'dispatch;
	}
	// 8240064C: 7F6B07B4  extsw r11, r27
	ctx.r[11].s64 = ctx.r[27].s32 as i64;
	// 82400650: F961FFB8  std r11, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.r[11].u64 ) };
	// 82400654: C801FFB8  lfd f0, -0x48(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82400658: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8240065C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82400660: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82400664: EDA70024  fdivs f13, f7, f0
	ctx.f[13].f64 = ((ctx.f[7].f64 / ctx.f[0].f64) as f32) as f64;
	// 82400668: C00B1850  lfs f0, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240066C: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82400670: 48134A90  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82400678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82400678 size=60
    let mut pc: u32 = 0x82400678;
    'dispatch: loop {
        match pc {
            0x82400678 => {
    //   block [0x82400678..0x824006B4)
	// 82400678: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8240067C: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 82400680: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82400684: C00A7588  lfs f0, 0x7588(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(30088 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400688: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8240068C: ED800824  fdivs f12, f0, f1
	ctx.f[12].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 82400690: C00A317C  lfs f0, 0x317c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12668 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400694: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82400698: C1AABFFC  lfs f13, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8240069C: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 824006A0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 824006A4: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 824006A8: 8061FFF0  lwz r3, -0x10(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 824006AC: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824006B0: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824006B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824006B4 size=8
    let mut pc: u32 = 0x824006B4;
    'dispatch: loop {
        match pc {
            0x824006B4 => {
    //   block [0x824006B4..0x824006BC)
	// 824006B4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824006B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824006C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824006C0 size=292
    let mut pc: u32 = 0x824006C0;
    'dispatch: loop {
        match pc {
            0x824006C0 => {
    //   block [0x824006C0..0x824007E4)
	// 824006C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824006C4: 481349ED  bl 0x825350b0
	ctx.lr = 0x824006C8;
	sub_82535080(ctx, base);
	// 824006C8: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 824006CC: 4813591D  bl 0x82535fe8
	ctx.lr = 0x824006D0;
	sub_82535FB0(ctx, base);
	// 824006D0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824006D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824006D8: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 824006DC: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 824006E0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 824006E4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 824006E8: C3EB2074  lfs f31, 0x2074(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 824006EC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 824006F0: C3C7AFCC  lfs f30, -0x5034(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-20532 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 824006F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824006F8: C388AFC8  lfs f28, -0x5038(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-20536 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 824006FC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82400700: C3A92310  lfs f29, 0x2310(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8976 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82400704: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82400708: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8240070C: 39600049  li r11, 0x49
	ctx.r[11].s64 = 73;
	// 82400710: 3BAA8E38  addi r29, r10, -0x71c8
	ctx.r[29].s64 = ctx.r[10].s64 + -29128;
	// 82400714: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82400718: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8240071C: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 82400720: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82400724: 4BFFD585  bl 0x823fdca8
	ctx.lr = 0x82400728;
	sub_823FDCA8(ctx, base);
	// 82400728: EDBF0772  fmuls f13, f31, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[29].f64) as f32) as f64);
	// 8240072C: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400730: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82400734: 41980098  blt cr6, 0x824007cc
	if ctx.cr[6].lt {
	pc = 0x824007CC; continue 'dispatch;
	}
	// 82400738: EDBF0732  fmuls f13, f31, f28
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[28].f64) as f32) as f64);
	// 8240073C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82400740: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82400744: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82400748: 41980008  blt cr6, 0x82400750
	if ctx.cr[6].lt {
	pc = 0x82400750; continue 'dispatch;
	}
	// 8240074C: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 82400750: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82400754: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 82400758: C19D0000  lfs f12, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8240075C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82400760: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 82400764: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82400768: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8240076C: EC0D07B2  fmuls f0, f13, f30
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 82400770: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82400774: 41980058  blt cr6, 0x824007cc
	if ctx.cr[6].lt {
	pc = 0x824007CC; continue 'dispatch;
	}
	// 82400778: 48000010  b 0x82400788
	pc = 0x82400788; continue 'dispatch;
	// 8240077C: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 82400780: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82400784: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400788: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8240078C: 4199FFF0  bgt cr6, 0x8240077c
	if ctx.cr[6].gt {
	pc = 0x8240077C; continue 'dispatch;
	}
	// 82400790: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82400794: 41980038  blt cr6, 0x824007cc
	if ctx.cr[6].lt {
	pc = 0x824007CC; continue 'dispatch;
	}
	// 82400798: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8240079C: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 824007A0: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824007A4: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824007A8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 824007AC: 40980010  bge cr6, 0x824007bc
	if !ctx.cr[6].lt {
	pc = 0x824007BC; continue 'dispatch;
	}
	// 824007B0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824007B4: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 824007B8: 4080FFE8  bge 0x824007a0
	if !ctx.cr[0].lt {
	pc = 0x824007A0; continue 'dispatch;
	}
	// 824007BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824007C0: 4198000C  blt cr6, 0x824007cc
	if ctx.cr[6].lt {
	pc = 0x824007CC; continue 'dispatch;
	}
	// 824007C4: 2F1F0005  cmpwi cr6, r31, 5
	ctx.cr[6].compare_i32(ctx.r[31].s32, 5, &mut ctx.xer);
	// 824007C8: 4198FF4C  blt cr6, 0x82400714
	if ctx.cr[6].lt {
	pc = 0x82400714; continue 'dispatch;
	}
	// 824007CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824007D0: 937A0000  stw r27, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 824007D4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 824007D8: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 824007DC: 48135859  bl 0x82536034
	ctx.lr = 0x824007E0;
	sub_82535FFC(ctx, base);
	// 824007E0: 48134920  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824007E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824007E8 size=320
    let mut pc: u32 = 0x824007E8;
    'dispatch: loop {
        match pc {
            0x824007E8 => {
    //   block [0x824007E8..0x82400928)
	// 824007E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824007EC: 481348C5  bl 0x825350b0
	ctx.lr = 0x824007F0;
	sub_82535080(ctx, base);
	// 824007F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824007F4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 824007F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824007FC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82400800: 390B8E38  addi r8, r11, -0x71c8
	ctx.r[8].s64 = ctx.r[11].s64 + -29128;
	// 82400804: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82400808: 83DC0000  lwz r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8240080C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82400810: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82400814: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82400818: C00976F4  lfs f0, 0x76f4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(30452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240081C: 835B0000  lwz r26, 0(r27)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82400820: 83EBFFFC  lwz r31, -4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82400824: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82400828: 7D4B4214  add r10, r11, r8
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 8240082C: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400830: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82400834: 419900E4  bgt cr6, 0x82400918
	if ctx.cr[6].gt {
	pc = 0x82400918; continue 'dispatch;
	}
	// 82400838: 7D8B1C2E  lfsx f12, r11, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8240083C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82400840: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82400844: C00BD6C8  lfs f0, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400848: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240084C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82400850: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400854: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82400858: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8240085C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82400860: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82400864: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82400868: 4198FFF0  blt cr6, 0x82400858
	if ctx.cr[6].lt {
	pc = 0x82400858; continue 'dispatch;
	}
	// 8240086C: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82400870: 7D4B1A14  add r10, r11, r3
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82400874: C00AFFFC  lfs f0, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400878: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8240087C: 40980014  bge cr6, 0x82400890
	if !ctx.cr[6].lt {
	pc = 0x82400890; continue 'dispatch;
	}
	// 82400880: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400884: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82400888: 40980008  bge cr6, 0x82400890
	if !ctx.cr[6].lt {
	pc = 0x82400890; continue 'dispatch;
	}
	// 8240088C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82400890: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82400894: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82400898: C00A2940  lfs f0, 0x2940(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10560 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240089C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 824008A0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824008A4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 824008A8: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824008AC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824008B0: 4198FFF0  blt cr6, 0x824008a0
	if ctx.cr[6].lt {
	pc = 0x824008A0; continue 'dispatch;
	}
	// 824008B4: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824008B8: 7C6B1A14  add r3, r11, r3
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 824008BC: C003FFFC  lfs f0, -4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824008C0: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 824008C4: 40980014  bge cr6, 0x824008d8
	if !ctx.cr[6].lt {
	pc = 0x824008D8; continue 'dispatch;
	}
	// 824008C8: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824008CC: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 824008D0: 40980008  bge cr6, 0x824008d8
	if !ctx.cr[6].lt {
	pc = 0x824008D8; continue 'dispatch;
	}
	// 824008D4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 824008D8: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 824008DC: 409A003C  bne cr6, 0x82400918
	if !ctx.cr[6].eq {
	pc = 0x82400918; continue 'dispatch;
	}
	// 824008E0: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 824008E4: 409A0024  bne cr6, 0x82400908
	if !ctx.cr[6].eq {
	pc = 0x82400908; continue 'dispatch;
	}
	// 824008E8: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 824008EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824008F0: 209F004A  subfic r4, r31, 0x4a
	ctx.xer.ca = ctx.r[31].u32 <= 74 as u32;
	ctx.r[4].s64 = (74 as i64) - ctx.r[31].s64;
	// 824008F4: 4BFFD3B5  bl 0x823fdca8
	ctx.lr = 0x824008F8;
	sub_823FDCA8(ctx, base);
	// 824008F8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824008FC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82400900: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82400904: 48000014  b 0x82400918
	pc = 0x82400918; continue 'dispatch;
	// 82400908: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 8240090C: 7F1AF000  cmpw cr6, r26, r30
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82400910: 409A0008  bne cr6, 0x82400918
	if !ctx.cr[6].eq {
	pc = 0x82400918; continue 'dispatch;
	}
	// 82400914: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82400918: 935B0000  stw r26, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 8240091C: 93DC0000  stw r30, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82400920: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82400924: 481347DC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82400928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82400928 size=972
    let mut pc: u32 = 0x82400928;
    'dispatch: loop {
        match pc {
            0x82400928 => {
    //   block [0x82400928..0x82400CF4)
	// 82400928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240092C: 48134759  bl 0x82535084
	ctx.lr = 0x82400930;
	sub_82535080(ctx, base);
	// 82400930: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 82400934: 481356AD  bl 0x82535fe0
	ctx.lr = 0x82400938;
	sub_82535FB0(ctx, base);
	// 82400938: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240093C: 7C912378  mr r17, r4
	ctx.r[17].u64 = ctx.r[4].u64;
	// 82400940: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82400944: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 82400948: FF601090  fmr f27, f2
	ctx.f[27].f64 = ctx.f[2].f64;
	// 8240094C: 7CB02B78  mr r16, r5
	ctx.r[16].u64 = ctx.r[5].u64;
	// 82400950: 7E258B78  mr r5, r17
	ctx.r[5].u64 = ctx.r[17].u64;
	// 82400954: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 82400958: 7CCF3378  mr r15, r6
	ctx.r[15].u64 = ctx.r[6].u64;
	// 8240095C: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82400960: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82400964: 4BFFD2B5  bl 0x823fdc18
	ctx.lr = 0x82400968;
	sub_823FDC18(ctx, base);
	// 82400968: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240096C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82400970: C00B2150  lfs f0, 0x2150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8528 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400974: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82400978: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 8240097C: C00B2934  lfs f0, 0x2934(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10548 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400980: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82400984: 3A6B8E38  addi r19, r11, -0x71c8
	ctx.r[19].s64 = ctx.r[11].s64 + -29128;
	// 82400988: EF406824  fdivs f26, f0, f13
	ctx.f[26].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8240098C: 7E278B78  mr r7, r17
	ctx.r[7].u64 = ctx.r[17].u64;
	// 82400990: 7C3F9C2E  lfsx f1, r31, r19
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[19].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82400994: 7E469378  mr r6, r18
	ctx.r[6].u64 = ctx.r[18].u64;
	// 82400998: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 8240099C: 7DE57B78  mr r5, r15
	ctx.r[5].u64 = ctx.r[15].u64;
	// 824009A0: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 824009A4: 480014F5  bl 0x82401e98
	ctx.lr = 0x824009A8;
	sub_82401E98(ctx, base);
	// 824009A8: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 824009AC: 7C3F5D2E  stfsx f1, r31, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 824009B0: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 824009B4: 2F1F0128  cmpwi cr6, r31, 0x128
	ctx.cr[6].compare_i32(ctx.r[31].s32, 296, &mut ctx.xer);
	// 824009B8: 4198FFD4  blt cr6, 0x8240098c
	if ctx.cr[6].lt {
	pc = 0x8240098C; continue 'dispatch;
	}
	// 824009BC: 39610084  addi r11, r1, 0x84
	ctx.r[11].s64 = ctx.r[1].s64 + 132;
	// 824009C0: 39400025  li r10, 0x25
	ctx.r[10].s64 = 37;
	// 824009C4: C00BFFFC  lfs f0, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824009C8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824009CC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824009D0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 824009D4: 4082FFF0  bne 0x824009c4
	if !ctx.cr[0].eq {
	pc = 0x824009C4; continue 'dispatch;
	}
	// 824009D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824009DC: C00B203C  lfs f0, 0x203c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824009E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824009E4: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 824009E8: C1ABAFC4  lfs f13, -0x503c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20540 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824009EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824009F0: ED9F0372  fmuls f12, f31, f13
	ctx.f[12].f64 = (((ctx.f[31].f64 * ctx.f[13].f64) as f32) as f64);
	// 824009F4: C1B30000  lfs f13, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824009F8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824009FC: 4098001C  bge cr6, 0x82400a18
	if !ctx.cr[6].lt {
	pc = 0x82400A18; continue 'dispatch;
	}
	// 82400A00: 7E6A9B78  mr r10, r19
	ctx.r[10].u64 = ctx.r[19].u64;
	// 82400A04: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82400A08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82400A0C: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400A10: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82400A14: 4198FFF0  blt cr6, 0x82400a04
	if ctx.cr[6].lt {
	pc = 0x82400A04; continue 'dispatch;
	}
	// 82400A18: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82400A1C: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82400A20: 7D755B78  mr r21, r11
	ctx.r[21].u64 = ctx.r[11].u64;
	// 82400A24: 7C0A4C2E  lfsx f0, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400A28: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82400A2C: 7DAA4C2E  lfsx f13, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400A30: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82400A34: 4098000C  bge cr6, 0x82400a40
	if !ctx.cr[6].lt {
	pc = 0x82400A40; continue 'dispatch;
	}
	// 82400A38: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82400A3C: 7D755B78  mr r21, r11
	ctx.r[21].u64 = ctx.r[11].u64;
	// 82400A40: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82400A44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82400A48: 2F0A0128  cmpwi cr6, r10, 0x128
	ctx.cr[6].compare_i32(ctx.r[10].s32, 296, &mut ctx.xer);
	// 82400A4C: 40980010  bge cr6, 0x82400a5c
	if !ctx.cr[6].lt {
	pc = 0x82400A5C; continue 'dispatch;
	}
	// 82400A50: 7DAA9C2E  lfsx f13, r10, r19
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[19].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400A54: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82400A58: 4099FFD0  ble cr6, 0x82400a28
	if !ctx.cr[6].gt {
	pc = 0x82400A28; continue 'dispatch;
	}
	// 82400A5C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82400A60: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82400A64: C38BBFFC  lfs f28, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82400A68: 4099000C  ble cr6, 0x82400a74
	if !ctx.cr[6].gt {
	pc = 0x82400A74; continue 'dispatch;
	}
	// 82400A6C: EC00D82A  fadds f0, f0, f27
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[27].f64) as f32) as f64;
	// 82400A70: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 82400A74: 56BF103A  slwi r31, r21, 2
	ctx.r[31].u32 = ctx.r[21].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82400A78: 3BC10080  addi r30, r1, 0x80
	ctx.r[30].s64 = ctx.r[1].s64 + 128;
	// 82400A7C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82400A80: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82400A84: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82400A88: 7FFFF42E  lfsx f31, r31, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82400A8C: 7C1FF52E  stfsx f0, r31, r30
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32), tmp.u32) };
	// 82400A90: 4BFFFC31  bl 0x824006c0
	ctx.lr = 0x82400A94;
	sub_824006C0(ctx, base);
	// 82400A94: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82400A98: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82400A9C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82400AA0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82400AA4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82400AA8: 4BFFFD41  bl 0x824007e8
	ctx.lr = 0x82400AAC;
	sub_824007E8(ctx, base);
	// 82400AAC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82400AB0: 80E10058  lwz r7, 0x58(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82400AB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82400AB8: 7D775B78  mr r23, r11
	ctx.r[23].u64 = ctx.r[11].u64;
	// 82400ABC: 7CF43B78  mr r20, r7
	ctx.r[20].u64 = ctx.r[7].u64;
	// 82400AC0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82400AC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82400AC8: 40990030  ble cr6, 0x82400af8
	if !ctx.cr[6].gt {
	pc = 0x82400AF8; continue 'dispatch;
	}
	// 82400ACC: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82400AD0: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82400AD4: 7F154000  cmpw cr6, r21, r8
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82400AD8: 409A000C  bne cr6, 0x82400ae4
	if !ctx.cr[6].eq {
	pc = 0x82400AE4; continue 'dispatch;
	}
	// 82400ADC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82400AE0: 7F154000  cmpw cr6, r21, r8
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82400AE4: 41990014  bgt cr6, 0x82400af8
	if ctx.cr[6].gt {
	pc = 0x82400AF8; continue 'dispatch;
	}
	// 82400AE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82400AEC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82400AF0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82400AF4: 4198FFDC  blt cr6, 0x82400ad0
	if ctx.cr[6].lt {
	pc = 0x82400AD0; continue 'dispatch;
	}
	// 82400AF8: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82400AFC: 409A00B4  bne cr6, 0x82400bb0
	if !ctx.cr[6].eq {
	pc = 0x82400BB0; continue 'dispatch;
	}
	// 82400B00: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82400B04: 7C1FF42E  lfsx f0, r31, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400B08: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82400B0C: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 82400B10: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82400B14: 7D29402E  lwzx r9, r9, r8
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82400B18: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82400B1C: 7D89342E  lfsx f12, r9, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400B20: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82400B24: C1A9AFC8  lfs f13, -0x5038(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-20536 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400B28: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82400B2C: 409A0028  bne cr6, 0x82400b54
	if !ctx.cr[6].eq {
	pc = 0x82400B54; continue 'dispatch;
	}
	// 82400B30: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82400B34: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 82400B38: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82400B3C: 7D69442E  lfsx f11, r9, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82400B40: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82400B44: C1892A1C  lfs f12, 0x2a1c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10780 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400B48: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82400B4C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82400B50: 40980014  bge cr6, 0x82400b64
	if !ctx.cr[6].lt {
	pc = 0x82400B64; continue 'dispatch;
	}
	// 82400B54: 7F0A3800  cmpw cr6, r10, r7
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82400B58: 40990058  ble cr6, 0x82400bb0
	if !ctx.cr[6].gt {
	pc = 0x82400BB0; continue 'dispatch;
	}
	// 82400B5C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82400B60: 41980050  blt cr6, 0x82400bb0
	if ctx.cr[6].lt {
	pc = 0x82400BB0; continue 'dispatch;
	}
	// 82400B64: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82400B68: 4099002C  ble cr6, 0x82400b94
	if !ctx.cr[6].gt {
	pc = 0x82400B94; continue 'dispatch;
	}
	// 82400B6C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82400B70: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82400B74: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82400B78: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 82400B7C: 80C9FFFC  lwz r6, -4(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82400B80: 38E9FFFC  addi r7, r9, -4
	ctx.r[7].s64 = ctx.r[9].s64 + -4;
	// 82400B84: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82400B88: 90C90000  stw r6, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82400B8C: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82400B90: 4082FFEC  bne 0x82400b7c
	if !ctx.cr[0].eq {
	pc = 0x82400B7C; continue 'dispatch;
	}
	// 82400B94: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82400B98: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82400B9C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82400BA0: 7EA9412E  stwx r21, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[21].u32) };
	// 82400BA4: 41980008  blt cr6, 0x82400bac
	if ctx.cr[6].lt {
	pc = 0x82400BAC; continue 'dispatch;
	}
	// 82400BA8: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 82400BAC: 3AEB0001  addi r23, r11, 1
	ctx.r[23].s64 = ctx.r[11].s64 + 1;
	// 82400BB0: 7FFFF52E  stfsx f31, r31, r30
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32), tmp.u32) };
	// 82400BB4: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82400BB8: 3AD7FFFF  addi r22, r23, -1
	ctx.r[22].s64 = ctx.r[23].s64 + -1;
	// 82400BBC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82400BC0: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 82400BC4: 4099011C  ble cr6, 0x82400ce0
	if !ctx.cr[6].gt {
	pc = 0x82400CE0; continue 'dispatch;
	}
	// 82400BC8: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 82400BCC: 7F1AE850  subf r24, r26, r29
	ctx.r[24].s64 = ctx.r[29].s64 - ctx.r[26].s64;
	// 82400BD0: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82400BD4: 419A0014  beq cr6, 0x82400be8
	if ctx.cr[6].eq {
	pc = 0x82400BE8; continue 'dispatch;
	}
	// 82400BD8: 7F1CB000  cmpw cr6, r28, r22
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[22].s32, &mut ctx.xer);
	// 82400BDC: 419A000C  beq cr6, 0x82400be8
	if ctx.cr[6].eq {
	pc = 0x82400BE8; continue 'dispatch;
	}
	// 82400BE0: 7F1CA000  cmpw cr6, r28, r20
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[20].s32, &mut ctx.xer);
	// 82400BE4: 409A00EC  bne cr6, 0x82400cd0
	if !ctx.cr[6].eq {
	pc = 0x82400CD0; continue 'dispatch;
	}
	// 82400BE8: 7F1CA000  cmpw cr6, r28, r20
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[20].s32, &mut ctx.xer);
	// 82400BEC: 409A000C  bne cr6, 0x82400bf8
	if !ctx.cr[6].eq {
	pc = 0x82400BF8; continue 'dispatch;
	}
	// 82400BF0: 816102C4  lwz r11, 0x2c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(708 as u32) ) } as u64;
	// 82400BF4: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82400BF8: 83DB0000  lwz r30, 0(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82400BFC: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 82400C00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82400C04: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82400C08: 2C1E0000  cmpwi r30, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82400C0C: 7D2A9A14  add r9, r10, r19
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[19].u64;
	// 82400C10: 7FEA442E  lfsx f31, r10, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82400C14: C3A90000  lfs f29, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82400C18: 40810018  ble 0x82400c30
	if !ctx.cr[0].gt {
	pc = 0x82400C30; continue 'dispatch;
	}
	// 82400C1C: C009FFFC  lfs f0, -4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400C20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82400C24: EC00E82A  fadds f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82400C28: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 82400C2C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82400C30: 395E0001  addi r10, r30, 1
	ctx.r[10].s64 = ctx.r[30].s64 + 1;
	// 82400C34: 2F0A004A  cmpwi cr6, r10, 0x4a
	ctx.cr[6].compare_i32(ctx.r[10].s32, 74, &mut ctx.xer);
	// 82400C38: 40980024  bge cr6, 0x82400c5c
	if !ctx.cr[6].lt {
	pc = 0x82400C5C; continue 'dispatch;
	}
	// 82400C3C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82400C40: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82400C44: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82400C48: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82400C4C: 7C0A9C2E  lfsx f0, r10, r19
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[19].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400C50: EC00E82A  fadds f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82400C54: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 82400C58: 7C09452E  stfsx f0, r9, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 82400C5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82400C60: 40990048  ble cr6, 0x82400ca8
	if !ctx.cr[6].gt {
	pc = 0x82400CA8; continue 'dispatch;
	}
	// 82400C64: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82400C68: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82400C6C: C3DF0000  lfs f30, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82400C70: 7E278B78  mr r7, r17
	ctx.r[7].u64 = ctx.r[17].u64;
	// 82400C74: 7E469378  mr r6, r18
	ctx.r[6].u64 = ctx.r[18].u64;
	// 82400C78: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 82400C7C: 7DE57B78  mr r5, r15
	ctx.r[5].u64 = ctx.r[15].u64;
	// 82400C80: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82400C84: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 82400C88: 48001211  bl 0x82401e98
	ctx.lr = 0x82400C8C;
	sub_82401E98(ctx, base);
	// 82400C8C: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82400C90: 4099000C  ble cr6, 0x82400c9c
	if !ctx.cr[6].gt {
	pc = 0x82400C9C; continue 'dispatch;
	}
	// 82400C94: FFA0F090  fmr f29, f30
	ctx.f[29].f64 = ctx.f[30].f64;
	// 82400C98: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82400C9C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82400CA0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82400CA4: 4082FFC8  bne 0x82400c6c
	if !ctx.cr[0].eq {
	pc = 0x82400C6C; continue 'dispatch;
	}
	// 82400CA8: 7FB8D52E  stfsx f29, r24, r26
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[24].u32.wrapping_add(ctx.r[26].u32), tmp.u32) };
	// 82400CAC: 7F1EA800  cmpw cr6, r30, r21
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[21].s32, &mut ctx.xer);
	// 82400CB0: 409A0014  bne cr6, 0x82400cc4
	if !ctx.cr[6].eq {
	pc = 0x82400CC4; continue 'dispatch;
	}
	// 82400CB4: FF1BF800  fcmpu cr6, f27, f31
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[31].f64);
	// 82400CB8: 4099000C  ble cr6, 0x82400cc4
	if !ctx.cr[6].gt {
	pc = 0x82400CC4; continue 'dispatch;
	}
	// 82400CBC: EC1FD82A  fadds f0, f31, f27
	ctx.f[0].f64 = ((ctx.f[31].f64 + ctx.f[27].f64) as f32) as f64;
	// 82400CC0: EFE00732  fmuls f31, f0, f28
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 82400CC4: D3FA0000  stfs f31, 0(r26)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400CC8: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82400CCC: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82400CD0: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82400CD4: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82400CD8: 7F1CB800  cmpw cr6, r28, r23
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[23].s32, &mut ctx.xer);
	// 82400CDC: 4198FEF4  blt cr6, 0x82400bd0
	if ctx.cr[6].lt {
	pc = 0x82400BD0; continue 'dispatch;
	}
	// 82400CE0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82400CE4: 38210270  addi r1, r1, 0x270
	ctx.r[1].s64 = ctx.r[1].s64 + 624;
	// 82400CE8: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 82400CEC: 48135341  bl 0x8253602c
	ctx.lr = 0x82400CF0;
	sub_82535FFC(ctx, base);
	// 82400CF0: 481343E4  b 0x825350d4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82400CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82400CF8 size=88
    let mut pc: u32 = 0x82400CF8;
    'dispatch: loop {
        match pc {
            0x82400CF8 => {
    //   block [0x82400CF8..0x82400D50)
	// 82400CF8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82400CFC: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400D00: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82400D04: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400D08: ED6D002A  fadds f11, f13, f0
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82400D0C: D1630000  stfs f11, 0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400D10: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82400D14: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 82400D18: 39040004  addi r8, r4, 4
	ctx.r[8].s64 = ctx.r[4].s64 + 4;
	// 82400D1C: C18A1FF8  lfs f12, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400D20: 7D4B1A14  add r10, r11, r3
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82400D24: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82400D28: D1840000  stfs f12, 0(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400D2C: 2F050100  cmpwi cr6, r5, 0x100
	ctx.cr[6].compare_i32(ctx.r[5].s32, 256, &mut ctx.xer);
	// 82400D30: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82400D34: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400D38: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 82400D3C: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400D40: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 82400D44: 409A000C  bne cr6, 0x82400d50
	if !ctx.cr[6].eq {
		sub_82400D50(ctx, base);
		return;
	}
	// 82400D48: 38C7AFD0  addi r6, r7, -0x5030
	ctx.r[6].s64 = ctx.r[7].s64 + -20528;
	// 82400D4C: 4800000C  b 0x82400d58
	sub_82400D50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82400D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82400D50 size=200
    let mut pc: u32 = 0x82400D50;
    'dispatch: loop {
        match pc {
            0x82400D50 => {
    //   block [0x82400D50..0x82400E18)
	// 82400D50: 38E7AFD0  addi r7, r7, -0x5030
	ctx.r[7].s64 = ctx.r[7].s64 + -20528;
	// 82400D54: 38C703F8  addi r6, r7, 0x3f8
	ctx.r[6].s64 = ctx.r[7].s64 + 1016;
	// 82400D58: 7CA70E70  srawi r7, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 82400D5C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82400D60: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 82400D64: 409900A0  ble cr6, 0x82400e04
	if !ctx.cr[6].gt {
	pc = 0x82400E04; continue 'dispatch;
	}
	// 82400D68: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 82400D6C: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 82400D70: 38670001  addi r3, r7, 1
	ctx.r[3].s64 = ctx.r[7].s64 + 1;
	// 82400D74: C005BFFC  lfs f0, -0x4004(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400D78: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400D7C: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82400D80: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82400D84: ECCA602A  fadds f6, f10, f12
	ctx.f[6].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 82400D88: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400D8C: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82400D90: ED4C5028  fsubs f10, f12, f10
	ctx.f[10].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82400D94: ECED5828  fsubs f7, f13, f11
	ctx.f[7].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82400D98: C1260000  lfs f9, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82400D9C: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82400DA0: ECAB682A  fadds f5, f11, f13
	ctx.f[5].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82400DA4: C1060000  lfs f8, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82400DA8: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82400DAC: ED860032  fmuls f12, f6, f0
	ctx.f[12].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82400DB0: ED6A0032  fmuls f11, f10, f0
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82400DB4: EDA70032  fmuls f13, f7, f0
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82400DB8: ED450032  fmuls f10, f5, f0
	ctx.f[10].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82400DBC: ECEC0232  fmuls f7, f12, f8
	ctx.f[7].f64 = (((ctx.f[12].f64 * ctx.f[8].f64) as f32) as f64);
	// 82400DC0: ED0D0232  fmuls f8, f13, f8
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[8].f64) as f32) as f64);
	// 82400DC4: EDAD3A78  fmsubs f13, f13, f9, f7
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[9].f64 - ctx.f[7].f64) as f32) as f64);
	// 82400DC8: ED8C427A  fmadds f12, f12, f9, f8
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[9].f64 + ctx.f[8].f64) as f32) as f64);
	// 82400DCC: ED2D582A  fadds f9, f13, f11
	ctx.f[9].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 82400DD0: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82400DD4: D1A80000  stfs f13, 0(r8)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400DD8: EDAC502A  fadds f13, f12, f10
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[10].f64) as f32) as f64;
	// 82400DDC: D1A90000  stfs f13, 0(r9)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400DE0: EDAA6028  fsubs f13, f10, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82400DE4: D1AA0000  stfs f13, 0(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400DE8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82400DEC: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 82400DF0: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82400DF4: FDA04850  fneg f13, f9
	ctx.f[13].u64 = ctx.f[9].u64 ^ 0x8000_0000_0000_0000u64;
	// 82400DF8: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400DFC: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 82400E00: 4082FF78  bne 0x82400d78
	if !ctx.cr[0].eq {
	pc = 0x82400D78; continue 'dispatch;
	}
	// 82400E04: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82400E08: 7C0B242E  lfsx f0, r11, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400E0C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82400E10: 7C0B252E  stfsx f0, r11, r4
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), tmp.u32) };
	// 82400E14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82400E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82400E18 size=292
    let mut pc: u32 = 0x82400E18;
    'dispatch: loop {
        match pc {
            0x82400E18 => {
    //   block [0x82400E18..0x82400F3C)
	// 82400E18: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82400E1C: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82400E20: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400E24: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400E28: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 82400E2C: 7D4B1A14  add r10, r11, r3
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82400E30: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82400E34: 39040004  addi r8, r4, 4
	ctx.r[8].s64 = ctx.r[4].s64 + 4;
	// 82400E38: 38EBFFFC  addi r7, r11, -4
	ctx.r[7].s64 = ctx.r[11].s64 + -4;
	// 82400E3C: 2F050100  cmpwi cr6, r5, 0x100
	ctx.cr[6].compare_i32(ctx.r[5].s32, 256, &mut ctx.xer);
	// 82400E40: C18A0000  lfs f12, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400E44: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 82400E48: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82400E4C: ED4C002A  fadds f10, f12, f0
	ctx.f[10].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82400E50: ED2B682A  fadds f9, f11, f13
	ctx.f[9].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82400E54: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82400E58: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82400E5C: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82400E60: ED8A4828  fsubs f12, f10, f9
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 82400E64: D1830000  stfs f12, 0(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400E68: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82400E6C: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400E70: 409A000C  bne cr6, 0x82400e7c
	if !ctx.cr[6].eq {
	pc = 0x82400E7C; continue 'dispatch;
	}
	// 82400E74: 3BEBAFD0  addi r31, r11, -0x5030
	ctx.r[31].s64 = ctx.r[11].s64 + -20528;
	// 82400E78: 4800000C  b 0x82400e84
	pc = 0x82400E84; continue 'dispatch;
	// 82400E7C: 396BAFD0  addi r11, r11, -0x5030
	ctx.r[11].s64 = ctx.r[11].s64 + -20528;
	// 82400E80: 3BEB03F8  addi r31, r11, 0x3f8
	ctx.r[31].s64 = ctx.r[11].s64 + 1016;
	// 82400E84: 7CA60E70  srawi r6, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 82400E88: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 82400E8C: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82400E90: 2F060001  cmpwi cr6, r6, 1
	ctx.cr[6].compare_i32(ctx.r[6].s32, 1, &mut ctx.xer);
	// 82400E94: C0052068  lfs f0, 0x2068(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400E98: 7DAB1C2E  lfsx f13, r11, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400E9C: 7D8B242E  lfsx f12, r11, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400EA0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82400EA4: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82400EA8: 7DAB1D2E  stfsx f13, r11, r3
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), tmp.u32) };
	// 82400EAC: 7C0B252E  stfsx f0, r11, r4
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), tmp.u32) };
	// 82400EB0: 40990084  ble cr6, 0x82400f34
	if !ctx.cr[6].gt {
	pc = 0x82400F34; continue 'dispatch;
	}
	// 82400EB4: 3966FFFF  addi r11, r6, -1
	ctx.r[11].s64 = ctx.r[6].s64 + -1;
	// 82400EB8: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82400EBC: 38DF0004  addi r6, r31, 4
	ctx.r[6].s64 = ctx.r[31].s64 + 4;
	// 82400EC0: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400EC4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82400EC8: ED0D5828  fsubs f8, f13, f11
	ctx.f[8].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82400ECC: C1470000  lfs f10, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82400ED0: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400ED4: EDAB682A  fadds f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82400ED8: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400EDC: ECEA602A  fadds f7, f10, f12
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 82400EE0: C1260000  lfs f9, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82400EE4: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82400EE8: 3BE60004  addi r31, r6, 4
	ctx.r[31].s64 = ctx.r[6].s64 + 4;
	// 82400EEC: ED600232  fmuls f11, f0, f8
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[8].f64) as f32) as f64);
	// 82400EF0: ED490232  fmuls f10, f9, f8
	ctx.f[10].f64 = (((ctx.f[9].f64 * ctx.f[8].f64) as f32) as f64);
	// 82400EF4: ED6959FA  fmadds f11, f9, f7, f11
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[7].f64 + ctx.f[11].f64) as f32) as f64);
	// 82400EF8: EC0051F8  fmsubs f0, f0, f7, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[7].f64 - ctx.f[10].f64) as f32) as f64);
	// 82400EFC: ED4C5828  fsubs f10, f12, f11
	ctx.f[10].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82400F00: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82400F04: D1880000  stfs f12, 0(r8)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400F08: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82400F0C: D1890000  stfs f12, 0(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400F10: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82400F14: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400F18: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82400F1C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82400F20: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 82400F24: FC005050  fneg f0, f10
	ctx.f[0].u64 = ctx.f[10].u64 ^ 0x8000_0000_0000_0000u64;
	// 82400F28: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400F2C: 38E7FFFC  addi r7, r7, -4
	ctx.r[7].s64 = ctx.r[7].s64 + -4;
	// 82400F30: 4082FF88  bne 0x82400eb8
	if !ctx.cr[0].eq {
	pc = 0x82400EB8; continue 'dispatch;
	}
	// 82400F34: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82400F38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82400F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82400F40 size=760
    let mut pc: u32 = 0x82400F40;
    'dispatch: loop {
        match pc {
            0x82400F40 => {
    //   block [0x82400F40..0x82401238)
	// 82400F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82400F44: 48134155  bl 0x82535098
	ctx.lr = 0x82400F48;
	sub_82535080(ctx, base);
	// 82400F48: DBC1FF88  stfd f30, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[30].u64 ) };
	// 82400F4C: DBE1FF90  stfd f31, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 82400F50: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82400F54: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82400F58: 396BB4C0  addi r11, r11, -0x4b40
	ctx.r[11].s64 = ctx.r[11].s64 + -19264;
	// 82400F5C: 2F050100  cmpwi cr6, r5, 0x100
	ctx.cr[6].compare_i32(ctx.r[5].s32, 256, &mut ctx.xer);
	// 82400F60: 3BEB0600  addi r31, r11, 0x600
	ctx.r[31].s64 = ctx.r[11].s64 + 1536;
	// 82400F64: 419A0008  beq cr6, 0x82400f6c
	if ctx.cr[6].eq {
	pc = 0x82400F6C; continue 'dispatch;
	}
	// 82400F68: 3BEB0780  addi r31, r11, 0x780
	ctx.r[31].s64 = ctx.r[11].s64 + 1920;
	// 82400F6C: 7CAB2670  srawi r11, r5, 4
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[5].s32 >> 4) as i64;
	// 82400F70: 1E8B0060  mulli r20, r11, 0x60
	ctx.r[20].s64 = ctx.r[11].s64 * 96;
	// 82400F74: 57AB2036  slwi r11, r29, 4
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82400F78: 7CBB1670  srawi r27, r5, 2
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[5].s32 >> 2) as i64;
	// 82400F7C: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 82400F80: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82400F84: 7D6BD9D6  mullw r11, r11, r27
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[27].s32 as i64);
	// 82400F88: 7D4B1A14  add r10, r11, r3
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82400F8C: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82400F90: 3B8AFFF0  addi r28, r10, -0x10
	ctx.r[28].s64 = ctx.r[10].s64 + -16;
	// 82400F94: 394BFFF0  addi r10, r11, -0x10
	ctx.r[10].s64 = ctx.r[11].s64 + -16;
	// 82400F98: 4099014C  ble cr6, 0x824010e4
	if !ctx.cr[6].gt {
	pc = 0x824010E4; continue 'dispatch;
	}
	// 82400F9C: 3ABBFFFC  addi r21, r27, -4
	ctx.r[21].s64 = ctx.r[27].s64 + -4;
	// 82400FA0: 1F1B000C  mulli r24, r27, 0xc
	ctx.r[24].s64 = ctx.r[27].s64 * 12;
	// 82400FA4: 7FB6EB78  mr r22, r29
	ctx.r[22].u64 = ctx.r[29].u64;
	// 82400FA8: 7FF4F850  subf r31, r20, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[20].s64;
	// 82400FAC: 2F150000  cmpwi cr6, r21, 0
	ctx.cr[6].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 82400FB0: 41980124  blt cr6, 0x824010d4
	if ctx.cr[6].lt {
	pc = 0x824010D4; continue 'dispatch;
	}
	// 82400FB4: 39750004  addi r11, r21, 4
	ctx.r[11].s64 = ctx.r[21].s64 + 4;
	// 82400FB8: 577A1838  slwi r26, r27, 3
	ctx.r[26].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 82400FBC: 5779103A  slwi r25, r27, 2
	ctx.r[25].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 82400FC0: 5577F0BE  srwi r23, r11, 2
	ctx.r[23].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[23].u64 = ctx.r[23].u32 as u64;
	// 82400FC4: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82400FC8: 7CD85214  add r6, r24, r10
	ctx.r[6].u64 = ctx.r[24].u64 + ctx.r[10].u64;
	// 82400FCC: 7CFA5214  add r7, r26, r10
	ctx.r[7].u64 = ctx.r[26].u64 + ctx.r[10].u64;
	// 82400FD0: 7D195214  add r8, r25, r10
	ctx.r[8].u64 = ctx.r[25].u64 + ctx.r[10].u64;
	// 82400FD4: 7D6AE050  subf r11, r10, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[10].s64;
	// 82400FD8: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 82400FDC: 7D8B3C2E  lfsx f12, r11, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400FE0: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82400FE4: 7D6B342E  lfsx f11, r11, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82400FE8: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400FEC: 7DAB442E  lfsx f13, r11, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400FF0: EFEC002A  fadds f31, f12, f0
	ctx.f[31].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82400FF4: C1070000  lfs f8, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82400FF8: EFCB682A  fadds f30, f11, f13
	ctx.f[30].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82400FFC: C0E60000  lfs f7, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82401000: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82401004: C1490000  lfs f10, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82401008: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 8240100C: C1280000  lfs f9, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82401010: ED88502A  fadds f12, f8, f10
	ctx.f[12].f64 = ((ctx.f[8].f64 + ctx.f[10].f64) as f32) as f64;
	// 82401014: ED67482A  fadds f11, f7, f9
	ctx.f[11].f64 = ((ctx.f[7].f64 + ctx.f[9].f64) as f32) as f64;
	// 82401018: C0BF0010  lfs f5, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 8240101C: ED4A4028  fsubs f10, f10, f8
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[8].f64) as f32) as f64);
	// 82401020: C0DF0000  lfs f6, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82401024: ED293828  fsubs f9, f9, f7
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[7].f64) as f32) as f64);
	// 82401028: C07F0030  lfs f3, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8240102C: C09F0020  lfs f4, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82401030: C03F0050  lfs f1, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82401034: C05F0040  lfs f2, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82401038: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 8240103C: ECFEF82A  fadds f7, f30, f31
	ctx.f[7].f64 = ((ctx.f[30].f64 + ctx.f[31].f64) as f32) as f64;
	// 82401040: 7CEB4D2E  stfsx f7, r11, r9
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82401044: ED1FF028  fsubs f8, f31, f30
	ctx.f[8].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 82401048: ECEC5828  fsubs f7, f12, f11
	ctx.f[7].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 8240104C: EFEA6828  fsubs f31, f10, f13
	ctx.f[31].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82401050: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82401054: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82401058: D1890000  stfs f12, 0(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8240105C: EFC9002A  fadds f30, f9, f0
	ctx.f[30].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82401060: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82401064: EC004828  fsubs f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[9].f64) as f32) as f64);
	// 82401068: ED870172  fmuls f12, f7, f5
	ctx.f[12].f64 = (((ctx.f[7].f64 * ctx.f[5].f64) as f32) as f64);
	// 8240106C: ED6701B2  fmuls f11, f7, f6
	ctx.f[11].f64 = (((ctx.f[7].f64 * ctx.f[6].f64) as f32) as f64);
	// 82401070: ED5F00F2  fmuls f10, f31, f3
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[3].f64) as f32) as f64);
	// 82401074: ED3F0132  fmuls f9, f31, f4
	ctx.f[9].f64 = (((ctx.f[31].f64 * ctx.f[4].f64) as f32) as f64);
	// 82401078: ECED0072  fmuls f7, f13, f1
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[1].f64) as f32) as f64);
	// 8240107C: EDAD00B2  fmuls f13, f13, f2
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[2].f64) as f32) as f64);
	// 82401080: ED8861B8  fmsubs f12, f8, f6, f12
	ctx.f[12].f64 = (((ctx.f[8].f64 * ctx.f[6].f64 - ctx.f[12].f64) as f32) as f64);
	// 82401084: 7D8B452E  stfsx f12, r11, r8
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 82401088: ED88597A  fmadds f12, f8, f5, f11
	ctx.f[12].f64 = (((ctx.f[8].f64 * ctx.f[5].f64 + ctx.f[11].f64) as f32) as f64);
	// 8240108C: D1880000  stfs f12, 0(r8)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401090: ED9E5138  fmsubs f12, f30, f4, f10
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[4].f64 - ctx.f[10].f64) as f32) as f64);
	// 82401094: 7D8B3D2E  stfsx f12, r11, r7
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 82401098: ED9E48FA  fmadds f12, f30, f3, f9
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[3].f64 + ctx.f[9].f64) as f32) as f64);
	// 8240109C: D1870000  stfs f12, 0(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824010A0: ED8038B8  fmsubs f12, f0, f2, f7
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[2].f64 - ctx.f[7].f64) as f32) as f64);
	// 824010A4: 7D8B352E  stfsx f12, r11, r6
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 824010A8: EC00687A  fmadds f0, f0, f1, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64 + ctx.f[13].f64) as f32) as f64);
	// 824010AC: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824010B0: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 824010B4: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 824010B8: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 824010BC: 4082FF20  bne 0x82400fdc
	if !ctx.cr[0].eq {
	pc = 0x82400FDC; continue 'dispatch;
	}
	// 824010C0: 36F7FFFF  addic. r23, r23, -1
	ctx.xer.ca = (ctx.r[23].u32 > (!(-1 as u32)));
	ctx.r[23].s64 = ctx.r[23].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 824010C4: 3B9CFFF0  addi r28, r28, -0x10
	ctx.r[28].s64 = ctx.r[28].s64 + -16;
	// 824010C8: 394AFFF0  addi r10, r10, -0x10
	ctx.r[10].s64 = ctx.r[10].s64 + -16;
	// 824010CC: 3BFF0050  addi r31, r31, 0x50
	ctx.r[31].s64 = ctx.r[31].s64 + 80;
	// 824010D0: 4082FEF4  bne 0x82400fc4
	if !ctx.cr[0].eq {
	pc = 0x82400FC4; continue 'dispatch;
	}
	// 824010D4: 36D6FFFF  addic. r22, r22, -1
	ctx.xer.ca = (ctx.r[22].u32 > (!(-1 as u32)));
	ctx.r[22].s64 = ctx.r[22].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 824010D8: 7F98E050  subf r28, r24, r28
	ctx.r[28].s64 = ctx.r[28].s64 - ctx.r[24].s64;
	// 824010DC: 7D585050  subf r10, r24, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[24].s64;
	// 824010E0: 4082FEC8  bne 0x82400fa8
	if !ctx.cr[0].eq {
	pc = 0x82400FA8; continue 'dispatch;
	}
	// 824010E4: 7CAB1670  srawi r11, r5, 2
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[5].s32 >> 2) as i64;
	// 824010E8: 57BD103A  slwi r29, r29, 2
	ctx.r[29].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824010EC: 7CAB0194  addze r5, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[5].s64 = tmp.s64;
	// 824010F0: 7CAB2670  srawi r11, r5, 4
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[5].s32 >> 4) as i64;
	// 824010F4: 2F050004  cmpwi cr6, r5, 4
	ctx.cr[6].compare_i32(ctx.r[5].s32, 4, &mut ctx.xer);
	// 824010F8: 1E8B0060  mulli r20, r11, 0x60
	ctx.r[20].s64 = ctx.r[11].s64 * 96;
	// 824010FC: 7FF4FA14  add r31, r20, r31
	ctx.r[31].u64 = ctx.r[20].u64 + ctx.r[31].u64;
	// 82401100: 4199FE74  bgt cr6, 0x82400f74
	if ctx.cr[6].gt {
	pc = 0x82400F74; continue 'dispatch;
	}
	// 82401104: 57AB2036  slwi r11, r29, 4
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82401108: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8240110C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82401110: 394BFFF0  addi r10, r11, -0x10
	ctx.r[10].s64 = ctx.r[11].s64 + -16;
	// 82401114: 409900A8  ble cr6, 0x824011bc
	if !ctx.cr[6].gt {
	pc = 0x824011BC; continue 'dispatch;
	}
	// 82401118: 7D635050  subf r11, r3, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	// 8240111C: 7D041850  subf r8, r4, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	// 82401120: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82401124: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82401128: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8240112C: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82401130: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82401134: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401138: ECCC002A  fadds f6, f12, f0
	ctx.f[6].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 8240113C: C16A000C  lfs f11, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82401140: 7DA85C2E  lfsx f13, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401144: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82401148: C10B0004  lfs f8, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8240114C: ED8B682A  fadds f12, f11, f13
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82401150: C14BFFFC  lfs f10, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82401154: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82401158: ED68502A  fadds f11, f8, f10
	ctx.f[11].f64 = ((ctx.f[8].f64 + ctx.f[10].f64) as f32) as f64;
	// 8240115C: C0EB0008  lfs f7, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82401160: C12B0000  lfs f9, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82401164: ED4A4028  fsubs f10, f10, f8
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[8].f64) as f32) as f64);
	// 82401168: ED07482A  fadds f8, f7, f9
	ctx.f[8].f64 = ((ctx.f[7].f64 + ctx.f[9].f64) as f32) as f64;
	// 8240116C: ED293828  fsubs f9, f9, f7
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[7].f64) as f32) as f64);
	// 82401170: ECEC302A  fadds f7, f12, f6
	ctx.f[7].f64 = ((ctx.f[12].f64 + ctx.f[6].f64) as f32) as f64;
	// 82401174: D0EA0000  stfs f7, 0(r10)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401178: ED866028  fsubs f12, f6, f12
	ctx.f[12].f64 = (((ctx.f[6].f64 - ctx.f[12].f64) as f32) as f64);
	// 8240117C: 7D885D2E  stfsx f12, r8, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82401180: ED8A6828  fsubs f12, f10, f13
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82401184: D18B0004  stfs f12, 4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82401188: ED88582A  fadds f12, f8, f11
	ctx.f[12].f64 = ((ctx.f[8].f64 + ctx.f[11].f64) as f32) as f64;
	// 8240118C: D18BFFFC  stfs f12, -4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82401190: ED89002A  fadds f12, f9, f0
	ctx.f[12].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82401194: D18A0008  stfs f12, 8(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82401198: EC004828  fsubs f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[9].f64) as f32) as f64);
	// 8240119C: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 824011A0: ED8B4028  fsubs f12, f11, f8
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[8].f64) as f32) as f64);
	// 824011A4: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824011A8: EC0A682A  fadds f0, f10, f13
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 824011AC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 824011B0: 394AFFF0  addi r10, r10, -0x10
	ctx.r[10].s64 = ctx.r[10].s64 + -16;
	// 824011B4: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 824011B8: 4082FF74  bne 0x8240112c
	if !ctx.cr[0].eq {
	pc = 0x8240112C; continue 'dispatch;
	}
	// 824011BC: 57A6103A  slwi r6, r29, 2
	ctx.r[6].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 824011C0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 824011C4: 38A6FFFF  addi r5, r6, -1
	ctx.r[5].s64 = ctx.r[6].s64 + -1;
	// 824011C8: 7CC90E70  srawi r9, r6, 1
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[6].s32 >> 1) as i64;
	// 824011CC: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 824011D0: 4099005C  ble cr6, 0x8240122c
	if !ctx.cr[6].gt {
	pc = 0x8240122C; continue 'dispatch;
	}
	// 824011D4: 39440004  addi r10, r4, 4
	ctx.r[10].s64 = ctx.r[4].s64 + 4;
	// 824011D8: 7D041850  subf r8, r4, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	// 824011DC: 7F074800  cmpw cr6, r7, r9
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824011E0: 40990028  ble cr6, 0x82401208
	if !ctx.cr[6].gt {
	pc = 0x82401208; continue 'dispatch;
	}
	// 824011E4: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824011E8: 7C0A442E  lfsx f0, r10, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824011EC: 7DAB1C2E  lfsx f13, r11, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824011F0: 7DAA452E  stfsx f13, r10, r8
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 824011F4: 7C0B1D2E  stfsx f0, r11, r3
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), tmp.u32) };
	// 824011F8: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824011FC: 7DAB242E  lfsx f13, r11, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401200: D1AA0000  stfs f13, 0(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401204: 7C0B252E  stfsx f0, r11, r4
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), tmp.u32) };
	// 82401208: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8240120C: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82401210: 7D694A78  xor r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82401214: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82401218: 4198FFF4  blt cr6, 0x8240120c
	if ctx.cr[6].lt {
	pc = 0x8240120C; continue 'dispatch;
	}
	// 8240121C: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82401220: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82401224: 7F072800  cmpw cr6, r7, r5
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82401228: 4198FFB4  blt cr6, 0x824011dc
	if ctx.cr[6].lt {
	pc = 0x824011DC; continue 'dispatch;
	}
	// 8240122C: CBC1FF88  lfd f30, -0x78(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 82401230: CBE1FF90  lfd f31, -0x70(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 82401234: 48133EB4  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82401238 size=600
    let mut pc: u32 = 0x82401238;
    'dispatch: loop {
        match pc {
            0x82401238 => {
    //   block [0x82401238..0x82401490)
	// 82401238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240123C: 48133E79  bl 0x825350b4
	ctx.lr = 0x82401240;
	sub_82535080(ctx, base);
	// 82401240: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82401244: 48134DA1  bl 0x82535fe4
	ctx.lr = 0x82401248;
	sub_82535FB0(ctx, base);
	// 82401248: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240124C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401250: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 82401254: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82401258: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8240125C: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82401260: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 82401264: C36BBFFC  lfs f27, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82401268: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 8240126C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82401270: 40990044  ble cr6, 0x824012b4
	if !ctx.cr[6].gt {
	pc = 0x824012B4; continue 'dispatch;
	}
	// 82401274: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 82401278: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8240127C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82401280: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82401284: 7D2A2850  subf r9, r10, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82401288: C1A72238  lfs f13, 0x2238(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8760 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8240128C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82401290: C00827E4  lfs f0, 0x27e4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(10212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401294: 7D895C2E  lfsx f12, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82401298: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8240129C: ED8C683A  fmadds f12, f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 824012A0: ED8CD82A  fadds f12, f12, f27
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[27].f64) as f32) as f64;
	// 824012A4: FD80601E  fctiwz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 824012A8: 7D805FAE  stfiwx f12, 0, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 824012AC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824012B0: 4082FFE4  bne 0x82401294
	if !ctx.cr[0].eq {
	pc = 0x82401294; continue 'dispatch;
	}
	// 824012B4: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 824012B8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 824012BC: 4BFFC435  bl 0x823fd6f0
	ctx.lr = 0x824012C0;
	sub_823FD6F0(ctx, base);
	// 824012C0: 81210068  lwz r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 824012C4: D3810060  stfs f28, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 824012C8: 80E1006C  lwz r7, 0x6c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 824012CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824012D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824012D4: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 824012D8: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824012DC: EC1C0028  fsubs f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 824012E0: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 824012E4: 4099006C  ble cr6, 0x82401350
	if !ctx.cr[6].gt {
	pc = 0x82401350; continue 'dispatch;
	}
	// 824012E8: 39090004  addi r8, r9, 4
	ctx.r[8].s64 = ctx.r[9].s64 + 4;
	// 824012EC: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824012F0: EC1C0028  fsubs f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 824012F4: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 824012F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 824012FC: 4098000C  bge cr6, 0x82401308
	if !ctx.cr[6].lt {
	pc = 0x82401308; continue 'dispatch;
	}
	// 82401300: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82401304: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82401308: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8240130C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82401310: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82401314: 4198FFD8  blt cr6, 0x824012ec
	if ctx.cr[6].lt {
	pc = 0x824012EC; continue 'dispatch;
	}
	// 82401318: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 8240131C: 41980034  blt cr6, 0x82401350
	if ctx.cr[6].lt {
	pc = 0x82401350; continue 'dispatch;
	}
	// 82401320: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82401324: 3907FFFF  addi r8, r7, -1
	ctx.r[8].s64 = ctx.r[7].s64 + -1;
	// 82401328: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 8240132C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82401330: C00BFFFC  lfs f0, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401334: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401338: EFED0028  fsubs f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8240133C: 40980028  bge cr6, 0x82401364
	if !ctx.cr[6].lt {
	pc = 0x82401364; continue 'dispatch;
	}
	// 82401340: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401344: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82401348: EFE006F2  fmuls f31, f0, f27
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 8240134C: 48000018  b 0x82401364
	pc = 0x82401364; continue 'dispatch;
	// 82401350: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82401354: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82401358: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240135C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401360: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82401364: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401368: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8240136C: C3ABBCA0  lfs f29, -0x4360(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17248 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82401370: 40990020  ble cr6, 0x82401390
	if !ctx.cr[6].gt {
	pc = 0x82401390; continue 'dispatch;
	}
	// 82401374: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82401378: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 8240137C: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401380: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82401384: EFBD002A  fadds f29, f29, f0
	ctx.f[29].f64 = ((ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64;
	// 82401388: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8240138C: 4082FFF0  bne 0x8240137c
	if !ctx.cr[0].eq {
	pc = 0x8240137C; continue 'dispatch;
	}
	// 82401390: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401394: C00B203C  lfs f0, 0x203c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401398: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240139C: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 824013A0: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824013A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824013A8: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 824013AC: C1AB2418  lfs f13, 0x2418(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824013B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824013B4: EC5C0028  fsubs f2, f28, f0
	ctx.f[2].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 824013B8: EC3F0372  fmuls f1, f31, f13
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[13].f64) as f32) as f64);
	// 824013BC: C3CB1848  lfs f30, 0x1848(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 824013C0: FF02F000  fcmpu cr6, f2, f30
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[30].f64);
	// 824013C4: 40980008  bge cr6, 0x824013cc
	if !ctx.cr[6].lt {
	pc = 0x824013CC; continue 'dispatch;
	}
	// 824013C8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 824013CC: EC60E02A  fadds f3, f0, f28
	ctx.f[3].f64 = ((ctx.f[0].f64 + ctx.f[28].f64) as f32) as f64;
	// 824013D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824013D4: C38B2ECC  lfs f28, 0x2ecc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11980 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 824013D8: FF03E000  fcmpu cr6, f3, f28
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[28].f64);
	// 824013DC: 40990008  ble cr6, 0x824013e4
	if !ctx.cr[6].gt {
	pc = 0x824013E4; continue 'dispatch;
	}
	// 824013E0: FC60E090  fmr f3, f28
	ctx.f[3].f64 = ctx.f[28].f64;
	// 824013E4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 824013E8: FC80E890  fmr f4, f29
	ctx.f[4].f64 = ctx.f[29].f64;
	// 824013EC: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 824013F0: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 824013F4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 824013F8: 38C10064  addi r6, r1, 0x64
	ctx.r[6].s64 = ctx.r[1].s64 + 100;
	// 824013FC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82401400: 48000BF9  bl 0x82401ff8
	ctx.lr = 0x82401404;
	sub_82401FF8(ctx, base);
	// 82401404: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401408: C00B2038  lfs f0, 0x2038(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240140C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401410: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82401414: C1AB2144  lfs f13, 0x2144(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401418: EC3F0372  fmuls f1, f31, f13
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[13].f64) as f32) as f64);
	// 8240141C: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401420: EC4D0028  fsubs f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82401424: FF02F000  fcmpu cr6, f2, f30
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[30].f64);
	// 82401428: 40980008  bge cr6, 0x82401430
	if !ctx.cr[6].lt {
	pc = 0x82401430; continue 'dispatch;
	}
	// 8240142C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82401430: EC60682A  fadds f3, f0, f13
	ctx.f[3].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82401434: FF03E000  fcmpu cr6, f3, f28
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[28].f64);
	// 82401438: 40990008  ble cr6, 0x82401440
	if !ctx.cr[6].gt {
	pc = 0x82401440; continue 'dispatch;
	}
	// 8240143C: FC60E090  fmr f3, f28
	ctx.f[3].f64 = ctx.f[28].f64;
	// 82401440: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82401444: FC80E890  fmr f4, f29
	ctx.f[4].f64 = ctx.f[29].f64;
	// 82401448: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8240144C: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82401450: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82401454: 38C10064  addi r6, r1, 0x64
	ctx.r[6].s64 = ctx.r[1].s64 + 100;
	// 82401458: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8240145C: 48000B9D  bl 0x82401ff8
	ctx.lr = 0x82401460;
	sub_82401FF8(ctx, base);
	// 82401460: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401464: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82401468: D3BD0000  stfs f29, 0(r29)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8240146C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82401470: EC00E824  fdivs f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[29].f64) as f32) as f64;
	// 82401474: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401478: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240147C: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401480: 38210260  addi r1, r1, 0x260
	ctx.r[1].s64 = ctx.r[1].s64 + 608;
	// 82401484: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82401488: 48134BA9  bl 0x82536030
	ctx.lr = 0x8240148C;
	sub_82535FFC(ctx, base);
	// 8240148C: 48133C78  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401490 size=112
    let mut pc: u32 = 0x82401490;
    'dispatch: loop {
        match pc {
            0x82401490 => {
    //   block [0x82401490..0x82401500)
	// 82401490: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 82401494: 396403FC  addi r11, r4, 0x3fc
	ctx.r[11].s64 = ctx.r[4].s64 + 1020;
	// 82401498: 6129A280  ori r9, r9, 0xa280
	ctx.r[9].u64 = ctx.r[9].u64 | 41600;
	// 8240149C: 394000FF  li r10, 0xff
	ctx.r[10].s64 = 255;
	// 824014A0: 3929FF5E  addi r9, r9, -0xa2
	ctx.r[9].s64 = ctx.r[9].s64 + -162;
	// 824014A4: 5528C23E  srwi r8, r9, 8
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shr(8);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824014A8: 39080041  addi r8, r8, 0x41
	ctx.r[8].s64 = ctx.r[8].s64 + 65;
	// 824014AC: 7D0851D6  mullw r8, r8, r10
	ctx.r[8].s64 = (ctx.r[8].s32 as i64) * (ctx.r[10].s32 as i64);
	// 824014B0: 390800D1  addi r8, r8, 0xd1
	ctx.r[8].s64 = ctx.r[8].s64 + 209;
	// 824014B4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824014B8: 5508C23E  srwi r8, r8, 8
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(8);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824014BC: 2B0A0056  cmplwi cr6, r10, 0x56
	ctx.cr[6].compare_u32(ctx.r[10].u32, 86 as u32, &mut ctx.xer);
	// 824014C0: 3908001D  addi r8, r8, 0x1d
	ctx.r[8].s64 = ctx.r[8].s64 + 29;
	// 824014C4: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824014C8: 7C081C2E  lfsx f0, r8, r3
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824014CC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824014D0: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 824014D4: 4199FFCC  bgt cr6, 0x824014a0
	if ctx.cr[6].gt {
	pc = 0x824014A0; continue 'dispatch;
	}
	// 824014D8: 3940457D  li r10, 0x457d
	ctx.r[10].s64 = 17789;
	// 824014DC: 39200057  li r9, 0x57
	ctx.r[9].s64 = 87;
	// 824014E0: 394AFF35  addi r10, r10, -0xcb
	ctx.r[10].s64 = ctx.r[10].s64 + -203;
	// 824014E4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 824014E8: 5548D1BA  rlwinm r8, r10, 0x1a, 6, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 824014EC: 7C081C2E  lfsx f0, r8, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824014F0: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824014F4: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 824014F8: 4082FFE8  bne 0x824014e0
	if !ctx.cr[0].eq {
	pc = 0x824014E0; continue 'dispatch;
	}
	// 824014FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82401500 size=328
    let mut pc: u32 = 0x82401500;
    'dispatch: loop {
        match pc {
            0x82401500 => {
    //   block [0x82401500..0x82401648)
	// 82401500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82401504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82401508: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240150C: 7C8B0735  extsh. r11, r4
	ctx.r[11].s64 = ctx.r[4].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82401510: 41810008  bgt 0x82401518
	if ctx.cr[0].gt {
	pc = 0x82401518; continue 'dispatch;
	}
	// 82401514: 388000B0  li r4, 0xb0
	ctx.r[4].s64 = 176;
	// 82401518: 7C8B0734  extsh r11, r4
	ctx.r[11].s64 = ctx.r[4].s16 as i64;
	// 8240151C: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401520: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82401524: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82401528: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8240152C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82401530: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82401534: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82401538: C1AB184C  lfs f13, 0x184c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6220 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8240153C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401540: C18BBCB4  lfs f12, -0x434c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17228 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82401544: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82401548: 4199000C  bgt cr6, 0x82401554
	if ctx.cr[6].gt {
	pc = 0x82401554; continue 'dispatch;
	}
	// 8240154C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82401550: 40980028  bge cr6, 0x82401578
	if !ctx.cr[6].lt {
	pc = 0x82401578; continue 'dispatch;
	}
	// 82401554: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82401558: 4098000C  bge cr6, 0x82401564
	if !ctx.cr[6].lt {
	pc = 0x82401564; continue 'dispatch;
	}
	// 8240155C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82401560: 48000008  b 0x82401568
	pc = 0x82401568; continue 'dispatch;
	// 82401564: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82401568: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240156C: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401570: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82401574: 409A000C  bne cr6, 0x82401580
	if !ctx.cr[6].eq {
	pc = 0x82401580; continue 'dispatch;
	}
	// 82401578: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8240157C: 480000BC  b 0x82401638
	pc = 0x82401638; continue 'dispatch;
	// 82401580: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82401584: 40980060  bge cr6, 0x824015e4
	if !ctx.cr[6].lt {
	pc = 0x824015E4; continue 'dispatch;
	}
	// 82401588: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8240158C: C1ABBCB0  lfs f13, -0x4350(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401590: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401594: EC400372  fmuls f2, f0, f13
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82401598: C82B2260  lfd f1, 0x2260(r11)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8800 as u32) ) };
	// 8240159C: 481321D5  bl 0x82533770
	ctx.lr = 0x824015A0;
	sub_82533770(ctx, base);
	// 824015A0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 824015A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824015A8: C1ABBCAC  lfs f13, -0x4354(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824015AC: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 824015B0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 824015B4: 40980008  bge cr6, 0x824015bc
	if !ctx.cr[6].lt {
	pc = 0x824015BC; continue 'dispatch;
	}
	// 824015B8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 824015BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824015C0: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824015C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824015C8: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 824015CC: C00B2898  lfs f0, 0x2898(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824015D0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 824015D4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 824015D8: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 824015DC: A0610056  lhz r3, 0x56(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 824015E0: 48000058  b 0x82401638
	pc = 0x82401638; continue 'dispatch;
	// 824015E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824015E8: C1ABBCA8  lfs f13, -0x4358(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824015EC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824015F0: EC400372  fmuls f2, f0, f13
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 824015F4: C82B2260  lfd f1, 0x2260(r11)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8800 as u32) ) };
	// 824015F8: 48132179  bl 0x82533770
	ctx.lr = 0x824015FC;
	sub_82533770(ctx, base);
	// 824015FC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82401600: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401604: C1ABBCA4  lfs f13, -0x435c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17244 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401608: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8240160C: 40990008  ble cr6, 0x82401614
	if !ctx.cr[6].gt {
	pc = 0x82401614; continue 'dispatch;
	}
	// 82401610: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82401614: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82401618: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8240161C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401620: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82401624: C00B2898  lfs f0, 0x2898(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401628: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8240162C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82401630: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82401634: A0610056  lhz r3, 0x56(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82401638: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8240163C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82401640: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82401644: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401648 size=268
    let mut pc: u32 = 0x82401648;
    'dispatch: loop {
        match pc {
            0x82401648 => {
    //   block [0x82401648..0x82401754)
	// 82401648: 546BEEFE  rlwinm r11, r3, 0x1d, 0x1b, 0x1f
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000007u64;
	// 8240164C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82401650: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82401654: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82401658: C1A9BCB8  lfs f13, -0x4348(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8240165C: C1881850  lfs f12, 0x1850(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(6224 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82401660: 7D695B79  or. r9, r11, r11
	ctx.r[9].u64 = ctx.r[11].u64 | ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82401664: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82401668: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240166C: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82401670: EC00637A  fmadds f0, f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82401674: 7C0B552E  stfsx f0, r11, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82401678: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8240167C: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401680: 40810030  ble 0x824016b0
	if !ctx.cr[0].gt {
	pc = 0x824016B0; continue 'dispatch;
	}
	// 82401684: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82401688: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 8240168C: 7D6B542E  lfsx f11, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82401690: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82401694: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82401698: 7D6B552E  stfsx f11, r11, r10
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 8240169C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824016A0: 7D6B542E  lfsx f11, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824016A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824016A8: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 824016AC: 4082FFE0  bne 0x8240168c
	if !ctx.cr[0].eq {
	pc = 0x8240168C; continue 'dispatch;
	}
	// 824016B0: 39690001  addi r11, r9, 1
	ctx.r[11].s64 = ctx.r[9].s64 + 1;
	// 824016B4: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 824016B8: 41990030  bgt cr6, 0x824016e8
	if ctx.cr[6].gt {
	pc = 0x824016E8; continue 'dispatch;
	}
	// 824016BC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824016C0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824016C4: 7D6B542E  lfsx f11, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824016C8: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 824016CC: 7D6B552E  stfsx f11, r11, r10
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 824016D0: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824016D4: 7D6B542E  lfsx f11, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824016D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824016DC: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 824016E0: 2F0B0080  cmpwi cr6, r11, 0x80
	ctx.cr[6].compare_i32(ctx.r[11].s32, 128, &mut ctx.xer);
	// 824016E4: 4099FFE0  ble cr6, 0x824016c4
	if !ctx.cr[6].gt {
	pc = 0x824016C4; continue 'dispatch;
	}
	// 824016E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824016EC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824016F0: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 824016F4: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824016F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824016FC: D1A40004  stfs f13, 4(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82401700: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82401704: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401708: C1840004  lfs f12, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8240170C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82401710: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82401714: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82401718: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 8240171C: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82401720: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82401724: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82401728: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 8240172C: EDAD603A  fmadds f13, f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82401730: D1A40004  stfs f13, 4(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82401734: 4099FFCC  ble cr6, 0x82401700
	if !ctx.cr[6].gt {
	pc = 0x82401700; continue 'dispatch;
	}
	// 82401738: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8240173C: C00B1848  lfs f0, 0x1848(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401740: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82401744: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82401748: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8240174C: B1640008  sth r11, 8(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u16 ) };
	// 82401750: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401758 size=64
    let mut pc: u32 = 0x82401758;
    'dispatch: loop {
        match pc {
            0x82401758 => {
    //   block [0x82401758..0x82401798)
	// 82401758: A9630008  lha r11, 8(r3)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as i16) as i64;
	// 8240175C: 2F0B0054  cmpwi cr6, r11, 0x54
	ctx.cr[6].compare_i32(ctx.r[11].s32, 84, &mut ctx.xer);
	// 82401760: 41990038  bgt cr6, 0x82401798
	if ctx.cr[6].gt {
		sub_82401798(ctx, base);
		return;
	}
	// 82401764: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82401768: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8240176C: C00ABCBC  lfs f0, -0x4344(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401770: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82401774: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82401778: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 8240177C: 7D0B0734  extsh r11, r8
	ctx.r[11].s64 = ctx.r[8].s16 as i64;
	// 82401780: 7DAA4C2E  lfsx f13, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401784: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82401788: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8240178C: 7DAA4D2E  stfsx f13, r10, r9
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82401790: 4099FFE0  ble cr6, 0x82401770
	if !ctx.cr[6].gt {
	pc = 0x82401770; continue 'dispatch;
	}
	// 82401794: 4800000C  b 0x824017a0
	sub_82401798(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82401798 size=24
    let mut pc: u32 = 0x82401798;
    'dispatch: loop {
        match pc {
            0x82401798 => {
    //   block [0x82401798..0x824017B0)
	// 82401798: 39600054  li r11, 0x54
	ctx.r[11].s64 = 84;
	// 8240179C: B1630008  sth r11, 8(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u16 ) };
	// 824017A0: A1630008  lhz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 824017A4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824017A8: B1630008  sth r11, 8(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u16 ) };
	// 824017AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824017B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824017B0 size=52
    let mut pc: u32 = 0x824017B0;
    'dispatch: loop {
        match pc {
            0x824017B0 => {
    //   block [0x824017B0..0x824017E4)
	// 824017B0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824017B4: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824017B8: C1ABBCD8  lfs f13, -0x4328(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824017BC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 824017C0: 40990024  ble cr6, 0x824017e4
	if !ctx.cr[6].gt {
		sub_824017E4(ctx, base);
		return;
	}
	// 824017C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824017C8: C1ABBCD4  lfs f13, -0x432c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824017CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824017D0: C18BBCD0  lfs f12, -0x4330(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17200 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824017D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824017D8: ED80637C  fnmsubs f12, f0, f13, f12
	ctx.f[12].f64 = -(((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 824017DC: C1ABBCCC  lfs f13, -0x4334(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17204 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824017E0: 48000020  b 0x82401800
	sub_824017E4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824017E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824017E4 size=60
    let mut pc: u32 = 0x824017E4;
    'dispatch: loop {
        match pc {
            0x824017E4 => {
    //   block [0x824017E4..0x82401820)
	// 824017E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824017E8: C1ABBCC8  lfs f13, -0x4338(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17208 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824017EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824017F0: C18BBCC4  lfs f12, -0x433c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824017F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824017F8: ED80637C  fnmsubs f12, f0, f13, f12
	ctx.f[12].f64 = -(((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 824017FC: C1ABBCC0  lfs f13, -0x4340(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401800: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82401804: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82401808: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8240180C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82401810: 41990008  bgt cr6, 0x82401818
	if ctx.cr[6].gt {
	pc = 0x82401818; continue 'dispatch;
	}
	// 82401814: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82401818: 99640013  stb r11, 0x13(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(19 as u32), ctx.r[11].u8 ) };
	// 8240181C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401820 size=108
    let mut pc: u32 = 0x82401820;
    'dispatch: loop {
        match pc {
            0x82401820 => {
    //   block [0x82401820..0x8240188C)
	// 82401820: 89660013  lbz r11, 0x13(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(19 as u32) ) } as u64;
	// 82401824: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82401828: 419A006C  beq cr6, 0x82401894
	if ctx.cr[6].eq {
		sub_82401894(ctx, base);
		return;
	}
	// 8240182C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401830: C00BBCE0  lfs f0, -0x4320(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401834: 7CAB0734  extsh r11, r5
	ctx.r[11].s64 = ctx.r[5].s16 as i64;
	// 82401838: EC020028  fsubs f0, f2, f0
	ctx.f[0].f64 = (((ctx.f[2].f64 - ctx.f[0].f64) as f32) as f64);
	// 8240183C: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82401840: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401844: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82401848: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8240184C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82401850: C1ABBCDC  lfs f13, -0x4324(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401854: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82401858: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8240185C: 40980008  bge cr6, 0x82401864
	if !ctx.cr[6].lt {
	pc = 0x82401864; continue 'dispatch;
	}
	// 82401860: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82401864: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82401868: 4198002C  blt cr6, 0x82401894
	if ctx.cr[6].lt {
		sub_82401894(ctx, base);
		return;
	}
	// 8240186C: A166000E  lhz r11, 0xe(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(14 as u32) ) } as u64;
	// 82401870: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82401874: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 82401878: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8240187C: B166000E  sth r11, 0xe(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(14 as u32), ctx.r[11].u16 ) };
	// 82401880: 4099000C  ble cr6, 0x8240188c
	if !ctx.cr[6].gt {
		sub_8240188C(ctx, base);
		return;
	}
	// 82401884: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82401888: 48000010  b 0x82401898
	sub_82401894(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8240188C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8240188C size=8
    let mut pc: u32 = 0x8240188C;
    'dispatch: loop {
        match pc {
            0x8240188C => {
    //   block [0x8240188C..0x82401894)
	// 8240188C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82401890: 4800000C  b 0x8240189c
	sub_82401894(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401894(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82401894 size=16
    let mut pc: u32 = 0x82401894;
    'dispatch: loop {
        match pc {
            0x82401894 => {
    //   block [0x82401894..0x824018A4)
	// 82401894: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82401898: B166000E  sth r11, 0xe(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(14 as u32), ctx.r[11].u16 ) };
	// 8240189C: 99660014  stb r11, 0x14(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 824018A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824018A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824018A8 size=60
    let mut pc: u32 = 0x824018A8;
    'dispatch: loop {
        match pc {
            0x824018A8 => {
    //   block [0x824018A8..0x824018E4)
	// 824018A8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824018AC: C1A40000  lfs f13, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824018B0: C00BBCD8  lfs f0, -0x4328(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824018B4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824018B8: 4098002C  bge cr6, 0x824018e4
	if !ctx.cr[6].lt {
		sub_824018E4(ctx, base);
		return;
	}
	// 824018BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824018C0: C00BBCF8  lfs f0, -0x4308(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824018C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824018C8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 824018CC: C18B26A0  lfs f12, 0x26a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9888 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824018D0: ED8D602A  fadds f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 824018D4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 824018D8: 40980034  bge cr6, 0x8240190c
	if !ctx.cr[6].lt {
		sub_82401900(ctx, base);
		return;
	}
	// 824018DC: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 824018E0: 4800002C  b 0x8240190c
	sub_82401900(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824018E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824018E4 size=28
    let mut pc: u32 = 0x824018E4;
    'dispatch: loop {
        match pc {
            0x824018E4 => {
    //   block [0x824018E4..0x82401900)
	// 824018E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824018E8: C00BBCF4  lfs f0, -0x430c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824018EC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824018F0: 40980010  bge cr6, 0x82401900
	if !ctx.cr[6].lt {
		sub_82401900(ctx, base);
		return;
	}
	// 824018F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824018F8: C00BBCF0  lfs f0, -0x4310(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824018FC: 4800000C  b 0x82401908
	sub_82401900(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401900 size=152
    let mut pc: u32 = 0x82401900;
    'dispatch: loop {
        match pc {
            0x82401900 => {
    //   block [0x82401900..0x82401998)
	// 82401900: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401904: C00BBCEC  lfs f0, -0x4314(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17172 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401908: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8240190C: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 82401910: 409800F0  bge cr6, 0x82401a00
	if !ctx.cr[6].lt {
		sub_82401A00(ctx, base);
		return;
	}
	// 82401914: 89640012  lbz r11, 0x12(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 82401918: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240191C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82401920: C12B1850  lfs f9, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82401924: 4181002C  bgt 0x82401950
	if ctx.cr[0].gt {
	pc = 0x82401950; continue 'dispatch;
	}
	// 82401928: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8240192C: ED81482A  fadds f12, f1, f9
	ctx.f[12].f64 = ((ctx.f[1].f64 + ctx.f[9].f64) as f32) as f64;
	// 82401930: C16B8E30  lfs f11, -0x71d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29136 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82401934: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401938: ED6D02F2  fmuls f11, f13, f11
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 8240193C: C14B8E24  lfs f10, -0x71dc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29148 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82401940: ED0C5ABA  fmadds f8, f12, f10, f11
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64);
	// 82401944: FF080000  fcmpu cr6, f8, f0
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[0].f64);
	// 82401948: 41990008  bgt cr6, 0x82401950
	if ctx.cr[6].gt {
	pc = 0x82401950; continue 'dispatch;
	}
	// 8240194C: EC0C5ABA  fmadds f0, f12, f10, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64);
	// 82401950: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401954: C18B2238  lfs f12, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82401958: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 8240195C: FF016000  fcmpu cr6, f1, f12
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[12].f64);
	// 82401960: 4199005C  bgt cr6, 0x824019bc
	if ctx.cr[6].gt {
		sub_824019BC(ctx, base);
		return;
	}
	// 82401964: FF014800  fcmpu cr6, f1, f9
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[9].f64);
	// 82401968: 40980030  bge cr6, 0x82401998
	if !ctx.cr[6].lt {
		sub_82401998(ctx, base);
		return;
	}
	// 8240196C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401970: ED81482A  fadds f12, f1, f9
	ctx.f[12].f64 = ((ctx.f[1].f64 + ctx.f[9].f64) as f32) as f64;
	// 82401974: C16BBCE8  lfs f11, -0x4318(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17176 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82401978: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8240197C: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82401980: C16B2980  lfs f11, 0x2980(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10624 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82401984: ED4C6AFA  fmadds f10, f12, f11, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82401988: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 8240198C: 419900A4  bgt cr6, 0x82401a30
	if ctx.cr[6].gt {
		sub_82401A00(ctx, base);
		return;
	}
	// 82401990: EC0C6AFA  fmadds f0, f12, f11, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82401994: 4800009C  b 0x82401a30
	sub_82401A00(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401998 size=36
    let mut pc: u32 = 0x82401998;
    'dispatch: loop {
        match pc {
            0x82401998 => {
    //   block [0x82401998..0x824019BC)
	// 82401998: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8240199C: C18B2984  lfs f12, 0x2984(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10628 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824019A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824019A4: C16B8E34  lfs f11, -0x71cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29132 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824019A8: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 824019AC: EDA16B3A  fmadds f13, f1, f12, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 824019B0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824019B4: 4199007C  bgt cr6, 0x82401a30
	if ctx.cr[6].gt {
		sub_82401A00(ctx, base);
		return;
	}
	// 824019B8: 48000074  b 0x82401a2c
	sub_82401A00(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824019BC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824019BC size=40
    let mut pc: u32 = 0x824019BC;
    'dispatch: loop {
        match pc {
            0x824019BC => {
    //   block [0x824019BC..0x824019E4)
	// 824019BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824019C0: C18B20B0  lfs f12, 0x20b0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824019C4: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 824019C8: FF016000  fcmpu cr6, f1, f12
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[12].f64);
	// 824019CC: 41990018  bgt cr6, 0x824019e4
	if ctx.cr[6].gt {
		sub_824019E4(ctx, base);
		return;
	}
	// 824019D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824019D4: C18B20C8  lfs f12, 0x20c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8392 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824019D8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824019DC: C16B8E28  lfs f11, -0x71d8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29144 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824019E0: 4BFFFFC8  b 0x824019a8
	sub_82401998(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824019E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824019E4 size=28
    let mut pc: u32 = 0x824019E4;
    'dispatch: loop {
        match pc {
            0x824019E4 => {
    //   block [0x824019E4..0x82401A00)
	// 824019E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824019E8: C18BD6C8  lfs f12, -0x2938(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824019EC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824019F0: C16B207C  lfs f11, 0x207c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824019F4: ED6102F2  fmuls f11, f1, f11
	ctx.f[11].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 824019F8: EDAD5B3A  fmadds f13, f13, f12, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 824019FC: 4BFFFFB4  b 0x824019b0
	sub_82401998(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401A00 size=96
    let mut pc: u32 = 0x82401A00;
    'dispatch: loop {
        match pc {
            0x82401A00 => {
    //   block [0x82401A00..0x82401A60)
	// 82401A00: 89640013  lbz r11, 0x13(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(19 as u32) ) } as u64;
	// 82401A04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82401A08: 409A0028  bne cr6, 0x82401a30
	if !ctx.cr[6].eq {
	pc = 0x82401A30; continue 'dispatch;
	}
	// 82401A0C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401A10: C18B203C  lfs f12, 0x203c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8252 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82401A14: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401A18: C16B2038  lfs f11, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82401A1C: ED6102F2  fmuls f11, f1, f11
	ctx.f[11].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 82401A20: EDAD5B3A  fmadds f13, f13, f12, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 82401A24: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82401A28: 41980008  blt cr6, 0x82401a30
	if ctx.cr[6].lt {
	pc = 0x82401A30; continue 'dispatch;
	}
	// 82401A2C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82401A30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401A34: C1ABBCE4  lfs f13, -0x431c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17180 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401A38: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82401A3C: 40990008  ble cr6, 0x82401a44
	if !ctx.cr[6].gt {
	pc = 0x82401A44; continue 'dispatch;
	}
	// 82401A40: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82401A44: 89640012  lbz r11, 0x12(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 82401A48: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82401A4C: 4181000C  bgt 0x82401a58
	if ctx.cr[0].gt {
	pc = 0x82401A58; continue 'dispatch;
	}
	// 82401A50: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82401A54: 99640012  stb r11, 0x12(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(18 as u32), ctx.r[11].u8 ) };
	// 82401A58: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401A5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82401A60 size=88
    let mut pc: u32 = 0x82401A60;
    'dispatch: loop {
        match pc {
            0x82401A60 => {
    //   block [0x82401A60..0x82401AB8)
	// 82401A60: 7C8B0734  extsh r11, r4
	ctx.r[11].s64 = ctx.r[4].s16 as i64;
	// 82401A64: 2F0B00FF  cmpwi cr6, r11, 0xff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 255, &mut ctx.xer);
	// 82401A68: 41980008  blt cr6, 0x82401a70
	if ctx.cr[6].lt {
	pc = 0x82401A70; continue 'dispatch;
	}
	// 82401A6C: 388000FF  li r4, 0xff
	ctx.r[4].s64 = 255;
	// 82401A70: 89660014  lbz r11, 0x14(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 82401A74: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82401A78: 409A0040  bne cr6, 0x82401ab8
	if !ctx.cr[6].eq {
		sub_82401AB8(ctx, base);
		return;
	}
	// 82401A7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82401A80: 89460015  lbz r10, 0x15(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(21 as u32) ) } as u64;
	// 82401A84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82401A88: B1660010  sth r11, 0x10(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 82401A8C: 409A0094  bne cr6, 0x82401b20
	if !ctx.cr[6].eq {
		sub_82401AB8(ctx, base);
		return;
	}
	// 82401A90: 7C8B0734  extsh r11, r4
	ctx.r[11].s64 = ctx.r[4].s16 as i64;
	// 82401A94: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82401A98: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82401A9C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82401AA0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82401AA4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82401AA8: 41980078  blt cr6, 0x82401b20
	if ctx.cr[6].lt {
		sub_82401AB8(ctx, base);
		return;
	}
	// 82401AAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82401AB0: 99660015  stb r11, 0x15(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(21 as u32), ctx.r[11].u8 ) };
	// 82401AB4: 4800006C  b 0x82401b20
	sub_82401AB8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401AB8 size=116
    let mut pc: u32 = 0x82401AB8;
    'dispatch: loop {
        match pc {
            0x82401AB8 => {
    //   block [0x82401AB8..0x82401B2C)
	// 82401AB8: 54A9043E  clrlwi r9, r5, 0x10
	ctx.r[9].u64 = ctx.r[5].u32 as u64 & 0x0000FFFFu64;
	// 82401ABC: A1460010  lhz r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 82401AC0: C1A60008  lfs f13, 8(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401AC4: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 82401AC8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 82401ACC: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 82401AD0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82401AD4: B1660010  sth r11, 0x10(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 82401AD8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401ADC: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82401AE0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82401AE4: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82401AE8: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401AEC: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82401AF0: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82401AF4: D801FFF0  stfd f0, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[0].u64 ) };
	// 82401AF8: A961FFF6  lha r11, -0xa(r1)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(-10 as u32) ) } as i16) as i64;
	// 82401AFC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82401B00: 40990020  ble cr6, 0x82401b20
	if !ctx.cr[6].gt {
	pc = 0x82401B20; continue 'dispatch;
	}
	// 82401B04: 7D4B0734  extsh r11, r10
	ctx.r[11].s64 = ctx.r[10].s16 as i64;
	// 82401B08: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82401B0C: 2F0B7FBC  cmpwi cr6, r11, 0x7fbc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32700, &mut ctx.xer);
	// 82401B10: 99460015  stb r10, 0x15(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 82401B14: 4099000C  ble cr6, 0x82401b20
	if !ctx.cr[6].gt {
	pc = 0x82401B20; continue 'dispatch;
	}
	// 82401B18: 39607FBC  li r11, 0x7fbc
	ctx.r[11].s64 = 32700;
	// 82401B1C: B1660010  sth r11, 0x10(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 82401B20: 89660015  lbz r11, 0x15(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(21 as u32) ) } as u64;
	// 82401B24: 7D630774  extsb r3, r11
	ctx.r[3].s64 = ctx.r[11].s8 as i64;
	// 82401B28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401B30 size=56
    let mut pc: u32 = 0x82401B30;
    'dispatch: loop {
        match pc {
            0x82401B30 => {
    //   block [0x82401B30..0x82401B68)
	// 82401B30: 89630014  lbz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82401B34: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82401B38: 409A0030  bne cr6, 0x82401b68
	if !ctx.cr[6].eq {
		sub_82401B68(ctx, base);
		return;
	}
	// 82401B3C: 7C8B0734  extsh r11, r4
	ctx.r[11].s64 = ctx.r[4].s16 as i64;
	// 82401B40: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82401B44: 409A0024  bne cr6, 0x82401b68
	if !ctx.cr[6].eq {
		sub_82401B68(ctx, base);
		return;
	}
	// 82401B48: 89630015  lbz r11, 0x15(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(21 as u32) ) } as u64;
	// 82401B4C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82401B50: 409A0018  bne cr6, 0x82401b68
	if !ctx.cr[6].eq {
		sub_82401B68(ctx, base);
		return;
	}
	// 82401B54: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401B58: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82401B5C: C00B2284  lfs f0, 0x2284(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8836 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401B60: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82401B64: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82401B68 size=8
    let mut pc: u32 = 0x82401B68;
    'dispatch: loop {
        match pc {
            0x82401B68 => {
    //   block [0x82401B68..0x82401B70)
	// 82401B68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82401B6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82401B70 size=444
    let mut pc: u32 = 0x82401B70;
    'dispatch: loop {
        match pc {
            0x82401B70 => {
    //   block [0x82401B70..0x82401D2C)
	// 82401B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82401B74: 48133541  bl 0x825350b4
	ctx.lr = 0x82401B78;
	sub_82535080(ctx, base);
	// 82401B78: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82401B7C: 4813446D  bl 0x82535fe8
	ctx.lr = 0x82401B80;
	sub_82535FB0(ctx, base);
	// 82401B80: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82401B84: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82401B88: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82401B8C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82401B90: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82401B94: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 82401B98: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82401B9C: 4BFFC10D  bl 0x823fdca8
	ctx.lr = 0x82401BA0;
	sub_823FDCA8(ctx, base);
	// 82401BA0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82401BA4: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 82401BA8: C3EB1850  lfs f31, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82401BAC: 3960000B  li r11, 0xb
	ctx.r[11].s64 = 11;
	// 82401BB0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82401BB4: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401BB8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82401BBC: EC00F83C  fnmsubs f0, f0, f0, f31
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82401BC0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82401BC4: EC200072  fmuls f1, f0, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82401BC8: 4082FFEC  bne 0x82401bb4
	if !ctx.cr[0].eq {
	pc = 0x82401BB4; continue 'dispatch;
	}
	// 82401BCC: 4BFFC59D  bl 0x823fe168
	ctx.lr = 0x82401BD0;
	sub_823FE168(ctx, base);
	// 82401BD0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401BD4: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401BD8: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82401BDC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82401BE0: EFE0F83A  fmadds f31, f0, f0, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64);
	// 82401BE4: 3BC00005  li r30, 5
	ctx.r[30].s64 = 5;
	// 82401BE8: 3F808273  lis r28, -0x7d8d
	ctx.r[28].s64 = -2106392576;
	// 82401BEC: C3CBBFFC  lfs f30, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82401BF0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401BF4: EFA1EFBC  fnmsubs f29, f1, f30, f29
	ctx.f[29].f64 = -(((ctx.f[1].f64 * ctx.f[30].f64 - ctx.f[29].f64) as f32) as f64);
	// 82401BF8: C1AB24DC  lfs f13, 0x24dc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9436 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401BFC: EF800372  fmuls f28, f0, f13
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82401C00: 817CD6E8  lwz r11, -0x2918(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-10520 as u32) ) } as u64;
	// 82401C04: 7C1F5C2E  lfsx f0, r31, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401C08: 3BFF0080  addi r31, r31, 0x80
	ctx.r[31].s64 = ctx.r[31].s64 + 128;
	// 82401C0C: EC20FF3A  fmadds f1, f0, f28, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[28].f64 + ctx.f[31].f64) as f32) as f64);
	// 82401C10: 4BFFC559  bl 0x823fe168
	ctx.lr = 0x82401C14;
	sub_823FE168(ctx, base);
	// 82401C14: EC01EFBC  fnmsubs f0, f1, f30, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[30].f64 - ctx.f[29].f64) as f32) as f64);
	// 82401C18: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401C1C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82401C20: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82401C24: 4082FFDC  bne 0x82401c00
	if !ctx.cr[0].eq {
	pc = 0x82401C00; continue 'dispatch;
	}
	// 82401C28: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82401C2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82401C30: 394ABCFC  addi r10, r10, -0x4304
	ctx.r[10].s64 = ctx.r[10].s64 + -17156;
	// 82401C34: 393B0004  addi r9, r27, 4
	ctx.r[9].s64 = ctx.r[27].s64 + 4;
	// 82401C38: C18A0000  lfs f12, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82401C3C: C14A0004  lfs f10, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82401C40: C16A000C  lfs f11, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82401C44: 5568073E  clrlwi r8, r11, 0x1c
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82401C48: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401C4C: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 82401C50: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 82401C54: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82401C58: 38C10074  addi r6, r1, 0x74
	ctx.r[6].s64 = ctx.r[1].s64 + 116;
	// 82401C5C: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 82401C60: 7D0A342E  lfsx f8, r10, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82401C64: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82401C68: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82401C6C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82401C70: ED2002F2  fmuls f9, f0, f11
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82401C74: 7C0A3C2E  lfsx f0, r10, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401C78: ED080028  fsubs f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82401C7C: EC08027A  fmadds f0, f8, f9, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64);
	// 82401C80: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82401C84: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82401C88: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82401C8C: 40990008  ble cr6, 0x82401c94
	if !ctx.cr[6].gt {
	pc = 0x82401C94; continue 'dispatch;
	}
	// 82401C90: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 82401C94: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82401C98: 41990008  bgt cr6, 0x82401ca0
	if ctx.cr[6].gt {
	pc = 0x82401CA0; continue 'dispatch;
	}
	// 82401C9C: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	// 82401CA0: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 82401CA4: 40980020  bge cr6, 0x82401cc4
	if !ctx.cr[6].lt {
	pc = 0x82401CC4; continue 'dispatch;
	}
	// 82401CA8: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 82401CAC: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 82401CB0: C9210068  lfd f9, 0x68(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82401CB4: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 82401CB8: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82401CBC: ED2902F2  fmuls f9, f9, f11
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[11].f64) as f32) as f64);
	// 82401CC0: EC090032  fmuls f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82401CC4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82401CC8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82401CCC: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401CD0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82401CD4: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 82401CD8: 4198FF6C  blt cr6, 0x82401c44
	if ctx.cr[6].lt {
	pc = 0x82401C44; continue 'dispatch;
	}
	// 82401CDC: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82401CE0: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82401CE4: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 82401CE8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82401CEC: 4BFFBFBD  bl 0x823fdca8
	ctx.lr = 0x82401CF0;
	sub_823FDCA8(ctx, base);
	// 82401CF0: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401CF4: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401CF8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82401CFC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82401D00: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 82401D04: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401D08: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82401D0C: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82401D10: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401D14: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82401D18: 4082FFEC  bne 0x82401d04
	if !ctx.cr[0].eq {
	pc = 0x82401D04; continue 'dispatch;
	}
	// 82401D1C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82401D20: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82401D24: 48134311  bl 0x82536034
	ctx.lr = 0x82401D28;
	sub_82535FFC(ctx, base);
	// 82401D28: 481333DC  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401D30 size=356
    let mut pc: u32 = 0x82401D30;
    'dispatch: loop {
        match pc {
            0x82401D30 => {
    //   block [0x82401D30..0x82401E94)
	// 82401D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82401D34: 48133379  bl 0x825350ac
	ctx.lr = 0x82401D38;
	sub_82535080(ctx, base);
	// 82401D38: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82401D3C: 38880808  addi r4, r8, 0x808
	ctx.r[4].s64 = ctx.r[8].s64 + 2056;
	// 82401D40: FDA01090  fmr f13, f2
	ctx.f[13].f64 = ctx.f[2].f64;
	// 82401D44: 3868090C  addi r3, r8, 0x90c
	ctx.r[3].s64 = ctx.r[8].s64 + 2316;
	// 82401D48: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82401D4C: C00400FC  lfs f0, 0xfc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401D50: D0040100  stfs f0, 0x100(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82401D54: C00300FC  lfs f0, 0xfc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401D58: D0030100  stfs f0, 0x100(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82401D5C: 40990104  ble cr6, 0x82401e60
	if !ctx.cr[6].gt {
	pc = 0x82401E60; continue 'dispatch;
	}
	// 82401D60: 3F40820D  lis r26, -0x7df3
	ctx.r[26].s64 = -2113077248;
	// 82401D64: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82401D68: 3F808201  lis r28, -0x7dff
	ctx.r[28].s64 = -2113863680;
	// 82401D6C: 8361005C  lwz r27, 0x5c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82401D70: 3FA08201  lis r29, -0x7dff
	ctx.r[29].s64 = -2113863680;
	// 82401D74: 3FC08201  lis r30, -0x7dff
	ctx.r[30].s64 = -2113863680;
	// 82401D78: 3FE08201  lis r31, -0x7dff
	ctx.r[31].s64 = -2113863680;
	// 82401D7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401D80: C15A2038  lfs f10, 0x2038(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8248 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82401D84: C0DCBD10  lfs f6, -0x42f0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-17136 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82401D88: 7F284850  subf r25, r8, r9
	ctx.r[25].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82401D8C: C0FDBD14  lfs f7, -0x42ec(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17132 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82401D90: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82401D94: C11EBD18  lfs f8, -0x42e8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-17128 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82401D98: C13FBD1C  lfs f9, -0x42e4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-17124 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82401D9C: C0ABBD20  lfs f5, -0x42e0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17120 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82401DA0: FF0D2800  fcmpu cr6, f13, f5
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[5].f64);
	// 82401DA4: 40990010  ble cr6, 0x82401db4
	if !ctx.cr[6].gt {
	pc = 0x82401DB4; continue 'dispatch;
	}
	// 82401DA8: EC0D427C  fnmsubs f0, f13, f9, f8
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[9].f64 - ctx.f[8].f64) as f32) as f64);
	// 82401DAC: EC003B7A  fmadds f0, f0, f13, f7
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[7].f64) as f32) as f64);
	// 82401DB0: 48000008  b 0x82401db8
	pc = 0x82401DB8; continue 'dispatch;
	// 82401DB4: EC0D01B2  fmuls f0, f13, f6
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[6].f64) as f32) as f64);
	// 82401DB8: EC0002B2  fmuls f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82401DBC: 3961FFA0  addi r11, r1, -0x60
	ctx.r[11].s64 = ctx.r[1].s64 + -96;
	// 82401DC0: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82401DC4: EDAD102A  fadds f13, f13, f2
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[2].f64) as f32) as f64;
	// 82401DC8: FD80001E  fctiwz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82401DCC: 7D805FAE  stfiwx f12, 0, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82401DD0: 8161FFA0  lwz r11, -0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) } as u64;
	// 82401DD4: 7D7F07B4  extsw r31, r11
	ctx.r[31].s64 = ctx.r[11].s32 as i64;
	// 82401DD8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82401DDC: 7FCB2214  add r30, r11, r4
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82401DE0: 7FABDA14  add r29, r11, r27
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82401DE4: FBE1FFA8  std r31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.r[31].u64 ) };
	// 82401DE8: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82401DEC: 7D8B542E  lfsx f12, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82401DF0: 7F8B1A14  add r28, r11, r3
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82401DF4: 7D6B242E  lfsx f11, r11, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82401DF8: C3FE0004  lfs f31, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82401DFC: EFFF5828  fsubs f31, f31, f11
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[11].f64) as f32) as f64);
	// 82401E00: C861FFA8  lfd f3, -0x58(r1)
	ctx.f[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82401E04: FC601E9C  fcfid f3, f3
	ctx.f[3].f64 = (ctx.f[3].s64 as f64);
	// 82401E08: FC601818  frsp f3, f3
	ctx.f[3].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82401E0C: EC001828  fsubs f0, f0, f3
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[3].f64) as f32) as f64);
	// 82401E10: C07F0004  lfs f3, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82401E14: EC636028  fsubs f3, f3, f12
	ctx.f[3].f64 = (((ctx.f[3].f64 - ctx.f[12].f64) as f32) as f64);
	// 82401E18: ED7F583A  fmadds f11, f31, f0, f11
	ctx.f[11].f64 = (((ctx.f[31].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82401E1C: ED83603A  fmadds f12, f3, f0, f12
	ctx.f[12].f64 = (((ctx.f[3].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82401E20: ED6B6028  fsubs f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82401E24: ED8B613A  fmadds f12, f11, f4, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[4].f64 + ctx.f[12].f64) as f32) as f64);
	// 82401E28: 7D99452E  stfsx f12, r25, r8
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[25].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 82401E2C: 7D8BDC2E  lfsx f12, r11, r27
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82401E30: C07D0004  lfs f3, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82401E34: 7D6B1C2E  lfsx f11, r11, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82401E38: EC636028  fsubs f3, f3, f12
	ctx.f[3].f64 = (((ctx.f[3].f64 - ctx.f[12].f64) as f32) as f64);
	// 82401E3C: C3FC0004  lfs f31, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82401E40: EFFF5828  fsubs f31, f31, f11
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[11].f64) as f32) as f64);
	// 82401E44: ED83603A  fmadds f12, f3, f0, f12
	ctx.f[12].f64 = (((ctx.f[3].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82401E48: EC1F583A  fmadds f0, f31, f0, f11
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82401E4C: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82401E50: EC00613A  fmadds f0, f0, f4, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[4].f64 + ctx.f[12].f64) as f32) as f64);
	// 82401E54: D0080000  stfs f0, 0(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401E58: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82401E5C: 4082FF44  bne 0x82401da0
	if !ctx.cr[0].eq {
	pc = 0x82401DA0; continue 'dispatch;
	}
	// 82401E60: 7F073000  cmpw cr6, r7, r6
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82401E64: 40980028  bge cr6, 0x82401e8c
	if !ctx.cr[6].lt {
	pc = 0x82401E8C; continue 'dispatch;
	}
	// 82401E68: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82401E6C: 7D473050  subf r10, r7, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[7].s64;
	// 82401E70: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82401E74: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401E78: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82401E7C: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82401E80: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401E84: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82401E88: 4082FFEC  bne 0x82401e74
	if !ctx.cr[0].eq {
	pc = 0x82401E74; continue 'dispatch;
	}
	// 82401E8C: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82401E90: 4813326C  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401E98 size=352
    let mut pc: u32 = 0x82401E98;
    'dispatch: loop {
        match pc {
            0x82401E98 => {
    //   block [0x82401E98..0x82401FF8)
	// 82401E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82401E9C: 4813321D  bl 0x825350b8
	ctx.lr = 0x82401EA0;
	sub_82535080(ctx, base);
	// 82401EA0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401EA4: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82401EA8: 3941FFD0  addi r10, r1, -0x30
	ctx.r[10].s64 = ctx.r[1].s64 + -48;
	// 82401EAC: 3CA01000  lis r5, 0x1000
	ctx.r[5].s64 = 268435456;
	// 82401EB0: 3BE04000  li r31, 0x4000
	ctx.r[31].s64 = 16384;
	// 82401EB4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82401EB8: C00B2148  lfs f0, 0x2148(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401EBC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401EC0: ED410032  fmuls f10, f1, f0
	ctx.f[10].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82401EC4: C00B2838  lfs f0, 0x2838(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401EC8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401ECC: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82401ED0: C1ABAFC0  lfs f13, -0x5040(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20544 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401ED4: FD40501E  fctiwz f10, f10
	ctx.f[10].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 82401ED8: 7D4057AE  stfiwx f10, 0, r10
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82401EDC: 3941FFD0  addi r10, r1, -0x30
	ctx.r[10].s64 = ctx.r[1].s64 + -48;
	// 82401EE0: 83C1FFD0  lwz r30, -0x30(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) } as u64;
	// 82401EE4: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	// 82401EE8: 7D68F1D6  mullw r11, r8, r30
	ctx.r[11].s64 = (ctx.r[8].s32 as i64) * (ctx.r[30].s32 as i64);
	// 82401EEC: FD606890  fmr f11, f13
	ctx.f[11].f64 = ctx.f[13].f64;
	// 82401EF0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82401EF4: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82401EF8: 8141FFD0  lwz r10, -0x30(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) } as u64;
	// 82401EFC: 2F0B4000  cmpwi cr6, r11, 0x4000
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16384, &mut ctx.xer);
	// 82401F00: 7F8553D6  divw r28, r5, r10
	ctx.r[28].s32 = ctx.r[5].s32 / ctx.r[10].s32;
	// 82401F04: 0CCA0000  twi 6, r10, 0
	// 82401F08: 40980020  bge cr6, 0x82401f28
	if !ctx.cr[6].lt {
	pc = 0x82401F28; continue 'dispatch;
	}
	// 82401F0C: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82401F10: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82401F14: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82401F18: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82401F1C: 7D6BF1D6  mullw r11, r11, r30
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[30].s32 as i64);
	// 82401F20: 2F0B4000  cmpwi cr6, r11, 0x4000
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16384, &mut ctx.xer);
	// 82401F24: 4198FFEC  blt cr6, 0x82401f10
	if ctx.cr[6].lt {
	pc = 0x82401F10; continue 'dispatch;
	}
	// 82401F28: 395C0800  addi r10, r28, 0x800
	ctx.r[10].s64 = ctx.r[28].s64 + 2048;
	// 82401F2C: 7D456670  srawi r5, r10, 0xc
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 12) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[10].s32 >> 12) as i64;
	// 82401F30: 7F053800  cmpw cr6, r5, r7
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82401F34: 409800A4  bge cr6, 0x82401fd8
	if !ctx.cr[6].lt {
	pc = 0x82401FD8; continue 'dispatch;
	}
	// 82401F38: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82401F3C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82401F40: 3D408273  lis r10, -0x7d8d
	ctx.r[10].s64 = -2106392576;
	// 82401F44: C1481850  lfs f10, 0x1850(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(6224 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82401F48: 83AAD6E8  lwz r29, -0x2918(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10520 as u32) ) } as u64;
	// 82401F4C: 3FFF0001  addis r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 65536;
	// 82401F50: D1A1FFD0  stfs f13, -0x30(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), tmp.u32 ) };
	// 82401F54: 3BFF8000  addi r31, r31, -0x8000
	ctx.r[31].s64 = ctx.r[31].s64 + -32768;
	// 82401F58: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82401F5C: 40980058  bge cr6, 0x82401fb4
	if !ctx.cr[6].lt {
	pc = 0x82401FB4; continue 'dispatch;
	}
	// 82401F60: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82401F64: 7D4A202E  lwzx r10, r10, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82401F68: 7D6B3E70  srawi r11, r11, 7
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 7) as i64;
	// 82401F6C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82401F70: 556B15BA  rlwinm r11, r11, 2, 0x16, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82401F74: 7C0A342E  lfsx f0, r10, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401F78: 8141FFD0  lwz r10, -0x30(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) } as u64;
	// 82401F7C: 7D2BEC2E  lfsx f9, r11, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82401F80: ED29502A  fadds f9, f9, f10
	ctx.f[9].f64 = ((ctx.f[9].f64 + ctx.f[10].f64) as f32) as f64;
	// 82401F84: EC090032  fmuls f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82401F88: D001FFD4  stfs f0, -0x2c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-44 as u32), tmp.u32 ) };
	// 82401F8C: 8161FFD4  lwz r11, -0x2c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-44 as u32) ) } as u64;
	// 82401F90: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82401F94: 40990008  ble cr6, 0x82401f9c
	if !ctx.cr[6].gt {
	pc = 0x82401F9C; continue 'dispatch;
	}
	// 82401F98: 9161FFD0  stw r11, -0x30(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[11].u32 ) };
	// 82401F9C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82401FA0: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82401FA4: 7D4B202E  lwzx r10, r11, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82401FA8: 7D6AF1D6  mullw r11, r10, r30
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[30].s32 as i64);
	// 82401FAC: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82401FB0: 4198FFB8  blt cr6, 0x82401f68
	if ctx.cr[6].lt {
	pc = 0x82401F68; continue 'dispatch;
	}
	// 82401FB4: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82401FB8: C121FFD0  lfs f9, -0x30(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82401FBC: 7C63E214  add r3, r3, r28
	ctx.r[3].u64 = ctx.r[3].u64 + ctx.r[28].u64;
	// 82401FC0: 7C656670  srawi r5, r3, 0xc
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 12) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[3].s32 >> 12) as i64;
	// 82401FC4: 7C0A342E  lfsx f0, r10, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401FC8: 7F053800  cmpw cr6, r5, r7
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82401FCC: ED80627A  fmadds f12, f0, f9, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64);
	// 82401FD0: ED60583A  fmadds f11, f0, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82401FD4: 4198FF78  blt cr6, 0x82401f4c
	if ctx.cr[6].lt {
	pc = 0x82401F4C; continue 'dispatch;
	}
	// 82401FD8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401FDC: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401FE0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401FE4: C1AB2418  lfs f13, 0x2418(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401FE8: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82401FEC: EC0C6838  fmsubs f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82401FF0: EC2000B2  fmuls f1, f0, f2
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 82401FF4: 48133114  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401FF8 size=164
    let mut pc: u32 = 0x82401FF8;
    'dispatch: loop {
        match pc {
            0x82401FF8 => {
    //   block [0x82401FF8..0x8240209C)
	// 82401FF8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82401FFC: FF021800  fcmpu cr6, f2, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[3].f64);
	// 82402000: 41990094  bgt cr6, 0x82402094
	if ctx.cr[6].gt {
	pc = 0x82402094; continue 'dispatch;
	}
	// 82402004: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82402008: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240200C: 3C808273  lis r4, -0x7d8d
	ctx.r[4].s64 = -2106392576;
	// 82402010: C189BFFC  lfs f12, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82402014: C1AB2A2C  lfs f13, 0x2a2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10796 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82402018: ED62637A  fmadds f11, f2, f13, f12
	ctx.f[11].f64 = (((ctx.f[2].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 8240201C: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 82402020: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82402024: FC002090  fmr f0, f4
	ctx.f[0].f64 = ctx.f[4].f64;
	// 82402028: FD60581E  fctiwz f11, f11
	ctx.f[11].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 8240202C: 7D605FAE  stfiwx f11, 0, r11
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82402030: 40990040  ble cr6, 0x82402070
	if !ctx.cr[6].gt {
	pc = 0x82402070; continue 'dispatch;
	}
	// 82402034: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82402038: 7CA85050  subf r5, r8, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8240203C: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82402040: 7C65582E  lwzx r3, r5, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82402044: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82402048: 83E1FFF0  lwz r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 8240204C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82402050: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82402054: 7C63F9D6  mullw r3, r3, r31
	ctx.r[3].s64 = (ctx.r[3].s32 as i64) * (ctx.r[31].s32 as i64);
	// 82402058: 83E4D6E8  lwz r31, -0x2918(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-10520 as u32) ) } as u64;
	// 8240205C: 3C630080  addis r3, r3, 0x80
	ctx.r[3].s64 = ctx.r[3].s64 + 8388608;
	// 82402060: 546355BA  rlwinm r3, r3, 0xa, 0x16, 0x1d
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x003FFFFFu64;
	// 82402064: 7D43FC2E  lfsx f10, r3, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82402068: EC0A02FA  fmadds f0, f10, f11, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 8240206C: 4082FFD4  bne 0x82402040
	if !ctx.cr[0].eq {
	pc = 0x82402040; continue 'dispatch;
	}
	// 82402070: C1660000  lfs f11, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82402074: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82402078: 40990010  ble cr6, 0x82402088
	if !ctx.cr[6].gt {
	pc = 0x82402088; continue 'dispatch;
	}
	// 8240207C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82402080: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82402084: D04B0000  stfs f2, 0(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82402088: EC41102A  fadds f2, f1, f2
	ctx.f[2].f64 = ((ctx.f[1].f64 + ctx.f[2].f64) as f32) as f64;
	// 8240208C: FF021800  fcmpu cr6, f2, f3
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[3].f64);
	// 82402090: 4099FF88  ble cr6, 0x82402018
	if !ctx.cr[6].gt {
	pc = 0x82402018; continue 'dispatch;
	}
	// 82402094: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82402098: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824020A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824020A0 size=100
    let mut pc: u32 = 0x824020A0;
    'dispatch: loop {
        match pc {
            0x824020A0 => {
    //   block [0x824020A0..0x82402104)
	// 824020A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824020A4: 48133009  bl 0x825350ac
	ctx.lr = 0x824020A8;
	sub_82535080(ctx, base);
	// 824020A8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824020AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824020B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824020B4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 824020B8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 824020BC: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 824020C0: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 824020C4: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 824020C8: 4BFC0299  bl 0x823c2360
	ctx.lr = 0x824020CC;
	sub_823C2360(ctx, base);
	// 824020CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824020D0: 4082002C  bne 0x824020fc
	if !ctx.cr[0].eq {
	pc = 0x824020FC; continue 'dispatch;
	}
	// 824020D4: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 824020D8: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 824020DC: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 824020E0: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 824020E4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 824020E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 824020EC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 824020F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824020F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824020F8: 4830BB05  bl 0x8270dbfc
	ctx.lr = 0x824020FC;
	// extern call 0x8270DBFC  crate::xam::XamUserReadProfileSettings
	crate::xam::XamUserReadProfileSettings(ctx, base);
	// 824020FC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82402100: 48132FFC  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82402108 size=108
    let mut pc: u32 = 0x82402108;
    'dispatch: loop {
        match pc {
            0x82402108 => {
    //   block [0x82402108..0x82402174)
	// 82402108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240210C: 48132F9D  bl 0x825350a8
	ctx.lr = 0x82402110;
	sub_82535080(ctx, base);
	// 82402110: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82402114: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82402118: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8240211C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82402120: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82402124: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82402128: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 8240212C: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 82402130: 7D585378  mr r24, r10
	ctx.r[24].u64 = ctx.r[10].u64;
	// 82402134: 4BFC022D  bl 0x823c2360
	ctx.lr = 0x82402138;
	sub_823C2360(ctx, base);
	// 82402138: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8240213C: 40820030  bne 0x8240216c
	if !ctx.cr[0].eq {
	pc = 0x8240216C; continue 'dispatch;
	}
	// 82402140: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82402144: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 82402148: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 8240214C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82402150: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82402154: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82402158: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8240215C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82402160: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82402164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82402168: 4830BA95  bl 0x8270dbfc
	ctx.lr = 0x8240216C;
	// extern call 0x8270DBFC  crate::xam::XamUserReadProfileSettings
	crate::xam::XamUserReadProfileSettings(ctx, base);
	// 8240216C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82402170: 48132F88  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82402178 size=72
    let mut pc: u32 = 0x82402178;
    'dispatch: loop {
        match pc {
            0x82402178 => {
    //   block [0x82402178..0x824021C0)
	// 82402178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240217C: 48132F3D  bl 0x825350b8
	ctx.lr = 0x82402180;
	sub_82535080(ctx, base);
	// 82402180: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82402184: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82402188: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8240218C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82402190: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82402194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82402198: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8240219C: 4830AF71  bl 0x8270d10c
	ctx.lr = 0x824021A0;
	// extern call 0x8270D10C  crate::xam::XamUserGetXUID
	crate::xam::XamUserGetXUID(ctx, base);
	// 824021A0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 824021A4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 824021A8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 824021AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824021B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824021B4: 4830BA99  bl 0x8270dc4c
	ctx.lr = 0x824021B8;
	// extern call 0x8270DC4C  crate::xam::XamUserWriteProfileSettings
	crate::xam::XamUserWriteProfileSettings(ctx, base);
	// 824021B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824021BC: 48132F4C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824021C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824021C0 size=428
    let mut pc: u32 = 0x824021C0;
    'dispatch: loop {
        match pc {
            0x824021C0 => {
    //   block [0x824021C0..0x8240236C)
	// 824021C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824021C4: 48132EDD  bl 0x825350a0
	ctx.lr = 0x824021C8;
	sub_82535080(ctx, base);
	// 824021C8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824021CC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824021D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824021D4: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 824021D8: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 824021DC: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 824021E0: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 824021E4: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 824021E8: 7D565378  mr r22, r10
	ctx.r[22].u64 = ctx.r[10].u64;
	// 824021EC: 2B1D0004  cmplwi cr6, r29, 4
	ctx.cr[6].compare_u32(ctx.r[29].u32, 4 as u32, &mut ctx.xer);
	// 824021F0: 4098016C  bge cr6, 0x8240235c
	if !ctx.cr[6].lt {
	pc = 0x8240235C; continue 'dispatch;
	}
	// 824021F4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 824021F8: 419A0164  beq cr6, 0x8240235c
	if ctx.cr[6].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	// 824021FC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82402200: 419A015C  beq cr6, 0x8240235c
	if ctx.cr[6].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	// 82402204: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 82402208: 419A0154  beq cr6, 0x8240235c
	if ctx.cr[6].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	// 8240220C: 57EA0032  rlwinm r10, r31, 0, 0, 0x19
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 82402210: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82402214: 91760000  stw r11, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82402218: 554A0625  rlwinm. r10, r10, 0, 0x18, 0x12
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8240221C: 40820140  bne 0x8240235c
	if !ctx.cr[0].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	// 82402220: 57EA0739  rlwinm. r10, r31, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82402224: 4182000C  beq 0x82402230
	if ctx.cr[0].eq {
	pc = 0x82402230; continue 'dispatch;
	}
	// 82402228: 57EB06B5  rlwinm. r11, r31, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240222C: 41820130  beq 0x8240235c
	if ctx.cr[0].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	// 82402230: 57EB06F7  rlwinm. r11, r31, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82402234: 4182000C  beq 0x82402240
	if ctx.cr[0].eq {
	pc = 0x82402240; continue 'dispatch;
	}
	// 82402238: 57E9077B  rlwinm. r9, r31, 0, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8240223C: 41820120  beq 0x8240235c
	if ctx.cr[0].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	// 82402240: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82402244: 419A000C  beq cr6, 0x82402250
	if ctx.cr[6].eq {
	pc = 0x82402250; continue 'dispatch;
	}
	// 82402248: 57EB06B5  rlwinm. r11, r31, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240224C: 41820110  beq 0x8240235c
	if ctx.cr[0].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	// 82402250: 57EB07FF  clrlwi. r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82402254: 41820010  beq 0x82402264
	if ctx.cr[0].eq {
	pc = 0x82402264; continue 'dispatch;
	}
	// 82402258: 73EB002C  andi. r11, r31, 0x2c
	ctx.r[11].u64 = ctx.r[31].u64 & 44;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240225C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82402260: 418200FC  beq 0x8240235c
	if ctx.cr[0].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	// 82402264: 57EB052F  rlwinm. r11, r31, 0, 0x14, 0x17
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82402268: 4182003C  beq 0x824022a4
	if ctx.cr[0].eq {
	pc = 0x824022A4; continue 'dispatch;
	}
	// 8240226C: 73E9000A  andi. r9, r31, 0xa
	ctx.r[9].u64 = ctx.r[31].u64 & 10;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82402270: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82402274: 418200E8  beq 0x8240235c
	if ctx.cr[0].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	// 82402278: 57E907BD  rlwinm. r9, r31, 0, 0x1e, 0x1e
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8240227C: 40820018  bne 0x82402294
	if !ctx.cr[0].eq {
	pc = 0x82402294; continue 'dispatch;
	}
	// 82402280: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82402284: 419A0010  beq cr6, 0x82402294
	if ctx.cr[6].eq {
	pc = 0x82402294; continue 'dispatch;
	}
	// 82402288: 57EA056A  rlwinm r10, r31, 0, 0x15, 0x15
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 8240228C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82402290: 409A00CC  bne cr6, 0x8240235c
	if !ctx.cr[6].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	// 82402294: 57EB05AD  rlwinm. r11, r31, 0, 0x16, 0x16
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82402298: 4182000C  beq 0x824022a4
	if ctx.cr[0].eq {
	pc = 0x824022A4; continue 'dispatch;
	}
	// 8240229C: 57EB0529  rlwinm. r11, r31, 0, 0x14, 0x14
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824022A0: 408200BC  bne 0x8240235c
	if !ctx.cr[0].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	// 824022A4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 824022A8: 4830B9C5  bl 0x8270dc6c
	ctx.lr = 0x824022AC;
	// extern call 0x8270DC6C  crate::xam::XamSessionCreateHandle
	crate::xam::XamSessionCreateHandle(ctx, base);
	// 824022AC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824022B0: 408200B0  bne 0x82402360
	if !ctx.cr[0].eq {
	pc = 0x82402360; continue 'dispatch;
	}
	// 824022B4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 824022B8: 80760000  lwz r3, 0(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 824022BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824022C0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 824022C4: 4830B999  bl 0x8270dc5c
	ctx.lr = 0x824022C8;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 824022C8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824022CC: 40820094  bne 0x82402360
	if !ctx.cr[0].eq {
	pc = 0x82402360; continue 'dispatch;
	}
	// 824022D0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824022D4: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 824022D8: 38E0001C  li r7, 0x1c
	ctx.r[7].s64 = 28;
	// 824022DC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 824022E0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 824022E4: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 824022E8: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 824022EC: 92E1006C  stw r23, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[23].u32 ) };
	// 824022F0: 60840010  ori r4, r4, 0x10
	ctx.r[4].u64 = ctx.r[4].u64 | 16;
	// 824022F4: 93010068  stw r24, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[24].u32 ) };
	// 824022F8: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 824022FC: 93410074  stw r26, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[26].u32 ) };
	// 82402300: 93610078  stw r27, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[27].u32 ) };
	// 82402304: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82402308: 4830AD75  bl 0x8270d07c
	ctx.lr = 0x8240230C;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 8240230C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402310: 4080000C  bge 0x8240231c
	if !ctx.cr[0].lt {
	pc = 0x8240231C; continue 'dispatch;
	}
	// 82402314: 3BC0065B  li r30, 0x65b
	ctx.r[30].s64 = 1627;
	// 82402318: 48000034  b 0x8240234c
	pc = 0x8240234C; continue 'dispatch;
	// 8240231C: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82402320: 409A0018  bne cr6, 0x82402338
	if !ctx.cr[6].eq {
	pc = 0x82402338; continue 'dispatch;
	}
	// 82402324: 4BFC001D  bl 0x823c2340
	ctx.lr = 0x82402328;
	sub_823C2340(ctx, base);
	// 82402328: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 8240232C: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82402330: 717E065B  andi. r30, r11, 0x65b
	ctx.r[30].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82402334: 48000008  b 0x8240233c
	pc = 0x8240233C; continue 'dispatch;
	// 82402338: 3BC003E5  li r30, 0x3e5
	ctx.r[30].s64 = 997;
	// 8240233C: 2B1E03E5  cmplwi cr6, r30, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[30].u32, 997 as u32, &mut ctx.xer);
	// 82402340: 419A0020  beq cr6, 0x82402360
	if ctx.cr[6].eq {
	pc = 0x82402360; continue 'dispatch;
	}
	// 82402344: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82402348: 419A0018  beq cr6, 0x82402360
	if ctx.cr[6].eq {
	pc = 0x82402360; continue 'dispatch;
	}
	// 8240234C: 80760000  lwz r3, 0(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 82402350: 4BFBE609  bl 0x823c0958
	ctx.lr = 0x82402354;
	sub_823C0958(ctx, base);
	// 82402354: 93960000  stw r28, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82402358: 48000008  b 0x82402360
	pc = 0x82402360; continue 'dispatch;
	// 8240235C: 3BC00057  li r30, 0x57
	ctx.r[30].s64 = 87;
	// 82402360: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82402364: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82402368: 48132D88  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82402370 size=184
    let mut pc: u32 = 0x82402370;
    'dispatch: loop {
        match pc {
            0x82402370 => {
    //   block [0x82402370..0x82402428)
	// 82402370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82402374: 48132D41  bl 0x825350b4
	ctx.lr = 0x82402378;
	sub_82535080(ctx, base);
	// 82402378: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240237C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82402380: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82402384: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82402388: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 8240238C: 57EB05AD  rlwinm. r11, r31, 0, 0x16, 0x16
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82402390: 41820014  beq 0x824023a4
	if ctx.cr[0].eq {
	pc = 0x824023A4; continue 'dispatch;
	}
	// 82402394: 57EB0529  rlwinm. r11, r31, 0, 0x14, 0x14
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82402398: 4182000C  beq 0x824023a4
	if ctx.cr[0].eq {
	pc = 0x824023A4; continue 'dispatch;
	}
	// 8240239C: 3BC00057  li r30, 0x57
	ctx.r[30].s64 = 87;
	// 824023A0: 4800007C  b 0x8240241c
	pc = 0x8240241C; continue 'dispatch;
	// 824023A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824023A8: 4830B8B5  bl 0x8270dc5c
	ctx.lr = 0x824023AC;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 824023AC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824023B0: 4082006C  bne 0x8240241c
	if !ctx.cr[0].eq {
	pc = 0x8240241C; continue 'dispatch;
	}
	// 824023B4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824023B8: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 824023BC: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 824023C0: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 824023C4: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 824023C8: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 824023CC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 824023D0: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 824023D4: 60840018  ori r4, r4, 0x18
	ctx.r[4].u64 = ctx.r[4].u64 | 24;
	// 824023D8: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 824023DC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 824023E0: 4830AC9D  bl 0x8270d07c
	ctx.lr = 0x824023E4;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 824023E4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824023E8: 4080000C  bge 0x824023f4
	if !ctx.cr[0].lt {
	pc = 0x824023F4; continue 'dispatch;
	}
	// 824023EC: 3BC0065B  li r30, 0x65b
	ctx.r[30].s64 = 1627;
	// 824023F0: 48000024  b 0x82402414
	pc = 0x82402414; continue 'dispatch;
	// 824023F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 824023F8: 409A0018  bne cr6, 0x82402410
	if !ctx.cr[6].eq {
	pc = 0x82402410; continue 'dispatch;
	}
	// 824023FC: 4BFBFF45  bl 0x823c2340
	ctx.lr = 0x82402400;
	sub_823C2340(ctx, base);
	// 82402400: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82402404: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82402408: 717E065B  andi. r30, r11, 0x65b
	ctx.r[30].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8240240C: 48000008  b 0x82402414
	pc = 0x82402414; continue 'dispatch;
	// 82402410: 3BC003E5  li r30, 0x3e5
	ctx.r[30].s64 = 997;
	// 82402414: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402418: 4830B035  bl 0x8270d44c
	ctx.lr = 0x8240241C;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	// 8240241C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82402420: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82402424: 48132CE0  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82402428 size=172
    let mut pc: u32 = 0x82402428;
    'dispatch: loop {
        match pc {
            0x82402428 => {
    //   block [0x82402428..0x824024D4)
	// 82402428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240242C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82402430: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82402434: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82402438: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240243C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82402440: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82402444: 4830B819  bl 0x8270dc5c
	ctx.lr = 0x82402448;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 82402448: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8240244C: 4082006C  bne 0x824024b8
	if !ctx.cr[0].eq {
	pc = 0x824024B8; continue 'dispatch;
	}
	// 82402450: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402454: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 82402458: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8240245C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82402460: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82402464: 60840011  ori r4, r4, 0x11
	ctx.r[4].u64 = ctx.r[4].u64 | 17;
	// 82402468: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8240246C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82402470: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 82402474: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82402478: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 8240247C: 4830AC01  bl 0x8270d07c
	ctx.lr = 0x82402480;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 82402480: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402484: 4080000C  bge 0x82402490
	if !ctx.cr[0].lt {
	pc = 0x82402490; continue 'dispatch;
	}
	// 82402488: 3BE0065B  li r31, 0x65b
	ctx.r[31].s64 = 1627;
	// 8240248C: 48000024  b 0x824024b0
	pc = 0x824024B0; continue 'dispatch;
	// 82402490: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82402494: 409A0018  bne cr6, 0x824024ac
	if !ctx.cr[6].eq {
	pc = 0x824024AC; continue 'dispatch;
	}
	// 82402498: 4BFBFEA9  bl 0x823c2340
	ctx.lr = 0x8240249C;
	sub_823C2340(ctx, base);
	// 8240249C: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 824024A0: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 824024A4: 717F065B  andi. r31, r11, 0x65b
	ctx.r[31].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824024A8: 48000008  b 0x824024b0
	pc = 0x824024B0; continue 'dispatch;
	// 824024AC: 3BE003E5  li r31, 0x3e5
	ctx.r[31].s64 = 997;
	// 824024B0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824024B4: 4830AF99  bl 0x8270d44c
	ctx.lr = 0x824024B8;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	// 824024B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824024BC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824024C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824024C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824024C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824024CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824024D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824024D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824024D8 size=168
    let mut pc: u32 = 0x824024D8;
    'dispatch: loop {
        match pc {
            0x824024D8 => {
    //   block [0x824024D8..0x82402580)
	// 824024D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824024DC: 48132BD9  bl 0x825350b4
	ctx.lr = 0x824024E0;
	sub_82535080(ctx, base);
	// 824024E0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824024E4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824024E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824024EC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 824024F0: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 824024F4: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 824024F8: 4830B765  bl 0x8270dc5c
	ctx.lr = 0x824024FC;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 824024FC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402500: 40820074  bne 0x82402574
	if !ctx.cr[0].eq {
	pc = 0x82402574; continue 'dispatch;
	}
	// 82402504: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402508: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 8240250C: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 82402510: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82402514: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82402518: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 8240251C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82402520: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 82402524: 60840012  ori r4, r4, 0x12
	ctx.r[4].u64 = ctx.r[4].u64 | 18;
	// 82402528: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8240252C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82402530: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 82402534: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82402538: 4830AB45  bl 0x8270d07c
	ctx.lr = 0x8240253C;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 8240253C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402540: 4080000C  bge 0x8240254c
	if !ctx.cr[0].lt {
	pc = 0x8240254C; continue 'dispatch;
	}
	// 82402544: 3BE0065B  li r31, 0x65b
	ctx.r[31].s64 = 1627;
	// 82402548: 48000024  b 0x8240256c
	pc = 0x8240256C; continue 'dispatch;
	// 8240254C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82402550: 409A0018  bne cr6, 0x82402568
	if !ctx.cr[6].eq {
	pc = 0x82402568; continue 'dispatch;
	}
	// 82402554: 4BFBFDED  bl 0x823c2340
	ctx.lr = 0x82402558;
	sub_823C2340(ctx, base);
	// 82402558: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 8240255C: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82402560: 717F065B  andi. r31, r11, 0x65b
	ctx.r[31].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402564: 48000008  b 0x8240256c
	pc = 0x8240256C; continue 'dispatch;
	// 82402568: 3BE003E5  li r31, 0x3e5
	ctx.r[31].s64 = 997;
	// 8240256C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402570: 4830AEDD  bl 0x8270d44c
	ctx.lr = 0x82402574;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	// 82402574: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82402578: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8240257C: 48132B88  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82402580 size=168
    let mut pc: u32 = 0x82402580;
    'dispatch: loop {
        match pc {
            0x82402580 => {
    //   block [0x82402580..0x82402628)
	// 82402580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82402584: 48132B31  bl 0x825350b4
	ctx.lr = 0x82402588;
	sub_82535080(ctx, base);
	// 82402588: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240258C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82402590: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82402594: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82402598: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 8240259C: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 824025A0: 4830B6BD  bl 0x8270dc5c
	ctx.lr = 0x824025A4;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 824025A4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824025A8: 40820074  bne 0x8240261c
	if !ctx.cr[0].eq {
	pc = 0x8240261C; continue 'dispatch;
	}
	// 824025AC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824025B0: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 824025B4: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 824025B8: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 824025BC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 824025C0: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 824025C4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 824025C8: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 824025CC: 60840012  ori r4, r4, 0x12
	ctx.r[4].u64 = ctx.r[4].u64 | 18;
	// 824025D0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 824025D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824025D8: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 824025DC: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 824025E0: 4830AA9D  bl 0x8270d07c
	ctx.lr = 0x824025E4;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 824025E4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824025E8: 4080000C  bge 0x824025f4
	if !ctx.cr[0].lt {
	pc = 0x824025F4; continue 'dispatch;
	}
	// 824025EC: 3BE0065B  li r31, 0x65b
	ctx.r[31].s64 = 1627;
	// 824025F0: 48000024  b 0x82402614
	pc = 0x82402614; continue 'dispatch;
	// 824025F4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824025F8: 409A0018  bne cr6, 0x82402610
	if !ctx.cr[6].eq {
	pc = 0x82402610; continue 'dispatch;
	}
	// 824025FC: 4BFBFD45  bl 0x823c2340
	ctx.lr = 0x82402600;
	sub_823C2340(ctx, base);
	// 82402600: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82402604: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82402608: 717F065B  andi. r31, r11, 0x65b
	ctx.r[31].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8240260C: 48000008  b 0x82402614
	pc = 0x82402614; continue 'dispatch;
	// 82402610: 3BE003E5  li r31, 0x3e5
	ctx.r[31].s64 = 997;
	// 82402614: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402618: 4830AE35  bl 0x8270d44c
	ctx.lr = 0x8240261C;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	// 8240261C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82402620: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82402624: 48132AE0  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82402628 size=164
    let mut pc: u32 = 0x82402628;
    'dispatch: loop {
        match pc {
            0x82402628 => {
    //   block [0x82402628..0x824026CC)
	// 82402628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240262C: 48132A8D  bl 0x825350b8
	ctx.lr = 0x82402630;
	sub_82535080(ctx, base);
	// 82402630: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82402634: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82402638: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8240263C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82402640: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82402644: 4830B619  bl 0x8270dc5c
	ctx.lr = 0x82402648;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 82402648: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8240264C: 40820074  bne 0x824026c0
	if !ctx.cr[0].eq {
	pc = 0x824026C0; continue 'dispatch;
	}
	// 82402650: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402654: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 82402658: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 8240265C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82402660: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82402664: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 82402668: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8240266C: 60840013  ori r4, r4, 0x13
	ctx.r[4].u64 = ctx.r[4].u64 | 19;
	// 82402670: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82402674: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82402678: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 8240267C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82402680: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82402684: 4830A9F9  bl 0x8270d07c
	ctx.lr = 0x82402688;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 82402688: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8240268C: 4080000C  bge 0x82402698
	if !ctx.cr[0].lt {
	pc = 0x82402698; continue 'dispatch;
	}
	// 82402690: 3BE0065B  li r31, 0x65b
	ctx.r[31].s64 = 1627;
	// 82402694: 48000024  b 0x824026b8
	pc = 0x824026B8; continue 'dispatch;
	// 82402698: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8240269C: 409A0018  bne cr6, 0x824026b4
	if !ctx.cr[6].eq {
	pc = 0x824026B4; continue 'dispatch;
	}
	// 824026A0: 4BFBFCA1  bl 0x823c2340
	ctx.lr = 0x824026A4;
	sub_823C2340(ctx, base);
	// 824026A4: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 824026A8: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 824026AC: 717F065B  andi. r31, r11, 0x65b
	ctx.r[31].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824026B0: 48000008  b 0x824026b8
	pc = 0x824026B8; continue 'dispatch;
	// 824026B4: 3BE003E5  li r31, 0x3e5
	ctx.r[31].s64 = 997;
	// 824026B8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824026BC: 4830AD91  bl 0x8270d44c
	ctx.lr = 0x824026C0;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	// 824026C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824026C4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824026C8: 48132A40  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824026D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824026D0 size=164
    let mut pc: u32 = 0x824026D0;
    'dispatch: loop {
        match pc {
            0x824026D0 => {
    //   block [0x824026D0..0x82402774)
	// 824026D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824026D4: 481329E5  bl 0x825350b8
	ctx.lr = 0x824026D8;
	sub_82535080(ctx, base);
	// 824026D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824026DC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824026E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824026E4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 824026E8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 824026EC: 4830B571  bl 0x8270dc5c
	ctx.lr = 0x824026F0;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 824026F0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824026F4: 40820074  bne 0x82402768
	if !ctx.cr[0].eq {
	pc = 0x82402768; continue 'dispatch;
	}
	// 824026F8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824026FC: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 82402700: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 82402704: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82402708: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 8240270C: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82402710: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82402714: 60840013  ori r4, r4, 0x13
	ctx.r[4].u64 = ctx.r[4].u64 | 19;
	// 82402718: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8240271C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82402720: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 82402724: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82402728: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8240272C: 4830A951  bl 0x8270d07c
	ctx.lr = 0x82402730;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 82402730: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402734: 4080000C  bge 0x82402740
	if !ctx.cr[0].lt {
	pc = 0x82402740; continue 'dispatch;
	}
	// 82402738: 3BE0065B  li r31, 0x65b
	ctx.r[31].s64 = 1627;
	// 8240273C: 48000024  b 0x82402760
	pc = 0x82402760; continue 'dispatch;
	// 82402740: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82402744: 409A0018  bne cr6, 0x8240275c
	if !ctx.cr[6].eq {
	pc = 0x8240275C; continue 'dispatch;
	}
	// 82402748: 4BFBFBF9  bl 0x823c2340
	ctx.lr = 0x8240274C;
	sub_823C2340(ctx, base);
	// 8240274C: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82402750: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82402754: 717F065B  andi. r31, r11, 0x65b
	ctx.r[31].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402758: 48000008  b 0x82402760
	pc = 0x82402760; continue 'dispatch;
	// 8240275C: 3BE003E5  li r31, 0x3e5
	ctx.r[31].s64 = 997;
	// 82402760: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402764: 4830ACE9  bl 0x8270d44c
	ctx.lr = 0x82402768;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	// 82402768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8240276C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82402770: 48132998  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82402778 size=216
    let mut pc: u32 = 0x82402778;
    'dispatch: loop {
        match pc {
            0x82402778 => {
    //   block [0x82402778..0x82402850)
	// 82402778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240277C: 48132935  bl 0x825350b0
	ctx.lr = 0x82402780;
	sub_82535080(ctx, base);
	// 82402780: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82402784: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82402788: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8240278C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82402790: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82402794: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 82402798: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8240279C: 419A009C  beq cr6, 0x82402838
	if ctx.cr[6].eq {
	pc = 0x82402838; continue 'dispatch;
	}
	// 824027A0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824027A4: 2B0B0E08  cmplwi cr6, r11, 0xe08
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3592 as u32, &mut ctx.xer);
	// 824027A8: 41980090  blt cr6, 0x82402838
	if ctx.cr[6].lt {
	pc = 0x82402838; continue 'dispatch;
	}
	// 824027AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824027B0: 4830B4AD  bl 0x8270dc5c
	ctx.lr = 0x824027B4;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 824027B4: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 824027B8: 4082008C  bne 0x82402844
	if !ctx.cr[0].eq {
	pc = 0x82402844; continue 'dispatch;
	}
	// 824027BC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824027C0: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 824027C4: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 824027C8: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 824027CC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 824027D0: FB410068  std r26, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u64 ) };
	// 824027D4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 824027D8: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 824027DC: 6084001A  ori r4, r4, 0x1a
	ctx.r[4].u64 = ctx.r[4].u64 | 26;
	// 824027E0: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 824027E4: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 824027E8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824027EC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 824027F0: 3960012C  li r11, 0x12c
	ctx.r[11].s64 = 300;
	// 824027F4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 824027F8: 4830A885  bl 0x8270d07c
	ctx.lr = 0x824027FC;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 824027FC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402800: 4080000C  bge 0x8240280c
	if !ctx.cr[0].lt {
	pc = 0x8240280C; continue 'dispatch;
	}
	// 82402804: 3BA0065B  li r29, 0x65b
	ctx.r[29].s64 = 1627;
	// 82402808: 48000024  b 0x8240282c
	pc = 0x8240282C; continue 'dispatch;
	// 8240280C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82402810: 409A0018  bne cr6, 0x82402828
	if !ctx.cr[6].eq {
	pc = 0x82402828; continue 'dispatch;
	}
	// 82402814: 4BFBFB2D  bl 0x823c2340
	ctx.lr = 0x82402818;
	sub_823C2340(ctx, base);
	// 82402818: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 8240281C: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82402820: 717D065B  andi. r29, r11, 0x65b
	ctx.r[29].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82402824: 48000008  b 0x8240282c
	pc = 0x8240282C; continue 'dispatch;
	// 82402828: 3BA003E5  li r29, 0x3e5
	ctx.r[29].s64 = 997;
	// 8240282C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402830: 4830AC1D  bl 0x8270d44c
	ctx.lr = 0x82402834;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	// 82402834: 48000010  b 0x82402844
	pc = 0x82402844; continue 'dispatch;
	// 82402838: 39600E08  li r11, 0xe08
	ctx.r[11].s64 = 3592;
	// 8240283C: 3BA0007A  li r29, 0x7a
	ctx.r[29].s64 = 122;
	// 82402840: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82402844: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82402848: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8240284C: 481328B4  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82402850 size=152
    let mut pc: u32 = 0x82402850;
    'dispatch: loop {
        match pc {
            0x82402850 => {
    //   block [0x82402850..0x824028E8)
	// 82402850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82402854: 48132869  bl 0x825350bc
	ctx.lr = 0x82402858;
	sub_82535080(ctx, base);
	// 82402858: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240285C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82402860: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82402864: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82402868: 4830B3F5  bl 0x8270dc5c
	ctx.lr = 0x8240286C;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 8240286C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402870: 4082006C  bne 0x824028dc
	if !ctx.cr[0].eq {
	pc = 0x824028DC; continue 'dispatch;
	}
	// 82402874: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402878: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 8240287C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82402880: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82402884: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82402888: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8240288C: 60840014  ori r4, r4, 0x14
	ctx.r[4].u64 = ctx.r[4].u64 | 20;
	// 82402890: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82402894: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82402898: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 8240289C: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 824028A0: 4830A7DD  bl 0x8270d07c
	ctx.lr = 0x824028A4;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 824028A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824028A8: 4080000C  bge 0x824028b4
	if !ctx.cr[0].lt {
	pc = 0x824028B4; continue 'dispatch;
	}
	// 824028AC: 3BE0065B  li r31, 0x65b
	ctx.r[31].s64 = 1627;
	// 824028B0: 48000024  b 0x824028d4
	pc = 0x824028D4; continue 'dispatch;
	// 824028B4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824028B8: 409A0018  bne cr6, 0x824028d0
	if !ctx.cr[6].eq {
	pc = 0x824028D0; continue 'dispatch;
	}
	// 824028BC: 4BFBFA85  bl 0x823c2340
	ctx.lr = 0x824028C0;
	sub_823C2340(ctx, base);
	// 824028C0: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 824028C4: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 824028C8: 717F065B  andi. r31, r11, 0x65b
	ctx.r[31].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824028CC: 48000008  b 0x824028d4
	pc = 0x824028D4; continue 'dispatch;
	// 824028D0: 3BE003E5  li r31, 0x3e5
	ctx.r[31].s64 = 997;
	// 824028D4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824028D8: 4830AB75  bl 0x8270d44c
	ctx.lr = 0x824028DC;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	// 824028DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824028E0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824028E4: 48132828  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824028E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824028E8 size=172
    let mut pc: u32 = 0x824028E8;
    'dispatch: loop {
        match pc {
            0x824028E8 => {
    //   block [0x824028E8..0x82402994)
	// 824028E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824028EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824028F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824028F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824028F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824028FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82402900: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82402904: 4830B359  bl 0x8270dc5c
	ctx.lr = 0x82402908;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 82402908: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8240290C: 4082006C  bne 0x82402978
	if !ctx.cr[0].eq {
	pc = 0x82402978; continue 'dispatch;
	}
	// 82402910: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402914: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 82402918: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8240291C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82402920: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82402924: 60840015  ori r4, r4, 0x15
	ctx.r[4].u64 = ctx.r[4].u64 | 21;
	// 82402928: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8240292C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82402930: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 82402934: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82402938: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 8240293C: 4830A741  bl 0x8270d07c
	ctx.lr = 0x82402940;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 82402940: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402944: 4080000C  bge 0x82402950
	if !ctx.cr[0].lt {
	pc = 0x82402950; continue 'dispatch;
	}
	// 82402948: 3BE0065B  li r31, 0x65b
	ctx.r[31].s64 = 1627;
	// 8240294C: 48000024  b 0x82402970
	pc = 0x82402970; continue 'dispatch;
	// 82402950: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82402954: 409A0018  bne cr6, 0x8240296c
	if !ctx.cr[6].eq {
	pc = 0x8240296C; continue 'dispatch;
	}
	// 82402958: 4BFBF9E9  bl 0x823c2340
	ctx.lr = 0x8240295C;
	sub_823C2340(ctx, base);
	// 8240295C: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82402960: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82402964: 717F065B  andi. r31, r11, 0x65b
	ctx.r[31].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402968: 48000008  b 0x82402970
	pc = 0x82402970; continue 'dispatch;
	// 8240296C: 3BE003E5  li r31, 0x3e5
	ctx.r[31].s64 = 997;
	// 82402970: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402974: 4830AAD9  bl 0x8270d44c
	ctx.lr = 0x82402978;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	// 82402978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8240297C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82402980: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82402984: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82402988: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8240298C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82402990: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82402998 size=240
    let mut pc: u32 = 0x82402998;
    'dispatch: loop {
        match pc {
            0x82402998 => {
    //   block [0x82402998..0x82402A88)
	// 82402998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240299C: 48132709  bl 0x825350a4
	ctx.lr = 0x824029A0;
	sub_82535080(ctx, base);
	// 824029A0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824029A4: 83C10124  lwz r30, 0x124(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 824029A8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 824029AC: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 824029B0: 1D7F052E  mulli r11, r31, 0x52e
	ctx.r[11].s64 = ctx.r[31].s64 * 1326;
	// 824029B4: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824029B8: 3AEB0008  addi r23, r11, 8
	ctx.r[23].s64 = ctx.r[11].s64 + 8;
	// 824029BC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 824029C0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824029C4: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 824029C8: 7F07B840  cmplw cr6, r7, r23
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[23].u32, &mut ctx.xer);
	// 824029CC: 419800AC  blt cr6, 0x82402a78
	if ctx.cr[6].lt {
	pc = 0x82402A78; continue 'dispatch;
	}
	// 824029D0: 8161012C  lwz r11, 0x12c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(300 as u32) ) } as u64;
	// 824029D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824029D8: 419A00A0  beq cr6, 0x82402a78
	if ctx.cr[6].eq {
	pc = 0x82402A78; continue 'dispatch;
	}
	// 824029DC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 824029E0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 824029E4: 83010134  lwz r24, 0x134(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 824029E8: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 824029EC: 38E00024  li r7, 0x24
	ctx.r[7].s64 = 36;
	// 824029F0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 824029F4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 824029F8: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 824029FC: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82402A00: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82402A04: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82402A08: 6084001C  ori r4, r4, 0x1c
	ctx.r[4].u64 = ctx.r[4].u64 | 28;
	// 82402A0C: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82402A10: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82402A14: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 82402A18: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 82402A1C: B321005C  sth r25, 0x5c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u16 ) };
	// 82402A20: B101005E  sth r8, 0x5e(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(94 as u32), ctx.r[8].u16 ) };
	// 82402A24: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 82402A28: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82402A2C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82402A30: 4830A64D  bl 0x8270d07c
	ctx.lr = 0x82402A34;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 82402A34: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402A38: 4080001C  bge 0x82402a54
	if !ctx.cr[0].lt {
	pc = 0x82402A54; continue 'dispatch;
	}
	// 82402A3C: 3D608015  lis r11, -0x7feb
	ctx.r[11].s64 = -2146107392;
	// 82402A40: 616B5207  ori r11, r11, 0x5207
	ctx.r[11].u64 = ctx.r[11].u64 | 20999;
	// 82402A44: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82402A48: 419A0030  beq cr6, 0x82402a78
	if ctx.cr[6].eq {
	pc = 0x82402A78; continue 'dispatch;
	}
	// 82402A4C: 3860065B  li r3, 0x65b
	ctx.r[3].s64 = 1627;
	// 82402A50: 48000030  b 0x82402a80
	pc = 0x82402A80; continue 'dispatch;
	// 82402A54: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82402A58: 409A0018  bne cr6, 0x82402a70
	if !ctx.cr[6].eq {
	pc = 0x82402A70; continue 'dispatch;
	}
	// 82402A5C: 4BFBF8E5  bl 0x823c2340
	ctx.lr = 0x82402A60;
	sub_823C2340(ctx, base);
	// 82402A60: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82402A64: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82402A68: 7163065B  andi. r3, r11, 0x65b
	ctx.r[3].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82402A6C: 48000014  b 0x82402a80
	pc = 0x82402A80; continue 'dispatch;
	// 82402A70: 386003E5  li r3, 0x3e5
	ctx.r[3].s64 = 997;
	// 82402A74: 4800000C  b 0x82402a80
	pc = 0x82402A80; continue 'dispatch;
	// 82402A78: 92FE0000  stw r23, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82402A7C: 3860007A  li r3, 0x7a
	ctx.r[3].s64 = 122;
	// 82402A80: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82402A84: 48132670  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82402A88 size=192
    let mut pc: u32 = 0x82402A88;
    'dispatch: loop {
        match pc {
            0x82402A88 => {
    //   block [0x82402A88..0x82402B48)
	// 82402A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82402A8C: 48132629  bl 0x825350b4
	ctx.lr = 0x82402A90;
	sub_82535080(ctx, base);
	// 82402A90: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82402A94: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82402A98: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82402A9C: 7BEB8420  rldicl r11, r31, 0x10, 0x30
	ctx.r[11].u64 = ctx.r[31].u64 & 0x0000FFFFFFFFFFFFu64;
	// 82402AA0: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82402AA4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82402AA8: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82402AAC: 556A073E  clrlwi r10, r11, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82402AB0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82402AB4: 2B0A0009  cmplwi cr6, r10, 9
	ctx.cr[6].compare_u32(ctx.r[10].u32, 9 as u32, &mut ctx.xer);
	// 82402AB8: 409A000C  bne cr6, 0x82402ac4
	if !ctx.cr[6].eq {
	pc = 0x82402AC4; continue 'dispatch;
	}
	// 82402ABC: 556B0633  rlwinm. r11, r11, 0, 0x18, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82402AC0: 4082007C  bne 0x82402b3c
	if !ctx.cr[0].eq {
	pc = 0x82402B3C; continue 'dispatch;
	}
	// 82402AC4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82402AC8: 4830B195  bl 0x8270dc5c
	ctx.lr = 0x82402ACC;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 82402ACC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82402AD0: 4082006C  bne 0x82402b3c
	if !ctx.cr[0].eq {
	pc = 0x82402B3C; continue 'dispatch;
	}
	// 82402AD4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402AD8: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 82402ADC: 38E00018  li r7, 0x18
	ctx.r[7].s64 = 24;
	// 82402AE0: FBE10068  std r31, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u64 ) };
	// 82402AE4: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82402AE8: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 82402AEC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82402AF0: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 82402AF4: 60840025  ori r4, r4, 0x25
	ctx.r[4].u64 = ctx.r[4].u64 | 37;
	// 82402AF8: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 82402AFC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82402B00: 4830A57D  bl 0x8270d07c
	ctx.lr = 0x82402B04;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 82402B04: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402B08: 4080000C  bge 0x82402b14
	if !ctx.cr[0].lt {
	pc = 0x82402B14; continue 'dispatch;
	}
	// 82402B0C: 3BC0065B  li r30, 0x65b
	ctx.r[30].s64 = 1627;
	// 82402B10: 48000024  b 0x82402b34
	pc = 0x82402B34; continue 'dispatch;
	// 82402B14: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82402B18: 409A0018  bne cr6, 0x82402b30
	if !ctx.cr[6].eq {
	pc = 0x82402B30; continue 'dispatch;
	}
	// 82402B1C: 4BFBF825  bl 0x823c2340
	ctx.lr = 0x82402B20;
	sub_823C2340(ctx, base);
	// 82402B20: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82402B24: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82402B28: 717E065B  andi. r30, r11, 0x65b
	ctx.r[30].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82402B2C: 48000008  b 0x82402b34
	pc = 0x82402B34; continue 'dispatch;
	// 82402B30: 3BC003E5  li r30, 0x3e5
	ctx.r[30].s64 = 997;
	// 82402B34: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402B38: 4830A915  bl 0x8270d44c
	ctx.lr = 0x82402B3C;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	// 82402B3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82402B40: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82402B44: 481325C0  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82402B48 size=80
    let mut pc: u32 = 0x82402B48;
    'dispatch: loop {
        match pc {
            0x82402B48 => {
    //   block [0x82402B48..0x82402B98)
	// 82402B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82402B4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82402B50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82402B54: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82402B58: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82402B5C: 3C800005  lis r4, 5
	ctx.r[4].s64 = 327680;
	// 82402B60: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82402B64: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82402B68: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82402B6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82402B70: 6084800E  ori r4, r4, 0x800e
	ctx.r[4].u64 = ctx.r[4].u64 | 32782;
	// 82402B74: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82402B78: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 82402B7C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82402B80: 4830B0FD  bl 0x8270dc7c
	ctx.lr = 0x82402B84;
	// extern call 0x8270DC7C  crate::xboxkrnl::XMsgInProcessCall
	crate::xboxkrnl::XMsgInProcessCall(ctx, base);
	// 82402B84: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82402B88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82402B8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82402B90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82402B94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82402B98 size=48
    let mut pc: u32 = 0x82402B98;
    'dispatch: loop {
        match pc {
            0x82402B98 => {
    //   block [0x82402B98..0x82402BC8)
	// 82402B98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82402B9C: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 82402BA0: 7C8807B4  extsw r8, r4
	ctx.r[8].s64 = ctx.r[4].s32 as i64;
	// 82402BA4: 814B0200  lwz r10, 0x200(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(512 as u32) ) } as u64;
	// 82402BA8: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82402BAC: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82402BB0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82402BB4: F90A0008  std r8, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 82402BB8: 806B0200  lwz r3, 0x200(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(512 as u32) ) } as u64;
	// 82402BBC: 39430001  addi r10, r3, 1
	ctx.r[10].s64 = ctx.r[3].s64 + 1;
	// 82402BC0: 914B0200  stw r10, 0x200(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(512 as u32), ctx.r[10].u32 ) };
	// 82402BC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82402BC8 size=352
    let mut pc: u32 = 0x82402BC8;
    'dispatch: loop {
        match pc {
            0x82402BC8 => {
    //   block [0x82402BC8..0x82402D28)
	// 82402BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82402BCC: 481324ED  bl 0x825350b8
	ctx.lr = 0x82402BD0;
	sub_82535080(ctx, base);
	// 82402BD0: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82402BD4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82402BD8: 906102E4  stw r3, 0x2e4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(740 as u32), ctx.r[3].u32 ) };
	// 82402BDC: 908102EC  stw r4, 0x2ec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(748 as u32), ctx.r[4].u32 ) };
	// 82402BE0: 38600206  li r3, 0x206
	ctx.r[3].s64 = 518;
	// 82402BE4: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82402BE8: 90A102F4  stw r5, 0x2f4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(756 as u32), ctx.r[5].u32 ) };
	// 82402BEC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82402BF0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82402BF4: 93C102A0  stw r30, 0x2a0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(672 as u32), ctx.r[30].u32 ) };
	// 82402BF8: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 82402BFC: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82402C00: 48000541  bl 0x82403140
	ctx.lr = 0x82402C04;
	sub_82403140(ctx, base);
	// 82402C04: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402C08: 418000EC  blt 0x82402cf4
	if ctx.cr[0].lt {
	pc = 0x82402CF4; continue 'dispatch;
	}
	// 82402C0C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82402C10: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82402C14: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82402C18: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
	// 82402C1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82402C20: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82402C24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82402C28: 480005A1  bl 0x824031c8
	ctx.lr = 0x82402C2C;
	sub_824031C8(ctx, base);
	// 82402C2C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402C30: 418000C4  blt 0x82402cf4
	if ctx.cr[0].lt {
	pc = 0x82402CF4; continue 'dispatch;
	}
	// 82402C34: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82402C38: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82402C3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82402C40: 4830B05D  bl 0x8270dc9c
	ctx.lr = 0x82402C44;
	// extern call 0x8270DC9C  crate::xam::XamAlloc
	crate::xam::XamAlloc(ctx, base);
	// 82402C44: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402C48: 418000AC  blt 0x82402cf4
	if ctx.cr[0].lt {
	pc = 0x82402CF4; continue 'dispatch;
	}
	// 82402C4C: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 82402C50: 81010084  lwz r8, 0x84(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82402C54: 38E10094  addi r7, r1, 0x94
	ctx.r[7].s64 = ctx.r[1].s64 + 148;
	// 82402C58: 80810088  lwz r4, 0x88(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82402C5C: 3961008C  addi r11, r1, 0x8c
	ctx.r[11].s64 = ctx.r[1].s64 + 140;
	// 82402C60: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82402C64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82402C68: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82402C6C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82402C70: 90C1005C  stw r6, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[6].u32 ) };
	// 82402C74: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82402C78: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82402C7C: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82402C80: 38600206  li r3, 0x206
	ctx.r[3].s64 = 518;
	// 82402C84: 80E10080  lwz r7, 0x80(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82402C88: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82402C8C: 480005DD  bl 0x82403268
	ctx.lr = 0x82402C90;
	sub_82403268(ctx, base);
	// 82402C90: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402C94: 41800060  blt 0x82402cf4
	if ctx.cr[0].lt {
	pc = 0x82402CF4; continue 'dispatch;
	}
	// 82402C98: 388102E4  addi r4, r1, 0x2e4
	ctx.r[4].s64 = ctx.r[1].s64 + 740;
	// 82402C9C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82402CA0: 4BFFFEF9  bl 0x82402b98
	ctx.lr = 0x82402CA4;
	sub_82402B98(ctx, base);
	// 82402CA4: 388102EC  addi r4, r1, 0x2ec
	ctx.r[4].s64 = ctx.r[1].s64 + 748;
	// 82402CA8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82402CAC: 4BFFFEED  bl 0x82402b98
	ctx.lr = 0x82402CB0;
	sub_82402B98(ctx, base);
	// 82402CB0: 388102F4  addi r4, r1, 0x2f4
	ctx.r[4].s64 = ctx.r[1].s64 + 756;
	// 82402CB4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82402CB8: 4BFFFEE1  bl 0x82402b98
	ctx.lr = 0x82402CBC;
	sub_82402B98(ctx, base);
	// 82402CBC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82402CC0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82402CC4: 4BFFFED5  bl 0x82402b98
	ctx.lr = 0x82402CC8;
	sub_82402B98(ctx, base);
	// 82402CC8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82402CCC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82402CD0: 4BFFFEC9  bl 0x82402b98
	ctx.lr = 0x82402CD4;
	sub_82402B98(ctx, base);
	// 82402CD4: 3C800005  lis r4, 5
	ctx.r[4].s64 = 327680;
	// 82402CD8: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 82402CDC: 80A1008C  lwz r5, 0x8c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82402CE0: 60848020  ori r4, r4, 0x8020
	ctx.r[4].u64 = ctx.r[4].u64 | 32800;
	// 82402CE4: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 82402CE8: 4830AF95  bl 0x8270dc7c
	ctx.lr = 0x82402CEC;
	// extern call 0x8270DC7C  crate::xboxkrnl::XMsgInProcessCall
	crate::xboxkrnl::XMsgInProcessCall(ctx, base);
	// 82402CEC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402CF0: 40800024  bge 0x82402d14
	if !ctx.cr[0].lt {
	pc = 0x82402D14; continue 'dispatch;
	}
	// 82402CF4: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82402CF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82402CFC: 419A0008  beq cr6, 0x82402d04
	if ctx.cr[6].eq {
	pc = 0x82402D04; continue 'dispatch;
	}
	// 82402D00: 4830AF8D  bl 0x8270dc8c
	ctx.lr = 0x82402D04;
	// extern call 0x8270DC8C  crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	// 82402D04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82402D08: 4BFBFA89  bl 0x823c2790
	ctx.lr = 0x82402D0C;
	sub_823C2790(ctx, base);
	// 82402D0C: 3BC0065B  li r30, 0x65b
	ctx.r[30].s64 = 1627;
	// 82402D10: 4800000C  b 0x82402d1c
	pc = 0x82402D1C; continue 'dispatch;
	// 82402D14: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82402D18: 4830AF75  bl 0x8270dc8c
	ctx.lr = 0x82402D1C;
	// extern call 0x8270DC8C  crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	// 82402D1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82402D20: 382102D0  addi r1, r1, 0x2d0
	ctx.r[1].s64 = ctx.r[1].s64 + 720;
	// 82402D24: 481323E4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82402D28 size=304
    let mut pc: u32 = 0x82402D28;
    'dispatch: loop {
        match pc {
            0x82402D28 => {
    //   block [0x82402D28..0x82402E58)
	// 82402D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82402D2C: 48132391  bl 0x825350bc
	ctx.lr = 0x82402D30;
	sub_82535080(ctx, base);
	// 82402D30: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82402D34: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82402D38: 906102E4  stw r3, 0x2e4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(740 as u32), ctx.r[3].u32 ) };
	// 82402D3C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82402D40: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82402D44: 38600586  li r3, 0x586
	ctx.r[3].s64 = 1414;
	// 82402D48: 93C102A0  stw r30, 0x2a0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(672 as u32), ctx.r[30].u32 ) };
	// 82402D4C: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 82402D50: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82402D54: 480003ED  bl 0x82403140
	ctx.lr = 0x82402D58;
	sub_82403140(ctx, base);
	// 82402D58: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402D5C: 418000C8  blt 0x82402e24
	if ctx.cr[0].lt {
	pc = 0x82402E24; continue 'dispatch;
	}
	// 82402D60: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82402D64: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82402D68: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82402D6C: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
	// 82402D70: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82402D74: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82402D78: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82402D7C: 4800044D  bl 0x824031c8
	ctx.lr = 0x82402D80;
	sub_824031C8(ctx, base);
	// 82402D80: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402D84: 418000A0  blt 0x82402e24
	if ctx.cr[0].lt {
	pc = 0x82402E24; continue 'dispatch;
	}
	// 82402D88: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82402D8C: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82402D90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82402D94: 4830AF09  bl 0x8270dc9c
	ctx.lr = 0x82402D98;
	// extern call 0x8270DC9C  crate::xam::XamAlloc
	crate::xam::XamAlloc(ctx, base);
	// 82402D98: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402D9C: 41800088  blt 0x82402e24
	if ctx.cr[0].lt {
	pc = 0x82402E24; continue 'dispatch;
	}
	// 82402DA0: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 82402DA4: 81010084  lwz r8, 0x84(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82402DA8: 38E10094  addi r7, r1, 0x94
	ctx.r[7].s64 = ctx.r[1].s64 + 148;
	// 82402DAC: 80810088  lwz r4, 0x88(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82402DB0: 3961008C  addi r11, r1, 0x8c
	ctx.r[11].s64 = ctx.r[1].s64 + 140;
	// 82402DB4: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82402DB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82402DBC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82402DC0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82402DC4: 90C1005C  stw r6, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[6].u32 ) };
	// 82402DC8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82402DCC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82402DD0: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82402DD4: 38600586  li r3, 0x586
	ctx.r[3].s64 = 1414;
	// 82402DD8: 80E10080  lwz r7, 0x80(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82402DDC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82402DE0: 48000489  bl 0x82403268
	ctx.lr = 0x82402DE4;
	sub_82403268(ctx, base);
	// 82402DE4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402DE8: 4180003C  blt 0x82402e24
	if ctx.cr[0].lt {
	pc = 0x82402E24; continue 'dispatch;
	}
	// 82402DEC: 388102E4  addi r4, r1, 0x2e4
	ctx.r[4].s64 = ctx.r[1].s64 + 740;
	// 82402DF0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82402DF4: 4BFFFDA5  bl 0x82402b98
	ctx.lr = 0x82402DF8;
	sub_82402B98(ctx, base);
	// 82402DF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82402DFC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82402E00: 4BFFFD99  bl 0x82402b98
	ctx.lr = 0x82402E04;
	sub_82402B98(ctx, base);
	// 82402E04: 3C800005  lis r4, 5
	ctx.r[4].s64 = 327680;
	// 82402E08: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 82402E0C: 80A1008C  lwz r5, 0x8c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82402E10: 60848023  ori r4, r4, 0x8023
	ctx.r[4].u64 = ctx.r[4].u64 | 32803;
	// 82402E14: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 82402E18: 4830AE65  bl 0x8270dc7c
	ctx.lr = 0x82402E1C;
	// extern call 0x8270DC7C  crate::xboxkrnl::XMsgInProcessCall
	crate::xboxkrnl::XMsgInProcessCall(ctx, base);
	// 82402E1C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402E20: 40800024  bge 0x82402e44
	if !ctx.cr[0].lt {
	pc = 0x82402E44; continue 'dispatch;
	}
	// 82402E24: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82402E28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82402E2C: 419A0008  beq cr6, 0x82402e34
	if ctx.cr[6].eq {
	pc = 0x82402E34; continue 'dispatch;
	}
	// 82402E30: 4830AE5D  bl 0x8270dc8c
	ctx.lr = 0x82402E34;
	// extern call 0x8270DC8C  crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	// 82402E34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82402E38: 4BFBF959  bl 0x823c2790
	ctx.lr = 0x82402E3C;
	sub_823C2790(ctx, base);
	// 82402E3C: 3BC0065B  li r30, 0x65b
	ctx.r[30].s64 = 1627;
	// 82402E40: 4800000C  b 0x82402e4c
	pc = 0x82402E4C; continue 'dispatch;
	// 82402E44: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82402E48: 4830AE45  bl 0x8270dc8c
	ctx.lr = 0x82402E4C;
	// extern call 0x8270DC8C  crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	// 82402E4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82402E50: 382102D0  addi r1, r1, 0x2d0
	ctx.r[1].s64 = ctx.r[1].s64 + 720;
	// 82402E54: 481322B8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82402E58 size=576
    let mut pc: u32 = 0x82402E58;
    'dispatch: loop {
        match pc {
            0x82402E58 => {
    //   block [0x82402E58..0x82403098)
	// 82402E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82402E5C: 48132255  bl 0x825350b0
	ctx.lr = 0x82402E60;
	sub_82535080(ctx, base);
	// 82402E60: 9421FCE0  stwu r1, -0x320(r1)
	ea = ctx.r[1].u32.wrapping_add(-800 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82402E64: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82402E68: 90610334  stw r3, 0x334(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(820 as u32), ctx.r[3].u32 ) };
	// 82402E6C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82402E70: 90A10344  stw r5, 0x344(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(836 as u32), ctx.r[5].u32 ) };
	// 82402E74: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82402E78: 38600801  li r3, 0x801
	ctx.r[3].s64 = 2049;
	// 82402E7C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82402E80: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82402E84: 93E102E0  stw r31, 0x2e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(736 as u32), ctx.r[31].u32 ) };
	// 82402E88: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 82402E8C: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 82402E90: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 82402E94: 93E10088  stw r31, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u32 ) };
	// 82402E98: 480002A9  bl 0x82403140
	ctx.lr = 0x82402E9C;
	sub_82403140(ctx, base);
	// 82402E9C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402EA0: 418001A0  blt 0x82403040
	if ctx.cr[0].lt {
	pc = 0x82403040; continue 'dispatch;
	}
	// 82402EA4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82402EA8: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82402EAC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82402EB0: 38E10088  addi r7, r1, 0x88
	ctx.r[7].s64 = ctx.r[1].s64 + 136;
	// 82402EB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82402EB8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82402EBC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82402EC0: 48000309  bl 0x824031c8
	ctx.lr = 0x82402EC4;
	sub_824031C8(ctx, base);
	// 82402EC4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402EC8: 41800178  blt 0x82403040
	if ctx.cr[0].lt {
	pc = 0x82403040; continue 'dispatch;
	}
	// 82402ECC: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82402ED0: 80810088  lwz r4, 0x88(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82402ED4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82402ED8: 4830ADC5  bl 0x8270dc9c
	ctx.lr = 0x82402EDC;
	// extern call 0x8270DC9C  crate::xam::XamAlloc
	crate::xam::XamAlloc(ctx, base);
	// 82402EDC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402EE0: 41800160  blt 0x82403040
	if ctx.cr[0].lt {
	pc = 0x82403040; continue 'dispatch;
	}
	// 82402EE4: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82402EE8: 4830ADC5  bl 0x8270dcac
	ctx.lr = 0x82402EEC;
	// extern call 0x8270DCAC  crate::xboxkrnl::XNetLogonGetTitleID
	crate::xboxkrnl::XNetLogonGetTitleID(ctx, base);
	// 82402EEC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82402EF0: 906100A0  stw r3, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[3].u32 ) };
	// 82402EF4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82402EF8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82402EFC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82402F00: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82402F04: 409AFFF4  bne cr6, 0x82402ef8
	if !ctx.cr[6].eq {
	pc = 0x82402EF8; continue 'dispatch;
	}
	// 82402F08: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82402F0C: 81010088  lwz r8, 0x88(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82402F10: 39410098  addi r10, r1, 0x98
	ctx.r[10].s64 = ctx.r[1].s64 + 152;
	// 82402F14: 80E10090  lwz r7, 0x90(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82402F18: 38C10094  addi r6, r1, 0x94
	ctx.r[6].s64 = ctx.r[1].s64 + 148;
	// 82402F1C: 80810080  lwz r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82402F20: 38A1009C  addi r5, r1, 0x9c
	ctx.r[5].s64 = ctx.r[1].s64 + 156;
	// 82402F24: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82402F28: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82402F2C: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 82402F30: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82402F34: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82402F38: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82402F3C: 83A10344  lwz r29, 0x344(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(836 as u32) ) } as u64;
	// 82402F40: 38600801  li r3, 0x801
	ctx.r[3].s64 = 2049;
	// 82402F44: 90C10064  stw r6, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[6].u32 ) };
	// 82402F48: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82402F4C: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82402F50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82402F54: B1610084  sth r11, 0x84(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u16 ) };
	// 82402F58: B3A1008C  sth r29, 0x8c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[29].u16 ) };
	// 82402F5C: 4800030D  bl 0x82403268
	ctx.lr = 0x82402F60;
	sub_82403268(ctx, base);
	// 82402F60: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402F64: 418000DC  blt 0x82403040
	if ctx.cr[0].lt {
	pc = 0x82403040; continue 'dispatch;
	}
	// 82402F68: 38810334  addi r4, r1, 0x334
	ctx.r[4].s64 = ctx.r[1].s64 + 820;
	// 82402F6C: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82402F70: 4BFFFC29  bl 0x82402b98
	ctx.lr = 0x82402F74;
	sub_82402B98(ctx, base);
	// 82402F74: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82402F78: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82402F7C: 4BFFFC1D  bl 0x82402b98
	ctx.lr = 0x82402F80;
	sub_82402B98(ctx, base);
	// 82402F80: 38810344  addi r4, r1, 0x344
	ctx.r[4].s64 = ctx.r[1].s64 + 836;
	// 82402F84: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82402F88: 4BFFFC11  bl 0x82402b98
	ctx.lr = 0x82402F8C;
	sub_82402B98(ctx, base);
	// 82402F8C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82402F90: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82402F94: 4BFFFC05  bl 0x82402b98
	ctx.lr = 0x82402F98;
	sub_82402B98(ctx, base);
	// 82402F98: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82402F9C: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82402FA0: 4BFFFBF9  bl 0x82402b98
	ctx.lr = 0x82402FA4;
	sub_82402B98(ctx, base);
	// 82402FA4: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 82402FA8: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82402FAC: 4BFFFBED  bl 0x82402b98
	ctx.lr = 0x82402FB0;
	sub_82402B98(ctx, base);
	// 82402FB0: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 82402FB4: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82402FB8: 4BFFFBE1  bl 0x82402b98
	ctx.lr = 0x82402FBC;
	sub_82402B98(ctx, base);
	// 82402FBC: 39410094  addi r10, r1, 0x94
	ctx.r[10].s64 = ctx.r[1].s64 + 148;
	// 82402FC0: 390100E0  addi r8, r1, 0xe0
	ctx.r[8].s64 = ctx.r[1].s64 + 224;
	// 82402FC4: 8121009C  lwz r9, 0x9c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82402FC8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82402FCC: 80A10080  lwz r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82402FD0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82402FD4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82402FD8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82402FDC: 48000375  bl 0x82403350
	ctx.lr = 0x82402FE0;
	sub_82403350(ctx, base);
	// 82402FE0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402FE4: 4180005C  blt 0x82403040
	if ctx.cr[0].lt {
	pc = 0x82403040; continue 'dispatch;
	}
	// 82402FE8: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82402FEC: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 82402FF0: 81210098  lwz r9, 0x98(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82402FF4: 38E00028  li r7, 0x28
	ctx.r[7].s64 = 40;
	// 82402FF8: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 82402FFC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82403000: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 82403004: 9149001C  stw r10, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82403008: FBEB0000  std r31, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	// 8240300C: FBEB0008  std r31, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u64 ) };
	// 82403010: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82403014: FBEB0010  std r31, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[31].u64 ) };
	// 82403018: FBEB0018  std r31, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[31].u64 ) };
	// 8240301C: 5544043E  clrlwi r4, r10, 0x10
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 82403020: FBEB0020  std r31, 0x20(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[31].u64 ) };
	// 82403024: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82403028: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 8240302C: 5144801E  rlwimi r4, r10, 0x10, 0, 0xf
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[4].u64 & 0xFFFFFFFF0000FFFF);
	// 82403030: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82403034: 4830A049  bl 0x8270d07c
	ctx.lr = 0x82403038;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 82403038: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8240303C: 40800030  bge 0x8240306c
	if !ctx.cr[0].lt {
	pc = 0x8240306C; continue 'dispatch;
	}
	// 82403040: 3BE0065B  li r31, 0x65b
	ctx.r[31].s64 = 1627;
	// 82403044: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82403048: 419A000C  beq cr6, 0x82403054
	if ctx.cr[6].eq {
	pc = 0x82403054; continue 'dispatch;
	}
	// 8240304C: 907E0018  stw r3, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 82403050: 48000008  b 0x82403058
	pc = 0x82403058; continue 'dispatch;
	// 82403054: 4BFBF29D  bl 0x823c22f0
	ctx.lr = 0x82403058;
	sub_823C22F0(ctx, base);
	// 82403058: 80610090  lwz r3, 0x90(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 8240305C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82403060: 419A002C  beq cr6, 0x8240308c
	if ctx.cr[6].eq {
	pc = 0x8240308C; continue 'dispatch;
	}
	// 82403064: 4830AC29  bl 0x8270dc8c
	ctx.lr = 0x82403068;
	// extern call 0x8270DC8C  crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	// 82403068: 48000024  b 0x8240308c
	pc = 0x8240308C; continue 'dispatch;
	// 8240306C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82403070: 419A000C  beq cr6, 0x8240307c
	if ctx.cr[6].eq {
	pc = 0x8240307C; continue 'dispatch;
	}
	// 82403074: 3BE003E5  li r31, 0x3e5
	ctx.r[31].s64 = 997;
	// 82403078: 48000014  b 0x8240308c
	pc = 0x8240308C; continue 'dispatch;
	// 8240307C: 4BFBF2C5  bl 0x823c2340
	ctx.lr = 0x82403080;
	sub_823C2340(ctx, base);
	// 82403080: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82403084: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82403088: 717F065B  andi. r31, r11, 0x65b
	ctx.r[31].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8240308C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403090: 38210320  addi r1, r1, 0x320
	ctx.r[1].s64 = ctx.r[1].s64 + 800;
	// 82403094: 4813206C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82403098 size=16
    let mut pc: u32 = 0x82403098;
    'dispatch: loop {
        match pc {
            0x82403098 => {
    //   block [0x82403098..0x824030A8)
	// 82403098: A1630000  lhz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8240309C: A1440000  lhz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824030A0: 7C6A5850  subf r3, r10, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 824030A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824030A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824030A8 size=136
    let mut pc: u32 = 0x824030A8;
    'dispatch: loop {
        match pc {
            0x824030A8 => {
    //   block [0x824030A8..0x82403130)
	// 824030A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824030AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824030B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824030B4: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824030B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824030BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 824030C0: 419A0058  beq cr6, 0x82403118
	if ctx.cr[6].eq {
	pc = 0x82403118; continue 'dispatch;
	}
	// 824030C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824030C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824030CC: 419A004C  beq cr6, 0x82403118
	if ctx.cr[6].eq {
	pc = 0x82403118; continue 'dispatch;
	}
	// 824030D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824030D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824030D8: 419A0040  beq cr6, 0x82403118
	if ctx.cr[6].eq {
	pc = 0x82403118; continue 'dispatch;
	}
	// 824030DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824030E0: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 824030E4: 4BFEE265  bl 0x823f1348
	ctx.lr = 0x824030E8;
	sub_823F1348(ctx, base);
	// 824030E8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824030EC: 40820030  bne 0x8240311c
	if !ctx.cr[0].eq {
	pc = 0x8240311C; continue 'dispatch;
	}
	// 824030F0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824030F4: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824030F8: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824030FC: 386B37C0  addi r3, r11, 0x37c0
	ctx.r[3].s64 = ctx.r[11].s64 + 14272;
	// 82403100: 48000801  bl 0x82403900
	ctx.lr = 0x82403104;
	sub_82403900(ctx, base);
	// 82403104: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403108: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8240310C: 40800010  bge 0x8240311c
	if !ctx.cr[0].lt {
	pc = 0x8240311C; continue 'dispatch;
	}
	// 82403110: 3860065B  li r3, 0x65b
	ctx.r[3].s64 = 1627;
	// 82403114: 48000008  b 0x8240311c
	pc = 0x8240311C; continue 'dispatch;
	// 82403118: 38600057  li r3, 0x57
	ctx.r[3].s64 = 87;
	// 8240311C: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 82403120: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82403124: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82403128: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8240312C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82403130 size=12
    let mut pc: u32 = 0x82403130;
    'dispatch: loop {
        match pc {
            0x82403130 => {
    //   block [0x82403130..0x8240313C)
	// 82403130: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 82403134: 386B3198  addi r3, r11, 0x3198
	ctx.r[3].s64 = ctx.r[11].s64 + 12696;
	// 82403138: 4BFFFF70  b 0x824030a8
	sub_824030A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403140 size=136
    let mut pc: u32 = 0x82403140;
    'dispatch: loop {
        match pc {
            0x82403140 => {
    //   block [0x82403140..0x824031C8)
	// 82403140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82403144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82403148: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8240314C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82403150: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82403154: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82403158: 396B37C0  addi r11, r11, 0x37c0
	ctx.r[11].s64 = ctx.r[11].s64 + 14272;
	// 8240315C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82403160: 808B002C  lwz r4, 0x2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82403164: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82403168: 40820010  bne 0x82403178
	if !ctx.cr[0].eq {
	pc = 0x82403178; continue 'dispatch;
	}
	// 8240316C: 3C608015  lis r3, -0x7feb
	ctx.r[3].s64 = -2146107392;
	// 82403170: 60630005  ori r3, r3, 5
	ctx.r[3].u64 = ctx.r[3].u64 | 5;
	// 82403174: 48000040  b 0x824031b4
	pc = 0x824031B4; continue 'dispatch;
	// 82403178: A0AB0028  lhz r5, 0x28(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8240317C: 3D608240  lis r11, -0x7dc0
	ctx.r[11].s64 = -2109734912;
	// 82403180: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82403184: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 82403188: 38EB3098  addi r7, r11, 0x3098
	ctx.r[7].s64 = ctx.r[11].s64 + 12440;
	// 8240318C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82403190: 48133439  bl 0x825365c8
	ctx.lr = 0x82403194;
	sub_825365C8(ctx, base);
	// 82403194: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82403198: 40820010  bne 0x824031a8
	if !ctx.cr[0].eq {
	pc = 0x824031A8; continue 'dispatch;
	}
	// 8240319C: 3C608015  lis r3, -0x7feb
	ctx.r[3].s64 = -2146107392;
	// 824031A0: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 824031A4: 48000010  b 0x824031b4
	pc = 0x824031B4; continue 'dispatch;
	// 824031A8: A1630002  lhz r11, 2(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(2 as u32) ) } as u64;
	// 824031AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824031B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824031B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824031B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824031BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824031C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824031C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824031C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824031C8 size=156
    let mut pc: u32 = 0x824031C8;
    'dispatch: loop {
        match pc {
            0x824031C8 => {
    //   block [0x824031C8..0x82403264)
	// 824031C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824031CC: 48131EE5  bl 0x825350b0
	ctx.lr = 0x824031D0;
	sub_82535080(ctx, base);
	// 824031D0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824031D4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 824031D8: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 824031DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824031E0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 824031E4: 386A37C0  addi r3, r10, 0x37c0
	ctx.r[3].s64 = ctx.r[10].s64 + 14272;
	// 824031E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824031EC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 824031F0: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 824031F4: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 824031F8: 7D1F4378  mr r31, r8
	ctx.r[31].u64 = ctx.r[8].u64;
	// 824031FC: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 82403200: 48000671  bl 0x82403870
	ctx.lr = 0x82403204;
	sub_82403870(ctx, base);
	// 82403204: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403208: 41800054  blt 0x8240325c
	if ctx.cr[0].lt {
	pc = 0x8240325C; continue 'dispatch;
	}
	// 8240320C: 57CB0739  rlwinm. r11, r30, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403210: 40820008  bne 0x82403218
	if !ctx.cr[0].eq {
	pc = 0x82403218; continue 'dispatch;
	}
	// 82403214: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82403218: 1D7D0078  mulli r11, r29, 0x78
	ctx.r[11].s64 = ctx.r[29].s64 * 120;
	// 8240321C: 39400064  li r10, 0x64
	ctx.r[10].s64 = 100;
	// 82403220: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82403224: 7D6B5396  divwu r11, r11, r10
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82403228: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	// 8240322C: 556B003A  rlwinm r11, r11, 0, 0, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82403230: 419A0008  beq cr6, 0x82403238
	if ctx.cr[6].eq {
	pc = 0x82403238; continue 'dispatch;
	}
	// 82403234: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82403238: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8240323C: 419A000C  beq cr6, 0x82403248
	if ctx.cr[6].eq {
	pc = 0x82403248; continue 'dispatch;
	}
	// 82403240: 39401000  li r10, 0x1000
	ctx.r[10].s64 = 4096;
	// 82403244: 915B0000  stw r10, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82403248: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8240324C: 419A0010  beq cr6, 0x8240325c
	if ctx.cr[6].eq {
	pc = 0x8240325C; continue 'dispatch;
	}
	// 82403250: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82403254: 396B2E6C  addi r11, r11, 0x2e6c
	ctx.r[11].s64 = ctx.r[11].s64 + 11884;
	// 82403258: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8240325C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82403260: 48131EA0  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403268 size=228
    let mut pc: u32 = 0x82403268;
    'dispatch: loop {
        match pc {
            0x82403268 => {
    //   block [0x82403268..0x8240334C)
	// 82403268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240326C: 48131E35  bl 0x825350a0
	ctx.lr = 0x82403270;
	sub_82535080(ctx, base);
	// 82403270: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82403274: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82403278: 3C800005  lis r4, 5
	ctx.r[4].s64 = 327680;
	// 8240327C: 3BC61E20  addi r30, r6, 0x1e20
	ctx.r[30].s64 = ctx.r[6].s64 + 7712;
	// 82403280: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82403284: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82403288: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8240328C: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82403290: 60848004  ori r4, r4, 0x8004
	ctx.r[4].u64 = ctx.r[4].u64 | 32772;
	// 82403294: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 82403298: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 8240329C: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 824032A0: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 824032A4: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	// 824032A8: 3ADE104C  addi r22, r30, 0x104c
	ctx.r[22].s64 = ctx.r[30].s64 + 4172;
	// 824032AC: 4830A9D1  bl 0x8270dc7c
	ctx.lr = 0x824032B0;
	// extern call 0x8270DC7C  crate::xboxkrnl::XMsgInProcessCall
	crate::xboxkrnl::XMsgInProcessCall(ctx, base);
	// 824032B0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824032B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824032B8: 41800008  blt 0x824032c0
	if ctx.cr[0].lt {
	pc = 0x824032C0; continue 'dispatch;
	}
	// 824032BC: 81410090  lwz r10, 0x90(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 824032C0: 81610144  lwz r11, 0x144(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 824032C4: 39001000  li r8, 0x1000
	ctx.r[8].s64 = 4096;
	// 824032C8: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 824032CC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 824032D0: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 824032D4: 92E10084  stw r23, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[23].u32 ) };
	// 824032D8: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 824032DC: 9301007C  stw r24, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[24].u32 ) };
	// 824032E0: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 824032E4: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 824032E8: 397F004C  addi r11, r31, 0x4c
	ctx.r[11].s64 = ctx.r[31].s64 + 76;
	// 824032EC: 7FF6C850  subf r31, r22, r25
	ctx.r[31].s64 = ctx.r[25].s64 - ctx.r[22].s64;
	// 824032F0: 91010074  stw r8, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[8].u32 ) };
	// 824032F4: 7FDE5A14  add r30, r30, r11
	ctx.r[30].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 824032F8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 824032FC: 7D7FF214  add r11, r31, r30
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 82403300: 38AA37C0  addi r5, r10, 0x37c0
	ctx.r[5].s64 = ctx.r[10].s64 + 14272;
	// 82403304: 8141015C  lwz r10, 0x15c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(348 as u32) ) } as u64;
	// 82403308: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 8240330C: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82403310: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82403314: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82403318: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8240331C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82403320: 48000721  bl 0x82403a40
	ctx.lr = 0x82403324;
	sub_82403A40(ctx, base);
	// 82403324: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403328: 4180001C  blt 0x82403344
	if ctx.cr[0].lt {
	pc = 0x82403344; continue 'dispatch;
	}
	// 8240332C: 8161014C  lwz r11, 0x14c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(332 as u32) ) } as u64;
	// 82403330: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82403334: 81610154  lwz r11, 0x154(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82403338: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8240333C: 81610164  lwz r11, 0x164(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 82403340: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82403344: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82403348: 48131DA8  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403350 size=212
    let mut pc: u32 = 0x82403350;
    'dispatch: loop {
        match pc {
            0x82403350 => {
    //   block [0x82403350..0x82403424)
	// 82403350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82403354: 48131D55  bl 0x825350a8
	ctx.lr = 0x82403358;
	sub_82535080(ctx, base);
	// 82403358: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240335C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82403360: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82403364: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82403368: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 8240336C: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 82403370: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82403374: 7CCB30F8  nor r11, r6, r6
	ctx.r[11].u64 = !(ctx.r[6].u64 | ctx.r[6].u64);
	// 82403378: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 8240337C: 2B040440  cmplwi cr6, r4, 0x440
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1088 as u32, &mut ctx.xer);
	// 82403380: 5578F7FE  rlwinm r24, r11, 0x1e, 0x1f, 0x1f
	ctx.r[24].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82403384: 40980038  bge cr6, 0x824033bc
	if !ctx.cr[6].lt {
	pc = 0x824033BC; continue 'dispatch;
	}
	// 82403388: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8240338C: 419A0010  beq cr6, 0x8240339c
	if ctx.cr[6].eq {
	pc = 0x8240339C; continue 'dispatch;
	}
	// 82403390: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 82403394: 63FF007A  ori r31, r31, 0x7a
	ctx.r[31].u64 = ctx.r[31].u64 | 122;
	// 82403398: 48000080  b 0x82403418
	pc = 0x82403418; continue 'dispatch;
	// 8240339C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824033A0: 38800440  li r4, 0x440
	ctx.r[4].s64 = 1088;
	// 824033A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824033A8: 4830A8F5  bl 0x8270dc9c
	ctx.lr = 0x824033AC;
	// extern call 0x8270DC9C  crate::xam::XamAlloc
	crate::xam::XamAlloc(ctx, base);
	// 824033AC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824033B0: 41800058  blt 0x82403408
	if ctx.cr[0].lt {
	pc = 0x82403408; continue 'dispatch;
	}
	// 824033B4: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824033B8: 48000008  b 0x824033c0
	pc = 0x824033C0; continue 'dispatch;
	// 824033BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824033C0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824033C4: 81390000  lwz r9, 0(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 824033C8: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 824033CC: 388B37C0  addi r4, r11, 0x37c0
	ctx.r[4].s64 = ctx.r[11].s64 + 14272;
	// 824033D0: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 824033D4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 824033D8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 824033DC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 824033E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824033E4: 4800073D  bl 0x82403b20
	ctx.lr = 0x824033E8;
	sub_82403B20(ctx, base);
	// 824033E8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824033EC: 4180001C  blt 0x82403408
	if ctx.cr[0].lt {
	pc = 0x82403408; continue 'dispatch;
	}
	// 824033F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824033F4: 4800103D  bl 0x82404430
	ctx.lr = 0x824033F8;
	sub_82404430(ctx, base);
	// 824033F8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824033FC: 4180000C  blt 0x82403408
	if ctx.cr[0].lt {
	pc = 0x82403408; continue 'dispatch;
	}
	// 82403400: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82403404: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82403408: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8240340C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82403410: 419A0008  beq cr6, 0x82403418
	if ctx.cr[6].eq {
	pc = 0x82403418; continue 'dispatch;
	}
	// 82403414: 4830A879  bl 0x8270dc8c
	ctx.lr = 0x82403418;
	// extern call 0x8270DC8C  crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	// 82403418: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8240341C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82403420: 48131CD8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403428 size=44
    let mut pc: u32 = 0x82403428;
    'dispatch: loop {
        match pc {
            0x82403428 => {
    //   block [0x82403428..0x82403454)
	// 82403428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240342C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82403430: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82403434: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82403438: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8240343C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82403440: 48001481  bl 0x824048c0
	ctx.lr = 0x82403444;
	sub_824048C0(ctx, base);
	// 82403444: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82403448: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8240344C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82403450: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403458 size=88
    let mut pc: u32 = 0x82403458;
    'dispatch: loop {
        match pc {
            0x82403458 => {
    //   block [0x82403458..0x824034B0)
	// 82403458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240345C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82403460: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82403464: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82403468: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240346C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82403470: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82403474: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82403478: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8240347C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82403480: 48001441  bl 0x824048c0
	ctx.lr = 0x82403484;
	sub_824048C0(ctx, base);
	// 82403484: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403488: 41800010  blt 0x82403498
	if ctx.cr[0].lt {
	pc = 0x82403498; continue 'dispatch;
	}
	// 8240348C: 389E0002  addi r4, r30, 2
	ctx.r[4].s64 = ctx.r[30].s64 + 2;
	// 82403490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403494: 480013FD  bl 0x82404890
	ctx.lr = 0x82403498;
	sub_82404890(ctx, base);
	// 82403498: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8240349C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824034A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824034A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824034A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824034AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824034B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824034B0 size=44
    let mut pc: u32 = 0x824034B0;
    'dispatch: loop {
        match pc {
            0x824034B0 => {
    //   block [0x824034B0..0x824034DC)
	// 824034B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824034B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824034B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824034BC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 824034C0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824034C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 824034C8: 480013F9  bl 0x824048c0
	ctx.lr = 0x824034CC;
	sub_824048C0(ctx, base);
	// 824034CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824034D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824034D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824034D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824034E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824034E0 size=80
    let mut pc: u32 = 0x824034E0;
    'dispatch: loop {
        match pc {
            0x824034E0 => {
    //   block [0x824034E0..0x82403530)
	// 824034E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824034E4: 48131BD9  bl 0x825350bc
	ctx.lr = 0x824034E8;
	sub_82535080(ctx, base);
	// 824034E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824034EC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 824034F0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 824034F4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824034F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824034FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82403500: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82403504: 480013BD  bl 0x824048c0
	ctx.lr = 0x82403508;
	sub_824048C0(ctx, base);
	// 82403508: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8240350C: 4180001C  blt 0x82403528
	if ctx.cr[0].lt {
	pc = 0x82403528; continue 'dispatch;
	}
	// 82403510: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82403514: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403518: 41820010  beq 0x82403528
	if ctx.cr[0].eq {
	pc = 0x82403528; continue 'dispatch;
	}
	// 8240351C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82403520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403524: 4800136D  bl 0x82404890
	ctx.lr = 0x82403528;
	sub_82404890(ctx, base);
	// 82403528: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8240352C: 48131BE0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403530 size=832
    let mut pc: u32 = 0x82403530;
    'dispatch: loop {
        match pc {
            0x82403530 => {
    //   block [0x82403530..0x82403870)
	// 82403530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82403534: 48131B7D  bl 0x825350b0
	ctx.lr = 0x82403538;
	sub_82535080(ctx, base);
	// 82403538: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240353C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82403540: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82403544: 2B1A0010  cmplwi cr6, r26, 0x10
	ctx.cr[6].compare_u32(ctx.r[26].u32, 16 as u32, &mut ctx.xer);
	// 82403548: 40980164  bge cr6, 0x824036ac
	if !ctx.cr[6].lt {
	pc = 0x824036AC; continue 'dispatch;
	}
	// 8240354C: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82403550: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82403554: 38810051  addi r4, r1, 0x51
	ctx.r[4].s64 = ctx.r[1].s64 + 81;
	// 82403558: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 8240355C: 48001365  bl 0x824048c0
	ctx.lr = 0x82403560;
	sub_824048C0(ctx, base);
	// 82403560: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403564: 41800150  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 82403568: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 8240356C: 556BF7BE  rlwinm r11, r11, 0x1e, 0x1e, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82403570: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82403574: 41980138  blt cr6, 0x824036ac
	if ctx.cr[6].lt {
	pc = 0x824036AC; continue 'dispatch;
	}
	// 82403578: 419A000C  beq cr6, 0x82403584
	if ctx.cr[6].eq {
	pc = 0x82403584; continue 'dispatch;
	}
	// 8240357C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82403580: 4098012C  bge cr6, 0x824036ac
	if !ctx.cr[6].lt {
	pc = 0x824036AC; continue 'dispatch;
	}
	// 82403584: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82403588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8240358C: 48001305  bl 0x82404890
	ctx.lr = 0x82403590;
	sub_82404890(ctx, base);
	// 82403590: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403594: 41800120  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 82403598: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 8240359C: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824035A0: 41820020  beq 0x824035c0
	if ctx.cr[0].eq {
	pc = 0x824035C0; continue 'dispatch;
	}
	// 824035A4: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 824035A8: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 824035AC: 38810053  addi r4, r1, 0x53
	ctx.r[4].s64 = ctx.r[1].s64 + 83;
	// 824035B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824035B4: 4800130D  bl 0x824048c0
	ctx.lr = 0x824035B8;
	sub_824048C0(ctx, base);
	// 824035B8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824035BC: 418000F8  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 824035C0: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 824035C4: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824035C8: 41820018  beq 0x824035e0
	if ctx.cr[0].eq {
	pc = 0x824035E0; continue 'dispatch;
	}
	// 824035CC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 824035D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824035D4: 480012BD  bl 0x82404890
	ctx.lr = 0x824035D8;
	sub_82404890(ctx, base);
	// 824035D8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824035DC: 418000D8  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 824035E0: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 824035E4: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 824035E8: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824035EC: 41820040  beq 0x8240362c
	if ctx.cr[0].eq {
	pc = 0x8240362C; continue 'dispatch;
	}
	// 824035F0: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 824035F4: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 824035F8: 38810056  addi r4, r1, 0x56
	ctx.r[4].s64 = ctx.r[1].s64 + 86;
	// 824035FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403600: 480012C1  bl 0x824048c0
	ctx.lr = 0x82403604;
	sub_824048C0(ctx, base);
	// 82403604: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403608: 418000AC  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 8240360C: 89610056  lbz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82403610: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403614: 41820018  beq 0x8240362c
	if ctx.cr[0].eq {
	pc = 0x8240362C; continue 'dispatch;
	}
	// 82403618: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8240361C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403620: 48001271  bl 0x82404890
	ctx.lr = 0x82403624;
	sub_82404890(ctx, base);
	// 82403624: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403628: 4180008C  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 8240362C: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82403630: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82403634: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82403638: 409A0024  bne cr6, 0x8240365c
	if !ctx.cr[6].eq {
	pc = 0x8240365C; continue 'dispatch;
	}
	// 8240363C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82403640: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82403644: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403648: 4BFFFE99  bl 0x824034e0
	ctx.lr = 0x8240364C;
	sub_824034E0(ctx, base);
	// 8240364C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403650: 41800064  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 82403654: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82403658: 48000008  b 0x82403660
	pc = 0x82403660; continue 'dispatch;
	// 8240365C: A3A10058  lhz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82403660: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82403664: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403668: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8240366C: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82403670: 409A00D4  bne cr6, 0x82403744
	if !ctx.cr[6].eq {
	pc = 0x82403744; continue 'dispatch;
	}
	// 82403674: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82403678: 57AA043E  clrlwi r10, r29, 0x10
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x0000FFFFu64;
	// 8240367C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82403680: 4198003C  blt cr6, 0x824036bc
	if ctx.cr[6].lt {
	pc = 0x824036BC; continue 'dispatch;
	}
	// 82403684: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82403688: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 8240368C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82403690: 48001231  bl 0x824048c0
	ctx.lr = 0x82403694;
	sub_824048C0(ctx, base);
	// 82403694: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403698: 4180001C  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 8240369C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824036A0: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824036A4: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 824036A8: 419A00F0  beq cr6, 0x82403798
	if ctx.cr[6].eq {
	pc = 0x82403798; continue 'dispatch;
	}
	// 824036AC: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824036B0: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 824036B4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 824036B8: 48131A48  b 0x82535100
	sub_825350D0(ctx, base);
	return;
	// 824036BC: 38810052  addi r4, r1, 0x52
	ctx.r[4].s64 = ctx.r[1].s64 + 82;
	// 824036C0: 48001179  bl 0x82404838
	ctx.lr = 0x824036C4;
	sub_82404838(ctx, base);
	// 824036C4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824036C8: 4180FFEC  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 824036CC: 89610052  lbz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 824036D0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 824036D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824036D8: 41820028  beq 0x82403700
	if ctx.cr[0].eq {
	pc = 0x82403700; continue 'dispatch;
	}
	// 824036DC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 824036E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824036E4: 480011AD  bl 0x82404890
	ctx.lr = 0x824036E8;
	sub_82404890(ctx, base);
	// 824036E8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824036EC: 4180FFC8  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 824036F0: 89610052  lbz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 824036F4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 824036F8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824036FC: 4198FFE0  blt cr6, 0x824036dc
	if ctx.cr[6].lt {
	pc = 0x824036DC; continue 'dispatch;
	}
	// 82403700: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82403704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403708: 48001189  bl 0x82404890
	ctx.lr = 0x8240370C;
	sub_82404890(ctx, base);
	// 8240370C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403710: 4180FFA4  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 82403714: A1610054  lhz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82403718: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8240371C: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82403720: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403724: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82403728: 480011E9  bl 0x82404910
	ctx.lr = 0x8240372C;
	sub_82404910(ctx, base);
	// 8240372C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403730: 4180FF84  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 82403734: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82403738: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8240373C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82403740: 48000058  b 0x82403798
	pc = 0x82403798; continue 'dispatch;
	// 82403744: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82403748: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8240374C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82403750: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82403754: 4800116D  bl 0x824048c0
	ctx.lr = 0x82403758;
	sub_824048C0(ctx, base);
	// 82403758: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8240375C: 4180FF58  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 82403760: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82403764: 554BF7BE  rlwinm r11, r10, 0x1e, 0x1e, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 82403768: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8240376C: 4198005C  blt cr6, 0x824037c8
	if ctx.cr[6].lt {
	pc = 0x824037C8; continue 'dispatch;
	}
	// 82403770: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82403774: 4098FF34  bge cr6, 0x824036a8
	if !ctx.cr[6].lt {
	pc = 0x824036A8; continue 'dispatch;
	}
	// 82403778: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8240377C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403780: 48000D01  bl 0x82404480
	ctx.lr = 0x82403784;
	sub_82404480(ctx, base);
	// 82403784: 389A0001  addi r4, r26, 1
	ctx.r[4].s64 = ctx.r[26].s64 + 1;
	// 82403788: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8240378C: 4BFFFDA5  bl 0x82403530
	ctx.lr = 0x82403790;
	sub_82403530(ctx, base);
	// 82403790: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403794: 4180FF20  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 82403798: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 8240379C: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824037A0: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 824037A4: 409A0010  bne cr6, 0x824037b4
	if !ctx.cr[6].eq {
	pc = 0x824037B4; continue 'dispatch;
	}
	// 824037A8: 57AB043E  clrlwi r11, r29, 0x10
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x0000FFFFu64;
	// 824037AC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824037B0: 557D043E  clrlwi r29, r11, 0x10
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 824037B4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824037B8: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824037BC: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 824037C0: 409AFEA0  bne cr6, 0x82403660
	if !ctx.cr[6].eq {
	pc = 0x82403660; continue 'dispatch;
	}
	// 824037C4: 4BFFFEF0  b 0x824036b4
	pc = 0x824036B4; continue 'dispatch;
	// 824037C8: 554B0031  rlwinm. r11, r10, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824037CC: 41820020  beq 0x824037ec
	if ctx.cr[0].eq {
	pc = 0x824037EC; continue 'dispatch;
	}
	// 824037D0: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 824037D4: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 824037D8: 38810053  addi r4, r1, 0x53
	ctx.r[4].s64 = ctx.r[1].s64 + 83;
	// 824037DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824037E0: 480010E1  bl 0x824048c0
	ctx.lr = 0x824037E4;
	sub_824048C0(ctx, base);
	// 824037E4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824037E8: 4180FECC  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 824037EC: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824037F0: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824037F4: 41820018  beq 0x8240380c
	if ctx.cr[0].eq {
	pc = 0x8240380C; continue 'dispatch;
	}
	// 824037F8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 824037FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403800: 48001091  bl 0x82404890
	ctx.lr = 0x82403804;
	sub_82404890(ctx, base);
	// 82403804: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403808: 4180FEAC  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 8240380C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82403810: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403814: 41820040  beq 0x82403854
	if ctx.cr[0].eq {
	pc = 0x82403854; continue 'dispatch;
	}
	// 82403818: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 8240381C: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82403820: 38810056  addi r4, r1, 0x56
	ctx.r[4].s64 = ctx.r[1].s64 + 86;
	// 82403824: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403828: 48001099  bl 0x824048c0
	ctx.lr = 0x8240382C;
	sub_824048C0(ctx, base);
	// 8240382C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403830: 4180FE84  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 82403834: 89610056  lbz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82403838: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240383C: 41820018  beq 0x82403854
	if ctx.cr[0].eq {
	pc = 0x82403854; continue 'dispatch;
	}
	// 82403840: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82403844: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403848: 48001049  bl 0x82404890
	ctx.lr = 0x8240384C;
	sub_82404890(ctx, base);
	// 8240384C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403850: 4180FE64  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 82403854: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82403858: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240385C: 4182FF3C  beq 0x82403798
	if ctx.cr[0].eq {
	pc = 0x82403798; continue 'dispatch;
	}
	// 82403860: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82403864: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403868: 4BFFFBF1  bl 0x82403458
	ctx.lr = 0x8240386C;
	sub_82403458(ctx, base);
	// 8240386C: 4BFFFF24  b 0x82403790
	pc = 0x82403790; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403870 size=88
    let mut pc: u32 = 0x82403870;
    'dispatch: loop {
        match pc {
            0x82403870 => {
    //   block [0x82403870..0x824038C8)
	// 82403870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82403874: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82403878: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240387C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82403880: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82403884: A14B0028  lhz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82403888: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8240388C: 41980010  blt cr6, 0x8240389c
	if ctx.cr[6].lt {
	pc = 0x8240389C; continue 'dispatch;
	}
	// 82403890: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82403894: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82403898: 48000020  b 0x824038b8
	pc = 0x824038B8; continue 'dispatch;
	// 8240389C: A12B002A  lhz r9, 0x2a(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(42 as u32) ) } as u64;
	// 824038A0: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 824038A4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 824038A8: 7D6921D6  mullw r11, r9, r4
	ctx.r[11].s64 = (ctx.r[9].s32 as i64) * (ctx.r[4].s32 as i64);
	// 824038AC: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824038B0: 481312A1  bl 0x82534b50
	ctx.lr = 0x824038B4;
	sub_82534B50(ctx, base);
	// 824038B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824038B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824038BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824038C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824038C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824038C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824038C8 size=28
    let mut pc: u32 = 0x824038C8;
    'dispatch: loop {
        match pc {
            0x824038C8 => {
    //   block [0x824038C8..0x824038E4)
	// 824038C8: A1430018  lhz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 824038CC: 548B043E  clrlwi r11, r4, 0x10
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x0000FFFFu64;
	// 824038D0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 824038D4: 40990010  ble cr6, 0x824038e4
	if !ctx.cr[6].gt {
		sub_824038E4(ctx, base);
		return;
	}
	// 824038D8: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824038DC: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 824038E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824038E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824038E4 size=24
    let mut pc: u32 = 0x824038E4;
    'dispatch: loop {
        match pc {
            0x824038E4 => {
    //   block [0x824038E4..0x824038FC)
	// 824038E4: 81430040  lwz r10, 0x40(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 824038E8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824038EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824038F0: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824038F4: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824038F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403900 size=196
    let mut pc: u32 = 0x82403900;
    'dispatch: loop {
        match pc {
            0x82403900 => {
    //   block [0x82403900..0x824039C4)
	// 82403900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82403904: 481317B9  bl 0x825350bc
	ctx.lr = 0x82403908;
	sub_82535080(ctx, base);
	// 82403908: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240390C: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 82403910: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82403914: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82403918: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8240391C: 48131235  bl 0x82534b50
	ctx.lr = 0x82403920;
	sub_82534B50(ctx, base);
	// 82403920: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82403924: 393E002C  addi r9, r30, 0x2c
	ctx.r[9].s64 = ctx.r[30].s64 + 44;
	// 82403928: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240392C: 41820010  beq 0x8240393c
	if ctx.cr[0].eq {
	pc = 0x8240393C; continue 'dispatch;
	}
	// 82403930: 3FA08000  lis r29, -0x8000
	ctx.r[29].s64 = -2147483648;
	// 82403934: 63BD4005  ori r29, r29, 0x4005
	ctx.r[29].u64 = ctx.r[29].u64 | 16389;
	// 82403938: 48000080  b 0x824039b8
	pc = 0x824039B8; continue 'dispatch;
	// 8240393C: A0DF0026  lhz r6, 0x26(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 82403940: 28060000  cmplwi r6, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82403944: 4182000C  beq 0x82403950
	if ctx.cr[0].eq {
	pc = 0x82403950; continue 'dispatch;
	}
	// 82403948: 913F003C  stw r9, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[9].u32 ) };
	// 8240394C: 7D264A14  add r9, r6, r9
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[9].u64;
	// 82403950: A15F001A  lhz r10, 0x1a(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(26 as u32) ) } as u64;
	// 82403954: A11F0018  lhz r8, 0x18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82403958: A17F0028  lhz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8240395C: 7CEA41D6  mullw r7, r10, r8
	ctx.r[7].s64 = (ctx.r[10].s32 as i64) * (ctx.r[8].s32 as i64);
	// 82403960: A15F0020  lhz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82403964: 5548083E  rotlwi r8, r10, 1
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82403968: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8240396C: 913F002C  stw r9, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 82403970: A0BF002A  lhz r5, 0x2a(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(42 as u32) ) } as u64;
	// 82403974: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 82403978: 7D6559D6  mullw r11, r5, r11
	ctx.r[11].s64 = (ctx.r[5].s32 as i64) * (ctx.r[11].s32 as i64);
	// 8240397C: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82403980: 7D4A2050  subf r10, r10, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 82403984: 7D465050  subf r10, r6, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[6].s64;
	// 82403988: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8240398C: 913F0030  stw r9, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[9].u32 ) };
	// 82403990: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82403994: 394AFFD4  addi r10, r10, -0x2c
	ctx.r[10].s64 = ctx.r[10].s64 + -44;
	// 82403998: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 8240399C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824039A0: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 824039A4: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 824039A8: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 824039AC: 7D485A14  add r10, r8, r11
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 824039B0: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 824039B4: 915F0048  stw r10, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 824039B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824039BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824039C0: 4813174C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824039C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824039C8 size=120
    let mut pc: u32 = 0x824039C8;
    'dispatch: loop {
        match pc {
            0x824039C8 => {
    //   block [0x824039C8..0x82403A40)
	// 824039C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824039CC: 481316ED  bl 0x825350b8
	ctx.lr = 0x824039D0;
	sub_82535080(ctx, base);
	// 824039D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824039D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824039D8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 824039DC: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 824039E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824039E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824039E8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 824039EC: 93FC0014  stw r31, 0x14(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 824039F0: 4BFFFE81  bl 0x82403870
	ctx.lr = 0x824039F4;
	sub_82403870(ctx, base);
	// 824039F4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824039F8: 4180003C  blt 0x82403a34
	if ctx.cr[0].lt {
	pc = 0x82403A34; continue 'dispatch;
	}
	// 824039FC: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82403A00: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82403A04: 419A0010  beq cr6, 0x82403a14
	if ctx.cr[6].eq {
	pc = 0x82403A14; continue 'dispatch;
	}
	// 82403A08: A0C10050  lhz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82403A0C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82403A10: 4800000C  b 0x82403a1c
	pc = 0x82403A1C; continue 'dispatch;
	// 82403A14: A0C10052  lhz r6, 0x52(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82403A18: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82403A1C: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82403A20: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82403A24: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82403A28: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82403A2C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82403A30: 48000A31  bl 0x82404460
	ctx.lr = 0x82403A34;
	sub_82404460(ctx, base);
	// 82403A34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82403A38: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82403A3C: 481316CC  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403A40 size=224
    let mut pc: u32 = 0x82403A40;
    'dispatch: loop {
        match pc {
            0x82403A40 => {
    //   block [0x82403A40..0x82403B20)
	// 82403A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82403A44: 48131665  bl 0x825350a8
	ctx.lr = 0x82403A48;
	sub_82535080(ctx, base);
	// 82403A48: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82403A4C: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82403A50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82403A54: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82403A58: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82403A5C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82403A60: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82403A64: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 82403A68: 7D585378  mr r24, r10
	ctx.r[24].u64 = ctx.r[10].u64;
	// 82403A6C: 57CB0673  rlwinm. r11, r30, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403A70: 41820014  beq 0x82403a84
	if ctx.cr[0].eq {
	pc = 0x82403A84; continue 'dispatch;
	}
	// 82403A74: 48309DE9  bl 0x8270d85c
	ctx.lr = 0x82403A78;
	// extern call 0x8270D85C  crate::xboxkrnl::KeGetCurrentProcessType
	crate::xboxkrnl::KeGetCurrentProcessType(ctx, base);
	// 82403A78: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82403A7C: 409A0008  bne cr6, 0x82403a84
	if !ctx.cr[6].eq {
	pc = 0x82403A84; continue 'dispatch;
	}
	// 82403A80: 63DE0010  ori r30, r30, 0x10
	ctx.r[30].u64 = ctx.r[30].u64 | 16;
	// 82403A84: 816100FC  lwz r11, 0xfc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 82403A88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82403A8C: 8061011C  lwz r3, 0x11c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 82403A90: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82403A94: 81210104  lwz r9, 0x104(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82403A98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82403A9C: 810100F4  lwz r8, 0xf4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82403AA0: 80A10114  lwz r5, 0x114(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 82403AA4: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82403AA8: 81610124  lwz r11, 0x124(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 82403AAC: 907F002C  stw r3, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[3].u32 ) };
	// 82403AB0: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 82403AB4: 8081010C  lwz r4, 0x10c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 82403AB8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82403ABC: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82403AC0: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82403AC4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82403AC8: 935F0010  stw r26, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 82403ACC: 933F0014  stw r25, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[25].u32 ) };
	// 82403AD0: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82403AD4: 913F0020  stw r9, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 82403AD8: 931F0024  stw r24, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[24].u32 ) };
	// 82403ADC: 911F0028  stw r8, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 82403AE0: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82403AE4: 4800097D  bl 0x82404460
	ctx.lr = 0x82403AE8;
	sub_82404460(ctx, base);
	// 82403AE8: 8161012C  lwz r11, 0x12c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(300 as u32) ) } as u64;
	// 82403AEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82403AF0: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82403AF4: 419A0020  beq cr6, 0x82403b14
	if ctx.cr[6].eq {
	pc = 0x82403B14; continue 'dispatch;
	}
	// 82403AF8: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82403AFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82403B00: 41820008  beq 0x82403b08
	if ctx.cr[0].eq {
	pc = 0x82403B08; continue 'dispatch;
	}
	// 82403B04: 4BFBD93D  bl 0x823c1440
	ctx.lr = 0x82403B08;
	sub_823C1440(ctx, base);
	// 82403B08: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82403B0C: 394003E5  li r10, 0x3e5
	ctx.r[10].s64 = 997;
	// 82403B10: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82403B14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82403B18: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82403B1C: 481315DC  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403B20 size=192
    let mut pc: u32 = 0x82403B20;
    'dispatch: loop {
        match pc {
            0x82403B20 => {
    //   block [0x82403B20..0x82403BE0)
	// 82403B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82403B24: 48131589  bl 0x825350ac
	ctx.lr = 0x82403B28;
	sub_82535080(ctx, base);
	// 82403B28: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82403B2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82403B30: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82403B34: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 82403B38: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82403B3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82403B40: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82403B44: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82403B48: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 82403B4C: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82403B50: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	// 82403B54: 4BFFFE75  bl 0x824039c8
	ctx.lr = 0x82403B58;
	sub_824039C8(ctx, base);
	// 82403B58: 7C791B79  or. r25, r3, r3
	ctx.r[25].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 82403B5C: 40800038  bge 0x82403b94
	if !ctx.cr[0].lt {
	pc = 0x82403B94; continue 'dispatch;
	}
	// 82403B60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82403B64: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82403B68: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82403B6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82403B70: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82403B74: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82403B78: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82403B7C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82403B80: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82403B84: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82403B88: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82403B8C: 917F0438  stw r11, 0x438(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1080 as u32), ctx.r[11].u32 ) };
	// 82403B90: 48000044  b 0x82403bd4
	pc = 0x82403BD4; continue 'dispatch;
	// 82403B94: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82403B98: 939F0438  stw r28, 0x438(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1080 as u32), ctx.r[28].u32 ) };
	// 82403B9C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82403BA0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82403BA4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82403BA8: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82403BAC: 480008B5  bl 0x82404460
	ctx.lr = 0x82403BB0;
	sub_82404460(ctx, base);
	// 82403BB0: 395F0038  addi r10, r31, 0x38
	ctx.r[10].s64 = ctx.r[31].s64 + 56;
	// 82403BB4: 39200040  li r9, 0x40
	ctx.r[9].s64 = 64;
	// 82403BB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82403BBC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82403BC0: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82403BC4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82403BC8: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82403BCC: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82403BD0: 4082FFEC  bne 0x82403bbc
	if !ctx.cr[0].eq {
	pc = 0x82403BBC; continue 'dispatch;
	}
	// 82403BD4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82403BD8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82403BDC: 48131520  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403BE0 size=136
    let mut pc: u32 = 0x82403BE0;
    'dispatch: loop {
        match pc {
            0x82403BE0 => {
    //   block [0x82403BE0..0x82403C68)
	// 82403BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82403BE4: 481314D9  bl 0x825350bc
	ctx.lr = 0x82403BE8;
	sub_82535080(ctx, base);
	// 82403BE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82403BEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82403BF0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82403BF4: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82403BF8: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 82403BFC: 4199005C  bgt cr6, 0x82403c58
	if ctx.cr[6].gt {
	pc = 0x82403C58; continue 'dispatch;
	}
	// 82403C00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82403C04: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82403C08: 4BFFF821  bl 0x82403428
	ctx.lr = 0x82403C0C;
	sub_82403428(ctx, base);
	// 82403C0C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403C10: 41800050  blt 0x82403c60
	if ctx.cr[0].lt {
	pc = 0x82403C60; continue 'dispatch;
	}
	// 82403C14: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82403C18: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82403C1C: 419A000C  beq cr6, 0x82403c28
	if ctx.cr[6].eq {
	pc = 0x82403C28; continue 'dispatch;
	}
	// 82403C20: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82403C24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82403C28: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82403C2C: 554A06FE  clrlwi r10, r10, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82403C30: 812B0200  lwz r9, 0x200(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(512 as u32) ) } as u64;
	// 82403C34: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82403C38: 40980010  bge cr6, 0x82403c48
	if !ctx.cr[6].lt {
	pc = 0x82403C48; continue 'dispatch;
	}
	// 82403C3C: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82403C40: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82403C44: 48000008  b 0x82403c4c
	pc = 0x82403C4C; continue 'dispatch;
	// 82403C48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82403C4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82403C50: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82403C54: 409A000C  bne cr6, 0x82403c60
	if !ctx.cr[6].eq {
	pc = 0x82403C60; continue 'dispatch;
	}
	// 82403C58: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82403C5C: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82403C60: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82403C64: 481314A8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403C68 size=1992
    let mut pc: u32 = 0x82403C68;
    'dispatch: loop {
        match pc {
            0x82403C68 => {
    //   block [0x82403C68..0x82404430)
	// 82403C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82403C6C: 48131415  bl 0x82535080
	ctx.lr = 0x82403C70;
	sub_82535080(ctx, base);
	// 82403C70: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82403C74: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82403C78: 39C00000  li r14, 0
	ctx.r[14].s64 = 0;
	// 82403C7C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82403C80: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82403C84: 2B1C0010  cmplwi cr6, r28, 0x10
	ctx.cr[6].compare_u32(ctx.r[28].u32, 16 as u32, &mut ctx.xer);
	// 82403C88: 9381014C  stw r28, 0x14c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), ctx.r[28].u32 ) };
	// 82403C8C: B1C1005A  sth r14, 0x5a(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[14].u16 ) };
	// 82403C90: 93A10154  stw r29, 0x154(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(340 as u32), ctx.r[29].u32 ) };
	// 82403C94: 91C10078  stw r14, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[14].u32 ) };
	// 82403C98: 41980010  blt cr6, 0x82403ca8
	if ctx.cr[6].lt {
	pc = 0x82403CA8; continue 'dispatch;
	}
	// 82403C9C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82403CA0: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82403CA4: 48000250  b 0x82403ef4
	pc = 0x82403EF4; continue 'dispatch;
	// 82403CA8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82403CAC: 419A000C  beq cr6, 0x82403cb8
	if ctx.cr[6].eq {
	pc = 0x82403CB8; continue 'dispatch;
	}
	// 82403CB0: 829D0000  lwz r20, 0(r29)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82403CB4: 48000008  b 0x82403cbc
	pc = 0x82403CBC; continue 'dispatch;
	// 82403CB8: 7DD47378  mr r20, r14
	ctx.r[20].u64 = ctx.r[14].u64;
	// 82403CBC: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 82403CC0: 3AFB001C  addi r23, r27, 0x1c
	ctx.r[23].s64 = ctx.r[27].s64 + 28;
	// 82403CC4: 38810051  addi r4, r1, 0x51
	ctx.r[4].s64 = ctx.r[1].s64 + 81;
	// 82403CC8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403CCC: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82403CD0: 4BFFF759  bl 0x82403428
	ctx.lr = 0x82403CD4;
	sub_82403428(ctx, base);
	// 82403CD4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403CD8: 41800218  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403CDC: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82403CE0: 556BF7BE  rlwinm r11, r11, 0x1e, 0x1e, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82403CE4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82403CE8: 41980200  blt cr6, 0x82403ee8
	if ctx.cr[6].lt {
	pc = 0x82403EE8; continue 'dispatch;
	}
	// 82403CEC: 419A0014  beq cr6, 0x82403d00
	if ctx.cr[6].eq {
	pc = 0x82403D00; continue 'dispatch;
	}
	// 82403CF0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82403CF4: 409801F4  bge cr6, 0x82403ee8
	if !ctx.cr[6].lt {
	pc = 0x82403EE8; continue 'dispatch;
	}
	// 82403CF8: 3881005A  addi r4, r1, 0x5a
	ctx.r[4].s64 = ctx.r[1].s64 + 90;
	// 82403CFC: 48000008  b 0x82403d04
	pc = 0x82403D04; continue 'dispatch;
	// 82403D00: 38810056  addi r4, r1, 0x56
	ctx.r[4].s64 = ctx.r[1].s64 + 86;
	// 82403D04: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403D08: 48000B89  bl 0x82404890
	ctx.lr = 0x82403D0C;
	sub_82404890(ctx, base);
	// 82403D0C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403D10: 418001E0  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403D14: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82403D18: 39E00004  li r15, 4
	ctx.r[15].s64 = 4;
	// 82403D1C: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403D20: 41820040  beq 0x82403d60
	if ctx.cr[0].eq {
	pc = 0x82403D60; continue 'dispatch;
	}
	// 82403D24: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82403D28: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 82403D2C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82403D30: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82403D34: 4BFFFEAD  bl 0x82403be0
	ctx.lr = 0x82403D38;
	sub_82403BE0(ctx, base);
	// 82403D38: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403D3C: 418001B4  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403D40: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82403D44: 813B0008  lwz r9, 8(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82403D48: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82403D4C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82403D50: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82403D54: EA8B0008  ld r20, 8(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82403D58: 91EB0000  stw r15, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[15].u32 ) };
	// 82403D5C: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82403D60: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82403D64: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403D68: 41820018  beq 0x82403d80
	if ctx.cr[0].eq {
	pc = 0x82403D80; continue 'dispatch;
	}
	// 82403D6C: 38810062  addi r4, r1, 0x62
	ctx.r[4].s64 = ctx.r[1].s64 + 98;
	// 82403D70: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403D74: 48000B1D  bl 0x82404890
	ctx.lr = 0x82403D78;
	sub_82404890(ctx, base);
	// 82403D78: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403D7C: 41800174  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403D80: 88810051  lbz r4, 0x51(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82403D84: 3A400001  li r18, 1
	ctx.r[18].s64 = 1;
	// 82403D88: 548B06B5  rlwinm. r11, r4, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403D8C: 4182002C  beq 0x82403db8
	if ctx.cr[0].eq {
	pc = 0x82403DB8; continue 'dispatch;
	}
	// 82403D90: 817B0438  lwz r11, 0x438(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1080 as u32) ) } as u64;
	// 82403D94: 38E10074  addi r7, r1, 0x74
	ctx.r[7].s64 = ctx.r[1].s64 + 116;
	// 82403D98: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82403D9C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 82403DA0: 387B0038  addi r3, r27, 0x38
	ctx.r[3].s64 = ctx.r[27].s64 + 56;
	// 82403DA4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82403DA8: 48000CA1  bl 0x82404a48
	ctx.lr = 0x82403DAC;
	sub_82404A48(ctx, base);
	// 82403DAC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403DB0: 41800140  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403DB4: 48000008  b 0x82403dbc
	pc = 0x82403DBC; continue 'dispatch;
	// 82403DB8: 92410074  stw r18, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[18].u32 ) };
	// 82403DBC: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82403DC0: 7DD17378  mr r17, r14
	ctx.r[17].u64 = ctx.r[14].u64;
	// 82403DC4: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82403DC8: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82403DCC: 409A008C  bne cr6, 0x82403e58
	if !ctx.cr[6].eq {
	pc = 0x82403E58; continue 'dispatch;
	}
	// 82403DD0: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82403DD4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82403DD8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403DDC: 4BFFF705  bl 0x824034e0
	ctx.lr = 0x82403DE0;
	sub_824034E0(ctx, base);
	// 82403DE0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403DE4: 4180010C  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403DE8: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82403DEC: 3BDB0038  addi r30, r27, 0x38
	ctx.r[30].s64 = ctx.r[27].s64 + 56;
	// 82403DF0: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82403DF4: 556406BE  clrlwi r4, r11, 0x1a
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82403DF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82403DFC: 48000B9D  bl 0x82404998
	ctx.lr = 0x82403E00;
	sub_82404998(ctx, base);
	// 82403E00: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403E04: 418000EC  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403E08: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82403E0C: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82403E10: EA0B0008  ld r16, 8(r11)
	ctx.r[16].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82403E14: 554A0673  rlwinm. r10, r10, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82403E18: 41820024  beq 0x82403e3c
	if ctx.cr[0].eq {
	pc = 0x82403E3C; continue 'dispatch;
	}
	// 82403E1C: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 82403E20: A081005C  lhz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82403E24: 807B0030  lwz r3, 0x30(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 82403E28: 4BFFFAA1  bl 0x824038c8
	ctx.lr = 0x82403E2C;
	sub_824038C8(ctx, base);
	// 82403E2C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403E30: 418000C0  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403E34: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82403E38: 7D708038  and r16, r11, r16
	ctx.r[16].u64 = ctx.r[11].u64 & ctx.r[16].u64;
	// 82403E3C: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82403E40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82403E44: 556406BE  clrlwi r4, r11, 0x1a
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82403E48: 48000BA1  bl 0x824049e8
	ctx.lr = 0x82403E4C;
	sub_824049E8(ctx, base);
	// 82403E4C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403E50: 4080000C  bge 0x82403e5c
	if !ctx.cr[0].lt {
	pc = 0x82403E5C; continue 'dispatch;
	}
	// 82403E54: 4800009C  b 0x82403ef0
	pc = 0x82403EF0; continue 'dispatch;
	// 82403E58: 82010084  lwz r16, 0x84(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82403E5C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82403E60: 827B0028  lwz r19, 0x28(r27)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 82403E64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82403E68: 419A0568  beq cr6, 0x824043d0
	if ctx.cr[6].eq {
	pc = 0x824043D0; continue 'dispatch;
	}
	// 82403E6C: EB010088  ld r24, 0x88(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 82403E70: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82403E74: 7DD67378  mr r22, r14
	ctx.r[22].u64 = ctx.r[14].u64;
	// 82403E78: 7DD57378  mr r21, r14
	ctx.r[21].u64 = ctx.r[14].u64;
	// 82403E7C: 716B00F3  andi. r11, r11, 0xf3
	ctx.r[11].u64 = ctx.r[11].u64 & 243;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403E80: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82403E84: 48000008  b 0x82403e8c
	pc = 0x82403E8C; continue 'dispatch;
	// 82403E88: 8381014C  lwz r28, 0x14c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(332 as u32) ) } as u64;
	// 82403E8C: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82403E90: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82403E94: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82403E98: 409A0114  bne cr6, 0x82403fac
	if !ctx.cr[6].eq {
	pc = 0x82403FAC; continue 'dispatch;
	}
	// 82403E9C: 89610055  lbz r11, 0x55(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(85 as u32) ) } as u64;
	// 82403EA0: 56CA043E  clrlwi r10, r22, 0x10
	ctx.r[10].u64 = ctx.r[22].u32 as u64 & 0x0000FFFFu64;
	// 82403EA4: 7DDD7378  mr r29, r14
	ctx.r[29].u64 = ctx.r[14].u64;
	// 82403EA8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82403EAC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403EB0: 4198004C  blt cr6, 0x82403efc
	if ctx.cr[6].lt {
	pc = 0x82403EFC; continue 'dispatch;
	}
	// 82403EB4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82403EB8: 4BFFF571  bl 0x82403428
	ctx.lr = 0x82403EBC;
	sub_82403428(ctx, base);
	// 82403EBC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403EC0: 41800030  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403EC4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82403EC8: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82403ECC: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 82403ED0: 409A0018  bne cr6, 0x82403ee8
	if !ctx.cr[6].eq {
	pc = 0x82403EE8; continue 'dispatch;
	}
	// 82403ED4: 2F150000  cmpwi cr6, r21, 0
	ctx.cr[6].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 82403ED8: 409A0498  bne cr6, 0x82404370
	if !ctx.cr[6].eq {
	pc = 0x82404370; continue 'dispatch;
	}
	// 82403EDC: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82403EE0: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403EE4: 4182048C  beq 0x82404370
	if ctx.cr[0].eq {
	pc = 0x82404370; continue 'dispatch;
	}
	// 82403EE8: 3FE08000  lis r31, -0x8000
	ctx.r[31].s64 = -2147483648;
	// 82403EEC: 63FF4005  ori r31, r31, 0x4005
	ctx.r[31].u64 = ctx.r[31].u64 | 16389;
	// 82403EF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403EF4: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82403EF8: 481311D8  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
	// 82403EFC: 38810052  addi r4, r1, 0x52
	ctx.r[4].s64 = ctx.r[1].s64 + 82;
	// 82403F00: 48000939  bl 0x82404838
	ctx.lr = 0x82403F04;
	sub_82404838(ctx, base);
	// 82403F04: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403F08: 4180FFE8  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403F0C: 89610052  lbz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82403F10: 7DDE7378  mr r30, r14
	ctx.r[30].u64 = ctx.r[14].u64;
	// 82403F14: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82403F18: 41820054  beq 0x82403f6c
	if ctx.cr[0].eq {
	pc = 0x82403F6C; continue 'dispatch;
	}
	// 82403F1C: 38810056  addi r4, r1, 0x56
	ctx.r[4].s64 = ctx.r[1].s64 + 86;
	// 82403F20: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403F24: 4800096D  bl 0x82404890
	ctx.lr = 0x82403F28;
	sub_82404890(ctx, base);
	// 82403F28: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403F2C: 4180FFC4  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403F30: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 82403F34: A0810056  lhz r4, 0x56(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82403F38: 807B0030  lwz r3, 0x30(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 82403F3C: 4BFFF98D  bl 0x824038c8
	ctx.lr = 0x82403F40;
	sub_824038C8(ctx, base);
	// 82403F40: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403F44: 4180FFAC  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403F48: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82403F4C: 7F105840  cmplw cr6, r16, r11
	ctx.cr[6].compare_u32(ctx.r[16].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82403F50: 409A000C  bne cr6, 0x82403f5c
	if !ctx.cr[6].eq {
	pc = 0x82403F5C; continue 'dispatch;
	}
	// 82403F54: 7E5D9378  mr r29, r18
	ctx.r[29].u64 = ctx.r[18].u64;
	// 82403F58: 7E559378  mr r21, r18
	ctx.r[21].u64 = ctx.r[18].u64;
	// 82403F5C: 89610052  lbz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82403F60: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82403F64: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82403F68: 4198FFB4  blt cr6, 0x82403f1c
	if ctx.cr[6].lt {
	pc = 0x82403F1C; continue 'dispatch;
	}
	// 82403F6C: 38810056  addi r4, r1, 0x56
	ctx.r[4].s64 = ctx.r[1].s64 + 86;
	// 82403F70: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403F74: 4800091D  bl 0x82404890
	ctx.lr = 0x82403F78;
	sub_82404890(ctx, base);
	// 82403F78: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403F7C: 4180FF74  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403F80: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82403F84: 409A0028  bne cr6, 0x82403fac
	if !ctx.cr[6].eq {
	pc = 0x82403FAC; continue 'dispatch;
	}
	// 82403F88: A1610056  lhz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82403F8C: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 82403F90: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82403F94: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403F98: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82403F9C: 48000975  bl 0x82404910
	ctx.lr = 0x82403FA0;
	sub_82404910(ctx, base);
	// 82403FA0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403FA4: 4180FF4C  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403FA8: 480003C8  b 0x82404370
	pc = 0x82404370; continue 'dispatch;
	// 82403FAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82403FB0: 83DB0028  lwz r30, 0x28(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 82403FB4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403FB8: 4BFFF471  bl 0x82403428
	ctx.lr = 0x82403FBC;
	sub_82403428(ctx, base);
	// 82403FBC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403FC0: 4180FF30  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403FC4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82403FC8: 556AF7BE  rlwinm r10, r11, 0x1e, 0x1e, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82403FCC: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82403FD0: 41980080  blt cr6, 0x82404050
	if ctx.cr[6].lt {
	pc = 0x82404050; continue 'dispatch;
	}
	// 82403FD4: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 82403FD8: 4198000C  blt cr6, 0x82403fe4
	if ctx.cr[6].lt {
	pc = 0x82403FE4; continue 'dispatch;
	}
	// 82403FDC: 409AFF0C  bne cr6, 0x82403ee8
	if !ctx.cr[6].eq {
	pc = 0x82403EE8; continue 'dispatch;
	}
	// 82403FE0: 48000390  b 0x82404370
	pc = 0x82404370; continue 'dispatch;
	// 82403FE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82403FE8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403FEC: 48000495  bl 0x82404480
	ctx.lr = 0x82403FF0;
	sub_82404480(ctx, base);
	// 82403FF0: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82403FF4: 556A06B5  rlwinm. r10, r11, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82403FF8: 41820050  beq 0x82404048
	if ctx.cr[0].eq {
	pc = 0x82404048; continue 'dispatch;
	}
	// 82403FFC: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82404000: 40820048  bne 0x82404048
	if !ctx.cr[0].eq {
	pc = 0x82404048; continue 'dispatch;
	}
	// 82404004: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 82404008: 419A0038  beq cr6, 0x82404040
	if ctx.cr[6].eq {
	pc = 0x82404040; continue 'dispatch;
	}
	// 8240400C: 81740000  lwz r11, 0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404010: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82404014: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82404018: 389C0001  addi r4, r28, 1
	ctx.r[4].s64 = ctx.r[28].s64 + 1;
	// 8240401C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82404020: 4BFFFC49  bl 0x82403c68
	ctx.lr = 0x82404024;
	sub_82403C68(ctx, base);
	// 82404024: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82404028: 4180FEC8  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 8240402C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404030: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82404034: 4182031C  beq 0x82404350
	if ctx.cr[0].eq {
	pc = 0x82404350; continue 'dispatch;
	}
	// 82404038: 3A940004  addi r20, r20, 4
	ctx.r[20].s64 = ctx.r[20].s64 + 4;
	// 8240403C: 48000334  b 0x82404370
	pc = 0x82404370; continue 'dispatch;
	// 82404040: 91C10068  stw r14, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[14].u32 ) };
	// 82404044: 4BFFFFD0  b 0x82404014
	pc = 0x82404014; continue 'dispatch;
	// 82404048: 92810068  stw r20, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[20].u32 ) };
	// 8240404C: 4BFFFFC8  b 0x82404014
	pc = 0x82404014; continue 'dispatch;
	// 82404050: 7DDA7378  mr r26, r14
	ctx.r[26].u64 = ctx.r[14].u64;
	// 82404054: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82404058: 7DD97378  mr r25, r14
	ctx.r[25].u64 = ctx.r[14].u64;
	// 8240405C: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82404060: 41820044  beq 0x824040a4
	if ctx.cr[0].eq {
	pc = 0x824040A4; continue 'dispatch;
	}
	// 82404064: 38C1005C  addi r6, r1, 0x5c
	ctx.r[6].s64 = ctx.r[1].s64 + 92;
	// 82404068: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 8240406C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82404070: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82404074: 4BFFFB6D  bl 0x82403be0
	ctx.lr = 0x82404078;
	sub_82403BE0(ctx, base);
	// 82404078: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8240407C: 4180FE74  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82404080: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82404084: 813B0008  lwz r9, 8(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82404088: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 8240408C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82404090: 8341005C  lwz r26, 0x5c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82404094: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82404098: EA8B0008  ld r20, 8(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 8240409C: 91EB0000  stw r15, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[15].u32 ) };
	// 824040A0: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 824040A4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824040A8: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824040AC: 41820018  beq 0x824040c4
	if ctx.cr[0].eq {
	pc = 0x824040C4; continue 'dispatch;
	}
	// 824040B0: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 824040B4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 824040B8: 480007D9  bl 0x82404890
	ctx.lr = 0x824040BC;
	sub_82404890(ctx, base);
	// 824040BC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824040C0: 4180FE30  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 824040C4: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824040C8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 824040CC: 556A07BE  clrlwi r10, r11, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 824040D0: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824040D4: 7E5C5030  slw r28, r18, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[28].u64 = 0;
	} else {
		ctx.r[28].u64 = ((ctx.r[18].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 824040D8: 418200C8  beq 0x824041a0
	if ctx.cr[0].eq {
	pc = 0x824041A0; continue 'dispatch;
	}
	// 824040DC: 817B0438  lwz r11, 0x438(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1080 as u32) ) } as u64;
	// 824040E0: 3BDB0038  addi r30, r27, 0x38
	ctx.r[30].s64 = ctx.r[27].s64 + 56;
	// 824040E4: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 824040E8: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 824040EC: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 824040F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824040F4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 824040F8: 48000951  bl 0x82404a48
	ctx.lr = 0x824040FC;
	sub_82404A48(ctx, base);
	// 824040FC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82404100: 4180FDF0  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82404104: 89610058  lbz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82404108: 556A0031  rlwinm. r10, r11, 0, 0, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8240410C: 40820024  bne 0x82404130
	if !ctx.cr[0].eq {
	pc = 0x82404130; continue 'dispatch;
	}
	// 82404110: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404114: 554A0031  rlwinm. r10, r10, 0, 0, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82404118: 40820018  bne 0x82404130
	if !ctx.cr[0].eq {
	pc = 0x82404130; continue 'dispatch;
	}
	// 8240411C: 7E5D9378  mr r29, r18
	ctx.r[29].u64 = ctx.r[18].u64;
	// 82404120: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 82404124: 419A006C  beq cr6, 0x82404190
	if ctx.cr[6].eq {
	pc = 0x82404190; continue 'dispatch;
	}
	// 82404128: 80740000  lwz r3, 0(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 8240412C: 4800000C  b 0x82404138
	pc = 0x82404138; continue 'dispatch;
	// 82404130: 7DDD7378  mr r29, r14
	ctx.r[29].u64 = ctx.r[14].u64;
	// 82404134: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82404138: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 8240413C: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82404140: 41820020  beq 0x82404160
	if ctx.cr[0].eq {
	pc = 0x82404160; continue 'dispatch;
	}
	// 82404144: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82404148: 7E599378  mr r25, r18
	ctx.r[25].u64 = ctx.r[18].u64;
	// 8240414C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82404150: 409A0010  bne cr6, 0x82404160
	if !ctx.cr[6].eq {
	pc = 0x82404160; continue 'dispatch;
	}
	// 82404154: 481307CD  bl 0x82534920
	ctx.lr = 0x82404158;
	sub_82534920(ctx, base);
	// 82404158: 39630001  addi r11, r3, 1
	ctx.r[11].s64 = ctx.r[3].s64 + 1;
	// 8240415C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82404160: 89610058  lbz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82404164: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82404168: 556406BE  clrlwi r4, r11, 0x1a
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 8240416C: 4800087D  bl 0x824049e8
	ctx.lr = 0x82404170;
	sub_824049E8(ctx, base);
	// 82404170: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82404174: 4180FD7C  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82404178: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8240417C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82404180: 80A10070  lwz r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82404184: 419A0014  beq cr6, 0x82404198
	if ctx.cr[6].eq {
	pc = 0x82404198; continue 'dispatch;
	}
	// 82404188: 7DFC7B78  mr r28, r15
	ctx.r[28].u64 = ctx.r[15].u64;
	// 8240418C: 48000024  b 0x824041b0
	pc = 0x824041B0; continue 'dispatch;
	// 82404190: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 82404194: 4BFFFFA4  b 0x82404138
	pc = 0x82404138; continue 'dispatch;
	// 82404198: 7F85E1D6  mullw r28, r5, r28
	ctx.r[28].s64 = (ctx.r[5].s32 as i64) * (ctx.r[28].s32 as i64);
	// 8240419C: 48000014  b 0x824041b0
	pc = 0x824041B0; continue 'dispatch;
	// 824041A0: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 824041A4: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 824041A8: 90A10070  stw r5, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[5].u32 ) };
	// 824041AC: 90810068  stw r4, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[4].u32 ) };
	// 824041B0: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 824041B4: 419A0074  beq cr6, 0x82404228
	if ctx.cr[6].eq {
	pc = 0x82404228; continue 'dispatch;
	}
	// 824041B8: 3BFB0008  addi r31, r27, 8
	ctx.r[31].s64 = ctx.r[27].s64 + 8;
	// 824041BC: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 824041C0: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 824041C4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824041C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824041CC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824041D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 824041D4: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824041D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824041DC: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824041E0: 557D003E  slwi r29, r11, 0
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824041E4: 7CEB4214  add r7, r11, r8
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 824041E8: 6063FDE9  ori r3, r3, 0xfde9
	ctx.r[3].u64 = ctx.r[3].u64 | 65001;
	// 824041EC: 7D1DF050  subf r8, r29, r30
	ctx.r[8].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 824041F0: 48142489  bl 0x82546678
	ctx.lr = 0x824041F4;
	sub_82546678(ctx, base);
	// 824041F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824041F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824041FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82404200: 48000601  bl 0x82404800
	ctx.lr = 0x82404204;
	sub_82404800(ctx, base);
	// 82404204: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82404208: 4180FCE8  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 8240420C: 89610058  lbz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82404210: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82404214: 7BC50020  clrldi r5, r30, 0x20
	ctx.r[5].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 82404218: 556406BE  clrlwi r4, r11, 0x1a
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 8240421C: 387B0038  addi r3, r27, 0x38
	ctx.r[3].s64 = ctx.r[27].s64 + 56;
	// 82404220: 48000939  bl 0x82404b58
	ctx.lr = 0x82404224;
	sub_82404B58(ctx, base);
	// 82404224: 4800008C  b 0x824042b0
	pc = 0x824042B0; continue 'dispatch;
	// 82404228: 7DDF7378  mr r31, r14
	ctx.r[31].u64 = ctx.r[14].u64;
	// 8240422C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82404230: 419A0090  beq cr6, 0x824042c0
	if ctx.cr[6].eq {
	pc = 0x824042C0; continue 'dispatch;
	}
	// 82404234: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404238: 556B07BE  clrlwi r11, r11, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 8240423C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82404240: 4198005C  blt cr6, 0x8240429c
	if ctx.cr[6].lt {
	pc = 0x8240429C; continue 'dispatch;
	}
	// 82404244: 419A0040  beq cr6, 0x82404284
	if ctx.cr[6].eq {
	pc = 0x82404284; continue 'dispatch;
	}
	// 82404248: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8240424C: 41980020  blt cr6, 0x8240426c
	if ctx.cr[6].lt {
	pc = 0x8240426C; continue 'dispatch;
	}
	// 82404250: 409A0070  bne cr6, 0x824042c0
	if !ctx.cr[6].eq {
	pc = 0x824042C0; continue 'dispatch;
	}
	// 82404254: EB040000  ld r24, 0(r4)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 82404258: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 8240425C: 409A0064  bne cr6, 0x824042c0
	if !ctx.cr[6].eq {
	pc = 0x824042C0; continue 'dispatch;
	}
	// 82404260: 387B0008  addi r3, r27, 8
	ctx.r[3].s64 = ctx.r[27].s64 + 8;
	// 82404264: 480004F5  bl 0x82404758
	ctx.lr = 0x82404268;
	sub_82404758(ctx, base);
	// 82404268: 48000048  b 0x824042b0
	pc = 0x824042B0; continue 'dispatch;
	// 8240426C: 83040000  lwz r24, 0(r4)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404270: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82404274: 409A004C  bne cr6, 0x824042c0
	if !ctx.cr[6].eq {
	pc = 0x824042C0; continue 'dispatch;
	}
	// 82404278: 387B0008  addi r3, r27, 8
	ctx.r[3].s64 = ctx.r[27].s64 + 8;
	// 8240427C: 48000455  bl 0x824046d0
	ctx.lr = 0x82404280;
	sub_824046D0(ctx, base);
	// 82404280: 48000030  b 0x824042b0
	pc = 0x824042B0; continue 'dispatch;
	// 82404284: A3040000  lhz r24, 0(r4)
	ctx.r[24].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404288: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 8240428C: 409A0034  bne cr6, 0x824042c0
	if !ctx.cr[6].eq {
	pc = 0x824042C0; continue 'dispatch;
	}
	// 82404290: 387B0008  addi r3, r27, 8
	ctx.r[3].s64 = ctx.r[27].s64 + 8;
	// 82404294: 480003BD  bl 0x82404650
	ctx.lr = 0x82404298;
	sub_82404650(ctx, base);
	// 82404298: 48000018  b 0x824042b0
	pc = 0x824042B0; continue 'dispatch;
	// 8240429C: 8B040000  lbz r24, 0(r4)
	ctx.r[24].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824042A0: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824042A4: 409A001C  bne cr6, 0x824042c0
	if !ctx.cr[6].eq {
	pc = 0x824042C0; continue 'dispatch;
	}
	// 824042A8: 387B0008  addi r3, r27, 8
	ctx.r[3].s64 = ctx.r[27].s64 + 8;
	// 824042AC: 4800032D  bl 0x824045d8
	ctx.lr = 0x824042B0;
	sub_824045D8(ctx, base);
	// 824042B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824042B4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824042B8: 4198FC38  blt cr6, 0x82403ef0
	if ctx.cr[6].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 824042BC: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 824042C0: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 824042C4: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824042C8: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 824042CC: 409A0008  bne cr6, 0x824042d4
	if !ctx.cr[6].eq {
	pc = 0x824042D4; continue 'dispatch;
	}
	// 824042D0: A381005A  lhz r28, 0x5a(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 824042D4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 824042D8: 419A0008  beq cr6, 0x824042e0
	if ctx.cr[6].eq {
	pc = 0x824042E0; continue 'dispatch;
	}
	// 824042DC: 7E9CA214  add r20, r28, r20
	ctx.r[20].u64 = ctx.r[28].u64 + ctx.r[20].u64;
	// 824042E0: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824042E4: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824042E8: 41820088  beq 0x82404370
	if ctx.cr[0].eq {
	pc = 0x82404370; continue 'dispatch;
	}
	// 824042EC: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 824042F0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 824042F4: 4BFFF165  bl 0x82403458
	ctx.lr = 0x824042F8;
	sub_82403458(ctx, base);
	// 824042F8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824042FC: 4180FBF4  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82404300: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 82404304: A081007E  lhz r4, 0x7e(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(126 as u32) ) } as u64;
	// 82404308: 807B0030  lwz r3, 0x30(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 8240430C: 4BFFF5BD  bl 0x824038c8
	ctx.lr = 0x82404310;
	sub_824038C8(ctx, base);
	// 82404310: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82404314: 4180FBDC  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82404318: 8961007C  lbz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8240431C: 3901007C  addi r8, r1, 0x7c
	ctx.r[8].s64 = ctx.r[1].s64 + 124;
	// 82404320: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82404324: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82404328: 5565D1BE  srwi r5, r11, 6
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shr(6);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 8240432C: 80E1006C  lwz r7, 0x6c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82404330: 556406BE  clrlwi r4, r11, 0x1a
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82404334: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82404338: 387B0038  addi r3, r27, 0x38
	ctx.r[3].s64 = ctx.r[27].s64 + 56;
	// 8240433C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82404340: 7E4A2830  slw r10, r18, r5
	if (ctx.r[5].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[18].u32) << ((ctx.r[5].u8 & 0x1F) as u32)) as u64;
	}
	// 82404344: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82404348: 480005D1  bl 0x82404918
	ctx.lr = 0x8240434C;
	sub_82404918(ctx, base);
	// 8240434C: 4BFFFC54  b 0x82403fa0
	pc = 0x82403FA0; continue 'dispatch;
	// 82404350: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82404354: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82404358: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 8240435C: 409A0010  bne cr6, 0x8240436c
	if !ctx.cr[6].eq {
	pc = 0x8240436C; continue 'dispatch;
	}
	// 82404360: A161005A  lhz r11, 0x5a(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 82404364: 7E8BA214  add r20, r11, r20
	ctx.r[20].u64 = ctx.r[11].u64 + ctx.r[20].u64;
	// 82404368: 48000008  b 0x82404370
	pc = 0x82404370; continue 'dispatch;
	// 8240436C: 82810068  lwz r20, 0x68(r1)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82404370: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82404374: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82404378: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 8240437C: 409A0010  bne cr6, 0x8240438c
	if !ctx.cr[6].eq {
	pc = 0x8240438C; continue 'dispatch;
	}
	// 82404380: 56CB043E  clrlwi r11, r22, 0x10
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0x0000FFFFu64;
	// 82404384: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82404388: 5576043E  clrlwi r22, r11, 0x10
	ctx.r[22].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 8240438C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404390: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82404394: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 82404398: 409AFAF0  bne cr6, 0x82403e88
	if !ctx.cr[6].eq {
	pc = 0x82403E88; continue 'dispatch;
	}
	// 8240439C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 824043A0: 3A310001  addi r17, r17, 1
	ctx.r[17].s64 = ctx.r[17].s64 + 1;
	// 824043A4: 7F115840  cmplw cr6, r17, r11
	ctx.cr[6].compare_u32(ctx.r[17].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824043A8: 40980024  bge cr6, 0x824043cc
	if !ctx.cr[6].lt {
	pc = 0x824043CC; continue 'dispatch;
	}
	// 824043AC: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 824043B0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 824043B4: 480000CD  bl 0x82404480
	ctx.lr = 0x824043B8;
	sub_82404480(ctx, base);
	// 824043B8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 824043BC: 7F115840  cmplw cr6, r17, r11
	ctx.cr[6].compare_u32(ctx.r[17].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824043C0: 4098000C  bge cr6, 0x824043cc
	if !ctx.cr[6].lt {
	pc = 0x824043CC; continue 'dispatch;
	}
	// 824043C4: 8381014C  lwz r28, 0x14c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(332 as u32) ) } as u64;
	// 824043C8: 4BFFFAA8  b 0x82403e70
	pc = 0x82403E70; continue 'dispatch;
	// 824043CC: 83A10154  lwz r29, 0x154(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 824043D0: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 824043D4: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824043D8: 4182001C  beq 0x824043f4
	if ctx.cr[0].eq {
	pc = 0x824043F4; continue 'dispatch;
	}
	// 824043DC: 89610060  lbz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824043E0: 387B0038  addi r3, r27, 0x38
	ctx.r[3].s64 = ctx.r[27].s64 + 56;
	// 824043E4: 556406BE  clrlwi r4, r11, 0x1a
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 824043E8: 48000601  bl 0x824049e8
	ctx.lr = 0x824043EC;
	sub_824049E8(ctx, base);
	// 824043EC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824043F0: 4180FB00  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 824043F4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 824043F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824043FC: 409A002C  bne cr6, 0x82404428
	if !ctx.cr[6].eq {
	pc = 0x82404428; continue 'dispatch;
	}
	// 82404400: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82404404: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82404408: 48000079  bl 0x82404480
	ctx.lr = 0x8240440C;
	sub_82404480(ctx, base);
	// 8240440C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82404410: 4180FAE0  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82404414: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82404418: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 8240441C: 4BFFF115  bl 0x82403530
	ctx.lr = 0x82404420;
	sub_82403530(ctx, base);
	// 82404420: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82404424: 4180FACC  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82404428: 929D0000  stw r20, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[20].u32 ) };
	// 8240442C: 4BFFFAC4  b 0x82403ef0
	pc = 0x82403EF0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404430 size=48
    let mut pc: u32 = 0x82404430;
    'dispatch: loop {
        match pc {
            0x82404430 => {
    //   block [0x82404430..0x82404460)
	// 82404430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404438: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240443C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82404440: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82404444: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82404448: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8240444C: 4BFFF81D  bl 0x82403c68
	ctx.lr = 0x82404450;
	sub_82403C68(ctx, base);
	// 82404450: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82404454: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404458: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8240445C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404460 size=28
    let mut pc: u32 = 0x82404460;
    'dispatch: loop {
        match pc {
            0x82404460 => {
    //   block [0x82404460..0x8240447C)
	// 82404460: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82404464: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82404468: 90A30004  stw r5, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 8240446C: 90C30008  stw r6, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82404470: 90E30010  stw r7, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 82404474: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82404478: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404480 size=28
    let mut pc: u32 = 0x82404480;
    'dispatch: loop {
        match pc {
            0x82404480 => {
    //   block [0x82404480..0x8240449C)
	// 82404480: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82404484: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82404488: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8240448C: 40990010  ble cr6, 0x8240449c
	if !ctx.cr[6].gt {
		sub_8240449C(ctx, base);
		return;
	}
	// 82404490: 3C608018  lis r3, -0x7fe8
	ctx.r[3].s64 = -2145910784;
	// 82404494: 60632001  ori r3, r3, 0x2001
	ctx.r[3].u64 = ctx.r[3].u64 | 8193;
	// 82404498: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8240449C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8240449C size=12
    let mut pc: u32 = 0x8240449C;
    'dispatch: loop {
        match pc {
            0x8240449C => {
    //   block [0x8240449C..0x824044A8)
	// 8240449C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824044A0: 908B000C  stw r4, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 824044A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824044A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824044A8 size=44
    let mut pc: u32 = 0x824044A8;
    'dispatch: loop {
        match pc {
            0x824044A8 => {
    //   block [0x824044A8..0x824044D4)
	// 824044A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 824044AC: 81050000  lwz r8, 0(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 824044B0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824044B4: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824044B8: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 824044BC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 824044C0: 40980014  bge cr6, 0x824044d4
	if !ctx.cr[6].lt {
		sub_824044D4(ctx, base);
		return;
	}
	// 824044C4: 3C608018  lis r3, -0x7fe8
	ctx.r[3].s64 = -2145910784;
	// 824044C8: 91250000  stw r9, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824044CC: 60632001  ori r3, r3, 0x2001
	ctx.r[3].u64 = ctx.r[3].u64 | 8193;
	// 824044D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824044D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824044D4 size=36
    let mut pc: u32 = 0x824044D4;
    'dispatch: loop {
        match pc {
            0x824044D4 => {
    //   block [0x824044D4..0x824044F8)
	// 824044D4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824044D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824044DC: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 824044E0: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824044E4: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 824044E8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824044EC: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 824044F0: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824044F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824044F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824044F8 size=220
    let mut pc: u32 = 0x824044F8;
    'dispatch: loop {
        match pc {
            0x824044F8 => {
    //   block [0x824044F8..0x824045D4)
	// 824044F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824044FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404500: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82404504: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404508: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 8240450C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82404510: 4BFFFF99  bl 0x824044a8
	ctx.lr = 0x82404514;
	sub_824044A8(ctx, base);
	// 82404514: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82404518: 418000A4  blt 0x824045bc
	if ctx.cr[0].lt {
	pc = 0x824045BC; continue 'dispatch;
	}
	// 8240451C: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82404520: 419A008C  beq cr6, 0x824045ac
	if ctx.cr[6].eq {
	pc = 0x824045AC; continue 'dispatch;
	}
	// 82404524: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404528: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8240452C: 419A0070  beq cr6, 0x8240459c
	if ctx.cr[6].eq {
	pc = 0x8240459C; continue 'dispatch;
	}
	// 82404530: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82404534: 419A0050  beq cr6, 0x82404584
	if ctx.cr[6].eq {
	pc = 0x82404584; continue 'dispatch;
	}
	// 82404538: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 8240453C: 419A0038  beq cr6, 0x82404574
	if ctx.cr[6].eq {
	pc = 0x82404574; continue 'dispatch;
	}
	// 82404540: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82404544: 419A0010  beq cr6, 0x82404554
	if ctx.cr[6].eq {
	pc = 0x82404554; continue 'dispatch;
	}
	// 82404548: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 8240454C: 63FF000D  ori r31, r31, 0xd
	ctx.r[31].u64 = ctx.r[31].u64 | 13;
	// 82404550: 4800006C  b 0x824045bc
	pc = 0x824045BC; continue 'dispatch;
	// 82404554: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404558: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 8240455C: 7D605C2C  lwbrx r11, 0, r11
	ctx.r[11].u64 = (unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32) }).swap_bytes() as u64;
	// 82404560: 7D40542C  lwbrx r10, 0, r10
	ctx.r[10].u64 = (unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32) }).swap_bytes() as u64;
	// 82404564: 794A07E6  rldicr r10, r10, 0x20, 0x3f
	ctx.r[10].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82404568: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 8240456C: F9670000  std r11, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82404570: 4800004C  b 0x824045bc
	pc = 0x824045BC; continue 'dispatch;
	// 82404574: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404578: 7D605C2C  lwbrx r11, 0, r11
	ctx.r[11].u64 = (unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32) }).swap_bytes() as u64;
	// 8240457C: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82404580: 4800003C  b 0x824045bc
	pc = 0x824045BC; continue 'dispatch;
	// 82404584: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404588: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8240458C: 556AC63E  rlwinm r10, r11, 0x18, 0x18, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82404590: 516A442E  rlwimi r10, r11, 8, 0x10, 0x17
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF00FF);
	// 82404594: B1470000  sth r10, 0(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 82404598: 48000024  b 0x824045bc
	pc = 0x824045BC; continue 'dispatch;
	// 8240459C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824045A0: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824045A4: 99670000  stb r11, 0(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824045A8: 48000014  b 0x824045bc
	pc = 0x824045BC; continue 'dispatch;
	// 824045AC: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 824045B0: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824045B4: 80A50000  lwz r5, 0(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 824045B8: 48130599  bl 0x82534b50
	ctx.lr = 0x824045BC;
	sub_82534B50(ctx, base);
	// 824045BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824045C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824045C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824045C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824045CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824045D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824045D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824045D8 size=116
    let mut pc: u32 = 0x824045D8;
    'dispatch: loop {
        match pc {
            0x824045D8 => {
    //   block [0x824045D8..0x8240464C)
	// 824045D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824045DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824045E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824045E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824045E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824045EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824045F0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 824045F4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824045F8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824045FC: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82404600: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82404604: 40980010  bge cr6, 0x82404614
	if !ctx.cr[6].lt {
	pc = 0x82404614; continue 'dispatch;
	}
	// 82404608: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 8240460C: 6063007A  ori r3, r3, 0x7a
	ctx.r[3].u64 = ctx.r[3].u64 | 122;
	// 82404610: 48000024  b 0x82404634
	pc = 0x82404634; continue 'dispatch;
	// 82404614: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404618: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8240461C: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82404620: 48130531  bl 0x82534b50
	ctx.lr = 0x82404624;
	sub_82534B50(ctx, base);
	// 82404624: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82404628: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8240462C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82404630: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82404634: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82404638: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8240463C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404640: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82404644: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82404648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404650 size=36
    let mut pc: u32 = 0x82404650;
    'dispatch: loop {
        match pc {
            0x82404650 => {
    //   block [0x82404650..0x82404674)
	// 82404650: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82404654: 54AA083C  slwi r10, r5, 1
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82404658: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8240465C: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82404660: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82404664: 40980010  bge cr6, 0x82404674
	if !ctx.cr[6].lt {
		sub_82404674(ctx, base);
		return;
	}
	// 82404668: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 8240466C: 6063007A  ori r3, r3, 0x7a
	ctx.r[3].u64 = ctx.r[3].u64 | 122;
	// 82404670: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404674(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404674 size=44
    let mut pc: u32 = 0x82404674;
    'dispatch: loop {
        match pc {
            0x82404674 => {
    //   block [0x82404674..0x824046A0)
	// 82404674: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404678: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8240467C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82404680: 419A0044  beq cr6, 0x824046c4
	if ctx.cr[6].eq {
		sub_824046A0(ctx, base);
		return;
	}
	// 82404684: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82404688: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240468C: 419A0014  beq cr6, 0x824046a0
	if ctx.cr[6].eq {
		sub_824046A0(ctx, base);
		return;
	}
	// 82404690: A1240000  lhz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404694: 552BC63E  rlwinm r11, r9, 0x18, 0x18, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82404698: 512B442E  rlwimi r11, r9, 8, 0x10, 0x17
	ctx.r[11].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[11].u64 & 0xFFFFFFFFFFFF00FF);
	// 8240469C: 48000008  b 0x824046a4
	sub_824046A0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824046A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824046A0 size=44
    let mut pc: u32 = 0x824046A0;
    'dispatch: loop {
        match pc {
            0x824046A0 => {
    //   block [0x824046A0..0x824046CC)
	// 824046A0: A1640000  lhz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824046A4: B16A0000  sth r11, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 824046A8: 38840002  addi r4, r4, 2
	ctx.r[4].s64 = ctx.r[4].s64 + 2;
	// 824046AC: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 824046B0: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 824046B4: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 824046B8: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 824046BC: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 824046C0: 4082FFC4  bne 0x82404684
	if !ctx.cr[0].eq {
		sub_82404674(ctx, base);
		return;
	}
	// 824046C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824046C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824046D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824046D0 size=36
    let mut pc: u32 = 0x824046D0;
    'dispatch: loop {
        match pc {
            0x824046D0 => {
    //   block [0x824046D0..0x824046F4)
	// 824046D0: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 824046D4: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824046D8: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 824046DC: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 824046E0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 824046E4: 40980010  bge cr6, 0x824046f4
	if !ctx.cr[6].lt {
		sub_824046F4(ctx, base);
		return;
	}
	// 824046E8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 824046EC: 6063007A  ori r3, r3, 0x7a
	ctx.r[3].u64 = ctx.r[3].u64 | 122;
	// 824046F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824046F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824046F4 size=52
    let mut pc: u32 = 0x824046F4;
    'dispatch: loop {
        match pc {
            0x824046F4 => {
    //   block [0x824046F4..0x82404728)
	// 824046F4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824046F8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 824046FC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82404700: 419A004C  beq cr6, 0x8240474c
	if ctx.cr[6].eq {
		sub_82404728(ctx, base);
		return;
	}
	// 82404704: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82404708: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240470C: 419A001C  beq cr6, 0x82404728
	if ctx.cr[6].eq {
		sub_82404728(ctx, base);
		return;
	}
	// 82404710: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404714: 552B463E  srwi r11, r9, 0x18
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(24);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82404718: 512BC42E  rlwimi r11, r9, 0x18, 0x10, 0x17
	ctx.r[11].u64 = (((ctx.r[9].u32).rotate_left(24) as u64) & 0x000000000000FF00) | (ctx.r[11].u64 & 0xFFFFFFFFFFFF00FF);
	// 8240471C: 512B421E  rlwimi r11, r9, 8, 8, 0xf
	ctx.r[11].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x0000000000FF0000) | (ctx.r[11].u64 & 0xFFFFFFFFFF00FFFF);
	// 82404720: 512BC00E  rlwimi r11, r9, 0x18, 0, 7
	ctx.r[11].u64 = (((ctx.r[9].u32).rotate_left(24) as u64) & 0x00000000FF000000) | (ctx.r[11].u64 & 0xFFFFFFFF00FFFFFF);
	// 82404724: 48000008  b 0x8240472c
	sub_82404728(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404728 size=44
    let mut pc: u32 = 0x82404728;
    'dispatch: loop {
        match pc {
            0x82404728 => {
    //   block [0x82404728..0x82404754)
	// 82404728: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8240472C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82404730: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82404734: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82404738: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8240473C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82404740: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82404744: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82404748: 4082FFBC  bne 0x82404704
	if !ctx.cr[0].eq {
		sub_824046F4(ctx, base);
		return;
	}
	// 8240474C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82404750: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404758 size=36
    let mut pc: u32 = 0x82404758;
    'dispatch: loop {
        match pc {
            0x82404758 => {
    //   block [0x82404758..0x8240477C)
	// 82404758: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8240475C: 54AA1838  slwi r10, r5, 3
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82404760: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82404764: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82404768: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8240476C: 40980010  bge cr6, 0x8240477c
	if !ctx.cr[6].lt {
		sub_8240477C(ctx, base);
		return;
	}
	// 82404770: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82404774: 6063007A  ori r3, r3, 0x7a
	ctx.r[3].u64 = ctx.r[3].u64 | 122;
	// 82404778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8240477C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8240477C size=128
    let mut pc: u32 = 0x8240477C;
    'dispatch: loop {
        match pc {
            0x8240477C => {
    //   block [0x8240477C..0x824047FC)
	// 8240477C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404780: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82404784: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82404788: 419A006C  beq cr6, 0x824047f4
	if ctx.cr[6].eq {
	pc = 0x824047F4; continue 'dispatch;
	}
	// 8240478C: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82404790: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82404794: E9440000  ld r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 82404798: 38840008  addi r4, r4, 8
	ctx.r[4].s64 = ctx.r[4].s64 + 8;
	// 8240479C: 419A003C  beq cr6, 0x824047d8
	if ctx.cr[6].eq {
	pc = 0x824047D8; continue 'dispatch;
	}
	// 824047A0: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 824047A4: 8141FFF4  lwz r10, -0xc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 824047A8: 8121FFF0  lwz r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 824047AC: 5548463E  srwi r8, r10, 0x18
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shr(24);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824047B0: 5527463E  srwi r7, r9, 0x18
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shr(24);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 824047B4: 5148C42E  rlwimi r8, r10, 0x18, 0x10, 0x17
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(24) as u64) & 0x000000000000FF00) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF00FF);
	// 824047B8: 5127C42E  rlwimi r7, r9, 0x18, 0x10, 0x17
	ctx.r[7].u64 = (((ctx.r[9].u32).rotate_left(24) as u64) & 0x000000000000FF00) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF00FF);
	// 824047BC: 5148421E  rlwimi r8, r10, 8, 8, 0xf
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x0000000000FF0000) | (ctx.r[8].u64 & 0xFFFFFFFFFF00FFFF);
	// 824047C0: 5127421E  rlwimi r7, r9, 8, 8, 0xf
	ctx.r[7].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x0000000000FF0000) | (ctx.r[7].u64 & 0xFFFFFFFFFF00FFFF);
	// 824047C4: 5148C00E  rlwimi r8, r10, 0x18, 0, 7
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(24) as u64) & 0x00000000FF000000) | (ctx.r[8].u64 & 0xFFFFFFFF00FFFFFF);
	// 824047C8: 5127C00E  rlwimi r7, r9, 0x18, 0, 7
	ctx.r[7].u64 = (((ctx.r[9].u32).rotate_left(24) as u64) & 0x00000000FF000000) | (ctx.r[7].u64 & 0xFFFFFFFF00FFFFFF);
	// 824047CC: 790A07C6  sldi r10, r8, 0x20
	ctx.r[10].u64 = ctx.r[8].u64.wrapping_shl(32);
	ctx.r[10].u32 = ctx.r[10].u64 as u32;
	// 824047D0: 78E90020  clrldi r9, r7, 0x20
	ctx.r[9].u64 = ctx.r[7].u64 & 0x00000000FFFFFFFFu64;
	// 824047D4: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 824047D8: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 824047DC: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 824047E0: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 824047E4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 824047E8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 824047EC: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824047F0: 4082FF9C  bne 0x8240478c
	if !ctx.cr[0].eq {
	pc = 0x8240478C; continue 'dispatch;
	}
	// 824047F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824047F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404800 size=36
    let mut pc: u32 = 0x82404800;
    'dispatch: loop {
        match pc {
            0x82404800 => {
    //   block [0x82404800..0x82404824)
	// 82404800: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82404804: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82404808: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8240480C: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82404810: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82404814: 40980010  bge cr6, 0x82404824
	if !ctx.cr[6].lt {
		sub_82404824(ctx, base);
		return;
	}
	// 82404818: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 8240481C: 6063007A  ori r3, r3, 0x7a
	ctx.r[3].u64 = ctx.r[3].u64 | 122;
	// 82404820: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404824(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404824 size=16
    let mut pc: u32 = 0x82404824;
    'dispatch: loop {
        match pc {
            0x82404824 => {
    //   block [0x82404824..0x82404834)
	// 82404824: 7D4A2214  add r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 82404828: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8240482C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82404830: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404838 size=88
    let mut pc: u32 = 0x82404838;
    'dispatch: loop {
        match pc {
            0x82404838 => {
    //   block [0x82404838..0x82404890)
	// 82404838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240483C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404840: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82404844: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404848: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8240484C: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 82404850: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82404854: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82404858: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8240485C: 4BFFFC4D  bl 0x824044a8
	ctx.lr = 0x82404860;
	sub_824044A8(ctx, base);
	// 82404860: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82404864: 41800014  blt 0x82404878
	if ctx.cr[0].lt {
	pc = 0x82404878; continue 'dispatch;
	}
	// 82404868: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 8240486C: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404870: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82404874: 481302DD  bl 0x82534b50
	ctx.lr = 0x82404878;
	sub_82534B50(ctx, base);
	// 82404878: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8240487C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82404880: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404884: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404888: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8240488C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404890 size=48
    let mut pc: u32 = 0x82404890;
    'dispatch: loop {
        match pc {
            0x82404890 => {
    //   block [0x82404890..0x824048C0)
	// 82404890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404898: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240489C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 824048A0: 80C30010  lwz r6, 0x10(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 824048A4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824048A8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 824048AC: 4BFFFC4D  bl 0x824044f8
	ctx.lr = 0x824048B0;
	sub_824044F8(ctx, base);
	// 824048B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824048B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824048B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824048BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824048C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824048C0 size=76
    let mut pc: u32 = 0x824048C0;
    'dispatch: loop {
        match pc {
            0x824048C0 => {
    //   block [0x824048C0..0x8240490C)
	// 824048C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824048C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824048C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824048CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824048D0: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 824048D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824048D8: 4BFFFBD1  bl 0x824044a8
	ctx.lr = 0x824048DC;
	sub_824044A8(ctx, base);
	// 824048DC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824048E0: 41800014  blt 0x824048f4
	if ctx.cr[0].lt {
	pc = 0x824048F4; continue 'dispatch;
	}
	// 824048E4: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 824048E8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824048EC: 80A50000  lwz r5, 0(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 824048F0: 48130261  bl 0x82534b50
	ctx.lr = 0x824048F4;
	sub_82534B50(ctx, base);
	// 824048F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824048F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824048FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404900: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404904: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82404908: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404910 size=4
    let mut pc: u32 = 0x82404910;
    'dispatch: loop {
        match pc {
            0x82404910 => {
    //   block [0x82404910..0x82404914)
	// 82404910: 4BFFFB98  b 0x824044a8
	sub_824044A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404918 size=48
    let mut pc: u32 = 0x82404918;
    'dispatch: loop {
        match pc {
            0x82404918 => {
    //   block [0x82404918..0x82404948)
	// 82404918: 2B040040  cmplwi cr6, r4, 0x40
	ctx.cr[6].compare_u32(ctx.r[4].u32, 64 as u32, &mut ctx.xer);
	// 8240491C: 4098006C  bge cr6, 0x82404988
	if !ctx.cr[6].lt {
		sub_82404988(ctx, base);
		return;
	}
	// 82404920: 2B050003  cmplwi cr6, r5, 3
	ctx.cr[6].compare_u32(ctx.r[5].u32, 3 as u32, &mut ctx.xer);
	// 82404924: 41990064  bgt cr6, 0x82404988
	if ctx.cr[6].gt {
		sub_82404988(ctx, base);
		return;
	}
	// 82404928: 548B2036  slwi r11, r4, 4
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8240492C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82404930: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404934: 554A0043  rlwinm. r10, r10, 0, 1, 1
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82404938: 41820010  beq 0x82404948
	if ctx.cr[0].eq {
		sub_82404948(ctx, base);
		return;
	}
	// 8240493C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82404940: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82404944: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404948 size=64
    let mut pc: u32 = 0x82404948;
    'dispatch: loop {
        match pc {
            0x82404948 => {
    //   block [0x82404948..0x82404988)
	// 82404948: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8240494C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82404950: 419A0020  beq cr6, 0x82404970
	if ctx.cr[6].eq {
	pc = 0x82404970; continue 'dispatch;
	}
	// 82404954: 89080001  lbz r8, 1(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(1 as u32) ) } as u64;
	// 82404958: 550807FF  clrlwi. r8, r8, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8240495C: 41820014  beq 0x82404970
	if ctx.cr[0].eq {
	pc = 0x82404970; continue 'dispatch;
	}
	// 82404960: 7D482830  slw r8, r10, r5
	if (ctx.r[5].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[10].u32) << ((ctx.r[5].u8 & 0x1F) as u32)) as u64;
	}
	// 82404964: 7D0807B4  extsw r8, r8
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82404968: 7CC64392  divdu r6, r6, r8
	ctx.r[6].u64 = ctx.r[6].u64 / ctx.r[8].u64;
	// 8240496C: 08C80000  tdi 6, r8, 0
	// tdi: trap doubleword immediate  TODO: implement trap semantics
	// 82404970: 5145F83A  rlwimi r5, r10, 0x1f, 0, 0x1d
	ctx.r[5].u64 = (((ctx.r[10].u32).rotate_left(31) as u64) & 0x00000000FFFFFFFC) | (ctx.r[5].u64 & 0xFFFFFFFF00000003);
	// 82404974: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82404978: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8240497C: F8CB0008  std r6, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u64 ) };
	// 82404980: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82404984: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404988 size=12
    let mut pc: u32 = 0x82404988;
    'dispatch: loop {
        match pc {
            0x82404988 => {
    //   block [0x82404988..0x82404994)
	// 82404988: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 8240498C: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82404990: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404998 size=20
    let mut pc: u32 = 0x82404998;
    'dispatch: loop {
        match pc {
            0x82404998 => {
    //   block [0x82404998..0x824049AC)
	// 82404998: 2B040040  cmplwi cr6, r4, 0x40
	ctx.cr[6].compare_u32(ctx.r[4].u32, 64 as u32, &mut ctx.xer);
	// 8240499C: 41980010  blt cr6, 0x824049ac
	if ctx.cr[6].lt {
		sub_824049AC(ctx, base);
		return;
	}
	// 824049A0: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 824049A4: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 824049A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824049AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824049AC size=48
    let mut pc: u32 = 0x824049AC;
    'dispatch: loop {
        match pc {
            0x824049AC => {
    //   block [0x824049AC..0x824049DC)
	// 824049AC: 548B2036  slwi r11, r4, 4
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824049B0: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 824049B4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824049B8: 55490001  rlwinm. r9, r10, 0, 0, 0
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 824049BC: 41820020  beq 0x824049dc
	if ctx.cr[0].eq {
		sub_824049DC(ctx, base);
		return;
	}
	// 824049C0: 55490043  rlwinm. r9, r10, 0, 1, 1
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 824049C4: 40820018  bne 0x824049dc
	if !ctx.cr[0].eq {
		sub_824049DC(ctx, base);
		return;
	}
	// 824049C8: 654A4000  oris r10, r10, 0x4000
	ctx.r[10].u64 = ctx.r[10].u64 | 1073741824;
	// 824049CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824049D0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824049D4: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824049D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824049DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824049DC size=12
    let mut pc: u32 = 0x824049DC;
    'dispatch: loop {
        match pc {
            0x824049DC => {
    //   block [0x824049DC..0x824049E8)
	// 824049DC: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824049E0: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 824049E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824049E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824049E8 size=24
    let mut pc: u32 = 0x824049E8;
    'dispatch: loop {
        match pc {
            0x824049E8 => {
    //   block [0x824049E8..0x82404A00)
	// 824049E8: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 824049EC: 2B040040  cmplwi cr6, r4, 0x40
	ctx.cr[6].compare_u32(ctx.r[4].u32, 64 as u32, &mut ctx.xer);
	// 824049F0: 41980010  blt cr6, 0x82404a00
	if ctx.cr[6].lt {
		sub_82404A00(ctx, base);
		return;
	}
	// 824049F4: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 824049F8: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 824049FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404A00 size=16
    let mut pc: u32 = 0x82404A00;
    'dispatch: loop {
        match pc {
            0x82404A00 => {
    //   block [0x82404A00..0x82404A10)
	// 82404A00: 2B04003F  cmplwi cr6, r4, 0x3f
	ctx.cr[6].compare_u32(ctx.r[4].u32, 63 as u32, &mut ctx.xer);
	// 82404A04: 409A000C  bne cr6, 0x82404a10
	if !ctx.cr[6].eq {
		sub_82404A10(ctx, base);
		return;
	}
	// 82404A08: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82404A0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404A10 size=40
    let mut pc: u32 = 0x82404A10;
    'dispatch: loop {
        match pc {
            0x82404A10 => {
    //   block [0x82404A10..0x82404A38)
	// 82404A10: 548A2036  slwi r10, r4, 4
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82404A14: 7D6A482E  lwzx r11, r10, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82404A18: 55680001  rlwinm. r8, r11, 0, 0, 0
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82404A1C: 4182001C  beq 0x82404a38
	if ctx.cr[0].eq {
		sub_82404A38(ctx, base);
		return;
	}
	// 82404A20: 55680043  rlwinm. r8, r11, 0, 1, 1
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82404A24: 41820014  beq 0x82404a38
	if ctx.cr[0].eq {
		sub_82404A38(ctx, base);
		return;
	}
	// 82404A28: 556B0080  rlwinm r11, r11, 0, 2, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82404A2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82404A30: 7D6A492E  stwx r11, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u32) };
	// 82404A34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404A38 size=12
    let mut pc: u32 = 0x82404A38;
    'dispatch: loop {
        match pc {
            0x82404A38 => {
    //   block [0x82404A38..0x82404A44)
	// 82404A38: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82404A3C: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82404A40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404A48 size=268
    let mut pc: u32 = 0x82404A48;
    'dispatch: loop {
        match pc {
            0x82404A48 => {
    //   block [0x82404A48..0x82404B54)
	// 82404A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404A4C: 48130669  bl 0x825350b4
	ctx.lr = 0x82404A50;
	sub_82535080(ctx, base);
	// 82404A50: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404A54: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82404A58: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82404A5C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82404A60: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82404A64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82404A68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82404A6C: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82404A70: 4BFFEA41  bl 0x824034b0
	ctx.lr = 0x82404A74;
	sub_824034B0(ctx, base);
	// 82404A74: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82404A78: 418000C8  blt 0x82404b40
	if ctx.cr[0].lt {
	pc = 0x82404B40; continue 'dispatch;
	}
	// 82404A7C: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404A80: 556A06BE  clrlwi r10, r11, 0x1a
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82404A84: 2B0A003F  cmplwi cr6, r10, 0x3f
	ctx.cr[6].compare_u32(ctx.r[10].u32, 63 as u32, &mut ctx.xer);
	// 82404A88: 419A00B8  beq cr6, 0x82404b40
	if ctx.cr[6].eq {
	pc = 0x82404B40; continue 'dispatch;
	}
	// 82404A8C: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82404A90: 41820088  beq 0x82404b18
	if ctx.cr[0].eq {
	pc = 0x82404B18; continue 'dispatch;
	}
	// 82404A94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82404A98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82404A9C: 4BFFFDF5  bl 0x82404890
	ctx.lr = 0x82404AA0;
	sub_82404890(ctx, base);
	// 82404AA0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82404AA4: 4180009C  blt 0x82404b40
	if ctx.cr[0].lt {
	pc = 0x82404B40; continue 'dispatch;
	}
	// 82404AA8: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82404AAC: A0810050  lhz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404AB0: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82404AB4: 4BFFEE15  bl 0x824038c8
	ctx.lr = 0x82404AB8;
	sub_824038C8(ctx, base);
	// 82404AB8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82404ABC: 41800084  blt 0x82404b40
	if ctx.cr[0].lt {
	pc = 0x82404B40; continue 'dispatch;
	}
	// 82404AC0: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404AC4: 57A907BE  clrlwi r9, r29, 0x1e
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0x00000003u64;
	// 82404AC8: 556B06BE  clrlwi r11, r11, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82404ACC: 2B0B0040  cmplwi cr6, r11, 0x40
	ctx.cr[6].compare_u32(ctx.r[11].u32, 64 as u32, &mut ctx.xer);
	// 82404AD0: 40980078  bge cr6, 0x82404b48
	if !ctx.cr[6].lt {
	pc = 0x82404B48; continue 'dispatch;
	}
	// 82404AD4: 2B090003  cmplwi cr6, r9, 3
	ctx.cr[6].compare_u32(ctx.r[9].u32, 3 as u32, &mut ctx.xer);
	// 82404AD8: 41990070  bgt cr6, 0x82404b48
	if ctx.cr[6].gt {
	pc = 0x82404B48; continue 'dispatch;
	}
	// 82404ADC: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82404AE0: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82404AE4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404AE8: 554A0043  rlwinm. r10, r10, 0, 1, 1
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82404AEC: 41820010  beq 0x82404afc
	if ctx.cr[0].eq {
	pc = 0x82404AFC; continue 'dispatch;
	}
	// 82404AF0: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82404AF4: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82404AF8: 48000048  b 0x82404b40
	pc = 0x82404B40; continue 'dispatch;
	// 82404AFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82404B00: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82404B04: 5149F83A  rlwimi r9, r10, 0x1f, 0, 0x1d
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(31) as u64) & 0x00000000FFFFFFFC) | (ctx.r[9].u64 & 0xFFFFFFFF00000003);
	// 82404B08: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82404B0C: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82404B10: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82404B14: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82404B18: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404B1C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82404B20: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82404B24: 556406BE  clrlwi r4, r11, 0x1a
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82404B28: 4BFFFE71  bl 0x82404998
	ctx.lr = 0x82404B2C;
	sub_82404998(ctx, base);
	// 82404B2C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82404B30: 41800010  blt 0x82404b40
	if ctx.cr[0].lt {
	pc = 0x82404B40; continue 'dispatch;
	}
	// 82404B34: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404B38: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82404B3C: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82404B40: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82404B44: 481305C0  b 0x82535104
	sub_825350D0(ctx, base);
	return;
	// 82404B48: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82404B4C: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82404B50: 4BFFFFF0  b 0x82404b40
	pc = 0x82404B40; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404B58 size=240
    let mut pc: u32 = 0x82404B58;
    'dispatch: loop {
        match pc {
            0x82404B58 => {
    //   block [0x82404B58..0x82404C48)
	// 82404B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404B5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404B60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82404B64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82404B68: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404B6C: 548B2036  slwi r11, r4, 4
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82404B70: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 82404B74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82404B78: 7FEB1A14  add r31, r11, r3
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82404B7C: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82404B80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82404B84: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82404B88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404B8C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82404B90: 556B07BE  clrlwi r11, r11, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82404B94: 7D465830  slw r6, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 82404B98: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82404B9C: 90C10054  stw r6, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[6].u32 ) };
	// 82404BA0: 4BFFF8C1  bl 0x82404460
	ctx.lr = 0x82404BA4;
	sub_82404460(ctx, base);
	// 82404BA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404BA8: 556B07BE  clrlwi r11, r11, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82404BAC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82404BB0: 41980060  blt cr6, 0x82404c10
	if ctx.cr[6].lt {
	pc = 0x82404C10; continue 'dispatch;
	}
	// 82404BB4: 419A0040  beq cr6, 0x82404bf4
	if ctx.cr[6].eq {
	pc = 0x82404BF4; continue 'dispatch;
	}
	// 82404BB8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82404BBC: 4198001C  blt cr6, 0x82404bd8
	if ctx.cr[6].lt {
	pc = 0x82404BD8; continue 'dispatch;
	}
	// 82404BC0: 409A006C  bne cr6, 0x82404c2c
	if !ctx.cr[6].eq {
	pc = 0x82404C2C; continue 'dispatch;
	}
	// 82404BC4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82404BC8: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82404BCC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82404BD0: 4BFFFB89  bl 0x82404758
	ctx.lr = 0x82404BD4;
	sub_82404758(ctx, base);
	// 82404BD4: 48000054  b 0x82404c28
	pc = 0x82404C28; continue 'dispatch;
	// 82404BD8: E96100B0  ld r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82404BDC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82404BE0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82404BE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82404BE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82404BEC: 4BFFFAE5  bl 0x824046d0
	ctx.lr = 0x82404BF0;
	sub_824046D0(ctx, base);
	// 82404BF0: 48000038  b 0x82404c28
	pc = 0x82404C28; continue 'dispatch;
	// 82404BF4: E96100B0  ld r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82404BF8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82404BFC: 38810052  addi r4, r1, 0x52
	ctx.r[4].s64 = ctx.r[1].s64 + 82;
	// 82404C00: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82404C04: B1610052  sth r11, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	// 82404C08: 4BFFFA49  bl 0x82404650
	ctx.lr = 0x82404C0C;
	sub_82404650(ctx, base);
	// 82404C0C: 4800001C  b 0x82404c28
	pc = 0x82404C28; continue 'dispatch;
	// 82404C10: E96100B0  ld r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82404C14: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82404C18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82404C1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82404C20: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82404C24: 4BFFF9B5  bl 0x824045d8
	ctx.lr = 0x82404C28;
	sub_824045D8(ctx, base);
	// 82404C28: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82404C2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82404C30: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82404C34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404C38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404C3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82404C40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82404C44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404C48 size=152
    let mut pc: u32 = 0x82404C48;
    'dispatch: loop {
        match pc {
            0x82404C48 => {
    //   block [0x82404C48..0x82404CE0)
	// 82404C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404C4C: 48130471  bl 0x825350bc
	ctx.lr = 0x82404C50;
	sub_82535080(ctx, base);
	// 82404C50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404C54: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82404C58: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82404C5C: 396BBD38  addi r11, r11, -0x42c8
	ctx.r[11].s64 = ctx.r[11].s64 + -17096;
	// 82404C60: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82404C64: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82404C68: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82404C6C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82404C70: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82404C74: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82404C78: 41820058  beq 0x82404cd0
	if ctx.cr[0].eq {
	pc = 0x82404CD0; continue 'dispatch;
	}
	// 82404C7C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82404C80: 4182004C  beq 0x82404ccc
	if ctx.cr[0].eq {
	pc = 0x82404CCC; continue 'dispatch;
	}
	// 82404C84: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82404C88: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404C8C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82404C90: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82404C94: 409AFFF4  bne cr6, 0x82404c88
	if !ctx.cr[6].eq {
	pc = 0x82404C88; continue 'dispatch;
	}
	// 82404C98: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82404C9C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82404CA0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82404CA4: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 82404CA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82404CAC: 4812EFC5  bl 0x82533c70
	ctx.lr = 0x82404CB0;
	sub_82533C70(ctx, base);
	// 82404CB0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82404CB4: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82404CB8: 4182001C  beq 0x82404cd4
	if ctx.cr[0].eq {
	pc = 0x82404CD4; continue 'dispatch;
	}
	// 82404CBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82404CC0: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82404CC4: 481305AD  bl 0x82535270
	ctx.lr = 0x82404CC8;
	sub_82535270(ctx, base);
	// 82404CC8: 4800000C  b 0x82404cd4
	pc = 0x82404CD4; continue 'dispatch;
	// 82404CCC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82404CD0: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82404CD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82404CD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82404CDC: 48130430  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404CE0 size=12
    let mut pc: u32 = 0x82404CE0;
    'dispatch: loop {
        match pc {
            0x82404CE0 => {
    //   block [0x82404CE0..0x82404CEC)
	// 82404CE0: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82404CE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82404CE8: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404CEC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404CEC size=12
    let mut pc: u32 = 0x82404CEC;
    'dispatch: loop {
        match pc {
            0x82404CEC => {
    //   block [0x82404CEC..0x82404CF8)
	// 82404CEC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82404CF0: 386BBD24  addi r3, r11, -0x42dc
	ctx.r[3].s64 = ctx.r[11].s64 + -17116;
	// 82404CF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404CF8 size=104
    let mut pc: u32 = 0x82404CF8;
    'dispatch: loop {
        match pc {
            0x82404CF8 => {
    //   block [0x82404CF8..0x82404D60)
	// 82404CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404D00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82404D04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82404D08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404D0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82404D10: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82404D14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82404D18: 396BBD38  addi r11, r11, -0x42c8
	ctx.r[11].s64 = ctx.r[11].s64 + -17096;
	// 82404D1C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82404D20: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82404D24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82404D28: 419A000C  beq cr6, 0x82404d34
	if ctx.cr[6].eq {
	pc = 0x82404D34; continue 'dispatch;
	}
	// 82404D2C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82404D30: 4812F009  bl 0x82533d38
	ctx.lr = 0x82404D34;
	sub_82533D38(ctx, base);
	// 82404D34: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82404D38: 4182000C  beq 0x82404d44
	if ctx.cr[0].eq {
	pc = 0x82404D44; continue 'dispatch;
	}
	// 82404D3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82404D40: 4812DE79  bl 0x82532bb8
	ctx.lr = 0x82404D44;
	sub_82532BB8(ctx, base);
	// 82404D44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82404D48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82404D4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404D50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404D54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82404D58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82404D5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404D60 size=24
    let mut pc: u32 = 0x82404D60;
    'dispatch: loop {
        match pc {
            0x82404D60 => {
    //   block [0x82404D60..0x82404D78)
	// 82404D60: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82404D64: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82404D68: 396BBD38  addi r11, r11, -0x42c8
	ctx.r[11].s64 = ctx.r[11].s64 + -17096;
	// 82404D6C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82404D70: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82404D74: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404D78 size=8
    let mut pc: u32 = 0x82404D78;
    'dispatch: loop {
        match pc {
            0x82404D78 => {
    //   block [0x82404D78..0x82404D80)
	// 82404D78: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82404D7C: 4812EFBC  b 0x82533d38
	sub_82533D38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404D80 size=4
    let mut pc: u32 = 0x82404D80;
    'dispatch: loop {
        match pc {
            0x82404D80 => {
    //   block [0x82404D80..0x82404D84)
	// 82404D80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404D88 size=60
    let mut pc: u32 = 0x82404D88;
    'dispatch: loop {
        match pc {
            0x82404D88 => {
    //   block [0x82404D88..0x82404DC4)
	// 82404D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404D90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82404D94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404D98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82404D9C: 4BFFFEAD  bl 0x82404c48
	ctx.lr = 0x82404DA0;
	sub_82404C48(ctx, base);
	// 82404DA0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82404DA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82404DA8: 396BBD38  addi r11, r11, -0x42c8
	ctx.r[11].s64 = ctx.r[11].s64 + -17096;
	// 82404DAC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82404DB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82404DB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404DB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404DBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82404DC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404DC8 size=192
    let mut pc: u32 = 0x82404DC8;
    'dispatch: loop {
        match pc {
            0x82404DC8 => {
    //   block [0x82404DC8..0x82404E88)
	// 82404DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404DCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404DD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82404DD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82404DD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404DDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82404DE0: 48000014  b 0x82404df4
	pc = 0x82404DF4; continue 'dispatch;
	// 82404DE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82404DE8: 48131911  bl 0x825366f8
	ctx.lr = 0x82404DEC;
	sub_825366F8(ctx, base);
	// 82404DEC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82404DF0: 4182002C  beq 0x82404e1c
	if ctx.cr[0].eq {
	pc = 0x82404E1C; continue 'dispatch;
	}
	// 82404DF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82404DF8: 4812EE79  bl 0x82533c70
	ctx.lr = 0x82404DFC;
	sub_82533C70(ctx, base);
	// 82404DFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82404E00: 4182FFE4  beq 0x82404de4
	if ctx.cr[0].eq {
	pc = 0x82404DE4; continue 'dispatch;
	}
	// 82404E04: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82404E08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404E0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404E10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82404E14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82404E18: 4E800020  blr
	return;
	// 82404E1C: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 82404E20: 816A381C  lwz r11, 0x381c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14364 as u32) ) } as u64;
	// 82404E24: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82404E28: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82404E2C: 3BC9BD38  addi r30, r9, -0x42c8
	ctx.r[30].s64 = ctx.r[9].s64 + -17096;
	// 82404E30: 3D208288  lis r9, -0x7d78
	ctx.r[9].s64 = -2105016320;
	// 82404E34: 3BE93810  addi r31, r9, 0x3810
	ctx.r[31].s64 = ctx.r[9].s64 + 14352;
	// 82404E38: 40820030  bne 0x82404e68
	if !ctx.cr[0].eq {
	pc = 0x82404E68; continue 'dispatch;
	}
	// 82404E3C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82404E40: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 82404E44: 3869CC18  addi r3, r9, -0x33e8
	ctx.r[3].s64 = ctx.r[9].s64 + -13288;
	// 82404E48: 916A381C  stw r11, 0x381c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(14364 as u32), ctx.r[11].u32 ) };
	// 82404E4C: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 82404E50: 816B31A0  lwz r11, 0x31a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12704 as u32) ) } as u64;
	// 82404E54: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82404E58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82404E5C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82404E60: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82404E64: 4812DCD5  bl 0x82532b38
	ctx.lr = 0x82404E68;
	sub_82532B38(ctx, base);
	// 82404E68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82404E6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82404E70: 4BFFFDD9  bl 0x82404c48
	ctx.lr = 0x82404E74;
	sub_82404C48(ctx, base);
	// 82404E74: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82404E78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82404E7C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82404E80: 388BA6AC  addi r4, r11, -0x5954
	ctx.r[4].s64 = ctx.r[11].s64 + -22868;
	// 82404E84: 481318BD  bl 0x82536740
	ctx.lr = 0x82404E88;
	sub_82536740(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404E88 size=144
    let mut pc: u32 = 0x82404E88;
    'dispatch: loop {
        match pc {
            0x82404E88 => {
    //   block [0x82404E88..0x82404F18)
	// 82404E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404E8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404E90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82404E94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82404E98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404E9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82404EA0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82404EA4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82404EA8: 48132221  bl 0x825370c8
	ctx.lr = 0x82404EAC;
	sub_825370C8(ctx, base);
	// 82404EAC: 48131C7D  bl 0x82536b28
	ctx.lr = 0x82404EB0;
	sub_82536B28(ctx, base);
	// 82404EB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82404EB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82404EB8: 388B0040  addi r4, r11, 0x40
	ctx.r[4].s64 = ctx.r[11].s64 + 64;
	// 82404EBC: 48131A3D  bl 0x825368f8
	ctx.lr = 0x82404EC0;
	sub_825368F8(ctx, base);
	// 82404EC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82404EC4: 409A000C  bne cr6, 0x82404ed0
	if !ctx.cr[6].eq {
	pc = 0x82404ED0; continue 'dispatch;
	}
	// 82404EC8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82404ECC: 3BEBCD5C  addi r31, r11, -0x32a4
	ctx.r[31].s64 = ctx.r[11].s64 + -12964;
	// 82404ED0: 48131C59  bl 0x82536b28
	ctx.lr = 0x82404ED4;
	sub_82536B28(ctx, base);
	// 82404ED4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82404ED8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82404EDC: 388B0040  addi r4, r11, 0x40
	ctx.r[4].s64 = ctx.r[11].s64 + 64;
	// 82404EE0: 48131A19  bl 0x825368f8
	ctx.lr = 0x82404EE4;
	sub_825368F8(ctx, base);
	// 82404EE4: 48131C45  bl 0x82536b28
	ctx.lr = 0x82404EE8;
	sub_82536B28(ctx, base);
	// 82404EE8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82404EEC: 38830040  addi r4, r3, 0x40
	ctx.r[4].s64 = ctx.r[3].s64 + 64;
	// 82404EF0: 396B4CC4  addi r11, r11, 0x4cc4
	ctx.r[11].s64 = ctx.r[11].s64 + 19652;
	// 82404EF4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82404EF8: 48131A01  bl 0x825368f8
	ctx.lr = 0x82404EFC;
	sub_825368F8(ctx, base);
	// 82404EFC: 48131925  bl 0x82536820
	ctx.lr = 0x82404F00;
	sub_82536820(ctx, base);
	// 82404F00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82404F04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404F08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404F0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82404F10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82404F14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404F18 size=64
    let mut pc: u32 = 0x82404F18;
    'dispatch: loop {
        match pc {
            0x82404F18 => {
    //   block [0x82404F18..0x82404F58)
	// 82404F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404F1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404F20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404F24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404F28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82404F2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82404F30: 4E800421  bctrl
	ctx.lr = 0x82404F34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82404F34: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82404F38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82404F3C: 396BBD40  addi r11, r11, -0x42c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17088;
	// 82404F40: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82404F44: 4BFFFF45  bl 0x82404e88
	ctx.lr = 0x82404F48;
	sub_82404E88(ctx, base);
	// 82404F48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82404F4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404F50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404F54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404F58 size=4
    let mut pc: u32 = 0x82404F58;
    'dispatch: loop {
        match pc {
            0x82404F58 => {
    //   block [0x82404F58..0x82404F5C)
	// 82404F58: 4BFFFE70  b 0x82404dc8
	sub_82404DC8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404F60 size=8
    let mut pc: u32 = 0x82404F60;
    'dispatch: loop {
        match pc {
            0x82404F60 => {
    //   block [0x82404F60..0x82404F68)
	// 82404F60: 825373A8  lwz r18, 0x73a8(r19)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(29608 as u32) ) } as u64;
	// 82404F64: 8200BD68  lwz r16, -0x4298(0)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, -17048u32 ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404F68 size=76
    let mut pc: u32 = 0x82404F68;
    'dispatch: loop {
        match pc {
            0x82404F68 => {
    //   block [0x82404F68..0x82404FB4)
	// 82404F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404F6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404F70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82404F74: 3BE1FF50  addi r31, r1, -0xb0
	ctx.r[31].s64 = ctx.r[1].s64 + -176;
	// 82404F78: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404F7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82404F80: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82404F84: 388BBD4C  addi r4, r11, -0x42b4
	ctx.r[4].s64 = ctx.r[11].s64 + -17076;
	// 82404F88: 4BF02371  bl 0x823072f8
	ctx.lr = 0x82404F8C;
	sub_823072F8(ctx, base);
	// 82404F8C: 389F0050  addi r4, r31, 0x50
	ctx.r[4].s64 = ctx.r[31].s64 + 80;
	// 82404F90: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 82404F94: 4BF01DC5  bl 0x82306d58
	ctx.lr = 0x82404F98;
	sub_82306D58(ctx, base);
	// 82404F98: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82404F9C: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 82404FA0: 388BA700  addi r4, r11, -0x5900
	ctx.r[4].s64 = ctx.r[11].s64 + -22784;
	// 82404FA4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82404FA8: 396BCD70  addi r11, r11, -0x3290
	ctx.r[11].s64 = ctx.r[11].s64 + -12944;
	// 82404FAC: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82404FB0: 48131791  bl 0x82536740
	ctx.lr = 0x82404FB4;
	sub_82536740(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404FB4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404FB4 size=40
    let mut pc: u32 = 0x82404FB4;
    'dispatch: loop {
        match pc {
            0x82404FB4 => {
    //   block [0x82404FB4..0x82404FDC)
	// 82404FB4: 3BECFF50  addi r31, r12, -0xb0
	ctx.r[31].s64 = ctx.r[12].s64 + -176;
	// 82404FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404FBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404FC0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404FC4: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82404FC8: 4BF01FA1  bl 0x82306f68
	ctx.lr = 0x82404FCC;
	sub_82306F68(ctx, base);
	// 82404FCC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82404FD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404FD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404FD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404FE0 size=8
    let mut pc: u32 = 0x82404FE0;
    'dispatch: loop {
        match pc {
            0x82404FE0 => {
    //   block [0x82404FE0..0x82404FE8)
	// 82404FE0: 825373A8  lwz r18, 0x73a8(r19)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(29608 as u32) ) } as u64;
	// 82404FE4: 8200BDA0  lwz r16, -0x4260(0)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, -16992u32 ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404FE8 size=68
    let mut pc: u32 = 0x82404FE8;
    'dispatch: loop {
        match pc {
            0x82404FE8 => {
    //   block [0x82404FE8..0x8240502C)
	// 82404FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404FEC: 481300D1  bl 0x825350bc
	ctx.lr = 0x82404FF0;
	sub_82535080(ctx, base);
	// 82404FF0: 3BE1FF90  addi r31, r1, -0x70
	ctx.r[31].s64 = ctx.r[1].s64 + -112;
	// 82404FF4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404FF8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82404FFC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82405000: 93DF0084  stw r30, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82405004: 4BFFFC45  bl 0x82404c48
	ctx.lr = 0x82405008;
	sub_82404C48(ctx, base);
	// 82405008: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240500C: 389D000C  addi r4, r29, 0xc
	ctx.r[4].s64 = ctx.r[29].s64 + 12;
	// 82405010: 396BCD64  addi r11, r11, -0x329c
	ctx.r[11].s64 = ctx.r[11].s64 + -12956;
	// 82405014: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 82405018: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8240501C: 4BF01EFD  bl 0x82306f18
	ctx.lr = 0x82405020;
	sub_82306F18(ctx, base);
	// 82405020: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82405024: 383F0070  addi r1, r31, 0x70
	ctx.r[1].s64 = ctx.r[31].s64 + 112;
	// 82405028: 481300E4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8240502C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8240502C size=40
    let mut pc: u32 = 0x8240502C;
    'dispatch: loop {
        match pc {
            0x8240502C => {
    //   block [0x8240502C..0x82405054)
	// 8240502C: 3BECFF90  addi r31, r12, -0x70
	ctx.r[31].s64 = ctx.r[12].s64 + -112;
	// 82405030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82405034: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82405038: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240503C: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82405040: 4BFFFD21  bl 0x82404d60
	ctx.lr = 0x82405044;
	sub_82404D60(ctx, base);
	// 82405044: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82405048: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8240504C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82405050: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82405058 size=60
    let mut pc: u32 = 0x82405058;
    'dispatch: loop {
        match pc {
            0x82405058 => {
    //   block [0x82405058..0x82405094)
	// 82405058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240505C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82405060: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82405064: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82405068: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8240506C: 4BFFFF7D  bl 0x82404fe8
	ctx.lr = 0x82405070;
	sub_82404FE8(ctx, base);
	// 82405070: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82405074: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405078: 396BCD70  addi r11, r11, -0x3290
	ctx.r[11].s64 = ctx.r[11].s64 + -12944;
	// 8240507C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82405080: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82405084: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82405088: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8240508C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82405090: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405098 size=8
    let mut pc: u32 = 0x82405098;
    'dispatch: loop {
        match pc {
            0x82405098 => {
    //   block [0x82405098..0x824050A0)
	// 82405098: 825373A8  lwz r18, 0x73a8(r19)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(29608 as u32) ) } as u64;
	// 8240509C: 8200BDF0  lwz r16, -0x4210(0)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, -16912u32 ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824050A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824050A0 size=76
    let mut pc: u32 = 0x824050A0;
    'dispatch: loop {
        match pc {
            0x824050A0 => {
    //   block [0x824050A0..0x824050EC)
	// 824050A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824050A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824050A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824050AC: 3BE1FF50  addi r31, r1, -0xb0
	ctx.r[31].s64 = ctx.r[1].s64 + -176;
	// 824050B0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824050B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824050B8: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 824050BC: 388BBDD0  addi r4, r11, -0x4230
	ctx.r[4].s64 = ctx.r[11].s64 + -16944;
	// 824050C0: 4BF02239  bl 0x823072f8
	ctx.lr = 0x824050C4;
	sub_823072F8(ctx, base);
	// 824050C4: 389F0050  addi r4, r31, 0x50
	ctx.r[4].s64 = ctx.r[31].s64 + 80;
	// 824050C8: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 824050CC: 4BF01C8D  bl 0x82306d58
	ctx.lr = 0x824050D0;
	sub_82306D58(ctx, base);
	// 824050D0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 824050D4: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 824050D8: 388BA758  addi r4, r11, -0x58a8
	ctx.r[4].s64 = ctx.r[11].s64 + -22696;
	// 824050DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824050E0: 396B05F4  addi r11, r11, 0x5f4
	ctx.r[11].s64 = ctx.r[11].s64 + 1524;
	// 824050E4: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 824050E8: 48131659  bl 0x82536740
	ctx.lr = 0x824050EC;
	sub_82536740(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824050EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824050EC size=40
    let mut pc: u32 = 0x824050EC;
    'dispatch: loop {
        match pc {
            0x824050EC => {
    //   block [0x824050EC..0x82405114)
	// 824050EC: 3BECFF50  addi r31, r12, -0xb0
	ctx.r[31].s64 = ctx.r[12].s64 + -176;
	// 824050F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824050F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824050F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824050FC: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82405100: 4BF01E69  bl 0x82306f68
	ctx.lr = 0x82405104;
	sub_82306F68(ctx, base);
	// 82405104: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82405108: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8240510C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82405110: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82405118 size=60
    let mut pc: u32 = 0x82405118;
    'dispatch: loop {
        match pc {
            0x82405118 => {
    //   block [0x82405118..0x82405154)
	// 82405118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240511C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82405120: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82405124: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82405128: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8240512C: 4BFFFEBD  bl 0x82404fe8
	ctx.lr = 0x82405130;
	sub_82404FE8(ctx, base);
	// 82405130: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82405134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405138: 396B05F4  addi r11, r11, 0x5f4
	ctx.r[11].s64 = ctx.r[11].s64 + 1524;
	// 8240513C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82405140: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82405144: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82405148: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8240514C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82405150: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405158 size=48
    let mut pc: u32 = 0x82405158;
    'dispatch: loop {
        match pc {
            0x82405158 => {
    //   block [0x82405158..0x82405188)
	// 82405158: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8240515C: 816B5868  lwz r11, 0x5868(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22632 as u32) ) } as u64;
	// 82405160: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82405164: 40980024  bge cr6, 0x82405188
	if !ctx.cr[6].lt {
		sub_82405188(ctx, base);
		return;
	}
	// 82405168: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8240516C: 4198001C  blt cr6, 0x82405188
	if ctx.cr[6].lt {
		sub_82405188(ctx, base);
		return;
	}
	// 82405170: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82405174: 1D43132C  mulli r10, r3, 0x132c
	ctx.r[10].s64 = ctx.r[3].s64 * 4908;
	// 82405178: 396B5870  addi r11, r11, 0x5870
	ctx.r[11].s64 = ctx.r[11].s64 + 22640;
	// 8240517C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82405180: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82405184: 480025E4  b 0x82407768
	sub_82407768(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405188 size=12
    let mut pc: u32 = 0x82405188;
    'dispatch: loop {
        match pc {
            0x82405188 => {
    //   block [0x82405188..0x82405194)
	// 82405188: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 8240518C: 6063000A  ori r3, r3, 0xa
	ctx.r[3].u64 = ctx.r[3].u64 | 10;
	// 82405190: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405198 size=48
    let mut pc: u32 = 0x82405198;
    'dispatch: loop {
        match pc {
            0x82405198 => {
    //   block [0x82405198..0x824051C8)
	// 82405198: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8240519C: 816B5868  lwz r11, 0x5868(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22632 as u32) ) } as u64;
	// 824051A0: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824051A4: 40980024  bge cr6, 0x824051c8
	if !ctx.cr[6].lt {
		sub_824051C8(ctx, base);
		return;
	}
	// 824051A8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 824051AC: 4198001C  blt cr6, 0x824051c8
	if ctx.cr[6].lt {
		sub_824051C8(ctx, base);
		return;
	}
	// 824051B0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824051B4: 1D43132C  mulli r10, r3, 0x132c
	ctx.r[10].s64 = ctx.r[3].s64 * 4908;
	// 824051B8: 396B5870  addi r11, r11, 0x5870
	ctx.r[11].s64 = ctx.r[11].s64 + 22640;
	// 824051BC: 396B0050  addi r11, r11, 0x50
	ctx.r[11].s64 = ctx.r[11].s64 + 80;
	// 824051C0: 7C6A5AAE  lhax r3, r10, r11
	ctx.r[3].s64 = (unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as i16) as i64;
	// 824051C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824051C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824051C8 size=12
    let mut pc: u32 = 0x824051C8;
    'dispatch: loop {
        match pc {
            0x824051C8 => {
    //   block [0x824051C8..0x824051D4)
	// 824051C8: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824051CC: 6063000A  ori r3, r3, 0xa
	ctx.r[3].u64 = ctx.r[3].u64 | 10;
	// 824051D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824051D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824051D8 size=44
    let mut pc: u32 = 0x824051D8;
    'dispatch: loop {
        match pc {
            0x824051D8 => {
    //   block [0x824051D8..0x82405204)
	// 824051D8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824051DC: 816B5868  lwz r11, 0x5868(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22632 as u32) ) } as u64;
	// 824051E0: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824051E4: 40980020  bge cr6, 0x82405204
	if !ctx.cr[6].lt {
		sub_82405204(ctx, base);
		return;
	}
	// 824051E8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 824051EC: 41980018  blt cr6, 0x82405204
	if ctx.cr[6].lt {
		sub_82405204(ctx, base);
		return;
	}
	// 824051F0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824051F4: 1D43132C  mulli r10, r3, 0x132c
	ctx.r[10].s64 = ctx.r[3].s64 * 4908;
	// 824051F8: 396B5870  addi r11, r11, 0x5870
	ctx.r[11].s64 = ctx.r[11].s64 + 22640;
	// 824051FC: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82405200: 48002540  b 0x82407740
	sub_82407740(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405204(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405204 size=12
    let mut pc: u32 = 0x82405204;
    'dispatch: loop {
        match pc {
            0x82405204 => {
    //   block [0x82405204..0x82405210)
	// 82405204: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82405208: 6063000A  ori r3, r3, 0xa
	ctx.r[3].u64 = ctx.r[3].u64 | 10;
	// 8240520C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405210 size=12
    let mut pc: u32 = 0x82405210;
    'dispatch: loop {
        match pc {
            0x82405210 => {
    //   block [0x82405210..0x8240521C)
	// 82405210: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82405214: 806B5868  lwz r3, 0x5868(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22632 as u32) ) } as u64;
	// 82405218: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82405220 size=316
    let mut pc: u32 = 0x82405220;
    'dispatch: loop {
        match pc {
            0x82405220 => {
    //   block [0x82405220..0x8240535C)
	// 82405220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82405224: 4812FE91  bl 0x825350b4
	ctx.lr = 0x82405228;
	sub_82535080(ctx, base);
	// 82405228: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240522C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82405230: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82405234: 48001C1D  bl 0x82406e50
	ctx.lr = 0x82405238;
	sub_82406E50(ctx, base);
	// 82405238: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8240523C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82405240: 3BEB3824  addi r31, r11, 0x3824
	ctx.r[31].s64 = ctx.r[11].s64 + 14372;
	// 82405244: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82405248: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8240524C: 409A00F4  bne cr6, 0x82405340
	if !ctx.cr[6].eq {
	pc = 0x82405340; continue 'dispatch;
	}
	// 82405250: 3FA08273  lis r29, -0x7d8d
	ctx.r[29].s64 = -2106392576;
	// 82405254: 3C600002  lis r3, 2
	ctx.r[3].s64 = 131072;
	// 82405258: 60632A24  ori r3, r3, 0x2a24
	ctx.r[3].u64 = ctx.r[3].u64 | 10788;
	// 8240525C: 817D3800  lwz r11, 0x3800(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14336 as u32) ) } as u64;
	// 82405260: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82405264: 4E800421  bctrl
	ctx.lr = 0x82405268;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82405268: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8240526C: 4182000C  beq 0x82405278
	if ctx.cr[0].eq {
	pc = 0x82405278; continue 'dispatch;
	}
	// 82405270: 48002551  bl 0x824077c0
	ctx.lr = 0x82405274;
	sub_824077C0(ctx, base);
	// 82405274: 48000008  b 0x8240527c
	pc = 0x8240527C; continue 'dispatch;
	// 82405278: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8240527C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82405280: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82405284: 48002585  bl 0x82407808
	ctx.lr = 0x82405288;
	sub_82407808(ctx, base);
	// 82405288: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8240528C: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 82405290: 419A0018  beq cr6, 0x824052a8
	if ctx.cr[6].eq {
	pc = 0x824052A8; continue 'dispatch;
	}
	// 82405294: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82405298: 386BBE54  addi r3, r11, -0x41ac
	ctx.r[3].s64 = ctx.r[11].s64 + -16812;
	// 8240529C: 4BEADCE5  bl 0x822b2f80
	ctx.lr = 0x824052A0;
	sub_822B2F80(ctx, base);
	// 824052A0: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824052A4: 480000B0  b 0x82405354
	pc = 0x82405354; continue 'dispatch;
	// 824052A8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824052AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824052B0: 409A002C  bne cr6, 0x824052dc
	if !ctx.cr[6].eq {
	pc = 0x824052DC; continue 'dispatch;
	}
	// 824052B4: 817D3800  lwz r11, 0x3800(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14336 as u32) ) } as u64;
	// 824052B8: 38601C5C  li r3, 0x1c5c
	ctx.r[3].s64 = 7260;
	// 824052BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824052C0: 4E800421  bctrl
	ctx.lr = 0x824052C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824052C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824052C8: 4182000C  beq 0x824052d4
	if ctx.cr[0].eq {
	pc = 0x824052D4; continue 'dispatch;
	}
	// 824052CC: 4800288D  bl 0x82407b58
	ctx.lr = 0x824052D0;
	sub_82407B58(ctx, base);
	// 824052D0: 48000008  b 0x824052d8
	pc = 0x824052D8; continue 'dispatch;
	// 824052D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824052D8: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 824052DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824052E0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824052E4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824052E8: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	// 824052EC: 48004B15  bl 0x82409e00
	ctx.lr = 0x824052F0;
	sub_82409E00(ctx, base);
	// 824052F0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824052F4: 40820060  bne 0x82405354
	if !ctx.cr[0].eq {
	pc = 0x82405354; continue 'dispatch;
	}
	// 824052F8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 824052FC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82405300: 48002669  bl 0x82407968
	ctx.lr = 0x82405304;
	sub_82407968(ctx, base);
	// 82405304: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82405308: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 8240530C: 4099002C  ble cr6, 0x82405338
	if !ctx.cr[6].gt {
	pc = 0x82405338; continue 'dispatch;
	}
	// 82405310: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82405314: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82405318: 480031E1  bl 0x824084f8
	ctx.lr = 0x8240531C;
	sub_824084F8(ctx, base);
	// 8240531C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82405320: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82405324: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82405328: 48002569  bl 0x82407890
	ctx.lr = 0x8240532C;
	sub_82407890(ctx, base);
	// 8240532C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82405330: 7F1EE000  cmpw cr6, r30, r28
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82405334: 4198FFDC  blt cr6, 0x82405310
	if ctx.cr[6].lt {
	pc = 0x82405310; continue 'dispatch;
	}
	// 82405338: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8240533C: 48000018  b 0x82405354
	pc = 0x82405354; continue 'dispatch;
	// 82405340: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82405344: 386BBE20  addi r3, r11, -0x41e0
	ctx.r[3].s64 = ctx.r[11].s64 + -16864;
	// 82405348: 4BEADC39  bl 0x822b2f80
	ctx.lr = 0x8240534C;
	sub_822B2F80(ctx, base);
	// 8240534C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82405350: 60630028  ori r3, r3, 0x28
	ctx.r[3].u64 = ctx.r[3].u64 | 40;
	// 82405354: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82405358: 4812FDAC  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405360 size=12
    let mut pc: u32 = 0x82405360;
    'dispatch: loop {
        match pc {
            0x82405360 => {
    //   block [0x82405360..0x8240536C)
	// 82405360: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82405364: 806B3828  lwz r3, 0x3828(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405368: 480036C0  b 0x82408a28
	sub_82408A28(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405370 size=16
    let mut pc: u32 = 0x82405370;
    'dispatch: loop {
        match pc {
            0x82405370 => {
    //   block [0x82405370..0x82405380)
	// 82405370: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82405374: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82405378: 806B3828  lwz r3, 0x3828(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 8240537C: 48002A1C  b 0x82407d98
	sub_82407D98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405380 size=12
    let mut pc: u32 = 0x82405380;
    'dispatch: loop {
        match pc {
            0x82405380 => {
    //   block [0x82405380..0x8240538C)
	// 82405380: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82405384: 806B3828  lwz r3, 0x3828(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405388: 4800F1A8  b 0x82414530
	sub_82414530(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82405390 size=24
    let mut pc: u32 = 0x82405390;
    'dispatch: loop {
        match pc {
            0x82405390 => {
    //   block [0x82405390..0x824053A8)
	// 82405390: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82405394: 816B3828  lwz r11, 0x3828(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405398: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8240539C: 419A000C  beq cr6, 0x824053a8
	if ctx.cr[6].eq {
		sub_824053A8(ctx, base);
		return;
	}
	// 824053A0: C02B1C1C  lfs f1, 0x1c1c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7196 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824053A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824053A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824053A8 size=12
    let mut pc: u32 = 0x824053A8;
    'dispatch: loop {
        match pc {
            0x824053A8 => {
    //   block [0x824053A8..0x824053B4)
	// 824053A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824053AC: C02B2268  lfs f1, 0x2268(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8808 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824053B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824053B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824053B8 size=16
    let mut pc: u32 = 0x824053B8;
    'dispatch: loop {
        match pc {
            0x824053B8 => {
    //   block [0x824053B8..0x824053C8)
	// 824053B8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824053BC: 816B3828  lwz r11, 0x3828(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 824053C0: C02B1C20  lfs f1, 0x1c20(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7200 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824053C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824053C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824053C8 size=32
    let mut pc: u32 = 0x824053C8;
    'dispatch: loop {
        match pc {
            0x824053C8 => {
    //   block [0x824053C8..0x824053E8)
	// 824053C8: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 824053CC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 824053D0: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 824053D4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824053D8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 824053DC: 814A3828  lwz r10, 0x3828(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14376 as u32) ) } as u64;
	// 824053E0: 806A1C38  lwz r3, 0x1c38(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(7224 as u32) ) } as u64;
	// 824053E4: 480072D4  b 0x8240c6b8
	sub_8240C6B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824053E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824053E8 size=28
    let mut pc: u32 = 0x824053E8;
    'dispatch: loop {
        match pc {
            0x824053E8 => {
    //   block [0x824053E8..0x82405404)
	// 824053E8: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 824053EC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 824053F0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824053F4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 824053F8: 814A3828  lwz r10, 0x3828(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14376 as u32) ) } as u64;
	// 824053FC: 806A1C38  lwz r3, 0x1c38(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(7224 as u32) ) } as u64;
	// 82405400: 48006FD8  b 0x8240c3d8
	sub_8240C3D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405408 size=28
    let mut pc: u32 = 0x82405408;
    'dispatch: loop {
        match pc {
            0x82405408 => {
    //   block [0x82405408..0x82405424)
	// 82405408: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8240540C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82405410: 816B3828  lwz r11, 0x3828(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405414: 816B1C38  lwz r11, 0x1c38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7224 as u32) ) } as u64;
	// 82405418: 3C6B0008  addis r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 524288;
	// 8240541C: 3863030C  addi r3, r3, 0x30c
	ctx.r[3].s64 = ctx.r[3].s64 + 780;
	// 82405420: 48001650  b 0x82406a70
	sub_82406A70(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82405428 size=408
    let mut pc: u32 = 0x82405428;
    'dispatch: loop {
        match pc {
            0x82405428 => {
    //   block [0x82405428..0x824055C0)
	// 82405428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240542C: 4812FC8D  bl 0x825350b8
	ctx.lr = 0x82405430;
	sub_82535080(ctx, base);
	// 82405430: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82405434: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82405438: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8240543C: 3BAB3824  addi r29, r11, 0x3824
	ctx.r[29].s64 = ctx.r[11].s64 + 14372;
	// 82405440: 80BF00C8  lwz r5, 0xc8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82405444: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82405448: 809F00C4  lwz r4, 0xc4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 8240544C: 806B1C38  lwz r3, 0x1c38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7224 as u32) ) } as u64;
	// 82405450: 48007331  bl 0x8240c780
	ctx.lr = 0x82405454;
	sub_8240C780(ctx, base);
	// 82405454: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82405458: 4080001C  bge 0x82405474
	if !ctx.cr[0].lt {
	pc = 0x82405474; continue 'dispatch;
	}
	// 8240545C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82405460: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82405464: 386BBE80  addi r3, r11, -0x4180
	ctx.r[3].s64 = ctx.r[11].s64 + -16768;
	// 82405468: 4BEADB19  bl 0x822b2f80
	ctx.lr = 0x8240546C;
	sub_822B2F80(ctx, base);
	// 8240546C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82405470: 48000148  b 0x824055b8
	pc = 0x824055B8; continue 'dispatch;
	// 82405474: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82405478: 809F00CC  lwz r4, 0xcc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 8240547C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82405480: 3C6B0002  addis r3, r11, 2
	ctx.r[3].s64 = ctx.r[11].s64 + 131072;
	// 82405484: 3863000C  addi r3, r3, 0xc
	ctx.r[3].s64 = ctx.r[3].s64 + 12;
	// 82405488: 48005A29  bl 0x8240aeb0
	ctx.lr = 0x8240548C;
	sub_8240AEB0(ctx, base);
	// 8240548C: 809F00C0  lwz r4, 0xc0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82405490: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82405494: 4800539D  bl 0x8240a830
	ctx.lr = 0x82405498;
	sub_8240A830(ctx, base);
	// 82405498: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8240549C: C05F00A0  lfs f2, 0xa0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 824054A0: C03F009C  lfs f1, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824054A4: 48005335  bl 0x8240a7d8
	ctx.lr = 0x824054A8;
	sub_8240A7D8(ctx, base);
	// 824054A8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 824054AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824054B0: 811F00BC  lwz r8, 0xbc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 824054B4: 80FF00B8  lwz r7, 0xb8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 824054B8: 80DF00B4  lwz r6, 0xb4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 824054BC: 809F00B0  lwz r4, 0xb0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 824054C0: 480057C9  bl 0x8240ac88
	ctx.lr = 0x824054C4;
	sub_8240AC88(ctx, base);
	// 824054C4: 2F03FFFD  cmpwi cr6, r3, -3
	ctx.cr[6].compare_i32(ctx.r[3].s32, -3, &mut ctx.xer);
	// 824054C8: 409A0010  bne cr6, 0x824054d8
	if !ctx.cr[6].eq {
	pc = 0x824054D8; continue 'dispatch;
	}
	// 824054CC: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824054D0: 60630017  ori r3, r3, 0x17
	ctx.r[3].u64 = ctx.r[3].u64 | 23;
	// 824054D4: 480000E4  b 0x824055b8
	pc = 0x824055B8; continue 'dispatch;
	// 824054D8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 824054DC: 4098000C  bge cr6, 0x824054e8
	if !ctx.cr[6].lt {
	pc = 0x824054E8; continue 'dispatch;
	}
	// 824054E0: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824054E4: 480000D4  b 0x824055b8
	pc = 0x824055B8; continue 'dispatch;
	// 824054E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824054EC: C03F0000  lfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824054F0: 48004BD9  bl 0x8240a0c8
	ctx.lr = 0x824054F4;
	sub_8240A0C8(ctx, base);
	// 824054F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824054F8: C03F0008  lfs f1, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824054FC: 48004C75  bl 0x8240a170
	ctx.lr = 0x82405500;
	sub_8240A170(ctx, base);
	// 82405500: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82405504: C03F00A8  lfs f1, 0xa8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82405508: 4BEEBEC9  bl 0x822f13d0
	ctx.lr = 0x8240550C;
	sub_822F13D0(ctx, base);
	// 8240550C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82405510: C03F00AC  lfs f1, 0xac(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82405514: 4BEEBEBD  bl 0x822f13d0
	ctx.lr = 0x82405518;
	sub_822F13D0(ctx, base);
	// 82405518: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8240551C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82405520: 809F00CC  lwz r4, 0xcc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82405524: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82405528: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8240552C: D001019C  stfs f0, 0x19c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82405530: D00101AC  stfs f0, 0x1ac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 82405534: D00101B0  stfs f0, 0x1b0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 82405538: 916101A4  stw r11, 0x1a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 8240553C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82405540: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82405544: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82405548: D1A101A0  stfs f13, 0x1a0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 8240554C: D1A101A8  stfs f13, 0x1a8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82405550: 806B1C3C  lwz r3, 0x1c3c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82405554: 48005E0D  bl 0x8240b360
	ctx.lr = 0x82405558;
	sub_8240B360(ctx, base);
	// 82405558: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 8240555C: 80C10088  lwz r6, 0x88(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82405560: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82405564: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82405568: 48004C81  bl 0x8240a1e8
	ctx.lr = 0x8240556C;
	sub_8240A1E8(ctx, base);
	// 8240556C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82405570: 806B1C3C  lwz r3, 0x1c3c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82405574: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82405578: 616B0B00  ori r11, r11, 0xb00
	ctx.r[11].u64 = ctx.r[11].u64 | 2816;
	// 8240557C: 7D63582E  lwzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82405580: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82405584: 409A0028  bne cr6, 0x824055ac
	if !ctx.cr[6].eq {
	pc = 0x824055AC; continue 'dispatch;
	}
	// 82405588: 809F00CC  lwz r4, 0xcc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 8240558C: 4800625D  bl 0x8240b7e8
	ctx.lr = 0x82405590;
	sub_8240B7E8(ctx, base);
	// 82405590: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82405594: 40820018  bne 0x824055ac
	if !ctx.cr[0].eq {
	pc = 0x824055AC; continue 'dispatch;
	}
	// 82405598: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8240559C: 48004A45  bl 0x82409fe0
	ctx.lr = 0x824055A0;
	sub_82409FE0(ctx, base);
	// 824055A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824055A4: 48004AB5  bl 0x8240a058
	ctx.lr = 0x824055A8;
	sub_8240A058(ctx, base);
	// 824055A8: 4800000C  b 0x824055b4
	pc = 0x824055B4; continue 'dispatch;
	// 824055AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824055B0: 480049C9  bl 0x82409f78
	ctx.lr = 0x824055B4;
	sub_82409F78(ctx, base);
	// 824055B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824055B8: 382101E0  addi r1, r1, 0x1e0
	ctx.r[1].s64 = ctx.r[1].s64 + 480;
	// 824055BC: 4812FB4C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824055C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824055C0 size=132
    let mut pc: u32 = 0x824055C0;
    'dispatch: loop {
        match pc {
            0x824055C0 => {
    //   block [0x824055C0..0x82405644)
	// 824055C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824055C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824055C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824055CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824055D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 824055D4: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 824055D8: 40980010  bge cr6, 0x824055e8
	if !ctx.cr[6].lt {
	pc = 0x824055E8; continue 'dispatch;
	}
	// 824055DC: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824055E0: 60630016  ori r3, r3, 0x16
	ctx.r[3].u64 = ctx.r[3].u64 | 22;
	// 824055E4: 4800004C  b 0x82405630
	pc = 0x82405630; continue 'dispatch;
	// 824055E8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824055EC: 816B3824  lwz r11, 0x3824(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14372 as u32) ) } as u64;
	// 824055F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824055F4: 3C6B0002  addis r3, r11, 2
	ctx.r[3].s64 = ctx.r[11].s64 + 131072;
	// 824055F8: 3863000C  addi r3, r3, 0xc
	ctx.r[3].s64 = ctx.r[3].s64 + 12;
	// 824055FC: 480058B5  bl 0x8240aeb0
	ctx.lr = 0x82405600;
	sub_8240AEB0(ctx, base);
	// 82405600: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82405604: 4182FFD8  beq 0x824055dc
	if ctx.cr[0].eq {
	pc = 0x824055DC; continue 'dispatch;
	}
	// 82405608: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240560C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405610: C04B1FF8  lfs f2, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82405614: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82405618: 480051C1  bl 0x8240a7d8
	ctx.lr = 0x8240561C;
	sub_8240A7D8(ctx, base);
	// 8240561C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405620: 480049D9  bl 0x82409ff8
	ctx.lr = 0x82405624;
	sub_82409FF8(ctx, base);
	// 82405624: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405628: 480048E9  bl 0x82409f10
	ctx.lr = 0x8240562C;
	sub_82409F10(ctx, base);
	// 8240562C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82405630: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82405634: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82405638: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8240563C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82405640: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82405648 size=144
    let mut pc: u32 = 0x82405648;
    'dispatch: loop {
        match pc {
            0x82405648 => {
    //   block [0x82405648..0x824056D8)
	// 82405648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240564C: 4812FA69  bl 0x825350b4
	ctx.lr = 0x82405650;
	sub_82535080(ctx, base);
	// 82405650: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82405654: 3FC08288  lis r30, -0x7d78
	ctx.r[30].s64 = -2105016320;
	// 82405658: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8240565C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82405660: 817E3828  lwz r11, 0x3828(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405664: 836B1C3C  lwz r27, 0x1c3c(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82405668: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8240566C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82405670: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82405674: 48005BFD  bl 0x8240b270
	ctx.lr = 0x82405678;
	sub_8240B270(ctx, base);
	// 82405678: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8240567C: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82405680: 409A0034  bne cr6, 0x824056b4
	if !ctx.cr[6].eq {
	pc = 0x824056B4; continue 'dispatch;
	}
	// 82405684: 817E3828  lwz r11, 0x3828(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405688: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8240568C: 83AB1C3C  lwz r29, 0x1c3c(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82405690: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82405694: 48005F85  bl 0x8240b618
	ctx.lr = 0x82405698;
	sub_8240B618(ctx, base);
	// 82405698: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 8240569C: 409A000C  bne cr6, 0x824056a8
	if !ctx.cr[6].eq {
	pc = 0x824056A8; continue 'dispatch;
	}
	// 824056A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824056A4: 4BFFFF1D  bl 0x824055c0
	ctx.lr = 0x824056A8;
	sub_824055C0(ctx, base);
	// 824056A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824056AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824056B0: 48005929  bl 0x8240afd8
	ctx.lr = 0x824056B4;
	sub_8240AFD8(ctx, base);
	// 824056B4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 824056B8: 2F1F00C0  cmpwi cr6, r31, 0xc0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 192, &mut ctx.xer);
	// 824056BC: 4198FFAC  blt cr6, 0x82405668
	if ctx.cr[6].lt {
	pc = 0x82405668; continue 'dispatch;
	}
	// 824056C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 824056C4: 807E3828  lwz r3, 0x3828(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14376 as u32) ) } as u64;
	// 824056C8: 48003091  bl 0x82408758
	ctx.lr = 0x824056CC;
	sub_82408758(ctx, base);
	// 824056CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824056D0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824056D4: 4812FA30  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824056D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824056D8 size=96
    let mut pc: u32 = 0x824056D8;
    'dispatch: loop {
        match pc {
            0x824056D8 => {
    //   block [0x824056D8..0x82405738)
	// 824056D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824056DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824056E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824056E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824056E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824056EC: 3FC08288  lis r30, -0x7d78
	ctx.r[30].s64 = -2105016320;
	// 824056F0: 817E3828  lwz r11, 0x3828(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14376 as u32) ) } as u64;
	// 824056F4: 806B1C3C  lwz r3, 0x1c3c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7228 as u32) ) } as u64;
	// 824056F8: 480059A1  bl 0x8240b098
	ctx.lr = 0x824056FC;
	sub_8240B098(ctx, base);
	// 824056FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82405700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405704: 4BFFFEBD  bl 0x824055c0
	ctx.lr = 0x82405708;
	sub_824055C0(ctx, base);
	// 82405708: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 8240570C: 2F1F00C0  cmpwi cr6, r31, 0xc0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 192, &mut ctx.xer);
	// 82405710: 4198FFF0  blt cr6, 0x82405700
	if ctx.cr[6].lt {
	pc = 0x82405700; continue 'dispatch;
	}
	// 82405714: 807E3828  lwz r3, 0x3828(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405718: 48003051  bl 0x82408768
	ctx.lr = 0x8240571C;
	sub_82408768(ctx, base);
	// 8240571C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82405720: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82405724: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82405728: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8240572C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82405730: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82405734: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405738 size=16
    let mut pc: u32 = 0x82405738;
    'dispatch: loop {
        match pc {
            0x82405738 => {
    //   block [0x82405738..0x82405748)
	// 82405738: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8240573C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82405740: 806B3828  lwz r3, 0x3828(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405744: 480028A4  b 0x82407fe8
	sub_82407FE8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405748 size=16
    let mut pc: u32 = 0x82405748;
    'dispatch: loop {
        match pc {
            0x82405748 => {
    //   block [0x82405748..0x82405758)
	// 82405748: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8240574C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82405750: 806B3828  lwz r3, 0x3828(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405754: 48002984  b 0x824080d8
	sub_824080D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405758 size=20
    let mut pc: u32 = 0x82405758;
    'dispatch: loop {
        match pc {
            0x82405758 => {
    //   block [0x82405758..0x8240576C)
	// 82405758: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8240575C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82405760: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82405764: 806B3828  lwz r3, 0x3828(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405768: 48002A28  b 0x82408190
	sub_82408190(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


