pub fn sub_82196928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82196928 size=36
    let mut pc: u32 = 0x82196928;
    'dispatch: loop {
        match pc {
            0x82196928 => {
    //   block [0x82196928..0x8219694C)
	// 82196928: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219692C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82196930: 386B00A0  addi r3, r11, 0xa0
	ctx.r[3].s64 = ctx.r[11].s64 + 160;
	// 82196934: 396B00B0  addi r11, r11, 0xb0
	ctx.r[11].s64 = ctx.r[11].s64 + 176;
	// 82196938: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8219693C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82196940: F9430000  std r10, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82196944: F9630008  std r11, 8(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82196948: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219694C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219694C size=20
    let mut pc: u32 = 0x8219694C;
    'dispatch: loop {
        match pc {
            0x8219694C => {
    //   block [0x8219694C..0x82196960)
	// 8219694C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82196950: F9660000  std r11, 0(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82196954: E9630008  ld r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 82196958: F9660008  std r11, 8(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8219695C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82196960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82196960 size=208
    let mut pc: u32 = 0x82196960;
    'dispatch: loop {
        match pc {
            0x82196960 => {
    //   block [0x82196960..0x82196A30)
	// 82196960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82196964: 4839E759  bl 0x825350bc
	ctx.lr = 0x82196968;
	sub_82535080(ctx, base);
	// 82196968: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219696C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82196970: C0440008  lfs f2, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82196974: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82196978: C0240000  lfs f1, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219697C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82196980: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82196984: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82196988: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219698C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82196990: 48020BA1  bl 0x821b7530
	ctx.lr = 0x82196994;
	sub_821B7530(ctx, base);
	// 82196994: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82196998: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219699C: 419A000C  beq cr6, 0x821969a8
	if ctx.cr[6].eq {
	pc = 0x821969A8; continue 'dispatch;
	}
	// 821969A0: 896B000C  lbz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821969A4: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821969A8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821969AC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821969B0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821969B4: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821969B8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821969BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821969C0: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821969C4: C00B2128  lfs f0, 0x2128(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8488 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821969C8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821969CC: 409A0010  bne cr6, 0x821969dc
	if !ctx.cr[6].eq {
	pc = 0x821969DC; continue 'dispatch;
	}
	// 821969D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821969D4: C1AB2038  lfs f13, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821969D8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821969DC: 387F00A0  addi r3, r31, 0xa0
	ctx.r[3].s64 = ctx.r[31].s64 + 160;
	// 821969E0: C1BF00B0  lfs f13, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821969E4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821969E8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821969EC: D1A30000  stfs f13, 0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821969F0: C1BF00B4  lfs f13, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821969F4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821969F8: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821969FC: C1BF00B8  lfs f13, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196A00: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196A04: D1A30008  stfs f13, 8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82196A08: C1BF00BC  lfs f13, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196A0C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196A10: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82196A14: 419A0014  beq cr6, 0x82196a28
	if ctx.cr[6].eq {
	pc = 0x82196A28; continue 'dispatch;
	}
	// 82196A18: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82196A1C: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82196A20: E9630008  ld r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 82196A24: F97D0008  std r11, 8(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82196A28: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82196A2C: 4839E6E0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82196A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82196A30 size=28
    let mut pc: u32 = 0x82196A30;
    'dispatch: loop {
        match pc {
            0x82196A30 => {
    //   block [0x82196A30..0x82196A4C)
	// 82196A30: 39630150  addi r11, r3, 0x150
	ctx.r[11].s64 = ctx.r[3].s64 + 336;
	// 82196A34: 394301D0  addi r10, r3, 0x1d0
	ctx.r[10].s64 = ctx.r[3].s64 + 464;
	// 82196A38: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82196A3C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82196A40: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82196A44: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82196A48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82196A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82196A50 size=1276
    let mut pc: u32 = 0x82196A50;
    'dispatch: loop {
        match pc {
            0x82196A50 => {
    //   block [0x82196A50..0x82196F4C)
	// 82196A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82196A54: 4839E665  bl 0x825350b8
	ctx.lr = 0x82196A58;
	sub_82535080(ctx, base);
	// 82196A58: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82196A5C: 4839F57D  bl 0x82535fd8
	ctx.lr = 0x82196A60;
	sub_82535FB0(ctx, base);
	// 82196A60: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82196A64: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82196A68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82196A6C: 896BBFF0  lbz r11, -0x4010(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-16400 as u32) ) } as u64;
	// 82196A70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82196A74: 409A04C8  bne cr6, 0x82196f3c
	if !ctx.cr[6].eq {
	pc = 0x82196F3C; continue 'dispatch;
	}
	// 82196A78: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196A7C: 3B9F00D0  addi r28, r31, 0xd0
	ctx.r[28].s64 = ctx.r[31].s64 + 208;
	// 82196A80: 3BDC0020  addi r30, r28, 0x20
	ctx.r[30].s64 = ctx.r[28].s64 + 32;
	// 82196A84: C32B1FF8  lfs f25, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82196A88: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82196A8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82196A90: FFC0C890  fmr f30, f25
	ctx.f[30].f64 = ctx.f[25].f64;
	// 82196A94: FFA0C890  fmr f29, f25
	ctx.f[29].f64 = ctx.f[25].f64;
	// 82196A98: C34BBA38  lfs f26, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82196A9C: FFE0D090  fmr f31, f26
	ctx.f[31].f64 = ctx.f[26].f64;
	// 82196AA0: 4BFFF5B1  bl 0x82196050
	ctx.lr = 0x82196AA4;
	sub_82196050(ctx, base);
	// 82196AA4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196AA8: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196AAC: C36B2490  lfs f27, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82196AB0: EC2006F2  fmuls f1, f0, f27
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82196AB4: 4BF86A15  bl 0x8211d4c8
	ctx.lr = 0x82196AB8;
	sub_8211D4C8(ctx, base);
	// 82196AB8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196ABC: C01E000C  lfs f0, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196AC0: 3BDC0030  addi r30, r28, 0x30
	ctx.r[30].s64 = ctx.r[28].s64 + 48;
	// 82196AC4: EF810032  fmuls f28, f1, f0
	ctx.f[28].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196AC8: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 82196ACC: C30BBFFC  lfs f24, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82196AD0: 387EFFD0  addi r3, r30, -0x30
	ctx.r[3].s64 = ctx.r[30].s64 + -48;
	// 82196AD4: 4BFFF57D  bl 0x82196050
	ctx.lr = 0x82196AD8;
	sub_82196050(ctx, base);
	// 82196AD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82196ADC: 4BFFF575  bl 0x82196050
	ctx.lr = 0x82196AE0;
	sub_82196050(ctx, base);
	// 82196AE0: C01EFFD0  lfs f0, -0x30(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196AE4: EC2006F2  fmuls f1, f0, f27
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82196AE8: 4BF869E1  bl 0x8211d4c8
	ctx.lr = 0x82196AEC;
	sub_8211D4C8(ctx, base);
	// 82196AEC: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82196AF0: C1BEFFDC  lfs f13, -0x24(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196AF4: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82196AF8: EC2C06F2  fmuls f1, f12, f27
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 82196AFC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82196B00: EFC0F7FA  fmadds f30, f0, f31, f30
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[30].f64) as f32) as f64);
	// 82196B04: 4BF869C5  bl 0x8211d4c8
	ctx.lr = 0x82196B08;
	sub_8211D4C8(ctx, base);
	// 82196B08: FDA00A10  fabs f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 82196B0C: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196B10: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 82196B14: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82196B18: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82196B1C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196B20: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82196B24: EFA0EFFA  fmadds f29, f0, f31, f29
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[29].f64) as f32) as f64);
	// 82196B28: EFFF0632  fmuls f31, f31, f24
	ctx.f[31].f64 = (((ctx.f[31].f64 * ctx.f[24].f64) as f32) as f64);
	// 82196B2C: 409AFFA4  bne cr6, 0x82196ad0
	if !ctx.cr[6].eq {
	pc = 0x82196AD0; continue 'dispatch;
	}
	// 82196B30: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196B34: C00B219C  lfs f0, 0x219c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8604 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196B38: EDBD0032  fmuls f13, f29, f0
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196B3C: ED9E0032  fmuls f12, f30, f0
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196B40: FF0DC800  fcmpu cr6, f13, f25
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[25].f64);
	// 82196B44: 4098003C  bge cr6, 0x82196b80
	if !ctx.cr[6].lt {
	pc = 0x82196B80; continue 'dispatch;
	}
	// 82196B48: 481D06C1  bl 0x82367208
	ctx.lr = 0x82196B4C;
	sub_82367208(ctx, base);
	// 82196B4C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 82196B50: C17C005C  lfs f11, 0x5c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82196B54: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82196B58: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82196B5C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82196B60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196B64: FD400018  frsp f10, f0
	ctx.f[10].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82196B68: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196B6C: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196B70: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82196B74: 4098000C  bge cr6, 0x82196b80
	if !ctx.cr[6].lt {
	pc = 0x82196B80; continue 'dispatch;
	}
	// 82196B78: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	// 82196B7C: 48000008  b 0x82196b84
	pc = 0x82196B84; continue 'dispatch;
	// 82196B80: EC0DD02A  fadds f0, f13, f26
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[26].f64) as f32) as f64;
	// 82196B84: C1BC0050  lfs f13, 0x50(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196B88: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82196B8C: D1BF0180  stfs f13, 0x180(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82196B90: C1BC0054  lfs f13, 0x54(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196B94: EDADE02A  fadds f13, f13, f28
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[28].f64) as f32) as f64;
	// 82196B98: D1BF0184  stfs f13, 0x184(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82196B9C: C1BC0058  lfs f13, 0x58(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196BA0: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196BA4: D3FF0188  stfs f31, 0x188(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82196BA8: FF1FC800  fcmpu cr6, f31, f25
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[25].f64);
	// 82196BAC: 40990060  ble cr6, 0x82196c0c
	if !ctx.cr[6].gt {
	pc = 0x82196C0C; continue 'dispatch;
	}
	// 82196BB0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196BB4: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196BB8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82196BBC: 40980030  bge cr6, 0x82196bec
	if !ctx.cr[6].lt {
	pc = 0x82196BEC; continue 'dispatch;
	}
	// 82196BC0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196BC4: C00B2144  lfs f0, 0x2144(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196BC8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196BCC: EDBF0032  fmuls f13, f31, f0
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196BD0: C00B2648  lfs f0, 0x2648(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9800 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196BD4: EC2D06FA  fmadds f1, f13, f27, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[27].f64 + ctx.f[0].f64) as f32) as f64);
	// 82196BD8: 4BF868F1  bl 0x8211d4c8
	ctx.lr = 0x82196BDC;
	sub_8211D4C8(ctx, base);
	// 82196BDC: EC01D02A  fadds f0, f1, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[26].f64) as f32) as f64;
	// 82196BE0: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82196BE4: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82196BE8: 48000028  b 0x82196c10
	pc = 0x82196C10; continue 'dispatch;
	// 82196BEC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196BF0: EC3FD028  fsubs f1, f31, f26
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[26].f64) as f32) as f64);
	// 82196BF4: C84B2970  lfd f2, 0x2970(r11)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(10608 as u32) ) };
	// 82196BF8: 4839CB79  bl 0x82533770
	ctx.lr = 0x82196BFC;
	sub_82533770(ctx, base);
	// 82196BFC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82196C00: EC00D02A  fadds f0, f0, f26
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 82196C04: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82196C08: 48000008  b 0x82196c10
	pc = 0x82196C10; continue 'dispatch;
	// 82196C0C: D33F0188  stfs f25, 0x188(r31)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82196C10: C01F0180  lfs f0, 0x180(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196C14: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196C18: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82196C1C: C3FF0184  lfs f31, 0x184(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82196C20: C3CB2048  lfs f30, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82196C24: FF0DC000  fcmpu cr6, f13, f24
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[24].f64);
	// 82196C28: 41980064  blt cr6, 0x82196c8c
	if ctx.cr[6].lt {
	pc = 0x82196C8C; continue 'dispatch;
	}
	// 82196C2C: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82196C30: FF00C800  fcmpu cr6, f0, f25
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[25].f64);
	// 82196C34: 4098003C  bge cr6, 0x82196c70
	if !ctx.cr[6].lt {
	pc = 0x82196C70; continue 'dispatch;
	}
	// 82196C38: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82196C3C: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82196C40: 4098000C  bge cr6, 0x82196c4c
	if !ctx.cr[6].lt {
	pc = 0x82196C4C; continue 'dispatch;
	}
	// 82196C44: EC1A0028  fsubs f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[0].f64) as f32) as f64);
	// 82196C48: 48000040  b 0x82196c88
	pc = 0x82196C88; continue 'dispatch;
	// 82196C4C: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82196C50: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82196C54: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82196C58: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82196C5C: EC1A0028  fsubs f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[0].f64) as f32) as f64);
	// 82196C60: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82196C64: 41980024  blt cr6, 0x82196c88
	if ctx.cr[6].lt {
	pc = 0x82196C88; continue 'dispatch;
	}
	// 82196C68: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	// 82196C6C: 4800001C  b 0x82196c88
	pc = 0x82196C88; continue 'dispatch;
	// 82196C70: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82196C74: 41980014  blt cr6, 0x82196c88
	if ctx.cr[6].lt {
	pc = 0x82196C88; continue 'dispatch;
	}
	// 82196C78: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82196C7C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82196C80: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82196C84: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82196C88: EC00C028  fsubs f0, f0, f24
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[24].f64) as f32) as f64);
	// 82196C8C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82196C90: EC2006F2  fmuls f1, f0, f27
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82196C94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82196C98: 4BF7B139  bl 0x82111dd0
	ctx.lr = 0x82196C9C;
	sub_82111DD0(ctx, base);
	// 82196C9C: FDA0FA10  fabs f13, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[31].u64 & !0x8000_0000_0000_0000u64;
	// 82196CA0: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82196CA4: FF0DC000  fcmpu cr6, f13, f24
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[24].f64);
	// 82196CA8: 41980064  blt cr6, 0x82196d0c
	if ctx.cr[6].lt {
	pc = 0x82196D0C; continue 'dispatch;
	}
	// 82196CAC: EC1FF028  fsubs f0, f31, f30
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 82196CB0: FF00C800  fcmpu cr6, f0, f25
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[25].f64);
	// 82196CB4: 4098003C  bge cr6, 0x82196cf0
	if !ctx.cr[6].lt {
	pc = 0x82196CF0; continue 'dispatch;
	}
	// 82196CB8: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82196CBC: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82196CC0: 4098000C  bge cr6, 0x82196ccc
	if !ctx.cr[6].lt {
	pc = 0x82196CCC; continue 'dispatch;
	}
	// 82196CC4: EC1A0028  fsubs f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[0].f64) as f32) as f64);
	// 82196CC8: 48000040  b 0x82196d08
	pc = 0x82196D08; continue 'dispatch;
	// 82196CCC: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82196CD0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82196CD4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82196CD8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82196CDC: EC1A0028  fsubs f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[0].f64) as f32) as f64);
	// 82196CE0: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82196CE4: 41980024  blt cr6, 0x82196d08
	if ctx.cr[6].lt {
	pc = 0x82196D08; continue 'dispatch;
	}
	// 82196CE8: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	// 82196CEC: 4800001C  b 0x82196d08
	pc = 0x82196D08; continue 'dispatch;
	// 82196CF0: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82196CF4: 41980014  blt cr6, 0x82196d08
	if ctx.cr[6].lt {
	pc = 0x82196D08; continue 'dispatch;
	}
	// 82196CF8: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82196CFC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82196D00: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82196D04: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82196D08: EC00C028  fsubs f0, f0, f24
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[24].f64) as f32) as f64);
	// 82196D0C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82196D10: EC2006F2  fmuls f1, f0, f27
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82196D14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82196D18: 4BF7B0B9  bl 0x82111dd0
	ctx.lr = 0x82196D1C;
	sub_82111DD0(ctx, base);
	// 82196D1C: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196D20: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82196D24: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82196D28: C19F0188  lfs f12, 0x188(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82196D2C: 397F00B0  addi r11, r31, 0xb0
	ctx.r[11].s64 = ctx.r[31].s64 + 176;
	// 82196D30: C1210060  lfs f9, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82196D34: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 82196D38: C1AA296C  lfs f13, 0x296c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10604 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196D3C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82196D40: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82196D44: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196D48: C10B0004  lfs f8, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82196D4C: 11A1034A  vcfsx v13, v0, 1
	ctx.fpscr.enable_flush_mode_unconditional();
	let scale = f32::from_bits(((127u32 - (1 as u32)) << 23));
	for i in 0..4 {
		ctx.v[13].f32[i] = (ctx.v[0].s32[i] as f32) * scale;
	}
	// 82196D50: C0EB0008  lfs f7, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82196D54: 1180034A  vcfsx v12, v0, 0
	ctx.fpscr.enable_flush_mode_unconditional();
	let scale = f32::from_bits(((127u32 - (0 as u32)) << 23));
	for i in 0..4 {
		ctx.v[12].f32[i] = (ctx.v[0].s32[i] as f32) * scale;
	}
	// 82196D58: C0CB000C  lfs f6, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82196D5C: ED600372  fmuls f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82196D60: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196D64: ED400372  fmuls f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82196D68: C00A295C  lfs f0, 0x295c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10588 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196D6C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82196D70: ED290332  fmuls f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82196D74: C1AA2960  lfs f13, 0x2960(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10592 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196D78: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82196D7C: ED080372  fmuls f8, f8, f13
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82196D80: ECE70372  fmuls f7, f7, f13
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 82196D84: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82196D88: ED8A0332  fmuls f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 82196D8C: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82196D90: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82196D94: EDA6037A  fmadds f13, f6, f13, f0
	ctx.f[13].f64 = (((ctx.f[6].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82196D98: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82196D9C: EDAB503A  fmadds f13, f11, f0, f10
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 82196DA0: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82196DA4: EDA9403A  fmadds f13, f9, f0, f8
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 82196DA8: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82196DAC: EC0C383A  fmadds f0, f12, f0, f7
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 82196DB0: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82196F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82196F50 size=688
    let mut pc: u32 = 0x82196F50;
    'dispatch: loop {
        match pc {
            0x82196F50 => {
    //   block [0x82196F50..0x82197200)
	// 82196F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82196F54: 4839E169  bl 0x825350bc
	ctx.lr = 0x82196F58;
	sub_82535080(ctx, base);
	// 82196F58: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82196F5C: 4839F081  bl 0x82535fdc
	ctx.lr = 0x82196F60;
	sub_82535FB0(ctx, base);
	// 82196F60: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82196F64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82197200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82197200 size=744
    let mut pc: u32 = 0x82197200;
    'dispatch: loop {
        match pc {
            0x82197200 => {
    //   block [0x82197200..0x821974E8)
	// 82197200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82197204: 4839DEB5  bl 0x825350b8
	ctx.lr = 0x82197208;
	sub_82535080(ctx, base);
	// 82197208: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219720C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82197210: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82197214: 3BE300D0  addi r31, r3, 0xd0
	ctx.r[31].s64 = ctx.r[3].s64 + 208;
	// 82197218: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219721C: C18ABA38  lfs f12, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82197220: C16BD564  lfs f11, -0x2a9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10908 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82197224: 409A0018  bne cr6, 0x8219723c
	if !ctx.cr[6].eq {
	pc = 0x8219723C; continue 'dispatch;
	}
	// 82197228: D17F0080  stfs f11, 0x80(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8219722C: D19F0084  stfs f12, 0x84(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82197230: D17F0088  stfs f11, 0x88(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82197234: D19F008C  stfs f12, 0x8c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82197238: 48000018  b 0x82197250
	pc = 0x82197250; continue 'dispatch;
	// 8219723C: E9470000  ld r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 82197240: 397F0080  addi r11, r31, 0x80
	ctx.r[11].s64 = ctx.r[31].s64 + 128;
	// 82197244: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82197248: E9470008  ld r10, 8(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 8219724C: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82197250: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82197254: D19F008C  stfs f12, 0x8c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82197258: C00BD2B0  lfs f0, -0x2d50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11600 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219725C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197260: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82197264: C0CB2280  lfs f6, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82197268: 40990038  ble cr6, 0x821972a0
	if !ctx.cr[6].gt {
	pc = 0x821972A0; continue 'dispatch;
	}
	// 8219726C: 481CFECD  bl 0x82367138
	ctx.lr = 0x82197270;
	sub_82367138(ctx, base);
	// 82197270: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 82197274: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82197278: C9A10050  lfd f13, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219727C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82197280: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82197284: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82197288: ED4D01B2  fmuls f10, f13, f6
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[6].f64) as f32) as f64);
	// 8219728C: C1ABD560  lfs f13, -0x2aa0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82197290: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82197294: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82197298: D1BF0050  stfs f13, 0x50(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8219729C: 48000008  b 0x821972a4
	pc = 0x821972A4; continue 'dispatch;
	// 821972A0: D05F0050  stfs f2, 0x50(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821972A4: FF030000  fcmpu cr6, f3, f0
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[0].f64);
	// 821972A8: 40990028  ble cr6, 0x821972d0
	if !ctx.cr[6].gt {
	pc = 0x821972D0; continue 'dispatch;
	}
	// 821972AC: 481CFE8D  bl 0x82367138
	ctx.lr = 0x821972B0;
	sub_82367138(ctx, base);
	// 821972B0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821972B4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821972B8: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821972BC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821972C0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821972C4: EC0001B2  fmuls f0, f0, f6
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[6].f64) as f32) as f64);
	// 821972C8: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821972CC: 48000008  b 0x821972d4
	pc = 0x821972D4; continue 'dispatch;
	// 821972D0: D07F0054  stfs f3, 0x54(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821972D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821972D8: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821972DC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821972E0: 40980040  bge cr6, 0x82197320
	if !ctx.cr[6].lt {
	pc = 0x82197320; continue 'dispatch;
	}
	// 821972E4: 481CFE55  bl 0x82367138
	ctx.lr = 0x821972E8;
	sub_82367138(ctx, base);
	// 821972E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821972EC: C00B22AC  lfs f0, 0x22ac(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821972F0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821972F4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821972F8: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821972FC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82197300: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197304: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82197308: ED4D01B2  fmuls f10, f13, f6
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[6].f64) as f32) as f64);
	// 8219730C: C1AB2328  lfs f13, 0x2328(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9000 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82197310: EC0A683A  fmadds f0, f10, f0, f13
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82197314: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82197318: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 8219731C: 48000008  b 0x82197324
	pc = 0x82197324; continue 'dispatch;
	// 82197320: D03F0058  stfs f1, 0x58(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82197324: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82197328: D1610054  stfs f11, 0x54(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8219732C: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 82197330: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82197334: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82197338: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219733C: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82197340: C00BCFEC  lfs f0, -0x3014(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197344: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197348: ECA10032  fmuls f5, f1, f0
	ctx.f[5].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219734C: C9882000  lfd f12, 0x2000(r8)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8192 as u32) ) };
	// 82197350: C9292008  lfd f9, 0x2008(r9)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8200 as u32) ) };
	// 82197354: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 82197358: C14A23D0  lfs f10, 0x23d0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9168 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219735C: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 82197360: C00BD6C8  lfs f0, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197364: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82197368: C08BD5B0  lfs f4, -0x2a50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219736C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197370: EC01203A  fmadds f0, f1, f0, f4
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[4].f64) as f32) as f64);
	// 82197374: C16B20B0  lfs f11, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82197378: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219737C: ED0002F2  fmuls f8, f0, f11
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82197380: C00B23CC  lfs f0, 0x23cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197384: EC05002A  fadds f0, f5, f0
	ctx.f[0].f64 = ((ctx.f[5].f64 + ctx.f[0].f64) as f32) as f64;
	// 82197388: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219738C: C0EB2198  lfs f7, 0x2198(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8600 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82197390: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82197394: 481CFE75  bl 0x82367208
	ctx.lr = 0x82197398;
	sub_82367208(ctx, base);
	// 82197398: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219739C: EDA002B2  fmuls f13, f0, f10
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 821973A0: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821973A4: C07C0000  lfs f3, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821973A8: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 821973AC: EC6301F2  fmuls f3, f3, f7
	ctx.f[3].f64 = (((ctx.f[3].f64 * ctx.f[7].f64) as f32) as f64);
	// 821973B0: D11E0004  stfs f8, 4(r30)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821973B4: D07EFFFC  stfs f3, -4(r30)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821973B8: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 821973BC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821973C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821973C4: FC0D4B6E  fsel f0, f13, f13, f9
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[9].f64 };
	// 821973C8: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821973CC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821973D0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821973D4: EDAD01B2  fmuls f13, f13, f6
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[6].f64) as f32) as f64);
	// 821973D8: D1BEFFF8  stfs f13, -8(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821973DC: FDA06028  fsub f13, f0, f12
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[12].f64;
	// 821973E0: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 821973E4: FC0D032E  fsel f0, f13, f12, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 821973E8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821973EC: 409AFFA8  bne cr6, 0x82197394
	if !ctx.cr[6].eq {
	pc = 0x82197394; continue 'dispatch;
	}
	// 821973F0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821973F4: C00BD4DC  lfs f0, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821973F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821973FC: C1AB2244  lfs f13, 0x2244(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8772 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82197400: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197404: ED05682A  fadds f8, f5, f13
	ctx.f[8].f64 = ((ctx.f[5].f64 + ctx.f[13].f64) as f32) as f64;
	// 82197408: C1AB2068  lfs f13, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219740C: EDA1683A  fmadds f13, f1, f0, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82197410: EC0802F2  fmuls f0, f8, f11
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[11].f64) as f32) as f64);
	// 82197414: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82197418: 481CFD21  bl 0x82367138
	ctx.lr = 0x8219741C;
	sub_82367138(ctx, base);
	// 8219741C: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 82197420: D01F0028  stfs f0, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82197424: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197428: D1BF002C  stfs f13, 0x2c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8219742C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82197430: 38BF0034  addi r5, r31, 0x34
	ctx.r[5].s64 = ctx.r[31].s64 + 52;
	// 82197434: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82197438: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 8219743C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82197440: C00B212C  lfs f0, 0x212c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8492 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197444: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82197448: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219744C: C0EA449C  lfs f7, 0x449c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17564 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82197450: C16B44A4  lfs f11, 0x44a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17572 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82197454: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197458: C10B23C8  lfs f8, 0x23c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9160 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8219745C: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82197460: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82197464: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82197468: EC0001B2  fmuls f0, f0, f6
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[6].f64) as f32) as f64);
	// 8219746C: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82197470: 481D0019  bl 0x82367488
	ctx.lr = 0x82197474;
	sub_82367488(ctx, base);
	// 82197474: EC0B02B2  fmuls f0, f11, f10
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82197478: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219747C: 3884FFFF  addi r4, r4, -1
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	// 82197480: EDAD0232  fmuls f13, f13, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[8].f64) as f32) as f64);
	// 82197484: D1A50000  stfs f13, 0(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82197488: D1650004  stfs f11, 4(r5)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8219748C: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82197490: D025FFFC  stfs f1, -4(r5)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82197494: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82197498: D0E50008  stfs f7, 8(r5)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219749C: 38A50010  addi r5, r5, 0x10
	ctx.r[5].s64 = ctx.r[5].s64 + 16;
	// 821974A0: FC00482E  fsel f0, f0, f0, f9
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[9].f64 };
	// 821974A4: FDA06028  fsub f13, f0, f12
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[12].f64;
	// 821974A8: FC0D032E  fsel f0, f13, f12, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 821974AC: FD600018  frsp f11, f0
	ctx.f[11].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821974B0: 409AFFC0  bne cr6, 0x82197470
	if !ctx.cr[6].eq {
	pc = 0x82197470; continue 'dispatch;
	}
	// 821974B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821974B8: D09F0068  stfs f4, 0x68(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821974BC: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821974C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821974C4: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821974C8: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821974CC: C1AB23D4  lfs f13, 0x23d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821974D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821974D4: D1BF0064  stfs f13, 0x64(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821974D8: C1AB23C4  lfs f13, 0x23c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821974DC: D1BF005C  stfs f13, 0x5c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821974E0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821974E4: 4839DC24  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821974E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821974E8 size=516
    let mut pc: u32 = 0x821974E8;
    'dispatch: loop {
        match pc {
            0x821974E8 => {
    //   block [0x821974E8..0x821976EC)
	// 821974E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821974EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821974F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821974F4: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 821974F8: 4839EAE9  bl 0x82535fe0
	ctx.lr = 0x821974FC;
	sub_82535FB0(ctx, base);
	// 821974FC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82197500: 3BE300D0  addi r31, r3, 0xd0
	ctx.r[31].s64 = ctx.r[3].s64 + 208;
	// 82197504: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82197508: 395F0080  addi r10, r31, 0x80
	ctx.r[10].s64 = ctx.r[31].s64 + 128;
	// 8219750C: C3EBBA38  lfs f31, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82197510: 396301D0  addi r11, r3, 0x1d0
	ctx.r[11].s64 = ctx.r[3].s64 + 464;
	// 82197514: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82197518: D3FF008C  stfs f31, 0x8c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8219751C: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82197520: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 82197524: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82197528: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219752C: C01F0070  lfs f0, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197530: D0030094  stfs f0, 0x94(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82197534: C01F009C  lfs f0, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197538: C36B1FF8  lfs f27, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 8219753C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82197540: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82197544: 409A0008  bne cr6, 0x8219754c
	if !ctx.cr[6].eq {
	pc = 0x8219754C; continue 'dispatch;
	}
	// 82197548: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219754C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82197550: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82197554: 419A017C  beq cr6, 0x821976d0
	if ctx.cr[6].eq {
	pc = 0x821976D0; continue 'dispatch;
	}
	// 82197558: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219755C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197560: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82197564: C3BF0094  lfs f29, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82197568: C34BBFFC  lfs f26, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 8219756C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197570: C38B2048  lfs f28, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82197574: FF0DD000  fcmpu cr6, f13, f26
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[26].f64);
	// 82197578: 41980064  blt cr6, 0x821975dc
	if ctx.cr[6].lt {
	pc = 0x821975DC; continue 'dispatch;
	}
	// 8219757C: EC00E028  fsubs f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[28].f64) as f32) as f64);
	// 82197580: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82197584: 4098003C  bge cr6, 0x821975c0
	if !ctx.cr[6].lt {
	pc = 0x821975C0; continue 'dispatch;
	}
	// 82197588: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8219758C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82197590: 4098000C  bge cr6, 0x8219759c
	if !ctx.cr[6].lt {
	pc = 0x8219759C; continue 'dispatch;
	}
	// 82197594: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82197598: 48000040  b 0x821975d8
	pc = 0x821975D8; continue 'dispatch;
	// 8219759C: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821975A0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821975A4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821975A8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821975AC: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821975B0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821975B4: 41980024  blt cr6, 0x821975d8
	if ctx.cr[6].lt {
	pc = 0x821975D8; continue 'dispatch;
	}
	// 821975B8: FC00D890  fmr f0, f27
	ctx.f[0].f64 = ctx.f[27].f64;
	// 821975BC: 4800001C  b 0x821975d8
	pc = 0x821975D8; continue 'dispatch;
	// 821975C0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821975C4: 41980014  blt cr6, 0x821975d8
	if ctx.cr[6].lt {
	pc = 0x821975D8; continue 'dispatch;
	}
	// 821975C8: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821975CC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821975D0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821975D4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821975D8: EC00D028  fsubs f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	// 821975DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821975E0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821975E4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 821975E8: C3CB2490  lfs f30, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821975EC: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821975F0: 4BF7A7E1  bl 0x82111dd0
	ctx.lr = 0x821975F4;
	sub_82111DD0(ctx, base);
	// 821975F4: FDA0EA10  fabs f13, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[29].u64 & !0x8000_0000_0000_0000u64;
	// 821975F8: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 821975FC: FF0DD000  fcmpu cr6, f13, f26
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[26].f64);
	// 82197600: 41980064  blt cr6, 0x82197664
	if ctx.cr[6].lt {
	pc = 0x82197664; continue 'dispatch;
	}
	// 82197604: EC1DE028  fsubs f0, f29, f28
	ctx.f[0].f64 = (((ctx.f[29].f64 - ctx.f[28].f64) as f32) as f64);
	// 82197608: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 8219760C: 4098003C  bge cr6, 0x82197648
	if !ctx.cr[6].lt {
	pc = 0x82197648; continue 'dispatch;
	}
	// 82197610: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82197614: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82197618: 4098000C  bge cr6, 0x82197624
	if !ctx.cr[6].lt {
	pc = 0x82197624; continue 'dispatch;
	}
	// 8219761C: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82197620: 48000040  b 0x82197660
	pc = 0x82197660; continue 'dispatch;
	// 82197624: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82197628: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8219762C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82197630: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82197634: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82197638: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8219763C: 41980024  blt cr6, 0x82197660
	if ctx.cr[6].lt {
	pc = 0x82197660; continue 'dispatch;
	}
	// 82197640: FC00D890  fmr f0, f27
	ctx.f[0].f64 = ctx.f[27].f64;
	// 82197644: 4800001C  b 0x82197660
	pc = 0x82197660; continue 'dispatch;
	// 82197648: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8219764C: 41980014  blt cr6, 0x82197660
	if ctx.cr[6].lt {
	pc = 0x82197660; continue 'dispatch;
	}
	// 82197650: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82197654: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82197658: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8219765C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82197660: EC00D028  fsubs f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	// 82197664: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82197668: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8219766C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82197670: 4BF7A761  bl 0x82111dd0
	ctx.lr = 0x82197674;
	sub_82111DD0(ctx, base);
	// 82197674: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197678: C1BF0058  lfs f13, 0x58(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219767C: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82197680: C1610058  lfs f11, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82197684: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82197688: C00B21B0  lfs f0, 0x21b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8624 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219768C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82197690: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82197694: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82197698: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8219769C: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 821976A0: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 821976A4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821976A8: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821976AC: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821976B0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821976B4: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821976B8: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821976BC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821976C0: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821976C4: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821976C8: F95F0090  std r10, 0x90(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u64 ) };
	// 821976CC: F97F0098  std r11, 0x98(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	// 821976D0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821976D4: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 821976D8: 4839E955  bl 0x8253602c
	ctx.lr = 0x821976DC;
	sub_82535FFC(ctx, base);
	// 821976DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821976E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821976E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821976E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821976F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821976F0 size=1580
    let mut pc: u32 = 0x821976F0;
    'dispatch: loop {
        match pc {
            0x821976F0 => {
    //   block [0x821976F0..0x82197D1C)
	// 821976F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821976F4: 4839D9C5  bl 0x825350b8
	ctx.lr = 0x821976F8;
	sub_82535080(ctx, base);
	// 821976F8: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821976FC: 4839E8D5  bl 0x82535fd0
	ctx.lr = 0x82197700;
	sub_82535FB0(ctx, base);
	// 82197700: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82197704: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82197708: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219770C: 896BBFF0  lbz r11, -0x4010(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-16400 as u32) ) } as u64;
	// 82197710: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82197714: 409A05F8  bne cr6, 0x82197d0c
	if !ctx.cr[6].eq {
	pc = 0x82197D0C; continue 'dispatch;
	}
	// 82197718: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219771C: C3DF0094  lfs f30, 0x94(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82197720: D3DF00C4  stfs f30, 0xc4(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82197724: 3BBF00D0  addi r29, r31, 0xd0
	ctx.r[29].s64 = ctx.r[31].s64 + 208;
	// 82197728: C2EB1FF8  lfs f23, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 8219772C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82197730: FFA0B890  fmr f29, f23
	ctx.f[29].f64 = ctx.f[23].f64;
	// 82197734: FF80B890  fmr f28, f23
	ctx.f[28].f64 = ctx.f[23].f64;
	// 82197738: FF1EB800  fcmpu cr6, f30, f23
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[23].f64);
	// 8219773C: C36BBA38  lfs f27, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82197740: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197744: FFE0D890  fmr f31, f27
	ctx.f[31].f64 = ctx.f[27].f64;
	// 82197748: C34B2648  lfs f26, 0x2648(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9800 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 8219774C: 40990060  ble cr6, 0x821977ac
	if !ctx.cr[6].gt {
	pc = 0x821977AC; continue 'dispatch;
	}
	// 82197750: C01D0070  lfs f0, 0x70(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197754: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197758: EDBE0024  fdivs f13, f30, f0
	ctx.f[13].f64 = ((ctx.f[30].f64 / ctx.f[0].f64) as f32) as f64;
	// 8219775C: C00B2604  lfs f0, 0x2604(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9732 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197760: EC2DD03A  fmadds f1, f13, f0, f26
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64);
	// 82197764: 4BF85D65  bl 0x8211d4c8
	ctx.lr = 0x82197768;
	sub_8211D4C8(ctx, base);
	// 82197768: EC1ED828  fsubs f0, f30, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[27].f64) as f32) as f64);
	// 8219776C: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82197770: EF01D82A  fadds f24, f1, f27
	ctx.f[24].f64 = ((ctx.f[1].f64 + ctx.f[27].f64) as f32) as f64;
	// 82197774: FF00B800  fcmpu cr6, f0, f23
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[23].f64);
	// 82197778: 41990038  bgt cr6, 0x821977b0
	if ctx.cr[6].gt {
	pc = 0x821977B0; continue 'dispatch;
	}
	// 8219777C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82197780: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82197784: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82197788: 409A0584  bne cr6, 0x82197d0c
	if !ctx.cr[6].eq {
	pc = 0x82197D0C; continue 'dispatch;
	}
	// 8219778C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82197790: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82197794: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82197798: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 8219779C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821977A0: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821977A4: 4839E879  bl 0x8253601c
	ctx.lr = 0x821977A8;
	sub_82535FFC(ctx, base);
	// 821977A8: 4839D960  b 0x82535108
	sub_825350D0(ctx, base);
	return;
	// 821977AC: FF00D890  fmr f24, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[24].f64 = ctx.f[27].f64;
	// 821977B0: C01D009C  lfs f0, 0x9c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821977B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821977B8: FF00B800  fcmpu cr6, f0, f23
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[23].f64);
	// 821977BC: 409A0008  bne cr6, 0x821977c4
	if !ctx.cr[6].eq {
	pc = 0x821977C4; continue 'dispatch;
	}
	// 821977C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821977C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821977C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821977CC: 419A0080  beq cr6, 0x8219784c
	if ctx.cr[6].eq {
	pc = 0x8219784C; continue 'dispatch;
	}
	// 821977D0: 397D0080  addi r11, r29, 0x80
	ctx.r[11].s64 = ctx.r[29].s64 + 128;
	// 821977D4: 39200090  li r9, 0x90
	ctx.r[9].s64 = 144;
	// 821977D8: 395F01D0  addi r10, r31, 0x1d0
	ctx.r[10].s64 = ctx.r[31].s64 + 464;
	// 821977DC: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82197D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82197D20 size=536
    let mut pc: u32 = 0x82197D20;
    'dispatch: loop {
        match pc {
            0x82197D20 => {
    //   block [0x82197D20..0x82197F38)
	// 82197D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82197D24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82197D28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82197D2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82197D30: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82197D34: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82197D38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82197F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82197F38 size=224
    let mut pc: u32 = 0x82197F38;
    'dispatch: loop {
        match pc {
            0x82197F38 => {
    //   block [0x82197F38..0x82198018)
	// 82197F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82197F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82197F40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82197F44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82197F48: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82197F4C: 4839E09D  bl 0x82535fe8
	ctx.lr = 0x82197F50;
	sub_82535FB0(ctx, base);
	// 82197F50: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82197F54: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197F58: D0A100D4  stfs f5, 0xd4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82197F5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82197F60: FF802090  fmr f28, f4
	ctx.f[28].f64 = ctx.f[4].f64;
	// 82197F64: FFC03090  fmr f30, f6
	ctx.f[30].f64 = ctx.f[6].f64;
	// 82197F68: C80B2008  lfd f0, 0x2008(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 82197F6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197F70: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82197F74: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82197F78: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82197F7C: FFA0F890  fmr f29, f31
	ctx.f[29].f64 = ctx.f[31].f64;
	// 82197F80: C00BD2B0  lfs f0, -0x2d50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11600 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197F84: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82197F88: 40990008  ble cr6, 0x82197f90
	if !ctx.cr[6].gt {
	pc = 0x82197F90; continue 'dispatch;
	}
	// 82197F8C: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 82197F90: FDA0F210  fabs f13, f30
	ctx.f[13].u64 = ctx.f[30].u64 & !0x8000_0000_0000_0000u64;
	// 82197F94: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82197F98: 40990008  ble cr6, 0x82197fa0
	if !ctx.cr[6].gt {
	pc = 0x82197FA0; continue 'dispatch;
	}
	// 82197F9C: FFC01890  fmr f30, f3
	ctx.f[30].f64 = ctx.f[3].f64;
	// 82197FA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82197FA4: 3BFE00D0  addi r31, r30, 0xd0
	ctx.r[31].s64 = ctx.r[30].s64 + 208;
	// 82197FA8: 4BFFF259  bl 0x82197200
	ctx.lr = 0x82197FAC;
	sub_82197200(ctx, base);
	// 82197FAC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82197FB0: 39400056  li r10, 0x56
	ctx.r[10].s64 = 86;
	// 82197FB4: D39F0070  stfs f28, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82197FB8: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197FBC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197FC0: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82197FC4: C1AB25BC  lfs f13, 0x25bc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9660 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82197FC8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82197FCC: D1BF006C  stfs f13, 0x6c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82197FD0: C18BD4D0  lfs f12, -0x2b30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11056 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82197FD4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197FD8: D19F0060  stfs f12, 0x60(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82197FDC: C1AB209C  lfs f13, 0x209c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8348 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82197FE0: D1BF0064  stfs f13, 0x64(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82197FE4: D3BF0090  stfs f29, 0x90(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82197FE8: D3DF0094  stfs f30, 0x94(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82197FEC: D3FF0098  stfs f31, 0x98(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82197FF0: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82197FF4: 995E004F  stb r10, 0x4f(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(79 as u32), ctx.r[10].u8 ) };
	// 82197FF8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82197FFC: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82198000: 4839E035  bl 0x82536034
	ctx.lr = 0x82198004;
	sub_82535FFC(ctx, base);
	// 82198004: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82198008: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219800C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82198010: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82198014: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82198018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82198018 size=224
    let mut pc: u32 = 0x82198018;
    'dispatch: loop {
        match pc {
            0x82198018 => {
    //   block [0x82198018..0x821980F8)
	// 82198018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219801C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82198020: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82198024: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82198028: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 8219802C: 4839DFBD  bl 0x82535fe8
	ctx.lr = 0x82198030;
	sub_82535FB0(ctx, base);
	// 82198030: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82198034: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82198038: D0A100D4  stfs f5, 0xd4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 8219803C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82198040: FF802090  fmr f28, f4
	ctx.f[28].f64 = ctx.f[4].f64;
	// 82198044: FFC03090  fmr f30, f6
	ctx.f[30].f64 = ctx.f[6].f64;
	// 82198048: C80B2008  lfd f0, 0x2008(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 8219804C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82198050: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82198054: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82198058: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219805C: FFA0F890  fmr f29, f31
	ctx.f[29].f64 = ctx.f[31].f64;
	// 82198060: C00BD2B0  lfs f0, -0x2d50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11600 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198064: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82198068: 40990008  ble cr6, 0x82198070
	if !ctx.cr[6].gt {
	pc = 0x82198070; continue 'dispatch;
	}
	// 8219806C: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 82198070: FDA0F210  fabs f13, f30
	ctx.f[13].u64 = ctx.f[30].u64 & !0x8000_0000_0000_0000u64;
	// 82198074: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82198078: 40990008  ble cr6, 0x82198080
	if !ctx.cr[6].gt {
	pc = 0x82198080; continue 'dispatch;
	}
	// 8219807C: FFC01890  fmr f30, f3
	ctx.f[30].f64 = ctx.f[3].f64;
	// 82198080: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82198084: 3BFE00D0  addi r31, r30, 0xd0
	ctx.r[31].s64 = ctx.r[30].s64 + 208;
	// 82198088: 4BFFF179  bl 0x82197200
	ctx.lr = 0x8219808C;
	sub_82197200(ctx, base);
	// 8219808C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82198090: 39400048  li r10, 0x48
	ctx.r[10].s64 = 72;
	// 82198094: D39F0070  stfs f28, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82198098: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219809C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821980A0: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821980A4: C1AB9F78  lfs f13, -0x6088(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821980A8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821980AC: D1BF006C  stfs f13, 0x6c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821980B0: C18BD560  lfs f12, -0x2aa0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821980B4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821980B8: D19F0060  stfs f12, 0x60(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821980BC: C1ABD218  lfs f13, -0x2de8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821980C0: D1BF0064  stfs f13, 0x64(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821980C4: D3BF0090  stfs f29, 0x90(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821980C8: D3DF0094  stfs f30, 0x94(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821980CC: D3FF0098  stfs f31, 0x98(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 821980D0: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 821980D4: 995E004F  stb r10, 0x4f(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(79 as u32), ctx.r[10].u8 ) };
	// 821980D8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821980DC: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 821980E0: 4839DF55  bl 0x82536034
	ctx.lr = 0x821980E4;
	sub_82535FFC(ctx, base);
	// 821980E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821980E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821980EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821980F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821980F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821980F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821980F8 size=636
    let mut pc: u32 = 0x821980F8;
    'dispatch: loop {
        match pc {
            0x821980F8 => {
    //   block [0x821980F8..0x82198374)
	// 821980F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821980FC: 4839CFBD  bl 0x825350b8
	ctx.lr = 0x82198100;
	sub_82535080(ctx, base);
	// 82198100: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82198104: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82198108: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8219810C: 3BE300D0  addi r31, r3, 0xd0
	ctx.r[31].s64 = ctx.r[3].s64 + 208;
	// 82198110: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82198114: C1AABA38  lfs f13, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82198118: C18BD564  lfs f12, -0x2a9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10908 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219811C: 409A0018  bne cr6, 0x82198134
	if !ctx.cr[6].eq {
	pc = 0x82198134; continue 'dispatch;
	}
	// 82198120: D19F0060  stfs f12, 0x60(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82198124: D1BF0064  stfs f13, 0x64(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82198128: D19F0068  stfs f12, 0x68(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8219812C: D1BF006C  stfs f13, 0x6c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82198130: 48000018  b 0x82198148
	pc = 0x82198148; continue 'dispatch;
	// 82198134: E9470000  ld r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 82198138: 397F0060  addi r11, r31, 0x60
	ctx.r[11].s64 = ctx.r[31].s64 + 96;
	// 8219813C: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82198140: E9470008  ld r10, 8(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 82198144: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82198148: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219814C: D1BF006C  stfs f13, 0x6c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82198150: C00BD2B0  lfs f0, -0x2d50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11600 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198154: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82198158: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 8219815C: C0CB2280  lfs f6, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82198160: 40990038  ble cr6, 0x82198198
	if !ctx.cr[6].gt {
	pc = 0x82198198; continue 'dispatch;
	}
	// 82198164: 481CEFD5  bl 0x82367138
	ctx.lr = 0x82198168;
	sub_82367138(ctx, base);
	// 82198168: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219816C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82198170: C9610050  lfd f11, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82198174: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82198178: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8219817C: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82198180: ED4B01B2  fmuls f10, f11, f6
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[6].f64) as f32) as f64);
	// 82198184: C16BD560  lfs f11, -0x2aa0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82198188: ED6A02F2  fmuls f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[11].f64) as f32) as f64);
	// 8219818C: FD605850  fneg f11, f11
	ctx.f[11].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 82198190: D17F0050  stfs f11, 0x50(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82198194: 48000008  b 0x8219819c
	pc = 0x8219819C; continue 'dispatch;
	// 82198198: D05F0050  stfs f2, 0x50(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8219819C: FF030000  fcmpu cr6, f3, f0
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[0].f64);
	// 821981A0: 40990028  ble cr6, 0x821981c8
	if !ctx.cr[6].gt {
	pc = 0x821981C8; continue 'dispatch;
	}
	// 821981A4: 481CEF95  bl 0x82367138
	ctx.lr = 0x821981A8;
	sub_82367138(ctx, base);
	// 821981A8: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821981AC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821981B0: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821981B4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821981B8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821981BC: EC0001B2  fmuls f0, f0, f6
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[6].f64) as f32) as f64);
	// 821981C0: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821981C4: 48000008  b 0x821981cc
	pc = 0x821981CC; continue 'dispatch;
	// 821981C8: D07F0054  stfs f3, 0x54(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821981CC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821981D0: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821981D4: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821981D8: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821981DC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821981E0: D03F0058  stfs f1, 0x58(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821981E4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821981E8: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 821981EC: C00BCFEC  lfs f0, -0x3014(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821981F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821981F4: ECA10032  fmuls f5, f1, f0
	ctx.f[5].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 821981F8: C9882000  lfd f12, 0x2000(r8)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8192 as u32) ) };
	// 821981FC: C9292008  lfd f9, 0x2008(r9)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8200 as u32) ) };
	// 82198200: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 82198204: C14A23D0  lfs f10, 0x23d0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9168 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82198208: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 8219820C: C00BD6C8  lfs f0, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198210: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82198214: C1ABD5B0  lfs f13, -0x2a50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82198218: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219821C: EC01683A  fmadds f0, f1, f0, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82198220: C16B20B0  lfs f11, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82198224: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82198228: ED0002F2  fmuls f8, f0, f11
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 8219822C: C00B23CC  lfs f0, 0x23cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198230: EC05002A  fadds f0, f5, f0
	ctx.f[0].f64 = ((ctx.f[5].f64 + ctx.f[0].f64) as f32) as f64;
	// 82198234: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82198238: C0EB2198  lfs f7, 0x2198(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8600 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 8219823C: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82198240: 481CEFC9  bl 0x82367208
	ctx.lr = 0x82198244;
	sub_82367208(ctx, base);
	// 82198244: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 82198248: EDA002B2  fmuls f13, f0, f10
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 8219824C: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82198250: C09C0000  lfs f4, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82198254: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 82198258: EC8401F2  fmuls f4, f4, f7
	ctx.f[4].f64 = (((ctx.f[4].f64 * ctx.f[7].f64) as f32) as f64);
	// 8219825C: D11E0004  stfs f8, 4(r30)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82198260: D09EFFFC  stfs f4, -4(r30)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82198264: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82198268: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8219826C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82198270: FC0D4B6E  fsel f0, f13, f13, f9
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[9].f64 };
	// 82198274: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82198278: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8219827C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82198280: EDAD01B2  fmuls f13, f13, f6
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[6].f64) as f32) as f64);
	// 82198284: D1BEFFF8  stfs f13, -8(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82198288: FDA06028  fsub f13, f0, f12
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[12].f64;
	// 8219828C: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82198290: FC0D032E  fsel f0, f13, f12, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 82198294: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82198298: 409AFFA8  bne cr6, 0x82198240
	if !ctx.cr[6].eq {
	pc = 0x82198240; continue 'dispatch;
	}
	// 8219829C: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821982A0: C00BD4DC  lfs f0, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821982A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821982A8: C1AB2244  lfs f13, 0x2244(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8772 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821982AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821982B0: ED05682A  fadds f8, f5, f13
	ctx.f[8].f64 = ((ctx.f[5].f64 + ctx.f[13].f64) as f32) as f64;
	// 821982B4: C1AB2068  lfs f13, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821982B8: EDA1683A  fmadds f13, f1, f0, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 821982BC: EC0802F2  fmuls f0, f8, f11
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[11].f64) as f32) as f64);
	// 821982C0: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 821982C4: 481CEE75  bl 0x82367138
	ctx.lr = 0x821982C8;
	sub_82367138(ctx, base);
	// 821982C8: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821982CC: D01F0028  stfs f0, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821982D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821982D4: D1BF002C  stfs f13, 0x2c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821982D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821982DC: 38BF0034  addi r5, r31, 0x34
	ctx.r[5].s64 = ctx.r[31].s64 + 52;
	// 821982E0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821982E4: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 821982E8: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821982EC: C00B212C  lfs f0, 0x212c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8492 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821982F0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821982F4: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821982F8: C0EA449C  lfs f7, 0x449c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17564 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821982FC: C16B44A4  lfs f11, 0x44a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17572 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82198300: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82198304: C10B23C8  lfs f8, 0x23c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9160 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82198308: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8219830C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82198310: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82198314: EC0001B2  fmuls f0, f0, f6
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[6].f64) as f32) as f64);
	// 82198318: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219831C: 481CF16D  bl 0x82367488
	ctx.lr = 0x82198320;
	sub_82367488(ctx, base);
	// 82198320: EC0B02B2  fmuls f0, f11, f10
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82198324: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82198328: 3884FFFF  addi r4, r4, -1
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	// 8219832C: EDAD0232  fmuls f13, f13, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[8].f64) as f32) as f64);
	// 82198330: D1A50000  stfs f13, 0(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82198334: D1650004  stfs f11, 4(r5)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82198338: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 8219833C: D025FFFC  stfs f1, -4(r5)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82198340: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82198344: D0E50008  stfs f7, 8(r5)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82198348: 38A50010  addi r5, r5, 0x10
	ctx.r[5].s64 = ctx.r[5].s64 + 16;
	// 8219834C: FC00482E  fsel f0, f0, f0, f9
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[9].f64 };
	// 82198350: FDA06028  fsub f13, f0, f12
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[12].f64;
	// 82198354: FC0D032E  fsel f0, f13, f12, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 82198358: FD600018  frsp f11, f0
	ctx.f[11].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219835C: 409AFFC0  bne cr6, 0x8219831c
	if !ctx.cr[6].eq {
	pc = 0x8219831C; continue 'dispatch;
	}
	// 82198360: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82198364: C00B23C4  lfs f0, 0x23c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198368: D01F005C  stfs f0, 0x5c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8219836C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82198370: 4839CD98  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82198378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82198378 size=1124
    let mut pc: u32 = 0x82198378;
    'dispatch: loop {
        match pc {
            0x82198378 => {
    //   block [0x82198378..0x821987DC)
	// 82198378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219837C: 4839CD41  bl 0x825350bc
	ctx.lr = 0x82198380;
	sub_82535080(ctx, base);
	// 82198380: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82198384: 4839DC5D  bl 0x82535fe0
	ctx.lr = 0x82198388;
	sub_82535FB0(ctx, base);
	// 82198388: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219838C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82198390: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 82198394: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82198398: 614A85E0  ori r10, r10, 0x85e0
	ctx.r[10].u64 = ctx.r[10].u64 | 34272;
	// 8219839C: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 821983A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821983A4: 612985DC  ori r9, r9, 0x85dc
	ctx.r[9].u64 = ctx.r[9].u64 | 34268;
	// 821983A8: 3BDF00D0  addi r30, r31, 0xd0
	ctx.r[30].s64 = ctx.r[31].s64 + 208;
	// 821983AC: 7C0B542E  lfsx f0, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821983B0: 395F0230  addi r10, r31, 0x230
	ctx.r[10].s64 = ctx.r[31].s64 + 560;
	// 821983B4: D01F018C  stfs f0, 0x18c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 821983B8: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821983BC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821983C0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821983C4: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 821983C8: C3EABA38  lfs f31, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821983CC: 395E0060  addi r10, r30, 0x60
	ctx.r[10].s64 = ctx.r[30].s64 + 96;
	// 821983D0: D3FE006C  stfs f31, 0x6c(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821983D4: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821983D8: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821983DC: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821983E0: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821983E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821983E8: C01E0080  lfs f0, 0x80(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821983EC: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821983F0: C01E007C  lfs f0, 0x7c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821983F4: C36B1FF8  lfs f27, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821983F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821983FC: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82198400: 409A0008  bne cr6, 0x82198408
	if !ctx.cr[6].eq {
	pc = 0x82198408; continue 'dispatch;
	}
	// 82198404: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82198408: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219840C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82198410: 419A03BC  beq cr6, 0x821987cc
	if ctx.cr[6].eq {
	pc = 0x821987CC; continue 'dispatch;
	}
	// 82198414: C01E0070  lfs f0, 0x70(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198418: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219841C: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82198420: C3BE0074  lfs f29, 0x74(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82198424: 3BBE0070  addi r29, r30, 0x70
	ctx.r[29].s64 = ctx.r[30].s64 + 112;
	// 82198428: C34BBFFC  lfs f26, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 8219842C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82198430: C38B2048  lfs f28, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82198434: FF0DD000  fcmpu cr6, f13, f26
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[26].f64);
	// 82198438: 41980064  blt cr6, 0x8219849c
	if ctx.cr[6].lt {
	pc = 0x8219849C; continue 'dispatch;
	}
	// 8219843C: EC00E028  fsubs f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[28].f64) as f32) as f64);
	// 82198440: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82198444: 4098003C  bge cr6, 0x82198480
	if !ctx.cr[6].lt {
	pc = 0x82198480; continue 'dispatch;
	}
	// 82198448: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8219844C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82198450: 4098000C  bge cr6, 0x8219845c
	if !ctx.cr[6].lt {
	pc = 0x8219845C; continue 'dispatch;
	}
	// 82198454: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82198458: 48000040  b 0x82198498
	pc = 0x82198498; continue 'dispatch;
	// 8219845C: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82198460: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82198464: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82198468: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8219846C: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82198470: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82198474: 41980024  blt cr6, 0x82198498
	if ctx.cr[6].lt {
	pc = 0x82198498; continue 'dispatch;
	}
	// 82198478: FC00D890  fmr f0, f27
	ctx.f[0].f64 = ctx.f[27].f64;
	// 8219847C: 4800001C  b 0x82198498
	pc = 0x82198498; continue 'dispatch;
	// 82198480: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82198484: 41980014  blt cr6, 0x82198498
	if ctx.cr[6].lt {
	pc = 0x82198498; continue 'dispatch;
	}
	// 82198488: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8219848C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82198490: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82198494: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82198498: EC00D028  fsubs f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	// 8219849C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821984A0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821984A4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 821984A8: C3CB2490  lfs f30, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821984AC: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821984B0: 4BF79921  bl 0x82111dd0
	ctx.lr = 0x821984B4;
	sub_82111DD0(ctx, base);
	// 821984B4: FDA0EA10  fabs f13, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[29].u64 & !0x8000_0000_0000_0000u64;
	// 821984B8: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 821984BC: FF0DD000  fcmpu cr6, f13, f26
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[26].f64);
	// 821984C0: 41980064  blt cr6, 0x82198524
	if ctx.cr[6].lt {
	pc = 0x82198524; continue 'dispatch;
	}
	// 821984C4: EC1DE028  fsubs f0, f29, f28
	ctx.f[0].f64 = (((ctx.f[29].f64 - ctx.f[28].f64) as f32) as f64);
	// 821984C8: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 821984CC: 4098003C  bge cr6, 0x82198508
	if !ctx.cr[6].lt {
	pc = 0x82198508; continue 'dispatch;
	}
	// 821984D0: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821984D4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821984D8: 4098000C  bge cr6, 0x821984e4
	if !ctx.cr[6].lt {
	pc = 0x821984E4; continue 'dispatch;
	}
	// 821984DC: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821984E0: 48000040  b 0x82198520
	pc = 0x82198520; continue 'dispatch;
	// 821984E4: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821984E8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821984EC: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821984F0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821984F4: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821984F8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821984FC: 41980024  blt cr6, 0x82198520
	if ctx.cr[6].lt {
	pc = 0x82198520; continue 'dispatch;
	}
	// 82198500: FC00D890  fmr f0, f27
	ctx.f[0].f64 = ctx.f[27].f64;
	// 82198504: 4800001C  b 0x82198520
	pc = 0x82198520; continue 'dispatch;
	// 82198508: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8219850C: 41980014  blt cr6, 0x82198520
	if ctx.cr[6].lt {
	pc = 0x82198520; continue 'dispatch;
	}
	// 82198510: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82198514: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82198518: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8219851C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82198520: EC00D028  fsubs f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	// 82198524: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82198528: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8219852C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82198530: 4BF798A1  bl 0x82111dd0
	ctx.lr = 0x82198534;
	sub_82111DD0(ctx, base);
	// 82198534: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82198538: C1BF018C  lfs f13, 0x18c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219853C: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 82198540: C15E0058  lfs f10, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82198544: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82198548: C00BD478  lfs f0, -0x2b88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219854C: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82198550: ED6D0032  fmuls f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82198554: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198558: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8219855C: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82198560: 11A1034A  vcfsx v13, v0, 1
	ctx.fpscr.enable_flush_mode_unconditional();
	let scale = f32::from_bits(((127u32 - (1 as u32)) << 23));
	for i in 0..4 {
		ctx.v[13].f32[i] = (ctx.v[0].s32[i] as f32) * scale;
	}
	// 82198564: 1180034A  vcfsx v12, v0, 0
	let scale = f32::from_bits(((127u32 - (0 as u32)) << 23));
	for i in 0..4 {
		ctx.v[12].f32[i] = (ctx.v[0].s32[i] as f32) * scale;
	}
	// 82198568: ED800372  fmuls f12, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219856C: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198570: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82198574: EC0B02B2  fmuls f0, f11, f10
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82198578: D01F0194  stfs f0, 0x194(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 8219857C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82198580: D1810080  stfs f12, 0x80(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82198584: C181005C  lfs f12, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82198588: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219858C: D1810084  stfs f12, 0x84(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82198590: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82198594: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82198598: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8219859C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821985A0: F95D0000  std r10, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 821985A4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821985A8: F97D0008  std r11, 8(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821987E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821987E0 size=1404
    let mut pc: u32 = 0x821987E0;
    'dispatch: loop {
        match pc {
            0x821987E0 => {
    //   block [0x821987E0..0x82198D5C)
	// 821987E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821987E4: 4839C8C1  bl 0x825350a4
	ctx.lr = 0x821987E8;
	sub_82535080(ctx, base);
	// 821987E8: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 821987EC: 4839D7C5  bl 0x82535fb0
	ctx.lr = 0x821987F0;
	sub_82535FB0(ctx, base);
	// 821987F0: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821987F4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821987F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821987FC: 896BBFF0  lbz r11, -0x4010(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-16400 as u32) ) } as u64;
	// 82198800: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82198804: 409A0548  bne cr6, 0x82198d4c
	if !ctx.cr[6].eq {
	pc = 0x82198D4C; continue 'dispatch;
	}
	// 82198808: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 8219880C: 3C80820D  lis r4, -0x7df3
	ctx.r[4].s64 = -2113077248;
	// 82198810: 3F00820A  lis r24, -0x7df6
	ctx.r[24].s64 = -2113273856;
	// 82198814: 3F20820D  lis r25, -0x7df3
	ctx.r[25].s64 = -2113077248;
	// 82198818: 3F40820D  lis r26, -0x7df3
	ctx.r[26].s64 = -2113077248;
	// 8219881C: 3F608288  lis r27, -0x7d78
	ctx.r[27].s64 = -2105016320;
	// 82198820: C0052280  lfs f0, 0x2280(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198824: 3F80820D  lis r28, -0x7df3
	ctx.r[28].s64 = -2113077248;
	// 82198828: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8219882C: 3FC0820D  lis r30, -0x7df3
	ctx.r[30].s64 = -2113077248;
	// 82198830: C0042068  lfs f0, 0x2068(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198834: 3C60820D  lis r3, -0x7df3
	ctx.r[3].s64 = -2113077248;
	// 82198838: C358BA38  lfs f26, -0x45c8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 8219883C: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 82198840: C2FA295C  lfs f23, 0x295c(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(10588 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82198844: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 82198848: C29BD4DC  lfs f20, -0x2b24(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 8219884C: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 82198850: C23C2048  lfs f17, 0x2048(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8264 as u32) ) };
	ctx.f[17].f64 = (tmp.f32 as f64);
	// 82198854: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82198858: C1DE2958  lfs f14, 0x2958(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(10584 as u32) ) };
	ctx.f[14].f64 = (tmp.f32 as f64);
	// 8219885C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82198860: C1E32144  lfs f15, 0x2144(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8516 as u32) ) };
	ctx.f[15].f64 = (tmp.f32 as f64);
	// 82198864: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82198868: C206219C  lfs f16, 0x219c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8604 as u32) ) };
	ctx.f[16].f64 = (tmp.f32 as f64);
	// 8219886C: C2A7BFFC  lfs f21, -0x4004(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 82198870: 3BBF00D0  addi r29, r31, 0xd0
	ctx.r[29].s64 = ctx.r[31].s64 + 208;
	// 82198874: C3282490  lfs f25, 0x2490(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(9360 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82198878: 3AE00070  li r23, 0x70
	ctx.r[23].s64 = 112;
	// 8219887C: C2692648  lfs f19, 0x2648(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9800 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 82198880: C24A2604  lfs f18, 0x2604(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9732 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	// 82198884: C3AB1FF8  lfs f29, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82198888: C2D92960  lfs f22, 0x2960(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(10592 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 8219888C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82198890: C3DF0094  lfs f30, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82198894: FF80E890  fmr f28, f29
	ctx.f[28].f64 = ctx.f[29].f64;
	// 82198898: D3DF00C4  stfs f30, 0xc4(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8219889C: FF60E890  fmr f27, f29
	ctx.f[27].f64 = ctx.f[29].f64;
	// 821988A0: FFE0D090  fmr f31, f26
	ctx.f[31].f64 = ctx.f[26].f64;
	// 821988A4: FF1EE800  fcmpu cr6, f30, f29
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[29].f64);
	// 821988A8: 4099005C  ble cr6, 0x82198904
	if !ctx.cr[6].gt {
	pc = 0x82198904; continue 'dispatch;
	}
	// 821988AC: C01D0080  lfs f0, 0x80(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821988B0: EC1E0024  fdivs f0, f30, f0
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[0].f64) as f32) as f64;
	// 821988B4: EC209CBA  fmadds f1, f0, f18, f19
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[18].f64 + ctx.f[19].f64) as f32) as f64);
	// 821988B8: 4BF84C11  bl 0x8211d4c8
	ctx.lr = 0x821988BC;
	sub_8211D4C8(ctx, base);
	// 821988BC: C01F0190  lfs f0, 0x190(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821988C0: EF01D02A  fadds f24, f1, f26
	ctx.f[24].f64 = ((ctx.f[1].f64 + ctx.f[26].f64) as f32) as f64;
	// 821988C4: EC1E0028  fsubs f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 821988C8: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821988CC: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 821988D0: 41990038  bgt cr6, 0x82198908
	if ctx.cr[6].gt {
	pc = 0x82198908; continue 'dispatch;
	}
	// 821988D4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821988D8: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821988DC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821988E0: 409A046C  bne cr6, 0x82198d4c
	if !ctx.cr[6].eq {
	pc = 0x82198D4C; continue 'dispatch;
	}
	// 821988E4: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821988E8: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 821988EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821988F0: 997F0025  stb r11, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	// 821988F4: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 821988F8: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 821988FC: 4839D701  bl 0x82535ffc
	ctx.lr = 0x82198900;
	sub_82535FFC(ctx, base);
	// 82198900: 4839C7F4  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
	// 82198904: FF00D090  fmr f24, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[24].f64 = ctx.f[26].f64;
	// 82198908: C01D007C  lfs f0, 0x7c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219890C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82198910: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82198914: 409A0008  bne cr6, 0x8219891c
	if !ctx.cr[6].eq {
	pc = 0x8219891C; continue 'dispatch;
	}
	// 82198918: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219891C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82198920: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82198924: 419A0054  beq cr6, 0x82198978
	if ctx.cr[6].eq {
	pc = 0x82198978; continue 'dispatch;
	}
	// 82198928: 397D0060  addi r11, r29, 0x60
	ctx.r[11].s64 = ctx.r[29].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82198D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82198D60 size=428
    let mut pc: u32 = 0x82198D60;
    'dispatch: loop {
        match pc {
            0x82198D60 => {
    //   block [0x82198D60..0x82198F0C)
	// 82198D60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82198D64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82198D68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82198D6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82198D70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82198D74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82198F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82198F10 size=232
    let mut pc: u32 = 0x82198F10;
    'dispatch: loop {
        match pc {
            0x82198F10 => {
    //   block [0x82198F10..0x82198FF8)
	// 82198F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82198F14: 4839C1A5  bl 0x825350b8
	ctx.lr = 0x82198F18;
	sub_82535080(ctx, base);
	// 82198F18: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82198F1C: 4839D0C1  bl 0x82535fdc
	ctx.lr = 0x82198F20;
	sub_82535FB0(ctx, base);
	// 82198F20: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82198F24: FFE04890  fmr f31, f9
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[9].f64;
	// 82198F28: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82198F2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82198F30: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 82198F34: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82198F38: FF801890  fmr f28, f3
	ctx.f[28].f64 = ctx.f[3].f64;
	// 82198F3C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82198F40: FF602090  fmr f27, f4
	ctx.f[27].f64 = ctx.f[4].f64;
	// 82198F44: FF402890  fmr f26, f5
	ctx.f[26].f64 = ctx.f[5].f64;
	// 82198F48: C00BD2B0  lfs f0, -0x2d50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11600 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198F4C: FF204090  fmr f25, f8
	ctx.f[25].f64 = ctx.f[8].f64;
	// 82198F50: FFC05090  fmr f30, f10
	ctx.f[30].f64 = ctx.f[10].f64;
	// 82198F54: FDA0FA10  fabs f13, f31
	ctx.f[13].u64 = ctx.f[31].u64 & !0x8000_0000_0000_0000u64;
	// 82198F58: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82198F5C: 40990008  ble cr6, 0x82198f64
	if !ctx.cr[6].gt {
	pc = 0x82198F64; continue 'dispatch;
	}
	// 82198F60: FFE03090  fmr f31, f6
	ctx.f[31].f64 = ctx.f[6].f64;
	// 82198F64: FDA0F210  fabs f13, f30
	ctx.f[13].u64 = ctx.f[30].u64 & !0x8000_0000_0000_0000u64;
	// 82198F68: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82198F6C: 40990008  ble cr6, 0x82198f74
	if !ctx.cr[6].gt {
	pc = 0x82198F74; continue 'dispatch;
	}
	// 82198F70: FFC03890  fmr f30, f7
	ctx.f[30].f64 = ctx.f[7].f64;
	// 82198F74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82198F78: 80E10114  lwz r7, 0x114(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 82198F7C: FC603890  fmr f3, f7
	ctx.f[3].f64 = ctx.f[7].f64;
	// 82198F80: 3BFE00D0  addi r31, r30, 0xd0
	ctx.r[31].s64 = ctx.r[30].s64 + 208;
	// 82198F84: FC403090  fmr f2, f6
	ctx.f[2].f64 = ctx.f[6].f64;
	// 82198F88: 4BFFF171  bl 0x821980f8
	ctx.lr = 0x82198F8C;
	sub_821980F8(ctx, base);
	// 82198F8C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82198F90: D33F0080  stfs f25, 0x80(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82198F94: D3FF0070  stfs f31, 0x70(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82198F98: 397E01B0  addi r11, r30, 0x1b0
	ctx.r[11].s64 = ctx.r[30].s64 + 432;
	// 82198F9C: D3DF0074  stfs f30, 0x74(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82198FA0: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198FA4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82198FA8: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82198FAC: C1AABA38  lfs f13, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82198FB0: D1BF007C  stfs f13, 0x7c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82198FB4: 939F0088  stw r28, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 82198FB8: D3BF008C  stfs f29, 0x8c(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82198FBC: E95D0000  ld r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 82198FC0: F95F0090  std r10, 0x90(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u64 ) };
	// 82198FC4: E95D0008  ld r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 82198FC8: D39F00A0  stfs f28, 0xa0(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82198FCC: E93F0090  ld r9, 0x90(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	// 82198FD0: D37F00A4  stfs f27, 0xa4(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82198FD4: D35F00A8  stfs f26, 0xa8(r31)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82198FD8: F95F0098  std r10, 0x98(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[10].u64 ) };
	// 82198FDC: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82198FE0: E95F0098  ld r10, 0x98(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	// 82198FE4: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82198FE8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82198FEC: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82198FF0: 4839D039  bl 0x82536028
	ctx.lr = 0x82198FF4;
	sub_82535FFC(ctx, base);
	// 82198FF4: 4839C114  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82198FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82198FF8 size=360
    let mut pc: u32 = 0x82198FF8;
    'dispatch: loop {
        match pc {
            0x82198FF8 => {
    //   block [0x82198FF8..0x82199160)
	// 82198FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82198FFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82199000: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82199004: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82199008: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219900C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82199010: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82199014: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82199018: 393F00D0  addi r9, r31, 0xd0
	ctx.r[9].s64 = ctx.r[31].s64 + 208;
	// 8219901C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82199020: 816BB9D8  lwz r11, -0x4628(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 82199024: C18ABFFC  lfs f12, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82199028: C0090014  lfs f0, 0x14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219902C: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82199030: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82199034: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199038: 419A007C  beq cr6, 0x821990b4
	if ctx.cr[6].eq {
	pc = 0x821990B4; continue 'dispatch;
	}
	// 8219903C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82199040: 419A0064  beq cr6, 0x821990a4
	if ctx.cr[6].eq {
	pc = 0x821990A4; continue 'dispatch;
	}
	// 82199044: A14B0088  lhz r10, 0x88(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 82199048: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 8219904C: 409A0058  bne cr6, 0x821990a4
	if !ctx.cr[6].eq {
	pc = 0x821990A4; continue 'dispatch;
	}
	// 82199050: 394B00D0  addi r10, r11, 0xd0
	ctx.r[10].s64 = ctx.r[11].s64 + 208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82199160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82199160 size=684
    let mut pc: u32 = 0x82199160;
    'dispatch: loop {
        match pc {
            0x82199160 => {
    //   block [0x82199160..0x8219940C)
	// 82199160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82199164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82199168: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219916C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82199170: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82199174: 4839CE6D  bl 0x82535fe0
	ctx.lr = 0x82199178;
	sub_82535FB0(ctx, base);
	// 82199178: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219917C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82199180: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82199184: 3BCBBFF0  addi r30, r11, -0x4010
	ctx.r[30].s64 = ctx.r[11].s64 + -16400;
	// 82199188: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219918C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199190: 409A025C  bne cr6, 0x821993ec
	if !ctx.cr[6].eq {
	pc = 0x821993EC; continue 'dispatch;
	}
	// 82199194: C01F0194  lfs f0, 0x194(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82199198: C1BF0198  lfs f13, 0x198(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219919C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821991A0: D01F0194  stfs f0, 0x194(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 821991A4: 481CDD8D  bl 0x82366f30
	ctx.lr = 0x821991A8;
	sub_82366F30(ctx, base);
	// 821991A8: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821991AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821991B0: C1BF01A0  lfs f13, 0x1a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821991B4: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 821991B8: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821991BC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821991C0: C3CB2038  lfs f30, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821991C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821991C8: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821991CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821991D0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821991D4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821991D8: C3AB2280  lfs f29, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821991DC: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 821991E0: EC206FBA  fmadds f1, f0, f30, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64);
	// 821991E4: 481CE95D  bl 0x82367b40
	ctx.lr = 0x821991E8;
	sub_82367B40(ctx, base);
	// 821991E8: D03F01A0  stfs f1, 0x1a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 821991EC: 481CDD45  bl 0x82366f30
	ctx.lr = 0x821991F0;
	sub_82366F30(ctx, base);
	// 821991F0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821991F4: C1BF019C  lfs f13, 0x19c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821991F8: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821991FC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82199200: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82199204: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82199208: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219920C: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82199210: EC206FBA  fmadds f1, f0, f30, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64);
	// 82199214: 481CE92D  bl 0x82367b40
	ctx.lr = 0x82199218;
	sub_82367B40(ctx, base);
	// 82199218: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8219921C: C3DF01A0  lfs f30, 0x1a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82199220: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82199224: D03F019C  stfs f1, 0x19c(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82199228: C00BD4DC  lfs f0, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219922C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199230: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82199234: C36A1FF8  lfs f27, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82199238: C34BBFFC  lfs f26, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 8219923C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199240: C38B2048  lfs f28, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82199244: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82199248: FF0DD000  fcmpu cr6, f13, f26
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[26].f64);
	// 8219924C: 41980064  blt cr6, 0x821992b0
	if ctx.cr[6].lt {
	pc = 0x821992B0; continue 'dispatch;
	}
	// 82199250: EC00E028  fsubs f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[28].f64) as f32) as f64);
	// 82199254: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82199258: 4098003C  bge cr6, 0x82199294
	if !ctx.cr[6].lt {
	pc = 0x82199294; continue 'dispatch;
	}
	// 8219925C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82199260: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82199264: 4098000C  bge cr6, 0x82199270
	if !ctx.cr[6].lt {
	pc = 0x82199270; continue 'dispatch;
	}
	// 82199268: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219926C: 48000040  b 0x821992ac
	pc = 0x821992AC; continue 'dispatch;
	// 82199270: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82199274: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82199278: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8219927C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82199280: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82199284: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82199288: 41980024  blt cr6, 0x821992ac
	if ctx.cr[6].lt {
	pc = 0x821992AC; continue 'dispatch;
	}
	// 8219928C: FC00D890  fmr f0, f27
	ctx.f[0].f64 = ctx.f[27].f64;
	// 82199290: 4800001C  b 0x821992ac
	pc = 0x821992AC; continue 'dispatch;
	// 82199294: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82199298: 41980014  blt cr6, 0x821992ac
	if ctx.cr[6].lt {
	pc = 0x821992AC; continue 'dispatch;
	}
	// 8219929C: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821992A0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821992A4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821992A8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821992AC: EC00D028  fsubs f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	// 821992B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821992B4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821992B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821992BC: C3AB2490  lfs f29, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821992C0: EC200772  fmuls f1, f0, f29
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 821992C4: 4BF78B0D  bl 0x82111dd0
	ctx.lr = 0x821992C8;
	sub_82111DD0(ctx, base);
	// 821992C8: FDA0F210  fabs f13, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[30].u64 & !0x8000_0000_0000_0000u64;
	// 821992CC: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 821992D0: FF0DD000  fcmpu cr6, f13, f26
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[26].f64);
	// 821992D4: 41980064  blt cr6, 0x82199338
	if ctx.cr[6].lt {
	pc = 0x82199338; continue 'dispatch;
	}
	// 821992D8: EC1EE028  fsubs f0, f30, f28
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[28].f64) as f32) as f64);
	// 821992DC: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 821992E0: 4098003C  bge cr6, 0x8219931c
	if !ctx.cr[6].lt {
	pc = 0x8219931C; continue 'dispatch;
	}
	// 821992E4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821992E8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821992EC: 4098000C  bge cr6, 0x821992f8
	if !ctx.cr[6].lt {
	pc = 0x821992F8; continue 'dispatch;
	}
	// 821992F0: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821992F4: 48000040  b 0x82199334
	pc = 0x82199334; continue 'dispatch;
	// 821992F8: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821992FC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82199300: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82199304: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82199308: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219930C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82199310: 41980024  blt cr6, 0x82199334
	if ctx.cr[6].lt {
	pc = 0x82199334; continue 'dispatch;
	}
	// 82199314: FC00D890  fmr f0, f27
	ctx.f[0].f64 = ctx.f[27].f64;
	// 82199318: 4800001C  b 0x82199334
	pc = 0x82199334; continue 'dispatch;
	// 8219931C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82199320: 41980014  blt cr6, 0x82199334
	if ctx.cr[6].lt {
	pc = 0x82199334; continue 'dispatch;
	}
	// 82199324: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82199328: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8219932C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82199330: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82199334: EC00D028  fsubs f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	// 82199338: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8219933C: EC200772  fmuls f1, f0, f29
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82199340: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82199344: 4BF78A8D  bl 0x82111dd0
	ctx.lr = 0x82199348;
	sub_82111DD0(ctx, base);
	// 82199348: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219934C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82199350: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82199354: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199358: D3FF018C  stfs f31, 0x18c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 8219935C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82199360: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82199364: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82199368: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 8219936C: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82199370: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82199374: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82199378: C1AB22D0  lfs f13, 0x22d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8912 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219937C: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 82199380: C19F0198  lfs f12, 0x198(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82199384: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82199388: D1BF0198  stfs f13, 0x198(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 8219938C: C19F00E4  lfs f12, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82199390: 616B85E0  ori r11, r11, 0x85e0
	ctx.r[11].u64 = ctx.r[11].u64 | 34272;
	// 82199394: C1BF00E0  lfs f13, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82199398: EDAD6024  fdivs f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 8219939C: C01F0190  lfs f0, 0x190(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821993A0: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821993A4: 7DBE5C2E  lfsx f13, r30, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821993A8: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 821993AC: 616B85DC  ori r11, r11, 0x85dc
	ctx.r[11].u64 = ctx.r[11].u64 | 34268;
	// 821993B0: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 821993B4: D1BF01A4  stfs f13, 0x1a4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), tmp.u32 ) };
	// 821993B8: 7DBE5C2E  lfsx f13, r30, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821993BC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821993C0: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 821993C4: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 821993C8: 41990024  bgt cr6, 0x821993ec
	if ctx.cr[6].gt {
	pc = 0x821993EC; continue 'dispatch;
	}
	// 821993CC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821993D0: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821993D4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821993D8: 409A0014  bne cr6, 0x821993ec
	if !ctx.cr[6].eq {
	pc = 0x821993EC; continue 'dispatch;
	}
	// 821993DC: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821993E0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821993E4: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 821993E8: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 821993EC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821993F0: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 821993F4: 4839CC39  bl 0x8253602c
	ctx.lr = 0x821993F8;
	sub_82535FFC(ctx, base);
	// 821993F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821993FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82199400: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82199404: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82199408: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82199410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82199410 size=420
    let mut pc: u32 = 0x82199410;
    'dispatch: loop {
        match pc {
            0x82199410 => {
    //   block [0x82199410..0x821995B4)
	// 82199410: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821995B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821995B4 size=36
    let mut pc: u32 = 0x821995B4;
    'dispatch: loop {
        match pc {
            0x821995B4 => {
    //   block [0x821995B4..0x821995D8)
	// 821995B4: 386B00B0  addi r3, r11, 0xb0
	ctx.r[3].s64 = ctx.r[11].s64 + 176;
	// 821995B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821995BC: D0030000  stfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821995C0: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821995C4: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821995C8: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821995CC: D1A3000C  stfs f13, 0xc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821995D0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821995D4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821995D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821995D8 size=20
    let mut pc: u32 = 0x821995D8;
    'dispatch: loop {
        match pc {
            0x821995D8 => {
    //   block [0x821995D8..0x821995EC)
	// 821995D8: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821995DC: F9660000  std r11, 0(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821995E0: E9630008  ld r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 821995E4: F9660008  std r11, 8(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821995E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821995F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821995F0 size=28
    let mut pc: u32 = 0x821995F0;
    'dispatch: loop {
        match pc {
            0x821995F0 => {
    //   block [0x821995F0..0x8219960C)
	// 821995F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821995F4: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 821995F8: 9163008C  stw r11, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 821995FC: 916AB9D8  stw r11, -0x4628(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17960 as u32), ctx.r[11].u32 ) };
	// 82199600: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 82199604: F96AB9D0  std r11, -0x4630(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(-17968 as u32), ctx.r[11].u64 ) };
	// 82199608: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82199610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82199610 size=204
    let mut pc: u32 = 0x82199610;
    'dispatch: loop {
        match pc {
            0x82199610 => {
    //   block [0x82199610..0x821996DC)
	// 82199610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82199614: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82199618: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219961C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82199620: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82199624: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82199628: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8219962C: 409A000C  bne cr6, 0x82199638
	if !ctx.cr[6].eq {
	pc = 0x82199638; continue 'dispatch;
	}
	// 82199630: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82199634: 808BFAC0  lwz r4, -0x540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82199638: 3FC082C0  lis r30, -0x7d40
	ctx.r[30].s64 = -2101346304;
	// 8219963C: 3D602236  lis r11, 0x2236
	ctx.r[11].s64 = 573964288;
	// 82199640: 617F0679  ori r31, r11, 0x679
	ctx.r[31].u64 = ctx.r[11].u64 | 1657;
	// 82199644: 817EB9D8  lwz r11, -0x4628(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 82199648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219964C: 419A0010  beq cr6, 0x8219965c
	if ctx.cr[6].eq {
	pc = 0x8219965C; continue 'dispatch;
	}
	// 82199650: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82199654: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82199658: 419A006C  beq cr6, 0x821996c4
	if ctx.cr[6].eq {
	pc = 0x821996C4; continue 'dispatch;
	}
	// 8219965C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199660: 3CC00000  lis r6, 0
	ctx.r[6].s64 = 0;
	// 82199664: 38EB099C  addi r7, r11, 0x99c
	ctx.r[7].s64 = ctx.r[11].s64 + 2460;
	// 82199668: 60C6EA60  ori r6, r6, 0xea60
	ctx.r[6].u64 = ctx.r[6].u64 | 60000;
	// 8219966C: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 82199670: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 82199674: 481D0E1D  bl 0x8236a490
	ctx.lr = 0x82199678;
	sub_8236A490(ctx, base);
	// 82199678: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219967C: 419A0040  beq cr6, 0x821996bc
	if ctx.cr[6].eq {
	pc = 0x821996BC; continue 'dispatch;
	}
	// 82199680: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82199684: 907EB9D8  stw r3, -0x4628(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-17960 as u32), ctx.r[3].u32 ) };
	// 82199688: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219968C: 93E3008C  stw r31, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[31].u32 ) };
	// 82199690: 394B09FC  addi r10, r11, 0x9fc
	ctx.r[10].s64 = ctx.r[11].s64 + 2556;
	// 82199694: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82199698: C0091FF8  lfs f0, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219969C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821996A0: D0030084  stfs f0, 0x84(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821996A4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821996A8: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821996AC: 916300D4  stw r11, 0xd4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 821996B0: 916300D0  stw r11, 0xd0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 821996B4: 9923001C  stb r9, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[9].u8 ) };
	// 821996B8: 4800000C  b 0x821996c4
	pc = 0x821996C4; continue 'dispatch;
	// 821996BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821996C0: 917EB9D8  stw r11, -0x4628(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-17960 as u32), ctx.r[11].u32 ) };
	// 821996C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821996C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821996CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821996D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821996D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821996D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821996E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821996E0 size=672
    let mut pc: u32 = 0x821996E0;
    'dispatch: loop {
        match pc {
            0x821996E0 => {
    //   block [0x821996E0..0x82199980)
	// 821996E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821996E4: 4839B9B9  bl 0x8253509c
	ctx.lr = 0x821996E8;
	sub_82535080(ctx, base);
	// 821996E8: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 821996EC: 4839C8FD  bl 0x82535fe8
	ctx.lr = 0x821996F0;
	sub_82535FB0(ctx, base);
	// 821996F0: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82199980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82199980 size=84
    let mut pc: u32 = 0x82199980;
    'dispatch: loop {
        match pc {
            0x82199980 => {
    //   block [0x82199980..0x821999D4)
	// 82199980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82199984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82199988: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219998C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82199990: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82199994: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82199998: 482308E1  bl 0x823ca278
	ctx.lr = 0x8219999C;
	sub_823CA278(ctx, base);
	// 8219999C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 821999A0: 39400068  li r10, 0x68
	ctx.r[10].s64 = 104;
	// 821999A4: E93F00E0  ld r9, 0xe0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	// 821999A8: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821999AC: 7D294050  subf r9, r9, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 821999B0: 7D6A582A  ldx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	// 821999B4: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 821999B8: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 821999BC: F96AB9D0  std r11, -0x4630(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(-17968 as u32), ctx.r[11].u64 ) };
	// 821999C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821999C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821999C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821999CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821999D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821999D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821999D8 size=360
    let mut pc: u32 = 0x821999D8;
    'dispatch: loop {
        match pc {
            0x821999D8 => {
    //   block [0x821999D8..0x82199B40)
	// 821999D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821999DC: 4839B6DD  bl 0x825350b8
	ctx.lr = 0x821999E0;
	sub_82535080(ctx, base);
	// 821999E0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821999E4: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82199B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82199B40 size=432
    let mut pc: u32 = 0x82199B40;
    'dispatch: loop {
        match pc {
            0x82199B40 => {
    //   block [0x82199B40..0x82199CF0)
	// 82199B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82199B44: 4839B575  bl 0x825350b8
	ctx.lr = 0x82199B48;
	sub_82535080(ctx, base);
	// 82199B48: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82199CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82199CF0 size=20
    let mut pc: u32 = 0x82199CF0;
    'dispatch: loop {
        match pc {
            0x82199CF0 => {
    //   block [0x82199CF0..0x82199D04)
	// 82199CF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82199CF4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82199CF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82199CFC: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82199D00: 481D05F8  b 0x8236a2f8
	sub_8236A2F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82199D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82199D08 size=676
    let mut pc: u32 = 0x82199D08;
    'dispatch: loop {
        match pc {
            0x82199D08 => {
    //   block [0x82199D08..0x82199D5C)
	// 82199D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82199D0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82199D10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82199D14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82199D18: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82199D1C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82199D20: 2B040005  cmplwi cr6, r4, 5
	ctx.cr[6].compare_u32(ctx.r[4].u32, 5 as u32, &mut ctx.xer);
	// 82199D24: 83EBB9D8  lwz r31, -0x4628(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 82199D28: 41990234  bgt cr6, 0x82199f5c
	if ctx.cr[6].gt {
	pc = 0x82199F5C; continue 'dispatch;
	}
	// 82199D2C: 3D80821A  lis r12, -0x7de6
	ctx.r[12].s64 = -2112225280;
	// 82199D30: 398C9D44  addi r12, r12, -0x62bc
	ctx.r[12].s64 = ctx.r[12].s64 + -25276;
	// 82199D34: 5480103A  slwi r0, r4, 2
	ctx.r[0].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82199D38: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82199D3C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82199D40: 4E800420  bctr
	match ctx.r[4].u64 {
		0 => {
	pc = 0x82199D5C; continue 'dispatch;
		},
		1 => {
	pc = 0x82199DC4; continue 'dispatch;
		},
		2 => {
	pc = 0x82199DFC; continue 'dispatch;
		},
		3 => {
	pc = 0x82199E34; continue 'dispatch;
		},
		4 => {
	pc = 0x82199E9C; continue 'dispatch;
		},
		5 => {
	pc = 0x82199EE0; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82199D44: 82199D5C  lwz r16, -0x62a4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25252 as u32) ) } as u64;
	// 82199D48: 82199DC4  lwz r16, -0x623c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25148 as u32) ) } as u64;
	// 82199D4C: 82199DFC  lwz r16, -0x6204(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25092 as u32) ) } as u64;
	// 82199D50: 82199E34  lwz r16, -0x61cc(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25036 as u32) ) } as u64;
	// 82199D54: 82199E9C  lwz r16, -0x6164(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-24932 as u32) ) } as u64;
	// 82199D58: 82199EE0  lwz r16, -0x6120(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-24864 as u32) ) } as u64;
            }
            0x82199D5C => {
    //   block [0x82199D5C..0x82199DC4)
	// 82199D5C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199D60: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82199D64: 38EB09A8  addi r7, r11, 0x9a8
	ctx.r[7].s64 = ctx.r[11].s64 + 2472;
	// 82199D68: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82199D6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82199D70: 38600190  li r3, 0x190
	ctx.r[3].s64 = 400;
	// 82199D74: 481D071D  bl 0x8236a490
	ctx.lr = 0x82199D78;
	sub_8236A490(ctx, base);
	// 82199D78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82199D7C: 419A01E0  beq cr6, 0x82199f5c
	if ctx.cr[6].eq {
	pc = 0x82199F5C; continue 'dispatch;
	}
	// 82199D80: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199D84: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82199D88: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82199D8C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199D90: C1A9BA38  lfs f13, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82199D94: 394B0A40  addi r10, r11, 0xa40
	ctx.r[10].s64 = ctx.r[11].s64 + 2624;
	// 82199D98: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82199D9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82199DA0: D00300B4  stfs f0, 0xb4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82199DA4: D00300B8  stfs f0, 0xb8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82199DA8: D1A300BC  stfs f13, 0xbc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82199DAC: D00300A0  stfs f0, 0xa0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82199DB0: D00300A4  stfs f0, 0xa4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82199DB4: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82199DB8: D1A300AC  stfs f13, 0xac(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82199DBC: B1630088  sth r11, 0x88(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u16 ) };
	// 82199DC0: 48000188  b 0x82199f48
	pc = 0x82199F48; continue 'dispatch;
            }
            0x82199DC4 => {
    //   block [0x82199DC4..0x82199DFC)
	// 82199DC4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199DC8: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82199DCC: 38EB09B4  addi r7, r11, 0x9b4
	ctx.r[7].s64 = ctx.r[11].s64 + 2484;
	// 82199DD0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82199DD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82199DD8: 386001E0  li r3, 0x1e0
	ctx.r[3].s64 = 480;
	// 82199DDC: 481D06B5  bl 0x8236a490
	ctx.lr = 0x82199DE0;
	sub_8236A490(ctx, base);
	// 82199DE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82199DE4: 419A0178  beq cr6, 0x82199f5c
	if ctx.cr[6].eq {
	pc = 0x82199F5C; continue 'dispatch;
	}
	// 82199DE8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199DEC: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82199DF0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199DF4: 394B0A88  addi r10, r11, 0xa88
	ctx.r[10].s64 = ctx.r[11].s64 + 2696;
	// 82199DF8: 4800011C  b 0x82199f14
	pc = 0x82199F14; continue 'dispatch;
            }
            0x82199DFC => {
    //   block [0x82199DFC..0x82199E34)
	// 82199DFC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199E00: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82199E04: 38EB09C0  addi r7, r11, 0x9c0
	ctx.r[7].s64 = ctx.r[11].s64 + 2496;
	// 82199E08: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82199E0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82199E10: 386001E0  li r3, 0x1e0
	ctx.r[3].s64 = 480;
	// 82199E14: 481D067D  bl 0x8236a490
	ctx.lr = 0x82199E18;
	sub_8236A490(ctx, base);
	// 82199E18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82199E1C: 419A0140  beq cr6, 0x82199f5c
	if ctx.cr[6].eq {
	pc = 0x82199F5C; continue 'dispatch;
	}
	// 82199E20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199E24: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82199E28: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199E2C: 394B0AAC  addi r10, r11, 0xaac
	ctx.r[10].s64 = ctx.r[11].s64 + 2732;
	// 82199E30: 480000E4  b 0x82199f14
	pc = 0x82199F14; continue 'dispatch;
            }
            0x82199E34 => {
    //   block [0x82199E34..0x82199E9C)
	// 82199E34: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199E38: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82199E3C: 38EB09CC  addi r7, r11, 0x9cc
	ctx.r[7].s64 = ctx.r[11].s64 + 2508;
	// 82199E40: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82199E44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82199E48: 38600190  li r3, 0x190
	ctx.r[3].s64 = 400;
	// 82199E4C: 481D0645  bl 0x8236a490
	ctx.lr = 0x82199E50;
	sub_8236A490(ctx, base);
	// 82199E50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82199E54: 419A0108  beq cr6, 0x82199f5c
	if ctx.cr[6].eq {
	pc = 0x82199F5C; continue 'dispatch;
	}
	// 82199E58: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199E5C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82199E60: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82199E64: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199E68: C1A9BA38  lfs f13, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82199E6C: 394B0A64  addi r10, r11, 0xa64
	ctx.r[10].s64 = ctx.r[11].s64 + 2660;
	// 82199E70: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82199E74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82199E78: D00300B4  stfs f0, 0xb4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82199E7C: D00300B8  stfs f0, 0xb8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82199E80: D1A300BC  stfs f13, 0xbc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82199E84: D00300A0  stfs f0, 0xa0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82199E88: D00300A4  stfs f0, 0xa4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82199E8C: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82199E90: D1A300AC  stfs f13, 0xac(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82199E94: B1630088  sth r11, 0x88(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u16 ) };
	// 82199E98: 480000B0  b 0x82199f48
	pc = 0x82199F48; continue 'dispatch;
            }
            0x82199E9C => {
    //   block [0x82199E9C..0x82199EE0)
	// 82199E9C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199EA0: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82199EA4: 38EB09D8  addi r7, r11, 0x9d8
	ctx.r[7].s64 = ctx.r[11].s64 + 2520;
	// 82199EA8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82199EAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82199EB0: 386001B0  li r3, 0x1b0
	ctx.r[3].s64 = 432;
	// 82199EB4: 481D05DD  bl 0x8236a490
	ctx.lr = 0x82199EB8;
	sub_8236A490(ctx, base);
	// 82199EB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82199EBC: 419A00A0  beq cr6, 0x82199f5c
	if ctx.cr[6].eq {
	pc = 0x82199F5C; continue 'dispatch;
	}
	// 82199EC0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199EC4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82199EC8: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82199ECC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199ED0: C1A9BA38  lfs f13, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82199ED4: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 82199ED8: 394B0AD0  addi r10, r11, 0xad0
	ctx.r[10].s64 = ctx.r[11].s64 + 2768;
	// 82199EDC: 48000044  b 0x82199f20
	pc = 0x82199F20; continue 'dispatch;
            }
            0x82199EE0 => {
    //   block [0x82199EE0..0x82199FAC)
	// 82199EE0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199EE4: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82199EE8: 38EB09E4  addi r7, r11, 0x9e4
	ctx.r[7].s64 = ctx.r[11].s64 + 2532;
	// 82199EEC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82199EF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82199EF4: 38600240  li r3, 0x240
	ctx.r[3].s64 = 576;
	// 82199EF8: 481D0599  bl 0x8236a490
	ctx.lr = 0x82199EFC;
	sub_8236A490(ctx, base);
	// 82199EFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82199F00: 419A005C  beq cr6, 0x82199f5c
	if ctx.cr[6].eq {
	pc = 0x82199F5C; continue 'dispatch;
	}
	// 82199F04: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199F08: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82199F0C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199F10: 394B0AF4  addi r10, r11, 0xaf4
	ctx.r[10].s64 = ctx.r[11].s64 + 2804;
	// 82199F14: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82199F18: C1A9BA38  lfs f13, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82199F1C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82199F20: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82199F24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82199F28: D00300B4  stfs f0, 0xb4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82199F2C: D00300B8  stfs f0, 0xb8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82199F30: D1A300BC  stfs f13, 0xbc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82199F34: D00300A0  stfs f0, 0xa0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82199F38: D00300A4  stfs f0, 0xa4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82199F3C: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82199F40: D1A300AC  stfs f13, 0xac(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82199F44: B1230088  sth r9, 0x88(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[9].u16 ) };
	// 82199F48: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82199F4C: D00300C4  stfs f0, 0xc4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82199F50: 916300C0  stw r11, 0xc0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82199F54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82199F58: 409A001C  bne cr6, 0x82199f74
	if !ctx.cr[6].eq {
	pc = 0x82199F74; continue 'dispatch;
	}
	// 82199F5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82199F60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82199F64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82199F68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82199F6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82199F70: 4E800020  blr
	return;
	// 82199F74: 93E30090  stw r31, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 82199F78: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82199F7C: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82199F80: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82199F84: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82199F88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199F8C: 419A0008  beq cr6, 0x82199f94
	if ctx.cr[6].eq {
	pc = 0x82199F94; continue 'dispatch;
	}
	// 82199F90: 906B0084  stw r3, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82199F94: 907F0080  stw r3, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 82199F98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82199F9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82199FA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82199FA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82199FA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82199FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82199FB0 size=532
    let mut pc: u32 = 0x82199FB0;
    'dispatch: loop {
        match pc {
            0x82199FB0 => {
    //   block [0x82199FB0..0x8219A1C4)
	// 82199FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82199FB4: 4839B109  bl 0x825350bc
	ctx.lr = 0x82199FB8;
	sub_82535080(ctx, base);
	// 82199FB8: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 82199FBC: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82199FC0: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82199FC4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82199FC8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82199FCC: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 82199FD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199FD4: 419A0050  beq cr6, 0x8219a024
	if ctx.cr[6].eq {
	pc = 0x8219A024; continue 'dispatch;
	}
	// 82199FD8: 813D00D4  lwz r9, 0xd4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(212 as u32) ) } as u64;
	// 82199FDC: 2F090008  cmpwi cr6, r9, 8
	ctx.cr[6].compare_i32(ctx.r[9].s32, 8, &mut ctx.xer);
	// 82199FE0: 409801C8  bge cr6, 0x8219a1a8
	if !ctx.cr[6].lt {
	pc = 0x8219A1A8; continue 'dispatch;
	}
	// 82199FE4: 817D00D0  lwz r11, 0xd0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(208 as u32) ) } as u64;
	// 82199FE8: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 82199FEC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82199FF0: 394A9FB0  addi r10, r10, -0x6050
	ctx.r[10].s64 = ctx.r[10].s64 + -24656;
	// 82199FF4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82199FF8: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 82199FFC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219A000: 7D4BE92E  stwx r10, r11, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), ctx.r[10].u32) };
	// 8219A004: 817D00D4  lwz r11, 0xd4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A008: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8219A00C: 917D00D4  stw r11, 0xd4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 8219A010: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219A014: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8219A018: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8219A01C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8219A020: 4839B0EC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
	// 8219A024: 817D00D8  lwz r11, 0xd8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(216 as u32) ) } as u64;
	// 8219A028: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219A02C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219A030: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A034: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219A038: C3CB2280  lfs f30, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8219A03C: 4098002C  bge cr6, 0x8219a068
	if !ctx.cr[6].lt {
	pc = 0x8219A068; continue 'dispatch;
	}
	// 8219A040: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219A044: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219A048: 3BEBB9D8  addi r31, r11, -0x4628
	ctx.r[31].s64 = ctx.r[11].s64 + -17960;
	// 8219A04C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A050: 4BFFFCB9  bl 0x82199d08
	ctx.lr = 0x8219A054;
	sub_82199D08(ctx, base);
	// 8219A054: C09D00F8  lfs f4, 0xf8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(248 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219A058: C07D00F4  lfs f3, 0xf4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(244 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8219A05C: C05D00F0  lfs f2, 0xf0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(240 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219A060: C03D00FC  lfs f1, 0xfc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(252 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219A064: 4800004C  b 0x8219a0b0
	pc = 0x8219A0B0; continue 'dispatch;
	// 8219A068: 481CD0D1  bl 0x82367138
	ctx.lr = 0x8219A06C;
	sub_82367138(ctx, base);
	// 8219A06C: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219A070: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219A074: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219A078: 3BEBB9D8  addi r31, r11, -0x4628
	ctx.r[31].s64 = ctx.r[11].s64 + -17960;
	// 8219A07C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 8219A080: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A084: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219A088: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8219A08C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219A090: EFA007B2  fmuls f29, f0, f30
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8219A094: 4BFFFC75  bl 0x82199d08
	ctx.lr = 0x8219A098;
	sub_82199D08(ctx, base);
	// 8219A098: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A09C: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 8219A0A0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8219A0A4: C08B23D0  lfs f4, 0x23d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9168 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219A0A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A0AC: C02B2E38  lfs f1, 0x2e38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11832 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219A0B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219A0B4: 4BFFC02D  bl 0x821960e0
	ctx.lr = 0x8219A0B8;
	sub_821960E0(ctx, base);
	// 8219A0B8: 39600DEF  li r11, 0xdef
	ctx.r[11].s64 = 3567;
	// 8219A0BC: 917E003C  stw r11, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 8219A0C0: 481CD079  bl 0x82367138
	ctx.lr = 0x8219A0C4;
	sub_82367138(ctx, base);
	// 8219A0C4: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219A0C8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219A0CC: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219A0D0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8219A0D4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219A0D8: ED8007B2  fmuls f12, f0, f30
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8219A0DC: 481CD3AD  bl 0x82367488
	ctx.lr = 0x8219A0E0;
	sub_82367488(ctx, base);
	// 8219A0E0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219A0E4: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A0E8: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8219A0EC: 38EB09CC  addi r7, r11, 0x9cc
	ctx.r[7].s64 = ctx.r[11].s64 + 2508;
	// 8219A0F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A0F4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219A0F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219A0FC: 38600190  li r3, 0x190
	ctx.r[3].s64 = 400;
	// 8219A100: C00BBFFC  lfs f0, -0x4004(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A104: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8219A108: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219A10C: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219A110: C00BD560  lfs f0, -0x2aa0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A114: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219A118: 481D0379  bl 0x8236a490
	ctx.lr = 0x8219A11C;
	sub_8236A490(ctx, base);
	// 8219A11C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219A120: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8219A124: 419A0098  beq cr6, 0x8219a1bc
	if ctx.cr[6].eq {
	pc = 0x8219A1BC; continue 'dispatch;
	}
	// 8219A128: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219A12C: D3E300B0  stfs f31, 0xb0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8219A130: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8219A134: D3E300B4  stfs f31, 0xb4(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 8219A138: 396B0A64  addi r11, r11, 0xa64
	ctx.r[11].s64 = ctx.r[11].s64 + 2660;
	// 8219A13C: D3E300B8  stfs f31, 0xb8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 8219A140: C00ABA38  lfs f0, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A144: D00300BC  stfs f0, 0xbc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 8219A148: D3E300A0  stfs f31, 0xa0(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8219A14C: D3E300A4  stfs f31, 0xa4(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8219A150: D3E300A8  stfs f31, 0xa8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8219A154: D00300AC  stfs f0, 0xac(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8219A158: 93C300C0  stw r30, 0xc0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 8219A15C: D3E300C4  stfs f31, 0xc4(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8219A160: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219A164: B3C30088  sth r30, 0x88(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[30].u16 ) };
	// 8219A168: 93E30090  stw r31, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 8219A16C: 93C30084  stw r30, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 8219A170: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219A174: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 8219A178: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219A17C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A180: 419A0008  beq cr6, 0x8219a188
	if ctx.cr[6].eq {
	pc = 0x8219A188; continue 'dispatch;
	}
	// 8219A184: 906B0084  stw r3, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 8219A188: 907F0080  stw r3, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 8219A18C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A190: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 8219A194: C04BD6C8  lfs f2, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219A198: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A19C: C02B23F0  lfs f1, 0x23f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9200 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219A1A0: 4BFFC1F9  bl 0x82196398
	ctx.lr = 0x8219A1A4;
	sub_82196398(ctx, base);
	// 8219A1A4: 93DD00DC  stw r30, 0xdc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(220 as u32), ctx.r[30].u32 ) };
	// 8219A1A8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219A1AC: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8219A1B0: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8219A1B4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8219A1B8: 4839AF54  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
	// 8219A1BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219A1C0: 4BFFFFCC  b 0x8219a18c
	pc = 0x8219A18C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219A1C8 size=132
    let mut pc: u32 = 0x8219A1C8;
    'dispatch: loop {
        match pc {
            0x8219A1C8 => {
    //   block [0x8219A1C8..0x8219A24C)
	// 8219A1C8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219A1CC: 816BB9D8  lwz r11, -0x4628(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 8219A1D0: 814B00D4  lwz r10, 0xd4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A1D4: 2F0A0008  cmpwi cr6, r10, 8
	ctx.cr[6].compare_i32(ctx.r[10].s32, 8, &mut ctx.xer);
	// 8219A1D8: 40980030  bge cr6, 0x8219a208
	if !ctx.cr[6].lt {
	pc = 0x8219A208; continue 'dispatch;
	}
	// 8219A1DC: 812B00D0  lwz r9, 0xd0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 8219A1E0: 3D00821A  lis r8, -0x7de6
	ctx.r[8].s64 = -2112225280;
	// 8219A1E4: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8219A1E8: 39089CF0  addi r8, r8, -0x6310
	ctx.r[8].s64 = ctx.r[8].s64 + -25360;
	// 8219A1EC: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 8219A1F0: 394A0024  addi r10, r10, 0x24
	ctx.r[10].s64 = ctx.r[10].s64 + 36;
	// 8219A1F4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219A1F8: 7D0A592E  stwx r8, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u32) };
	// 8219A1FC: 814B00D4  lwz r10, 0xd4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A200: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8219A204: 914B00D4  stw r10, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[10].u32 ) };
	// 8219A208: 812300D4  lwz r9, 0xd4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A20C: 2F090008  cmpwi cr6, r9, 8
	ctx.cr[6].compare_i32(ctx.r[9].s32, 8, &mut ctx.xer);
	// 8219A210: 4098003C  bge cr6, 0x8219a24c
	if !ctx.cr[6].lt {
		sub_8219A24C(ctx, base);
		return;
	}
	// 8219A214: 816300D0  lwz r11, 0xd0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) } as u64;
	// 8219A218: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 8219A21C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219A220: 394A9FB0  addi r10, r10, -0x6050
	ctx.r[10].s64 = ctx.r[10].s64 + -24656;
	// 8219A224: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 8219A228: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8219A22C: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 8219A230: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219A234: 7D4B192E  stwx r10, r11, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[10].u32) };
	// 8219A238: 816300D4  lwz r11, 0xd4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A23C: 912300DC  stw r9, 0xdc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(220 as u32), ctx.r[9].u32 ) };
	// 8219A240: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8219A244: 916300D4  stw r11, 0xd4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 8219A248: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A24C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219A24C size=12
    let mut pc: u32 = 0x8219A24C;
    'dispatch: loop {
        match pc {
            0x8219A24C => {
    //   block [0x8219A24C..0x8219A258)
	// 8219A24C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219A250: 916300DC  stw r11, 0xdc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 8219A254: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219A258 size=16
    let mut pc: u32 = 0x8219A258;
    'dispatch: loop {
        match pc {
            0x8219A258 => {
    //   block [0x8219A258..0x8219A268)
	// 8219A258: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219A25C: 816BB9D8  lwz r11, -0x4628(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 8219A260: 386B0100  addi r3, r11, 0x100
	ctx.r[3].s64 = ctx.r[11].s64 + 256;
	// 8219A264: 4BFFBC54  b 0x82195eb8
	sub_82195EB8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219A268 size=428
    let mut pc: u32 = 0x8219A268;
    'dispatch: loop {
        match pc {
            0x8219A268 => {
    //   block [0x8219A268..0x8219A414)
	// 8219A268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219A26C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219A270: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219A274: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219A278: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219A27C: 3FE082C0  lis r31, -0x7d40
	ctx.r[31].s64 = -2101346304;
	// 8219A280: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8219A284: 809FB9D8  lwz r4, -0x4628(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 8219A288: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8219A28C: 409A0010  bne cr6, 0x8219a29c
	if !ctx.cr[6].eq {
	pc = 0x8219A29C; continue 'dispatch;
	}
	// 8219A290: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219A294: 4BFFF37D  bl 0x82199610
	ctx.lr = 0x8219A298;
	sub_82199610(ctx, base);
	// 8219A298: 809FB9D8  lwz r4, -0x4628(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 8219A29C: 481CCE9D  bl 0x82367138
	ctx.lr = 0x8219A2A0;
	sub_82367138(ctx, base);
	// 8219A2A0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219A2A4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219A2A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A2AC: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219A2B0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8219A2B4: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219A2B8: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A2BC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219A2C0: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8219A2C4: 481CCE75  bl 0x82367138
	ctx.lr = 0x8219A2C8;
	sub_82367138(ctx, base);
	// 8219A2C8: 78690260  clrldi r9, r3, 0x29
	ctx.r[9].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219A2CC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219A2D0: 810400DC  lwz r8, 0xdc(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(220 as u32) ) } as u64;
	// 8219A2D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A2D8: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 8219A2DC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8219A2E0: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 8219A2E4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8219A2E8: C18A3140  lfs f12, 0x3140(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12608 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219A2EC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219A2F0: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8219A2F4: C1AB2038  lfs f13, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219A2F8: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 8219A2FC: 90E400D8  stw r7, 0xd8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(216 as u32), ctx.r[7].u32 ) };
	// 8219A300: C18ABFFC  lfs f12, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219A304: 394400F0  addi r10, r4, 0xf0
	ctx.r[10].s64 = ctx.r[4].s64 + 240;
	// 8219A308: D181006C  stfs f12, 0x6c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8219A30C: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219A310: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8219A314: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8219A318: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219A31C: C0092144  lfs f0, 0x2144(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A320: EC0C0378  fmsubs f0, f12, f13, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219A324: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8219A328: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8219A32C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 8219A330: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8219A334: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8219A338: 409A007C  bne cr6, 0x8219a3b4
	if !ctx.cr[6].eq {
	pc = 0x8219A3B4; continue 'dispatch;
	}
	// 8219A33C: 812400D4  lwz r9, 0xd4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A340: 2F090008  cmpwi cr6, r9, 8
	ctx.cr[6].compare_i32(ctx.r[9].s32, 8, &mut ctx.xer);
	// 8219A344: 40980030  bge cr6, 0x8219a374
	if !ctx.cr[6].lt {
	pc = 0x8219A374; continue 'dispatch;
	}
	// 8219A348: 816400D0  lwz r11, 0xd0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(208 as u32) ) } as u64;
	// 8219A34C: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 8219A350: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219A354: 394A9CF0  addi r10, r10, -0x6310
	ctx.r[10].s64 = ctx.r[10].s64 + -25360;
	// 8219A358: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 8219A35C: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 8219A360: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219A364: 7D4B212E  stwx r10, r11, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), ctx.r[10].u32) };
	// 8219A368: 816400D4  lwz r11, 0xd4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A36C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8219A370: 916400D4  stw r11, 0xd4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 8219A374: 812400D4  lwz r9, 0xd4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A378: 2F090008  cmpwi cr6, r9, 8
	ctx.cr[6].compare_i32(ctx.r[9].s32, 8, &mut ctx.xer);
	// 8219A37C: 40980030  bge cr6, 0x8219a3ac
	if !ctx.cr[6].lt {
	pc = 0x8219A3AC; continue 'dispatch;
	}
	// 8219A380: 816400D0  lwz r11, 0xd0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(208 as u32) ) } as u64;
	// 8219A384: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 8219A388: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219A38C: 394A9FB0  addi r10, r10, -0x6050
	ctx.r[10].s64 = ctx.r[10].s64 + -24656;
	// 8219A390: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 8219A394: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 8219A398: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219A39C: 7D4B212E  stwx r10, r11, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), ctx.r[10].u32) };
	// 8219A3A0: 816400D4  lwz r11, 0xd4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A3A4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8219A3A8: 916400D4  stw r11, 0xd4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 8219A3AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219A3B0: 916400DC  stw r11, 0xdc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 8219A3B4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219A3B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219A3BC: 38EB09F0  addi r7, r11, 0x9f0
	ctx.r[7].s64 = ctx.r[11].s64 + 2544;
	// 8219A3C0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219A3C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219A3C8: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 8219A3CC: 481D00C5  bl 0x8236a490
	ctx.lr = 0x8219A3D0;
	sub_8236A490(ctx, base);
	// 8219A3D0: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8219A3D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219A3D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219A3DC: 61299504  ori r9, r9, 0x9504
	ctx.r[9].u64 = ctx.r[9].u64 | 38148;
	// 8219A3E0: 419A0010  beq cr6, 0x8219a3f0
	if ctx.cr[6].eq {
	pc = 0x8219A3F0; continue 'dispatch;
	}
	// 8219A3E4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219A3E8: 396B0B38  addi r11, r11, 0xb38
	ctx.r[11].s64 = ctx.r[11].s64 + 2872;
	// 8219A3EC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219A3F0: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219A3F4: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219A3F8: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 8219A3FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219A400: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219A404: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219A408: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219A40C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219A410: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219A418 size=668
    let mut pc: u32 = 0x8219A418;
    'dispatch: loop {
        match pc {
            0x8219A418 => {
    //   block [0x8219A418..0x8219A6B4)
	// 8219A418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219A41C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219A420: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219A424: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219A428: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 8219A42C: 4839BBB5  bl 0x82535fe0
	ctx.lr = 0x8219A430;
	sub_82535FB0(ctx, base);
	// 8219A430: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219A434: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219A438: 809F0080  lwz r4, 0x80(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219A43C: 89440007  lbz r10, 7(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(7 as u32) ) } as u64;
	// 8219A440: 89640005  lbz r11, 5(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(5 as u32) ) } as u64;
	// 8219A444: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219A448: 409A0028  bne cr6, 0x8219a470
	if !ctx.cr[6].eq {
	pc = 0x8219A470; continue 'dispatch;
	}
	// 8219A44C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8219A450: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219A454: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8219A458: 409A023C  bne cr6, 0x8219a694
	if !ctx.cr[6].eq {
	pc = 0x8219A694; continue 'dispatch;
	}
	// 8219A45C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8219A460: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219A464: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 8219A468: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 8219A46C: 48000228  b 0x8219a694
	pc = 0x8219A694; continue 'dispatch;
	// 8219A470: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 8219A474: 4198FFD8  blt cr6, 0x8219a44c
	if ctx.cr[6].lt {
	pc = 0x8219A44C; continue 'dispatch;
	}
	// 8219A478: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 8219A47C: 80C4005C  lwz r6, 0x5c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(92 as u32) ) } as u64;
	// 8219A480: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219A484: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8219A488: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 8219A48C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 8219A490: 38BF00B0  addi r5, r31, 0xb0
	ctx.r[5].s64 = ctx.r[31].s64 + 176;
	// 8219A494: C3471FF8  lfs f26, 0x1ff8(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8184 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 8219A498: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 8219A49C: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A4A0: 38DF00A0  addi r6, r31, 0xa0
	ctx.r[6].s64 = ctx.r[31].s64 + 160;
	// 8219A4A4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8219A4A8: C00B0024  lfs f0, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A4AC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8219A4B0: E8670000  ld r3, 0(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 8219A4B4: C00B0028  lfs f0, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A4B8: E8E70008  ld r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 8219A4BC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8219A4C0: C12B0010  lfs f9, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8219A4C4: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219A4C8: FF09D000  fcmpu cr6, f9, f26
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[26].f64);
	// 8219A4CC: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219A4D0: F86A0000  std r3, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[3].u64 ) };
	// 8219A4D4: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219A4D8: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219A4DC: F8EA0008  std r7, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 8219A4E0: C10B0014  lfs f8, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8219A4E4: E9490000  ld r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 8219A4E8: C0EB0018  lfs f7, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 8219A4EC: C00B001C  lfs f0, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A4F0: E9690008  ld r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 8219A4F4: D341005C  stfs f26, 0x5c(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8219A4F8: EBC80000  ld r30, 0(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 8219A4FC: E9280008  ld r9, 8(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 8219A500: D1BF0090  stfs f13, 0x90(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8219A504: F9460000  std r10, 0(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 8219A508: D19F00E4  stfs f12, 0xe4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 8219A50C: D17F00D0  stfs f11, 0xd0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 8219A510: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219A514: D15F00D8  stfs f10, 0xd8(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 8219A518: F9660008  std r11, 8(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8219A51C: FBC50000  std r30, 0(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 8219A520: F9250008  std r9, 8(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 8219A524: 409A0008  bne cr6, 0x8219a52c
	if !ctx.cr[6].eq {
	pc = 0x8219A52C; continue 'dispatch;
	}
	// 8219A528: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219A52C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219A530: D11F00C0  stfs f8, 0xc0(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8219A534: D0FF00CC  stfs f7, 0xcc(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 8219A538: 915F00D4  stw r10, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[10].u32 ) };
	// 8219A53C: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8219A540: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219A544: C3ABBA38  lfs f29, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8219A548: EDA0E828  fsubs f13, f0, f29
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	// 8219A54C: D1BF00C8  stfs f13, 0xc8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 8219A550: 8164005C  lwz r11, 0x5c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(92 as u32) ) } as u64;
	// 8219A554: C06B0018  lfs f3, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8219A558: C04B0014  lfs f2, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219A55C: C02B0010  lfs f1, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219A560: 481CDCB9  bl 0x82368218
	ctx.lr = 0x8219A564;
	sub_82368218(ctx, base);
	// 8219A564: C0010090  lfs f0, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A568: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A56C: FF600090  fmr f27, f0
	ctx.f[27].f64 = ctx.f[0].f64;
	// 8219A570: C1AB2150  lfs f13, 0x2150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8528 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219A574: FD80DA10  fabs f12, f27
	ctx.f[12].u64 = ctx.f[27].u64 & !0x8000_0000_0000_0000u64;
	// 8219A578: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 8219A57C: 40990080  ble cr6, 0x8219a5fc
	if !ctx.cr[6].gt {
	pc = 0x8219A5FC; continue 'dispatch;
	}
	// 8219A580: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219A584: C3E10098  lfs f31, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219A588: C0210094  lfs f1, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219A58C: EC1F07FA  fmadds f0, f31, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 8219A590: EC40002C  fsqrts f2, f0
	ctx.f[2].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 8219A594: 48398915  bl 0x82532ea8
	ctx.lr = 0x8219A598;
	sub_82532EA8(ctx, base);
	// 8219A598: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A59C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8219A5A0: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 8219A5A4: C38B2254  lfs f28, 0x2254(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8788 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 8219A5A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A5AC: C3CBBFFC  lfs f30, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8219A5B0: EC20F73A  fmadds f1, f0, f28, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[28].f64 + ctx.f[30].f64) as f32) as f64);
	// 8219A5B4: 481CD58D  bl 0x82367b40
	ctx.lr = 0x8219A5B8;
	sub_82367B40(ctx, base);
	// 8219A5B8: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 8219A5BC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219A5C0: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 8219A5C4: EFE0F028  fsubs f31, f0, f30
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 8219A5C8: 483988E1  bl 0x82532ea8
	ctx.lr = 0x8219A5CC;
	sub_82532EA8(ctx, base);
	// 8219A5CC: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8219A5D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A5D4: FD80FA10  fabs f12, f31
	ctx.f[12].u64 = ctx.f[31].u64 & !0x8000_0000_0000_0000u64;
	// 8219A5D8: C00B2038  lfs f0, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A5DC: EC2D0738  fmsubs f1, f13, f28, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219A5E0: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 8219A5E4: 40990094  ble cr6, 0x8219a678
	if !ctx.cr[6].gt {
	pc = 0x8219A678; continue 'dispatch;
	}
	// 8219A5E8: EFFEF828  fsubs f31, f30, f31
	ctx.f[31].f64 = (((ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 8219A5EC: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 8219A5F0: EC21F02A  fadds f1, f1, f30
	ctx.f[1].f64 = ((ctx.f[1].f64 + ctx.f[30].f64) as f32) as f64;
	// 8219A5F4: 481CD54D  bl 0x82367b40
	ctx.lr = 0x8219A5F8;
	sub_82367B40(ctx, base);
	// 8219A5F8: 48000080  b 0x8219a678
	pc = 0x8219A678; continue 'dispatch;
	// 8219A5FC: C3C10098  lfs f30, 0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8219A600: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8219A604: FC001210  fabs f0, f2
	ctx.f[0].u64 = ctx.f[2].u64 & !0x8000_0000_0000_0000u64;
	// 8219A608: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8219A60C: 40990050  ble cr6, 0x8219a65c
	if !ctx.cr[6].gt {
	pc = 0x8219A65C; continue 'dispatch;
	}
	// 8219A610: C0210094  lfs f1, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219A614: 48398895  bl 0x82532ea8
	ctx.lr = 0x8219A618;
	sub_82532EA8(ctx, base);
	// 8219A618: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A61C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8219A620: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 8219A624: C00B2254  lfs f0, 0x2254(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8788 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A628: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A62C: C18BBFFC  lfs f12, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219A630: EC2D603A  fmadds f1, f13, f0, f12
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8219A634: 481CD50D  bl 0x82367b40
	ctx.lr = 0x8219A638;
	sub_82367B40(ctx, base);
	// 8219A638: EFE16028  fsubs f31, f1, f12
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[1].f64 - ctx.f[12].f64) as f32) as f64);
	// 8219A63C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A640: C00B2038  lfs f0, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A644: FDA0FA10  fabs f13, f31
	ctx.f[13].u64 = ctx.f[31].u64 & !0x8000_0000_0000_0000u64;
	// 8219A648: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8219A64C: 40990008  ble cr6, 0x8219a654
	if !ctx.cr[6].gt {
	pc = 0x8219A654; continue 'dispatch;
	}
	// 8219A650: EFECF828  fsubs f31, f12, f31
	ctx.f[31].f64 = (((ctx.f[12].f64 - ctx.f[31].f64) as f32) as f64);
	// 8219A654: FC3E66AE  fsel f1, f30, f26, f12
	ctx.f[1].f64 = if ctx.f[30].f64 >= 0.0 { ctx.f[26].f64 } else { ctx.f[12].f64 };
	// 8219A658: 48000020  b 0x8219a678
	pc = 0x8219A678; continue 'dispatch;
	// 8219A65C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A660: C1810094  lfs f12, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219A664: FC20D090  fmr f1, f26
	ctx.f[1].f64 = ctx.f[26].f64;
	// 8219A668: C00B2038  lfs f0, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A66C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8219A670: C1ABD428  lfs f13, -0x2bd8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219A674: FFEC682E  fsel f31, f12, f0, f13
	ctx.f[31].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 8219A678: 396000B4  li r11, 0xb4
	ctx.r[11].s64 = 180;
	// 8219A67C: D3FF00DC  stfs f31, 0xdc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 8219A680: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219A684: D03F00E0  stfs f1, 0xe0(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8219A688: D35F0094  stfs f26, 0x94(r31)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8219A68C: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 8219A690: 915F0088  stw r10, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 8219A694: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 8219A698: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 8219A69C: 4839B991  bl 0x8253602c
	ctx.lr = 0x8219A6A0;
	sub_82535FFC(ctx, base);
	// 8219A6A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219A6A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219A6A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219A6AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219A6B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219A6B8 size=464
    let mut pc: u32 = 0x8219A6B8;
    'dispatch: loop {
        match pc {
            0x8219A6B8 => {
    //   block [0x8219A6B8..0x8219A888)
	// 8219A6B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219A6BC: 4839A9E5  bl 0x825350a0
	ctx.lr = 0x8219A6C0;
	sub_82535080(ctx, base);
	// 8219A6C0: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 8219A6C4: 4839B925  bl 0x82535fe8
	ctx.lr = 0x8219A6C8;
	sub_82535FB0(ctx, base);
	// 8219A6C8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219A6CC: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219A6D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219A6D4: 3ACBBFF0  addi r22, r11, -0x4010
	ctx.r[22].s64 = ctx.r[11].s64 + -16400;
	// 8219A6D8: 89760000  lbz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A6DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A6E0: 409A0198  bne cr6, 0x8219a878
	if !ctx.cr[6].eq {
	pc = 0x8219A878; continue 'dispatch;
	}
	// 8219A6E4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219A6E8: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 8219A6EC: 3B4B0AF4  addi r26, r11, 0xaf4
	ctx.r[26].s64 = ctx.r[11].s64 + 2804;
	// 8219A6F0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219A6F4: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8219A6F8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8219A6FC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219A700: C3C7BA38  lfs f30, -0x45c8(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8219A704: 3F8082C0  lis r28, -0x7d40
	ctx.r[28].s64 = -2101346304;
	// 8219A708: 3B0B09E4  addi r24, r11, 0x9e4
	ctx.r[24].s64 = ctx.r[11].s64 + 2532;
	// 8219A70C: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219A710: C3A82054  lfs f29, 0x2054(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8276 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8219A714: C3892280  lfs f28, 0x2280(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8832 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 8219A718: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8219A71C: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219A720: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 8219A724: 83BCB9D8  lwz r29, -0x4628(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 8219A728: 61797A9E  ori r25, r11, 0x7a9e
	ctx.r[25].u64 = ctx.r[11].u64 | 31390;
	// 8219A72C: C01E0094  lfs f0, 0x94(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A730: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8219A734: 4099001C  ble cr6, 0x8219a750
	if !ctx.cr[6].gt {
	pc = 0x8219A750; continue 'dispatch;
	}
	// 8219A738: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8219A73C: 616B85E0  ori r11, r11, 0x85e0
	ctx.r[11].u64 = ctx.r[11].u64 | 34272;
	// 8219A740: 7DB65C2E  lfsx f13, r22, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219A744: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8219A748: D01E0094  stfs f0, 0x94(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8219A74C: 48000104  b 0x8219a850
	pc = 0x8219A850; continue 'dispatch;
	// 8219A750: 481CC9E9  bl 0x82367138
	ctx.lr = 0x8219A754;
	sub_82367138(ctx, base);
	// 8219A754: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219A758: C1BE00E4  lfs f13, 0xe4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219A75C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8219A760: C19E0090  lfs f12, 0x90(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219A764: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 8219A768: C8010080  lfd f0, 0x80(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 8219A76C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8219A770: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219A774: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 8219A778: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8219A77C: D01E0094  stfs f0, 0x94(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8219A780: 419A00D0  beq cr6, 0x8219a850
	if ctx.cr[6].eq {
	pc = 0x8219A850; continue 'dispatch;
	}
	// 8219A784: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8219A788: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 8219A78C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219A790: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8219A794: 38600240  li r3, 0x240
	ctx.r[3].s64 = 576;
	// 8219A798: 481CFCF9  bl 0x8236a490
	ctx.lr = 0x8219A79C;
	sub_8236A490(ctx, base);
	// 8219A79C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219A7A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8219A7A4: 419A00A8  beq cr6, 0x8219a84c
	if ctx.cr[6].eq {
	pc = 0x8219A84C; continue 'dispatch;
	}
	// 8219A7A8: D3FF00B0  stfs f31, 0xb0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8219A7AC: D3FF00B4  stfs f31, 0xb4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 8219A7B0: D3FF00B8  stfs f31, 0xb8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 8219A7B4: D3DF00BC  stfs f30, 0xbc(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 8219A7B8: D3FF00A0  stfs f31, 0xa0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8219A7BC: D3FF00A4  stfs f31, 0xa4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8219A7C0: D3FF00A8  stfs f31, 0xa8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8219A7C4: D3DF00AC  stfs f30, 0xac(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8219A7C8: 937F00C0  stw r27, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[27].u32 ) };
	// 8219A7CC: D3FF00C4  stfs f31, 0xc4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8219A7D0: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 8219A7D4: B2FF0088  sth r23, 0x88(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[23].u16 ) };
	// 8219A7D8: 93BF0090  stw r29, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	// 8219A7DC: 937F0084  stw r27, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 8219A7E0: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219A7E4: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 8219A7E8: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219A7EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A7F0: 419A0008  beq cr6, 0x8219a7f8
	if ctx.cr[6].eq {
	pc = 0x8219A7F8; continue 'dispatch;
	}
	// 8219A7F4: 93EB0084  stw r31, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 8219A7F8: 397E00A0  addi r11, r30, 0xa0
	ctx.r[11].s64 = ctx.r[30].s64 + 160;
	// 8219A7FC: 93FD0080  stw r31, 0x80(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 8219A800: C15E00E0  lfs f10, 0xe0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(224 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219A804: 38DE00B0  addi r6, r30, 0xb0
	ctx.r[6].s64 = ctx.r[30].s64 + 176;
	// 8219A808: C13E00DC  lfs f9, 0xdc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(220 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8219A80C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219A810: C01E00D8  lfs f0, 0xd8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A814: 809E00D4  lwz r4, 0xd4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A818: C0BE00CC  lfs f5, 0xcc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(204 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 8219A81C: ED000772  fmuls f8, f0, f29
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 8219A820: C09E00C8  lfs f4, 0xc8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219A824: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8219A828: C07E00C4  lfs f3, 0xc4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(196 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8219A82C: FCE05090  fmr f7, f10
	ctx.f[7].f64 = ctx.f[10].f64;
	// 8219A830: C05E00C0  lfs f2, 0xc0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(192 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219A834: FCC04890  fmr f6, f9
	ctx.f[6].f64 = ctx.f[9].f64;
	// 8219A838: C03E00D0  lfs f1, 0xd0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219A83C: 4BFFE6D5  bl 0x82198f10
	ctx.lr = 0x8219A840;
	sub_82198F10(ctx, base);
	// 8219A840: 933F003C  stw r25, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[25].u32 ) };
	// 8219A844: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219A848: 917F01A8  stw r11, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[11].u32 ) };
	// 8219A84C: 83BCB9D8  lwz r29, -0x4628(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 8219A850: 817E0088  lwz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 8219A854: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A858: 40990018  ble cr6, 0x8219a870
	if !ctx.cr[6].gt {
	pc = 0x8219A870; continue 'dispatch;
	}
	// 8219A85C: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219A860: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 8219A864: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A868: 915E008C  stw r10, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 8219A86C: 409AFEC0  bne cr6, 0x8219a72c
	if !ctx.cr[6].eq {
	pc = 0x8219A72C; continue 'dispatch;
	}
	// 8219A870: 937E0088  stw r27, 0x88(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[27].u32 ) };
	// 8219A874: 937E008C  stw r27, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[27].u32 ) };
	// 8219A878: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 8219A87C: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 8219A880: 4839B7B5  bl 0x82536034
	ctx.lr = 0x8219A884;
	sub_82535FFC(ctx, base);
	// 8219A884: 4839A86C  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219A888 size=84
    let mut pc: u32 = 0x8219A888;
    'dispatch: loop {
        match pc {
            0x8219A888 => {
    //   block [0x8219A888..0x8219A8DC)
	// 8219A888: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219A88C: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 8219A890: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 8219A894: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 8219A898: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8219A89C: 40990018  ble cr6, 0x8219a8b4
	if !ctx.cr[6].gt {
	pc = 0x8219A8B4; continue 'dispatch;
	}
	// 8219A8A0: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8219A8A4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 8219A8A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219A8AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219A8B0: 41990008  bgt cr6, 0x8219a8b8
	if ctx.cr[6].gt {
	pc = 0x8219A8B8; continue 'dispatch;
	}
	// 8219A8B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219A8B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219A8BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A8C0: 419A001C  beq cr6, 0x8219a8dc
	if ctx.cr[6].eq {
		sub_8219A8DC(ctx, base);
		return;
	}
	// 8219A8C4: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219A8C8: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219A8CC: 396B1090  addi r11, r11, 0x1090
	ctx.r[11].s64 = ctx.r[11].s64 + 4240;
	// 8219A8D0: 396B00C8  addi r11, r11, 0xc8
	ctx.r[11].s64 = ctx.r[11].s64 + 200;
	// 8219A8D4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219A8D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A8DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219A8DC size=8
    let mut pc: u32 = 0x8219A8DC;
    'dispatch: loop {
        match pc {
            0x8219A8DC => {
    //   block [0x8219A8DC..0x8219A8E4)
	// 8219A8DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8219A8E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8219A8E8 size=496
    let mut pc: u32 = 0x8219A8E8;
    'dispatch: loop {
        match pc {
            0x8219A8E8 => {
    //   block [0x8219A8E8..0x8219A9C0)
	// 8219A8E8: 3963FFFC  addi r11, r3, -4
	ctx.r[11].s64 = ctx.r[3].s64 + -4;
	// 8219A8EC: 2B0B002C  cmplwi cr6, r11, 0x2c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 44 as u32, &mut ctx.xer);
	// 8219A8F0: 419901C0  bgt cr6, 0x8219aab0
	if ctx.cr[6].gt {
	pc = 0x8219AAB0; continue 'dispatch;
	}
	// 8219A8F4: 3D80821A  lis r12, -0x7de6
	ctx.r[12].s64 = -2112225280;
	// 8219A8F8: 398CA90C  addi r12, r12, -0x56f4
	ctx.r[12].s64 = ctx.r[12].s64 + -22260;
	// 8219A8FC: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8219A900: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8219A904: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8219A908: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x8219A9C0; continue 'dispatch;
		},
		1 => {
	pc = 0x8219A9C0; continue 'dispatch;
		},
		2 => {
	pc = 0x8219AA10; continue 'dispatch;
		},
		3 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		4 => {
	pc = 0x8219AA10; continue 'dispatch;
		},
		5 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		6 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		7 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		8 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		9 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		10 => {
	pc = 0x8219A9E8; continue 'dispatch;
		},
		11 => {
	pc = 0x8219AA10; continue 'dispatch;
		},
		12 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		13 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		14 => {
	pc = 0x8219AA38; continue 'dispatch;
		},
		15 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		16 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		17 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		18 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		19 => {
	pc = 0x8219A9E8; continue 'dispatch;
		},
		20 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		21 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		22 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		23 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		24 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		25 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		26 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		27 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		28 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		29 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		30 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		31 => {
	pc = 0x8219AA10; continue 'dispatch;
		},
		32 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		33 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		34 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		35 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		36 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		37 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		38 => {
	pc = 0x8219AA60; continue 'dispatch;
		},
		39 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		40 => {
	pc = 0x8219AA88; continue 'dispatch;
		},
		41 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		42 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		43 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		44 => {
	pc = 0x8219AA10; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8219A90C: 8219A9C0  lwz r16, -0x5640(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-22080 as u32) ) } as u64;
	// 8219A910: 8219A9C0  lwz r16, -0x5640(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-22080 as u32) ) } as u64;
	// 8219A914: 8219AA10  lwz r16, -0x55f0(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-22000 as u32) ) } as u64;
	// 8219A918: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A91C: 8219AA10  lwz r16, -0x55f0(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-22000 as u32) ) } as u64;
	// 8219A920: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A924: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A928: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A92C: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A930: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A934: 8219A9E8  lwz r16, -0x5618(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-22040 as u32) ) } as u64;
	// 8219A938: 8219AA10  lwz r16, -0x55f0(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-22000 as u32) ) } as u64;
	// 8219A93C: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A940: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A944: 8219AA38  lwz r16, -0x55c8(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21960 as u32) ) } as u64;
	// 8219A948: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A94C: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A950: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A954: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A958: 8219A9E8  lwz r16, -0x5618(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-22040 as u32) ) } as u64;
	// 8219A95C: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A960: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A964: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A968: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A96C: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A970: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A974: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A978: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A97C: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A980: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A984: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A988: 8219AA10  lwz r16, -0x55f0(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-22000 as u32) ) } as u64;
	// 8219A98C: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A990: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A994: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A998: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A99C: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A9A0: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A9A4: 8219AA60  lwz r16, -0x55a0(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21920 as u32) ) } as u64;
	// 8219A9A8: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A9AC: 8219AA88  lwz r16, -0x5578(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21880 as u32) ) } as u64;
	// 8219A9B0: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A9B4: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A9B8: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A9BC: 8219AA10  lwz r16, -0x55f0(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-22000 as u32) ) } as u64;
            }
            0x8219A9C0 => {
    //   block [0x8219A9C0..0x8219A9E8)
	// 8219A9C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A9C4: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8219A9C8: C00B21C0  lfs f0, 0x21c0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8640 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A9CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A9D0: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8219A9D4: C00B21BC  lfs f0, 0x21bc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8636 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A9D8: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219A9DC: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8219A9E0: 7C2B542E  lfsx f1, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219A9E4: 4E800020  blr
	return;
            }
            0x8219A9E8 => {
    //   block [0x8219A9E8..0x8219AA10)
	// 8219A9E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A9EC: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8219A9F0: C00B21B8  lfs f0, 0x21b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8632 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A9F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A9F8: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8219A9FC: C00B21B4  lfs f0, 0x21b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8628 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AA00: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AA04: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8219AA08: 7C2B542E  lfsx f1, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219AA0C: 4E800020  blr
	return;
            }
            0x8219AA10 => {
    //   block [0x8219AA10..0x8219AA38)
	// 8219AA10: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AA14: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8219AA18: C00B21B4  lfs f0, 0x21b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8628 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AA1C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AA20: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8219AA24: C00B2098  lfs f0, 0x2098(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AA28: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AA2C: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8219AA30: 7C2B542E  lfsx f1, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219AA34: 4E800020  blr
	return;
            }
            0x8219AA38 => {
    //   block [0x8219AA38..0x8219AA60)
	// 8219AA38: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AA3C: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8219AA40: C00B2098  lfs f0, 0x2098(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AA44: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AA48: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8219AA4C: C00B21B0  lfs f0, 0x21b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8624 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AA50: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AA54: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8219AA58: 7C2B542E  lfsx f1, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219AA5C: 4E800020  blr
	return;
            }
            0x8219AA60 => {
    //   block [0x8219AA60..0x8219AA88)
	// 8219AA60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AA64: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8219AA68: C00B21AC  lfs f0, 0x21ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8620 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AA6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AA70: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8219AA74: C00B21A8  lfs f0, 0x21a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8616 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AA78: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AA7C: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8219AA80: 7C2B542E  lfsx f1, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219AA84: 4E800020  blr
	return;
            }
            0x8219AA88 => {
    //   block [0x8219AA88..0x8219AAB0)
	// 8219AA88: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AA8C: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8219AA90: C00B21A8  lfs f0, 0x21a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8616 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AA94: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AA98: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8219AA9C: C00B21A4  lfs f0, 0x21a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8612 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AAA0: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AAA4: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8219AAA8: 7C2B542E  lfsx f1, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219AAAC: 4E800020  blr
	return;
            }
            0x8219AAB0 => {
    //   block [0x8219AAB0..0x8219AAD8)
	// 8219AAB0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AAB4: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8219AAB8: C00B21A0  lfs f0, 0x21a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8608 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AABC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AAC0: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8219AAC4: C00B21AC  lfs f0, 0x21ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8620 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AAC8: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AACC: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8219AAD0: 7C2B542E  lfsx f1, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219AAD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219AAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219AAD8 size=364
    let mut pc: u32 = 0x8219AAD8;
    'dispatch: loop {
        match pc {
            0x8219AAD8 => {
    //   block [0x8219AAD8..0x8219AC44)
	// 8219AAD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219AADC: 4839A5AD  bl 0x82535088
	ctx.lr = 0x8219AAE0;
	sub_82535080(ctx, base);
	// 8219AAE0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219AAE4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219AAE8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8219AAEC: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 8219AAF0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219AAF4: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 8219AAF8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8219AAFC: 3AA0000F  li r21, 0xf
	ctx.r[21].s64 = 15;
	// 8219AB00: 7FDD50AE  lbzx r30, r29, r10
	ctx.r[30].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219AB04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219AB08: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AB0C: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219AB10: 57C3183E  rotlwi r3, r30, 3
	ctx.r[3].u64 = ((ctx.r[30].u32).rotate_left(3)) as u64;
	// 8219AB14: 3BEB1090  addi r31, r11, 0x1090
	ctx.r[31].s64 = ctx.r[11].s64 + 4240;
	// 8219AB18: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219AB1C: 393F0090  addi r9, r31, 0x90
	ctx.r[9].s64 = ctx.r[31].s64 + 144;
	// 8219AB20: 61668414  ori r6, r11, 0x8414
	ctx.r[6].u64 = ctx.r[11].u64 | 33812;
	// 8219AB24: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219AB28: 391F00B0  addi r8, r31, 0xb0
	ctx.r[8].s64 = ctx.r[31].s64 + 176;
	// 8219AB2C: 61658410  ori r5, r11, 0x8410
	ctx.r[5].u64 = ctx.r[11].u64 | 33808;
	// 8219AB30: 57CB183E  rotlwi r11, r30, 3
	ctx.r[11].u64 = ((ctx.r[30].u32).rotate_left(3)) as u64;
	// 8219AB34: 7D43492E  stwx r10, r3, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 8219AB38: 57D3103E  rotlwi r19, r30, 2
	ctx.r[19].u64 = ((ctx.r[30].u32).rotate_left(2)) as u64;
	// 8219AB3C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 8219AB40: 3B1F00B8  addi r24, r31, 0xb8
	ctx.r[24].s64 = ctx.r[31].s64 + 184;
	// 8219AB44: 57D2183E  rotlwi r18, r30, 3
	ctx.r[18].u64 = ((ctx.r[30].u32).rotate_left(3)) as u64;
	// 8219AB48: 3B3F00C8  addi r25, r31, 0xc8
	ctx.r[25].s64 = ctx.r[31].s64 + 200;
	// 8219AB4C: 3AFF0104  addi r23, r31, 0x104
	ctx.r[23].s64 = ctx.r[31].s64 + 260;
	// 8219AB50: 914B0094  stw r10, 0x94(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 8219AB54: 3ADF00D0  addi r22, r31, 0xd0
	ctx.r[22].s64 = ctx.r[31].s64 + 208;
	// 8219AB58: 3A9F00D8  addi r20, r31, 0xd8
	ctx.r[20].s64 = ctx.r[31].s64 + 216;
	// 8219AB5C: 7CF3412E  stwx r7, r19, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[19].u32.wrapping_add(ctx.r[8].u32), ctx.r[7].u32) };
	// 8219AB60: 57DA103E  rotlwi r26, r30, 2
	ctx.r[26].u64 = ((ctx.r[30].u32).rotate_left(2)) as u64;
	// 8219AB64: 7DBD342E  lfsx f13, r29, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219AB68: 57D1103E  rotlwi r17, r30, 2
	ctx.r[17].u64 = ((ctx.r[30].u32).rotate_left(2)) as u64;
	// 8219AB6C: D1AB00BC  stfs f13, 0xbc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 8219AB70: 57D0103E  rotlwi r16, r30, 2
	ctx.r[16].u64 = ((ctx.r[30].u32).rotate_left(2)) as u64;
	// 8219AB74: 7DBD2C2E  lfsx f13, r29, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219AB78: 57C9103E  rotlwi r9, r30, 2
	ctx.r[9].u64 = ((ctx.r[30].u32).rotate_left(2)) as u64;
	// 8219AB7C: 7DB2C52E  stfsx f13, r18, r24
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[18].u32.wrapping_add(ctx.r[24].u32), tmp.u32) };
	// 8219AB80: 3B7D0030  addi r27, r29, 0x30
	ctx.r[27].s64 = ctx.r[29].s64 + 48;
	// 8219AB84: 7F9AC92E  stwx r28, r26, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32), ctx.r[28].u32) };
	// 8219AB88: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 8219AB8C: 7C11BD2E  stfsx f0, r17, r23
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[17].u32.wrapping_add(ctx.r[23].u32), tmp.u32) };
	// 8219AB90: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219AB94: 7EB0B12E  stwx r21, r16, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[16].u32.wrapping_add(ctx.r[22].u32), ctx.r[21].u32) };
	// 8219AB98: 7F89A12E  stwx r28, r9, r20
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[20].u32), ctx.r[28].u32) };
	// 8219AB9C: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219ABA0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219ABA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219ABA8: 4E800421  bctrl
	ctx.lr = 0x8219ABAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219ABAC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219ABB0: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 8219ABB4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219ABB8: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219ABBC: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219ABC0: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219ABC4: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8219ABC8: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219ABCC: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219ABD0: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219ABD4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219ABD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219ABDC: 4E800421  bctrl
	ctx.lr = 0x8219ABE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219ABE0: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219ABE4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219ABE8: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219ABEC: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219ABF0: 395F00E0  addi r10, r31, 0xe0
	ctx.r[10].s64 = ctx.r[31].s64 + 224;
	// 8219ABF4: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219ABF8: 393F00E4  addi r9, r31, 0xe4
	ctx.r[9].s64 = ctx.r[31].s64 + 228;
	// 8219ABFC: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AC00: 57C8103E  rotlwi r8, r30, 2
	ctx.r[8].u64 = ((ctx.r[30].u32).rotate_left(2)) as u64;
	// 8219AC04: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219AC08: 7F9AC92E  stwx r28, r26, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32), ctx.r[28].u32) };
	// 8219AC0C: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AC10: 57CB103E  rotlwi r11, r30, 2
	ctx.r[11].u64 = ((ctx.r[30].u32).rotate_left(2)) as u64;
	// 8219AC14: 7F9E51AE  stbx r28, r30, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32), ctx.r[28].u8) };
	// 8219AC18: 38FF00EC  addi r7, r31, 0xec
	ctx.r[7].s64 = ctx.r[31].s64 + 236;
	// 8219AC1C: 57CA103E  rotlwi r10, r30, 2
	ctx.r[10].u64 = ((ctx.r[30].u32).rotate_left(2)) as u64;
	// 8219AC20: 38DF00F4  addi r6, r31, 0xf4
	ctx.r[6].s64 = ctx.r[31].s64 + 244;
	// 8219AC24: 7C0B4D2E  stfsx f0, r11, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 8219AC28: 57CB103E  rotlwi r11, r30, 2
	ctx.r[11].u64 = ((ctx.r[30].u32).rotate_left(2)) as u64;
	// 8219AC2C: 7F88392E  stwx r28, r8, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32), ctx.r[28].u32) };
	// 8219AC30: 393F00FC  addi r9, r31, 0xfc
	ctx.r[9].s64 = ctx.r[31].s64 + 252;
	// 8219AC34: 7F8A312E  stwx r28, r10, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32), ctx.r[28].u32) };
	// 8219AC38: 7F8B492E  stwx r28, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[28].u32) };
	// 8219AC3C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8219AC40: 4839A498  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219AC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219AC48 size=396
    let mut pc: u32 = 0x8219AC48;
    'dispatch: loop {
        match pc {
            0x8219AC48 => {
    //   block [0x8219AC48..0x8219ADD4)
	// 8219AC48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219AC4C: 4839A465  bl 0x825350b0
	ctx.lr = 0x8219AC50;
	sub_82535080(ctx, base);
	// 8219AC50: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 8219AC54: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219AC58: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219AC5C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8219AC60: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 8219AC64: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219AC68: 3B9F0030  addi r28, r31, 0x30
	ctx.r[28].s64 = ctx.r[31].s64 + 48;
	// 8219AC6C: 3BAB1090  addi r29, r11, 0x1090
	ctx.r[29].s64 = ctx.r[11].s64 + 4240;
	// 8219AC70: 813F0030  lwz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219AC74: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 8219AC78: 7F7F50AE  lbzx r27, r31, r10
	ctx.r[27].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219AC7C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8219AC80: 576B183E  rotlwi r11, r27, 3
	ctx.r[11].u64 = ((ctx.r[27].u32).rotate_left(3)) as u64;
	// 8219AC84: 7FCBEA14  add r30, r11, r29
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8219AC88: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219AC8C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219AC90: C1BE00BC  lfs f13, 0xbc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219AC94: C00BD210  lfs f0, -0x2df0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AC98: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219AC9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219ACA0: 4E800421  bctrl
	ctx.lr = 0x8219ACA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219ACA4: 3F5F0002  addis r26, r31, 2
	ctx.r[26].s64 = ctx.r[31].s64 + 131072;
	// 8219ACA8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219ACAC: 3B5A9B84  addi r26, r26, -0x647c
	ctx.r[26].s64 = ctx.r[26].s64 + -25724;
	// 8219ACB0: 576A183E  rotlwi r10, r27, 3
	ctx.r[10].u64 = ((ctx.r[27].u32).rotate_left(3)) as u64;
	// 8219ACB4: 393D0080  addi r9, r29, 0x80
	ctx.r[9].s64 = ctx.r[29].s64 + 128;
	// 8219ACB8: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 8219ACBC: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219ACC0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8219ACC4: C1BA0000  lfs f13, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219ACC8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8219ACCC: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 8219ACD0: 7C0A4D2E  stfsx f0, r10, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 8219ACD4: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219ACD8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219ACDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219ACE0: 4E800421  bctrl
	ctx.lr = 0x8219ACE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219ACE4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219ACE8: C01A0000  lfs f0, 0(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219ACEC: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 8219ACF0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8219ACF4: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219ACF8: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219ACFC: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 8219AD00: D01E0084  stfs f0, 0x84(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8219AD04: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219AD08: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219AD0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219AD10: 4E800421  bctrl
	ctx.lr = 0x8219AD14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219AD14: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219AD18: 576A283E  rotlwi r10, r27, 5
	ctx.r[10].u64 = ((ctx.r[27].u32).rotate_left(5)) as u64;
	// 8219AD1C: 5769283E  rotlwi r9, r27, 5
	ctx.r[9].u64 = ((ctx.r[27].u32).rotate_left(5)) as u64;
	// 8219AD20: 7FCAEA14  add r30, r10, r29
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 8219AD24: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8219AD28: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AD2C: 391D0040  addi r8, r29, 0x40
	ctx.r[8].s64 = ctx.r[29].s64 + 64;
	// 8219AD30: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8219AD34: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 8219AD38: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AD3C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8219AD40: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8219AD44: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AD48: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8219AD4C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219ADD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219ADD8 size=204
    let mut pc: u32 = 0x8219ADD8;
    'dispatch: loop {
        match pc {
            0x8219ADD8 => {
    //   block [0x8219ADD8..0x8219AEA4)
	// 8219ADD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219ADDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219ADE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219ADE4: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219ADE8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8219ADEC: 6148BE64  ori r8, r10, 0xbe64
	ctx.r[8].u64 = ctx.r[10].u64 | 48740;
	// 8219ADF0: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219ADF4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219ADF8: 6146BEBA  ori r6, r10, 0xbeba
	ctx.r[6].u64 = ctx.r[10].u64 | 48826;
	// 8219ADFC: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 8219AE00: 7D0B40AE  lbzx r8, r11, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8219AE04: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219AE08: 392A1090  addi r9, r10, 0x1090
	ctx.r[9].s64 = ctx.r[10].s64 + 4240;
	// 8219AE0C: 7C6B322E  lhzx r3, r11, r6
	ctx.r[3].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 8219AE10: 550B083E  rotlwi r11, r8, 1
	ctx.r[11].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 8219AE14: 39490080  addi r10, r9, 0x80
	ctx.r[10].s64 = ctx.r[9].s64 + 128;
	// 8219AE18: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 8219AE1C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AE20: 7DAB542E  lfsx f13, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219AE24: 4BFFFAC5  bl 0x8219a8e8
	ctx.lr = 0x8219AE28;
	sub_8219A8E8(ctx, base);
	// 8219AE28: FF0D0800  fcmpu cr6, f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[1].f64);
	// 8219AE2C: 4099002C  ble cr6, 0x8219ae58
	if !ctx.cr[6].gt {
	pc = 0x8219AE58; continue 'dispatch;
	}
	// 8219AE30: 550B083C  slwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AE34: 39490090  addi r10, r9, 0x90
	ctx.r[10].s64 = ctx.r[9].s64 + 144;
	// 8219AE38: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 8219AE3C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AE40: 7D2B502E  lwzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219AE44: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 8219AE48: 409A0008  bne cr6, 0x8219ae50
	if !ctx.cr[6].eq {
	pc = 0x8219AE50; continue 'dispatch;
	}
	// 8219AE4C: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8219AE50: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 8219AE54: 48000038  b 0x8219ae8c
	pc = 0x8219AE8C; continue 'dispatch;
	// 8219AE58: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8219AE5C: 4BFFFA8D  bl 0x8219a8e8
	ctx.lr = 0x8219AE60;
	sub_8219A8E8(ctx, base);
	// 8219AE60: FF0D0800  fcmpu cr6, f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[1].f64);
	// 8219AE64: 4098002C  bge cr6, 0x8219ae90
	if !ctx.cr[6].lt {
	pc = 0x8219AE90; continue 'dispatch;
	}
	// 8219AE68: 550B083C  slwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AE6C: 39490090  addi r10, r9, 0x90
	ctx.r[10].s64 = ctx.r[9].s64 + 144;
	// 8219AE70: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 8219AE74: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AE78: 7D2B502E  lwzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219AE7C: 2F090004  cmpwi cr6, r9, 4
	ctx.cr[6].compare_i32(ctx.r[9].s32, 4, &mut ctx.xer);
	// 8219AE80: 409A0008  bne cr6, 0x8219ae88
	if !ctx.cr[6].eq {
	pc = 0x8219AE88; continue 'dispatch;
	}
	// 8219AE84: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 8219AE88: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8219AE8C: 7D2B512E  stwx r9, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 8219AE90: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 8219AE94: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219AE98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219AE9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219AEA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219AEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219AEA8 size=252
    let mut pc: u32 = 0x8219AEA8;
    'dispatch: loop {
        match pc {
            0x8219AEA8 => {
    //   block [0x8219AEA8..0x8219AFA4)
	// 8219AEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219AEAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219AEB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219AEB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219AEB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219AEBC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8219AEC0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8219AEC4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8219AEC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219AECC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219AED0: 4801CAF9  bl 0x821b79c8
	ctx.lr = 0x8219AED4;
	sub_821B79C8(ctx, base);
	// 8219AED4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219AED8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219AEDC: C0410068  lfs f2, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219AEE0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8219AEE4: C0210060  lfs f1, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219AEE8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8219AEEC: 4801C645  bl 0x821b7530
	ctx.lr = 0x8219AEF0;
	sub_821B7530(ctx, base);
	// 8219AEF0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AEF4: C00B2954  lfs f0, 0x2954(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10580 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AEF8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8219AEFC: 40990044  ble cr6, 0x8219af40
	if !ctx.cr[6].gt {
	pc = 0x8219AF40; continue 'dispatch;
	}
	// 8219AF00: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8219AF04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219AF08: 419A0038  beq cr6, 0x8219af40
	if ctx.cr[6].eq {
	pc = 0x8219AF40; continue 'dispatch;
	}
	// 8219AF0C: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219AF10: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219AF14: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8219AF18: 419A0020  beq cr6, 0x8219af38
	if ctx.cr[6].eq {
	pc = 0x8219AF38; continue 'dispatch;
	}
	// 8219AF1C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 8219AF20: 419A0010  beq cr6, 0x8219af30
	if ctx.cr[6].eq {
	pc = 0x8219AF30; continue 'dispatch;
	}
	// 8219AF24: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219AF28: 556BE63E  rlwinm r11, r11, 0x1c, 0x18, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 8219AF2C: 48000018  b 0x8219af44
	pc = 0x8219AF44; continue 'dispatch;
	// 8219AF30: 3960003C  li r11, 0x3c
	ctx.r[11].s64 = 60;
	// 8219AF34: 48000010  b 0x8219af44
	pc = 0x8219AF44; continue 'dispatch;
	// 8219AF38: 3960003A  li r11, 0x3a
	ctx.r[11].s64 = 58;
	// 8219AF3C: 48000008  b 0x8219af44
	pc = 0x8219AF44; continue 'dispatch;
	// 8219AF40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219AF44: 2F1E0011  cmpwi cr6, r30, 0x11
	ctx.cr[6].compare_i32(ctx.r[30].s32, 17, &mut ctx.xer);
	// 8219AF48: 419A0024  beq cr6, 0x8219af6c
	if ctx.cr[6].eq {
	pc = 0x8219AF6C; continue 'dispatch;
	}
	// 8219AF4C: 2F1E0015  cmpwi cr6, r30, 0x15
	ctx.cr[6].compare_i32(ctx.r[30].s32, 21, &mut ctx.xer);
	// 8219AF50: 409A003C  bne cr6, 0x8219af8c
	if !ctx.cr[6].eq {
	pc = 0x8219AF8C; continue 'dispatch;
	}
	// 8219AF54: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219AF58: 6149BE64  ori r9, r10, 0xbe64
	ctx.r[9].u64 = ctx.r[10].u64 | 48740;
	// 8219AF5C: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 8219AF60: 394A1090  addi r10, r10, 0x1090
	ctx.r[10].s64 = ctx.r[10].s64 + 4240;
	// 8219AF64: 394A00A0  addi r10, r10, 0xa0
	ctx.r[10].s64 = ctx.r[10].s64 + 160;
	// 8219AF68: 48000018  b 0x8219af80
	pc = 0x8219AF80; continue 'dispatch;
	// 8219AF6C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219AF70: 6149BE64  ori r9, r10, 0xbe64
	ctx.r[9].u64 = ctx.r[10].u64 | 48740;
	// 8219AF74: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 8219AF78: 394A1090  addi r10, r10, 0x1090
	ctx.r[10].s64 = ctx.r[10].s64 + 4240;
	// 8219AF7C: 394A00A4  addi r10, r10, 0xa4
	ctx.r[10].s64 = ctx.r[10].s64 + 164;
	// 8219AF80: 7D3F48AE  lbzx r9, r31, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8219AF84: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 8219AF88: 7D69512E  stwx r11, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 8219AF8C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219AF90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219AF94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219AF98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219AF9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219AFA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219AFA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219AFA8 size=996
    let mut pc: u32 = 0x8219AFA8;
    'dispatch: loop {
        match pc {
            0x8219AFA8 => {
    //   block [0x8219AFA8..0x8219B38C)
	// 8219AFA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219AFAC: 4839A0E1  bl 0x8253508c
	ctx.lr = 0x8219AFB0;
	sub_82535080(ctx, base);
	// 8219AFB0: DBC1FF70  stfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[30].u64 ) };
	// 8219AFB4: DBE1FF78  stfd f31, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 8219AFB8: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219AFBC: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219AFC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8219AFC4: 3A4BBFF0  addi r18, r11, -0x4010
	ctx.r[18].s64 = ctx.r[11].s64 + -16400;
	// 8219AFC8: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8219AFCC: 616B9450  ori r11, r11, 0x9450
	ctx.r[11].u64 = ctx.r[11].u64 | 37968;
	// 8219AFD0: 7D725A2E  lhzx r11, r18, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[18].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219AFD4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8219AFD8: 419A03A4  beq cr6, 0x8219b37c
	if ctx.cr[6].eq {
	pc = 0x8219B37C; continue 'dispatch;
	}
	// 8219AFDC: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219AFE0: 38A00015  li r5, 0x15
	ctx.r[5].s64 = 21;
	// 8219AFE4: 3B6B1090  addi r27, r11, 0x1090
	ctx.r[27].s64 = ctx.r[11].s64 + 4240;
	// 8219AFE8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219AFEC: 4BFFFEBD  bl 0x8219aea8
	ctx.lr = 0x8219AFF0;
	sub_8219AEA8(ctx, base);
	// 8219AFF0: 38A00011  li r5, 0x11
	ctx.r[5].s64 = 17;
	// 8219AFF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219AFF8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219AFFC: 4BFFFEAD  bl 0x8219aea8
	ctx.lr = 0x8219B000;
	sub_8219AEA8(ctx, base);
	// 8219B000: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219B004: 3BDF0030  addi r30, r31, 0x30
	ctx.r[30].s64 = ctx.r[31].s64 + 48;
	// 8219B008: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 8219B00C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219B010: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219B014: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219B018: 4E800421  bctrl
	ctx.lr = 0x8219B01C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219B01C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219B020: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 8219B024: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219B028: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219B02C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219B030: 4E800421  bctrl
	ctx.lr = 0x8219B034;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219B034: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219B038: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 8219B03C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219B040: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219B044: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219B048: 4E800421  bctrl
	ctx.lr = 0x8219B04C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219B04C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219B050: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8219B054: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219B058: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219B05C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219B060: 4E800421  bctrl
	ctx.lr = 0x8219B064;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219B064: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219B068: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219B06C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8219B070: 616B8410  ori r11, r11, 0x8410
	ctx.r[11].u64 = ctx.r[11].u64 | 33808;
	// 8219B074: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219B078: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219B07C: 7C1F5C2E  lfsx f0, r31, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219B080: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219B084: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8219B088: C3CB1FF8  lfs f30, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8219B08C: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8219B090: EDA007B2  fmuls f13, f0, f30
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8219B094: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8219B098: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8219B09C: C18BD4DC  lfs f12, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219B0A0: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 8219B0A4: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8219B0A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219B0AC: 4E800421  bctrl
	ctx.lr = 0x8219B0B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219B0B0: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8219B0B4: 80FF0030  lwz r7, 0x30(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219B0B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219B0BC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219B0C0: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 8219B0C4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219B390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219B390 size=408
    let mut pc: u32 = 0x8219B390;
    'dispatch: loop {
        match pc {
            0x8219B390 => {
    //   block [0x8219B390..0x8219B528)
	// 8219B390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219B394: 48399D01  bl 0x82535094
	ctx.lr = 0x8219B398;
	sub_82535080(ctx, base);
	// 8219B398: DBC1FF80  stfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[30].u64 ) };
	// 8219B39C: DBE1FF88  stfd f31, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 8219B3A0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219B3A4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219B3A8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8219B3AC: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 8219B3B0: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219B3B4: 3A600001  li r19, 1
	ctx.r[19].s64 = 1;
	// 8219B3B8: 3B6B1090  addi r27, r11, 0x1090
	ctx.r[27].s64 = ctx.r[11].s64 + 4240;
	// 8219B3BC: 39600011  li r11, 0x11
	ctx.r[11].s64 = 17;
	// 8219B3C0: 7FBC50AE  lbzx r29, r28, r10
	ctx.r[29].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219B3C4: 3A9B00E4  addi r20, r27, 0xe4
	ctx.r[20].s64 = ctx.r[27].s64 + 228;
	// 8219B3C8: 57B5103E  rotlwi r21, r29, 2
	ctx.r[21].u64 = ((ctx.r[29].u32).rotate_left(2)) as u64;
	// 8219B3CC: 9261005C  stw r19, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[19].u32 ) };
	// 8219B3D0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8219B3D4: 39600015  li r11, 0x15
	ctx.r[11].s64 = 21;
	// 8219B3D8: 7DB5A42E  lfsx f13, r21, r20
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[20].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219B3DC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8219B3E0: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8219B3E4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8219B3E8: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 8219B3EC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8219B3F0: 3960000D  li r11, 0xd
	ctx.r[11].s64 = 13;
	// 8219B3F4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8219B3F8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219B3FC: C00BD218  lfs f0, -0x2de8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219B400: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219B404: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8219B408: C3CB1FF8  lfs f30, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8219B40C: 409900C0  ble cr6, 0x8219b4cc
	if !ctx.cr[6].gt {
	pc = 0x8219B4CC; continue 'dispatch;
	}
	// 8219B410: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219B414: 616BEB34  ori r11, r11, 0xeb34
	ctx.r[11].u64 = ctx.r[11].u64 | 60212;
	// 8219B418: 7D7C58AE  lbzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219B41C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B420: 409A00AC  bne cr6, 0x8219b4cc
	if !ctx.cr[6].eq {
	pc = 0x8219B4CC; continue 'dispatch;
	}
	// 8219B424: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219B428: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219B42C: 57B8103A  slwi r24, r29, 2
	ctx.r[24].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[24].u64 = ctx.r[24].u32 as u64;
	// 8219B430: 3B410050  addi r26, r1, 0x50
	ctx.r[26].s64 = ctx.r[1].s64 + 80;
	// 8219B434: 3AFB00B0  addi r23, r27, 0xb0
	ctx.r[23].s64 = ctx.r[27].s64 + 176;
	// 8219B438: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219B43C: 3B200006  li r25, 6
	ctx.r[25].s64 = 6;
	// 8219B440: 6156BEBA  ori r22, r10, 0xbeba
	ctx.r[22].u64 = ctx.r[10].u64 | 48826;
	// 8219B444: 7D78B82E  lwzx r11, r24, r23
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 8219B448: 83DA0000  lwz r30, 0(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219B44C: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 8219B450: 419A0020  beq cr6, 0x8219b470
	if ctx.cr[6].eq {
	pc = 0x8219B470; continue 'dispatch;
	}
	// 8219B454: 7D7CB22E  lhzx r11, r28, r22
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 8219B458: 2B0B0029  cmplwi cr6, r11, 0x29
	ctx.cr[6].compare_u32(ctx.r[11].u32, 41 as u32, &mut ctx.xer);
	// 8219B45C: 419A0048  beq cr6, 0x8219b4a4
	if ctx.cr[6].eq {
	pc = 0x8219B4A4; continue 'dispatch;
	}
	// 8219B460: 2F1E0015  cmpwi cr6, r30, 0x15
	ctx.cr[6].compare_i32(ctx.r[30].s32, 21, &mut ctx.xer);
	// 8219B464: 419A000C  beq cr6, 0x8219b470
	if ctx.cr[6].eq {
	pc = 0x8219B470; continue 'dispatch;
	}
	// 8219B468: 2F1E0011  cmpwi cr6, r30, 0x11
	ctx.cr[6].compare_i32(ctx.r[30].s32, 17, &mut ctx.xer);
	// 8219B46C: 409A0038  bne cr6, 0x8219b4a4
	if !ctx.cr[6].eq {
	pc = 0x8219B4A4; continue 'dispatch;
	}
	// 8219B470: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219B474: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219B478: 395B00A0  addi r10, r27, 0xa0
	ctx.r[10].s64 = ctx.r[27].s64 + 160;
	// 8219B47C: 7FC40734  extsh r4, r30
	ctx.r[4].s64 = ctx.r[30].s16 as i64;
	// 8219B480: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8219B484: 7FEB502E  lwzx r31, r11, r10
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219B488: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8219B48C: 4814C525  bl 0x822e79b0
	ctx.lr = 0x8219B490;
	sub_822E79B0(ctx, base);
	// 8219B490: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8219B494: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219B498: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219B49C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8219B4A0: 48000A41  bl 0x8219bee0
	ctx.lr = 0x8219B4A4;
	sub_8219BEE0(ctx, base);
	// 8219B4A4: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 8219B4A8: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 8219B4AC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8219B4B0: 409AFF94  bne cr6, 0x8219b444
	if !ctx.cr[6].eq {
	pc = 0x8219B444; continue 'dispatch;
	}
	// 8219B4B4: 397B00E0  addi r11, r27, 0xe0
	ctx.r[11].s64 = ctx.r[27].s64 + 224;
	// 8219B4B8: 7D5D58AE  lbzx r10, r29, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219B4BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219B4C0: 409A0008  bne cr6, 0x8219b4c8
	if !ctx.cr[6].eq {
	pc = 0x8219B4C8; continue 'dispatch;
	}
	// 8219B4C4: 7E7D59AE  stbx r19, r29, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32), ctx.r[19].u8) };
	// 8219B4C8: 7FD5A52E  stfsx f30, r21, r20
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[21].u32.wrapping_add(ctx.r[20].u32), tmp.u32) };
	// 8219B4CC: 3D5C0006  addis r10, r28, 6
	ctx.r[10].s64 = ctx.r[28].s64 + 393216;
	// 8219B4D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219B4D4: 394A9238  addi r10, r10, -0x6dc8
	ctx.r[10].s64 = ctx.r[10].s64 + -28104;
	// 8219B4D8: C00B20B0  lfs f0, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219B4DC: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219B4E0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8219B4E4: 40980020  bge cr6, 0x8219b504
	if !ctx.cr[6].lt {
	pc = 0x8219B504; continue 'dispatch;
	}
	// 8219B4E8: 397B00E0  addi r11, r27, 0xe0
	ctx.r[11].s64 = ctx.r[27].s64 + 224;
	// 8219B4EC: 7D3D58AE  lbzx r9, r29, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219B4F0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219B4F4: 419A0010  beq cr6, 0x8219b504
	if ctx.cr[6].eq {
	pc = 0x8219B504; continue 'dispatch;
	}
	// 8219B4F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219B4FC: 7D3D59AE  stbx r9, r29, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 8219B500: 7FD5A52E  stfsx f30, r21, r20
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[21].u32.wrapping_add(ctx.r[20].u32), tmp.u32) };
	// 8219B504: 7C15A42E  lfsx f0, r21, r20
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[20].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219B508: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219B50C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8219B510: 7C15A52E  stfsx f0, r21, r20
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[21].u32.wrapping_add(ctx.r[20].u32), tmp.u32) };
	// 8219B514: D3CA0000  stfs f30, 0(r10)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219B518: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 8219B51C: CBC1FF80  lfd f30, -0x80(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 8219B520: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 8219B524: 48399BC0  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219B528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219B528 size=736
    let mut pc: u32 = 0x8219B528;
    'dispatch: loop {
        match pc {
            0x8219B528 => {
    //   block [0x8219B528..0x8219B808)
	// 8219B528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219B52C: 48399B79  bl 0x825350a4
	ctx.lr = 0x8219B530;
	sub_82535080(ctx, base);
	// 8219B530: DBC1FFA0  stfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 8219B534: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 8219B538: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219B53C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219B540: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219B544: 616BEB1B  ori r11, r11, 0xeb1b
	ctx.r[11].u64 = ctx.r[11].u64 | 60187;
	// 8219B548: 614ABE64  ori r10, r10, 0xbe64
	ctx.r[10].u64 = ctx.r[10].u64 | 48740;
	// 8219B54C: 7D6458AE  lbzx r11, r4, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219B550: 7F0450AE  lbzx r24, r4, r10
	ctx.r[24].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219B554: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B558: 419A02A0  beq cr6, 0x8219b7f8
	if ctx.cr[6].eq {
	pc = 0x8219B7F8; continue 'dispatch;
	}
	// 8219B55C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219B560: 616BEB00  ori r11, r11, 0xeb00
	ctx.r[11].u64 = ctx.r[11].u64 | 60160;
	// 8219B564: 7D6458AE  lbzx r11, r4, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219B568: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B56C: 419A028C  beq cr6, 0x8219b7f8
	if ctx.cr[6].eq {
	pc = 0x8219B7F8; continue 'dispatch;
	}
	// 8219B570: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219B574: 38A00017  li r5, 0x17
	ctx.r[5].s64 = 23;
	// 8219B578: 616ABEBC  ori r10, r11, 0xbebc
	ctx.r[10].u64 = ctx.r[11].u64 | 48828;
	// 8219B57C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219B580: C3CBBA38  lfs f30, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8219B584: 7D64522E  lhzx r11, r4, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219B588: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8219B58C: 2B0B000B  cmplwi cr6, r11, 0xb
	ctx.cr[6].compare_u32(ctx.r[11].u32, 11 as u32, &mut ctx.xer);
	// 8219B590: 409A0010  bne cr6, 0x8219b5a0
	if !ctx.cr[6].eq {
	pc = 0x8219B5A0; continue 'dispatch;
	}
	// 8219B594: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219B598: 38A0001F  li r5, 0x1f
	ctx.r[5].s64 = 31;
	// 8219B59C: C02B2070  lfs f1, 0x2070(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8304 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219B5A0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219B5A4: 4814A9D5  bl 0x822e5f78
	ctx.lr = 0x8219B5A8;
	sub_822E5F78(ctx, base);
	// 8219B5A8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219B5AC: 4801C1B5  bl 0x821b7760
	ctx.lr = 0x8219B5B0;
	sub_821B7760(ctx, base);
	// 8219B5B0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8219B5B4: C0010084  lfs f0, 0x84(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219B5B8: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 8219B5BC: C3EBD4D0  lfs f31, -0x2b30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11056 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219B5C0: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219B5C4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8219B5C8: 3B8B1090  addi r28, r11, 0x1090
	ctx.r[28].s64 = ctx.r[11].s64 + 4240;
	// 8219B5CC: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 8219B5D0: 3B2B0C40  addi r25, r11, 0xc40
	ctx.r[25].s64 = ctx.r[11].s64 + 3136;
	// 8219B5D4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219B5D8: 3BABC470  addi r29, r11, -0x3b90
	ctx.r[29].s64 = ctx.r[11].s64 + -15248;
	// 8219B5DC: 409800DC  bge cr6, 0x8219b6b8
	if !ctx.cr[6].lt {
	pc = 0x8219B6B8; continue 'dispatch;
	}
	// 8219B5E0: 571B103A  slwi r27, r24, 2
	ctx.r[27].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 8219B5E4: 81590688  lwz r10, 0x688(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(1672 as u32) ) } as u64;
	// 8219B5E8: 3B5C00EC  addi r26, r28, 0xec
	ctx.r[26].s64 = ctx.r[28].s64 + 236;
	// 8219B5EC: 7D7BD02E  lwzx r11, r27, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 8219B5F0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8219B5F4: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 8219B5F8: 409900C0  ble cr6, 0x8219b6b8
	if !ctx.cr[6].gt {
	pc = 0x8219B6B8; continue 'dispatch;
	}
	// 8219B5FC: 2F030005  cmpwi cr6, r3, 5
	ctx.cr[6].compare_i32(ctx.r[3].s32, 5, &mut ctx.xer);
	// 8219B600: 419A0060  beq cr6, 0x8219b660
	if ctx.cr[6].eq {
	pc = 0x8219B660; continue 'dispatch;
	}
	// 8219B604: 2F030009  cmpwi cr6, r3, 9
	ctx.cr[6].compare_i32(ctx.r[3].s32, 9, &mut ctx.xer);
	// 8219B608: 409A00A8  bne cr6, 0x8219b6b0
	if !ctx.cr[6].eq {
	pc = 0x8219B6B0; continue 'dispatch;
	}
	// 8219B60C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219B610: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 8219B614: 3BEBC188  addi r31, r11, -0x3e78
	ctx.r[31].s64 = ctx.r[11].s64 + -15992;
	// 8219B618: 4814B809  bl 0x822e6e20
	ctx.lr = 0x8219B61C;
	sub_822E6E20(ctx, base);
	// 8219B61C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8219B620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B624: 419A008C  beq cr6, 0x8219b6b0
	if ctx.cr[6].eq {
	pc = 0x8219B6B0; continue 'dispatch;
	}
	// 8219B628: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 8219B62C: 809D0014  lwz r4, 0x14(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219B630: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 8219B634: 38A01385  li r5, 0x1385
	ctx.r[5].s64 = 4997;
	// 8219B638: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 8219B63C: 481CEE55  bl 0x8236a490
	ctx.lr = 0x8219B640;
	sub_8236A490(ctx, base);
	// 8219B640: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219B644: 419A000C  beq cr6, 0x8219b650
	if ctx.cr[6].eq {
	pc = 0x8219B650; continue 'dispatch;
	}
	// 8219B648: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8219B64C: 4814F7BD  bl 0x822eae08
	ctx.lr = 0x8219B650;
	sub_822EAE08(ctx, base);
	// 8219B650: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8219B654: 2F1E000C  cmpwi cr6, r30, 0xc
	ctx.cr[6].compare_i32(ctx.r[30].s32, 12, &mut ctx.xer);
	// 8219B658: 4198FFC0  blt cr6, 0x8219b618
	if ctx.cr[6].lt {
	pc = 0x8219B618; continue 'dispatch;
	}
	// 8219B65C: 48000054  b 0x8219b6b0
	pc = 0x8219B6B0; continue 'dispatch;
	// 8219B660: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219B664: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 8219B668: 3BEBC188  addi r31, r11, -0x3e78
	ctx.r[31].s64 = ctx.r[11].s64 + -15992;
	// 8219B66C: 4814B7B5  bl 0x822e6e20
	ctx.lr = 0x8219B670;
	sub_822E6E20(ctx, base);
	// 8219B670: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8219B674: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B678: 419A0038  beq cr6, 0x8219b6b0
	if ctx.cr[6].eq {
	pc = 0x8219B6B0; continue 'dispatch;
	}
	// 8219B67C: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 8219B680: 809D0014  lwz r4, 0x14(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219B684: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 8219B688: 38A01385  li r5, 0x1385
	ctx.r[5].s64 = 4997;
	// 8219B68C: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 8219B690: 481CEE01  bl 0x8236a490
	ctx.lr = 0x8219B694;
	sub_8236A490(ctx, base);
	// 8219B694: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219B698: 419A000C  beq cr6, 0x8219b6a4
	if ctx.cr[6].eq {
	pc = 0x8219B6A4; continue 'dispatch;
	}
	// 8219B69C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8219B6A0: 4814F089  bl 0x822ea728
	ctx.lr = 0x8219B6A4;
	sub_822EA728(ctx, base);
	// 8219B6A4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8219B6A8: 2F1E000C  cmpwi cr6, r30, 0xc
	ctx.cr[6].compare_i32(ctx.r[30].s32, 12, &mut ctx.xer);
	// 8219B6AC: 4198FFC0  blt cr6, 0x8219b66c
	if ctx.cr[6].lt {
	pc = 0x8219B66C; continue 'dispatch;
	}
	// 8219B6B0: 81790688  lwz r11, 0x688(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(1672 as u32) ) } as u64;
	// 8219B6B4: 7D7BD12E  stwx r11, r27, r26
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32), ctx.r[11].u32) };
	// 8219B6B8: 3920003F  li r9, 0x3f
	ctx.r[9].s64 = 63;
	// 8219B6BC: 3900003F  li r8, 0x3f
	ctx.r[8].s64 = 63;
	// 8219B6C0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219B6C4: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 8219B6C8: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 8219B6CC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8219B6D0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219B6D4: 480198F5  bl 0x821b4fc8
	ctx.lr = 0x8219B6D8;
	sub_821B4FC8(ctx, base);
	// 8219B6D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219B6DC: 419A011C  beq cr6, 0x8219b7f8
	if ctx.cr[6].eq {
	pc = 0x8219B7F8; continue 'dispatch;
	}
	// 8219B6E0: 571F103A  slwi r31, r24, 2
	ctx.r[31].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 8219B6E4: 81790688  lwz r11, 0x688(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(1672 as u32) ) } as u64;
	// 8219B6E8: 3BDC00F4  addi r30, r28, 0xf4
	ctx.r[30].s64 = ctx.r[28].s64 + 244;
	// 8219B6EC: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8219B6F0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8219B6F4: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 8219B6F8: 40990100  ble cr6, 0x8219b7f8
	if !ctx.cr[6].gt {
	pc = 0x8219B7F8; continue 'dispatch;
	}
	// 8219B6FC: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219B700: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219B704: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8219B708: 419A00F0  beq cr6, 0x8219b7f8
	if ctx.cr[6].eq {
	pc = 0x8219B7F8; continue 'dispatch;
	}
	// 8219B70C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 8219B710: 419A00E8  beq cr6, 0x8219b7f8
	if ctx.cr[6].eq {
	pc = 0x8219B7F8; continue 'dispatch;
	}
	// 8219B714: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219B718: 556BE63E  rlwinm r11, r11, 0x1c, 0x18, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 8219B71C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219B720: 419A0024  beq cr6, 0x8219b744
	if ctx.cr[6].eq {
	pc = 0x8219B744; continue 'dispatch;
	}
	// 8219B724: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 8219B728: 419A001C  beq cr6, 0x8219b744
	if ctx.cr[6].eq {
	pc = 0x8219B744; continue 'dispatch;
	}
	// 8219B72C: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 8219B730: 419A0014  beq cr6, 0x8219b744
	if ctx.cr[6].eq {
	pc = 0x8219B744; continue 'dispatch;
	}
	// 8219B734: 2F0B000E  cmpwi cr6, r11, 0xe
	ctx.cr[6].compare_i32(ctx.r[11].s32, 14, &mut ctx.xer);
	// 8219B738: 419A000C  beq cr6, 0x8219b744
	if ctx.cr[6].eq {
	pc = 0x8219B744; continue 'dispatch;
	}
	// 8219B73C: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 8219B740: 409A00B8  bne cr6, 0x8219b7f8
	if !ctx.cr[6].eq {
	pc = 0x8219B7F8; continue 'dispatch;
	}
	// 8219B744: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219B748: 80BD0014  lwz r5, 0x14(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219B74C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219B750: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8219B754: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219B758: 92E10054  stw r23, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[23].u32 ) };
	// 8219B75C: 38C0006A  li r6, 0x6a
	ctx.r[6].s64 = 106;
	// 8219B760: FAE10060  std r23, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u64 ) };
	// 8219B764: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8219B768: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8219B76C: 481B01F5  bl 0x8234b960
	ctx.lr = 0x8219B770;
	sub_8234B960(ctx, base);
	// 8219B770: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8219B774: E8610060  ld r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8219B778: 481B0931  bl 0x8234c0a8
	ctx.lr = 0x8219B77C;
	sub_8234C0A8(ctx, base);
	// 8219B77C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8219B780: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B784: 419A006C  beq cr6, 0x8219b7f0
	if ctx.cr[6].eq {
	pc = 0x8219B7F0; continue 'dispatch;
	}
	// 8219B788: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219B78C: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8219B790: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219B794: 409A005C  bne cr6, 0x8219b7f0
	if !ctx.cr[6].eq {
	pc = 0x8219B7F0; continue 'dispatch;
	}
	// 8219B798: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8219B79C: 894B01F7  lbz r10, 0x1f7(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(503 as u32) ) } as u64;
	// 8219B7A0: C18B020C  lfs f12, 0x20c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(524 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219B7A4: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 8219B7A8: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219B7AC: C1A92074  lfs f13, 0x2074(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219B7B0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8219B7B4: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 8219B7B8: 994B01F7  stb r10, 0x1f7(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(503 as u32), ctx.r[10].u8 ) };
	// 8219B7BC: C1A9D6C8  lfs f13, -0x2938(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219B7C0: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8219B7C4: D1AB0208  stfs f13, 0x208(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(520 as u32), tmp.u32 ) };
	// 8219B7C8: 409A000C  bne cr6, 0x8219b7d4
	if !ctx.cr[6].eq {
	pc = 0x8219B7D4; continue 'dispatch;
	}
	// 8219B7CC: 714A00FB  andi. r10, r10, 0xfb
	ctx.r[10].u64 = ctx.r[10].u64 & 251;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8219B7D0: 48000010  b 0x8219b7e0
	pc = 0x8219B7E0; continue 'dispatch;
	// 8219B7D4: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 8219B7D8: 614A0004  ori r10, r10, 4
	ctx.r[10].u64 = ctx.r[10].u64 | 4;
	// 8219B7DC: D00B020C  stfs f0, 0x20c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(524 as u32), tmp.u32 ) };
	// 8219B7E0: 994B01F7  stb r10, 0x1f7(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(503 as u32), ctx.r[10].u8 ) };
	// 8219B7E4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219B7E8: 554A062C  rlwinm r10, r10, 0, 0x18, 0x16
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8219B7EC: 914B008C  stw r10, 0x8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 8219B7F0: 81790688  lwz r11, 0x688(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(1672 as u32) ) } as u64;
	// 8219B7F4: 7D7FF12E  stwx r11, r31, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32), ctx.r[11].u32) };
	// 8219B7F8: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 8219B7FC: CBC1FFA0  lfd f30, -0x60(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 8219B800: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 8219B804: 483998F0  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219B808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219B808 size=1068
    let mut pc: u32 = 0x8219B808;
    'dispatch: loop {
        match pc {
            0x8219B808 => {
    //   block [0x8219B808..0x8219BC34)
	// 8219B808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219B80C: 48399895  bl 0x825350a0
	ctx.lr = 0x8219B810;
	sub_82535080(ctx, base);
	// 8219B810: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 8219B814: 4839A7D5  bl 0x82535fe8
	ctx.lr = 0x8219B818;
	sub_82535FB0(ctx, base);
	// 8219B818: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219B81C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219B820: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219B824: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8219B828: 616BBE64  ori r11, r11, 0xbe64
	ctx.r[11].u64 = ctx.r[11].u64 | 48740;
	// 8219B82C: 614AEB33  ori r10, r10, 0xeb33
	ctx.r[10].u64 = ctx.r[10].u64 | 60211;
	// 8219B830: 7EDC58AE  lbzx r22, r28, r11
	ctx.r[22].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219B834: 7D7C50AE  lbzx r11, r28, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219B838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B83C: 409A03E8  bne cr6, 0x8219bc24
	if !ctx.cr[6].eq {
	pc = 0x8219BC24; continue 'dispatch;
	}
	// 8219B840: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 8219B844: 394000A8  li r10, 0xa8
	ctx.r[10].s64 = 168;
	// 8219B848: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 8219B84C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8219B850: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8219B854: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8219B858: 4200FFF8  bdnz 0x8219b850
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8219B850; continue 'dispatch;
	}
	// 8219B85C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8219B860: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219B864: 56CA103A  slwi r10, r22, 2
	ctx.r[10].u32 = ctx.r[22].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219B868: 396BCF90  addi r11, r11, -0x3070
	ctx.r[11].s64 = ctx.r[11].s64 + -12400;
	// 8219B86C: 3AE00005  li r23, 5
	ctx.r[23].s64 = 5;
	// 8219B870: 91210090  stw r9, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[9].u32 ) };
	// 8219B874: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 8219B878: 396B0798  addi r11, r11, 0x798
	ctx.r[11].s64 = ctx.r[11].s64 + 1944;
	// 8219B87C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8219B880: 92E10094  stw r23, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[23].u32 ) };
	// 8219B884: 91210098  stw r9, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[9].u32 ) };
	// 8219B888: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219B88C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219B890: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B894: 9121009C  stw r9, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[9].u32 ) };
	// 8219B898: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 8219B89C: 912100A0  stw r9, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	// 8219B8A0: 419A0008  beq cr6, 0x8219b8a8
	if ctx.cr[6].eq {
	pc = 0x8219B8A8; continue 'dispatch;
	}
	// 8219B8A4: 3BCB0030  addi r30, r11, 0x30
	ctx.r[30].s64 = ctx.r[11].s64 + 48;
	// 8219B8A8: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 8219B8AC: 396100F0  addi r11, r1, 0xf0
	ctx.r[11].s64 = ctx.r[1].s64 + 240;
	// 8219B8B0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219BC38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219BC38 size=348
    let mut pc: u32 = 0x8219BC38;
    'dispatch: loop {
        match pc {
            0x8219BC38 => {
    //   block [0x8219BC38..0x8219BD94)
	// 8219BC38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219BC3C: 48399479  bl 0x825350b4
	ctx.lr = 0x8219BC40;
	sub_82535080(ctx, base);
	// 8219BC40: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8219BC44: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219BC48: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219BC4C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8219BC50: 549C103A  slwi r28, r4, 2
	ctx.r[28].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 8219BC54: 396B1090  addi r11, r11, 0x1090
	ctx.r[11].s64 = ctx.r[11].s64 + 4240;
	// 8219BC58: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8219BC5C: 3B6B00FC  addi r27, r11, 0xfc
	ctx.r[27].s64 = ctx.r[11].s64 + 252;
	// 8219BC60: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 8219BC64: 3BAB0C40  addi r29, r11, 0xc40
	ctx.r[29].s64 = ctx.r[11].s64 + 3136;
	// 8219BC68: 7D5CD82E  lwzx r10, r28, r27
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 8219BC6C: 817D0688  lwz r11, 0x688(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1672 as u32) ) } as u64;
	// 8219BC70: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8219BC74: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 8219BC78: 41980110  blt cr6, 0x8219bd88
	if ctx.cr[6].lt {
	pc = 0x8219BD88; continue 'dispatch;
	}
	// 8219BC7C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219BC80: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8219BC84: 38EB09D8  addi r7, r11, 0x9d8
	ctx.r[7].s64 = ctx.r[11].s64 + 2520;
	// 8219BC88: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219BC8C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219BC90: 386001B0  li r3, 0x1b0
	ctx.r[3].s64 = 432;
	// 8219BC94: 83EBB9D8  lwz r31, -0x4628(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 8219BC98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219BC9C: 481CE7F5  bl 0x8236a490
	ctx.lr = 0x8219BCA0;
	sub_8236A490(ctx, base);
	// 8219BCA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219BCA4: 419A00E4  beq cr6, 0x8219bd88
	if ctx.cr[6].eq {
	pc = 0x8219BD88; continue 'dispatch;
	}
	// 8219BCA8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219BCAC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8219BCB0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219BCB4: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219BCB8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219BCBC: C1AABA38  lfs f13, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219BCC0: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 8219BCC4: 396B0AD0  addi r11, r11, 0xad0
	ctx.r[11].s64 = ctx.r[11].s64 + 2768;
	// 8219BCC8: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8219BCCC: D00300B4  stfs f0, 0xb4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 8219BCD0: D00300B8  stfs f0, 0xb8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 8219BCD4: D1A300BC  stfs f13, 0xbc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 8219BCD8: D00300A0  stfs f0, 0xa0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8219BCDC: D00300A4  stfs f0, 0xa4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8219BCE0: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8219BCE4: D1A300AC  stfs f13, 0xac(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8219BCE8: 912300C0  stw r9, 0xc0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[9].u32 ) };
	// 8219BCEC: D00300C4  stfs f0, 0xc4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8219BCF0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219BCF4: B1430088  sth r10, 0x88(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[10].u16 ) };
	// 8219BCF8: 93E30090  stw r31, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 8219BCFC: 91230084  stw r9, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 8219BD00: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219BD04: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 8219BD08: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219BD0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219BD10: 419A0008  beq cr6, 0x8219bd18
	if ctx.cr[6].eq {
	pc = 0x8219BD18; continue 'dispatch;
	}
	// 8219BD14: 906B0084  stw r3, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 8219BD18: 907F0080  stw r3, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 8219BD1C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8219BD20: E93E0000  ld r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 8219BD24: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8219BD28: E91E0008  ld r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 8219BD2C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 8219BD30: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 8219BD34: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8219BD38: F90B0008  std r8, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 8219BD3C: E96A0000  ld r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8219BD40: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 8219BD44: F96300D0  std r11, 0xd0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), ctx.r[11].u64 ) };
	// 8219BD48: F94300D8  std r10, 0xd8(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(216 as u32), ctx.r[10].u64 ) };
	// 8219BD4C: 40980014  bge cr6, 0x8219bd60
	if !ctx.cr[6].lt {
	pc = 0x8219BD60; continue 'dispatch;
	}
	// 8219BD50: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219BD54: C00B228C  lfs f0, 0x228c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8844 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219BD58: D00300E0  stfs f0, 0xe0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8219BD5C: 48000008  b 0x8219bd64
	pc = 0x8219BD64; continue 'dispatch;
	// 8219BD60: D3E300E0  stfs f31, 0xe0(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8219BD64: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219BD68: C1ABF1FC  lfs f13, -0xe04(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3588 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219BD6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219BD70: D1A300E4  stfs f13, 0xe4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 8219BD74: C1AB23C0  lfs f13, 0x23c0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219BD78: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219BD7C: D00300E8  stfs f0, 0xe8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 8219BD80: 817D0688  lwz r11, 0x688(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1672 as u32) ) } as u64;
	// 8219BD84: 7D7CD92E  stwx r11, r28, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[27].u32), ctx.r[11].u32) };
	// 8219BD88: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8219BD8C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8219BD90: 48399374  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219BD98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219BD98 size=324
    let mut pc: u32 = 0x8219BD98;
    'dispatch: loop {
        match pc {
            0x8219BD98 => {
    //   block [0x8219BD98..0x8219BEDC)
	// 8219BD98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219BD9C: 4839931D  bl 0x825350b8
	ctx.lr = 0x8219BDA0;
	sub_82535080(ctx, base);
	// 8219BDA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219BDA4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219BDA8: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219BDAC: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219BDB0: 614A8654  ori r10, r10, 0x8654
	ctx.r[10].u64 = ctx.r[10].u64 | 34388;
	// 8219BDB4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8219BDB8: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219BDBC: 2B0B0016  cmplwi cr6, r11, 0x16
	ctx.cr[6].compare_u32(ctx.r[11].u32, 22 as u32, &mut ctx.xer);
	// 8219BDC0: 419A0114  beq cr6, 0x8219bed4
	if ctx.cr[6].eq {
	pc = 0x8219BED4; continue 'dispatch;
	}
	// 8219BDC4: 2B0B0017  cmplwi cr6, r11, 0x17
	ctx.cr[6].compare_u32(ctx.r[11].u32, 23 as u32, &mut ctx.xer);
	// 8219BDC8: 419A010C  beq cr6, 0x8219bed4
	if ctx.cr[6].eq {
	pc = 0x8219BED4; continue 'dispatch;
	}
	// 8219BDCC: 2B0B0019  cmplwi cr6, r11, 0x19
	ctx.cr[6].compare_u32(ctx.r[11].u32, 25 as u32, &mut ctx.xer);
	// 8219BDD0: 419A0104  beq cr6, 0x8219bed4
	if ctx.cr[6].eq {
	pc = 0x8219BED4; continue 'dispatch;
	}
	// 8219BDD4: 2B0B0014  cmplwi cr6, r11, 0x14
	ctx.cr[6].compare_u32(ctx.r[11].u32, 20 as u32, &mut ctx.xer);
	// 8219BDD8: 419A00FC  beq cr6, 0x8219bed4
	if ctx.cr[6].eq {
	pc = 0x8219BED4; continue 'dispatch;
	}
	// 8219BDDC: 2B0B0015  cmplwi cr6, r11, 0x15
	ctx.cr[6].compare_u32(ctx.r[11].u32, 21 as u32, &mut ctx.xer);
	// 8219BDE0: 419A00F4  beq cr6, 0x8219bed4
	if ctx.cr[6].eq {
	pc = 0x8219BED4; continue 'dispatch;
	}
	// 8219BDE4: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 8219BDE8: 419A00EC  beq cr6, 0x8219bed4
	if ctx.cr[6].eq {
	pc = 0x8219BED4; continue 'dispatch;
	}
	// 8219BDEC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219BDF0: 617E9C00  ori r30, r11, 0x9c00
	ctx.r[30].u64 = ctx.r[11].u64 | 39936;
	// 8219BDF4: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219BDF8: 3BEB1090  addi r31, r11, 0x1090
	ctx.r[31].s64 = ctx.r[11].s64 + 4240;
	// 8219BDFC: 7D44F02E  lwzx r10, r4, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8219BE00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219BE04: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 8219BE08: 419A0010  beq cr6, 0x8219be18
	if ctx.cr[6].eq {
	pc = 0x8219BE18; continue 'dispatch;
	}
	// 8219BE0C: 813F00D0  lwz r9, 0xd0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8219BE10: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 8219BE14: 409A0020  bne cr6, 0x8219be34
	if !ctx.cr[6].eq {
	pc = 0x8219BE34; continue 'dispatch;
	}
	// 8219BE18: 7D3CF02E  lwzx r9, r28, r30
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8219BE1C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219BE20: 419A00A8  beq cr6, 0x8219bec8
	if ctx.cr[6].eq {
	pc = 0x8219BEC8; continue 'dispatch;
	}
	// 8219BE24: 813F00D4  lwz r9, 0xd4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219BE28: 811F00CC  lwz r8, 0xcc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 8219BE2C: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 8219BE30: 419A0098  beq cr6, 0x8219bec8
	if ctx.cr[6].eq {
	pc = 0x8219BEC8; continue 'dispatch;
	}
	// 8219BE34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219BE38: 419A0018  beq cr6, 0x8219be50
	if ctx.cr[6].eq {
	pc = 0x8219BE50; continue 'dispatch;
	}
	// 8219BE3C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219BE40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219BE44: 4BFFEA45  bl 0x8219a888
	ctx.lr = 0x8219BE48;
	sub_8219A888(ctx, base);
	// 8219BE48: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8219BE4C: 48000008  b 0x8219be54
	pc = 0x8219BE54; continue 'dispatch;
	// 8219BE50: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8219BE54: 7D7CF02E  lwzx r11, r28, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8219BE58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219BE5C: 419A0018  beq cr6, 0x8219be74
	if ctx.cr[6].eq {
	pc = 0x8219BE74; continue 'dispatch;
	}
	// 8219BE60: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8219BE64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219BE68: 4BFFEA21  bl 0x8219a888
	ctx.lr = 0x8219BE6C;
	sub_8219A888(ctx, base);
	// 8219BE6C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 8219BE70: 48000008  b 0x8219be78
	pc = 0x8219BE78; continue 'dispatch;
	// 8219BE74: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219BE78: 7F1D5000  cmpw cr6, r29, r10
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8219BE7C: 41980008  blt cr6, 0x8219be84
	if ctx.cr[6].lt {
	pc = 0x8219BE84; continue 'dispatch;
	}
	// 8219BE80: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 8219BE84: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8219BE88: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219BE8C: 396BCFD0  addi r11, r11, -0x3030
	ctx.r[11].s64 = ctx.r[11].s64 + -12336;
	// 8219BE90: 7C4A5C2E  lfsx f2, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219BE94: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219BE98: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219BE9C: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 8219BEA0: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 8219BEA4: 396BFFD8  addi r11, r11, -0x28
	ctx.r[11].s64 = ctx.r[11].s64 + -40;
	// 8219BEA8: C02B0098  lfs f1, 0x98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219BEAC: 40980008  bge cr6, 0x8219beb4
	if !ctx.cr[6].lt {
	pc = 0x8219BEB4; continue 'dispatch;
	}
	// 8219BEB0: FC400890  fmr f2, f1
	ctx.f[2].f64 = ctx.f[1].f64;
	// 8219BEB4: 38C00046  li r6, 0x46
	ctx.r[6].s64 = 70;
	// 8219BEB8: 38600023  li r3, 0x23
	ctx.r[3].s64 = 35;
	// 8219BEBC: 38EB0098  addi r7, r11, 0x98
	ctx.r[7].s64 = ctx.r[11].s64 + 152;
	// 8219BEC0: 481DD7D9  bl 0x82379698
	ctx.lr = 0x8219BEC4;
	sub_82379698(ctx, base);
	// 8219BEC4: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 8219BEC8: 917F00D0  stw r11, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 8219BECC: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 8219BED0: 917F00D4  stw r11, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 8219BED4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8219BED8: 48399230  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219BEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219BEE0 size=156
    let mut pc: u32 = 0x8219BEE0;
    'dispatch: loop {
        match pc {
            0x8219BEE0 => {
    //   block [0x8219BEE0..0x8219BF7C)
	// 8219BEE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219BEE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219BEE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219BEEC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219BEF0: 3D0082C0  lis r8, -0x7d40
	ctx.r[8].s64 = -2101346304;
	// 8219BEF4: 3CE00003  lis r7, 3
	ctx.r[7].s64 = 196608;
	// 8219BEF8: 3908BFF0  addi r8, r8, -0x4010
	ctx.r[8].s64 = ctx.r[8].s64 + -16400;
	// 8219BEFC: 60E79450  ori r7, r7, 0x9450
	ctx.r[7].u64 = ctx.r[7].u64 | 37968;
	// 8219BF00: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219BF04: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 8219BF08: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 8219BF0C: 7D083A2E  lhzx r8, r8, r7
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 8219BF10: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 8219BF14: 409A0054  bne cr6, 0x8219bf68
	if !ctx.cr[6].eq {
	pc = 0x8219BF68; continue 'dispatch;
	}
	// 8219BF18: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8219BF1C: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 8219BF20: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 8219BF24: 99210052  stb r9, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[9].u8 ) };
	// 8219BF28: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 8219BF2C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8219BF30: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 8219BF34: C0082094  lfs f0, 0x2094(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219BF38: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 8219BF3C: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219BF40: 611FBE64  ori r31, r8, 0xbe64
	ctx.r[31].u64 = ctx.r[8].u64 | 48740;
	// 8219BF44: 3D00829A  lis r8, -0x7d66
	ctx.r[8].s64 = -2103836672;
	// 8219BF48: 386845D8  addi r3, r8, 0x45d8
	ctx.r[3].s64 = ctx.r[8].s64 + 17880;
	// 8219BF4C: 7D6BF8AE  lbzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 8219BF50: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 8219BF54: 7C003FAE  stfiwx f0, 0, r7
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32, tmp.u32) };
	// 8219BF58: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8219BF5C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219BF60: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 8219BF64: 4BFE0AB5  bl 0x8217ca18
	ctx.lr = 0x8219BF68;
	sub_8217CA18(ctx, base);
	// 8219BF68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219BF6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219BF70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219BF74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219BF78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219BF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219BF80 size=940
    let mut pc: u32 = 0x8219BF80;
    'dispatch: loop {
        match pc {
            0x8219BF80 => {
    //   block [0x8219BF80..0x8219C32C)
	// 8219BF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219BF84: 48399139  bl 0x825350bc
	ctx.lr = 0x8219BF88;
	sub_82535080(ctx, base);
	// 8219BF88: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219BF8C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219BF90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219BF94: 3CE50504  addis r7, r5, 0x504
	ctx.r[7].s64 = ctx.r[5].s64 + 84148224;
	// 8219BF98: 3D208288  lis r9, -0x7d78
	ctx.r[9].s64 = -2105016320;
	// 8219BF9C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8219BFA0: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219BFA4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219BFA8: 38E74000  addi r7, r7, 0x4000
	ctx.r[7].s64 = ctx.r[7].s64 + 16384;
	// 8219BFAC: 394B0B58  addi r10, r11, 0xb58
	ctx.r[10].s64 = ctx.r[11].s64 + 2904;
	// 8219BFB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219BFB4: 3BA00030  li r29, 0x30
	ctx.r[29].s64 = 48;
	// 8219BFB8: 39298E40  addi r9, r9, -0x71c0
	ctx.r[9].s64 = ctx.r[9].s64 + -29120;
	// 8219BFBC: 3BFE00B8  addi r31, r30, 0xb8
	ctx.r[31].s64 = ctx.r[30].s64 + 184;
	// 8219BFC0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8219BFC4: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 8219BFC8: 917E0080  stw r11, 0x80(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 8219BFCC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8219BFD0: 394AC470  addi r10, r10, -0x3b90
	ctx.r[10].s64 = ctx.r[10].s64 + -15248;
	// 8219BFD4: B17E0084  sth r11, 0x84(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), ctx.r[11].u16 ) };
	// 8219BFD8: B17E0086  sth r11, 0x86(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(134 as u32), ctx.r[11].u16 ) };
	// 8219BFDC: 38800F00  li r4, 0xf00
	ctx.r[4].s64 = 3840;
	// 8219BFE0: 917E00B8  stw r11, 0xb8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 8219BFE4: 386A0030  addi r3, r10, 0x30
	ctx.r[3].s64 = ctx.r[10].s64 + 48;
	// 8219BFE8: 991E001E  stb r8, 0x1e(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(30 as u32), ctx.r[8].u8 ) };
	// 8219BFEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8219BFF0: 917E00A4  stw r11, 0xa4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 8219BFF4: 917E0098  stw r11, 0x98(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 8219BFF8: 90FE0088  stw r7, 0x88(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[7].u32 ) };
	// 8219BFFC: 911E008C  stw r8, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[8].u32 ) };
	// 8219C000: 93BE0094  stw r29, 0x94(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(148 as u32), ctx.r[29].u32 ) };
	// 8219C004: D01E009C  stfs f0, 0x9c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 8219C008: D01E00A0  stfs f0, 0xa0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8219C00C: 913E0080  stw r9, 0x80(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 8219C010: B17E0084  sth r11, 0x84(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), ctx.r[11].u16 ) };
	// 8219C014: B17E0086  sth r11, 0x86(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(134 as u32), ctx.r[11].u16 ) };
	// 8219C018: 48005C19  bl 0x821a1c30
	ctx.lr = 0x8219C01C;
	sub_821A1C30(ctx, base);
	// 8219C01C: 817E00B8  lwz r11, 0xb8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C024: 419A02FC  beq cr6, 0x8219c320
	if ctx.cr[6].eq {
	pc = 0x8219C320; continue 'dispatch;
	}
	// 8219C028: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 8219C02C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8219C030: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8219C034: 39400090  li r10, 0x90
	ctx.r[10].s64 = 144;
	// 8219C038: C008BA38  lfs f0, -0x45c8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C03C: C1A92950  lfs f13, 0x2950(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10576 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C040: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 8219C044: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C048: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 8219C04C: 54A5F87E  srwi r5, r5, 1
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shr(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 8219C050: 78C607E0  clrldi r6, r6, 0x3f
	ctx.r[6].u64 = ctx.r[6].u64 & 0x0000000000000001u64;
	// 8219C054: 78A50020  clrldi r5, r5, 0x20
	ctx.r[5].u64 = ctx.r[5].u64 & 0x00000000FFFFFFFFu64;
	// 8219C058: 390BFFFE  addi r8, r11, -2
	ctx.r[8].s64 = ctx.r[11].s64 + -2;
	// 8219C05C: 5564F87E  srwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8219C060: 38EAFF70  addi r7, r10, -0x90
	ctx.r[7].s64 = ctx.r[10].s64 + -144;
	// 8219C064: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 8219C068: 790607E0  clrldi r6, r8, 0x3f
	ctx.r[6].u64 = ctx.r[8].u64 & 0x0000000000000001u64;
	// 8219C06C: F8A10058  std r5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u64 ) };
	// 8219C070: 5508F87E  srwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219C074: 78840020  clrldi r4, r4, 0x20
	ctx.r[4].u64 = ctx.r[4].u64 & 0x00000000FFFFFFFFu64;
	// 8219C078: 79080020  clrldi r8, r8, 0x20
	ctx.r[8].u64 = ctx.r[8].u64 & 0x00000000FFFFFFFFu64;
	// 8219C07C: 7D274A14  add r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 8219C080: F8C10068  std r6, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[6].u64 ) };
	// 8219C084: 38CB0003  addi r6, r11, 3
	ctx.r[6].s64 = ctx.r[11].s64 + 3;
	// 8219C088: F8810060  std r4, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[4].u64 ) };
	// 8219C08C: 54C6F87E  srwi r6, r6, 1
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shr(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8219C090: F9010070  std r8, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u64 ) };
	// 8219C094: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 8219C098: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C09C: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C0A0: 5508F87E  srwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219C0A4: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C0A8: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C0AC: 79080020  clrldi r8, r8, 0x20
	ctx.r[8].u64 = ctx.r[8].u64 & 0x00000000FFFFFFFFu64;
	// 8219C0B0: F9010078  std r8, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[8].u64 ) };
	// 8219C0B4: 78C80020  clrldi r8, r6, 0x20
	ctx.r[8].u64 = ctx.r[6].u64 & 0x00000000FFFFFFFFu64;
	// 8219C0B8: F9010088  std r8, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[8].u64 ) };
	// 8219C0BC: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219C0C0: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8219C0C4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8219C0C8: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 8219C0CC: C9410060  lfd f10, 0x60(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8219C0D0: C9010070  lfd f8, 0x70(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 8219C0D4: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 8219C0D8: FD00469C  fcfid f8, f8
	ctx.f[8].f64 = (ctx.f[8].s64 as f64);
	// 8219C0DC: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8219C0E0: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 8219C0E4: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 8219C0E8: FD004018  frsp f8, f8
	ctx.f[8].f64 = (ctx.f[8].f64 as f32) as f64;
	// 8219C0EC: ED2B037C  fnmsubs f9, f11, f13, f0
	ctx.f[9].f64 = -(((ctx.f[11].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C0F0: C9610068  lfd f11, 0x68(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8219C0F4: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 8219C0F8: ED4A037C  fnmsubs f10, f10, f13, f0
	ctx.f[10].f64 = -(((ctx.f[10].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C0FC: ED08037C  fnmsubs f8, f8, f13, f0
	ctx.f[8].f64 = -(((ctx.f[8].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C100: D1090020  stfs f8, 0x20(r9)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C104: C9010088  lfd f8, 0x88(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8219C108: FD00469C  fcfid f8, f8
	ctx.f[8].f64 = (ctx.f[8].s64 as f64);
	// 8219C10C: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 8219C110: D1690024  stfs f11, 0x24(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C114: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C118: 7D274A14  add r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 8219C11C: 38EB0002  addi r7, r11, 2
	ctx.r[7].s64 = ctx.r[11].s64 + 2;
	// 8219C120: 39290030  addi r9, r9, 0x30
	ctx.r[9].s64 = ctx.r[9].s64 + 48;
	// 8219C124: 54E7F87E  srwi r7, r7, 1
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8219C128: 78E70020  clrldi r7, r7, 0x20
	ctx.r[7].u64 = ctx.r[7].u64 & 0x00000000FFFFFFFFu64;
	// 8219C12C: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C130: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C134: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C138: F8E10080  std r7, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[7].u64 ) };
	// 8219C13C: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C140: D1290020  stfs f9, 0x20(r9)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C144: D1890024  stfs f12, 0x24(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C148: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C14C: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8219C150: 3929FFD0  addi r9, r9, -0x30
	ctx.r[9].s64 = ctx.r[9].s64 + -48;
	// 8219C154: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C158: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C15C: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C160: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C164: D1490020  stfs f10, 0x20(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C168: D1690024  stfs f11, 0x24(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C16C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C170: C9410078  lfd f10, 0x78(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 8219C174: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8219C178: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 8219C17C: C9210080  lfd f9, 0x80(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 8219C180: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 8219C184: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 8219C188: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 8219C18C: 38EB0005  addi r7, r11, 5
	ctx.r[7].s64 = ctx.r[11].s64 + 5;
	// 8219C190: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C194: 5508F87E  srwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219C198: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C19C: 54E7F87E  srwi r7, r7, 1
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8219C1A0: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C1A4: 79080020  clrldi r8, r8, 0x20
	ctx.r[8].u64 = ctx.r[8].u64 & 0x00000000FFFFFFFFu64;
	// 8219C1A8: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C1AC: 38CB0006  addi r6, r11, 6
	ctx.r[6].s64 = ctx.r[11].s64 + 6;
	// 8219C1B0: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 8219C1B4: FD004018  frsp f8, f8
	ctx.f[8].f64 = (ctx.f[8].f64 as f32) as f64;
	// 8219C1B8: 54C6F87E  srwi r6, r6, 1
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shr(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8219C1BC: F9010090  std r8, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[8].u64 ) };
	// 8219C1C0: 78E80020  clrldi r8, r7, 0x20
	ctx.r[8].u64 = ctx.r[7].u64 & 0x00000000FFFFFFFFu64;
	// 8219C1C4: ED4A037C  fnmsubs f10, f10, f13, f0
	ctx.f[10].f64 = -(((ctx.f[10].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C1C8: D1490020  stfs f10, 0x20(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C1CC: D1890024  stfs f12, 0x24(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C1D0: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C1D4: 78C70020  clrldi r7, r6, 0x20
	ctx.r[7].u64 = ctx.r[6].u64 & 0x00000000FFFFFFFFu64;
	// 8219C1D8: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8219C1DC: F9010098  std r8, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[8].u64 ) };
	// 8219C1E0: 38CB0007  addi r6, r11, 7
	ctx.r[6].s64 = ctx.r[11].s64 + 7;
	// 8219C1E4: 39290030  addi r9, r9, 0x30
	ctx.r[9].s64 = ctx.r[9].s64 + 48;
	// 8219C1E8: ED29037C  fnmsubs f9, f9, f13, f0
	ctx.f[9].f64 = -(((ctx.f[9].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C1EC: ED08037C  fnmsubs f8, f8, f13, f0
	ctx.f[8].f64 = -(((ctx.f[8].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C1F0: 54C6F87E  srwi r6, r6, 1
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shr(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8219C1F4: F8E100A0  std r7, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[7].u64 ) };
	// 8219C1F8: 78C80020  clrldi r8, r6, 0x20
	ctx.r[8].u64 = ctx.r[6].u64 & 0x00000000FFFFFFFFu64;
	// 8219C1FC: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C200: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C204: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C208: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C20C: F90100A8  std r8, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[8].u64 ) };
	// 8219C210: D1290020  stfs f9, 0x20(r9)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C214: D1690024  stfs f11, 0x24(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C218: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C21C: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8219C220: 39290060  addi r9, r9, 0x60
	ctx.r[9].s64 = ctx.r[9].s64 + 96;
	// 8219C224: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C228: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C22C: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C230: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C234: D1090020  stfs f8, 0x20(r9)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C238: D1890024  stfs f12, 0x24(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C23C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C240: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8219C244: 39290090  addi r9, r9, 0x90
	ctx.r[9].s64 = ctx.r[9].s64 + 144;
	// 8219C248: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C24C: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C250: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C254: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C258: C9410090  lfd f10, 0x90(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 8219C25C: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 8219C260: C9210098  lfd f9, 0x98(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 8219C264: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 8219C268: C90100A0  lfd f8, 0xa0(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 8219C26C: FD00469C  fcfid f8, f8
	ctx.f[8].f64 = (ctx.f[8].s64 as f64);
	// 8219C270: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 8219C274: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 8219C278: FD004018  frsp f8, f8
	ctx.f[8].f64 = (ctx.f[8].f64 as f32) as f64;
	// 8219C27C: ED4A037C  fnmsubs f10, f10, f13, f0
	ctx.f[10].f64 = -(((ctx.f[10].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C280: D1490020  stfs f10, 0x20(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C284: D1690024  stfs f11, 0x24(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C288: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C28C: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8219C290: 392900C0  addi r9, r9, 0xc0
	ctx.r[9].s64 = ctx.r[9].s64 + 192;
	// 8219C294: ED49037C  fnmsubs f10, f9, f13, f0
	ctx.f[10].f64 = -(((ctx.f[9].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C298: ED28037C  fnmsubs f9, f8, f13, f0
	ctx.f[9].f64 = -(((ctx.f[8].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C29C: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C2A0: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C2A4: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C2A8: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C2AC: D1490020  stfs f10, 0x20(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C2B0: D1890024  stfs f12, 0x24(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C2B4: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C2B8: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8219C2BC: 392900F0  addi r9, r9, 0xf0
	ctx.r[9].s64 = ctx.r[9].s64 + 240;
	// 8219C2C0: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C2C4: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C2C8: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C2CC: 396B000A  addi r11, r11, 0xa
	ctx.r[11].s64 = ctx.r[11].s64 + 10;
	// 8219C2D0: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C2D4: D1290020  stfs f9, 0x20(r9)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C2D8: D1690024  stfs f11, 0x24(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C2DC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C2E0: C96100A8  lfd f11, 0xa8(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 8219C2E4: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 8219C2E8: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8219C2EC: 394A01E0  addi r10, r10, 0x1e0
	ctx.r[10].s64 = ctx.r[10].s64 + 480;
	// 8219C2F0: 39290120  addi r9, r9, 0x120
	ctx.r[9].s64 = ctx.r[9].s64 + 288;
	// 8219C2F4: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C2F8: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C2FC: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C300: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 8219C304: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C308: ED6B037C  fnmsubs f11, f11, f13, f0
	ctx.f[11].f64 = -(((ctx.f[11].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C30C: D1690020  stfs f11, 0x20(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C310: D1890024  stfs f12, 0x24(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C314: 392BFFFE  addi r9, r11, -2
	ctx.r[9].s64 = ctx.r[11].s64 + -2;
	// 8219C318: 2B090028  cmplwi cr6, r9, 0x28
	ctx.cr[6].compare_u32(ctx.r[9].u32, 40 as u32, &mut ctx.xer);
	// 8219C31C: 4198FD24  blt cr6, 0x8219c040
	if ctx.cr[6].lt {
	pc = 0x8219C040; continue 'dispatch;
	}
	// 8219C320: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219C324: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8219C328: 48398DE4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219C330 size=156
    let mut pc: u32 = 0x8219C330;
    'dispatch: loop {
        match pc {
            0x8219C330 => {
    //   block [0x8219C330..0x8219C3CC)
	// 8219C330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219C334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219C338: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219C33C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219C340: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219C344: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219C348: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219C34C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8219C350: 396B0B58  addi r11, r11, 0xb58
	ctx.r[11].s64 = ctx.r[11].s64 + 2904;
	// 8219C354: 389F00B8  addi r4, r31, 0xb8
	ctx.r[4].s64 = ctx.r[31].s64 + 184;
	// 8219C358: 815F00B8  lwz r10, 0xb8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C35C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219C360: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219C364: 419A0014  beq cr6, 0x8219c378
	if ctx.cr[6].eq {
	pc = 0x8219C378; continue 'dispatch;
	}
	// 8219C368: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219C36C: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219C370: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 8219C374: 48005D0D  bl 0x821a2080
	ctx.lr = 0x8219C378;
	sub_821A2080(ctx, base);
	// 8219C378: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219C37C: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8219C380: 396BDED0  addi r11, r11, -0x2130
	ctx.r[11].s64 = ctx.r[11].s64 + -8496;
	// 8219C384: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219C388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219C38C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219C390: 419A0024  beq cr6, 0x8219c3b4
	if ctx.cr[6].eq {
	pc = 0x8219C3B4; continue 'dispatch;
	}
	// 8219C394: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8219C398: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219C39C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8219C3A0: 409A0014  bne cr6, 0x8219c3b4
	if !ctx.cr[6].eq {
	pc = 0x8219C3B4; continue 'dispatch;
	}
	// 8219C3A4: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8219C3A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219C3AC: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 8219C3B0: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 8219C3B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219C3B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219C3BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219C3C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219C3C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219C3C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219C3D0 size=492
    let mut pc: u32 = 0x8219C3D0;
    'dispatch: loop {
        match pc {
            0x8219C3D0 => {
    //   block [0x8219C3D0..0x8219C5BC)
	// 8219C3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219C3D4: 48398CE9  bl 0x825350bc
	ctx.lr = 0x8219C3D8;
	sub_82535080(ctx, base);
	// 8219C3D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219C3DC: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 8219C3E0: 816900B8  lwz r11, 0xb8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C3E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C3E8: 419A01CC  beq cr6, 0x8219c5b4
	if ctx.cr[6].eq {
	pc = 0x8219C5B4; continue 'dispatch;
	}
	// 8219C3EC: 81490010  lwz r10, 0x10(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 8219C3F0: 816A00C4  lwz r11, 0xc4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(196 as u32) ) } as u64;
	// 8219C3F4: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 8219C3F8: 41980008  blt cr6, 0x8219c400
	if ctx.cr[6].lt {
	pc = 0x8219C400; continue 'dispatch;
	}
	// 8219C3FC: 39600014  li r11, 0x14
	ctx.r[11].s64 = 20;
	// 8219C400: 557FF87E  srwi r31, r11, 1
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 8219C404: 810A00CC  lwz r8, 0xcc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(204 as u32) ) } as u64;
	// 8219C408: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8219C40C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219C410: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8219C414: 419A01A0  beq cr6, 0x8219c5b4
	if ctx.cr[6].eq {
	pc = 0x8219C5B4; continue 'dispatch;
	}
	// 8219C418: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 8219C41C: 39680034  addi r11, r8, 0x34
	ctx.r[11].s64 = ctx.r[8].s64 + 52;
	// 8219C420: C007BFFC  lfs f0, -0x4004(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C424: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219C428: 419A00E8  beq cr6, 0x8219c510
	if ctx.cr[6].eq {
	pc = 0x8219C510; continue 'dispatch;
	}
	// 8219C42C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8219C430: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C434: 80C900B8  lwz r6, 0xb8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C438: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C43C: 54E5083C  slwi r5, r7, 1
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 8219C440: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C444: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219C448: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C44C: 7CE72A14  add r7, r7, r5
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[5].u64;
	// 8219C450: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C454: C14BFFD8  lfs f10, -0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-40 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219C458: 38630002  addi r3, r3, 2
	ctx.r[3].s64 = ctx.r[3].s64 + 2;
	// 8219C45C: 54E72036  slwi r7, r7, 4
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8219C460: 7CC73214  add r6, r7, r6
	ctx.r[6].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 8219C464: D146000C  stfs f10, 0xc(r6)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8219C468: C14BFFD0  lfs f10, -0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219C46C: EDAA683A  fmadds f13, f10, f0, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8219C470: C12BFFD4  lfs f9, -0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-44 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8219C474: C1480000  lfs f10, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219C478: ED89603A  fmadds f12, f9, f0, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8219C47C: ED6A583A  fmadds f11, f10, f0, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 8219C480: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8219C484: D1660000  stfs f11, 0(r6)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219C488: D1860008  stfs f12, 8(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219C48C: 80C900B8  lwz r6, 0xb8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C490: C18A001C  lfs f12, 0x1c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C494: C1ABFFE8  lfs f13, -0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C498: 7CC73214  add r6, r7, r6
	ctx.r[6].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 8219C49C: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 8219C4A0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C4A4: D1A6001C  stfs f13, 0x1c(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C4A8: C1AA0034  lfs f13, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C4AC: 80C900B8  lwz r6, 0xb8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C4B0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C4B4: C16A0030  lfs f11, 0x30(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219C4B8: 7CC73214  add r6, r7, r6
	ctx.r[6].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 8219C4BC: C18A0038  lfs f12, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C4C0: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C4C4: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219C4C8: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C4CC: D146003C  stfs f10, 0x3c(r6)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8219C4D0: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219C4D4: C12B0004  lfs f9, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8219C4D8: EDAA683A  fmadds f13, f10, f0, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8219C4DC: C14BFFFC  lfs f10, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219C4E0: ED6A583A  fmadds f11, f10, f0, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 8219C4E4: D1660030  stfs f11, 0x30(r6)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8219C4E8: D1A60034  stfs f13, 0x34(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8219C4EC: ED89603A  fmadds f12, f9, f0, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8219C4F0: D1860038  stfs f12, 0x38(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8219C4F4: 80C900B8  lwz r6, 0xb8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C4F8: C18A004C  lfs f12, 0x4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C4FC: C1AB0018  lfs f13, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C500: 7D473214  add r10, r7, r6
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 8219C504: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 8219C508: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C50C: D1AA004C  stfs f13, 0x4c(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 8219C510: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8219C514: 808900B8  lwz r4, 0xb8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C518: 7D064378  mr r6, r8
	ctx.r[6].u64 = ctx.r[8].u64;
	// 8219C51C: 54FE083C  slwi r30, r7, 1
	ctx.r[30].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 8219C520: 38ABFFFC  addi r5, r11, -4
	ctx.r[5].s64 = ctx.r[11].s64 + -4;
	// 8219C524: 7CE7F214  add r7, r7, r30
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[30].u64;
	// 8219C528: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 8219C52C: 54E72036  slwi r7, r7, 4
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8219C530: EBA60000  ld r29, 0(r6)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	// 8219C534: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 8219C538: 7C872214  add r4, r7, r4
	ctx.r[4].u64 = ctx.r[7].u64 + ctx.r[4].u64;
	// 8219C53C: 38630002  addi r3, r3, 2
	ctx.r[3].s64 = ctx.r[3].s64 + 2;
	// 8219C540: 39080060  addi r8, r8, 0x60
	ctx.r[8].s64 = ctx.r[8].s64 + 96;
	// 8219C544: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8219C548: FBA40000  std r29, 0(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[29].u64 ) };
	// 8219C54C: E8C60008  ld r6, 8(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	// 8219C550: F8C40008  std r6, 8(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[6].u64 ) };
	// 8219C554: C1ABFFE8  lfs f13, -0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C558: 80C900B8  lwz r6, 0xb8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C55C: 7CC73214  add r6, r7, r6
	ctx.r[6].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 8219C560: D1A6001C  stfs f13, 0x1c(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C564: 80C900B8  lwz r6, 0xb8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C568: E8850000  ld r4, 0(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	// 8219C56C: 7CC73214  add r6, r7, r6
	ctx.r[6].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 8219C570: 38C60030  addi r6, r6, 0x30
	ctx.r[6].s64 = ctx.r[6].s64 + 48;
	// 8219C574: F8860000  std r4, 0(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[4].u64 ) };
	// 8219C578: E8A50008  ld r5, 8(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	// 8219C57C: F8A60008  std r5, 8(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	// 8219C580: C1AB0018  lfs f13, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C584: 80C900B8  lwz r6, 0xb8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C588: 396B0060  addi r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 + 96;
	// 8219C58C: 7CE73214  add r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 8219C590: D1A7004C  stfs f13, 0x4c(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 8219C594: 409AFE90  bne cr6, 0x8219c424
	if !ctx.cr[6].eq {
	pc = 0x8219C424; continue 'dispatch;
	}
	// 8219C598: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219C59C: 419A0018  beq cr6, 0x8219c5b4
	if ctx.cr[6].eq {
	pc = 0x8219C5B4; continue 'dispatch;
	}
	// 8219C5A0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219C5A4: 80C900B8  lwz r6, 0xb8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C5A8: 38A90088  addi r5, r9, 0x88
	ctx.r[5].s64 = ctx.r[9].s64 + 136;
	// 8219C5AC: 38890080  addi r4, r9, 0x80
	ctx.r[4].s64 = ctx.r[9].s64 + 128;
	// 8219C5B0: 481D09C9  bl 0x8236cf78
	ctx.lr = 0x8219C5B4;
	sub_8236CF78(ctx, base);
	// 8219C5B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219C5B8: 48398B54  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C5C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219C5C0 size=168
    let mut pc: u32 = 0x8219C5C0;
    'dispatch: loop {
        match pc {
            0x8219C5C0 => {
    //   block [0x8219C5C0..0x8219C668)
	// 8219C5C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219C5C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219C5C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219C5CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219C5D0: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 8219C5D4: 80E40084  lwz r7, 0x84(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(132 as u32) ) } as u64;
	// 8219C5D8: 80C40080  lwz r6, 0x80(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219C5DC: FD000890  fmr f8, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[8].f64 = ctx.f[1].f64;
	// 8219C5E0: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8219C5E4: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 8219C5E8: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8219C5EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C5F0: 409A001C  bne cr6, 0x8219c60c
	if !ctx.cr[6].eq {
	pc = 0x8219C60C; continue 'dispatch;
	}
	// 8219C5F4: 48013465  bl 0x821afa58
	ctx.lr = 0x8219C5F8;
	sub_821AFA58(ctx, base);
	// 8219C5F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219C5FC: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 8219C600: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C604: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8219C608: 40990008  ble cr6, 0x8219c610
	if !ctx.cr[6].gt {
	pc = 0x8219C610; continue 'dispatch;
	}
	// 8219C60C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8219C610: 38A00007  li r5, 7
	ctx.r[5].s64 = 7;
	// 8219C614: 554AF87E  srwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219C618: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 8219C61C: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8219C620: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 8219C624: 54C6F87E  srwi r6, r6, 1
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shr(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8219C628: 54E7F87E  srwi r7, r7, 1
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8219C62C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C630: 409A0014  bne cr6, 0x8219c644
	if !ctx.cr[6].eq {
	pc = 0x8219C644; continue 'dispatch;
	}
	// 8219C634: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 8219C638: FC204090  fmr f1, f8
	ctx.f[1].f64 = ctx.f[8].f64;
	// 8219C63C: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 8219C640: 48013419  bl 0x821afa58
	ctx.lr = 0x8219C644;
	sub_821AFA58(ctx, base);
	// 8219C644: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 8219C648: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8219C64C: 409AFFC8  bne cr6, 0x8219c614
	if !ctx.cr[6].eq {
	pc = 0x8219C614; continue 'dispatch;
	}
	// 8219C650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219C654: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219C658: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219C65C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219C660: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219C664: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8219C668 size=96
    let mut pc: u32 = 0x8219C668;
    'dispatch: loop {
        match pc {
            0x8219C668 => {
    //   block [0x8219C668..0x8219C6C8)
	// 8219C668: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219C66C: D0A3000C  stfs f5, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8219C670: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 8219C674: D0830010  stfs f4, 0x10(r3)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C678: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 8219C67C: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C680: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219C684: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8219C688: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8219C68C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8219C690: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C694: 41990008  bgt cr6, 0x8219c69c
	if ctx.cr[6].gt {
	pc = 0x8219C69C; continue 'dispatch;
	}
	// 8219C698: FC206890  fmr f1, f13
	ctx.f[1].f64 = ctx.f[13].f64;
	// 8219C69C: FF030000  fcmpu cr6, f3, f0
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[0].f64);
	// 8219C6A0: 41990008  bgt cr6, 0x8219c6a8
	if ctx.cr[6].gt {
	pc = 0x8219C6A8; continue 'dispatch;
	}
	// 8219C6A4: FC606890  fmr f3, f13
	ctx.f[3].f64 = ctx.f[13].f64;
	// 8219C6A8: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C6AC: EC040028  fsubs f0, f4, f0
	ctx.f[0].f64 = (((ctx.f[4].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C6B0: D023001C  stfs f1, 0x1c(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C6B4: D0430020  stfs f2, 0x20(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C6B8: D0630024  stfs f3, 0x24(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C6BC: EC000824  fdivs f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 8219C6C0: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C6C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8219C6C8 size=32
    let mut pc: u32 = 0x8219C6C8;
    'dispatch: loop {
        match pc {
            0x8219C6C8 => {
    //   block [0x8219C6C8..0x8219C6E8)
	// 8219C6C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C6CC: C0230008  lfs f1, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219C6D0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8219C6D4: 419A00C8  beq cr6, 0x8219c79c
	if ctx.cr[6].eq {
		sub_8219C79C(ctx, base);
		return;
	}
	// 8219C6D8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8219C6DC: 419A0048  beq cr6, 0x8219c724
	if ctx.cr[6].eq {
		sub_8219C724(ctx, base);
		return;
	}
	// 8219C6E0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 8219C6E4: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8219C6E8 size=60
    let mut pc: u32 = 0x8219C6E8;
    'dispatch: loop {
        match pc {
            0x8219C6E8 => {
    //   block [0x8219C6E8..0x8219C724)
	// 8219C6E8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219C6EC: C1A30018  lfs f13, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C6F0: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219C6F4: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219C6F8: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 8219C6FC: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C700: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219C704: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C708: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C70C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8219C710: 4199000C  bgt cr6, 0x8219c71c
	if ctx.cr[6].gt {
	pc = 0x8219C71C; continue 'dispatch;
	}
	// 8219C714: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219C718: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219C71C: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C720: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C724(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8219C724 size=120
    let mut pc: u32 = 0x8219C724;
    'dispatch: loop {
        match pc {
            0x8219C724 => {
    //   block [0x8219C724..0x8219C79C)
	// 8219C724: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219C728: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C72C: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219C730: C1830010  lfs f12, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C734: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219C738: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 8219C73C: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C740: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219C744: EC200B7A  fmadds f1, f0, f13, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64);
	// 8219C748: C16B1FF8  lfs f11, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219C74C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 8219C750: 4098000C  bge cr6, 0x8219c75c
	if !ctx.cr[6].lt {
	pc = 0x8219C75C; continue 'dispatch;
	}
	// 8219C754: FF016000  fcmpu cr6, f1, f12
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[12].f64);
	// 8219C758: 40990014  ble cr6, 0x8219c76c
	if !ctx.cr[6].gt {
	pc = 0x8219C76C; continue 'dispatch;
	}
	// 8219C75C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 8219C760: 41980090  blt cr6, 0x8219c7f0
	if ctx.cr[6].lt {
		sub_8219C79C(ctx, base);
		return;
	}
	// 8219C764: FF016000  fcmpu cr6, f1, f12
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[12].f64);
	// 8219C768: 41980088  blt cr6, 0x8219c7f0
	if ctx.cr[6].lt {
		sub_8219C79C(ctx, base);
		return;
	}
	// 8219C76C: C003000C  lfs f0, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C770: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219C774: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 8219C778: C1A30024  lfs f13, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C77C: C1630020  lfs f11, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219C780: FC206090  fmr f1, f12
	ctx.f[1].f64 = ctx.f[12].f64;
	// 8219C784: D1630018  stfs f11, 0x18(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C788: D0230008  stfs f1, 8(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219C78C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219C790: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8219C794: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C798: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C79C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8219C79C size=92
    let mut pc: u32 = 0x8219C79C;
    'dispatch: loop {
        match pc {
            0x8219C79C => {
    //   block [0x8219C79C..0x8219C7F8)
	// 8219C79C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219C7A0: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C7A4: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219C7A8: C163000C  lfs f11, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219C7AC: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219C7B0: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 8219C7B4: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C7B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219C7BC: EC200B7A  fmadds f1, f0, f13, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64);
	// 8219C7C0: C18B1FF8  lfs f12, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C7C4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8219C7C8: 4198000C  blt cr6, 0x8219c7d4
	if ctx.cr[6].lt {
	pc = 0x8219C7D4; continue 'dispatch;
	}
	// 8219C7CC: FF015800  fcmpu cr6, f1, f11
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[11].f64);
	// 8219C7D0: 40980014  bge cr6, 0x8219c7e4
	if !ctx.cr[6].lt {
	pc = 0x8219C7E4; continue 'dispatch;
	}
	// 8219C7D4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8219C7D8: 40980018  bge cr6, 0x8219c7f0
	if !ctx.cr[6].lt {
	pc = 0x8219C7F0; continue 'dispatch;
	}
	// 8219C7DC: FF015800  fcmpu cr6, f1, f11
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[11].f64);
	// 8219C7E0: 41990010  bgt cr6, 0x8219c7f0
	if ctx.cr[6].gt {
	pc = 0x8219C7F0; continue 'dispatch;
	}
	// 8219C7E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219C7E8: FC205890  fmr f1, f11
	ctx.f[1].f64 = ctx.f[11].f64;
	// 8219C7EC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219C7F0: D0230008  stfs f1, 8(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219C7F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219C7F8 size=308
    let mut pc: u32 = 0x8219C7F8;
    'dispatch: loop {
        match pc {
            0x8219C7F8 => {
    //   block [0x8219C7F8..0x8219C92C)
	// 8219C7F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219C7FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219C800: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219C804: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219C808: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219C80C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8219C810: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8219C814: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 8219C818: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 8219C81C: 4198FFF0  blt cr6, 0x8219c80c
	if ctx.cr[6].lt {
	pc = 0x8219C80C; continue 'dispatch;
	}
	// 8219C820: 55432036  slwi r3, r10, 4
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8219C824: 4839744D  bl 0x82533c70
	ctx.lr = 0x8219C828;
	sub_82533C70(ctx, base);
	// 8219C828: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219C82C: 419A00FC  beq cr6, 0x8219c928
	if ctx.cr[6].eq {
	pc = 0x8219C928; continue 'dispatch;
	}
	// 8219C830: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219C834: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 8219C838: 38EB1340  addi r7, r11, 0x1340
	ctx.r[7].s64 = ctx.r[11].s64 + 4928;
	// 8219C83C: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 8219C840: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8219C844: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8219C848: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219C84C: C105BA38  lfs f8, -0x45c8(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8219C850: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219C854: C0A6219C  lfs f5, 0x219c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8604 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 8219C858: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 8219C85C: C1282120  lfs f9, 0x2120(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8480 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8219C860: C0C9BFFC  lfs f6, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 8219C864: C08B1FF8  lfs f4, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219C868: 7D4B07B4  extsw r11, r10
	ctx.r[11].s64 = ctx.r[10].s32 as i64;
	// 8219C86C: FC002090  fmr f0, f4
	ctx.f[0].f64 = ctx.f[4].f64;
	// 8219C870: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219C874: 90670000  stw r3, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 8219C878: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8219C87C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219C880: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219C884: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8219C888: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8219C88C: ECE86824  fdivs f7, f8, f13
	ctx.f[7].f64 = ((ctx.f[8].f64 / ctx.f[13].f64) as f32) as f64;
	// 8219C890: 4198006C  blt cr6, 0x8219c8fc
	if ctx.cr[6].lt {
	pc = 0x8219C8FC; continue 'dispatch;
	}
	// 8219C894: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 8219C898: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 8219C89C: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 8219C8A0: ED680028  fsubs f11, f8, f0
	ctx.f[11].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C8A4: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 8219C8A8: EDA001B2  fmuls f13, f0, f6
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[6].f64) as f32) as f64);
	// 8219C8AC: ED800032  fmuls f12, f0, f0
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C8B0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219C8B4: EC6B02F2  fmuls f3, f11, f11
	ctx.f[3].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 8219C8B8: ED4C0372  fmuls f10, f12, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219C8BC: EC4C0032  fmuls f2, f12, f0
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C8C0: ED6302F2  fmuls f11, f3, f11
	ctx.f[11].f64 = (((ctx.f[3].f64 * ctx.f[11].f64) as f32) as f64);
	// 8219C8C4: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 8219C8C8: EC620272  fmuls f3, f2, f9
	ctx.f[3].f64 = (((ctx.f[2].f64 * ctx.f[9].f64) as f32) as f64);
	// 8219C8CC: D06B0004  stfs f3, 4(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8219C8D0: ED6B0272  fmuls f11, f11, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[9].f64) as f32) as f64);
	// 8219C8D4: D16BFFF8  stfs f11, -8(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 8219C8D8: ED6D5038  fmsubs f11, f13, f0, f10
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 8219C8DC: ED8C282A  fadds f12, f12, f5
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[5].f64) as f32) as f64;
	// 8219C8E0: D18BFFFC  stfs f12, -4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 8219C8E4: EC07002A  fadds f0, f7, f0
	ctx.f[0].f64 = ((ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64;
	// 8219C8E8: EDAB682A  fadds f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 8219C8EC: EDAD482A  fadds f13, f13, f9
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[9].f64) as f32) as f64;
	// 8219C8F0: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219C8F4: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 8219C8F8: 409AFFA8  bne cr6, 0x8219c8a0
	if !ctx.cr[6].eq {
	pc = 0x8219C8A0; continue 'dispatch;
	}
	// 8219C8FC: 3884FFFF  addi r4, r4, -1
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	// 8219C900: 550B2036  slwi r11, r8, 4
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219C904: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 8219C908: 7C6B1A14  add r3, r11, r3
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 8219C90C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8219C910: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8219C914: 409AFF54  bne cr6, 0x8219c868
	if !ctx.cr[6].eq {
	pc = 0x8219C868; continue 'dispatch;
	}
	// 8219C918: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219C91C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219C920: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219C924: 4E800020  blr
	return;
	// 8219C928: 48000000  b 0x8219c928
	pc = 0x8219C928; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8219C930 size=352
    let mut pc: u32 = 0x8219C930;
    'dispatch: loop {
        match pc {
            0x8219C930 => {
    //   block [0x8219C930..0x8219CA90)
	// 8219C930: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 8219C934: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219C938: 90E10034  stw r7, 0x34(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(52 as u32), ctx.r[7].u32 ) };
	// 8219C93C: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219C940: 396B1340  addi r11, r11, 0x1340
	ctx.r[11].s64 = ctx.r[11].s64 + 4928;
	// 8219C944: 38E5FFFF  addi r7, r5, -1
	ctx.r[7].s64 = ctx.r[5].s64 + -1;
	// 8219C948: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8219C94C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8219C950: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 8219C954: 7CAA582E  lwzx r5, r10, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219C958: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 8219C95C: 41980118  blt cr6, 0x8219ca74
	if ctx.cr[6].lt {
	pc = 0x8219CA74; continue 'dispatch;
	}
	// 8219C960: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 8219C964: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219C968: 39640018  addi r11, r4, 0x18
	ctx.r[11].s64 = ctx.r[4].s64 + 24;
	// 8219C96C: C1A9BA38  lfs f13, -0x45c8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C970: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C974: C1840000  lfs f12, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C978: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 8219C97C: D181FFB0  stfs f12, -0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), tmp.u32 ) };
	// 8219C980: C18BFFEC  lfs f12, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C984: D181FFB4  stfs f12, -0x4c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-76 as u32), tmp.u32 ) };
	// 8219C988: C18BFFF0  lfs f12, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C98C: D181FFB8  stfs f12, -0x48(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), tmp.u32 ) };
	// 8219C990: C18BFFF8  lfs f12, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C994: D181FFC0  stfs f12, -0x40(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), tmp.u32 ) };
	// 8219C998: C18BFFFC  lfs f12, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C99C: D181FFC4  stfs f12, -0x3c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-60 as u32), tmp.u32 ) };
	// 8219C9A0: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C9A4: D181FFC8  stfs f12, -0x38(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), tmp.u32 ) };
	// 8219C9A8: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C9AC: D181FFD0  stfs f12, -0x30(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), tmp.u32 ) };
	// 8219C9B0: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C9B4: D181FFD4  stfs f12, -0x2c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-44 as u32), tmp.u32 ) };
	// 8219C9B8: C18B0010  lfs f12, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C9BC: D181FFD8  stfs f12, -0x28(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), tmp.u32 ) };
	// 8219C9C0: C18B0018  lfs f12, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C9C4: D181FFE0  stfs f12, -0x20(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 8219C9C8: C18B001C  lfs f12, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C9CC: D181FFE4  stfs f12, -0x1c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), tmp.u32 ) };
	// 8219C9D0: C18B0020  lfs f12, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C9D4: D001FFBC  stfs f0, -0x44(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-68 as u32), tmp.u32 ) };
	// 8219C9D8: D001FFCC  stfs f0, -0x34(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-52 as u32), tmp.u32 ) };
	// 8219C9DC: D001FFDC  stfs f0, -0x24(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-36 as u32), tmp.u32 ) };
	// 8219C9E0: D1A1FFEC  stfs f13, -0x14(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-20 as u32), tmp.u32 ) };
	// 8219C9E4: D181FFE8  stfs f12, -0x18(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), tmp.u32 ) };
	// 8219C9E8: 409A0008  bne cr6, 0x8219c9f0
	if !ctx.cr[6].eq {
	pc = 0x8219C9F0; continue 'dispatch;
	}
	// 8219C9EC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 8219C9F0: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 8219C9F4: 4099006C  ble cr6, 0x8219ca60
	if !ctx.cr[6].gt {
	pc = 0x8219CA60; continue 'dispatch;
	}
	// 8219C9F8: 3BE1FFE0  addi r31, r1, -0x20
	ctx.r[31].s64 = ctx.r[1].s64 + -32;
	// 8219C9FC: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 8219CA00: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 8219CA04: 7C633214  add r3, r3, r6
	ctx.r[3].u64 = ctx.r[3].u64 + ctx.r[6].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219CA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219CA90 size=300
    let mut pc: u32 = 0x8219CA90;
    'dispatch: loop {
        match pc {
            0x8219CA90 => {
    //   block [0x8219CA90..0x8219CBBC)
	// 8219CA90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219CA94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219CA98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219CA9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219CAA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219CAA4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219CAA8: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 8219CAAC: 816BBECC  lwz r11, -0x4134(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16692 as u32) ) } as u64;
	// 8219CAB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219CAB4: 409A0028  bne cr6, 0x8219cadc
	if !ctx.cr[6].eq {
	pc = 0x8219CADC; continue 'dispatch;
	}
	// 8219CAB8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219CABC: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 8219CAC0: 814BBED0  lwz r10, -0x4130(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16688 as u32) ) } as u64;
	// 8219CAC4: 394A0100  addi r10, r10, 0x100
	ctx.r[10].s64 = ctx.r[10].s64 + 256;
	// 8219CAC8: 914BBED0  stw r10, -0x4130(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16688 as u32), ctx.r[10].u32 ) };
	// 8219CACC: 483971A5  bl 0x82533c70
	ctx.lr = 0x8219CAD0;
	sub_82533C70(ctx, base);
	// 8219CAD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219CAD4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8219CAD8: 409A000C  bne cr6, 0x8219cae4
	if !ctx.cr[6].eq {
	pc = 0x8219CAE4; continue 'dispatch;
	}
	// 8219CADC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8219CAE0: 480000C4  b 0x8219cba4
	pc = 0x8219CBA4; continue 'dispatch;
	// 8219CAE4: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8219CAE8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8219CAEC: 396BFBB0  addi r11, r11, -0x450
	ctx.r[11].s64 = ctx.r[11].s64 + -1104;
	// 8219CAF0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8219CAF4: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 8219CAF8: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219CAFC: C0291FF8  lfs f1, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219CB00: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219CB04: 396B20B0  addi r11, r11, 0x20b0
	ctx.r[11].s64 = ctx.r[11].s64 + 8368;
	// 8219CB08: C04ABA38  lfs f2, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219CB0C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8219CB10: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219CB14: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 8219CB18: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8219CB1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219CB20: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8219CB24: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8219CB28: 480130B9  bl 0x821afbe0
	ctx.lr = 0x8219CB2C;
	sub_821AFBE0(ctx, base);
	// 8219CB2C: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 8219CB30: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219CB34: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219CB38: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 8219CB3C: 3BC00010  li r30, 0x10
	ctx.r[30].s64 = 16;
	// 8219CB40: C169D6D0  lfs f11, -0x2930(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10544 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219CB44: C18A20C8  lfs f12, 0x20c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8392 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219CB48: C1AB2280  lfs f13, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CB4C: 481CA5ED  bl 0x82367138
	ctx.lr = 0x8219CB50;
	sub_82367138(ctx, base);
	// 8219CB50: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219CB54: C144FFF8  lfs f10, -8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219CB58: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 8219CB5C: C124FFFC  lfs f9, -4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8219CB60: C1040000  lfs f8, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8219CB64: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219CB68: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219CB6C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219CB70: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8219CB74: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219CB78: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219CB7C: EC005B3A  fmadds f0, f0, f12, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 8219CB80: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CB84: D144FFF8  stfs f10, -8(r4)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 8219CB88: ED490032  fmuls f10, f9, f0
	ctx.f[10].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CB8C: D144FFFC  stfs f10, -4(r4)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 8219CB90: EC080032  fmuls f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CB94: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219CB98: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 8219CB9C: 409AFFB0  bne cr6, 0x8219cb4c
	if !ctx.cr[6].eq {
	pc = 0x8219CB4C; continue 'dispatch;
	}
	// 8219CBA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219CBA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219CBA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219CBAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219CBB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219CBB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219CBB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219CBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219CBC0 size=712
    let mut pc: u32 = 0x8219CBC0;
    'dispatch: loop {
        match pc {
            0x8219CBC0 => {
    //   block [0x8219CBC0..0x8219CE88)
	// 8219CBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219CBC4: 483984F9  bl 0x825350bc
	ctx.lr = 0x8219CBC8;
	sub_82535080(ctx, base);
	// 8219CBC8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8219CBCC: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219CBD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219CBD4: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 8219CBD8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8219CBDC: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 8219CBE0: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 8219CBE4: 481CB505  bl 0x823680e8
	ctx.lr = 0x8219CBE8;
	sub_823680E8(ctx, base);
	// 8219CBE8: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CBEC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8219CBF0: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8219CBF4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8219CBF8: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CBFC: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8219CC00: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8219CC04: C0010070  lfs f0, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CC08: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8219CC0C: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8219CC10: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CC14: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8219CC18: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8219CC1C: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CC20: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8219CC24: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8219CC28: C0010074  lfs f0, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CC2C: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8219CC30: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8219CC34: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CC38: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8219CC3C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8219CC40: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CC44: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8219CC48: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8219CC4C: C0010078  lfs f0, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CC50: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8219CC54: C07E0008  lfs f3, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8219CC58: C05E0004  lfs f2, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219CC5C: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219CC60: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8219CC64: 481CB5B5  bl 0x82368218
	ctx.lr = 0x8219CC68;
	sub_82368218(ctx, base);
	// 8219CC68: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 8219CC6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8219CC70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219CC74: 481CB17D  bl 0x82367df0
	ctx.lr = 0x8219CC78;
	sub_82367DF0(ctx, base);
	// 8219CC78: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8219CC7C: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CC80: 394BD030  addi r10, r11, -0x2fd0
	ctx.r[10].s64 = ctx.r[11].s64 + -12240;
	// 8219CC84: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8219CC88: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CC8C: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219CC90: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8219CC94: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CC98: 392B20B0  addi r9, r11, 0x20b0
	ctx.r[9].s64 = ctx.r[11].s64 + 8368;
	// 8219CC9C: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CCA0: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219CCA4: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8219CCA8: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CCAC: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8219CCB0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219CCB4: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CCB8: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219CCBC: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219CCC0: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8219CCC4: C1A10070  lfs f13, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CCC8: 2F090004  cmpwi cr6, r9, 4
	ctx.cr[6].compare_i32(ctx.r[9].s32, 4, &mut ctx.xer);
	// 8219CCCC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CCD0: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8219CCD4: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CCD8: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CCDC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CCE0: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8219CCE4: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CCE8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CCEC: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8219CCF0: C1A10074  lfs f13, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CCF4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CCF8: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8219CCFC: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CD00: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CD04: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CD08: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8219CD0C: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CD10: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CD14: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8219CD18: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8219CD1C: C1A10078  lfs f13, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CD20: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CD24: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8219CD28: C00ABA38  lfs f0, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CD2C: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8219CD30: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219CE88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219CE88 size=608
    let mut pc: u32 = 0x8219CE88;
    'dispatch: loop {
        match pc {
            0x8219CE88 => {
    //   block [0x8219CE88..0x8219D064)
	// 8219CE88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219CE8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219CE90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219CE94: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8219CE98: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 8219CE9C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8219CEA0: 40980040  bge cr6, 0x8219cee0
	if !ctx.cr[6].lt {
	pc = 0x8219CEE0; continue 'dispatch;
	}
	// 8219CEA4: 21250001  subfic r9, r5, 1
	ctx.xer.ca = ctx.r[5].u32 <= 1 as u32;
	ctx.r[9].s64 = (1 as i64) - ctx.r[5].s64;
	// 8219CEA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219CEAC: 419A0228  beq cr6, 0x8219d0d4
	if ctx.cr[6].eq {
	pc = 0x8219D0D4; continue 'dispatch;
	}
	// 8219CEB0: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219CEB4: 396BB790  addi r11, r11, -0x4870
	ctx.r[11].s64 = ctx.r[11].s64 + -18544;
	// 8219CEB8: C08B000C  lfs f4, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219CEBC: C06B0008  lfs f3, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8219CEC0: C04B0004  lfs f2, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219CEC4: C02B0000  lfs f1, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219CEC8: 481E59B1  bl 0x82382878
	ctx.lr = 0x8219CECC;
	sub_82382878(ctx, base);
	// 8219CECC: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 8219CED0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219CED4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219CED8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219CEDC: 4E800020  blr
	return;
	// 8219CEE0: 2F050100  cmpwi cr6, r5, 0x100
	ctx.cr[6].compare_i32(ctx.r[5].s32, 256, &mut ctx.xer);
	// 8219CEE4: 41980048  blt cr6, 0x8219cf2c
	if ctx.cr[6].lt {
	pc = 0x8219CF2C; continue 'dispatch;
	}
	// 8219CEE8: 3945FF00  addi r10, r5, -0x100
	ctx.r[10].s64 = ctx.r[5].s64 + -256;
	// 8219CEEC: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219CEF0: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219CEF4: 396BB790  addi r11, r11, -0x4870
	ctx.r[11].s64 = ctx.r[11].s64 + -18544;
	// 8219CEF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219CEFC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219CF00: 419A01D4  beq cr6, 0x8219d0d4
	if ctx.cr[6].eq {
	pc = 0x8219D0D4; continue 'dispatch;
	}
	// 8219CF04: C08B000C  lfs f4, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219CF08: C06B0008  lfs f3, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8219CF0C: C04B0004  lfs f2, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219CF10: C02B0000  lfs f1, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219CF14: 481E5965  bl 0x82382878
	ctx.lr = 0x8219CF18;
	sub_82382878(ctx, base);
	// 8219CF18: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 8219CF1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219CF20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219CF24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219CF28: 4E800020  blr
	return;
	// 8219CF2C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219CF30: 3965FF40  addi r11, r5, -0xc0
	ctx.r[11].s64 = ctx.r[5].s64 + -192;
	// 8219CF34: 2B0B003F  cmplwi cr6, r11, 0x3f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 63 as u32, &mut ctx.xer);
	// 8219CF38: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CF3C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8219CF40: C18ABA38  lfs f12, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219CF44: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	// 8219CF48: 4199014C  bgt cr6, 0x8219d094
	if ctx.cr[6].gt {
	pc = 0x8219D094; continue 'dispatch;
	}
	// 8219CF4C: 3D80821A  lis r12, -0x7de6
	ctx.r[12].s64 = -2112225280;
	// 8219CF50: 398CCF64  addi r12, r12, -0x309c
	ctx.r[12].s64 = ctx.r[12].s64 + -12444;
	// 8219CF54: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8219CF58: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8219CF5C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8219CF60: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x8219D064; continue 'dispatch;
		},
		1 => {
	pc = 0x8219D064; continue 'dispatch;
		},
		2 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		3 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		4 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		5 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		6 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		7 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		8 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		9 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		10 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		11 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		12 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		13 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		14 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		15 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		16 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		17 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		18 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		19 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		20 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		21 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		22 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		23 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		24 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		25 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		26 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		27 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		28 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		29 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		30 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		31 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		32 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		33 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		34 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		35 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		36 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		37 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		38 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		39 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		40 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		41 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		42 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		43 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		44 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		45 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		46 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		47 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		48 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		49 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		50 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		51 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		52 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		53 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		54 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		55 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		56 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		57 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		58 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		59 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		60 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		61 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		62 => {
	pc = 0x8219D0BC; continue 'dispatch;
		},
		63 => {
	pc = 0x8219D06C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8219CF64: 8219D064  lwz r16, -0x2f9c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12188 as u32) ) } as u64;
	// 8219CF68: 8219D064  lwz r16, -0x2f9c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12188 as u32) ) } as u64;
	// 8219CF6C: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF70: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF74: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF78: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF7C: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF80: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF84: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF88: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF8C: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF90: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF94: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF98: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF9C: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFA0: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFA4: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFA8: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFAC: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFB0: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFB4: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFB8: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFBC: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFC0: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFC4: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFC8: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFCC: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFD0: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFD4: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFD8: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFDC: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFE0: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFE4: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFE8: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFEC: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFF0: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFF4: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFF8: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFFC: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D000: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D004: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D008: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D00C: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D010: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D014: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D018: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D01C: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D020: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D024: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D028: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D02C: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D030: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D034: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D038: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D03C: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D040: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D044: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D048: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D04C: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D050: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D054: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D058: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D05C: 8219D0BC  lwz r16, -0x2f44(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12100 as u32) ) } as u64;
	// 8219D060: 8219D06C  lwz r16, -0x2f94(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12180 as u32) ) } as u64;
            }
            0x8219D064 => {
    //   block [0x8219D064..0x8219D06C)
	// 8219D064: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 8219D068: 48000054  b 0x8219d0bc
	pc = 0x8219D0BC; continue 'dispatch;
            }
            0x8219D06C => {
    //   block [0x8219D06C..0x8219D094)
	// 8219D06C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219D070: 419AFFF4  beq cr6, 0x8219d064
	if ctx.cr[6].eq {
	pc = 0x8219D064; continue 'dispatch;
	}
	// 8219D074: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219D078: 616ABEB8  ori r10, r11, 0xbeb8
	ctx.r[10].u64 = ctx.r[11].u64 | 48824;
	// 8219D07C: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219D080: 396BA510  addi r11, r11, -0x5af0
	ctx.r[11].s64 = ctx.r[11].s64 + -23280;
	// 8219D084: 7D47522E  lhzx r10, r7, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219D088: 554A303E  rotlwi r10, r10, 6
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(6)) as u64;
	// 8219D08C: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D090: 4800002C  b 0x8219d0bc
	pc = 0x8219D0BC; continue 'dispatch;
            }
            0x8219D094 => {
    //   block [0x8219D094..0x8219D0BC)
	// 8219D094: 2F0500C1  cmpwi cr6, r5, 0xc1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 193, &mut ctx.xer);
	// 8219D098: 40980024  bge cr6, 0x8219d0bc
	if !ctx.cr[6].lt {
	pc = 0x8219D0BC; continue 'dispatch;
	}
	// 8219D09C: 7CAB07B4  extsw r11, r5
	ctx.r[11].s64 = ctx.r[5].s32 as i64;
	// 8219D0A0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219D0A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219D0A8: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219D0AC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8219D0B0: FD600018  frsp f11, f0
	ctx.f[11].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219D0B4: C00B2050  lfs f0, 0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D0B8: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x8219D0BC; continue 'dispatch;
            }
            0x8219D0BC => {
    //   block [0x8219D0BC..0x8219D0E8)
	// 8219D0BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219D0C0: 419A0014  beq cr6, 0x8219d0d4
	if ctx.cr[6].eq {
	pc = 0x8219D0D4; continue 'dispatch;
	}
	// 8219D0C4: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219D0C8: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8219D0CC: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219D0D0: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8219D0D4: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 8219D0D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219D0DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219D0E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219D0E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D0E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219D0E8 size=352
    let mut pc: u32 = 0x8219D0E8;
    'dispatch: loop {
        match pc {
            0x8219D0E8 => {
    //   block [0x8219D0E8..0x8219D248)
	// 8219D0E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219D0EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219D0F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219D0F4: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 8219D0F8: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8219D0FC: 40980038  bge cr6, 0x8219d134
	if !ctx.cr[6].lt {
	pc = 0x8219D134; continue 'dispatch;
	}
	// 8219D100: 20650001  subfic r3, r5, 1
	ctx.xer.ca = ctx.r[5].u32 <= 1 as u32;
	ctx.r[3].s64 = (1 as i64) - ctx.r[5].s64;
	// 8219D104: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8219D108: 419A0130  beq cr6, 0x8219d238
	if ctx.cr[6].eq {
	pc = 0x8219D238; continue 'dispatch;
	}
	// 8219D10C: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219D110: 396BB790  addi r11, r11, -0x4870
	ctx.r[11].s64 = ctx.r[11].s64 + -18544;
	// 8219D114: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8219D118: F9440000  std r10, 0(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 8219D11C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 8219D120: F9640008  std r11, 8(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8219D124: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219D128: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219D12C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219D130: 4E800020  blr
	return;
	// 8219D134: 2F050100  cmpwi cr6, r5, 0x100
	ctx.cr[6].compare_i32(ctx.r[5].s32, 256, &mut ctx.xer);
	// 8219D138: 41980044  blt cr6, 0x8219d17c
	if ctx.cr[6].lt {
	pc = 0x8219D17C; continue 'dispatch;
	}
	// 8219D13C: 3945FF00  addi r10, r5, -0x100
	ctx.r[10].s64 = ctx.r[5].s64 + -256;
	// 8219D140: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219D144: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219D148: 396BB790  addi r11, r11, -0x4870
	ctx.r[11].s64 = ctx.r[11].s64 + -18544;
	// 8219D14C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8219D150: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219D154: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 8219D158: 419A00E0  beq cr6, 0x8219d238
	if ctx.cr[6].eq {
	pc = 0x8219D238; continue 'dispatch;
	}
	// 8219D15C: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8219D160: F9440000  std r10, 0(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 8219D164: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 8219D168: F9640008  std r11, 8(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8219D16C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219D170: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219D174: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219D178: 4E800020  blr
	return;
	// 8219D17C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219D180: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8219D184: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D188: 419A0018  beq cr6, 0x8219d1a0
	if ctx.cr[6].eq {
	pc = 0x8219D1A0; continue 'dispatch;
	}
	// 8219D18C: C0260000  lfs f1, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219D190: C0460004  lfs f2, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219D194: C0660008  lfs f3, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8219D198: C086000C  lfs f4, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219D19C: 48000018  b 0x8219d1b4
	pc = 0x8219D1B4; continue 'dispatch;
	// 8219D1A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219D1A4: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 8219D1A8: C08BBA38  lfs f4, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219D1AC: FC602090  fmr f3, f4
	ctx.f[3].f64 = ctx.f[4].f64;
	// 8219D1B0: FC402090  fmr f2, f4
	ctx.f[2].f64 = ctx.f[4].f64;
	// 8219D1B4: 2F0500C0  cmpwi cr6, r5, 0xc0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 192, &mut ctx.xer);
	// 8219D1B8: 41980044  blt cr6, 0x8219d1fc
	if ctx.cr[6].lt {
	pc = 0x8219D1FC; continue 'dispatch;
	}
	// 8219D1BC: 2F0500C1  cmpwi cr6, r5, 0xc1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 193, &mut ctx.xer);
	// 8219D1C0: 40990034  ble cr6, 0x8219d1f4
	if !ctx.cr[6].gt {
	pc = 0x8219D1F4; continue 'dispatch;
	}
	// 8219D1C4: 2F0500FF  cmpwi cr6, r5, 0xff
	ctx.cr[6].compare_i32(ctx.r[5].s32, 255, &mut ctx.xer);
	// 8219D1C8: 409A0034  bne cr6, 0x8219d1fc
	if !ctx.cr[6].eq {
	pc = 0x8219D1FC; continue 'dispatch;
	}
	// 8219D1CC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219D1D0: 419A0054  beq cr6, 0x8219d224
	if ctx.cr[6].eq {
	pc = 0x8219D224; continue 'dispatch;
	}
	// 8219D1D4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219D1D8: 616ABEB8  ori r10, r11, 0xbeb8
	ctx.r[10].u64 = ctx.r[11].u64 | 48824;
	// 8219D1DC: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219D1E0: 396BA510  addi r11, r11, -0x5af0
	ctx.r[11].s64 = ctx.r[11].s64 + -23280;
	// 8219D1E4: 7D47522E  lhzx r10, r7, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219D1E8: 554A303E  rotlwi r10, r10, 6
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(6)) as u64;
	// 8219D1EC: 7C2A5C2E  lfsx f1, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219D1F0: 48000034  b 0x8219d224
	pc = 0x8219D224; continue 'dispatch;
	// 8219D1F4: FC400090  fmr f2, f0
	ctx.f[2].f64 = ctx.f[0].f64;
	// 8219D1F8: 4800002C  b 0x8219d224
	pc = 0x8219D224; continue 'dispatch;
	// 8219D1FC: 2F0500C1  cmpwi cr6, r5, 0xc1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 193, &mut ctx.xer);
	// 8219D200: 40980024  bge cr6, 0x8219d224
	if !ctx.cr[6].lt {
	pc = 0x8219D224; continue 'dispatch;
	}
	// 8219D204: 7CAB07B4  extsw r11, r5
	ctx.r[11].s64 = ctx.r[5].s32 as i64;
	// 8219D208: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219D20C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219D210: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219D214: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8219D218: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219D21C: C00B2050  lfs f0, 0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D220: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219D224: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8219D228: 419A000C  beq cr6, 0x8219d234
	if ctx.cr[6].eq {
	pc = 0x8219D234; continue 'dispatch;
	}
	// 8219D22C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8219D230: 481D3B89  bl 0x82370db8
	ctx.lr = 0x8219D234;
	sub_82370DB8(ctx, base);
	// 8219D234: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 8219D238: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219D23C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219D240: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219D244: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219D248 size=16
    let mut pc: u32 = 0x8219D248;
    'dispatch: loop {
        match pc {
            0x8219D248 => {
    //   block [0x8219D248..0x8219D258)
	// 8219D248: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8219D24C: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219D250: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D254: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219D258 size=12
    let mut pc: u32 = 0x8219D258;
    'dispatch: loop {
        match pc {
            0x8219D258 => {
    //   block [0x8219D258..0x8219D264)
	// 8219D258: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219D25C: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 8219D260: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219D268 size=180
    let mut pc: u32 = 0x8219D268;
    'dispatch: loop {
        match pc {
            0x8219D268 => {
    //   block [0x8219D268..0x8219D31C)
	// 8219D268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219D26C: 48397E51  bl 0x825350bc
	ctx.lr = 0x8219D270;
	sub_82535080(ctx, base);
	// 8219D270: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219D274: 3FC0830F  lis r30, -0x7cf1
	ctx.r[30].s64 = -2096168960;
	// 8219D278: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219D27C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219D280: 817EFAC0  lwz r11, -0x540(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219D284: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8219D288: 912B0040  stw r9, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[9].u32 ) };
	// 8219D28C: 7D4B0734  extsh r11, r10
	ctx.r[11].s64 = ctx.r[10].s16 as i64;
	// 8219D290: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8219D294: 419A0080  beq cr6, 0x8219d314
	if ctx.cr[6].eq {
	pc = 0x8219D314; continue 'dispatch;
	}
	// 8219D298: 3BBF0080  addi r29, r31, 0x80
	ctx.r[29].s64 = ctx.r[31].s64 + 128;
	// 8219D29C: 817D0084  lwz r11, 0x84(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 8219D2A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219D2A4: 419A000C  beq cr6, 0x8219d2b0
	if ctx.cr[6].eq {
	pc = 0x8219D2B0; continue 'dispatch;
	}
	// 8219D2A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219D2AC: 48000385  bl 0x8219d630
	ctx.lr = 0x8219D2B0;
	sub_8219D630(ctx, base);
	// 8219D2B0: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219D2B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219D2B8: 409A005C  bne cr6, 0x8219d314
	if !ctx.cr[6].eq {
	pc = 0x8219D314; continue 'dispatch;
	}
	// 8219D2BC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219D2C0: 394BC448  addi r10, r11, -0x3bb8
	ctx.r[10].s64 = ctx.r[11].s64 + -15288;
	// 8219D2C4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219D2C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D2CC: 419A0020  beq cr6, 0x8219d2ec
	if ctx.cr[6].eq {
	pc = 0x8219D2EC; continue 'dispatch;
	}
	// 8219D2D0: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219D2D4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219D2D8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219D2DC: 409A0010  bne cr6, 0x8219d2ec
	if !ctx.cr[6].eq {
	pc = 0x8219D2EC; continue 'dispatch;
	}
	// 8219D2E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D2E4: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 8219D2E8: 409A0008  bne cr6, 0x8219d2f0
	if !ctx.cr[6].eq {
	pc = 0x8219D2F0; continue 'dispatch;
	}
	// 8219D2EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219D2F0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219D2F4: 419A0020  beq cr6, 0x8219d314
	if ctx.cr[6].eq {
	pc = 0x8219D314; continue 'dispatch;
	}
	// 8219D2F8: 817EFAC0  lwz r11, -0x540(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219D2FC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8219D300: 409A0014  bne cr6, 0x8219d314
	if !ctx.cr[6].eq {
	pc = 0x8219D314; continue 'dispatch;
	}
	// 8219D304: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8219D308: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219D30C: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 8219D310: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 8219D314: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219D318: 48397DF4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219D320 size=64
    let mut pc: u32 = 0x8219D320;
    'dispatch: loop {
        match pc {
            0x8219D320 => {
    //   block [0x8219D320..0x8219D360)
	// 8219D320: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219D324: 39030080  addi r8, r3, 0x80
	ctx.r[8].s64 = ctx.r[3].s64 + 128;
	// 8219D328: 394BC448  addi r10, r11, -0x3bb8
	ctx.r[10].s64 = ctx.r[11].s64 + -15288;
	// 8219D32C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219D330: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D334: 419A0020  beq cr6, 0x8219d354
	if ctx.cr[6].eq {
	pc = 0x8219D354; continue 'dispatch;
	}
	// 8219D338: 80EB0030  lwz r7, 0x30(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219D33C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219D340: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219D344: 409A0010  bne cr6, 0x8219d354
	if !ctx.cr[6].eq {
	pc = 0x8219D354; continue 'dispatch;
	}
	// 8219D348: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D34C: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 8219D350: 409A0008  bne cr6, 0x8219d358
	if !ctx.cr[6].eq {
	pc = 0x8219D358; continue 'dispatch;
	}
	// 8219D354: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219D358: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219D35C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219D360 size=12
    let mut pc: u32 = 0x8219D360;
    'dispatch: loop {
        match pc {
            0x8219D360 => {
    //   block [0x8219D360..0x8219D36C)
	// 8219D360: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219D364: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 8219D368: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219D370 size=704
    let mut pc: u32 = 0x8219D370;
    'dispatch: loop {
        match pc {
            0x8219D370 => {
    //   block [0x8219D370..0x8219D630)
	// 8219D370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219D374: 48397D35  bl 0x825350a8
	ctx.lr = 0x8219D378;
	sub_82535080(ctx, base);
	// 8219D378: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219D37C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219D380: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 8219D384: 38EB0B78  addi r7, r11, 0xb78
	ctx.r[7].s64 = ctx.r[11].s64 + 2936;
	// 8219D388: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219D38C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 8219D390: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219D394: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8219D398: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8219D39C: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 8219D3A0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8219D3A4: 38A00380  li r5, 0x380
	ctx.r[5].s64 = 896;
	// 8219D3A8: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 8219D3AC: FB580000  std r26, 0(r24)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[26].u64 ) };
	// 8219D3B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8219D3B4: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219D3B8: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 8219D3BC: 481CD0D5  bl 0x8236a490
	ctx.lr = 0x8219D3C0;
	sub_8236A490(ctx, base);
	// 8219D3C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219D3C4: 419A000C  beq cr6, 0x8219d3d0
	if ctx.cr[6].eq {
	pc = 0x8219D3D0; continue 'dispatch;
	}
	// 8219D3C8: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219D3CC: 48000008  b 0x8219d3d4
	pc = 0x8219D3D4; continue 'dispatch;
	// 8219D3D0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 8219D3D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219D3D8: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219D3DC: 90780004  stw r3, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 8219D3E0: 419A0064  beq cr6, 0x8219d444
	if ctx.cr[6].eq {
	pc = 0x8219D444; continue 'dispatch;
	}
	// 8219D3E4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219D3E8: 3BE30080  addi r31, r3, 0x80
	ctx.r[31].s64 = ctx.r[3].s64 + 128;
	// 8219D3EC: 396B0B80  addi r11, r11, 0xb80
	ctx.r[11].s64 = ctx.r[11].s64 + 2944;
	// 8219D3F0: 572A07BC  rlwinm r10, r25, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 8219D3F4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8219D3F8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219D3FC: E9780000  ld r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	// 8219D400: FB430110  std r26, 0x110(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(272 as u32), ctx.r[26].u64 ) };
	// 8219D404: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8219D408: 935F0080  stw r26, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[26].u32 ) };
	// 8219D40C: 933F0088  stw r25, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[25].u32 ) };
	// 8219D410: F97F0090  std r11, 0x90(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 8219D414: 419A0080  beq cr6, 0x8219d494
	if ctx.cr[6].eq {
	pc = 0x8219D494; continue 'dispatch;
	}
	// 8219D418: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219D41C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8219D420: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D424: 419A0030  beq cr6, 0x8219d454
	if ctx.cr[6].eq {
	pc = 0x8219D454; continue 'dispatch;
	}
	// 8219D428: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219D42C: D1BF0060  stfs f13, 0x60(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8219D430: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219D434: D1BF0064  stfs f13, 0x64(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8219D438: C1BC0008  lfs f13, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219D43C: D1BF0068  stfs f13, 0x68(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8219D440: 48000020  b 0x8219d460
	pc = 0x8219D460; continue 'dispatch;
	// 8219D444: FB580000  std r26, 0(r24)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[26].u64 ) };
	// 8219D448: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 8219D44C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8219D450: 48397CA8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
	// 8219D454: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8219D458: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8219D45C: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8219D460: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8219D464: 419A0020  beq cr6, 0x8219d484
	if ctx.cr[6].eq {
	pc = 0x8219D484; continue 'dispatch;
	}
	// 8219D468: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D46C: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8219D470: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D474: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8219D478: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D47C: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8219D480: 48000194  b 0x8219d614
	pc = 0x8219D614; continue 'dispatch;
	// 8219D484: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8219D488: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8219D48C: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8219D490: 48000184  b 0x8219d614
	pc = 0x8219D614; continue 'dispatch;
	// 8219D494: 572B077A  rlwinm r11, r25, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 8219D498: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219D49C: 419A0080  beq cr6, 0x8219d51c
	if ctx.cr[6].eq {
	pc = 0x8219D51C; continue 'dispatch;
	}
	// 8219D4A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219D4A4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8219D4A8: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D4AC: 419A0020  beq cr6, 0x8219d4cc
	if ctx.cr[6].eq {
	pc = 0x8219D4CC; continue 'dispatch;
	}
	// 8219D4B0: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219D4B4: D1BF0040  stfs f13, 0x40(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8219D4B8: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219D4BC: D1BF0044  stfs f13, 0x44(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8219D4C0: C1BC0008  lfs f13, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219D4C4: D1BF0048  stfs f13, 0x48(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8219D4C8: 48000010  b 0x8219d4d8
	pc = 0x8219D4D8; continue 'dispatch;
	// 8219D4CC: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8219D4D0: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8219D4D4: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8219D4D8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8219D4DC: 419A0028  beq cr6, 0x8219d504
	if ctx.cr[6].eq {
	pc = 0x8219D504; continue 'dispatch;
	}
	// 8219D4E0: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D4E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219D4E8: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8219D4EC: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D4F0: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8219D4F4: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D4F8: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8219D4FC: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 8219D500: 48000118  b 0x8219d618
	pc = 0x8219D618; continue 'dispatch;
	// 8219D504: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8219D508: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8219D50C: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8219D510: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219D514: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 8219D518: 48000100  b 0x8219d618
	pc = 0x8219D618; continue 'dispatch;
	// 8219D51C: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 8219D520: 57AB0420  rlwinm r11, r29, 0, 0x10, 0x10
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 8219D524: 57A4057E  clrlwi r4, r29, 0x15
	ctx.r[4].u64 = ctx.r[29].u32 as u64 & 0x000007FFu64;
	// 8219D528: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219D52C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8219D530: 419A0028  beq cr6, 0x8219d558
	if ctx.cr[6].eq {
	pc = 0x8219D558; continue 'dispatch;
	}
	// 8219D534: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219D538: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219D53C: 386B14A0  addi r3, r11, 0x14a0
	ctx.r[3].s64 = ctx.r[11].s64 + 5280;
	// 8219D540: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8219D544: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8219D548: 480065C1  bl 0x821a3b08
	ctx.lr = 0x8219D54C;
	sub_821A3B08(ctx, base);
	// 8219D54C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8219D550: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8219D554: 48000030  b 0x8219d584
	pc = 0x8219D584; continue 'dispatch;
	// 8219D558: 2F040058  cmpwi cr6, r4, 0x58
	ctx.cr[6].compare_i32(ctx.r[4].s32, 88, &mut ctx.xer);
	// 8219D55C: 41980028  blt cr6, 0x8219d584
	if ctx.cr[6].lt {
	pc = 0x8219D584; continue 'dispatch;
	}
	// 8219D560: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 8219D564: 3964FFA8  addi r11, r4, -0x58
	ctx.r[11].s64 = ctx.r[4].s64 + -88;
	// 8219D568: 394A47D0  addi r10, r10, 0x47d0
	ctx.r[10].s64 = ctx.r[10].s64 + 18384;
	// 8219D56C: 390A0002  addi r8, r10, 2
	ctx.r[8].s64 = ctx.r[10].s64 + 2;
	// 8219D570: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219D574: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8219D578: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219D57C: 7D6B422E  lhzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8219D580: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 8219D584: 397F0040  addi r11, r31, 0x40
	ctx.r[11].s64 = ctx.r[31].s64 + 64;
	// 8219D588: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8219D58C: 419A0020  beq cr6, 0x8219d5ac
	if ctx.cr[6].eq {
	pc = 0x8219D5AC; continue 'dispatch;
	}
	// 8219D590: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D594: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 8219D598: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219D59C: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D5A0: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8219D5A4: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D5A8: 48000014  b 0x8219d5bc
	pc = 0x8219D5BC; continue 'dispatch;
	// 8219D5AC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219D5B0: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D5B4: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8219D5B8: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219D5BC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219D5C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219D5C4: 909F0010  stw r4, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 8219D5C8: 913F0018  stw r9, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 8219D5CC: 935F001C  stw r26, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[26].u32 ) };
	// 8219D5D0: 409A0018  bne cr6, 0x8219d5e8
	if !ctx.cr[6].eq {
	pc = 0x8219D5E8; continue 'dispatch;
	}
	// 8219D5D4: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 8219D5D8: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 8219D5DC: 394A3E78  addi r10, r10, 0x3e78
	ctx.r[10].s64 = ctx.r[10].s64 + 15992;
	// 8219D5E0: 396B3E78  addi r11, r11, 0x3e78
	ctx.r[11].s64 = ctx.r[11].s64 + 15992;
	// 8219D5E4: 48000014  b 0x8219d5f8
	pc = 0x8219D5F8; continue 'dispatch;
	// 8219D5E8: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 8219D5EC: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 8219D5F0: 394A3EC8  addi r10, r10, 0x3ec8
	ctx.r[10].s64 = ctx.r[10].s64 + 16072;
	// 8219D5F4: 396B3F60  addi r11, r11, 0x3f60
	ctx.r[11].s64 = ctx.r[11].s64 + 16224;
	// 8219D5F8: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 8219D5FC: 572B07FE  clrlwi r11, r25, 0x1f
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x00000001u64;
	// 8219D600: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 8219D604: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219D608: 409AFF08  bne cr6, 0x8219d510
	if !ctx.cr[6].eq {
	pc = 0x8219D510; continue 'dispatch;
	}
	// 8219D60C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219D610: 48000021  bl 0x8219d630
	ctx.lr = 0x8219D614;
	sub_8219D630(ctx, base);
	// 8219D614: 935F0084  stw r26, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[26].u32 ) };
	// 8219D618: E9780000  ld r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	// 8219D61C: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 8219D620: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 8219D624: F96AC448  std r11, -0x3bb8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(-15288 as u32), ctx.r[11].u64 ) };
	// 8219D628: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8219D62C: 48397ACC  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219D630 size=244
    let mut pc: u32 = 0x8219D630;
    'dispatch: loop {
        match pc {
            0x8219D630 => {
    //   block [0x8219D630..0x8219D724)
	// 8219D630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219D634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219D638: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219D63C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219D640: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219D644: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 8219D648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D64C: 419A00C4  beq cr6, 0x8219d710
	if ctx.cr[6].eq {
	pc = 0x8219D710; continue 'dispatch;
	}
	// 8219D650: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219D654: 815F0090  lwz r10, 0x90(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 8219D658: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219D65C: 409A00B4  bne cr6, 0x8219d710
	if !ctx.cr[6].eq {
	pc = 0x8219D710; continue 'dispatch;
	}
	// 8219D660: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 8219D664: 556B077A  rlwinm r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219D668: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D66C: 419A0068  beq cr6, 0x8219d6d4
	if ctx.cr[6].eq {
	pc = 0x8219D6D4; continue 'dispatch;
	}
	// 8219D670: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 8219D674: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219D678: 39200110  li r9, 0x110
	ctx.r[9].s64 = 272;
	// 8219D67C: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219D680: 390000E0  li r8, 0xe0
	ctx.r[8].s64 = 224;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219D728 size=120
    let mut pc: u32 = 0x8219D728;
    'dispatch: loop {
        match pc {
            0x8219D728 => {
    //   block [0x8219D728..0x8219D7A0)
	// 8219D728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219D72C: 48397985  bl 0x825350b0
	ctx.lr = 0x8219D730;
	sub_82535080(ctx, base);
	// 8219D730: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219D734: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8219D738: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8219D73C: 2F1D0040  cmpwi cr6, r29, 0x40
	ctx.cr[6].compare_i32(ctx.r[29].s32, 64, &mut ctx.xer);
	// 8219D740: 409A0008  bne cr6, 0x8219d748
	if !ctx.cr[6].eq {
	pc = 0x8219D748; continue 'dispatch;
	}
	// 8219D744: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 8219D748: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8219D74C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8219D750: 3B6B16A0  addi r27, r11, 0x16a0
	ctx.r[27].s64 = ctx.r[11].s64 + 5792;
	// 8219D754: 7D7DD8AE  lbzx r11, r29, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 8219D758: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 8219D75C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219D760: 40990038  ble cr6, 0x8219d798
	if !ctx.cr[6].gt {
	pc = 0x8219D798; continue 'dispatch;
	}
	// 8219D764: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219D768: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8219D76C: 7F855850  subf r28, r5, r11
	ctx.r[28].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 8219D770: 7CBCFA14  add r5, r28, r31
	ctx.r[5].u64 = ctx.r[28].u64 + ctx.r[31].u64;
	// 8219D774: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219D778: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8219D77C: 4800EB0D  bl 0x821ac288
	ctx.lr = 0x8219D780;
	sub_821AC288(ctx, base);
	// 8219D780: 7D7DD8AE  lbzx r11, r29, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 8219D784: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8219D788: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 8219D78C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 8219D790: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8219D794: 4198FFDC  blt cr6, 0x8219d770
	if ctx.cr[6].lt {
	pc = 0x8219D770; continue 'dispatch;
	}
	// 8219D798: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219D79C: 48397964  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219D7A0 size=24
    let mut pc: u32 = 0x8219D7A0;
    'dispatch: loop {
        match pc {
            0x8219D7A0 => {
    //   block [0x8219D7A0..0x8219D7B8)
	// 8219D7A0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219D7A4: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 8219D7A8: 396BDED0  addi r11, r11, -0x2130
	ctx.r[11].s64 = ctx.r[11].s64 + -8496;
	// 8219D7AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219D7B0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219D7B4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219D7B8 size=16
    let mut pc: u32 = 0x8219D7B8;
    'dispatch: loop {
        match pc {
            0x8219D7B8 => {
    //   block [0x8219D7B8..0x8219D7C8)
	// 8219D7B8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8219D7BC: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219D7C0: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 8219D7C4: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D7C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219D7C8 size=20
    let mut pc: u32 = 0x8219D7C8;
    'dispatch: loop {
        match pc {
            0x8219D7C8 => {
    //   block [0x8219D7C8..0x8219D7DC)
	// 8219D7C8: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8219D7CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219D7D0: 99630019  stb r11, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 8219D7D4: 99430025  stb r10, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 8219D7D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D7E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219D7E0 size=304
    let mut pc: u32 = 0x8219D7E0;
    'dispatch: loop {
        match pc {
            0x8219D7E0 => {
    //   block [0x8219D7E0..0x8219D910)
	// 8219D7E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219D7E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219D7E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219D7EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219D7F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219D7F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219D7F8: 815E0080  lwz r10, 0x80(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219D7FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219D800: 419A00F8  beq cr6, 0x8219d8f8
	if ctx.cr[6].eq {
	pc = 0x8219D8F8; continue 'dispatch;
	}
	// 8219D804: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219D808: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8219D80C: 3BEB63D0  addi r31, r11, 0x63d0
	ctx.r[31].s64 = ctx.r[11].s64 + 25552;
	// 8219D810: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219D814: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219D818: 912A002C  stw r9, 0x2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 8219D81C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8219D820: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8219D824: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8219D828: 3960002C  li r11, 0x2c
	ctx.r[11].s64 = 44;
	// 8219D82C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8219D830: 4856FA2D  bl 0x8270d25c
	ctx.lr = 0x8219D834;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 8219D834: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219D838: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8219D83C: 38CB0BC4  addi r6, r11, 0xbc4
	ctx.r[6].s64 = ctx.r[11].s64 + 3012;
	// 8219D840: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219D844: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8219D848: 808BB9F8  lwz r4, -0x4608(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17928 as u32) ) } as u64;
	// 8219D84C: 4805B495  bl 0x821f8ce0
	ctx.lr = 0x8219D850;
	sub_821F8CE0(ctx, base);
	// 8219D850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219D854: 4856FA19  bl 0x8270d26c
	ctx.lr = 0x8219D858;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 8219D858: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8219D85C: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 8219D860: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8219D864: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8219D868: 4BF86631  bl 0x82123e98
	ctx.lr = 0x8219D86C;
	sub_82123E98(ctx, base);
	// 8219D86C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8219D870: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219D874: 419A0008  beq cr6, 0x8219d87c
	if ctx.cr[6].eq {
	pc = 0x8219D87C; continue 'dispatch;
	}
	// 8219D878: 4BF7F7E1  bl 0x8211d058
	ctx.lr = 0x8219D87C;
	sub_8211D058(ctx, base);
	// 8219D87C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219D880: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8219D884: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219D888: 38EB0BD0  addi r7, r11, 0xbd0
	ctx.r[7].s64 = ctx.r[11].s64 + 3024;
	// 8219D88C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8219D890: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219D894: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 8219D898: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 8219D89C: 808BFAC0  lwz r4, -0x540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219D8A0: 481CCBF1  bl 0x8236a490
	ctx.lr = 0x8219D8A4;
	sub_8236A490(ctx, base);
	// 8219D8A4: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219D8A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219D8AC: 419A003C  beq cr6, 0x8219d8e8
	if ctx.cr[6].eq {
	pc = 0x8219D8E8; continue 'dispatch;
	}
	// 8219D8B0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8219D8B4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219D8B8: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 8219D8BC: 419A0024  beq cr6, 0x8219d8e0
	if ctx.cr[6].eq {
	pc = 0x8219D8E0; continue 'dispatch;
	}
	// 8219D8C0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 8219D8C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8219D8C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219D8CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8219D8D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8219D8D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8219D8D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219D8DC: 4082FFE8  bne 0x8219d8c4
	if !ctx.cr[0].eq {
	pc = 0x8219D8C4; continue 'dispatch;
	}
	// 8219D8E0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8219D8E4: 4813AD0D  bl 0x822d85f0
	ctx.lr = 0x8219D8E8;
	sub_822D85F0(ctx, base);
	// 8219D8E8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219D8EC: 419A000C  beq cr6, 0x8219d8f8
	if ctx.cr[6].eq {
	pc = 0x8219D8F8; continue 'dispatch;
	}
	// 8219D8F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219D8F4: 4BF7F765  bl 0x8211d058
	ctx.lr = 0x8219D8F8;
	sub_8211D058(ctx, base);
	// 8219D8F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8219D8FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219D900: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219D904: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219D908: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219D90C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219D910 size=368
    let mut pc: u32 = 0x8219D910;
    'dispatch: loop {
        match pc {
            0x8219D910 => {
    //   block [0x8219D910..0x8219DA80)
	// 8219D910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219D914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219D918: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219D91C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8219D920: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8219D924: 80CBFAC0  lwz r6, -0x540(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219D928: 3D6082C3  lis r11, -0x7d3d
	ctx.r[11].s64 = -2101149696;
	// 8219D92C: 394B5518  addi r10, r11, 0x5518
	ctx.r[10].s64 = ctx.r[11].s64 + 21784;
	// 8219D930: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219D934: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D938: 419A0014  beq cr6, 0x8219d94c
	if ctx.cr[6].eq {
	pc = 0x8219D94C; continue 'dispatch;
	}
	// 8219D93C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219D940: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219D944: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219D948: 419A0008  beq cr6, 0x8219d950
	if ctx.cr[6].eq {
	pc = 0x8219D950; continue 'dispatch;
	}
	// 8219D94C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219D950: 38EB0090  addi r7, r11, 0x90
	ctx.r[7].s64 = ctx.r[11].s64 + 144;
	// 8219D954: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219D958: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 8219D95C: 390BC470  addi r8, r11, -0x3b90
	ctx.r[8].s64 = ctx.r[11].s64 + -15248;
	// 8219D960: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 8219D964: 394800E0  addi r10, r8, 0xe0
	ctx.r[10].s64 = ctx.r[8].s64 + 224;
	// 8219D968: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8219D96C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8219D970: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8219D974: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8219D978: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8219D97C: 4200FFF0  bdnz 0x8219d96c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8219D96C; continue 'dispatch;
	}
	// 8219D980: 388800E0  addi r4, r8, 0xe0
	ctx.r[4].s64 = ctx.r[8].s64 + 224;
	// 8219D984: 386800E0  addi r3, r8, 0xe0
	ctx.r[3].s64 = ctx.r[8].s64 + 224;
	// 8219D988: 481CA301  bl 0x82367c88
	ctx.lr = 0x8219D98C;
	sub_82367C88(ctx, base);
	// 8219D98C: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 8219D990: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 8219D994: 394800A0  addi r10, r8, 0xa0
	ctx.r[10].s64 = ctx.r[8].s64 + 160;
	// 8219D998: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8219D99C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8219D9A0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8219D9A4: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8219D9A8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8219D9AC: 4200FFF0  bdnz 0x8219d99c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8219D99C; continue 'dispatch;
	}
	// 8219D9B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219D9B4: 388800A0  addi r4, r8, 0xa0
	ctx.r[4].s64 = ctx.r[8].s64 + 160;
	// 8219D9B8: 386800A0  addi r3, r8, 0xa0
	ctx.r[3].s64 = ctx.r[8].s64 + 160;
	// 8219D9BC: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D9C0: D00800D8  stfs f0, 0xd8(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 8219D9C4: D00800D4  stfs f0, 0xd4(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 8219D9C8: D00800D0  stfs f0, 0xd0(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 8219D9CC: 481CA2BD  bl 0x82367c88
	ctx.lr = 0x8219D9D0;
	sub_82367C88(ctx, base);
	// 8219D9D0: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219D9D4: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219D9D8: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8219D9DC: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219D9E0: 61298608  ori r9, r9, 0x8608
	ctx.r[9].u64 = ctx.r[9].u64 | 34312;
	// 8219D9E4: 614A8600  ori r10, r10, 0x8600
	ctx.r[10].u64 = ctx.r[10].u64 | 34304;
	// 8219D9E8: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8219D9EC: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219D9F0: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 8219D9F4: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8219D9F8: 6129860C  ori r9, r9, 0x860c
	ctx.r[9].u64 = ctx.r[9].u64 | 34316;
	// 8219D9FC: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8219DA00: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 8219DA04: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219DA08: A1660014  lhz r11, 0x14(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219DA0C: 419A001C  beq cr6, 0x8219da28
	if ctx.cr[6].eq {
	pc = 0x8219DA28; continue 'dispatch;
	}
	// 8219DA10: 616B0400  ori r11, r11, 0x400
	ctx.r[11].u64 = ctx.r[11].u64 | 1024;
	// 8219DA14: B1660014  sth r11, 0x14(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 8219DA18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219DA1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219DA20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219DA24: 4E800020  blr
	return;
	// 8219DA28: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 8219DA2C: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 8219DA30: 556B05A8  rlwinm r11, r11, 0, 0x16, 0x14
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219DA34: 798CFFE6  rldicr r12, r12, 0x3f, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 8219DA38: B1660014  sth r11, 0x14(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 8219DA3C: 81650080  lwz r11, 0x80(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219DA40: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8219DA44: E94B00A0  ld r10, 0xa0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) };
	// 8219DA48: F94B0080  std r10, 0x80(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u64 ) };
	// 8219DA4C: E94B00A8  ld r10, 0xa8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) };
	// 8219DA50: F94B0088  std r10, 0x88(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[10].u64 ) };
	// 8219DA54: E94B00B0  ld r10, 0xb0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) };
	// 8219DA58: F94B0090  std r10, 0x90(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[10].u64 ) };
	// 8219DA5C: E94B00B8  ld r10, 0xb8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) };
	// 8219DA60: F94B0098  std r10, 0x98(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[10].u64 ) };
	// 8219DA64: E94B0078  ld r10, 0x78(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) };
	// 8219DA68: 7D4A6378  or r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[12].u64;
	// 8219DA6C: F94B0078  std r10, 0x78(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), ctx.r[10].u64 ) };
	// 8219DA70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219DA74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219DA78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219DA7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219DA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219DA80 size=12
    let mut pc: u32 = 0x8219DA80;
    'dispatch: loop {
        match pc {
            0x8219DA80 => {
    //   block [0x8219DA80..0x8219DA8C)
	// 8219DA80: 81030080  lwz r8, 0x80(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219DA84: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8219DA88: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219DA8C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219DA8C size=36
    let mut pc: u32 = 0x8219DA8C;
    'dispatch: loop {
        match pc {
            0x8219DA8C => {
    //   block [0x8219DA8C..0x8219DAB0)
	// 8219DA8C: 39680004  addi r11, r8, 4
	ctx.r[11].s64 = ctx.r[8].s64 + 4;
	// 8219DA90: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219DA94: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 8219DA98: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219DA9C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8219DAA0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8219DAA4: 4200FFF8  bdnz 0x8219da9c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8219DA9C; continue 'dispatch;
	}
	// 8219DAA8: 9128002C  stw r9, 0x2c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 8219DAAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219DAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219DAB0 size=580
    let mut pc: u32 = 0x8219DAB0;
    'dispatch: loop {
        match pc {
            0x8219DAB0 => {
    //   block [0x8219DAB0..0x8219DCF4)
	// 8219DAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219DAB4: 48397609  bl 0x825350bc
	ctx.lr = 0x8219DAB8;
	sub_82535080(ctx, base);
	// 8219DAB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219DABC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219DAC0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219DAC4: 3BEBC470  addi r31, r11, -0x3b90
	ctx.r[31].s64 = ctx.r[11].s64 + -15248;
	// 8219DAC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219DACC: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 8219DAD0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219DAD4: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 8219DAD8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8219DADC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219DAE0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8219DAE4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8219DAE8: 4200FFF8  bdnz 0x8219dae0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8219DAE0; continue 'dispatch;
	}
	// 8219DAEC: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 8219DAF0: 39400090  li r10, 0x90
	ctx.r[10].s64 = 144;
	// 8219DAF4: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219DAF8: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 8219DAFC: 3BCB1380  addi r30, r11, 0x1380
	ctx.r[30].s64 = ctx.r[11].s64 + 4992;
	// 8219DB00: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8219DB04: 387E0D30  addi r3, r30, 0xd30
	ctx.r[3].s64 = ctx.r[30].s64 + 3376;
	// 8219DB08: 396B8E40  addi r11, r11, -0x71c0
	ctx.r[11].s64 = ctx.r[11].s64 + -29120;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219DCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219DCF8 size=248
    let mut pc: u32 = 0x8219DCF8;
    'dispatch: loop {
        match pc {
            0x8219DCF8 => {
    //   block [0x8219DCF8..0x8219DDF0)
	// 8219DCF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219DCFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219DD00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219DD04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219DD08: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219DD0C: 3BEBC470  addi r31, r11, -0x3b90
	ctx.r[31].s64 = ctx.r[11].s64 + -15248;
	// 8219DD10: 817F016C  lwz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 8219DD14: 815F0174  lwz r10, 0x174(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 8219DD18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DD1C: 409A000C  bne cr6, 0x8219dd28
	if !ctx.cr[6].eq {
	pc = 0x8219DD28; continue 'dispatch;
	}
	// 8219DD20: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219DD24: 48000028  b 0x8219dd4c
	pc = 0x8219DD4C; continue 'dispatch;
	// 8219DD28: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219DD2C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219DD30: 419A000C  beq cr6, 0x8219dd3c
	if ctx.cr[6].eq {
	pc = 0x8219DD3C; continue 'dispatch;
	}
	// 8219DD34: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219DD38: 48000014  b 0x8219dd4c
	pc = 0x8219DD4C; continue 'dispatch;
	// 8219DD3C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219DD40: 7D290034  cntlzw r9, r9
	ctx.r[9].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 8219DD44: 5529DFFE  rlwinm r9, r9, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 8219DD48: 69290001  xori r9, r9, 1
	ctx.r[9].u64 = ctx.r[9].u64 ^ 1;
	// 8219DD4C: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 8219DD50: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219DD54: 409A0028  bne cr6, 0x8219dd7c
	if !ctx.cr[6].eq {
	pc = 0x8219DD7C; continue 'dispatch;
	}
	// 8219DD58: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219DD5C: 3CA00020  lis r5, 0x20
	ctx.r[5].s64 = 2097152;
	// 8219DD60: 38CB0BD8  addi r6, r11, 0xbd8
	ctx.r[6].s64 = ctx.r[11].s64 + 3032;
	// 8219DD64: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219DD68: 389F016C  addi r4, r31, 0x16c
	ctx.r[4].s64 = ctx.r[31].s64 + 364;
	// 8219DD6C: 386B5508  addi r3, r11, 0x5508
	ctx.r[3].s64 = ctx.r[11].s64 + 21768;
	// 8219DD70: 4808F7C9  bl 0x8222d538
	ctx.lr = 0x8219DD74;
	sub_8222D538(ctx, base);
	// 8219DD74: 815F0174  lwz r10, 0x174(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 8219DD78: 817F016C  lwz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 8219DD7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DD80: 409A000C  bne cr6, 0x8219dd8c
	if !ctx.cr[6].eq {
	pc = 0x8219DD8C; continue 'dispatch;
	}
	// 8219DD84: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219DD88: 48000028  b 0x8219ddb0
	pc = 0x8219DDB0; continue 'dispatch;
	// 8219DD8C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219DD90: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219DD94: 419A000C  beq cr6, 0x8219dda0
	if ctx.cr[6].eq {
	pc = 0x8219DDA0; continue 'dispatch;
	}
	// 8219DD98: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219DD9C: 48000014  b 0x8219ddb0
	pc = 0x8219DDB0; continue 'dispatch;
	// 8219DDA0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219DDA4: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 8219DDA8: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 8219DDAC: 694A0001  xori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 ^ 1;
	// 8219DDB0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8219DDB4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219DDB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219DDBC: 419A0008  beq cr6, 0x8219ddc4
	if ctx.cr[6].eq {
	pc = 0x8219DDC4; continue 'dispatch;
	}
	// 8219DDC0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219DDC4: 39000800  li r8, 0x800
	ctx.r[8].s64 = 2048;
	// 8219DDC8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219DDCC: 38C00800  li r6, 0x800
	ctx.r[6].s64 = 2048;
	// 8219DDD0: 3CA00020  lis r5, 0x20
	ctx.r[5].s64 = 2097152;
	// 8219DDD4: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 8219DDD8: 48003D79  bl 0x821a1b50
	ctx.lr = 0x8219DDDC;
	sub_821A1B50(ctx, base);
	// 8219DDDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219DDE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219DDE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219DDE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219DDEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219DDF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219DDF0 size=644
    let mut pc: u32 = 0x8219DDF0;
    'dispatch: loop {
        match pc {
            0x8219DDF0 => {
    //   block [0x8219DDF0..0x8219E074)
	// 8219DDF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219DDF4: 483972A9  bl 0x8253509c
	ctx.lr = 0x8219DDF8;
	sub_82535080(ctx, base);
	// 8219DDF8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219DDFC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219DE00: 38C03A98  li r6, 0x3a98
	ctx.r[6].s64 = 15000;
	// 8219DE04: 38EB0BEC  addi r7, r11, 0xbec
	ctx.r[7].s64 = ctx.r[11].s64 + 3052;
	// 8219DE08: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 8219DE0C: 38600088  li r3, 0x88
	ctx.r[3].s64 = 136;
	// 8219DE10: 481CC681  bl 0x8236a490
	ctx.lr = 0x8219DE14;
	sub_8236A490(ctx, base);
	// 8219DE14: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 8219DE18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219DE1C: 419A0018  beq cr6, 0x8219de34
	if ctx.cr[6].eq {
	pc = 0x8219DE34; continue 'dispatch;
	}
	// 8219DE20: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219DE24: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8219DE28: 396B0CC8  addi r11, r11, 0xcc8
	ctx.r[11].s64 = ctx.r[11].s64 + 3272;
	// 8219DE2C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219DE30: 48000008  b 0x8219de38
	pc = 0x8219DE38; continue 'dispatch;
	// 8219DE34: 7EBBAB78  mr r27, r21
	ctx.r[27].u64 = ctx.r[21].u64;
	// 8219DE38: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219DE3C: A15B0014  lhz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219DE40: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 8219DE44: 3BEBC470  addi r31, r11, -0x3b90
	ctx.r[31].s64 = ctx.r[11].s64 + -15248;
	// 8219DE48: 7D4B0734  extsh r11, r10
	ctx.r[11].s64 = ctx.r[10].s16 as i64;
	// 8219DE4C: 3B5F0004  addi r26, r31, 4
	ctx.r[26].s64 = ctx.r[31].s64 + 4;
	// 8219DE50: 556B05A6  rlwinm r11, r11, 0, 0x16, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219DE54: B17B0014  sth r11, 0x14(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 8219DE58: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219DE5C: 93FB0080  stw r31, 0x80(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 8219DE60: 3B2B0F7C  addi r25, r11, 0xf7c
	ctx.r[25].s64 = ctx.r[11].s64 + 3964;
	// 8219DE64: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219DE68: 3AEB0C00  addi r23, r11, 0xc00
	ctx.r[23].s64 = ctx.r[11].s64 + 3072;
	// 8219DE6C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219DE70: 3ACB0BF4  addi r22, r11, 0xbf4
	ctx.r[22].s64 = ctx.r[11].s64 + 3060;
	// 8219DE74: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8219DE78: 3B0B52F0  addi r24, r11, 0x52f0
	ctx.r[24].s64 = ctx.r[11].s64 + 21232;
	// 8219DE7C: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 8219DE80: 409A0014  bne cr6, 0x8219de94
	if !ctx.cr[6].eq {
	pc = 0x8219DE94; continue 'dispatch;
	}
	// 8219DE84: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219DE88: 3B807FFF  li r28, 0x7fff
	ctx.r[28].s64 = 32767;
	// 8219DE8C: 7FABC02E  lwzx r29, r11, r24
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 8219DE90: 48000048  b 0x8219ded8
	pc = 0x8219DED8; continue 'dispatch;
	// 8219DE94: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 8219DE98: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 8219DE9C: 41990010  bgt cr6, 0x8219deac
	if ctx.cr[6].gt {
	pc = 0x8219DEAC; continue 'dispatch;
	}
	// 8219DEA0: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219DEA4: 7FABC02E  lwzx r29, r11, r24
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 8219DEA8: 48000030  b 0x8219ded8
	pc = 0x8219DED8; continue 'dispatch;
	// 8219DEAC: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8219DEB0: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 8219DEB4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219DEB8: 397EFFFE  addi r11, r30, -2
	ctx.r[11].s64 = ctx.r[30].s64 + -2;
	// 8219DEBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219DEC0: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8219DEC4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 8219DEC8: 7CAB0194  addze r5, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[5].s64 = tmp.s64;
	// 8219DECC: 409A0008  bne cr6, 0x8219ded4
	if !ctx.cr[6].eq {
	pc = 0x8219DED4; continue 'dispatch;
	}
	// 8219DED0: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8219DED4: 48394D4D  bl 0x82532c20
	ctx.lr = 0x8219DED8;
	sub_82532C20(ctx, base);
	// 8219DED8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 8219DEDC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8219DEE0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219DEE4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8219DEE8: 38600088  li r3, 0x88
	ctx.r[3].s64 = 136;
	// 8219DEEC: 481CC5A5  bl 0x8236a490
	ctx.lr = 0x8219DEF0;
	sub_8236A490(ctx, base);
	// 8219DEF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219DEF4: 419A0010  beq cr6, 0x8219df04
	if ctx.cr[6].eq {
	pc = 0x8219DF04; continue 'dispatch;
	}
	// 8219DEF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219DEFC: 93230000  stw r25, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 8219DF00: 48000008  b 0x8219df08
	pc = 0x8219DF08; continue 'dispatch;
	// 8219DF04: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 8219DF08: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8219DF0C: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219DF10: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 8219DF14: 2F1E0008  cmpwi cr6, r30, 8
	ctx.cr[6].compare_i32(ctx.r[30].s32, 8, &mut ctx.xer);
	// 8219DF18: 4198FF64  blt cr6, 0x8219de7c
	if ctx.cr[6].lt {
	pc = 0x8219DE7C; continue 'dispatch;
	}
	// 8219DF1C: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 8219DF20: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219DF24: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 8219DF28: 388BE1A0  addi r4, r11, -0x1e60
	ctx.r[4].s64 = ctx.r[11].s64 + -7776;
	// 8219DF2C: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 8219DF30: 3909E1A0  addi r8, r9, -0x1e60
	ctx.r[8].s64 = ctx.r[9].s64 + -7776;
	// 8219DF34: 3BABE1A0  addi r29, r11, -0x1e60
	ctx.r[29].s64 = ctx.r[11].s64 + -7776;
	// 8219DF38: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219DF3C: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 8219DF40: 38EB0C08  addi r7, r11, 0xc08
	ctx.r[7].s64 = ctx.r[11].s64 + 3080;
	// 8219DF44: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8219DF48: 910A0058  stw r8, 0x58(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 8219DF4C: 3BC9E1A0  addi r30, r9, -0x1e60
	ctx.r[30].s64 = ctx.r[9].s64 + -7776;
	// 8219DF50: 396B76FC  addi r11, r11, 0x76fc
	ctx.r[11].s64 = ctx.r[11].s64 + 30460;
	// 8219DF54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219DF58: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219DF5C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8219DF60: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219DF64: 912A0080  stw r9, 0x80(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 8219DF68: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8219DF6C: 908A0058  stw r4, 0x58(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 8219DF70: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219DF74: 912A0080  stw r9, 0x80(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 8219DF78: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219DF7C: 93CA0058  stw r30, 0x58(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 8219DF80: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219DF84: 912A0080  stw r9, 0x80(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 8219DF88: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8219DF8C: 93AA0058  stw r29, 0x58(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 8219DF90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219DF94: 916A0080  stw r11, 0x80(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 8219DF98: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219DF9C: 481CC4F5  bl 0x8236a490
	ctx.lr = 0x8219DFA0;
	sub_8236A490(ctx, base);
	// 8219DFA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219DFA4: 419A0054  beq cr6, 0x8219dff8
	if ctx.cr[6].eq {
	pc = 0x8219DFF8; continue 'dispatch;
	}
	// 8219DFA8: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 8219DFAC: A1230014  lhz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219DFB0: 396300C4  addi r11, r3, 0xc4
	ctx.r[11].s64 = ctx.r[3].s64 + 196;
	// 8219DFB4: 92A300C0  stw r21, 0xc0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[21].u32 ) };
	// 8219DFB8: 394A0EF8  addi r10, r10, 0xef8
	ctx.r[10].s64 = ctx.r[10].s64 + 3832;
	// 8219DFBC: 92A300C4  stw r21, 0xc4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), ctx.r[21].u32 ) };
	// 8219DFC0: 6128000D  ori r8, r9, 0xd
	ctx.r[8].u64 = ctx.r[9].u64 | 13;
	// 8219DFC4: FAA300D0  std r21, 0xd0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), ctx.r[21].u64 ) };
	// 8219DFC8: 3D20821B  lis r9, -0x7de5
	ctx.r[9].s64 = -2112159744;
	// 8219DFCC: 92A300CC  stw r21, 0xcc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(204 as u32), ctx.r[21].u32 ) };
	// 8219DFD0: 38FF0024  addi r7, r31, 0x24
	ctx.r[7].s64 = ctx.r[31].s64 + 36;
	// 8219DFD4: 916300C8  stw r11, 0xc8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 8219DFD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219DFDC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8219DFE0: 3949C3E0  addi r10, r9, -0x3c20
	ctx.r[10].s64 = ctx.r[9].s64 + -15392;
	// 8219DFE4: B1030014  sth r8, 0x14(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[8].u16 ) };
	// 8219DFE8: 90E300D8  stw r7, 0xd8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(216 as u32), ctx.r[7].u32 ) };
	// 8219DFEC: 9143005C  stw r10, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8219DFF0: 907F0024  stw r3, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 8219DFF4: 48000008  b 0x8219dffc
	pc = 0x8219DFFC; continue 'dispatch;
	// 8219DFF8: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 8219DFFC: 817E00C0  lwz r11, 0xc0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(192 as u32) ) } as u64;
	// 8219E000: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8219E004: 409A002C  bne cr6, 0x8219e030
	if !ctx.cr[6].eq {
	pc = 0x8219E030; continue 'dispatch;
	}
	// 8219E008: 817E00C8  lwz r11, 0xc8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 8219E00C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E010: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219E014: 409A001C  bne cr6, 0x8219e030
	if !ctx.cr[6].eq {
	pc = 0x8219E030; continue 'dispatch;
	}
	// 8219E018: E97E00D0  ld r11, 0xd0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) };
	// 8219E01C: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 8219E020: 419A0010  beq cr6, 0x8219e030
	if ctx.cr[6].eq {
	pc = 0x8219E030; continue 'dispatch;
	}
	// 8219E024: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8219E028: 481DACB1  bl 0x82378cd8
	ctx.lr = 0x8219E02C;
	sub_82378CD8(ctx, base);
	// 8219E02C: FABE00D0  std r21, 0xd0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(208 as u32), ctx.r[21].u64 ) };
	// 8219E030: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 8219E034: 396BE078  addi r11, r11, -0x1f88
	ctx.r[11].s64 = ctx.r[11].s64 + -8072;
	// 8219E038: 917E0058  stw r11, 0x58(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8219E03C: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 8219E040: FABE00A0  std r21, 0xa0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(160 as u32), ctx.r[21].u64 ) };
	// 8219E044: FABE00A8  std r21, 0xa8(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[21].u64 ) };
	// 8219E048: FABE00B0  std r21, 0xb0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(176 as u32), ctx.r[21].u64 ) };
	// 8219E04C: FABE00B8  std r21, 0xb8(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(184 as u32), ctx.r[21].u64 ) };
	// 8219E050: F97E0080  std r11, 0x80(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 8219E054: E97E00A8  ld r11, 0xa8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(168 as u32) ) };
	// 8219E058: F97E0088  std r11, 0x88(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[11].u64 ) };
	// 8219E05C: E97E00B0  ld r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) };
	// 8219E060: F97E0090  std r11, 0x90(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 8219E064: E97E00B8  ld r11, 0xb8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(184 as u32) ) };
	// 8219E068: F97E0098  std r11, 0x98(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	// 8219E06C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8219E070: 4839707C  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219E078 size=292
    let mut pc: u32 = 0x8219E078;
    'dispatch: loop {
        match pc {
            0x8219E078 => {
    //   block [0x8219E078..0x8219E19C)
	// 8219E078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219E07C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219E080: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219E084: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8219E088: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219E08C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219E090: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219E094: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8219E098: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219E09C: 61298608  ori r9, r9, 0x8608
	ctx.r[9].u64 = ctx.r[9].u64 | 34312;
	// 8219E0A0: 614A8600  ori r10, r10, 0x8600
	ctx.r[10].u64 = ctx.r[10].u64 | 34304;
	// 8219E0A4: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8219E0A8: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219E0AC: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 8219E0B0: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8219E0B4: 6129860C  ori r9, r9, 0x860c
	ctx.r[9].u64 = ctx.r[9].u64 | 34316;
	// 8219E0B8: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8219E0BC: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 8219E0C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219E0C4: 409A00BC  bne cr6, 0x8219e180
	if !ctx.cr[6].eq {
	pc = 0x8219E180; continue 'dispatch;
	}
	// 8219E0C8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219E0CC: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219E0D0: 816B0168  lwz r11, 0x168(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(360 as u32) ) } as u64;
	// 8219E0D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E0D8: 419A00A8  beq cr6, 0x8219e180
	if ctx.cr[6].eq {
	pc = 0x8219E180; continue 'dispatch;
	}
	// 8219E0DC: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219E0E0: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 8219E0E4: 386B1290  addi r3, r11, 0x1290
	ctx.r[3].s64 = ctx.r[11].s64 + 4752;
	// 8219E0E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219E0EC: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219E0F0: FD40F890  fmr f10, f31
	ctx.f[10].f64 = ctx.f[31].f64;
	// 8219E0F4: 4BFFE5D5  bl 0x8219c6c8
	ctx.lr = 0x8219E0F8;
	sub_8219C6C8(ctx, base);
	// 8219E0F8: FF015000  fcmpu cr6, f1, f10
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[10].f64);
	// 8219E0FC: 40980008  bge cr6, 0x8219e104
	if !ctx.cr[6].lt {
	pc = 0x8219E104; continue 'dispatch;
	}
	// 8219E100: FD400890  fmr f10, f1
	ctx.f[10].f64 = ctx.f[1].f64;
	// 8219E104: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 8219E108: 3863002C  addi r3, r3, 0x2c
	ctx.r[3].s64 = ctx.r[3].s64 + 44;
	// 8219E10C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8219E110: 4199FFE4  bgt cr6, 0x8219e0f4
	if ctx.cr[6].gt {
	pc = 0x8219E0F4; continue 'dispatch;
	}
	// 8219E114: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219E118: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8219E11C: 214B001F  subfic r10, r11, 0x1f
	ctx.xer.ca = ctx.r[11].u32 <= 31 as u32;
	ctx.r[10].s64 = (31 as i64) - ctx.r[11].s64;
	// 8219E120: 2B0A0010  cmplwi cr6, r10, 0x10
	ctx.cr[6].compare_u32(ctx.r[10].u32, 16 as u32, &mut ctx.xer);
	// 8219E124: 41980008  blt cr6, 0x8219e12c
	if ctx.cr[6].lt {
	pc = 0x8219E12C; continue 'dispatch;
	}
	// 8219E128: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219E12C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8219E130: 3BEB4A00  addi r31, r11, 0x4a00
	ctx.r[31].s64 = ctx.r[11].s64 + 18944;
	// 8219E134: 1D6A03C0  mulli r11, r10, 0x3c0
	ctx.r[11].s64 = ctx.r[10].s64 * 960;
	// 8219E138: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219E13C: C00A2604  lfs f0, 0x2604(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9732 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219E140: 395F00F0  addi r10, r31, 0xf0
	ctx.r[10].s64 = ctx.r[31].s64 + 240;
	// 8219E144: EC2A0032  fmuls f1, f10, f0
	ctx.f[1].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219E148: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8219E14C: D14B0000  stfs f10, 0(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219E150: D14B0004  stfs f10, 4(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8219E154: D14B0008  stfs f10, 8(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219E158: D3EB000C  stfs f31, 0xc(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8219E15C: 4BF7F36D  bl 0x8211d4c8
	ctx.lr = 0x8219E160;
	sub_8211D4C8(ctx, base);
	// 8219E160: D3FF04BC  stfs f31, 0x4bc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1212 as u32), tmp.u32 ) };
	// 8219E164: D3FF087C  stfs f31, 0x87c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2172 as u32), tmp.u32 ) };
	// 8219E168: D03F04B0  stfs f1, 0x4b0(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1200 as u32), tmp.u32 ) };
	// 8219E16C: D03F04B4  stfs f1, 0x4b4(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1204 as u32), tmp.u32 ) };
	// 8219E170: D03F04B8  stfs f1, 0x4b8(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1208 as u32), tmp.u32 ) };
	// 8219E174: D03F0870  stfs f1, 0x870(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2160 as u32), tmp.u32 ) };
	// 8219E178: D03F0874  stfs f1, 0x874(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2164 as u32), tmp.u32 ) };
	// 8219E17C: D03F0878  stfs f1, 0x878(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2168 as u32), tmp.u32 ) };
	// 8219E180: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8219E184: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219E188: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219E18C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219E190: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219E194: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219E198: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219E1A0 size=116
    let mut pc: u32 = 0x8219E1A0;
    'dispatch: loop {
        match pc {
            0x8219E1A0 => {
    //   block [0x8219E1A0..0x8219E214)
	// 8219E1A0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219E1A4: 3D40830F  lis r10, -0x7cf1
	ctx.r[10].s64 = -2096168960;
	// 8219E1A8: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219E1AC: 814AFAC0  lwz r10, -0x540(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219E1B0: 816B0190  lwz r11, 0x190(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(400 as u32) ) } as u64;
	// 8219E1B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219E1B8: 409A005C  bne cr6, 0x8219e214
	if !ctx.cr[6].eq {
		sub_8219E214(ctx, base);
		return;
	}
	// 8219E1BC: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 8219E1C0: 816A0080  lwz r11, 0x80(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219E1C4: 61299C00  ori r9, r9, 0x9c00
	ctx.r[9].u64 = ctx.r[9].u64 | 39936;
	// 8219E1C8: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8219E1CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219E1D0: 419A0030  beq cr6, 0x8219e200
	if ctx.cr[6].eq {
	pc = 0x8219E200; continue 'dispatch;
	}
	// 8219E1D4: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8219E1D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219E1DC: 419A0024  beq cr6, 0x8219e200
	if ctx.cr[6].eq {
	pc = 0x8219E200; continue 'dispatch;
	}
	// 8219E1E0: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 8219E1E4: 6129EB2B  ori r9, r9, 0xeb2b
	ctx.r[9].u64 = ctx.r[9].u64 | 60203;
	// 8219E1E8: 7D2B48AE  lbzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8219E1EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219E1F0: 409A0010  bne cr6, 0x8219e200
	if !ctx.cr[6].eq {
	pc = 0x8219E200; continue 'dispatch;
	}
	// 8219E1F4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219E1F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E1FC: 409A0028  bne cr6, 0x8219e224
	if !ctx.cr[6].eq {
		sub_8219E214(ctx, base);
		return;
	}
	// 8219E200: A16A0014  lhz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219E204: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8219E208: 616B0800  ori r11, r11, 0x800
	ctx.r[11].u64 = ctx.r[11].u64 | 2048;
	// 8219E20C: B16A0014  sth r11, 0x14(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 8219E210: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E214(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219E214 size=40
    let mut pc: u32 = 0x8219E214;
    'dispatch: loop {
        match pc {
            0x8219E214 => {
    //   block [0x8219E214..0x8219E23C)
	// 8219E214: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8219E218: 419AFFE8  beq cr6, 0x8219e200
	if ctx.cr[6].eq {
		sub_8219E1A0(ctx, base);
		return;
	}
	// 8219E21C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8219E220: 409A0014  bne cr6, 0x8219e234
	if !ctx.cr[6].eq {
	pc = 0x8219E234; continue 'dispatch;
	}
	// 8219E224: A16A0014  lhz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219E228: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 8219E22C: 556B0566  rlwinm r11, r11, 0, 0x15, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219E230: B16A0014  sth r11, 0x14(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 8219E234: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8219E238: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219E240 size=188
    let mut pc: u32 = 0x8219E240;
    'dispatch: loop {
        match pc {
            0x8219E240 => {
    //   block [0x8219E240..0x8219E2FC)
	// 8219E240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219E244: 48396E79  bl 0x825350bc
	ctx.lr = 0x8219E248;
	sub_82535080(ctx, base);
	// 8219E248: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219E24C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219E250: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 8219E254: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8219E258: F96AC448  std r11, -0x3bb8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(-15288 as u32), ctx.r[11].u64 ) };
	// 8219E25C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219E260: 3BABC470  addi r29, r11, -0x3b90
	ctx.r[29].s64 = ctx.r[11].s64 + -15248;
	// 8219E264: 817D002C  lwz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 8219E268: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219E26C: 419A0054  beq cr6, 0x8219e2c0
	if ctx.cr[6].eq {
	pc = 0x8219E2C0; continue 'dispatch;
	}
	// 8219E270: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219E274: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8219E278: 617EBE64  ori r30, r11, 0xbe64
	ctx.r[30].u64 = ctx.r[11].u64 | 48740;
	// 8219E27C: 419A000C  beq cr6, 0x8219e288
	if ctx.cr[6].eq {
	pc = 0x8219E288; continue 'dispatch;
	}
	// 8219E280: 7D7FF0AE  lbzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8219E284: 48000008  b 0x8219e28c
	pc = 0x8219E28C; continue 'dispatch;
	// 8219E288: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8219E28C: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 8219E290: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219E294: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8219E298: 48000069  bl 0x8219e300
	ctx.lr = 0x8219E29C;
	sub_8219E300(ctx, base);
	// 8219E29C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8219E2A0: 419A000C  beq cr6, 0x8219e2ac
	if ctx.cr[6].eq {
	pc = 0x8219E2AC; continue 'dispatch;
	}
	// 8219E2A4: 7D7FF0AE  lbzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8219E2A8: 48000008  b 0x8219e2b0
	pc = 0x8219E2B0; continue 'dispatch;
	// 8219E2AC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8219E2B0: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219E2B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219E2B8: 388B0005  addi r4, r11, 5
	ctx.r[4].s64 = ctx.r[11].s64 + 5;
	// 8219E2BC: 48000045  bl 0x8219e300
	ctx.lr = 0x8219E2C0;
	sub_8219E300(ctx, base);
	// 8219E2C0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8219E2C4: 394BF800  addi r10, r11, -0x800
	ctx.r[10].s64 = ctx.r[11].s64 + -2048;
	// 8219E2C8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219E2CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E2D0: 419A0024  beq cr6, 0x8219e2f4
	if ctx.cr[6].eq {
	pc = 0x8219E2F4; continue 'dispatch;
	}
	// 8219E2D4: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219E2D8: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E2DC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219E2E0: 409A0014  bne cr6, 0x8219e2f4
	if !ctx.cr[6].eq {
	pc = 0x8219E2F4; continue 'dispatch;
	}
	// 8219E2E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E2E8: 419A000C  beq cr6, 0x8219e2f4
	if ctx.cr[6].eq {
	pc = 0x8219E2F4; continue 'dispatch;
	}
	// 8219E2EC: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 8219E2F0: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 8219E2F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219E2F8: 48396E14  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219E300 size=104
    let mut pc: u32 = 0x8219E300;
    'dispatch: loop {
        match pc {
            0x8219E300 => {
    //   block [0x8219E300..0x8219E368)
	// 8219E300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219E304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219E308: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219E30C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219E310: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219E314: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219E318: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219E31C: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8219E320: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8219E324: 419A002C  beq cr6, 0x8219e350
	if ctx.cr[6].eq {
	pc = 0x8219E350; continue 'dispatch;
	}
	// 8219E328: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219E32C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8219E330: 3FE0830F  lis r31, -0x7cf1
	ctx.r[31].s64 = -2096168960;
	// 8219E334: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219E338: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219E33C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219E340: 83DFFAC0  lwz r30, -0x540(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219E344: 907FFAC0  stw r3, -0x540(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-1344 as u32), ctx.r[3].u32 ) };
	// 8219E348: 481CBFB1  bl 0x8236a2f8
	ctx.lr = 0x8219E34C;
	sub_8236A2F8(ctx, base);
	// 8219E34C: 93DFFAC0  stw r30, -0x540(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-1344 as u32), ctx.r[30].u32 ) };
	// 8219E350: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219E354: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219E358: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219E35C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219E360: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219E364: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219E368 size=212
    let mut pc: u32 = 0x8219E368;
    'dispatch: loop {
        match pc {
            0x8219E368 => {
    //   block [0x8219E368..0x8219E43C)
	// 8219E368: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219E36C: 616B91F6  ori r11, r11, 0x91f6
	ctx.r[11].u64 = ctx.r[11].u64 | 37366;
	// 8219E370: 7D635A2E  lhzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219E374: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 8219E378: 409A0008  bne cr6, 0x8219e380
	if !ctx.cr[6].eq {
	pc = 0x8219E380; continue 'dispatch;
	}
	// 8219E37C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219E380: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 8219E384: 556A0462  rlwinm r10, r11, 0, 0x11, 0x11
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219E388: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8219E38C: 409A001C  bne cr6, 0x8219e3a8
	if !ctx.cr[6].eq {
	pc = 0x8219E3A8; continue 'dispatch;
	}
	// 8219E390: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 8219E394: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219E398: 614A9208  ori r10, r10, 0x9208
	ctx.r[10].u64 = ctx.r[10].u64 | 37384;
	// 8219E39C: 7D43502E  lwzx r10, r3, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219E3A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219E3A4: 419A0008  beq cr6, 0x8219e3ac
	if ctx.cr[6].eq {
	pc = 0x8219E3AC; continue 'dispatch;
	}
	// 8219E3A8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8219E3AC: 556B04A0  rlwinm r11, r11, 0, 0x12, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219E3B0: 3940000F  li r10, 0xf
	ctx.r[10].s64 = 15;
	// 8219E3B4: 7D690734  extsh r9, r11
	ctx.r[9].s64 = ctx.r[11].s16 as i64;
	// 8219E3B8: 2F090010  cmpwi cr6, r9, 0x10
	ctx.cr[6].compare_i32(ctx.r[9].s32, 16, &mut ctx.xer);
	// 8219E3BC: 41980008  blt cr6, 0x8219e3c4
	if ctx.cr[6].lt {
	pc = 0x8219E3C4; continue 'dispatch;
	}
	// 8219E3C0: 3940001F  li r10, 0x1f
	ctx.r[10].s64 = 31;
	// 8219E3C4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219E3C8: 616BF322  ori r11, r11, 0xf322
	ctx.r[11].u64 = ctx.r[11].u64 | 62242;
	// 8219E3CC: 7D635A2E  lhzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219E3D0: 556B0026  rlwinm r11, r11, 0, 0, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219E3D4: 2B0B1000  cmplwi cr6, r11, 0x1000
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4096 as u32, &mut ctx.xer);
	// 8219E3D8: 419A001C  beq cr6, 0x8219e3f4
	if ctx.cr[6].eq {
	pc = 0x8219E3F4; continue 'dispatch;
	}
	// 8219E3DC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219E3E0: 616BEB1B  ori r11, r11, 0xeb1b
	ctx.r[11].u64 = ctx.r[11].u64 | 60187;
	// 8219E3E4: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219E3E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E3EC: 409A0008  bne cr6, 0x8219e3f4
	if !ctx.cr[6].eq {
	pc = 0x8219E3F4; continue 'dispatch;
	}
	// 8219E3F0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219E3F4: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219E3F8: 7D470734  extsh r7, r10
	ctx.r[7].s64 = ctx.r[10].s16 as i64;
	// 8219E3FC: 616B9210  ori r11, r11, 0x9210
	ctx.r[11].u64 = ctx.r[11].u64 | 37392;
	// 8219E400: 7D63582E  lwzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219E404: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 8219E408: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 8219E40C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 8219E410: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 8219E414: 40990008  ble cr6, 0x8219e41c
	if !ctx.cr[6].gt {
	pc = 0x8219E41C; continue 'dispatch;
	}
	// 8219E418: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8219E41C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8219E420: 419A000C  beq cr6, 0x8219e42c
	if ctx.cr[6].eq {
	pc = 0x8219E42C; continue 'dispatch;
	}
	// 8219E424: 616B4000  ori r11, r11, 0x4000
	ctx.r[11].u64 = ctx.r[11].u64 | 16384;
	// 8219E428: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 8219E42C: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 8219E430: 614A91F4  ori r10, r10, 0x91f4
	ctx.r[10].u64 = ctx.r[10].u64 | 37364;
	// 8219E434: 7D63532E  sthx r11, r3, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u16) };
	// 8219E438: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219E440 size=1364
    let mut pc: u32 = 0x8219E440;
    'dispatch: loop {
        match pc {
            0x8219E440 => {
    //   block [0x8219E440..0x8219E994)
	// 8219E440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219E444: 48396C3D  bl 0x82535080
	ctx.lr = 0x8219E448;
	sub_82535080(ctx, base);
	// 8219E448: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 8219E44C: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219E450: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219E454: 90A10144  stw r5, 0x144(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), ctx.r[5].u32 ) };
	// 8219E458: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8219E45C: 616FBE64  ori r15, r11, 0xbe64
	ctx.r[15].u64 = ctx.r[11].u64 | 48740;
	// 8219E460: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219E464: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8219E468: 3B2BC470  addi r25, r11, -0x3b90
	ctx.r[25].s64 = ctx.r[11].s64 + -15248;
	// 8219E46C: 419A0024  beq cr6, 0x8219e490
	if ctx.cr[6].eq {
	pc = 0x8219E490; continue 'dispatch;
	}
	// 8219E470: 7D7B78AE  lbzx r11, r27, r15
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[15].u32)) } as u64;
	// 8219E474: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8219E478: 40980018  bge cr6, 0x8219e490
	if !ctx.cr[6].lt {
	pc = 0x8219E490; continue 'dispatch;
	}
	// 8219E47C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8219E480: 419A0010  beq cr6, 0x8219e490
	if ctx.cr[6].eq {
	pc = 0x8219E490; continue 'dispatch;
	}
	// 8219E484: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219E488: 39590180  addi r10, r25, 0x180
	ctx.r[10].s64 = ctx.r[25].s64 + 384;
	// 8219E48C: 7CAB512E  stwx r5, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 8219E490: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 8219E494: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219E498: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	// 8219E49C: 396B1410  addi r11, r11, 0x1410
	ctx.r[11].s64 = ctx.r[11].s64 + 5136;
	// 8219E4A0: 3D2082CF  lis r9, -0x7d31
	ctx.r[9].s64 = -2100363264;
	// 8219E4A4: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 8219E4A8: 914B0084  stw r10, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 8219E4AC: 914B0088  stw r10, 0x88(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 8219E4B0: F949C448  std r10, -0x3bb8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(-15288 as u32), ctx.r[10].u64 ) };
	// 8219E4B4: 7EA9AB78  mr r9, r21
	ctx.r[9].u64 = ctx.r[21].u64;
	// 8219E4B8: 914B008C  stw r10, 0x8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 8219E4BC: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 8219E4C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219E4C4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8219E4C8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8219E4CC: 4200FFF8  bdnz 0x8219e4c4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8219E4C4; continue 'dispatch;
	}
	// 8219E4D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219E4D4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8219E4D8: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219E4DC: 419A006C  beq cr6, 0x8219e548
	if ctx.cr[6].eq {
	pc = 0x8219E548; continue 'dispatch;
	}
	// 8219E4E0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219E4E4: 7D3B78AE  lbzx r9, r27, r15
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[15].u32)) } as u64;
	// 8219E4E8: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219E4EC: 396B1290  addi r11, r11, 0x1290
	ctx.r[11].s64 = ctx.r[11].s64 + 4752;
	// 8219E4F0: C1AA20C8  lfs f13, 0x20c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8392 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219E4F4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219E4F8: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219E4FC: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 8219E500: C18AD4CC  lfs f12, -0x2b34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11060 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219E504: 1D49002C  mulli r10, r9, 0x2c
	ctx.r[10].s64 = ctx.r[9].s64 * 44;
	// 8219E508: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8219E50C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219E510: C1692938  lfs f11, 0x2938(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10552 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219E514: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8219E518: D3EB000C  stfs f31, 0xc(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8219E51C: 92AB0004  stw r21, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[21].u32 ) };
	// 8219E520: D3EB0008  stfs f31, 8(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219E524: 92AB0000  stw r21, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[21].u32 ) };
	// 8219E528: D1AB0010  stfs f13, 0x10(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219E52C: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219E530: C1492094  lfs f10, 0x2094(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8340 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219E534: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219E538: D18B001C  stfs f12, 0x1c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219E53C: D16B0020  stfs f11, 0x20(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219E540: D14B0024  stfs f10, 0x24(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219E544: D00B0028  stfs f0, 0x28(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8219E548: 8179002C  lwz r11, 0x2c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) } as u64;
	// 8219E54C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219E550: 419A0438  beq cr6, 0x8219e988
	if ctx.cr[6].eq {
	pc = 0x8219E988; continue 'dispatch;
	}
	// 8219E554: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8219E558: 419A0430  beq cr6, 0x8219e988
	if ctx.cr[6].eq {
	pc = 0x8219E988; continue 'dispatch;
	}
	// 8219E55C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219E560: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8219E564: 617CBEB8  ori r28, r11, 0xbeb8
	ctx.r[28].u64 = ctx.r[11].u64 | 48824;
	// 8219E568: 409A01C8  bne cr6, 0x8219e730
	if !ctx.cr[6].eq {
	pc = 0x8219E730; continue 'dispatch;
	}
	// 8219E56C: 7FBBE214  add r29, r27, r28
	ctx.r[29].u64 = ctx.r[27].u64 + ctx.r[28].u64;
	// 8219E570: 3BE00400  li r31, 0x400
	ctx.r[31].s64 = 1024;
	// 8219E574: A17D0000  lhz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E578: 2B0B0026  cmplwi cr6, r11, 0x26
	ctx.cr[6].compare_u32(ctx.r[11].u32, 38 as u32, &mut ctx.xer);
	// 8219E57C: 409A0030  bne cr6, 0x8219e5ac
	if !ctx.cr[6].eq {
	pc = 0x8219E5AC; continue 'dispatch;
	}
	// 8219E580: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219E584: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219E588: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219E58C: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 8219E590: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8219E594: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219E598: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 8219E59C: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 8219E5A0: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 8219E5A4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219E5A8: 4800E871  bl 0x821ace18
	ctx.lr = 0x8219E5AC;
	sub_821ACE18(ctx, base);
	// 8219E5AC: A17D0000  lhz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E5B0: 2B0B0027  cmplwi cr6, r11, 0x27
	ctx.cr[6].compare_u32(ctx.r[11].u32, 39 as u32, &mut ctx.xer);
	// 8219E5B4: 409A005C  bne cr6, 0x8219e610
	if !ctx.cr[6].eq {
	pc = 0x8219E610; continue 'dispatch;
	}
	// 8219E5B8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219E5BC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219E5C0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219E5C4: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 8219E5C8: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8219E5CC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219E5D0: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 8219E5D4: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 8219E5D8: 38800019  li r4, 0x19
	ctx.r[4].s64 = 25;
	// 8219E5DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219E5E0: 4800E839  bl 0x821ace18
	ctx.lr = 0x8219E5E4;
	sub_821ACE18(ctx, base);
	// 8219E5E4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219E5E8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219E5EC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219E5F0: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8219E5F4: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 8219E5F8: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 8219E5FC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219E600: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 8219E604: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 8219E608: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219E60C: 4800E80D  bl 0x821ace18
	ctx.lr = 0x8219E610;
	sub_821ACE18(ctx, base);
	// 8219E610: A17D0000  lhz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E614: 2B0B0024  cmplwi cr6, r11, 0x24
	ctx.cr[6].compare_u32(ctx.r[11].u32, 36 as u32, &mut ctx.xer);
	// 8219E618: 409A0030  bne cr6, 0x8219e648
	if !ctx.cr[6].eq {
	pc = 0x8219E648; continue 'dispatch;
	}
	// 8219E61C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219E620: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219E624: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 8219E628: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 8219E62C: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8219E630: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219E634: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 8219E638: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 8219E63C: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 8219E640: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219E644: 4800E7D5  bl 0x821ace18
	ctx.lr = 0x8219E648;
	sub_821ACE18(ctx, base);
	// 8219E648: A17D0000  lhz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E64C: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 8219E650: 409A007C  bne cr6, 0x8219e6cc
	if !ctx.cr[6].eq {
	pc = 0x8219E6CC; continue 'dispatch;
	}
	// 8219E654: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219E658: 616BBF12  ori r11, r11, 0xbf12
	ctx.r[11].u64 = ctx.r[11].u64 | 48914;
	// 8219E65C: 7D7B5A2E  lhzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219E660: 2B0B0528  cmplwi cr6, r11, 0x528
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1320 as u32, &mut ctx.xer);
	// 8219E664: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 8219E668: 419A0008  beq cr6, 0x8219e670
	if ctx.cr[6].eq {
	pc = 0x8219E670; continue 'dispatch;
	}
	// 8219E66C: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 8219E670: 7D7E0734  extsh r30, r11
	ctx.r[30].s64 = ctx.r[11].s16 as i64;
	// 8219E674: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219E678: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219E67C: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 8219E680: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8219E684: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219E688: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 8219E68C: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 8219E690: 38800019  li r4, 0x19
	ctx.r[4].s64 = 25;
	// 8219E694: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219E698: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 8219E69C: 4800E77D  bl 0x821ace18
	ctx.lr = 0x8219E6A0;
	sub_821ACE18(ctx, base);
	// 8219E6A0: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219E6A4: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 8219E6A8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219E6AC: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8219E6B0: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 8219E6B4: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 8219E6B8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219E6BC: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 8219E6C0: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 8219E6C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219E6C8: 4800E751  bl 0x821ace18
	ctx.lr = 0x8219E6CC;
	sub_821ACE18(ctx, base);
	// 8219E6CC: A17D0000  lhz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E6D0: 2B0B0011  cmplwi cr6, r11, 0x11
	ctx.cr[6].compare_u32(ctx.r[11].u32, 17 as u32, &mut ctx.xer);
	// 8219E6D4: 409A005C  bne cr6, 0x8219e730
	if !ctx.cr[6].eq {
	pc = 0x8219E730; continue 'dispatch;
	}
	// 8219E6D8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219E6DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219E6E0: 39000090  li r8, 0x90
	ctx.r[8].s64 = 144;
	// 8219E6E4: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 8219E6E8: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8219E6EC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219E6F0: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 8219E6F4: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 8219E6F8: 38800019  li r4, 0x19
	ctx.r[4].s64 = 25;
	// 8219E6FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219E700: 4800E719  bl 0x821ace18
	ctx.lr = 0x8219E704;
	sub_821ACE18(ctx, base);
	// 8219E704: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219E708: 39000090  li r8, 0x90
	ctx.r[8].s64 = 144;
	// 8219E70C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219E710: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8219E714: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 8219E718: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 8219E71C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219E720: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 8219E724: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 8219E728: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219E72C: 4800E6ED  bl 0x821ace18
	ctx.lr = 0x8219E730;
	sub_821ACE18(ctx, base);
	// 8219E730: 7FDBE214  add r30, r27, r28
	ctx.r[30].u64 = ctx.r[27].u64 + ctx.r[28].u64;
	// 8219E734: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E738: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 8219E73C: 2B0B0029  cmplwi cr6, r11, 0x29
	ctx.cr[6].compare_u32(ctx.r[11].u32, 41 as u32, &mut ctx.xer);
	// 8219E740: 409A0060  bne cr6, 0x8219e7a0
	if !ctx.cr[6].eq {
	pc = 0x8219E7A0; continue 'dispatch;
	}
	// 8219E744: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219E748: 39590018  addi r10, r25, 0x18
	ctx.r[10].s64 = ctx.r[25].s64 + 24;
	// 8219E74C: 38EB0C14  addi r7, r11, 0xc14
	ctx.r[7].s64 = ctx.r[11].s64 + 3092;
	// 8219E750: 7D7B78AE  lbzx r11, r27, r15
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[15].u32)) } as u64;
	// 8219E754: 3FFB0006  addis r31, r27, 6
	ctx.r[31].s64 = ctx.r[27].s64 + 393216;
	// 8219E758: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8219E75C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219E760: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219E764: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 8219E768: 3BFFA908  addi r31, r31, -0x56f8
	ctx.r[31].s64 = ctx.r[31].s64 + -22264;
	// 8219E76C: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219E770: 481CBD21  bl 0x8236a490
	ctx.lr = 0x8219E774;
	sub_8236A490(ctx, base);
	// 8219E774: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219E778: 419A000C  beq cr6, 0x8219e784
	if ctx.cr[6].eq {
	pc = 0x8219E784; continue 'dispatch;
	}
	// 8219E77C: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219E780: 48000008  b 0x8219e788
	pc = 0x8219E788; continue 'dispatch;
	// 8219E784: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 8219E788: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219E78C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219E790: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 8219E794: 419A000C  beq cr6, 0x8219e7a0
	if ctx.cr[6].eq {
	pc = 0x8219E7A0; continue 'dispatch;
	}
	// 8219E798: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8219E79C: 4BFB0FD5  bl 0x8214f770
	ctx.lr = 0x8219E7A0;
	sub_8214F770(ctx, base);
	// 8219E7A0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219E7A4: 7EB3AB78  mr r19, r21
	ctx.r[19].u64 = ctx.r[21].u64;
	// 8219E7A8: 3A2B0C20  addi r17, r11, 0xc20
	ctx.r[17].s64 = ctx.r[11].s64 + 3104;
	// 8219E7AC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219E7B0: 7E328B78  mr r18, r17
	ctx.r[18].u64 = ctx.r[17].u64;
	// 8219E7B4: 3AEB0CB0  addi r23, r11, 0xcb0
	ctx.r[23].s64 = ctx.r[11].s64 + 3248;
	// 8219E7B8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219E7BC: 7EB0AB78  mr r16, r21
	ctx.r[16].u64 = ctx.r[21].u64;
	// 8219E7C0: 3A8B0CC0  addi r20, r11, 0xcc0
	ctx.r[20].s64 = ctx.r[11].s64 + 3264;
	// 8219E7C4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219E7C8: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 8219E7CC: 616EBECC  ori r14, r11, 0xbecc
	ctx.r[14].u64 = ctx.r[11].u64 | 48844;
	// 8219E7D0: 89720000  lbz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E7D4: A15E0000  lhz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E7D8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219E7DC: 409A0198  bne cr6, 0x8219e974
	if !ctx.cr[6].eq {
	pc = 0x8219E974; continue 'dispatch;
	}
	// 8219E7E0: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219E7E4: 614ABEBA  ori r10, r10, 0xbeba
	ctx.r[10].u64 = ctx.r[10].u64 | 48826;
	// 8219E7E8: 7D5B522E  lhzx r10, r27, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219E7EC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219E7F0: 409A0184  bne cr6, 0x8219e974
	if !ctx.cr[6].eq {
	pc = 0x8219E974; continue 'dispatch;
	}
	// 8219E7F4: 7D7B702E  lwzx r11, r27, r14
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[14].u32)) } as u64;
	// 8219E7F8: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 8219E7FC: 4098018C  bge cr6, 0x8219e988
	if !ctx.cr[6].lt {
	pc = 0x8219E988; continue 'dispatch;
	}
	// 8219E800: 7D735A14  add r11, r19, r11
	ctx.r[11].u64 = ctx.r[19].u64 + ctx.r[11].u64;
	// 8219E804: 39510002  addi r10, r17, 2
	ctx.r[10].s64 = ctx.r[17].s64 + 2;
	// 8219E808: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219E80C: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219E810: 7D7C0734  extsh r28, r11
	ctx.r[28].s64 = ctx.r[11].s16 as i64;
	// 8219E814: 2F1CFFFF  cmpwi cr6, r28, -1
	ctx.cr[6].compare_i32(ctx.r[28].s32, -1, &mut ctx.xer);
	// 8219E818: 419A0170  beq cr6, 0x8219e988
	if ctx.cr[6].eq {
	pc = 0x8219E988; continue 'dispatch;
	}
	// 8219E81C: FAA10068  std r21, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[21].u64 ) };
	// 8219E820: 3BDB0030  addi r30, r27, 0x30
	ctx.r[30].s64 = ctx.r[27].s64 + 48;
	// 8219E824: 7F5B7A14  add r26, r27, r15
	ctx.r[26].u64 = ctx.r[27].u64 + ctx.r[15].u64;
	// 8219E828: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	// 8219E82C: 3B000002  li r24, 2
	ctx.r[24].s64 = 2;
	// 8219E830: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8219E834: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8219E838: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8219E83C: 4BF8698D  bl 0x821251c8
	ctx.lr = 0x8219E840;
	sub_821251C8(ctx, base);
	// 8219E840: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219E844: 39590004  addi r10, r25, 4
	ctx.r[10].s64 = ctx.r[25].s64 + 4;
	// 8219E848: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219E84C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8219E850: 92C10054  stw r22, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[22].u32 ) };
	// 8219E854: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219E858: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8219E85C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219E860: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219E864: 7CAB502E  lwzx r5, r11, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219E868: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219E86C: 481AD0F5  bl 0x8234b960
	ctx.lr = 0x8219E870;
	sub_8234B960(ctx, base);
	// 8219E870: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E874: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219E878: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219E87C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219E880: 4E800421  bctrl
	ctx.lr = 0x8219E884;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219E884: EBE10068  ld r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8219E888: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8219E88C: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219E894: 481AD4CD  bl 0x8234bd60
	ctx.lr = 0x8219E898;
	sub_8234BD60(ctx, base);
	// 8219E898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219E89C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8219E8A0: 481AD809  bl 0x8234c0a8
	ctx.lr = 0x8219E8A4;
	sub_8234C0A8(ctx, base);
	// 8219E8A4: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8219E8A8: 81010068  lwz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8219E8AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E8B0: 419A0020  beq cr6, 0x8219e8d0
	if ctx.cr[6].eq {
	pc = 0x8219E8D0; continue 'dispatch;
	}
	// 8219E8B4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219E8B8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8219E8BC: 409A0014  bne cr6, 0x8219e8d0
	if !ctx.cr[6].eq {
	pc = 0x8219E8D0; continue 'dispatch;
	}
	// 8219E8C0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219E8C4: D3EB00A8  stfs f31, 0xa8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8219E8C8: 614A0004  ori r10, r10, 4
	ctx.r[10].u64 = ctx.r[10].u64 | 4;
	// 8219E8CC: 914B008C  stw r10, 0x8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 8219E8D0: 895A0000  lbz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E8D4: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 8219E8D8: 40980088  bge cr6, 0x8219e960
	if !ctx.cr[6].lt {
	pc = 0x8219E960; continue 'dispatch;
	}
	// 8219E8DC: 81210144  lwz r9, 0x144(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 8219E8E0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219E8E4: 419A007C  beq cr6, 0x8219e960
	if ctx.cr[6].eq {
	pc = 0x8219E960; continue 'dispatch;
	}
	// 8219E8E8: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E8EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219E8F0: 419A0014  beq cr6, 0x8219e904
	if ctx.cr[6].eq {
	pc = 0x8219E904; continue 'dispatch;
	}
	// 8219E8F4: 80EA001C  lwz r7, 0x1c(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219E8F8: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219E8FC: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219E900: 419A0008  beq cr6, 0x8219e908
	if ctx.cr[6].eq {
	pc = 0x8219E908; continue 'dispatch;
	}
	// 8219E904: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	// 8219E908: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8219E90C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E910: 912A0018  stw r9, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 8219E914: 419A0024  beq cr6, 0x8219e938
	if ctx.cr[6].eq {
	pc = 0x8219E938; continue 'dispatch;
	}
	// 8219E918: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219E91C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8219E920: 409A0018  bne cr6, 0x8219e938
	if !ctx.cr[6].eq {
	pc = 0x8219E938; continue 'dispatch;
	}
	// 8219E924: 39490080  addi r10, r9, 0x80
	ctx.r[10].s64 = ctx.r[9].s64 + 128;
	// 8219E928: 892B0090  lbz r9, 0x90(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 8219E92C: 61290008  ori r9, r9, 8
	ctx.r[9].u64 = ctx.r[9].u64 | 8;
	// 8219E930: 992B0090  stb r9, 0x90(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[9].u8 ) };
	// 8219E934: 914B0448  stw r10, 0x448(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1096 as u32), ctx.r[10].u32 ) };
	// 8219E938: 895A0000  lbz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E93C: 39390180  addi r9, r25, 0x180
	ctx.r[9].s64 = ctx.r[25].s64 + 384;
	// 8219E940: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E944: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8219E948: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8219E94C: 419A0014  beq cr6, 0x8219e960
	if ctx.cr[6].eq {
	pc = 0x8219E960; continue 'dispatch;
	}
	// 8219E950: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219E954: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8219E958: 409A0008  bne cr6, 0x8219e960
	if !ctx.cr[6].eq {
	pc = 0x8219E960; continue 'dispatch;
	}
	// 8219E95C: 914B044C  stw r10, 0x44c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1100 as u32), ctx.r[10].u32 ) };
	// 8219E960: 3B18FFFF  addi r24, r24, -1
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	// 8219E964: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 8219E968: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 8219E96C: 409AFEC4  bne cr6, 0x8219e830
	if !ctx.cr[6].eq {
	pc = 0x8219E830; continue 'dispatch;
	}
	// 8219E970: 83C10060  lwz r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8219E974: 3A100012  addi r16, r16, 0x12
	ctx.r[16].s64 = ctx.r[16].s64 + 18;
	// 8219E978: 3A520012  addi r18, r18, 0x12
	ctx.r[18].s64 = ctx.r[18].s64 + 18;
	// 8219E97C: 3A730009  addi r19, r19, 9
	ctx.r[19].s64 = ctx.r[19].s64 + 9;
	// 8219E980: 2B100090  cmplwi cr6, r16, 0x90
	ctx.cr[6].compare_u32(ctx.r[16].u32, 144 as u32, &mut ctx.xer);
	// 8219E984: 4198FE4C  blt cr6, 0x8219e7d0
	if ctx.cr[6].lt {
	pc = 0x8219E7D0; continue 'dispatch;
	}
	// 8219E988: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 8219E98C: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 8219E990: 48396740  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219E998 size=184
    let mut pc: u32 = 0x8219E998;
    'dispatch: loop {
        match pc {
            0x8219E998 => {
    //   block [0x8219E998..0x8219EA50)
	// 8219E998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219E99C: 4839671D  bl 0x825350b8
	ctx.lr = 0x8219E9A0;
	sub_82535080(ctx, base);
	// 8219E9A0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219E9A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219E9A8: 7CBE0734  extsh r30, r5
	ctx.r[30].s64 = ctx.r[5].s16 as i64;
	// 8219E9AC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8219E9B0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 8219E9B4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8219E9B8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8219E9BC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8219E9C0: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 8219E9C4: 480128C5  bl 0x821b1288
	ctx.lr = 0x8219E9C8;
	sub_821B1288(ctx, base);
	// 8219E9C8: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8219E9CC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 8219E9D0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8219E9D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E9D8: 419A0018  beq cr6, 0x8219e9f0
	if ctx.cr[6].eq {
	pc = 0x8219E9F0; continue 'dispatch;
	}
	// 8219E9DC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219E9E0: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 8219E9E4: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8219E9E8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219E9EC: 419A0008  beq cr6, 0x8219e9f4
	if ctx.cr[6].eq {
	pc = 0x8219E9F4; continue 'dispatch;
	}
	// 8219E9F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219E9F4: 2F1E005A  cmpwi cr6, r30, 0x5a
	ctx.cr[6].compare_i32(ctx.r[30].s32, 90, &mut ctx.xer);
	// 8219E9F8: 409A0010  bne cr6, 0x8219ea08
	if !ctx.cr[6].eq {
	pc = 0x8219EA08; continue 'dispatch;
	}
	// 8219E9FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219EA00: 419A0048  beq cr6, 0x8219ea48
	if ctx.cr[6].eq {
	pc = 0x8219EA48; continue 'dispatch;
	}
	// 8219EA04: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8219EA08: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219EA0C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219EA10: 7F8A0734  extsh r10, r28
	ctx.r[10].s64 = ctx.r[28].s16 as i64;
	// 8219EA14: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 8219EA18: 5545103A  slwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 8219EA1C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219EA20: C04BBA38  lfs f2, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219EA24: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8219EA28: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219EA2C: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 8219EA30: 396B1594  addi r11, r11, 0x1594
	ctx.r[11].s64 = ctx.r[11].s64 + 5524;
	// 8219EA34: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 8219EA38: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8219EA3C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8219EA40: 7C65582E  lwzx r3, r5, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219EA44: 4800BFB5  bl 0x821aa9f8
	ctx.lr = 0x8219EA48;
	sub_821AA9F8(ctx, base);
	// 8219EA48: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8219EA4C: 483966BC  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219EA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219EA50 size=420
    let mut pc: u32 = 0x8219EA50;
    'dispatch: loop {
        match pc {
            0x8219EA50 => {
    //   block [0x8219EA50..0x8219EBF4)
	// 8219EA50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219EA54: 48396659  bl 0x825350ac
	ctx.lr = 0x8219EA58;
	sub_82535080(ctx, base);
	// 8219EA58: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219EA5C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 8219EA60: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8219EA64: 397A3C67  addi r11, r26, 0x3c67
	ctx.r[11].s64 = ctx.r[26].s64 + 15463;
	// 8219EA68: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 8219EA6C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219EA70: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 8219EA74: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 8219EA78: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 8219EA7C: 613CE338  ori r28, r9, 0xe338
	ctx.r[28].u64 = ctx.r[9].u64 | 58168;
	// 8219EA80: 7D6BE82A  ldx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) };
	// 8219EA84: 556A0252  rlwinm r10, r11, 0, 9, 9
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219EA88: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 8219EA8C: 419A0044  beq cr6, 0x8219ead0
	if ctx.cr[6].eq {
	pc = 0x8219EAD0; continue 'dispatch;
	}
	// 8219EA90: 3BE00016  li r31, 0x16
	ctx.r[31].s64 = 22;
	// 8219EA94: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219EA98: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 8219EA9C: 616BA9C0  ori r11, r11, 0xa9c0
	ctx.r[11].u64 = ctx.r[11].u64 | 43456;
	// 8219EAA0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8219EAA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219EAA8: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219EAAC: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 8219EAB0: 4BFBB1F9  bl 0x82159ca8
	ctx.lr = 0x8219EAB4;
	sub_82159CA8(ctx, base);
	// 8219EAB4: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219EAB8: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 8219EABC: 409A00BC  bne cr6, 0x8219eb78
	if !ctx.cr[6].eq {
	pc = 0x8219EB78; continue 'dispatch;
	}
	// 8219EAC0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219EBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219EBF8 size=584
    let mut pc: u32 = 0x8219EBF8;
    'dispatch: loop {
        match pc {
            0x8219EBF8 => {
    //   block [0x8219EBF8..0x8219EE40)
	// 8219EBF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219EBFC: 483964BD  bl 0x825350b8
	ctx.lr = 0x8219EC00;
	sub_82535080(ctx, base);
	// 8219EC00: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8219EC04: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219EC08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219EC0C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8219EC10: 4BF90F41  bl 0x8212fb50
	ctx.lr = 0x8219EC14;
	sub_8212FB50(ctx, base);
	// 8219EC14: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219EC18: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219EC1C: 616BA9C0  ori r11, r11, 0xa9c0
	ctx.r[11].u64 = ctx.r[11].u64 | 43456;
	// 8219EC20: 615EE338  ori r30, r10, 0xe338
	ctx.r[30].u64 = ctx.r[10].u64 | 58168;
	// 8219EC24: 7C7D0734  extsh r29, r3
	ctx.r[29].s64 = ctx.r[3].s16 as i64;
	// 8219EC28: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 8219EC2C: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 8219EC30: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219EC34: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 8219EC38: 4BFBB071  bl 0x82159ca8
	ctx.lr = 0x8219EC3C;
	sub_82159CA8(ctx, base);
	// 8219EC3C: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 8219EC40: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 8219EC44: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 8219EC48: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8219EC4C: 7C7FF214  add r3, r31, r30
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[30].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219EE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219EE40 size=396
    let mut pc: u32 = 0x8219EE40;
    'dispatch: loop {
        match pc {
            0x8219EE40 => {
    //   block [0x8219EE40..0x8219EFCC)
	// 8219EE40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219EE44: 48396279  bl 0x825350bc
	ctx.lr = 0x8219EE48;
	sub_82535080(ctx, base);
	// 8219EE48: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8219EE4C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219EE50: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 8219EE54: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 8219EE58: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219EE5C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8219EE60: 816A4300  lwz r11, 0x4300(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17152 as u32) ) } as u64;
	// 8219EE64: C3E8BA38  lfs f31, -0x45c8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219EE68: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8219EE6C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219EE70: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 8219EE74: 3BE942F0  addi r31, r9, 0x42f0
	ctx.r[31].s64 = ctx.r[9].s64 + 17136;
	// 8219EE78: 409A0024  bne cr6, 0x8219ee9c
	if !ctx.cr[6].eq {
	pc = 0x8219EE9C; continue 'dispatch;
	}
	// 8219EE7C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8219EE80: 916A4300  stw r11, 0x4300(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(17152 as u32), ctx.r[11].u32 ) };
	// 8219EE84: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8219EE88: C00BD47C  lfs f0, -0x2b84(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219EE8C: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219EE90: D3FF0004  stfs f31, 4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8219EE94: D3FF0008  stfs f31, 8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219EE98: D3FF000C  stfs f31, 0xc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8219EE9C: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219EEA0: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 8219EEA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8219EEA8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219EEAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219EEB0: 4E800421  bctrl
	ctx.lr = 0x8219EEB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219EEB4: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219EEB8: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8219EEBC: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219EEC0: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8219EEC4: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219EEC8: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8219EECC: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8219EED0: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8219EED4: 481C8265  bl 0x82367138
	ctx.lr = 0x8219EED8;
	sub_82367138(ctx, base);
	// 8219EED8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219EEDC: C00B2068  lfs f0, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219EEE0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219EEE4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 8219EEE8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219EEEC: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8219EEF0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8219EEF4: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8219EEF8: C1AB2280  lfs f13, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219EEFC: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219EF00: ED8CF838  fmsubs f12, f12, f0, f31
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 8219EF04: D1810080  stfs f12, 0x80(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8219EF08: 481C8231  bl 0x82367138
	ctx.lr = 0x8219EF0C;
	sub_82367138(ctx, base);
	// 8219EF0C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219EF10: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 8219EF14: C9810060  lfd f12, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8219EF18: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8219EF1C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8219EF20: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219EF24: ED8CF838  fmsubs f12, f12, f0, f31
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 8219EF28: D1810084  stfs f12, 0x84(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8219EF2C: 481C820D  bl 0x82367138
	ctx.lr = 0x8219EF30;
	sub_82367138(ctx, base);
	// 8219EF30: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219EF34: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219EF38: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8219EF3C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219EF40: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 8219EF44: C9810060  lfd f12, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8219EF48: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8219EF4C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8219EF50: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219EF54: EC0DF838  fmsubs f0, f13, f0, f31
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 8219EF58: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8219EF5C: 48007C8D  bl 0x821a6be8
	ctx.lr = 0x8219EF60;
	sub_821A6BE8(ctx, base);
	// 8219EF60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219EF64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219EF68: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219EF6C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219EF70: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219EF74: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219EF78: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 8219EF7C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8219EF80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219EF84: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8219EF88: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219EF8C: 48002325  bl 0x821a12b0
	ctx.lr = 0x8219EF90;
	sub_821A12B0(ctx, base);
	// 8219EF90: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219EF94: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219EF98: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219EF9C: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 8219EFA0: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219EFA4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8219EFA8: 409A0018  bne cr6, 0x8219efc0
	if !ctx.cr[6].eq {
	pc = 0x8219EFC0; continue 'dispatch;
	}
	// 8219EFAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219EFB0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8219EFB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219EFB8: 38600009  li r3, 9
	ctx.r[3].s64 = 9;
	// 8219EFBC: 4BFDDE45  bl 0x8217ce00
	ctx.lr = 0x8219EFC0;
	sub_8217CE00(ctx, base);
	// 8219EFC0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8219EFC4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8219EFC8: 48396144  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219EFD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219EFD0 size=96
    let mut pc: u32 = 0x8219EFD0;
    'dispatch: loop {
        match pc {
            0x8219EFD0 => {
    //   block [0x8219EFD0..0x8219F030)
	// 8219EFD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219EFD4: 483960E1  bl 0x825350b4
	ctx.lr = 0x8219EFD8;
	sub_82535080(ctx, base);
	// 8219EFD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219EFDC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219EFE0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8219EFE4: 3B8BC450  addi r28, r11, -0x3bb0
	ctx.r[28].s64 = ctx.r[11].s64 + -15280;
	// 8219EFE8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8219EFEC: A17C0000  lhz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219EFF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219EFF4: 419A0034  beq cr6, 0x8219f028
	if ctx.cr[6].eq {
	pc = 0x8219F028; continue 'dispatch;
	}
	// 8219EFF8: 3BFC000C  addi r31, r28, 0xc
	ctx.r[31].s64 = ctx.r[28].s64 + 12;
	// 8219EFFC: 3BDC0002  addi r30, r28, 2
	ctx.r[30].s64 = ctx.r[28].s64 + 2;
	// 8219F000: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219F004: A0BE0000  lhz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F008: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F00C: 481AD14D  bl 0x8234c158
	ctx.lr = 0x8219F010;
	sub_8234C158(ctx, base);
	// 8219F010: A17C0000  lhz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F014: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 8219F018: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 8219F01C: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 8219F020: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8219F024: 4198FFDC  blt cr6, 0x8219f000
	if ctx.cr[6].lt {
	pc = 0x8219F000; continue 'dispatch;
	}
	// 8219F028: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8219F02C: 483960D8  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219F030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219F030 size=1828
    let mut pc: u32 = 0x8219F030;
    'dispatch: loop {
        match pc {
            0x8219F030 => {
    //   block [0x8219F030..0x8219F754)
	// 8219F030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219F034: 48396051  bl 0x82535084
	ctx.lr = 0x8219F038;
	sub_82535080(ctx, base);
	// 8219F038: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 8219F03C: 48396FA1  bl 0x82535fdc
	ctx.lr = 0x8219F040;
	sub_82535FB0(ctx, base);
	// 8219F040: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219F044: 54BE057E  clrlwi r30, r5, 0x15
	ctx.r[30].u64 = ctx.r[5].u32 as u64 & 0x000007FFu64;
	// 8219F048: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 8219F04C: 3A400000  li r18, 0
	ctx.r[18].s64 = 0;
	// 8219F050: FF601090  fmr f27, f2
	ctx.f[27].f64 = ctx.f[2].f64;
	// 8219F054: 397EFFA8  addi r11, r30, -0x58
	ctx.r[11].s64 = ctx.r[30].s64 + -88;
	// 8219F058: FF401890  fmr f26, f3
	ctx.f[26].f64 = ctx.f[3].f64;
	// 8219F05C: 7E5F9378  mr r31, r18
	ctx.r[31].u64 = ctx.r[18].u64;
	// 8219F060: FF202090  fmr f25, f4
	ctx.f[25].f64 = ctx.f[4].f64;
	// 8219F064: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8219F068: FFC02890  fmr f30, f5
	ctx.f[30].f64 = ctx.f[5].f64;
	// 8219F06C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219F070: FFA03090  fmr f29, f6
	ctx.f[29].f64 = ctx.f[6].f64;
	// 8219F074: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F078: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 8219F07C: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 8219F080: FBE10068  std r31, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u64 ) };
	// 8219F084: 7CCF3378  mr r15, r6
	ctx.r[15].u64 = ctx.r[6].u64;
	// 8219F088: 54B40428  rlwinm r20, r5, 0, 0x10, 0x14
	ctx.r[20].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F08C: 6151BE64  ori r17, r10, 0xbe64
	ctx.r[17].u64 = ctx.r[10].u64 | 48740;
	// 8219F090: 3A0BC450  addi r16, r11, -0x3bb0
	ctx.r[16].s64 = ctx.r[11].s64 + -15280;
	// 8219F094: 419902A0  bgt cr6, 0x8219f334
	if ctx.cr[6].gt {
	pc = 0x8219F334; continue 'dispatch;
	}
	// 8219F098: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	// 8219F09C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8219F0A0: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8219F0A4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219F0A8: 480121E1  bl 0x821b1288
	ctx.lr = 0x8219F0AC;
	sub_821B1288(ctx, base);
	// 8219F0AC: EB230000  ld r25, 0(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8219F0B0: FB210060  std r25, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u64 ) };
	// 8219F0B4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8219F0B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F0BC: 419A0018  beq cr6, 0x8219f0d4
	if ctx.cr[6].eq {
	pc = 0x8219F0D4; continue 'dispatch;
	}
	// 8219F0C0: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F0C4: 3B4B0080  addi r26, r11, 0x80
	ctx.r[26].s64 = ctx.r[11].s64 + 128;
	// 8219F0C8: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8219F0CC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219F0D0: 419A0008  beq cr6, 0x8219f0d8
	if ctx.cr[6].eq {
	pc = 0x8219F0D8; continue 'dispatch;
	}
	// 8219F0D4: 7E5A9378  mr r26, r18
	ctx.r[26].u64 = ctx.r[18].u64;
	// 8219F0D8: 2F1E005A  cmpwi cr6, r30, 0x5a
	ctx.cr[6].compare_i32(ctx.r[30].s32, 90, &mut ctx.xer);
	// 8219F0DC: 409A0014  bne cr6, 0x8219f0f0
	if !ctx.cr[6].eq {
	pc = 0x8219F0F0; continue 'dispatch;
	}
	// 8219F0E0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8219F0E4: 409A000C  bne cr6, 0x8219f0f0
	if !ctx.cr[6].eq {
	pc = 0x8219F0F0; continue 'dispatch;
	}
	// 8219F0E8: 7E5F9378  mr r31, r18
	ctx.r[31].u64 = ctx.r[18].u64;
	// 8219F0EC: 4800062C  b 0x8219f718
	pc = 0x8219F718; continue 'dispatch;
	// 8219F0F0: 396FFFF9  addi r11, r15, -7
	ctx.r[11].s64 = ctx.r[15].s64 + -7;
	// 8219F0F4: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 8219F0F8: 41990034  bgt cr6, 0x8219f12c
	if ctx.cr[6].gt {
	pc = 0x8219F12C; continue 'dispatch;
	}
	// 8219F0FC: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 8219F100: 419A0018  beq cr6, 0x8219f118
	if ctx.cr[6].eq {
	pc = 0x8219F118; continue 'dispatch;
	}
	// 8219F104: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F108: 7D5388AE  lbzx r10, r19, r17
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[17].u32)) } as u64;
	// 8219F10C: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219F110: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 8219F114: 48000038  b 0x8219f14c
	pc = 0x8219F14C; continue 'dispatch;
	// 8219F118: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F11C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8219F120: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219F124: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 8219F128: 48000024  b 0x8219f14c
	pc = 0x8219F14C; continue 'dispatch;
	// 8219F12C: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 8219F130: 419A000C  beq cr6, 0x8219f13c
	if ctx.cr[6].eq {
	pc = 0x8219F13C; continue 'dispatch;
	}
	// 8219F134: 7D5388AE  lbzx r10, r19, r17
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[17].u32)) } as u64;
	// 8219F138: 48000008  b 0x8219f140
	pc = 0x8219F140; continue 'dispatch;
	// 8219F13C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8219F140: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F144: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219F148: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 8219F14C: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219F150: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 8219F154: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219F158: 92410054  stw r18, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[18].u32 ) };
	// 8219F15C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219F160: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219F164: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 8219F168: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8219F16C: 7CAA582E  lwzx r5, r10, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219F170: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8219F174: 481AC7ED  bl 0x8234b960
	ctx.lr = 0x8219F178;
	sub_8234B960(ctx, base);
	// 8219F178: 8361006C  lwz r27, 0x6c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8219F17C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8219F180: 419A0594  beq cr6, 0x8219f714
	if ctx.cr[6].eq {
	pc = 0x8219F714; continue 'dispatch;
	}
	// 8219F184: 817B0030  lwz r11, 0x30(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F188: 3BBB0030  addi r29, r27, 0x30
	ctx.r[29].s64 = ctx.r[27].s64 + 48;
	// 8219F18C: 83810068  lwz r28, 0x68(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8219F190: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F194: 409A0580  bne cr6, 0x8219f714
	if !ctx.cr[6].eq {
	pc = 0x8219F714; continue 'dispatch;
	}
	// 8219F198: D37B00AC  stfs f27, 0xac(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8219F19C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F1A0: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F1A4: 409A0008  bne cr6, 0x8219f1ac
	if !ctx.cr[6].eq {
	pc = 0x8219F1AC; continue 'dispatch;
	}
	// 8219F1A8: D35B00B0  stfs f26, 0xb0(r27)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8219F1AC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F1B0: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F1B4: 409A0014  bne cr6, 0x8219f1c8
	if !ctx.cr[6].eq {
	pc = 0x8219F1C8; continue 'dispatch;
	}
	// 8219F1B8: 817B008C  lwz r11, 0x8c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219F1BC: D33B00A8  stfs f25, 0xa8(r27)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8219F1C0: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 8219F1C4: 917B008C  stw r11, 0x8c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 8219F1C8: 2F1E005A  cmpwi cr6, r30, 0x5a
	ctx.cr[6].compare_i32(ctx.r[30].s32, 90, &mut ctx.xer);
	// 8219F1CC: 409A00FC  bne cr6, 0x8219f2c8
	if !ctx.cr[6].eq {
	pc = 0x8219F2C8; continue 'dispatch;
	}
	// 8219F1D0: 817A0088  lwz r11, 0x88(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(136 as u32) ) } as u64;
	// 8219F1D4: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F1D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219F1DC: 419A000C  beq cr6, 0x8219f1e8
	if ctx.cr[6].eq {
	pc = 0x8219F1E8; continue 'dispatch;
	}
	// 8219F1E0: 389A0060  addi r4, r26, 0x60
	ctx.r[4].s64 = ctx.r[26].s64 + 96;
	// 8219F1E4: 480000E8  b 0x8219f2cc
	pc = 0x8219F2CC; continue 'dispatch;
	// 8219F1E8: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F1EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219F1F0: 419A0068  beq cr6, 0x8219f258
	if ctx.cr[6].eq {
	pc = 0x8219F258; continue 'dispatch;
	}
	// 8219F1F4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F1F8: 394BC448  addi r10, r11, -0x3bb8
	ctx.r[10].s64 = ctx.r[11].s64 + -15288;
	// 8219F1FC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F200: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F204: 419A0030  beq cr6, 0x8219f234
	if ctx.cr[6].eq {
	pc = 0x8219F234; continue 'dispatch;
	}
	// 8219F208: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F20C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F210: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219F214: 409A0020  bne cr6, 0x8219f234
	if !ctx.cr[6].eq {
	pc = 0x8219F234; continue 'dispatch;
	}
	// 8219F218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F21C: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 8219F220: 409A0008  bne cr6, 0x8219f228
	if !ctx.cr[6].eq {
	pc = 0x8219F228; continue 'dispatch;
	}
	// 8219F224: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8219F228: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219F22C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8219F230: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 8219F234: EBE10068  ld r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8219F238: 389A0060  addi r4, r26, 0x60
	ctx.r[4].s64 = ctx.r[26].s64 + 96;
	// 8219F23C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F240: 481ACBD9  bl 0x8234be18
	ctx.lr = 0x8219F244;
	sub_8234BE18(ctx, base);
	// 8219F244: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F248: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F24C: 409A008C  bne cr6, 0x8219f2d8
	if !ctx.cr[6].eq {
	pc = 0x8219F2D8; continue 'dispatch;
	}
	// 8219F250: FB3B0450  std r25, 0x450(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(1104 as u32), ctx.r[25].u64 ) };
	// 8219F254: 48000084  b 0x8219f2d8
	pc = 0x8219F2D8; continue 'dispatch;
	// 8219F258: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8219F25C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F260: 419AFF80  beq cr6, 0x8219f1e0
	if ctx.cr[6].eq {
	pc = 0x8219F1E0; continue 'dispatch;
	}
	// 8219F264: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F268: 394BC448  addi r10, r11, -0x3bb8
	ctx.r[10].s64 = ctx.r[11].s64 + -15288;
	// 8219F26C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F274: 419A0030  beq cr6, 0x8219f2a4
	if ctx.cr[6].eq {
	pc = 0x8219F2A4; continue 'dispatch;
	}
	// 8219F278: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F27C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F280: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219F284: 409A0020  bne cr6, 0x8219f2a4
	if !ctx.cr[6].eq {
	pc = 0x8219F2A4; continue 'dispatch;
	}
	// 8219F288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F28C: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 8219F290: 409A0008  bne cr6, 0x8219f298
	if !ctx.cr[6].eq {
	pc = 0x8219F298; continue 'dispatch;
	}
	// 8219F294: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8219F298: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219F29C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8219F2A0: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 8219F2A4: EBE10068  ld r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8219F2A8: 389A0060  addi r4, r26, 0x60
	ctx.r[4].s64 = ctx.r[26].s64 + 96;
	// 8219F2AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F2B0: 481ACB69  bl 0x8234be18
	ctx.lr = 0x8219F2B4;
	sub_8234BE18(ctx, base);
	// 8219F2B4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F2B8: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F2BC: 409A001C  bne cr6, 0x8219f2d8
	if !ctx.cr[6].eq {
	pc = 0x8219F2D8; continue 'dispatch;
	}
	// 8219F2C0: FB3B0450  std r25, 0x450(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(1104 as u32), ctx.r[25].u64 ) };
	// 8219F2C4: 48000014  b 0x8219f2d8
	pc = 0x8219F2D8; continue 'dispatch;
	// 8219F2C8: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8219F2CC: EBE10068  ld r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8219F2D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F2D4: 481ACDD5  bl 0x8234c0a8
	ctx.lr = 0x8219F2D8;
	sub_8234C0A8(ctx, base);
	// 8219F2D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219F2DC: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 8219F2E0: 4BFFFCF1  bl 0x8219efd0
	ctx.lr = 0x8219F2E4;
	sub_8219EFD0(ctx, base);
	// 8219F2E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219F2E8: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219F2EC: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 8219F2F0: 419A001C  beq cr6, 0x8219f30c
	if ctx.cr[6].eq {
	pc = 0x8219F30C; continue 'dispatch;
	}
	// 8219F2F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219F2F8: 80E101EC  lwz r7, 0x1ec(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(492 as u32) ) } as u64;
	// 8219F2FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F300: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8219F304: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8219F308: 481AC881  bl 0x8234bb88
	ctx.lr = 0x8219F30C;
	sub_8234BB88(ctx, base);
	// 8219F30C: 568B0528  rlwinm r11, r20, 0, 0x14, 0x14
	ctx.r[11].u64 = ctx.r[20].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F310: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F314: 419A0404  beq cr6, 0x8219f718
	if ctx.cr[6].eq {
	pc = 0x8219F718; continue 'dispatch;
	}
	// 8219F318: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F31C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F320: 409A03F8  bne cr6, 0x8219f718
	if !ctx.cr[6].eq {
	pc = 0x8219F718; continue 'dispatch;
	}
	// 8219F324: A17B0014  lhz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219F328: 716BFDFF  andi. r11, r11, 0xfdff
	ctx.r[11].u64 = ctx.r[11].u64 & 65023;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219F32C: B17B0014  sth r11, 0x14(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 8219F330: 480003E8  b 0x8219f718
	pc = 0x8219F718; continue 'dispatch;
	// 8219F334: 396FFFF9  addi r11, r15, -7
	ctx.r[11].s64 = ctx.r[15].s64 + -7;
	// 8219F338: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 8219F33C: 41990034  bgt cr6, 0x8219f370
	if ctx.cr[6].gt {
	pc = 0x8219F370; continue 'dispatch;
	}
	// 8219F340: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 8219F344: 419A0018  beq cr6, 0x8219f35c
	if ctx.cr[6].eq {
	pc = 0x8219F35C; continue 'dispatch;
	}
	// 8219F348: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F34C: 7D5388AE  lbzx r10, r19, r17
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[17].u32)) } as u64;
	// 8219F350: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219F354: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 8219F358: 48000038  b 0x8219f390
	pc = 0x8219F390; continue 'dispatch;
	// 8219F35C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F360: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8219F364: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219F368: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 8219F36C: 48000024  b 0x8219f390
	pc = 0x8219F390; continue 'dispatch;
	// 8219F370: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 8219F374: 419A000C  beq cr6, 0x8219f380
	if ctx.cr[6].eq {
	pc = 0x8219F380; continue 'dispatch;
	}
	// 8219F378: 7D5388AE  lbzx r10, r19, r17
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[17].u32)) } as u64;
	// 8219F37C: 48000008  b 0x8219f384
	pc = 0x8219F384; continue 'dispatch;
	// 8219F380: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8219F384: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F388: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219F38C: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 8219F390: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219F394: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 8219F398: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219F39C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8219F3A0: 7ECA582E  lwzx r22, r10, r11
	ctx.r[22].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219F3A4: 48004575  bl 0x821a3918
	ctx.lr = 0x8219F3A8;
	sub_821A3918(ctx, base);
	// 8219F3A8: 568B0462  rlwinm r11, r20, 0, 0x11, 0x11
	ctx.r[11].u64 = ctx.r[20].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F3AC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8219F3B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F3B4: 419A0134  beq cr6, 0x8219f4e8
	if ctx.cr[6].eq {
	pc = 0x8219F4E8; continue 'dispatch;
	}
	// 8219F3B8: 48004701  bl 0x821a3ab8
	ctx.lr = 0x8219F3BC;
	sub_821A3AB8(ctx, base);
	// 8219F3BC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8219F3C0: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8219F3C4: 419A0354  beq cr6, 0x8219f718
	if ctx.cr[6].eq {
	pc = 0x8219F718; continue 'dispatch;
	}
	// 8219F3C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219F3CC: 836101EC  lwz r27, 0x1ec(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(492 as u32) ) } as u64;
	// 8219F3D0: 3B930030  addi r28, r19, 0x30
	ctx.r[28].s64 = ctx.r[19].s64 + 48;
	// 8219F3D4: 569A0528  rlwinm r26, r20, 0, 0x14, 0x14
	ctx.r[26].u64 = ctx.r[20].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F3D8: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219F3DC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219F3E0: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 8219F3E4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219F3E8: 92410054  stw r18, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[18].u32 ) };
	// 8219F3EC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219F3F0: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 8219F3F4: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 8219F3F8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8219F3FC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219F400: 481AC561  bl 0x8234b960
	ctx.lr = 0x8219F404;
	sub_8234B960(ctx, base);
	// 8219F404: 83C1006C  lwz r30, 0x6c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8219F408: 83A10068  lwz r29, 0x68(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8219F40C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219F410: 419A0040  beq cr6, 0x8219f450
	if ctx.cr[6].eq {
	pc = 0x8219F450; continue 'dispatch;
	}
	// 8219F414: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F418: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8219F41C: 409A0008  bne cr6, 0x8219f424
	if !ctx.cr[6].eq {
	pc = 0x8219F424; continue 'dispatch;
	}
	// 8219F420: D37E00AC  stfs f27, 0xac(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8219F424: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F428: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8219F42C: 409A0008  bne cr6, 0x8219f434
	if !ctx.cr[6].eq {
	pc = 0x8219F434; continue 'dispatch;
	}
	// 8219F430: D35E00B0  stfs f26, 0xb0(r30)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8219F434: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F438: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8219F43C: 409A0014  bne cr6, 0x8219f450
	if !ctx.cr[6].eq {
	pc = 0x8219F450; continue 'dispatch;
	}
	// 8219F440: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219F444: D33E00A8  stfs f25, 0xa8(r30)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8219F448: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 8219F44C: 917E008C  stw r11, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 8219F450: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F454: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8219F458: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219F45C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219F460: 4E800421  bctrl
	ctx.lr = 0x8219F464;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219F464: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219F468: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8219F46C: 4800457D  bl 0x821a39e8
	ctx.lr = 0x8219F470;
	sub_821A39E8(ctx, base);
	// 8219F470: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219F474: EBE10068  ld r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8219F478: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8219F47C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F480: 481AC8E1  bl 0x8234bd60
	ctx.lr = 0x8219F484;
	sub_8234BD60(ctx, base);
	// 8219F484: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219F488: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 8219F48C: 4BFFFB45  bl 0x8219efd0
	ctx.lr = 0x8219F490;
	sub_8219EFD0(ctx, base);
	// 8219F490: FF1EF800  fcmpu cr6, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 8219F494: 419A001C  beq cr6, 0x8219f4b0
	if ctx.cr[6].eq {
	pc = 0x8219F4B0; continue 'dispatch;
	}
	// 8219F498: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8219F49C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8219F4A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219F4A4: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8219F4A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F4AC: 481AC6DD  bl 0x8234bb88
	ctx.lr = 0x8219F4B0;
	sub_8234BB88(ctx, base);
	// 8219F4B0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8219F4B4: 419A0024  beq cr6, 0x8219f4d8
	if ctx.cr[6].eq {
	pc = 0x8219F4D8; continue 'dispatch;
	}
	// 8219F4B8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219F4BC: 419A001C  beq cr6, 0x8219f4d8
	if ctx.cr[6].eq {
	pc = 0x8219F4D8; continue 'dispatch;
	}
	// 8219F4C0: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F4C4: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8219F4C8: 409A0010  bne cr6, 0x8219f4d8
	if !ctx.cr[6].eq {
	pc = 0x8219F4D8; continue 'dispatch;
	}
	// 8219F4CC: A17E0014  lhz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219F4D0: 716BFDFF  andi. r11, r11, 0xfdff
	ctx.r[11].u64 = ctx.r[11].u64 & 65023;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219F4D4: B17E0014  sth r11, 0x14(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 8219F4D8: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 8219F4DC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8219F4E0: 409AFEFC  bne cr6, 0x8219f3dc
	if !ctx.cr[6].eq {
	pc = 0x8219F3DC; continue 'dispatch;
	}
	// 8219F4E4: 48000234  b 0x8219f718
	pc = 0x8219F718; continue 'dispatch;
	// 8219F4E8: 480045D1  bl 0x821a3ab8
	ctx.lr = 0x8219F4EC;
	sub_821A3AB8(ctx, base);
	// 8219F4EC: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 8219F4F0: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 8219F4F4: 419A0224  beq cr6, 0x8219f718
	if ctx.cr[6].eq {
	pc = 0x8219F718; continue 'dispatch;
	}
	// 8219F4F8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219F4FC: 834101EC  lwz r26, 0x1ec(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(492 as u32) ) } as u64;
	// 8219F500: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F504: 569904A4  rlwinm r25, r20, 0, 0x12, 0x12
	ctx.r[25].u64 = ctx.r[20].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F508: 3BB30030  addi r29, r19, 0x30
	ctx.r[29].s64 = ctx.r[19].s64 + 48;
	// 8219F50C: 56980528  rlwinm r24, r20, 0, 0x14, 0x14
	ctx.r[24].u64 = ctx.r[20].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F510: C3EA1FF8  lfs f31, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219F514: 3B6BDBD0  addi r27, r11, -0x2430
	ctx.r[27].s64 = ctx.r[11].s64 + -9264;
	// 8219F518: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219F51C: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 8219F520: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219F524: 92410054  stw r18, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[18].u32 ) };
	// 8219F528: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219F52C: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 8219F530: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 8219F534: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8219F538: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219F53C: 481AC425  bl 0x8234b960
	ctx.lr = 0x8219F540;
	sub_8234B960(ctx, base);
	// 8219F540: 83C1006C  lwz r30, 0x6c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8219F544: 83810068  lwz r28, 0x68(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8219F548: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219F54C: 419A0040  beq cr6, 0x8219f58c
	if ctx.cr[6].eq {
	pc = 0x8219F58C; continue 'dispatch;
	}
	// 8219F550: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F554: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F558: 409A0008  bne cr6, 0x8219f560
	if !ctx.cr[6].eq {
	pc = 0x8219F560; continue 'dispatch;
	}
	// 8219F55C: D37E00AC  stfs f27, 0xac(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8219F560: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F564: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F568: 409A0008  bne cr6, 0x8219f570
	if !ctx.cr[6].eq {
	pc = 0x8219F570; continue 'dispatch;
	}
	// 8219F56C: D35E00B0  stfs f26, 0xb0(r30)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8219F570: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F574: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F578: 409A0014  bne cr6, 0x8219f58c
	if !ctx.cr[6].eq {
	pc = 0x8219F58C; continue 'dispatch;
	}
	// 8219F57C: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219F580: D33E00A8  stfs f25, 0xa8(r30)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8219F584: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 8219F588: 917E008C  stw r11, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 8219F58C: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8219F590: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8219F594: 419A0050  beq cr6, 0x8219f5e4
	if ctx.cr[6].eq {
	pc = 0x8219F5E4; continue 'dispatch;
	}
	// 8219F598: 48004451  bl 0x821a39e8
	ctx.lr = 0x8219F59C;
	sub_821A39E8(ctx, base);
	// 8219F59C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F5A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8219F5A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219F5A8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F5AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219F5B0: 4E800421  bctrl
	ctx.lr = 0x8219F5B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219F5B4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219F5B8: EBE10068  ld r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8219F5BC: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 8219F5C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F5C4: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219F5C8: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8219F5CC: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219F5D0: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8219F5D4: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219F5D8: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 8219F5DC: 481ACACD  bl 0x8234c0a8
	ctx.lr = 0x8219F5E0;
	sub_8234C0A8(ctx, base);
	// 8219F5E0: 480000D0  b 0x8219f6b0
	pc = 0x8219F6B0; continue 'dispatch;
	// 8219F5E4: 568B04E6  rlwinm r11, r20, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[20].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F5E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F5EC: 419A0098  beq cr6, 0x8219f684
	if ctx.cr[6].eq {
	pc = 0x8219F684; continue 'dispatch;
	}
	// 8219F5F0: 480043F9  bl 0x821a39e8
	ctx.lr = 0x8219F5F4;
	sub_821A39E8(ctx, base);
	// 8219F5F4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F5F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8219F5FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219F600: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F604: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219F608: 4E800421  bctrl
	ctx.lr = 0x8219F60C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219F60C: 897B0001  lbz r11, 1(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(1 as u32) ) } as u64;
	// 8219F610: C0230030  lfs f1, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219F614: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 8219F618: C0430038  lfs f2, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219F61C: D02100A0  stfs f1, 0xa0(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8219F620: D04100A8  stfs f2, 0xa8(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8219F624: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219F628: 40990018  ble cr6, 0x8219f640
	if !ctx.cr[6].gt {
	pc = 0x8219F640; continue 'dispatch;
	}
	// 8219F62C: 897B0002  lbz r11, 2(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(2 as u32) ) } as u64;
	// 8219F630: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 8219F634: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219F638: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219F63C: 41990008  bgt cr6, 0x8219f644
	if ctx.cr[6].gt {
	pc = 0x8219F644; continue 'dispatch;
	}
	// 8219F640: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8219F644: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219F648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F64C: 409A0010  bne cr6, 0x8219f65c
	if !ctx.cr[6].eq {
	pc = 0x8219F65C; continue 'dispatch;
	}
	// 8219F650: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219F654: 48017E75  bl 0x821b74c8
	ctx.lr = 0x8219F658;
	sub_821B74C8(ctx, base);
	// 8219F658: 48000014  b 0x8219f66c
	pc = 0x8219F66C; continue 'dispatch;
	// 8219F65C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219F660: 92410060  stw r18, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[18].u32 ) };
	// 8219F664: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8219F668: 48017EC9  bl 0x821b7530
	ctx.lr = 0x8219F66C;
	sub_821B7530(ctx, base);
	// 8219F66C: EBE10068  ld r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8219F670: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8219F674: D02100A4  stfs f1, 0xa4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8219F678: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F67C: 481ACA2D  bl 0x8234c0a8
	ctx.lr = 0x8219F680;
	sub_8234C0A8(ctx, base);
	// 8219F680: 48000030  b 0x8219f6b0
	pc = 0x8219F6B0; continue 'dispatch;
	// 8219F684: 48004365  bl 0x821a39e8
	ctx.lr = 0x8219F688;
	sub_821A39E8(ctx, base);
	// 8219F688: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F68C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8219F690: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219F694: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F698: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219F69C: 4E800421  bctrl
	ctx.lr = 0x8219F6A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219F6A0: EBE10068  ld r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8219F6A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8219F6A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F6AC: 481AC8A5  bl 0x8234bf50
	ctx.lr = 0x8219F6B0;
	sub_8234BF50(ctx, base);
	// 8219F6B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219F6B4: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 8219F6B8: 4BFFF919  bl 0x8219efd0
	ctx.lr = 0x8219F6BC;
	sub_8219EFD0(ctx, base);
	// 8219F6BC: FF1EF800  fcmpu cr6, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 8219F6C0: 419A001C  beq cr6, 0x8219f6dc
	if ctx.cr[6].eq {
	pc = 0x8219F6DC; continue 'dispatch;
	}
	// 8219F6C4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 8219F6C8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8219F6CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219F6D0: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8219F6D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F6D8: 481AC4B1  bl 0x8234bb88
	ctx.lr = 0x8219F6DC;
	sub_8234BB88(ctx, base);
	// 8219F6DC: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 8219F6E0: 419A0024  beq cr6, 0x8219f704
	if ctx.cr[6].eq {
	pc = 0x8219F704; continue 'dispatch;
	}
	// 8219F6E4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219F6E8: 419A001C  beq cr6, 0x8219f704
	if ctx.cr[6].eq {
	pc = 0x8219F704; continue 'dispatch;
	}
	// 8219F6EC: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F6F0: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F6F4: 409A0010  bne cr6, 0x8219f704
	if !ctx.cr[6].eq {
	pc = 0x8219F704; continue 'dispatch;
	}
	// 8219F6F8: A17E0014  lhz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219F6FC: 716BFDFF  andi. r11, r11, 0xfdff
	ctx.r[11].u64 = ctx.r[11].u64 & 65023;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219F700: B17E0014  sth r11, 0x14(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 8219F704: 3AF7FFFF  addi r23, r23, -1
	ctx.r[23].s64 = ctx.r[23].s64 + -1;
	// 8219F708: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 8219F70C: 409AFE0C  bne cr6, 0x8219f518
	if !ctx.cr[6].eq {
	pc = 0x8219F518; continue 'dispatch;
	}
	// 8219F710: 48000008  b 0x8219f718
	pc = 0x8219F718; continue 'dispatch;
	// 8219F714: EBE10068  ld r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8219F718: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8219F71C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8219F720: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 8219F724: B1700000  sth r11, 0(r16)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 8219F728: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F72C: 7D5388AE  lbzx r10, r19, r17
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[17].u32)) } as u64;
	// 8219F730: 396BC7D0  addi r11, r11, -0x3830
	ctx.r[11].s64 = ctx.r[11].s64 + -14384;
	// 8219F734: 1D4A0108  mulli r10, r10, 0x108
	ctx.r[10].s64 = ctx.r[10].s64 * 264;
	// 8219F738: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219F73C: 4BFC7F7D  bl 0x821676b8
	ctx.lr = 0x8219F740;
	sub_821676B8(ctx, base);
	// 8219F740: 5463043E  clrlwi r3, r3, 0x10
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 8219F744: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 8219F748: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 8219F74C: 483968DD  bl 0x82536028
	ctx.lr = 0x8219F750;
	sub_82535FFC(ctx, base);
	// 8219F750: 48395984  b 0x825350d4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219F758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219F758 size=152
    let mut pc: u32 = 0x8219F758;
    'dispatch: loop {
        match pc {
            0x8219F758 => {
    //   block [0x8219F758..0x8219F7F0)
	// 8219F758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219F75C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219F760: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219F764: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219F768: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 8219F76C: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 8219F770: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 8219F774: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 8219F778: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F77C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 8219F780: 396BC7D0  addi r11, r11, -0x3830
	ctx.r[11].s64 = ctx.r[11].s64 + -14384;
	// 8219F784: 7D4350AE  lbzx r10, r3, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219F788: 1D4A0108  mulli r10, r10, 0x108
	ctx.r[10].s64 = ctx.r[10].s64 * 264;
	// 8219F78C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219F790: 40980014  bge cr6, 0x8219f7a4
	if !ctx.cr[6].lt {
	pc = 0x8219F7A4; continue 'dispatch;
	}
	// 8219F794: 2F040010  cmpwi cr6, r4, 0x10
	ctx.cr[6].compare_i32(ctx.r[4].s32, 16, &mut ctx.xer);
	// 8219F798: 4198000C  blt cr6, 0x8219f7a4
	if ctx.cr[6].lt {
	pc = 0x8219F7A4; continue 'dispatch;
	}
	// 8219F79C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219F7A0: 48000010  b 0x8219f7b0
	pc = 0x8219F7B0; continue 'dispatch;
	// 8219F7A4: 39440001  addi r10, r4, 1
	ctx.r[10].s64 = ctx.r[4].s64 + 1;
	// 8219F7A8: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219F7AC: 7D6A582A  ldx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	// 8219F7B0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219F7B4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219F7B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219F7BC: 419A0024  beq cr6, 0x8219f7e0
	if ctx.cr[6].eq {
	pc = 0x8219F7E0; continue 'dispatch;
	}
	// 8219F7C0: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F7C4: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8219F7C8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219F7CC: 409A0014  bne cr6, 0x8219f7e0
	if !ctx.cr[6].eq {
	pc = 0x8219F7E0; continue 'dispatch;
	}
	// 8219F7D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219F7D4: FC400090  fmr f2, f0
	ctx.f[2].f64 = ctx.f[0].f64;
	// 8219F7D8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8219F7DC: 481AC3AD  bl 0x8234bb88
	ctx.lr = 0x8219F7E0;
	sub_8234BB88(ctx, base);
	// 8219F7E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219F7E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219F7E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219F7EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219F7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219F7F0 size=928
    let mut pc: u32 = 0x8219F7F0;
    'dispatch: loop {
        match pc {
            0x8219F7F0 => {
    //   block [0x8219F7F0..0x8219FB90)
	// 8219F7F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219F7F4: 483958BD  bl 0x825350b0
	ctx.lr = 0x8219F7F8;
	sub_82535080(ctx, base);
	// 8219F7F8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 8219F7FC: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219F800: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219F804: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8219F808: 616BEB0E  ori r11, r11, 0xeb0e
	ctx.r[11].u64 = ctx.r[11].u64 | 60174;
	// 8219F80C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8219F810: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 8219F814: 7D7D58AE  lbzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219F818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F81C: 419A0020  beq cr6, 0x8219f83c
	if ctx.cr[6].eq {
	pc = 0x8219F83C; continue 'dispatch;
	}
	// 8219F820: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219F824: 616BA960  ori r11, r11, 0xa960
	ctx.r[11].u64 = ctx.r[11].u64 | 43360;
	// 8219F828: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219F82C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8219F830: 4198000C  blt cr6, 0x8219f83c
	if ctx.cr[6].lt {
	pc = 0x8219F83C; continue 'dispatch;
	}
	// 8219F834: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 8219F838: 4199034C  bgt cr6, 0x8219fb84
	if ctx.cr[6].gt {
	pc = 0x8219FB84; continue 'dispatch;
	}
	// 8219F83C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219F840: 4BF90311  bl 0x8212fb50
	ctx.lr = 0x8219F844;
	sub_8212FB50(ctx, base);
	// 8219F844: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219F848: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8219F84C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219F850: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 8219F854: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 8219F858: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8219F85C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219F860: 7D7C0734  extsh r28, r11
	ctx.r[28].s64 = ctx.r[11].s16 as i64;
	// 8219F864: 4BFFF1ED  bl 0x8219ea50
	ctx.lr = 0x8219F868;
	sub_8219EA50(ctx, base);
	// 8219F868: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219F86C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219F870: 616BA9C0  ori r11, r11, 0xa9c0
	ctx.r[11].u64 = ctx.r[11].u64 | 43456;
	// 8219F874: 614AE2D4  ori r10, r10, 0xe2d4
	ctx.r[10].u64 = ctx.r[10].u64 | 58068;
	// 8219F878: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8219F87C: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219F880: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219F884: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F888: 419A000C  beq cr6, 0x8219f894
	if ctx.cr[6].eq {
	pc = 0x8219F894; continue 'dispatch;
	}
	// 8219F88C: A16B0032  lhz r11, 0x32(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(50 as u32) ) } as u64;
	// 8219F890: 48000008  b 0x8219f898
	pc = 0x8219F898; continue 'dispatch;
	// 8219F894: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 8219F898: 556B0630  rlwinm r11, r11, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F89C: 2B0B0080  cmplwi cr6, r11, 0x80
	ctx.cr[6].compare_u32(ctx.r[11].u32, 128 as u32, &mut ctx.xer);
	// 8219F8A0: 409A0040  bne cr6, 0x8219f8e0
	if !ctx.cr[6].eq {
	pc = 0x8219F8E0; continue 'dispatch;
	}
	// 8219F8A4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219F8A8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219F8AC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219F8B0: FBE10068  std r31, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u64 ) };
	// 8219F8B4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219F8B8: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 8219F8BC: 38C00093  li r6, 0x93
	ctx.r[6].s64 = 147;
	// 8219F8C0: C02BBA38  lfs f1, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219F8C4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F8C8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8219F8CC: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219F8D0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219F8D4: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219F8D8: 481AC089  bl 0x8234b960
	ctx.lr = 0x8219F8DC;
	sub_8234B960(ctx, base);
	// 8219F8DC: 48000278  b 0x8219fb54
	pc = 0x8219FB54; continue 'dispatch;
	// 8219F8E0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219F8E4: 616BE2E0  ori r11, r11, 0xe2e0
	ctx.r[11].u64 = ctx.r[11].u64 | 58080;
	// 8219F8E8: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219F8EC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8219F8F0: 409800C8  bge cr6, 0x8219f9b8
	if !ctx.cr[6].lt {
	pc = 0x8219F9B8; continue 'dispatch;
	}
	// 8219F8F4: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219F8F8: 616BA968  ori r11, r11, 0xa968
	ctx.r[11].u64 = ctx.r[11].u64 | 43368;
	// 8219F8FC: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219F900: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219F904: 409A00B4  bne cr6, 0x8219f9b8
	if !ctx.cr[6].eq {
	pc = 0x8219F9B8; continue 'dispatch;
	}
	// 8219F908: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219F90C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 8219F910: C3EBBA38  lfs f31, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219F914: 409A0074  bne cr6, 0x8219f988
	if !ctx.cr[6].eq {
	pc = 0x8219F988; continue 'dispatch;
	}
	// 8219F918: FBE10068  std r31, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u64 ) };
	// 8219F91C: 2F1C0009  cmpwi cr6, r28, 9
	ctx.cr[6].compare_i32(ctx.r[28].s32, 9, &mut ctx.xer);
	// 8219F920: 38C00015  li r6, 0x15
	ctx.r[6].s64 = 21;
	// 8219F924: 40980008  bge cr6, 0x8219f92c
	if !ctx.cr[6].lt {
	pc = 0x8219F92C; continue 'dispatch;
	}
	// 8219F928: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 8219F92C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F930: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219F934: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219F938: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219F93C: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219F940: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219F944: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 8219F948: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8219F94C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219F950: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219F954: 481AC00D  bl 0x8234b960
	ctx.lr = 0x8219F958;
	sub_8234B960(ctx, base);
	// 8219F958: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219F95C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219F960: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219F964: 388BB8A0  addi r4, r11, -0x4760
	ctx.r[4].s64 = ctx.r[11].s64 + -18272;
	// 8219F968: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8219F96C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219F970: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219F974: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219F978: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219F97C: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 8219F980: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8219F984: 4800192D  bl 0x821a12b0
	ctx.lr = 0x8219F988;
	sub_821A12B0(ctx, base);
	// 8219F988: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219F98C: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8219F990: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 8219F994: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219F998: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 8219F99C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219F9A0: 38E0000D  li r7, 0xd
	ctx.r[7].s64 = 13;
	// 8219F9A4: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8219F9A8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8219F9AC: 3860000D  li r3, 0xd
	ctx.r[3].s64 = 13;
	// 8219F9B0: 4800B049  bl 0x821aa9f8
	ctx.lr = 0x8219F9B4;
	sub_821AA9F8(ctx, base);
	// 8219F9B4: 480001A0  b 0x8219fb54
	pc = 0x8219FB54; continue 'dispatch;
	// 8219F9B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219F9BC: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 8219F9C0: C3EBBA38  lfs f31, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219F9C4: 409A0164  bne cr6, 0x8219fb28
	if !ctx.cr[6].eq {
	pc = 0x8219FB28; continue 'dispatch;
	}
	// 8219F9C8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F9CC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219F9D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219F9D4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219F9D8: 3BCBC470  addi r30, r11, -0x3b90
	ctx.r[30].s64 = ctx.r[11].s64 + -15248;
	// 8219F9DC: FBE10068  std r31, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u64 ) };
	// 8219F9E0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219F9E4: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 8219F9E8: 38C0000B  li r6, 0xb
	ctx.r[6].s64 = 11;
	// 8219F9EC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8219F9F0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219F9F4: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219F9F8: 481ABF69  bl 0x8234b960
	ctx.lr = 0x8219F9FC;
	sub_8234B960(ctx, base);
	// 8219F9FC: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219FA00: 387D0030  addi r3, r29, 0x30
	ctx.r[3].s64 = ctx.r[29].s64 + 48;
	// 8219FA04: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219FA08: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219FA0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219FA10: 4E800421  bctrl
	ctx.lr = 0x8219FA14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219FA14: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 8219FA18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219FA1C: C12100A0  lfs f9, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8219FA20: C10100A4  lfs f8, 0xa4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8219FA24: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219FA28: C0E100A8  lfs f7, 0xa8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 8219FA2C: C00AD218  lfs f0, -0x2de8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219FA30: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219FA34: C18B0020  lfs f12, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219FA38: C16B0024  lfs f11, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219FA3C: C14B0028  lfs f10, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219FA40: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8219FA44: C1AA2074  lfs f13, 0x2074(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219FA48: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219FA4C: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219FA50: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219FA54: C1ABD468  lfs f13, -0x2b98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219FA58: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219FA5C: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219FA60: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219FA64: EC29603A  fmadds f1, f9, f0, f12
	ctx.f[1].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8219FA68: EC48583A  fmadds f2, f8, f0, f11
	ctx.f[2].f64 = (((ctx.f[8].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 8219FA6C: EC67683A  fmadds f3, f7, f0, f13
	ctx.f[3].f64 = (((ctx.f[7].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8219FA70: 48010919  bl 0x821b0388
	ctx.lr = 0x8219FA74;
	sub_821B0388(ctx, base);
	// 8219FA74: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219FA78: C1A10080  lfs f13, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219FA7C: C1810084  lfs f12, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219FA80: 2F1C0009  cmpwi cr6, r28, 9
	ctx.cr[6].compare_i32(ctx.r[28].s32, 9, &mut ctx.xer);
	// 8219FA84: C1610088  lfs f11, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219FA88: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8219FA8C: C00B2034  lfs f0, 0x2034(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8244 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219FA90: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219FA94: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219FA98: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219FA9C: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 8219FAA0: D9A10070  stfd f13, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[13].u64 ) };
	// 8219FAA4: FDA0601E  fctiwz f13, f12
	ctx.f[13].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 8219FAA8: D9A10078  stfd f13, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.f[13].u64 ) };
	// 8219FAAC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 8219FAB0: D8010080  stfd f0, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.f[0].u64 ) };
	// 8219FAB4: A1610076  lhz r11, 0x76(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(118 as u32) ) } as u64;
	// 8219FAB8: B1610060  sth r11, 0x60(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u16 ) };
	// 8219FABC: A161007E  lhz r11, 0x7e(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(126 as u32) ) } as u64;
	// 8219FAC0: B1610062  sth r11, 0x62(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[11].u16 ) };
	// 8219FAC4: A1610086  lhz r11, 0x86(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(134 as u32) ) } as u64;
	// 8219FAC8: B1610064  sth r11, 0x64(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u16 ) };
	// 8219FACC: 40980008  bge cr6, 0x8219fad4
	if !ctx.cr[6].lt {
	pc = 0x8219FAD4; continue 'dispatch;
	}
	// 8219FAD0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 8219FAD4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219FAD8: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219FADC: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 8219FAE0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219FAE4: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 8219FAE8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219FAEC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8219FAF0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219FAF4: 481ABE6D  bl 0x8234b960
	ctx.lr = 0x8219FAF8;
	sub_8234B960(ctx, base);
	// 8219FAF8: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219FAFC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219FB00: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219FB04: 388BB8B0  addi r4, r11, -0x4750
	ctx.r[4].s64 = ctx.r[11].s64 + -18256;
	// 8219FB08: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8219FB0C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219FB10: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219FB14: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219FB18: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219FB1C: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 8219FB20: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8219FB24: 4800178D  bl 0x821a12b0
	ctx.lr = 0x8219FB28;
	sub_821A12B0(ctx, base);
	// 8219FB28: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219FB2C: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8219FB30: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 8219FB34: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219FB38: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 8219FB3C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219FB40: 38E0000C  li r7, 0xc
	ctx.r[7].s64 = 12;
	// 8219FB44: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8219FB48: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 8219FB4C: 3860000D  li r3, 0xd
	ctx.r[3].s64 = 13;
	// 8219FB50: 4800AEA9  bl 0x821aa9f8
	ctx.lr = 0x8219FB54;
	sub_821AA9F8(ctx, base);
	// 8219FB54: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219FB58: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219FB5C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219FB60: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 8219FB64: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219FB68: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8219FB6C: 409A0018  bne cr6, 0x8219fb84
	if !ctx.cr[6].eq {
	pc = 0x8219FB84; continue 'dispatch;
	}
	// 8219FB70: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 8219FB74: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 8219FB78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8219FB7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8219FB80: 4BFDD281  bl 0x8217ce00
	ctx.lr = 0x8219FB84;
	sub_8217CE00(ctx, base);
	// 8219FB84: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 8219FB88: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8219FB8C: 48395574  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219FB90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219FB90 size=1064
    let mut pc: u32 = 0x8219FB90;
    'dispatch: loop {
        match pc {
            0x8219FB90 => {
    //   block [0x8219FB90..0x8219FD2C)
	// 8219FB90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219FB94: 48395515  bl 0x825350a8
	ctx.lr = 0x8219FB98;
	sub_82535080(ctx, base);
	// 8219FB98: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 8219FB9C: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 8219FBA0: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219FBA4: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 8219FBA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219FBAC: 3978FFCF  addi r11, r24, -0x31
	ctx.r[11].s64 = ctx.r[24].s64 + -49;
	// 8219FBB0: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 8219FBB4: 2B0B0025  cmplwi cr6, r11, 0x25
	ctx.cr[6].compare_u32(ctx.r[11].u32, 37 as u32, &mut ctx.xer);
	// 8219FBB8: 4199001C  bgt cr6, 0x8219fbd4
	if ctx.cr[6].gt {
	pc = 0x8219FBD4; continue 'dispatch;
	}
	// 8219FBBC: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219FBC0: 3BA0000A  li r29, 0xa
	ctx.r[29].s64 = 10;
	// 8219FBC4: 3B8BB8E0  addi r28, r11, -0x4720
	ctx.r[28].s64 = ctx.r[11].s64 + -18208;
	// 8219FBC8: 3B400025  li r26, 0x25
	ctx.r[26].s64 = 37;
	// 8219FBCC: 3B60006D  li r27, 0x6d
	ctx.r[27].s64 = 109;
	// 8219FBD0: 48000018  b 0x8219fbe8
	pc = 0x8219FBE8; continue 'dispatch;
	// 8219FBD4: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219FBD8: 3BA00009  li r29, 9
	ctx.r[29].s64 = 9;
	// 8219FBDC: 3B8BB8D0  addi r28, r11, -0x4730
	ctx.r[28].s64 = ctx.r[11].s64 + -18224;
	// 8219FBE0: 3B40000D  li r26, 0xd
	ctx.r[26].s64 = 13;
	// 8219FBE4: 3B60007B  li r27, 0x7b
	ctx.r[27].s64 = 123;
	// 8219FBE8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219FBEC: 2B180046  cmplwi cr6, r24, 0x46
	ctx.cr[6].compare_u32(ctx.r[24].u32, 70 as u32, &mut ctx.xer);
	// 8219FBF0: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219FBF4: 4199019C  bgt cr6, 0x8219fd90
	if ctx.cr[6].gt {
	pc = 0x8219FD90; continue 'dispatch;
	}
	// 8219FBF8: 3D80821A  lis r12, -0x7de6
	ctx.r[12].s64 = -2112225280;
	// 8219FBFC: 398CFC10  addi r12, r12, -0x3f0
	ctx.r[12].s64 = ctx.r[12].s64 + -1008;
	// 8219FC00: 5700103A  slwi r0, r24, 2
	ctx.r[0].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8219FC04: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8219FC08: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8219FC0C: 4E800420  bctr
	match ctx.r[24].u64 {
		0 => {
	pc = 0x8219FFA8; continue 'dispatch;
		},
		1 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		2 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		3 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		4 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		5 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		6 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		7 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		8 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		9 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		10 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		11 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		12 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		13 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		14 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		15 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		16 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		17 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		18 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		19 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		20 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		21 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		22 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		23 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		24 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		25 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		26 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		27 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		28 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		29 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		30 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		31 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		32 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		33 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		34 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		35 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		36 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		37 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		38 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		39 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		40 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		41 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		42 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		43 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		44 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		45 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		46 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		47 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		48 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		49 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		50 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		51 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		52 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		53 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		54 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		55 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		56 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		57 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		58 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		59 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		60 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		61 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		62 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		63 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		64 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		65 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		66 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		67 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		68 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		69 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		70 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8219FC10: 8219FFA8  lwz r16, -0x58(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-88 as u32) ) } as u64;
	// 8219FC14: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC18: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC1C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC20: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC24: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC28: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC2C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC30: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC34: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC38: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC3C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC40: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC44: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC48: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC4C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC50: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC54: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC58: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC5C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC60: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC64: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC68: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC6C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC70: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC74: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC78: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC7C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC80: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC84: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FC88: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC8C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC90: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC94: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC98: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FC9C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCA0: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCA4: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCA8: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCAC: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCB0: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCB4: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCB8: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCBC: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCC0: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCC4: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCC8: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCCC: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCD0: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCD4: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCD8: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCDC: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCE0: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCE4: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCE8: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCEC: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCF0: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCF4: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCF8: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCFC: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD00: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD04: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD08: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD0C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD10: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD14: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FD18: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD1C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD20: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD24: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD28: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
            }
            0x8219FD2C => {
    //   block [0x8219FD2C..0x8219FD90)
	// 8219FD2C: 3D408287  lis r10, -0x7d79
	ctx.r[10].s64 = -2105081856;
	// 8219FD30: FCA0F890  fmr f5, f31
	ctx.f[5].f64 = ctx.f[31].f64;
	// 8219FD34: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219FD38: 3B8AB8F0  addi r28, r10, -0x4710
	ctx.r[28].s64 = ctx.r[10].s64 + -18192;
	// 8219FD3C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219FD40: 6169BE64  ori r9, r11, 0xbe64
	ctx.r[9].u64 = ctx.r[11].u64 | 48740;
	// 8219FD44: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219FD48: 3BA0000B  li r29, 0xb
	ctx.r[29].s64 = 11;
	// 8219FD4C: 3B60006E  li r27, 0x6e
	ctx.r[27].s64 = 110;
	// 8219FD50: C08A20C8  lfs f4, 0x20c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8392 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219FD54: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219FD58: 7D3E48AE  lbzx r9, r30, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8219FD5C: 3B40000E  li r26, 0xe
	ctx.r[26].s64 = 14;
	// 8219FD60: C3CBD28C  lfs f30, -0x2d74(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11636 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8219FD64: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219FD68: 396B1290  addi r11, r11, 0x1290
	ctx.r[11].s64 = ctx.r[11].s64 + 4752;
	// 8219FD6C: C06A2094  lfs f3, 0x2094(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8340 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8219FD70: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8219FD74: C04A2938  lfs f2, 0x2938(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10552 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219FD78: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 8219FD7C: C02AD4CC  lfs f1, -0x2b34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219FD80: 1D49002C  mulli r10, r9, 0x2c
	ctx.r[10].s64 = ctx.r[9].s64 * 44;
	// 8219FD84: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219FD88: 4BFFC8E1  bl 0x8219c668
	ctx.lr = 0x8219FD8C;
	sub_8219C668(ctx, base);
	// 8219FD8C: 4800000C  b 0x8219fd98
	pc = 0x8219FD98; continue 'dispatch;
            }
            0x8219FD90 => {
    //   block [0x8219FD90..0x8219FFA8)
	// 8219FD90: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219FD94: C3CB3138  lfs f30, 0x3138(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12600 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8219FD98: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219FD9C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219FDA0: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 8219FDA4: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 8219FDA8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8219FDAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219FDB0: 4BFFECA1  bl 0x8219ea50
	ctx.lr = 0x8219FDB4;
	sub_8219EA50(ctx, base);
	// 8219FDB4: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219FDB8: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 8219FDBC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219FDC0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219FDC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219FDC8: 4E800421  bctrl
	ctx.lr = 0x8219FDCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219FDCC: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 8219FDD0: C1810090  lfs f12, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219FDD4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219FDD8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8219FDDC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219FDE0: C00AD468  lfs f0, -0x2b98(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219FDE4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219FDE8: C16B0028  lfs f11, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219FDEC: FBE10068  std r31, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u64 ) };
	// 8219FDF0: C1AA2B88  lfs f13, 0x2b88(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219FDF4: ED4C0372  fmuls f10, f12, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219FDF8: C1810094  lfs f12, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219FDFC: ED2C0372  fmuls f9, f12, f13
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219FE00: C1810098  lfs f12, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219FE04: ED0C0372  fmuls f8, f12, f13
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219FE08: C1AB0020  lfs f13, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219FE0C: C18B0024  lfs f12, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219FE10: EC2D503A  fmadds f1, f13, f0, f10
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 8219FE14: D0210090  stfs f1, 0x90(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8219FE18: EC4C483A  fmadds f2, f12, f0, f9
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64);
	// 8219FE1C: D0410094  stfs f2, 0x94(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8219FE20: EC6B403A  fmadds f3, f11, f0, f8
	ctx.f[3].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 8219FE24: D0610098  stfs f3, 0x98(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 8219FE28: 48010561  bl 0x821b0388
	ctx.lr = 0x8219FE2C;
	sub_821B0388(ctx, base);
	// 8219FE2C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219FE30: C1A10080  lfs f13, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219FE34: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219FE38: C1810084  lfs f12, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219FE3C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 8219FE40: C1610088  lfs f11, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219FE44: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 8219FE48: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 8219FE4C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219FE50: C00B2034  lfs f0, 0x2034(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8244 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219FE54: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219FE58: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219FE5C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8219FE60: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219FE64: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219FE68: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219FE6C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219FE70: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219FE74: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219FE78: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 8219FE7C: D9A10070  stfd f13, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[13].u64 ) };
	// 8219FE80: FDA0601E  fctiwz f13, f12
	ctx.f[13].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 8219FE84: D9A10078  stfd f13, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.f[13].u64 ) };
	// 8219FE88: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 8219FE8C: D8010080  stfd f0, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.f[0].u64 ) };
	// 8219FE90: A1610076  lhz r11, 0x76(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(118 as u32) ) } as u64;
	// 8219FE94: B1610060  sth r11, 0x60(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u16 ) };
	// 8219FE98: A161007E  lhz r11, 0x7e(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(126 as u32) ) } as u64;
	// 8219FE9C: B1610062  sth r11, 0x62(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[11].u16 ) };
	// 8219FEA0: A1610086  lhz r11, 0x86(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(134 as u32) ) } as u64;
	// 8219FEA4: B1610064  sth r11, 0x64(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u16 ) };
	// 8219FEA8: 481ABAB9  bl 0x8234b960
	ctx.lr = 0x8219FEAC;
	sub_8234B960(ctx, base);
	// 8219FEAC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219FEB0: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8219FEB4: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 8219FEB8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219FEBC: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 8219FEC0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219FEC4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 8219FEC8: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8219FECC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8219FED0: 38600027  li r3, 0x27
	ctx.r[3].s64 = 39;
	// 8219FED4: 4800AB25  bl 0x821aa9f8
	ctx.lr = 0x8219FED8;
	sub_821AA9F8(ctx, base);
	// 8219FED8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219FEDC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219FEE0: C02B2068  lfs f1, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219FEE4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219FEE8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8219FEEC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219FEF0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219FEF4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8219FEF8: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 8219FEFC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8219FF00: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8219FF04: 480013AD  bl 0x821a12b0
	ctx.lr = 0x8219FF08;
	sub_821A12B0(ctx, base);
	// 8219FF08: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219FF0C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219FF10: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219FF14: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8219FF18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219FF1C: 481C11ED  bl 0x82361108
	ctx.lr = 0x8219FF20;
	sub_82361108(ctx, base);
	// 8219FF20: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219FF24: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 8219FF28: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8219FF2C: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 8219FF30: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219FF34: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 8219FF38: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219FF3C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8219FF40: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 8219FF44: 3860000B  li r3, 0xb
	ctx.r[3].s64 = 11;
	// 8219FF48: 4800AAB1  bl 0x821aa9f8
	ctx.lr = 0x8219FF4C;
	sub_821AA9F8(ctx, base);
	// 8219FF4C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219FF50: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 8219FF54: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8219FF58: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 8219FF5C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219FF60: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 8219FF64: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219FF68: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8219FF6C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8219FF70: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 8219FF74: 4800AA85  bl 0x821aa9f8
	ctx.lr = 0x8219FF78;
	sub_821AA9F8(ctx, base);
	// 8219FF78: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219FF7C: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219FF80: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219FF84: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 8219FF88: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219FF8C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8219FF90: 409A0018  bne cr6, 0x8219ffa8
	if !ctx.cr[6].eq {
	pc = 0x8219FFA8; continue 'dispatch;
	}
	// 8219FF94: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 8219FF98: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 8219FF9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219FFA0: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 8219FFA4: 4BFDCE5D  bl 0x8217ce00
	ctx.lr = 0x8219FFA8;
	sub_8217CE00(ctx, base);
            }
            0x8219FFA8 => {
    //   block [0x8219FFA8..0x8219FFB8)
	// 8219FFA8: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 8219FFAC: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 8219FFB0: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 8219FFB4: 48395144  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219FFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219FFB8 size=344
    let mut pc: u32 = 0x8219FFB8;
    'dispatch: loop {
        match pc {
            0x8219FFB8 => {
    //   block [0x8219FFB8..0x821A0110)
	// 8219FFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219FFBC: 483950FD  bl 0x825350b8
	ctx.lr = 0x8219FFC0;
	sub_82535080(ctx, base);
	// 8219FFC0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8219FFC4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219FFC8: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 8219FFCC: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 8219FFD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8219FFD4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8219FFD8: 816A42EC  lwz r11, 0x42ec(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17132 as u32) ) } as u64;
	// 8219FFDC: C3E8BA38  lfs f31, -0x45c8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219FFE0: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8219FFE4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219FFE8: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 8219FFEC: 3BC942DC  addi r30, r9, 0x42dc
	ctx.r[30].s64 = ctx.r[9].s64 + 17116;
	// 8219FFF0: 409A0034  bne cr6, 0x821a0024
	if !ctx.cr[6].eq {
	pc = 0x821A0024; continue 'dispatch;
	}
	// 8219FFF4: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8219FFF8: 916A42EC  stw r11, 0x42ec(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(17132 as u32), ctx.r[11].u32 ) };
	// 8219FFFC: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A0000: C00BD5B0  lfs f0, -0x2a50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A0004: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A0008: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A000C: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A0010: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A0014: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A0018: C00B20C8  lfs f0, 0x20c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A001C: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A0020: D3FE000C  stfs f31, 0xc(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A0024: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A0028: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A002C: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 821A0030: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821A0034: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821A0038: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A003C: 4BFFEA15  bl 0x8219ea50
	ctx.lr = 0x821A0040;
	sub_8219EA50(ctx, base);
	// 821A0040: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A0044: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A0048: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A004C: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A0050: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0054: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A0058: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 821A005C: 38C0006B  li r6, 0x6b
	ctx.r[6].s64 = 107;
	// 821A0060: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821A0064: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821A0068: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A006C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821A0070: FBE10060  std r31, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u64 ) };
	// 821A0074: 481AB8ED  bl 0x8234b960
	ctx.lr = 0x821A0078;
	sub_8234B960(ctx, base);
	// 821A0078: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A007C: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821A0080: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821A0084: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 821A0088: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A008C: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A0090: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821A0094: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821A0098: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 821A009C: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 821A00A0: 4800A959  bl 0x821aa9f8
	ctx.lr = 0x821A00A4;
	sub_821AA9F8(ctx, base);
	// 821A00A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A00A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A00AC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821A00B0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A00B4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821A00B8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A00BC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A00C0: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 821A00C4: C02B2068  lfs f1, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A00C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A00CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A00D0: 480011E1  bl 0x821a12b0
	ctx.lr = 0x821A00D4;
	sub_821A12B0(ctx, base);
	// 821A00D4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A00D8: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A00DC: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A00E0: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 821A00E4: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821A00E8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A00EC: 409A0018  bne cr6, 0x821a0104
	if !ctx.cr[6].eq {
	pc = 0x821A0104; continue 'dispatch;
	}
	// 821A00F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A00F4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821A00F8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A00FC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A0100: 4BFDCD01  bl 0x8217ce00
	ctx.lr = 0x821A0104;
	sub_8217CE00(ctx, base);
	// 821A0104: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821A0108: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821A010C: 48394FFC  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A0110 size=328
    let mut pc: u32 = 0x821A0110;
    'dispatch: loop {
        match pc {
            0x821A0110 => {
    //   block [0x821A0110..0x821A0258)
	// 821A0110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A0114: 48394FA5  bl 0x825350b8
	ctx.lr = 0x821A0118;
	sub_82535080(ctx, base);
	// 821A0118: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821A011C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A0120: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 821A0124: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821A0128: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A012C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821A0130: 816A42D8  lwz r11, 0x42d8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17112 as u32) ) } as u64;
	// 821A0134: C3E8BA38  lfs f31, -0x45c8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A0138: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821A013C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A0140: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 821A0144: 3BC942C8  addi r30, r9, 0x42c8
	ctx.r[30].s64 = ctx.r[9].s64 + 17096;
	// 821A0148: 409A0024  bne cr6, 0x821a016c
	if !ctx.cr[6].eq {
	pc = 0x821A016C; continue 'dispatch;
	}
	// 821A014C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821A0150: 916A42D8  stw r11, 0x42d8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(17112 as u32), ctx.r[11].u32 ) };
	// 821A0154: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A0158: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A015C: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A0160: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A0164: D3FE0008  stfs f31, 8(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A0168: D3FE000C  stfs f31, 0xc(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A016C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A0170: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A0174: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 821A0178: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821A017C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821A0180: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A0184: 4BFFE8CD  bl 0x8219ea50
	ctx.lr = 0x821A0188;
	sub_8219EA50(ctx, base);
	// 821A0188: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A018C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A0190: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A0194: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A0198: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A019C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A01A0: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 821A01A4: 38C0007C  li r6, 0x7c
	ctx.r[6].s64 = 124;
	// 821A01A8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821A01AC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821A01B0: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A01B4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821A01B8: FBE10060  std r31, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u64 ) };
	// 821A01BC: 481AB7A5  bl 0x8234b960
	ctx.lr = 0x821A01C0;
	sub_8234B960(ctx, base);
	// 821A01C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A01C4: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821A01C8: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821A01CC: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 821A01D0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A01D4: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A01D8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821A01DC: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821A01E0: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 821A01E4: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 821A01E8: 4800A811  bl 0x821aa9f8
	ctx.lr = 0x821A01EC;
	sub_821AA9F8(ctx, base);
	// 821A01EC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A01F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A01F4: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821A01F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A01FC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821A0200: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A0204: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A0208: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 821A020C: C02B2068  lfs f1, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A0210: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A0214: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A0218: 48001099  bl 0x821a12b0
	ctx.lr = 0x821A021C;
	sub_821A12B0(ctx, base);
	// 821A021C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A0220: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A0224: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A0228: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 821A022C: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821A0230: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A0234: 409A0018  bne cr6, 0x821a024c
	if !ctx.cr[6].eq {
	pc = 0x821A024C; continue 'dispatch;
	}
	// 821A0238: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A023C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821A0240: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A0244: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 821A0248: 4BFDCBB9  bl 0x8217ce00
	ctx.lr = 0x821A024C;
	sub_8217CE00(ctx, base);
	// 821A024C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821A0250: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821A0254: 48394EB4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A0258 size=288
    let mut pc: u32 = 0x821A0258;
    'dispatch: loop {
        match pc {
            0x821A0258 => {
    //   block [0x821A0258..0x821A0378)
	// 821A0258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A025C: 48394E5D  bl 0x825350b8
	ctx.lr = 0x821A0260;
	sub_82535080(ctx, base);
	// 821A0260: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A0264: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 821A0268: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821A026C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A0270: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821A0274: 816A42A4  lwz r11, 0x42a4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17060 as u32) ) } as u64;
	// 821A0278: C028BA38  lfs f1, -0x45c8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A027C: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821A0280: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A0284: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 821A0288: 3BE94294  addi r31, r9, 0x4294
	ctx.r[31].s64 = ctx.r[9].s64 + 17044;
	// 821A028C: 409A0034  bne cr6, 0x821a02c0
	if !ctx.cr[6].eq {
	pc = 0x821A02C0; continue 'dispatch;
	}
	// 821A0290: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821A0294: 916A42A4  stw r11, 0x42a4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(17060 as u32), ctx.r[11].u32 ) };
	// 821A0298: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A029C: C00B2C44  lfs f0, 0x2c44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11332 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A02A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A02A4: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A02A8: C00B203C  lfs f0, 0x203c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A02AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A02B0: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A02B4: C00B295C  lfs f0, 0x295c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10588 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A02B8: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A02BC: D03F000C  stfs f1, 0xc(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A02C0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A02C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A02C8: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 821A02CC: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 821A02D0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821A02D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A02D8: 4BFFE779  bl 0x8219ea50
	ctx.lr = 0x821A02DC;
	sub_8219EA50(ctx, base);
	// 821A02DC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A02E0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821A02E4: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A02E8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A02EC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A02F0: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 821A02F4: 38C0007A  li r6, 0x7a
	ctx.r[6].s64 = 122;
	// 821A02F8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821A02FC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821A0300: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A0304: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A0308: FBC10060  std r30, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u64 ) };
	// 821A030C: 481AB655  bl 0x8234b960
	ctx.lr = 0x821A0310;
	sub_8234B960(ctx, base);
	// 821A0310: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A0314: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0318: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 821A031C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0320: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821A0324: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A0328: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A032C: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 821A0330: C02B2068  lfs f1, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A0334: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A0338: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821A033C: 48000F75  bl 0x821a12b0
	ctx.lr = 0x821A0340;
	sub_821A12B0(ctx, base);
	// 821A0340: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A0344: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A0348: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A034C: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 821A0350: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821A0354: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A0358: 409A0018  bne cr6, 0x821a0370
	if !ctx.cr[6].eq {
	pc = 0x821A0370; continue 'dispatch;
	}
	// 821A035C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A0360: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821A0364: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A0368: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 821A036C: 4BFDCA95  bl 0x8217ce00
	ctx.lr = 0x821A0370;
	sub_8217CE00(ctx, base);
	// 821A0370: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821A0374: 48394D94  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A0378 size=288
    let mut pc: u32 = 0x821A0378;
    'dispatch: loop {
        match pc {
            0x821A0378 => {
    //   block [0x821A0378..0x821A0498)
	// 821A0378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A037C: 48394D3D  bl 0x825350b8
	ctx.lr = 0x821A0380;
	sub_82535080(ctx, base);
	// 821A0380: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A0384: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 821A0388: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821A038C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A0390: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821A0394: 816A4290  lwz r11, 0x4290(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17040 as u32) ) } as u64;
	// 821A0398: C028BA38  lfs f1, -0x45c8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A039C: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821A03A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A03A4: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 821A03A8: 3BE94280  addi r31, r9, 0x4280
	ctx.r[31].s64 = ctx.r[9].s64 + 17024;
	// 821A03AC: 409A0034  bne cr6, 0x821a03e0
	if !ctx.cr[6].eq {
	pc = 0x821A03E0; continue 'dispatch;
	}
	// 821A03B0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821A03B4: 916A4290  stw r11, 0x4290(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(17040 as u32), ctx.r[11].u32 ) };
	// 821A03B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A03BC: C00B2C44  lfs f0, 0x2c44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11332 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A03C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A03C4: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A03C8: C00B203C  lfs f0, 0x203c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A03CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A03D0: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A03D4: C00B295C  lfs f0, 0x295c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10588 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A03D8: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A03DC: D03F000C  stfs f1, 0xc(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A03E0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A03E4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A03E8: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 821A03EC: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 821A03F0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821A03F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A03F8: 4BFFE659  bl 0x8219ea50
	ctx.lr = 0x821A03FC;
	sub_8219EA50(ctx, base);
	// 821A03FC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A0400: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821A0404: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A0408: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A040C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A0410: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 821A0414: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 821A0418: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821A041C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821A0420: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A0424: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A0428: FBC10060  std r30, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u64 ) };
	// 821A042C: 481AB535  bl 0x8234b960
	ctx.lr = 0x821A0430;
	sub_8234B960(ctx, base);
	// 821A0430: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A0434: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0438: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 821A043C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0440: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821A0444: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A0448: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A044C: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 821A0450: C02B2068  lfs f1, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A0454: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A0458: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821A045C: 48000E55  bl 0x821a12b0
	ctx.lr = 0x821A0460;
	sub_821A12B0(ctx, base);
	// 821A0460: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A0464: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A0468: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A046C: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 821A0470: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821A0474: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A0478: 409A0018  bne cr6, 0x821a0490
	if !ctx.cr[6].eq {
	pc = 0x821A0490; continue 'dispatch;
	}
	// 821A047C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A0480: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821A0484: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A0488: 38600006  li r3, 6
	ctx.r[3].s64 = 6;
	// 821A048C: 4BFDC975  bl 0x8217ce00
	ctx.lr = 0x821A0490;
	sub_8217CE00(ctx, base);
	// 821A0490: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821A0494: 48394C74  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A0498 size=564
    let mut pc: u32 = 0x821A0498;
    'dispatch: loop {
        match pc {
            0x821A0498 => {
    //   block [0x821A0498..0x821A06CC)
	// 821A0498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A049C: 48394C15  bl 0x825350b0
	ctx.lr = 0x821A04A0;
	sub_82535080(ctx, base);
	// 821A04A0: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 821A04A4: 48395B45  bl 0x82535fe8
	ctx.lr = 0x821A04A8;
	sub_82535FB0(ctx, base);
	// 821A04A8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A04AC: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 821A04B0: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821A04B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A04B8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821A04BC: 816A44A8  lwz r11, 0x44a8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17576 as u32) ) } as u64;
	// 821A04C0: C388BA38  lfs f28, -0x45c8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821A04C4: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821A04C8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A04CC: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 821A04D0: 3BA94498  addi r29, r9, 0x4498
	ctx.r[29].s64 = ctx.r[9].s64 + 17560;
	// 821A04D4: 409A0034  bne cr6, 0x821a0508
	if !ctx.cr[6].eq {
	pc = 0x821A0508; continue 'dispatch;
	}
	// 821A04D8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821A04DC: 916A44A8  stw r11, 0x44a8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(17576 as u32), ctx.r[11].u32 ) };
	// 821A04E0: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A04E4: C00BD5B0  lfs f0, -0x2a50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A04E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A04EC: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A04F0: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A04F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A04F8: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A04FC: C00B20C8  lfs f0, 0x20c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A0500: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A0504: D39D000C  stfs f28, 0xc(r29)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A0508: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A050C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A0510: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 821A0514: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821A0518: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821A051C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A0520: 4BFFE531  bl 0x8219ea50
	ctx.lr = 0x821A0524;
	sub_8219EA50(ctx, base);
	// 821A0524: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A0528: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 821A052C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821A0530: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A0534: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A0538: 4E800421  bctrl
	ctx.lr = 0x821A053C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A053C: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821A0540: C3E30030  lfs f31, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A0544: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821A0548: 616BA9C0  ori r11, r11, 0xa9c0
	ctx.r[11].u64 = ctx.r[11].u64 | 43456;
	// 821A054C: C3C30034  lfs f30, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A0550: C3A30038  lfs f29, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821A0554: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821A0558: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A055C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A0560: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A0564: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A0568: 4E800421  bctrl
	ctx.lr = 0x821A056C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A056C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A0570: C1A1008C  lfs f13, 0x8c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A0574: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821A0578: D1A1007C  stfs f13, 0x7c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 821A057C: C1A30030  lfs f13, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A0580: C1830034  lfs f12, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A0584: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A0588: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A058C: ED5F0032  fmuls f10, f31, f0
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A0590: C1630038  lfs f11, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A0594: ED3E0032  fmuls f9, f30, f0
	ctx.f[9].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A0598: 616BBE64  ori r11, r11, 0xbe64
	ctx.r[11].u64 = ctx.r[11].u64 | 48740;
	// 821A059C: ED1D0032  fmuls f8, f29, f0
	ctx.f[8].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A05A0: FBC10060  std r30, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u64 ) };
	// 821A05A4: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821A05A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A05AC: EDAD503A  fmadds f13, f13, f0, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 821A05B0: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821A05B4: EDAC483A  fmadds f13, f12, f0, f9
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64);
	// 821A05B8: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821A05BC: EC0B403A  fmadds f0, f11, f0, f8
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 821A05C0: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 821A05C4: 409A0034  bne cr6, 0x821a05f8
	if !ctx.cr[6].eq {
	pc = 0x821A05F8; continue 'dispatch;
	}
	// 821A05C8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A05CC: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 821A05D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A05D4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821A05D8: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A05DC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A05E0: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 821A05E4: 38C0007D  li r6, 0x7d
	ctx.r[6].s64 = 125;
	// 821A05E8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821A05EC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821A05F0: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A05F4: 481AB36D  bl 0x8234b960
	ctx.lr = 0x821A05F8;
	sub_8234B960(ctx, base);
	// 821A05F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A05FC: FC40E090  fmr f2, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[28].f64;
	// 821A0600: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821A0604: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 821A0608: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 821A060C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821A0610: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A0614: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821A0618: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 821A061C: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 821A0620: 4800A3D9  bl 0x821aa9f8
	ctx.lr = 0x821A0624;
	sub_821AA9F8(ctx, base);
	// 821A0624: 3D4082B5  lis r10, -0x7d4b
	ctx.r[10].s64 = -2102067200;
	// 821A0628: 3F6082C0  lis r27, -0x7d40
	ctx.r[27].s64 = -2101346304;
	// 821A062C: 3B8A0C40  addi r28, r10, 0xc40
	ctx.r[28].s64 = ctx.r[10].s64 + 3136;
	// 821A0630: 817BB9DC  lwz r11, -0x4624(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17956 as u32) ) } as u64;
	// 821A0634: 815C0684  lwz r10, 0x684(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1668 as u32) ) } as u64;
	// 821A0638: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A063C: 419A0024  beq cr6, 0x821a0660
	if ctx.cr[6].eq {
	pc = 0x821A0660; continue 'dispatch;
	}
	// 821A0640: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A0644: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 821A0648: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A064C: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 821A0650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A0654: 481C0AB5  bl 0x82361108
	ctx.lr = 0x821A0658;
	sub_82361108(ctx, base);
	// 821A0658: 817C0684  lwz r11, 0x684(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1668 as u32) ) } as u64;
	// 821A065C: 917BB9DC  stw r11, -0x4624(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(-17956 as u32), ctx.r[11].u32 ) };
	// 821A0660: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0664: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 821A0668: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A066C: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 821A0670: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A0674: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821A0678: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A067C: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 821A0680: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A0684: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A0688: 48000C29  bl 0x821a12b0
	ctx.lr = 0x821A068C;
	sub_821A12B0(ctx, base);
	// 821A068C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A0690: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A0694: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A0698: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 821A069C: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821A06A0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A06A4: 409A0018  bne cr6, 0x821a06bc
	if !ctx.cr[6].eq {
	pc = 0x821A06BC; continue 'dispatch;
	}
	// 821A06A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A06AC: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821A06B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A06B4: 38600007  li r3, 7
	ctx.r[3].s64 = 7;
	// 821A06B8: 4BFDC749  bl 0x8217ce00
	ctx.lr = 0x821A06BC;
	sub_8217CE00(ctx, base);
	// 821A06BC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 821A06C0: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 821A06C4: 48395971  bl 0x82536034
	ctx.lr = 0x821A06C8;
	sub_82535FFC(ctx, base);
	// 821A06C8: 48394A38  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A06D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A06D0 size=228
    let mut pc: u32 = 0x821A06D0;
    'dispatch: loop {
        match pc {
            0x821A06D0 => {
    //   block [0x821A06D0..0x821A07B4)
	// 821A06D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A06D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A06D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A06DC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A06E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A06E4: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 821A06E8: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A06EC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A06F0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A06F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A06F8: 4E800421  bctrl
	ctx.lr = 0x821A06FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A06FC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A0700: C0230030  lfs f1, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A0704: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A0708: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821A070C: C0430038  lfs f2, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A0710: D0210070  stfs f1, 0x70(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821A0714: D0410078  stfs f2, 0x78(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 821A0718: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821A071C: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821A0720: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A0724: 40990018  ble cr6, 0x821a073c
	if !ctx.cr[6].gt {
	pc = 0x821A073C; continue 'dispatch;
	}
	// 821A0728: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821A072C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821A0730: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A0734: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A0738: 41990008  bgt cr6, 0x821a0740
	if ctx.cr[6].gt {
	pc = 0x821A0740; continue 'dispatch;
	}
	// 821A073C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821A0740: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A0744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A0748: 409A0010  bne cr6, 0x821a0758
	if !ctx.cr[6].eq {
	pc = 0x821A0758; continue 'dispatch;
	}
	// 821A074C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A0750: 48016D79  bl 0x821b74c8
	ctx.lr = 0x821A0754;
	sub_821B74C8(ctx, base);
	// 821A0754: 48000014  b 0x821a0768
	pc = 0x821A0768; continue 'dispatch;
	// 821A0758: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A075C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 821A0760: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821A0764: 48016DCD  bl 0x821b7530
	ctx.lr = 0x821A0768;
	sub_821B7530(ctx, base);
	// 821A0768: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 821A076C: D0210074  stfs f1, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821A0770: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0774: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821A0778: 390B33C0  addi r8, r11, 0x33c0
	ctx.r[8].s64 = ctx.r[11].s64 + 13248;
	// 821A077C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A0780: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821A0784: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A0788: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821A078C: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 821A0790: C04BBA38  lfs f2, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A0794: 38600011  li r3, 0x11
	ctx.r[3].s64 = 17;
	// 821A0798: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 821A079C: 4800A25D  bl 0x821aa9f8
	ctx.lr = 0x821A07A0;
	sub_821AA9F8(ctx, base);
	// 821A07A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A07A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A07A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A07AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A07B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A07B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A07B8 size=380
    let mut pc: u32 = 0x821A07B8;
    'dispatch: loop {
        match pc {
            0x821A07B8 => {
    //   block [0x821A07B8..0x821A0934)
	// 821A07B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A07BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A07C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A07C4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A07C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A07CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A07D0: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821A07D4: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821A07D8: 40980020  bge cr6, 0x821a07f8
	if !ctx.cr[6].lt {
	pc = 0x821A07F8; continue 'dispatch;
	}
	// 821A07DC: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821A07E0: 614AFAF0  ori r10, r10, 0xfaf0
	ctx.r[10].u64 = ctx.r[10].u64 | 64240;
	// 821A07E4: 7D44502E  lwzx r10, r4, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821A07E8: C00A0010  lfs f0, 0x10(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A07EC: C1AA0008  lfs f13, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A07F0: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821A07F4: 48000018  b 0x821a080c
	pc = 0x821A080C; continue 'dispatch;
	// 821A07F8: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 821A07FC: F9410090  std r10, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u64 ) };
	// 821A0800: C8010090  lfd f0, 0x90(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821A0804: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A0808: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A080C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A0810: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A0814: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821A0818: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821A081C: C04ABA38  lfs f2, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A0820: 41990008  bgt cr6, 0x821a0828
	if ctx.cr[6].gt {
	pc = 0x821A0828; continue 'dispatch;
	}
	// 821A0824: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 821A0828: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 821A082C: 4198009C  blt cr6, 0x821a08c8
	if ctx.cr[6].lt {
	pc = 0x821A08C8; continue 'dispatch;
	}
	// 821A0830: 419A0058  beq cr6, 0x821a0888
	if ctx.cr[6].eq {
	pc = 0x821A0888; continue 'dispatch;
	}
	// 821A0834: 2B070003  cmplwi cr6, r7, 3
	ctx.cr[6].compare_u32(ctx.r[7].u32, 3 as u32, &mut ctx.xer);
	// 821A0838: 409800E0  bge cr6, 0x821a0918
	if !ctx.cr[6].lt {
	pc = 0x821A0918; continue 'dispatch;
	}
	// 821A083C: 2F0800C1  cmpwi cr6, r8, 0xc1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 193, &mut ctx.xer);
	// 821A0840: 409A0008  bne cr6, 0x821a0848
	if !ctx.cr[6].eq {
	pc = 0x821A0848; continue 'dispatch;
	}
	// 821A0844: 3900007C  li r8, 0x7c
	ctx.r[8].s64 = 124;
	// 821A0848: 38E00400  li r7, 0x400
	ctx.r[7].s64 = 1024;
	// 821A084C: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 821A0850: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 821A0854: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0858: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 821A085C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0860: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 821A0864: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 821A0868: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 821A086C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821A0870: 90E10084  stw r7, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[7].u32 ) };
	// 821A0874: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821A0878: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A087C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 821A0880: 4800A8D9  bl 0x821ab158
	ctx.lr = 0x821A0884;
	sub_821AB158(ctx, base);
	// 821A0884: 4800008C  b 0x821a0910
	pc = 0x821A0910; continue 'dispatch;
	// 821A0888: 38E00400  li r7, 0x400
	ctx.r[7].s64 = 1024;
	// 821A088C: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 821A0890: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 821A0894: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0898: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 821A089C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A08A0: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 821A08A4: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 821A08A8: 38800019  li r4, 0x19
	ctx.r[4].s64 = 25;
	// 821A08AC: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821A08B0: 90E10084  stw r7, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[7].u32 ) };
	// 821A08B4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 821A08B8: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A08BC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 821A08C0: 4800A899  bl 0x821ab158
	ctx.lr = 0x821A08C4;
	sub_821AB158(ctx, base);
	// 821A08C4: 4800004C  b 0x821a0910
	pc = 0x821A0910; continue 'dispatch;
	// 821A08C8: 2F0800C1  cmpwi cr6, r8, 0xc1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 193, &mut ctx.xer);
	// 821A08CC: 409A0008  bne cr6, 0x821a08d4
	if !ctx.cr[6].eq {
	pc = 0x821A08D4; continue 'dispatch;
	}
	// 821A08D0: 3900007C  li r8, 0x7c
	ctx.r[8].s64 = 124;
	// 821A08D4: 38E00400  li r7, 0x400
	ctx.r[7].s64 = 1024;
	// 821A08D8: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 821A08DC: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 821A08E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A08E4: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 821A08E8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A08EC: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 821A08F0: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 821A08F4: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 821A08F8: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821A08FC: 90E10084  stw r7, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[7].u32 ) };
	// 821A0900: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 821A0904: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A0908: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 821A090C: 4800A84D  bl 0x821ab158
	ctx.lr = 0x821A0910;
	sub_821AB158(ctx, base);
	// 821A0910: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A0914: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A0918: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821A091C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A0920: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821A0924: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A0928: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A092C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A0930: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A0938 size=396
    let mut pc: u32 = 0x821A0938;
    'dispatch: loop {
        match pc {
            0x821A0938 => {
    //   block [0x821A0938..0x821A0AC4)
	// 821A0938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A093C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A0940: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A0944: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 821A0948: 2B060001  cmplwi cr6, r6, 1
	ctx.cr[6].compare_u32(ctx.r[6].u32, 1 as u32, &mut ctx.xer);
	// 821A094C: 41980100  blt cr6, 0x821a0a4c
	if ctx.cr[6].lt {
	pc = 0x821A0A4C; continue 'dispatch;
	}
	// 821A0950: 419A0084  beq cr6, 0x821a09d4
	if ctx.cr[6].eq {
	pc = 0x821A09D4; continue 'dispatch;
	}
	// 821A0954: 2B060003  cmplwi cr6, r6, 3
	ctx.cr[6].compare_u32(ctx.r[6].u32, 3 as u32, &mut ctx.xer);
	// 821A0958: 4098015C  bge cr6, 0x821a0ab4
	if !ctx.cr[6].lt {
	pc = 0x821A0AB4; continue 'dispatch;
	}
	// 821A095C: 2F0800C1  cmpwi cr6, r8, 0xc1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 193, &mut ctx.xer);
	// 821A0960: 409A0008  bne cr6, 0x821a0968
	if !ctx.cr[6].eq {
	pc = 0x821A0968; continue 'dispatch;
	}
	// 821A0964: 390000A0  li r8, 0xa0
	ctx.r[8].s64 = 160;
	// 821A0968: 7CA707B4  extsw r7, r5
	ctx.r[7].s64 = ctx.r[5].s32 as i64;
	// 821A096C: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 821A0970: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821A0974: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 821A0978: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A097C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 821A0980: 38C00400  li r6, 0x400
	ctx.r[6].s64 = 1024;
	// 821A0984: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0988: F8E10090  std r7, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[7].u64 ) };
	// 821A098C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821A0990: C04ABA38  lfs f2, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A0994: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A0998: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A099C: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 821A09A0: 38800033  li r4, 0x33
	ctx.r[4].s64 = 51;
	// 821A09A4: 90C10084  stw r6, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[6].u32 ) };
	// 821A09A8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 821A09AC: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821A09B0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821A09B4: C8010090  lfd f0, 0x90(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821A09B8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A09BC: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A09C0: 4800A799  bl 0x821ab158
	ctx.lr = 0x821A09C4;
	sub_821AB158(ctx, base);
	// 821A09C4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821A09C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A09CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A09D0: 4E800020  blr
	return;
	// 821A09D4: 2F0800C1  cmpwi cr6, r8, 0xc1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 193, &mut ctx.xer);
	// 821A09D8: 409A0008  bne cr6, 0x821a09e0
	if !ctx.cr[6].eq {
	pc = 0x821A09E0; continue 'dispatch;
	}
	// 821A09DC: 39000040  li r8, 0x40
	ctx.r[8].s64 = 64;
	// 821A09E0: 7CA707B4  extsw r7, r5
	ctx.r[7].s64 = ctx.r[5].s32 as i64;
	// 821A09E4: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 821A09E8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A09EC: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 821A09F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A09F4: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 821A09F8: 38C00400  li r6, 0x400
	ctx.r[6].s64 = 1024;
	// 821A09FC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0A00: F8E10090  std r7, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[7].u64 ) };
	// 821A0A04: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821A0A08: C04A207C  lfs f2, 0x207c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8316 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A0A0C: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A0A10: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0A14: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 821A0A18: 38800014  li r4, 0x14
	ctx.r[4].s64 = 20;
	// 821A0A1C: 90C10084  stw r6, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[6].u32 ) };
	// 821A0A20: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 821A0A24: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821A0A28: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821A0A2C: C8010090  lfd f0, 0x90(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821A0A30: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A0A34: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A0A38: 4800A721  bl 0x821ab158
	ctx.lr = 0x821A0A3C;
	sub_821AB158(ctx, base);
	// 821A0A3C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821A0A40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A0A44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A0A48: 4E800020  blr
	return;
	// 821A0A4C: 2F0800C1  cmpwi cr6, r8, 0xc1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 193, &mut ctx.xer);
	// 821A0A50: 409A0008  bne cr6, 0x821a0a58
	if !ctx.cr[6].eq {
	pc = 0x821A0A58; continue 'dispatch;
	}
	// 821A0A54: 39000080  li r8, 0x80
	ctx.r[8].s64 = 128;
	// 821A0A58: 7CA707B4  extsw r7, r5
	ctx.r[7].s64 = ctx.r[5].s32 as i64;
	// 821A0A5C: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 821A0A60: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821A0A64: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 821A0A68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A0A6C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 821A0A70: 38C00400  li r6, 0x400
	ctx.r[6].s64 = 1024;
	// 821A0A74: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0A78: F8E10090  std r7, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[7].u64 ) };
	// 821A0A7C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821A0A80: C04ABA38  lfs f2, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A0A84: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A0A88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0A8C: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 821A0A90: 38800013  li r4, 0x13
	ctx.r[4].s64 = 19;
	// 821A0A94: 90C10084  stw r6, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[6].u32 ) };
	// 821A0A98: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 821A0A9C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821A0AA0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821A0AA4: C8010090  lfd f0, 0x90(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821A0AA8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A0AAC: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A0AB0: 4800A6A9  bl 0x821ab158
	ctx.lr = 0x821A0AB4;
	sub_821AB158(ctx, base);
	// 821A0AB4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821A0AB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A0ABC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A0AC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A0AC8 size=364
    let mut pc: u32 = 0x821A0AC8;
    'dispatch: loop {
        match pc {
            0x821A0AC8 => {
    //   block [0x821A0AC8..0x821A0C34)
	// 821A0AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A0ACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A0AD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A0AD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A0AD8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A0ADC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A0AE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A0AE4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821A0AE8: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821A0AEC: F87F0000  std r3, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u64 ) };
	// 821A0AF0: 40980020  bge cr6, 0x821a0b10
	if !ctx.cr[6].lt {
	pc = 0x821A0B10; continue 'dispatch;
	}
	// 821A0AF4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A0AF8: 616BFAF0  ori r11, r11, 0xfaf0
	ctx.r[11].u64 = ctx.r[11].u64 | 64240;
	// 821A0AFC: 7D64582E  lwzx r11, r4, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821A0B00: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A0B04: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A0B08: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821A0B0C: 48000018  b 0x821a0b24
	pc = 0x821A0B24; continue 'dispatch;
	// 821A0B10: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 821A0B14: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 821A0B18: C8010090  lfd f0, 0x90(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821A0B1C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A0B20: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A0B24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A0B28: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A0B2C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821A0B30: 4199000C  bgt cr6, 0x821a0b3c
	if ctx.cr[6].gt {
	pc = 0x821A0B3C; continue 'dispatch;
	}
	// 821A0B34: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A0B38: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A0B3C: 2F0800C1  cmpwi cr6, r8, 0xc1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 193, &mut ctx.xer);
	// 821A0B40: 409A0014  bne cr6, 0x821a0b54
	if !ctx.cr[6].eq {
	pc = 0x821A0B54; continue 'dispatch;
	}
	// 821A0B44: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A0B48: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A0B4C: 396B53C8  addi r11, r11, 0x53c8
	ctx.r[11].s64 = ctx.r[11].s64 + 21448;
	// 821A0B50: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821A0B54: 3D208286  lis r9, -0x7d7a
	ctx.r[9].s64 = -2105147392;
	// 821A0B58: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A0B5C: 38C95300  addi r6, r9, 0x5300
	ctx.r[6].s64 = ctx.r[9].s64 + 21248;
	// 821A0B60: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 821A0B64: 39260068  addi r9, r6, 0x68
	ctx.r[9].s64 = ctx.r[6].s64 + 104;
	// 821A0B68: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A0B6C: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821A0B70: F9210090  std r9, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[9].u64 ) };
	// 821A0B74: C9A10090  lfd f13, 0x90(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821A0B78: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821A0B7C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A0B80: EDAD0072  fmuls f13, f13, f1
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[1].f64) as f32) as f64);
	// 821A0B84: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 821A0B88: 7DA02FAE  stfiwx f13, 0, r5
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32, tmp.u32) };
	// 821A0B8C: 80A10090  lwz r5, 0x90(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A0B90: 2F050004  cmpwi cr6, r5, 4
	ctx.cr[6].compare_i32(ctx.r[5].s32, 4, &mut ctx.xer);
	// 821A0B94: 40980008  bge cr6, 0x821a0b9c
	if !ctx.cr[6].lt {
	pc = 0x821A0B9C; continue 'dispatch;
	}
	// 821A0B98: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821A0B9C: 2F070011  cmpwi cr6, r7, 0x11
	ctx.cr[6].compare_i32(ctx.r[7].s32, 17, &mut ctx.xer);
	// 821A0BA0: 409A0024  bne cr6, 0x821a0bc4
	if !ctx.cr[6].eq {
	pc = 0x821A0BC4; continue 'dispatch;
	}
	// 821A0BA4: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821A0BA8: 6129BEC4  ori r9, r9, 0xbec4
	ctx.r[9].u64 = ctx.r[9].u64 | 48836;
	// 821A0BAC: 7D244A2E  lhzx r9, r4, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A0BB0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A0BB4: 409A0010  bne cr6, 0x821a0bc4
	if !ctx.cr[6].eq {
	pc = 0x821A0BC4; continue 'dispatch;
	}
	// 821A0BB8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A0BBC: C049BFFC  lfs f2, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A0BC0: 48000010  b 0x821a0bd0
	pc = 0x821A0BD0; continue 'dispatch;
	// 821A0BC4: 3D208286  lis r9, -0x7d7a
	ctx.r[9].s64 = -2105147392;
	// 821A0BC8: 39295430  addi r9, r9, 0x5430
	ctx.r[9].s64 = ctx.r[9].s64 + 21552;
	// 821A0BCC: 7C4B4C2E  lfsx f2, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A0BD0: 38E00400  li r7, 0x400
	ctx.r[7].s64 = 1024;
	// 821A0BD4: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821A0BD8: 9061008C  stw r3, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 821A0BDC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0BE0: 9061007C  stw r3, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 821A0BE4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0BE8: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 821A0BEC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821A0BF0: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 821A0BF4: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 821A0BF8: 90E10084  stw r7, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[7].u32 ) };
	// 821A0BFC: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A0C00: 7C8B302E  lwzx r4, r11, r6
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821A0C04: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 821A0C08: 4800A551  bl 0x821ab158
	ctx.lr = 0x821A0C0C;
	sub_821AB158(ctx, base);
	// 821A0C0C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A0C10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A0C14: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A0C18: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821A0C1C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821A0C20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A0C24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A0C28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A0C2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A0C30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A0C38 size=376
    let mut pc: u32 = 0x821A0C38;
    'dispatch: loop {
        match pc {
            0x821A0C38 => {
    //   block [0x821A0C38..0x821A0DB0)
	// 821A0C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A0C3C: 4839447D  bl 0x825350b8
	ctx.lr = 0x821A0C40;
	sub_82535080(ctx, base);
	// 821A0C40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A0C44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A0C48: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821A0C4C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821A0C50: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 821A0C54: 481C64E5  bl 0x82367138
	ctx.lr = 0x821A0C58;
	sub_82367138(ctx, base);
	// 821A0C58: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A0C5C: C1BE0010  lfs f13, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A0C60: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A0C64: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A0C68: C16B2280  lfs f11, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A0C6C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A0C70: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A0C74: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A0C78: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 821A0C7C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A0C80: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A0C84: 481C64B5  bl 0x82367138
	ctx.lr = 0x821A0C88;
	sub_82367138(ctx, base);
	// 821A0C88: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A0C8C: C1BE0014  lfs f13, 0x14(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A0C90: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A0C94: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A0C98: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A0C9C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A0CA0: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 821A0CA4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A0CA8: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A0CAC: 481C648D  bl 0x82367138
	ctx.lr = 0x821A0CB0;
	sub_82367138(ctx, base);
	// 821A0CB0: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A0CB4: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 821A0CB8: C1BE0018  lfs f13, 0x18(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A0CBC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A0CC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A0CC4: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821A0CC8: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A0CCC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A0CD0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A0CD4: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 821A0CD8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A0CDC: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A0DB0 size=340
    let mut pc: u32 = 0x821A0DB0;
    'dispatch: loop {
        match pc {
            0x821A0DB0 => {
    //   block [0x821A0DB0..0x821A0F04)
	// 821A0DB0: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 821A0DB4: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821A0DB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A0DBC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A0DC0: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821A0DC4: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A0DC8: 812B0084  lwz r9, 0x84(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A0DCC: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A0DD0: 419A0124  beq cr6, 0x821a0ef4
	if ctx.cr[6].eq {
	pc = 0x821A0EF4; continue 'dispatch;
	}
	// 821A0DD4: 812B008C  lwz r9, 0x8c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A0DD8: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 821A0DDC: 7D095214  add r8, r9, r10
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821A0DE0: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A0DE4: 90E80008  stw r7, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821A0DE8: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 821A0DEC: 419A0010  beq cr6, 0x821a0dfc
	if ctx.cr[6].eq {
	pc = 0x821A0DFC; continue 'dispatch;
	}
	// 821A0DF0: 80EB008C  lwz r7, 0x8c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A0DF4: 912B0080  stw r9, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 821A0DF8: 7FC7492E  stwx r30, r7, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32), ctx.r[30].u32) };
	// 821A0DFC: 83EB0084  lwz r31, 0x84(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A0E00: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 821A0E04: 409A0040  bne cr6, 0x821a0e44
	if !ctx.cr[6].eq {
	pc = 0x821A0E44; continue 'dispatch;
	}
	// 821A0E08: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 821A0E0C: 914B0084  stw r10, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 821A0E10: 419A0020  beq cr6, 0x821a0e30
	if ctx.cr[6].eq {
	pc = 0x821A0E30; continue 'dispatch;
	}
	// 821A0E14: 812B0088  lwz r9, 0x88(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 821A0E18: 80EB008C  lwz r7, 0x8c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A0E1C: 93C80004  stw r30, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821A0E20: 7CE74A14  add r7, r7, r9
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821A0E24: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821A0E28: 914B0088  stw r10, 0x88(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 821A0E2C: 91470004  stw r10, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A0E30: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A0E34: 91040000  stw r8, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A0E38: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A0E3C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821A0E40: 4E800020  blr
	return;
	// 821A0E44: 80AB008C  lwz r5, 0x8c(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A0E48: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 821A0E4C: 7CC54A14  add r6, r5, r9
	ctx.r[6].u64 = ctx.r[5].u64 + ctx.r[9].u64;
	// 821A0E50: 80E60008  lwz r7, 8(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A0E54: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821A0E58: 40980014  bge cr6, 0x821a0e6c
	if !ctx.cr[6].lt {
	pc = 0x821A0E6C; continue 'dispatch;
	}
	// 821A0E5C: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A0E60: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 821A0E64: 409AFFE8  bne cr6, 0x821a0e4c
	if !ctx.cr[6].eq {
	pc = 0x821A0E4C; continue 'dispatch;
	}
	// 821A0E68: 4800000C  b 0x821a0e74
	pc = 0x821A0E74; continue 'dispatch;
	// 821A0E6C: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 821A0E70: 409A002C  bne cr6, 0x821a0e9c
	if !ctx.cr[6].eq {
	pc = 0x821A0E9C; continue 'dispatch;
	}
	// 821A0E74: 812B0088  lwz r9, 0x88(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 821A0E78: 93C80004  stw r30, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821A0E7C: 7CE54A14  add r7, r5, r9
	ctx.r[7].u64 = ctx.r[5].u64 + ctx.r[9].u64;
	// 821A0E80: 91040000  stw r8, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A0E84: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821A0E88: 914B0088  stw r10, 0x88(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 821A0E8C: 91470004  stw r10, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A0E90: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A0E94: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821A0E98: 4E800020  blr
	return;
	// 821A0E9C: 7F09F800  cmpw cr6, r9, r31
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[31].s32, &mut ctx.xer);
	// 821A0EA0: 409A0008  bne cr6, 0x821a0ea8
	if !ctx.cr[6].eq {
	pc = 0x821A0EA8; continue 'dispatch;
	}
	// 821A0EA4: 914B0084  stw r10, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 821A0EA8: 80E60000  lwz r7, 0(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A0EAC: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821A0EB0: 2F07FFFF  cmpwi cr6, r7, -1
	ctx.cr[6].compare_i32(ctx.r[7].s32, -1, &mut ctx.xer);
	// 821A0EB4: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821A0EB8: 419A0024  beq cr6, 0x821a0edc
	if ctx.cr[6].eq {
	pc = 0x821A0EDC; continue 'dispatch;
	}
	// 821A0EBC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A0EC0: 91040000  stw r8, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A0EC4: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A0EC8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A0ECC: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A0ED0: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A0ED4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821A0ED8: 4E800020  blr
	return;
	// 821A0EDC: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821A0EE0: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A0EE4: 91040000  stw r8, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A0EE8: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A0EEC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821A0EF0: 4E800020  blr
	return;
	// 821A0EF4: 90E40000  stw r7, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821A0EF8: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A0EFC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821A0F00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A0F08 size=84
    let mut pc: u32 = 0x821A0F08;
    'dispatch: loop {
        match pc {
            0x821A0F08 => {
    //   block [0x821A0F08..0x821A0F5C)
	// 821A0F08: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A0F0C: 8143008C  lwz r10, 0x8c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A0F10: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821A0F14: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A0F18: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A0F1C: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 821A0F20: 7CCA4A14  add r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821A0F24: 409A0008  bne cr6, 0x821a0f2c
	if !ctx.cr[6].eq {
	pc = 0x821A0F2C; continue 'dispatch;
	}
	// 821A0F28: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A0F2C: 2F07FFFF  cmpwi cr6, r7, -1
	ctx.cr[6].compare_i32(ctx.r[7].s32, -1, &mut ctx.xer);
	// 821A0F30: 419A0054  beq cr6, 0x821a0f84
	if ctx.cr[6].eq {
		sub_821A0F84(ctx, base);
		return;
	}
	// 821A0F34: 80A30084  lwz r5, 0x84(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A0F38: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821A0F3C: 7F082800  cmpw cr6, r8, r5
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[5].s32, &mut ctx.xer);
	// 821A0F40: 409A0008  bne cr6, 0x821a0f48
	if !ctx.cr[6].eq {
	pc = 0x821A0F48; continue 'dispatch;
	}
	// 821A0F44: 91230084  stw r9, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 821A0F48: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 821A0F4C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821A0F50: 409A000C  bne cr6, 0x821a0f5c
	if !ctx.cr[6].eq {
		sub_821A0F5C(ctx, base);
		return;
	}
	// 821A0F54: 90E30088  stw r7, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[7].u32 ) };
	// 821A0F58: 48000008  b 0x821a0f60
	sub_821A0F5C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0F5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A0F5C size=40
    let mut pc: u32 = 0x821A0F5C;
    'dispatch: loop {
        match pc {
            0x821A0F5C => {
    //   block [0x821A0F5C..0x821A0F84)
	// 821A0F5C: 90E60000  stw r7, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821A0F60: 81430080  lwz r10, 0x80(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A0F64: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A0F68: 8123008C  lwz r9, 0x8c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A0F6C: 91030080  stw r8, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[8].u32 ) };
	// 821A0F70: 90C40000  stw r6, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 821A0F74: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821A0F78: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A0F7C: 7D09512E  stwx r8, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821A0F80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0F84(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A0F84 size=12
    let mut pc: u32 = 0x821A0F84;
    'dispatch: loop {
        match pc {
            0x821A0F84 => {
    //   block [0x821A0F84..0x821A0F90)
	// 821A0F84: 91230084  stw r9, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 821A0F88: 90C40000  stw r6, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 821A0F8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A0F90 size=44
    let mut pc: u32 = 0x821A0F90;
    'dispatch: loop {
        match pc {
            0x821A0F90 => {
    //   block [0x821A0F90..0x821A0FBC)
	// 821A0F90: 89430020  lbz r10, 0x20(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A0F94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A0F98: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 821A0F9C: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 821A0FA0: 99630026  stb r11, 0x26(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(38 as u32), ctx.r[11].u8 ) };
	// 821A0FA4: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821A0FA8: F9630040  std r11, 0x40(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u64 ) };
	// 821A0FAC: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821A0FB0: 714A00DF  andi. r10, r10, 0xdf
	ctx.r[10].u64 = ctx.r[10].u64 & 223;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A0FB4: 99430020  stb r10, 0x20(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 821A0FB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A0FC0 size=172
    let mut pc: u32 = 0x821A0FC0;
    'dispatch: loop {
        match pc {
            0x821A0FC0 => {
    //   block [0x821A0FC0..0x821A106C)
	// 821A0FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A0FC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A0FC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A0FCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A0FD0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 821A0FD4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A0FD8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A0FDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A0FE0: 396BC918  addi r11, r11, -0x36e8
	ctx.r[11].s64 = ctx.r[11].s64 + -14056;
	// 821A0FE4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821A0FE8: 3BFE0080  addi r31, r30, 0x80
	ctx.r[31].s64 = ctx.r[30].s64 + 128;
	// 821A0FEC: 394A0D0C  addi r10, r10, 0xd0c
	ctx.r[10].s64 = ctx.r[10].s64 + 3340;
	// 821A0FF0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0FF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A0FF8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A0FFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A1000: F93F0010  std r9, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u64 ) };
	// 821A1004: F93F0040  std r9, 0x40(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 821A1008: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A100C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A1010: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A1014: 4E800421  bctrl
	ctx.lr = 0x821A1018;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A1018: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A101C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A1020: 392000B0  li r9, 0xb0
	ctx.r[9].s64 = 176;
	// 821A1024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A1028: C3EBBA38  lfs f31, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A102C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A1030: D3FF00A4  stfs f31, 0xa4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 821A1034: 995F001C  stb r10, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u8 ) };
	// 821A1038: B13F0024  sth r9, 0x24(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[9].u16 ) };
	// 821A103C: C02B1FF8  lfs f1, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A1040: 481E1A49  bl 0x82382a88
	ctx.lr = 0x821A1044;
	sub_82382A88(ctx, base);
	// 821A1044: D3FF007C  stfs f31, 0x7c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 821A1048: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A104C: D3FF008C  stfs f31, 0x8c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821A1050: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A1054: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A1058: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A105C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 821A1060: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A1064: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A1068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A1070 size=128
    let mut pc: u32 = 0x821A1070;
    'dispatch: loop {
        match pc {
            0x821A1070 => {
    //   block [0x821A1070..0x821A10F0)
	// 821A1070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A1074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A1078: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A107C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A1080: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A1084: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A1088: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A108C: 396BC918  addi r11, r11, -0x36e8
	ctx.r[11].s64 = ctx.r[11].s64 + -14056;
	// 821A1090: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821A1094: 3BFE0080  addi r31, r30, 0x80
	ctx.r[31].s64 = ctx.r[30].s64 + 128;
	// 821A1098: 394A0D18  addi r10, r10, 0xd18
	ctx.r[10].s64 = ctx.r[10].s64 + 3352;
	// 821A109C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A10A0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A10A4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A10A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A10AC: F93F0010  std r9, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u64 ) };
	// 821A10B0: F93F0040  std r9, 0x40(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 821A10B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A10B8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A10BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A10C0: 4E800421  bctrl
	ctx.lr = 0x821A10C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A10C4: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 821A10C8: 394000A0  li r10, 0xa0
	ctx.r[10].s64 = 160;
	// 821A10CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A10D0: 997F001C  stb r11, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 821A10D4: B15F0024  sth r10, 0x24(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u16 ) };
	// 821A10D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A10DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A10E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A10E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A10E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A10EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A10F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A10F0 size=328
    let mut pc: u32 = 0x821A10F0;
    'dispatch: loop {
        match pc {
            0x821A10F0 => {
    //   block [0x821A10F0..0x821A1238)
	// 821A10F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A10F4: 48393FBD  bl 0x825350b0
	ctx.lr = 0x821A10F8;
	sub_82535080(ctx, base);
	// 821A10F8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A10FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A1100: 7C9E0734  extsh r30, r4
	ctx.r[30].s64 = ctx.r[4].s16 as i64;
	// 821A1104: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821A1108: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 821A110C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821A1110: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821A1114: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821A1118: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821A111C: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 821A1120: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 821A1124: 48010165  bl 0x821b1288
	ctx.lr = 0x821A1128;
	sub_821B1288(ctx, base);
	// 821A1128: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821A112C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A1130: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821A1134: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821A1138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A113C: 419A0018  beq cr6, 0x821a1154
	if ctx.cr[6].eq {
	pc = 0x821A1154; continue 'dispatch;
	}
	// 821A1140: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A1144: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A1148: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821A114C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A1150: 419A0008  beq cr6, 0x821a1158
	if ctx.cr[6].eq {
	pc = 0x821A1158; continue 'dispatch;
	}
	// 821A1154: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 821A1158: 2F1E005A  cmpwi cr6, r30, 0x5a
	ctx.cr[6].compare_i32(ctx.r[30].s32, 90, &mut ctx.xer);
	// 821A115C: 409A001C  bne cr6, 0x821a1178
	if !ctx.cr[6].eq {
	pc = 0x821A1178; continue 'dispatch;
	}
	// 821A1160: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1164: 409A0010  bne cr6, 0x821a1174
	if !ctx.cr[6].eq {
	pc = 0x821A1174; continue 'dispatch;
	}
	// 821A1168: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A116C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821A1170: 48393F90  b 0x82535100
	sub_825350D0(ctx, base);
	return;
	// 821A1174: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 821A1178: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A117C: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 821A1180: 7F5E0734  extsh r30, r26
	ctx.r[30].s64 = ctx.r[26].s16 as i64;
	// 821A1184: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 821A1188: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A118C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A1190: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 821A1194: 7F660734  extsh r6, r27
	ctx.r[6].s64 = ctx.r[27].s16 as i64;
	// 821A1198: C02BBA38  lfs f1, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A119C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821A11A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A11A4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821A11A8: 48000109  bl 0x821a12b0
	ctx.lr = 0x821A11AC;
	sub_821A12B0(ctx, base);
	// 821A11AC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821A11B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A11B4: 419A0078  beq cr6, 0x821a122c
	if ctx.cr[6].eq {
	pc = 0x821A122C; continue 'dispatch;
	}
	// 821A11B8: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821A11BC: 3D1F0002  addis r8, r31, 2
	ctx.r[8].s64 = ctx.r[31].s64 + 131072;
	// 821A11C0: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 821A11C4: 392B1410  addi r9, r11, 0x1410
	ctx.r[9].s64 = ctx.r[11].s64 + 5136;
	// 821A11C8: 3908BE64  addi r8, r8, -0x419c
	ctx.r[8].s64 = ctx.r[8].s64 + -16796;
	// 821A11CC: 419A003C  beq cr6, 0x821a1208
	if ctx.cr[6].eq {
	pc = 0x821A1208; continue 'dispatch;
	}
	// 821A11D0: 89480000  lbz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A11D4: 39690080  addi r11, r9, 0x80
	ctx.r[11].s64 = ctx.r[9].s64 + 128;
	// 821A11D8: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 821A11DC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821A11E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A11E4: 419A0008  beq cr6, 0x821a11ec
	if ctx.cr[6].eq {
	pc = 0x821A11EC; continue 'dispatch;
	}
	// 821A11E8: 48000051  bl 0x821a1238
	ctx.lr = 0x821A11EC;
	sub_821A1238(ctx, base);
	// 821A11EC: 89680000  lbz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A11F0: 39490080  addi r10, r9, 0x80
	ctx.r[10].s64 = ctx.r[9].s64 + 128;
	// 821A11F4: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821A11F8: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 821A11FC: 7CEB512E  stwx r7, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[7].u32) };
	// 821A1200: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821A1204: 48393EFC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
	// 821A1208: 89680000  lbz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A120C: 556B283E  rotlwi r11, r11, 5
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(5)) as u64;
	// 821A1210: 7C6B482E  lwzx r3, r11, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A1214: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A1218: 419A0008  beq cr6, 0x821a1220
	if ctx.cr[6].eq {
	pc = 0x821A1220; continue 'dispatch;
	}
	// 821A121C: 4800001D  bl 0x821a1238
	ctx.lr = 0x821A1220;
	sub_821A1238(ctx, base);
	// 821A1220: 89680000  lbz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1224: 556B283E  rotlwi r11, r11, 5
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(5)) as u64;
	// 821A1228: 7CEB492E  stwx r7, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 821A122C: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821A1230: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821A1234: 48393ECC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A1238 size=40
    let mut pc: u32 = 0x821A1238;
    'dispatch: loop {
        match pc {
            0x821A1238 => {
    //   block [0x821A1238..0x821A1260)
	// 821A1238: 81630094  lwz r11, 0x94(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A123C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A1240: 40980030  bge cr6, 0x821a1270
	if !ctx.cr[6].lt {
		sub_821A1270(ctx, base);
		return;
	}
	// 821A1244: 81630090  lwz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A1248: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821A124C: 419A0014  beq cr6, 0x821a1260
	if ctx.cr[6].eq {
		sub_821A1260(ctx, base);
		return;
	}
	// 821A1250: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A1254: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1258: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 821A125C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A1260 size=16
    let mut pc: u32 = 0x821A1260;
    'dispatch: loop {
        match pc {
            0x821A1260 => {
    //   block [0x821A1260..0x821A1270)
	// 821A1260: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A1264: C00BD6D0  lfs f0, -0x2930(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10544 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1268: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 821A126C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A1270 size=32
    let mut pc: u32 = 0x821A1270;
    'dispatch: loop {
        match pc {
            0x821A1270 => {
    //   block [0x821A1270..0x821A1290)
	// 821A1270: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821A1274: 81430090  lwz r10, 0x90(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A1278: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 821A127C: 91630094  stw r11, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 821A1280: 419A0010  beq cr6, 0x821a1290
	if ctx.cr[6].eq {
		sub_821A1290(ctx, base);
		return;
	}
	// 821A1284: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A1288: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A128C: 4800000C  b 0x821a1298
	sub_821A1290(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A1290 size=32
    let mut pc: u32 = 0x821A1290;
    'dispatch: loop {
        match pc {
            0x821A1290 => {
    //   block [0x821A1290..0x821A12B0)
	// 821A1290: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A1294: C00BD6D0  lfs f0, -0x2930(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10544 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1298: C1A300AC  lfs f13, 0xac(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A129C: C18300B0  lfs f12, 0xb0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A12A0: EDAD6024  fdivs f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821A12A4: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 821A12A8: D1A300A4  stfs f13, 0xa4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 821A12AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A12B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A12B0 size=1116
    let mut pc: u32 = 0x821A12B0;
    'dispatch: loop {
        match pc {
            0x821A12B0 => {
    //   block [0x821A12B0..0x821A170C)
	// 821A12B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A12B4: 48393DE1  bl 0x82535094
	ctx.lr = 0x821A12B8;
	sub_82535080(ctx, base);
	// 821A12B8: DBC1FF80  stfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[30].u64 ) };
	// 821A12BC: DBE1FF88  stfd f31, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 821A12C0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A12C4: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A12C8: D0210104  stfs f1, 0x104(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 821A12CC: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 821A12D0: 3B0B052C  addi r24, r11, 0x52c
	ctx.r[24].s64 = ctx.r[11].s64 + 1324;
	// 821A12D4: 56CA103A  slwi r10, r22, 2
	ctx.r[10].u32 = ctx.r[22].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A12D8: 397847A4  addi r11, r24, 0x47a4
	ctx.r[11].s64 = ctx.r[24].s64 + 18340;
	// 821A12DC: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 821A12E0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821A12E4: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 821A12E8: 7D134378  mr r19, r8
	ctx.r[19].u64 = ctx.r[8].u64;
	// 821A12EC: 7FCA5C2E  lfsx f30, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A12F0: 7D374B78  mr r23, r9
	ctx.r[23].u64 = ctx.r[9].u64;
	// 821A12F4: 2F160006  cmpwi cr6, r22, 6
	ctx.cr[6].compare_i32(ctx.r[22].s32, 6, &mut ctx.xer);
	// 821A12F8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 821A12FC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821A1300: 409A000C  bne cr6, 0x821a130c
	if !ctx.cr[6].eq {
	pc = 0x821A130C; continue 'dispatch;
	}
	// 821A1304: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 821A1308: 4800009C  b 0x821a13a4
	pc = 0x821A13A4; continue 'dispatch;
	// 821A130C: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 821A1310: 409A007C  bne cr6, 0x821a138c
	if !ctx.cr[6].eq {
	pc = 0x821A138C; continue 'dispatch;
	}
	// 821A1314: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A1318: 394BC448  addi r10, r11, -0x3bb8
	ctx.r[10].s64 = ctx.r[11].s64 + -15288;
	// 821A131C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1320: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1324: 419A0030  beq cr6, 0x821a1354
	if ctx.cr[6].eq {
	pc = 0x821A1354; continue 'dispatch;
	}
	// 821A1328: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A132C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1330: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A1334: 409A0020  bne cr6, 0x821a1354
	if !ctx.cr[6].eq {
	pc = 0x821A1354; continue 'dispatch;
	}
	// 821A1338: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A133C: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A1340: 409A0008  bne cr6, 0x821a1348
	if !ctx.cr[6].eq {
	pc = 0x821A1348; continue 'dispatch;
	}
	// 821A1344: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821A1348: 812B0080  lwz r9, 0x80(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A134C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821A1350: 912B0080  stw r9, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 821A1354: EB6A0000  ld r27, 0(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821A1358: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 821A135C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1364: 419A01C4  beq cr6, 0x821a1528
	if ctx.cr[6].eq {
	pc = 0x821A1528; continue 'dispatch;
	}
	// 821A1368: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A136C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1370: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A1374: 409A01B4  bne cr6, 0x821a1528
	if !ctx.cr[6].eq {
	pc = 0x821A1528; continue 'dispatch;
	}
	// 821A1378: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A137C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1380: 419A01A8  beq cr6, 0x821a1528
	if ctx.cr[6].eq {
	pc = 0x821A1528; continue 'dispatch;
	}
	// 821A1384: 3A8B0060  addi r20, r11, 0x60
	ctx.r[20].s64 = ctx.r[11].s64 + 96;
	// 821A1388: 48000008  b 0x821a1390
	pc = 0x821A1390; continue 'dispatch;
	// 821A138C: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 821A1390: 2F160004  cmpwi cr6, r22, 4
	ctx.cr[6].compare_i32(ctx.r[22].s32, 4, &mut ctx.xer);
	// 821A1394: 40980010  bge cr6, 0x821a13a4
	if !ctx.cr[6].lt {
	pc = 0x821A13A4; continue 'dispatch;
	}
	// 821A1398: 2F160002  cmpwi cr6, r22, 2
	ctx.cr[6].compare_i32(ctx.r[22].s32, 2, &mut ctx.xer);
	// 821A139C: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 821A13A0: 409A0008  bne cr6, 0x821a13a8
	if !ctx.cr[6].eq {
	pc = 0x821A13A8; continue 'dispatch;
	}
	// 821A13A4: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821A13A8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A13AC: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 821A13B0: 6175BE64  ori r21, r11, 0xbe64
	ctx.r[21].u64 = ctx.r[11].u64 | 48740;
	// 821A13B4: 419A000C  beq cr6, 0x821a13c0
	if ctx.cr[6].eq {
	pc = 0x821A13C0; continue 'dispatch;
	}
	// 821A13B8: 7D73A8AE  lbzx r11, r19, r21
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[21].u32)) } as u64;
	// 821A13BC: 48000008  b 0x821a13c4
	pc = 0x821A13C4; continue 'dispatch;
	// 821A13C0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821A13C4: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A13C8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A13CC: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821A13D0: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A13D4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A13D8: 392B0014  addi r9, r11, 0x14
	ctx.r[9].s64 = ctx.r[11].s64 + 20;
	// 821A13DC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A13E0: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821A13E4: 38EB0CE8  addi r7, r11, 0xce8
	ctx.r[7].s64 = ctx.r[11].s64 + 3304;
	// 821A13E8: 38A00380  li r5, 0x380
	ctx.r[5].s64 = 896;
	// 821A13EC: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 821A13F0: 7C8A482E  lwzx r4, r10, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A13F4: 481C909D  bl 0x8236a490
	ctx.lr = 0x821A13F8;
	sub_8236A490(ctx, base);
	// 821A13F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A13FC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A1400: 419A0128  beq cr6, 0x821a1528
	if ctx.cr[6].eq {
	pc = 0x821A1528; continue 'dispatch;
	}
	// 821A1404: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A1408: 833F0030  lwz r25, 0x30(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A140C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 821A1410: 396B0D24  addi r11, r11, 0xd24
	ctx.r[11].s64 = ctx.r[11].s64 + 3364;
	// 821A1414: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A1418: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A141C: FB9F0080  std r28, 0x80(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[28].u64 ) };
	// 821A1420: FB9F0088  std r28, 0x88(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[28].u64 ) };
	// 821A1424: FB9F00B8  std r28, 0xb8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[28].u64 ) };
	// 821A1428: 9BDF001C  stb r30, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 821A142C: C3EBBA38  lfs f31, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A1430: 92DF0090  stw r22, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[22].u32 ) };
	// 821A1434: 939F00D8  stw r28, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[28].u32 ) };
	// 821A1438: 935F0094  stw r26, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[26].u32 ) };
	// 821A143C: 40980020  bge cr6, 0x821a145c
	if !ctx.cr[6].lt {
	pc = 0x821A145C; continue 'dispatch;
	}
	// 821A1440: 397A0001  addi r11, r26, 1
	ctx.r[11].s64 = ctx.r[26].s64 + 1;
	// 821A1444: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A1448: 7D6BC050  subf r11, r11, r24
	ctx.r[11].s64 = ctx.r[24].s64 - ctx.r[11].s64;
	// 821A144C: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1450: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 821A1454: D3FF00A4  stfs f31, 0xa4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 821A1458: 48000020  b 0x821a1478
	pc = 0x821A1478; continue 'dispatch;
	// 821A145C: 7F4B07B4  extsw r11, r26
	ctx.r[11].s64 = ctx.r[26].s32 as i64;
	// 821A1460: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A1464: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A1468: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A146C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A1470: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821A1474: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 821A1478: D3DF00B4  stfs f30, 0xb4(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821A147C: FB7F00B8  std r27, 0xb8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[27].u64 ) };
	// 821A1480: 939F00D4  stw r28, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[28].u32 ) };
	// 821A1484: 397F00C0  addi r11, r31, 0xc0
	ctx.r[11].s64 = ctx.r[31].s64 + 192;
	// 821A1488: 92FF009C  stw r23, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[23].u32 ) };
	// 821A148C: 2F160002  cmpwi cr6, r22, 2
	ctx.cr[6].compare_i32(ctx.r[22].s32, 2, &mut ctx.xer);
	// 821A1490: 939F00DC  stw r28, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[28].u32 ) };
	// 821A1494: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A1498: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A149C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A14A0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A14A4: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A14A8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A14AC: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A14B0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821A14B4: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A14B8: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821A14BC: 409A00DC  bne cr6, 0x821a1598
	if !ctx.cr[6].eq {
	pc = 0x821A1598; continue 'dispatch;
	}
	// 821A14C0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A14C4: 38C00007  li r6, 7
	ctx.r[6].s64 = 7;
	// 821A14C8: 38EB0CF0  addi r7, r11, 0xcf0
	ctx.r[7].s64 = ctx.r[11].s64 + 3312;
	// 821A14CC: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 821A14D0: 481C8FC1  bl 0x8236a490
	ctx.lr = 0x821A14D4;
	sub_8236A490(ctx, base);
	// 821A14D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A14D8: 419A000C  beq cr6, 0x821a14e4
	if ctx.cr[6].eq {
	pc = 0x821A14E4; continue 'dispatch;
	}
	// 821A14DC: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A14E0: 48000008  b 0x821a14e8
	pc = 0x821A14E8; continue 'dispatch;
	// 821A14E4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821A14E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A14EC: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 821A14F0: 907F008C  stw r3, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 821A14F4: 419A0010  beq cr6, 0x821a1504
	if ctx.cr[6].eq {
	pc = 0x821A1504; continue 'dispatch;
	}
	// 821A14F8: 4BFFFB79  bl 0x821a1070
	ctx.lr = 0x821A14FC;
	sub_821A1070(ctx, base);
	// 821A14FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A1500: 409A003C  bne cr6, 0x821a153c
	if !ctx.cr[6].eq {
	pc = 0x821A153C; continue 'dispatch;
	}
	// 821A1504: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A1508: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 821A150C: 409A001C  bne cr6, 0x821a1528
	if !ctx.cr[6].eq {
	pc = 0x821A1528; continue 'dispatch;
	}
	// 821A1510: A17F0014  lhz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A1514: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A1518: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 821A151C: 995F0019  stb r10, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A1520: 9BDF0025  stb r30, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[30].u8 ) };
	// 821A1524: B17F0014  sth r11, 0x14(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 821A1528: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A152C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821A1530: CBC1FF80  lfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 821A1534: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 821A1538: 48393BAC  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
	// 821A153C: 39630080  addi r11, r3, 0x80
	ctx.r[11].s64 = ctx.r[3].s64 + 128;
	// 821A1540: 811D0000  lwz r8, 0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1544: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1548: 394B0070  addi r10, r11, 0x70
	ctx.r[10].s64 = ctx.r[11].s64 + 112;
	// 821A154C: 392B0080  addi r9, r11, 0x80
	ctx.r[9].s64 = ctx.r[11].s64 + 128;
	// 821A1550: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 821A1554: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A1558: 811D0004  lwz r8, 4(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A155C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821A1560: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A1564: 910A0008  stw r8, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821A1568: 811D000C  lwz r8, 0xc(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A156C: 910A000C  stw r8, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 821A1570: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1574: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A1578: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A157C: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A1580: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A1584: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821A1588: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A158C: D3EB0090  stfs f31, 0x90(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821A1590: 9149000C  stw r10, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821A1594: 48000074  b 0x821a1608
	pc = 0x821A1608; continue 'dispatch;
	// 821A1598: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A159C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A15A0: 38EB0CF8  addi r7, r11, 0xcf8
	ctx.r[7].s64 = ctx.r[11].s64 + 3320;
	// 821A15A4: 38600130  li r3, 0x130
	ctx.r[3].s64 = 304;
	// 821A15A8: 481C8EE9  bl 0x8236a490
	ctx.lr = 0x821A15AC;
	sub_8236A490(ctx, base);
	// 821A15AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A15B0: 419A000C  beq cr6, 0x821a15bc
	if ctx.cr[6].eq {
	pc = 0x821A15BC; continue 'dispatch;
	}
	// 821A15B4: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A15B8: 48000008  b 0x821a15c0
	pc = 0x821A15C0; continue 'dispatch;
	// 821A15BC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821A15C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A15C4: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821A15C8: 907F0084  stw r3, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 821A15CC: 419AFF38  beq cr6, 0x821a1504
	if ctx.cr[6].eq {
	pc = 0x821A1504; continue 'dispatch;
	}
	// 821A15D0: 4BFFF9F1  bl 0x821a0fc0
	ctx.lr = 0x821A15D4;
	sub_821A0FC0(ctx, base);
	// 821A15D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A15D8: 419AFF2C  beq cr6, 0x821a1504
	if ctx.cr[6].eq {
	pc = 0x821A1504; continue 'dispatch;
	}
	// 821A15DC: 38630080  addi r3, r3, 0x80
	ctx.r[3].s64 = ctx.r[3].s64 + 128;
	// 821A15E0: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A15E4: 39630090  addi r11, r3, 0x90
	ctx.r[11].s64 = ctx.r[3].s64 + 144;
	// 821A15E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821A15EC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A15F0: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A15F4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A15F8: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A15FC: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821A1600: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A1604: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821A1608: 3960EFEC  li r11, -0x1014
	ctx.r[11].s64 = -4116;
	// 821A160C: 9BDC0021  stb r30, 0x21(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(33 as u32), ctx.r[30].u8 ) };
	// 821A1610: 2F160006  cmpwi cr6, r22, 6
	ctx.cr[6].compare_i32(ctx.r[22].s32, 6, &mut ctx.xer);
	// 821A1614: 9BDC0027  stb r30, 0x27(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(39 as u32), ctx.r[30].u8 ) };
	// 821A1618: 9BDC001F  stb r30, 0x1f(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(31 as u32), ctx.r[30].u8 ) };
	// 821A161C: B17C0022  sth r11, 0x22(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(34 as u32), ctx.r[11].u16 ) };
	// 821A1620: 409A0010  bne cr6, 0x821a1630
	if !ctx.cr[6].eq {
	pc = 0x821A1630; continue 'dispatch;
	}
	// 821A1624: 38A00007  li r5, 7
	ctx.r[5].s64 = 7;
	// 821A1628: 3BC00007  li r30, 7
	ctx.r[30].s64 = 7;
	// 821A162C: 480000AC  b 0x821a16d8
	pc = 0x821A16D8; continue 'dispatch;
	// 821A1630: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A1634: 2F160005  cmpwi cr6, r22, 5
	ctx.cr[6].compare_i32(ctx.r[22].s32, 5, &mut ctx.xer);
	// 821A1638: C02BBFFC  lfs f1, -0x4004(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A163C: 409A0018  bne cr6, 0x821a1654
	if !ctx.cr[6].eq {
	pc = 0x821A1654; continue 'dispatch;
	}
	// 821A1640: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A1644: 814BB9E4  lwz r10, -0x461c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17948 as u32) ) } as u64;
	// 821A1648: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A164C: 914BB9E4  stw r10, -0x461c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-17948 as u32), ctx.r[10].u32 ) };
	// 821A1650: 4800001C  b 0x821a166c
	pc = 0x821A166C; continue 'dispatch;
	// 821A1654: 2F160004  cmpwi cr6, r22, 4
	ctx.cr[6].compare_i32(ctx.r[22].s32, 4, &mut ctx.xer);
	// 821A1658: 419A0014  beq cr6, 0x821a166c
	if ctx.cr[6].eq {
	pc = 0x821A166C; continue 'dispatch;
	}
	// 821A165C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A1660: 2F160002  cmpwi cr6, r22, 2
	ctx.cr[6].compare_i32(ctx.r[22].s32, 2, &mut ctx.xer);
	// 821A1664: C02B2C40  lfs f1, 0x2c40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11328 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A1668: 419A0050  beq cr6, 0x821a16b8
	if ctx.cr[6].eq {
	pc = 0x821A16B8; continue 'dispatch;
	}
	// 821A166C: D3C3007C  stfs f30, 0x7c(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 821A1670: E9540000  ld r10, 0(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) };
	// 821A1674: 39630080  addi r11, r3, 0x80
	ctx.r[11].s64 = ctx.r[3].s64 + 128;
	// 821A1678: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 821A167C: E9540008  ld r10, 8(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) };
	// 821A1680: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821A1684: 481E1405  bl 0x82382a88
	ctx.lr = 0x821A1688;
	sub_82382A88(ctx, base);
	// 821A1688: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 821A168C: 419A0024  beq cr6, 0x821a16b0
	if ctx.cr[6].eq {
	pc = 0x821A16B0; continue 'dispatch;
	}
	// 821A1690: 2F160003  cmpwi cr6, r22, 3
	ctx.cr[6].compare_i32(ctx.r[22].s32, 3, &mut ctx.xer);
	// 821A1694: 409A001C  bne cr6, 0x821a16b0
	if !ctx.cr[6].eq {
	pc = 0x821A16B0; continue 'dispatch;
	}
	// 821A1698: 7D73A8AE  lbzx r11, r19, r21
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[21].u32)) } as u64;
	// 821A169C: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 821A16A0: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821A16A4: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A16A8: 3BCB0003  addi r30, r11, 3
	ctx.r[30].s64 = ctx.r[11].s64 + 3;
	// 821A16AC: 48000028  b 0x821a16d4
	pc = 0x821A16D4; continue 'dispatch;
	// 821A16B0: 3BC00007  li r30, 7
	ctx.r[30].s64 = 7;
	// 821A16B4: 48000020  b 0x821a16d4
	pc = 0x821A16D4; continue 'dispatch;
	// 821A16B8: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 821A16BC: 419A0018  beq cr6, 0x821a16d4
	if ctx.cr[6].eq {
	pc = 0x821A16D4; continue 'dispatch;
	}
	// 821A16C0: 7D73A8AE  lbzx r11, r19, r21
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[21].u32)) } as u64;
	// 821A16C4: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 821A16C8: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821A16CC: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A16D0: 3BCB0002  addi r30, r11, 2
	ctx.r[30].s64 = ctx.r[11].s64 + 2;
	// 821A16D4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821A16D8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A16DC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A16E0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821A16E4: 386B4A00  addi r3, r11, 0x4a00
	ctx.r[3].s64 = ctx.r[11].s64 + 18944;
	// 821A16E8: 481DCAE1  bl 0x8237e1c8
	ctx.lr = 0x821A16EC;
	sub_8237E1C8(ctx, base);
	// 821A16EC: 907F0098  stw r3, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[3].u32 ) };
	// 821A16F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A16F4: 93DF00A0  stw r30, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 821A16F8: 927F00D0  stw r19, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[19].u32 ) };
	// 821A16FC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821A1700: CBC1FF80  lfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 821A1704: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 821A1708: 483939DC  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A1710 size=672
    let mut pc: u32 = 0x821A1710;
    'dispatch: loop {
        match pc {
            0x821A1710 => {
    //   block [0x821A1710..0x821A19B0)
	// 821A1710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A1714: 483939A9  bl 0x825350bc
	ctx.lr = 0x821A1718;
	sub_82535080(ctx, base);
	// 821A1718: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A171C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A1720: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A1724: 81640040  lwz r11, 0x40(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A1728: 93E40040  stw r31, 0x40(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(64 as u32), ctx.r[31].u32 ) };
	// 821A172C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A1730: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A1734: 419A0274  beq cr6, 0x821a19a8
	if ctx.cr[6].eq {
	pc = 0x821A19A8; continue 'dispatch;
	}
	// 821A1738: 81640098  lwz r11, 0x98(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A173C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1740: 419A0248  beq cr6, 0x821a1988
	if ctx.cr[6].eq {
	pc = 0x821A1988; continue 'dispatch;
	}
	// 821A1744: 83A40090  lwz r29, 0x90(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A1748: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 821A174C: 409A0034  bne cr6, 0x821a1780
	if !ctx.cr[6].eq {
	pc = 0x821A1780; continue 'dispatch;
	}
	// 821A1750: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A1754: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1758: 419A0250  beq cr6, 0x821a19a8
	if ctx.cr[6].eq {
	pc = 0x821A19A8; continue 'dispatch;
	}
	// 821A175C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A1760: 81240088  lwz r9, 0x88(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(136 as u32) ) } as u64;
	// 821A1764: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A1768: 409A0240  bne cr6, 0x821a19a8
	if !ctx.cr[6].eq {
	pc = 0x821A19A8; continue 'dispatch;
	}
	// 821A176C: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A1770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1774: 419A0234  beq cr6, 0x821a19a8
	if ctx.cr[6].eq {
	pc = 0x821A19A8; continue 'dispatch;
	}
	// 821A1778: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A177C: 48000030  b 0x821a17ac
	pc = 0x821A17AC; continue 'dispatch;
	// 821A1780: 81640084  lwz r11, 0x84(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A1784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1788: 419A0220  beq cr6, 0x821a19a8
	if ctx.cr[6].eq {
	pc = 0x821A19A8; continue 'dispatch;
	}
	// 821A178C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A1790: 81240080  lwz r9, 0x80(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A1794: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A1798: 409A0210  bne cr6, 0x821a19a8
	if !ctx.cr[6].eq {
	pc = 0x821A19A8; continue 'dispatch;
	}
	// 821A179C: 3BEB0080  addi r31, r11, 0x80
	ctx.r[31].s64 = ctx.r[11].s64 + 128;
	// 821A17A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A17A4: 419A0204  beq cr6, 0x821a19a8
	if ctx.cr[6].eq {
	pc = 0x821A19A8; continue 'dispatch;
	}
	// 821A17A8: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 821A17AC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A17B0: 419A01F8  beq cr6, 0x821a19a8
	if ctx.cr[6].eq {
	pc = 0x821A19A8; continue 'dispatch;
	}
	// 821A17B4: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 821A17B8: 419A0050  beq cr6, 0x821a1808
	if ctx.cr[6].eq {
	pc = 0x821A1808; continue 'dispatch;
	}
	// 821A17BC: 816400BC  lwz r11, 0xbc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(188 as u32) ) } as u64;
	// 821A17C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A17C4: 419A0044  beq cr6, 0x821a1808
	if ctx.cr[6].eq {
	pc = 0x821A1808; continue 'dispatch;
	}
	// 821A17C8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A17CC: 812400B8  lwz r9, 0xb8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(184 as u32) ) } as u64;
	// 821A17D0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A17D4: 409A0034  bne cr6, 0x821a1808
	if !ctx.cr[6].eq {
	pc = 0x821A1808; continue 'dispatch;
	}
	// 821A17D8: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A17DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A17E0: 419A0028  beq cr6, 0x821a1808
	if ctx.cr[6].eq {
	pc = 0x821A1808; continue 'dispatch;
	}
	// 821A17E4: 814B0084  lwz r10, 0x84(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A17E8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A17EC: 419A001C  beq cr6, 0x821a1808
	if ctx.cr[6].eq {
	pc = 0x821A1808; continue 'dispatch;
	}
	// 821A17F0: C00B0060  lfs f0, 0x60(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A17F4: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821A17F8: C00B0064  lfs f0, 0x64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A17FC: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821A1800: C00B0068  lfs f0, 0x68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1804: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821A1808: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A180C: 2F1D0006  cmpwi cr6, r29, 6
	ctx.cr[6].compare_i32(ctx.r[29].s32, 6, &mut ctx.xer);
	// 821A1810: C18B1FF8  lfs f12, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A1814: 409A0068  bne cr6, 0x821a187c
	if !ctx.cr[6].eq {
	pc = 0x821A187C; continue 'dispatch;
	}
	// 821A1818: 481C5921  bl 0x82367138
	ctx.lr = 0x821A181C;
	sub_82367138(ctx, base);
	// 821A181C: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A1820: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A1824: C17F0090  lfs f11, 0x90(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A1828: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821A182C: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1830: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A1834: C04B20D8  lfs f2, 0x20d8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8408 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A1838: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A183C: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A1840: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821A1844: FD406818  frsp f10, f13
	ctx.f[10].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A1848: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A184C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A1850: EDAA683A  fmadds f13, f10, f0, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 821A1854: C00BD760  lfs f0, -0x28a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1858: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A185C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A1860: C00B2054  lfs f0, 0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1864: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A1868: EC020024  fdivs f0, f2, f0
	ctx.f[0].f64 = ((ctx.f[2].f64 / ctx.f[0].f64) as f32) as f64;
	// 821A186C: EC2B002A  fadds f1, f11, f0
	ctx.f[1].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 821A1870: 481C62D1  bl 0x82367b40
	ctx.lr = 0x821A1874;
	sub_82367B40(ctx, base);
	// 821A1874: D03F0090  stfs f1, 0x90(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821A1878: 48000080  b 0x821a18f8
	pc = 0x821A18F8; continue 'dispatch;
	// 821A187C: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 821A1880: 409A002C  bne cr6, 0x821a18ac
	if !ctx.cr[6].eq {
	pc = 0x821A18AC; continue 'dispatch;
	}
	// 821A1884: 816400D8  lwz r11, 0xd8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A1888: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A188C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1890: 419A004C  beq cr6, 0x821a18dc
	if ctx.cr[6].eq {
	pc = 0x821A18DC; continue 'dispatch;
	}
	// 821A1894: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A1898: D19F0094  stfs f12, 0x94(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821A189C: C1A400C8  lfs f13, 0xc8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A18A0: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A18A4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A18A8: 48000040  b 0x821a18e8
	pc = 0x821A18E8; continue 'dispatch;
	// 821A18AC: 2F1D0005  cmpwi cr6, r29, 5
	ctx.cr[6].compare_i32(ctx.r[29].s32, 5, &mut ctx.xer);
	// 821A18B0: 409A0048  bne cr6, 0x821a18f8
	if !ctx.cr[6].eq {
	pc = 0x821A18F8; continue 'dispatch;
	}
	// 821A18B4: 816400D8  lwz r11, 0xd8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A18B8: 556B077A  rlwinm r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A18BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A18C0: 419A001C  beq cr6, 0x821a18dc
	if ctx.cr[6].eq {
	pc = 0x821A18DC; continue 'dispatch;
	}
	// 821A18C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A18C8: D19F0094  stfs f12, 0x94(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821A18CC: C1A400C8  lfs f13, 0xc8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A18D0: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A18D4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A18D8: 48000010  b 0x821a18e8
	pc = 0x821A18E8; continue 'dispatch;
	// 821A18DC: C00400C4  lfs f0, 0xc4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A18E0: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821A18E4: C00400C8  lfs f0, 0xc8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A18E8: D01F0098  stfs f0, 0x98(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 821A18EC: 816400D8  lwz r11, 0xd8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A18F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A18F4: 916400D8  stw r11, 0xd8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 821A18F8: 81640094  lwz r11, 0x94(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A18FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A1900: 40980038  bge cr6, 0x821a1938
	if !ctx.cr[6].lt {
	pc = 0x821A1938; continue 'dispatch;
	}
	// 821A1904: C00400A4  lfs f0, 0xa4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1908: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 821A190C: 409A0008  bne cr6, 0x821a1914
	if !ctx.cr[6].eq {
	pc = 0x821A1914; continue 'dispatch;
	}
	// 821A1910: D01E0110  stfs f0, 0x110(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 821A1914: C1A400A8  lfs f13, 0xa8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(168 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A1918: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A191C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A1920: C1AB2238  lfs f13, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A1924: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821A1928: 40990060  ble cr6, 0x821a1988
	if !ctx.cr[6].gt {
	pc = 0x821A1988; continue 'dispatch;
	}
	// 821A192C: D00400A4  stfs f0, 0xa4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 821A1930: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A1934: 483937D8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
	// 821A1938: 81640090  lwz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A193C: C1A400AC  lfs f13, 0xac(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A1940: C00400B0  lfs f0, 0xb0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1944: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821A1948: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 821A194C: 419A0014  beq cr6, 0x821a1960
	if ctx.cr[6].eq {
	pc = 0x821A1960; continue 'dispatch;
	}
	// 821A1950: C16400B4  lfs f11, 0xb4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(180 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A1954: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A1958: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 821A195C: 48000008  b 0x821a1964
	pc = 0x821A1964; continue 'dispatch;
	// 821A1960: D01E0110  stfs f0, 0x110(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 821A1964: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A1968: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A196C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A1970: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 821A1974: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1978: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821A197C: D00400AC  stfs f0, 0xac(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 821A1980: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 821A1984: 41990024  bgt cr6, 0x821a19a8
	if ctx.cr[6].gt {
	pc = 0x821A19A8; continue 'dispatch;
	}
	// 821A1988: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A198C: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A1990: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821A1994: 409A0014  bne cr6, 0x821a19a8
	if !ctx.cr[6].eq {
	pc = 0x821A19A8; continue 'dispatch;
	}
	// 821A1998: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821A199C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A19A0: 99640019  stb r11, 0x19(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 821A19A4: 99440025  stb r10, 0x25(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 821A19A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A19AC: 48393760  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A19B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A19B0 size=412
    let mut pc: u32 = 0x821A19B0;
    'dispatch: loop {
        match pc {
            0x821A19B0 => {
    //   block [0x821A19B0..0x821A1B4C)
	// 821A19B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A19B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A19B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A19BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A19C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A19C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A19C8: 817F00BC  lwz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 821A19CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A19D0: 419A0048  beq cr6, 0x821a1a18
	if ctx.cr[6].eq {
	pc = 0x821A1A18; continue 'dispatch;
	}
	// 821A19D4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A19D8: 813F00B8  lwz r9, 0xb8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 821A19DC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A19E0: 409A0038  bne cr6, 0x821a1a18
	if !ctx.cr[6].eq {
	pc = 0x821A1A18; continue 'dispatch;
	}
	// 821A19E4: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A19E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A19EC: 419A002C  beq cr6, 0x821a1a18
	if ctx.cr[6].eq {
	pc = 0x821A1A18; continue 'dispatch;
	}
	// 821A19F0: 814B0094  lwz r10, 0x94(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A19F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A19F8: 419A0020  beq cr6, 0x821a1a18
	if ctx.cr[6].eq {
	pc = 0x821A1A18; continue 'dispatch;
	}
	// 821A19FC: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A1A00: 812B0090  lwz r9, 0x90(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A1A04: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A1A08: 409A0010  bne cr6, 0x821a1a18
	if !ctx.cr[6].eq {
	pc = 0x821A1A18; continue 'dispatch;
	}
	// 821A1A0C: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A1A10: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A1A14: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821A1A18: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 821A1A1C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821A1A20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1A24: 419A0074  beq cr6, 0x821a1a98
	if ctx.cr[6].eq {
	pc = 0x821A1A98; continue 'dispatch;
	}
	// 821A1A28: 811F00D0  lwz r8, 0xd0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A1A2C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821A1A30: 419A0068  beq cr6, 0x821a1a98
	if ctx.cr[6].eq {
	pc = 0x821A1A98; continue 'dispatch;
	}
	// 821A1A34: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A1A38: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821A1A3C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A1A40: 409A0030  bne cr6, 0x821a1a70
	if !ctx.cr[6].eq {
	pc = 0x821A1A70; continue 'dispatch;
	}
	// 821A1A44: 6167BE64  ori r7, r11, 0xbe64
	ctx.r[7].u64 = ctx.r[11].u64 | 48740;
	// 821A1A48: 813F00DC  lwz r9, 0xdc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 821A1A4C: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821A1A50: 396B1490  addi r11, r11, 0x1490
	ctx.r[11].s64 = ctx.r[11].s64 + 5264;
	// 821A1A54: 394BFF80  addi r10, r11, -0x80
	ctx.r[10].s64 = ctx.r[11].s64 + -128;
	// 821A1A58: 7D6838AE  lbzx r11, r8, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821A1A5C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821A1A60: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821A1A64: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A1A68: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A1A6C: 4800001C  b 0x821a1a88
	pc = 0x821A1A88; continue 'dispatch;
	// 821A1A70: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 821A1A74: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821A1A78: 396B1490  addi r11, r11, 0x1490
	ctx.r[11].s64 = ctx.r[11].s64 + 5264;
	// 821A1A7C: 7D4850AE  lbzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821A1A80: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 821A1A84: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A1A88: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1A8C: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821A1A90: 409A0008  bne cr6, 0x821a1a98
	if !ctx.cr[6].eq {
	pc = 0x821A1A98; continue 'dispatch;
	}
	// 821A1A94: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821A1A98: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A1A9C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821A1AA0: 409A0018  bne cr6, 0x821a1ab8
	if !ctx.cr[6].eq {
	pc = 0x821A1AB8; continue 'dispatch;
	}
	// 821A1AA4: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A1AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1AAC: 419A0050  beq cr6, 0x821a1afc
	if ctx.cr[6].eq {
	pc = 0x821A1AFC; continue 'dispatch;
	}
	// 821A1AB0: 813F0088  lwz r9, 0x88(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 821A1AB4: 48000014  b 0x821a1ac8
	pc = 0x821A1AC8; continue 'dispatch;
	// 821A1AB8: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A1ABC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1AC0: 419A003C  beq cr6, 0x821a1afc
	if ctx.cr[6].eq {
	pc = 0x821A1AFC; continue 'dispatch;
	}
	// 821A1AC4: 813F0080  lwz r9, 0x80(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A1AC8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A1ACC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A1AD0: 409A002C  bne cr6, 0x821a1afc
	if !ctx.cr[6].eq {
	pc = 0x821A1AFC; continue 'dispatch;
	}
	// 821A1AD4: 388B0080  addi r4, r11, 0x80
	ctx.r[4].s64 = ctx.r[11].s64 + 128;
	// 821A1AD8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A1ADC: 419A0020  beq cr6, 0x821a1afc
	if ctx.cr[6].eq {
	pc = 0x821A1AFC; continue 'dispatch;
	}
	// 821A1AE0: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A1AE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1AE8: 419A0014  beq cr6, 0x821a1afc
	if ctx.cr[6].eq {
	pc = 0x821A1AFC; continue 'dispatch;
	}
	// 821A1AEC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A1AF0: 80BF00A0  lwz r5, 0xa0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A1AF4: 386B4A00  addi r3, r11, 0x4a00
	ctx.r[3].s64 = ctx.r[11].s64 + 18944;
	// 821A1AF8: 481DC929  bl 0x8237e420
	ctx.lr = 0x821A1AFC;
	sub_8237E420(ctx, base);
	// 821A1AFC: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A1B00: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821A1B04: 409A0014  bne cr6, 0x821a1b18
	if !ctx.cr[6].eq {
	pc = 0x821A1B18; continue 'dispatch;
	}
	// 821A1B08: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A1B0C: 814BB9E4  lwz r10, -0x461c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17948 as u32) ) } as u64;
	// 821A1B10: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A1B14: 914BB9E4  stw r10, -0x461c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-17948 as u32), ctx.r[10].u32 ) };
	// 821A1B18: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A1B1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1B20: 419A0014  beq cr6, 0x821a1b34
	if ctx.cr[6].eq {
	pc = 0x821A1B34; continue 'dispatch;
	}
	// 821A1B24: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1B28: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821A1B2C: 409A0008  bne cr6, 0x821a1b34
	if !ctx.cr[6].eq {
	pc = 0x821A1B34; continue 'dispatch;
	}
	// 821A1B30: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821A1B34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A1B38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A1B3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A1B40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A1B44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A1B48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A1B50 size=20
    let mut pc: u32 = 0x821A1B50;
    'dispatch: loop {
        match pc {
            0x821A1B50 => {
    //   block [0x821A1B50..0x821A1B64)
	// 821A1B50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A1B54: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821A1B58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A1B5C: 409A0008  bne cr6, 0x821a1b64
	if !ctx.cr[6].eq {
		sub_821A1B64(ctx, base);
		return;
	}
	// 821A1B60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1B64(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A1B64 size=76
    let mut pc: u32 = 0x821A1B64;
    'dispatch: loop {
        match pc {
            0x821A1B64 => {
    //   block [0x821A1B64..0x821A1BB0)
	// 821A1B64: 3943180B  addi r10, r3, 0x180b
	ctx.r[10].s64 = ctx.r[3].s64 + 6155;
	// 821A1B68: 3CA00020  lis r5, 0x20
	ctx.r[5].s64 = 2097152;
	// 821A1B6C: 55490028  rlwinm r9, r10, 0, 0, 0x14
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821A1B70: 7CC32A14  add r6, r3, r5
	ctx.r[6].u64 = ctx.r[3].u64 + ctx.r[5].u64;
	// 821A1B74: 7D092A14  add r8, r9, r5
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[5].u64;
	// 821A1B78: 39400400  li r10, 0x400
	ctx.r[10].s64 = 1024;
	// 821A1B7C: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A1B80: 41980030  blt cr6, 0x821a1bb0
	if ctx.cr[6].lt {
		sub_821A1BB0(ctx, base);
		return;
	}
	// 821A1B84: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 821A1B88: 3903180B  addi r8, r3, 0x180b
	ctx.r[8].s64 = ctx.r[3].s64 + 6155;
	// 821A1B8C: 3908FFFC  addi r8, r8, -4
	ctx.r[8].s64 = ctx.r[8].s64 + -4;
	// 821A1B90: 38E7F800  addi r7, r7, -0x800
	ctx.r[7].s64 = ctx.r[7].s64 + -2048;
	// 821A1B94: 55090028  rlwinm r9, r8, 0, 0, 0x14
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821A1B98: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A1B9C: 7C874A14  add r4, r7, r9
	ctx.r[4].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821A1BA0: 7F043040  cmplw cr6, r4, r6
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A1BA4: 4098FFE8  bge cr6, 0x821a1b8c
	if !ctx.cr[6].lt {
	pc = 0x821A1B8C; continue 'dispatch;
	}
	// 821A1BA8: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821A1BAC: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A1BB0 size=100
    let mut pc: u32 = 0x821A1BB0;
    'dispatch: loop {
        match pc {
            0x821A1BB0 => {
    //   block [0x821A1BB0..0x821A1C14)
	// 821A1BB0: 38E00800  li r7, 0x800
	ctx.r[7].s64 = 2048;
	// 821A1BB4: 914B0028  stw r10, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 821A1BB8: 38C3000C  addi r6, r3, 0xc
	ctx.r[6].s64 = ctx.r[3].s64 + 12;
	// 821A1BBC: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 821A1BC0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A1BC4: 912B0024  stw r9, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 821A1BC8: 906B0020  stw r3, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 821A1BCC: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 821A1BD0: 90EB000C  stw r7, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 821A1BD4: 90CB002C  stw r6, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[6].u32 ) };
	// 821A1BD8: 3CC07379  lis r6, 0x7379
	ctx.r[6].s64 = 1937309696;
	// 821A1BDC: 90EB0008  stw r7, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821A1BE0: 3CE0656D  lis r7, 0x656d
	ctx.r[7].s64 = 1701642240;
	// 821A1BE4: 60C6736D  ori r6, r6, 0x736d
	ctx.r[6].u64 = ctx.r[6].u64 | 29549;
	// 821A1BE8: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A1BEC: 60E75F6F  ori r7, r7, 0x5f6f
	ctx.r[7].u64 = ctx.r[7].u64 | 24431;
	// 821A1BF0: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821A1BF4: 90C30004  stw r6, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821A1BF8: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821A1BFC: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A1C00: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A1C04: 910B0018  stw r8, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 821A1C08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A1C0C: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 821A1C10: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1C14(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A1C14 size=24
    let mut pc: u32 = 0x821A1C14;
    'dispatch: loop {
        match pc {
            0x821A1C14 => {
    //   block [0x821A1C14..0x821A1C2C)
	// 821A1C14: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821A1C18: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A1C1C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A1C20: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821A1C24: 4200FFF8  bdnz 0x821a1c1c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821A1C1C; continue 'dispatch;
	}
	// 821A1C28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A1C30 size=1100
    let mut pc: u32 = 0x821A1C30;
    'dispatch: loop {
        match pc {
            0x821A1C30 => {
    //   block [0x821A1C30..0x821A1E4C)
	// 821A1C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A1C34: 4839347D  bl 0x825350b0
	ctx.lr = 0x821A1C38;
	sub_82535080(ctx, base);
	// 821A1C38: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A1C3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A1C40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A1C44: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821A1C48: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821A1C4C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 821A1C50: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A1C54: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 821A1C58: 409A0010  bne cr6, 0x821a1c68
	if !ctx.cr[6].eq {
	pc = 0x821A1C68; continue 'dispatch;
	}
	// 821A1C5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A1C60: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A1C64: 4839349C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
	// 821A1C68: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A1C6C: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A1C70: 4199FFEC  bgt cr6, 0x821a1c5c
	if ctx.cr[6].gt {
	pc = 0x821A1C5C; continue 'dispatch;
	}
	// 821A1C74: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A1C78: 3946FFFF  addi r10, r6, -1
	ctx.r[10].s64 = ctx.r[6].s64 + -1;
	// 821A1C7C: 811F0018  lwz r8, 0x18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A1C80: 80FF0024  lwz r7, 0x24(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A1C84: 7D2B41D6  mullw r9, r11, r8
	ctx.r[9].s64 = (ctx.r[11].s32 as i64) * (ctx.r[8].s32 as i64);
	// 821A1C88: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 821A1C8C: 7CE95214  add r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821A1C90: 7CFE5078  andc r30, r7, r10
	ctx.r[30].u64 = ctx.r[7].u64 & !ctx.r[10].u64;
	// 821A1C94: 7D49F050  subf r10, r9, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[9].s64;
	// 821A1C98: 7FAA2214  add r29, r10, r4
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 821A1C9C: 7D5D5B96  divwu r10, r29, r11
	ctx.r[10].u32 = ctx.r[29].u32 / ctx.r[11].u32;
	// 821A1CA0: 7D3D5B96  divwu r9, r29, r11
	ctx.r[9].u32 = ctx.r[29].u32 / ctx.r[11].u32;
	// 821A1CA4: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 821A1CA8: 7D6BE851  subf. r11, r11, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A1CAC: 41820008  beq 0x821a1cb4
	if ctx.cr[0].eq {
	pc = 0x821A1CB4; continue 'dispatch;
	}
	// 821A1CB0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821A1CB4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A1CB8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A1CBC: 409901EC  ble cr6, 0x821a1ea8
	if !ctx.cr[6].gt {
	pc = 0x821A1EA8; continue 'dispatch;
	}
	// 821A1CC0: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 821A1CC4: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821A1CC8: 3BCB0C40  addi r30, r11, 0xc40
	ctx.r[30].s64 = ctx.r[11].s64 + 3136;
	// 821A1CCC: 817E0688  lwz r11, 0x688(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1672 as u32) ) } as u64;
	// 821A1CD0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A1CD4: 419A0054  beq cr6, 0x821a1d28
	if ctx.cr[6].eq {
	pc = 0x821A1D28; continue 'dispatch;
	}
	// 821A1CD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1CDC: 556B0000  rlwinm r11, r11, 0, 0, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A1CE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1CE4: 409A0044  bne cr6, 0x821a1d28
	if !ctx.cr[6].eq {
	pc = 0x821A1D28; continue 'dispatch;
	}
	// 821A1CE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A1CEC: 4800051D  bl 0x821a2208
	ctx.lr = 0x821A1CF0;
	sub_821A2208(ctx, base);
	// 821A1CF0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1CF4: 817E0688  lwz r11, 0x688(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1672 as u32) ) } as u64;
	// 821A1CF8: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821A1CFC: 654A8000  oris r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 2147483648;
	// 821A1D00: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821A1D04: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821A1D08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A1D0C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821A1D10: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A1D14: 4BFFFF1D  bl 0x821a1c30
	ctx.lr = 0x821A1D18;
	sub_821A1C30(ctx, base);
	// 821A1D18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1D1C: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 821A1D20: 6D6B8000  xoris r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 ^ 2147483648;
	// 821A1D24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A1D28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A1D2C: 907C0000  stw r3, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821A1D30: 419A0344  beq cr6, 0x821a2074
	if ctx.cr[6].eq {
	pc = 0x821A2074; continue 'dispatch;
	}
	// 821A1D34: 2B1D0100  cmplwi cr6, r29, 0x100
	ctx.cr[6].compare_u32(ctx.r[29].u32, 256 as u32, &mut ctx.xer);
	// 821A1D38: 40980010  bge cr6, 0x821a1d48
	if !ctx.cr[6].lt {
	pc = 0x821A1D48; continue 'dispatch;
	}
	// 821A1D3C: 7C001A2C  dcbt 0, r3
	// 821A1D40: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A1D44: 483933BC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
	// 821A1D48: 3D600004  lis r11, 4
	ctx.r[11].s64 = 262144;
	// 821A1D4C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A1D50: 41980008  blt cr6, 0x821a1d58
	if ctx.cr[6].lt {
	pc = 0x821A1D58; continue 'dispatch;
	}
	// 821A1D54: 3FA00004  lis r29, 4
	ctx.r[29].s64 = 262144;
	// 821A1D58: 3963007F  addi r11, r3, 0x7f
	ctx.r[11].s64 = ctx.r[3].s64 + 127;
	// 821A1D5C: 7D5D1A14  add r10, r29, r3
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[3].u64;
	// 821A1D60: 55690030  rlwinm r9, r11, 0, 0, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A1D64: 554B0030  rlwinm r11, r10, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821A1D68: 7F091840  cmplw cr6, r9, r3
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821A1D6C: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A1D70: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A1D74: 419A0008  beq cr6, 0x821a1d7c
	if ctx.cr[6].eq {
	pc = 0x821A1D7C; continue 'dispatch;
	}
	// 821A1D78: 7C001A2C  dcbt 0, r3
	// 821A1D7C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821A1D80: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 821A1D84: 41980084  blt cr6, 0x821a1e08
	if ctx.cr[6].lt {
	pc = 0x821A1E08; continue 'dispatch;
	}
	// 821A1D88: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 821A1D8C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1D90: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1D94: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 821A1D98: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1D9C: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 821A1DA0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1DA4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1DA8: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 821A1DAC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1DB0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1DB4: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 821A1DB8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1DBC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1DC0: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 821A1DC4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1DC8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1DCC: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 821A1DD0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1DD4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1DD8: 3940FC00  li r10, -0x400
	ctx.r[10].s64 = -1024;
	// 821A1DDC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1DE0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1DE4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821A1DE8: 394BFC00  addi r10, r11, -0x400
	ctx.r[10].s64 = ctx.r[11].s64 + -1024;
	// 821A1DEC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1DF0: 396BFC00  addi r11, r11, -0x400
	ctx.r[11].s64 = ctx.r[11].s64 + -1024;
	// 821A1DF4: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 821A1DF8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A1DFC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821A1E00: 4098FF88  bge cr6, 0x821a1d88
	if !ctx.cr[6].lt {
	pc = 0x821A1D88; continue 'dispatch;
	}
	// 821A1E04: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A1E08: 554ACF7E  rlwinm r10, r10, 0x19, 0x1d, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 821A1E0C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A1E10: 2B0A0006  cmplwi cr6, r10, 6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 6 as u32, &mut ctx.xer);
	// 821A1E14: 41990260  bgt cr6, 0x821a2074
	if ctx.cr[6].gt {
	pc = 0x821A2074; continue 'dispatch;
	}
	// 821A1E18: 3D80821A  lis r12, -0x7de6
	ctx.r[12].s64 = -2112225280;
	// 821A1E1C: 398C1E30  addi r12, r12, 0x1e30
	ctx.r[12].s64 = ctx.r[12].s64 + 7728;
	// 821A1E20: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821A1E24: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821A1E28: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821A1E2C: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x821A2068; continue 'dispatch;
		},
		1 => {
	pc = 0x821A1E88; continue 'dispatch;
		},
		2 => {
	pc = 0x821A1E7C; continue 'dispatch;
		},
		3 => {
	pc = 0x821A1E70; continue 'dispatch;
		},
		4 => {
	pc = 0x821A1E64; continue 'dispatch;
		},
		5 => {
	pc = 0x821A1E58; continue 'dispatch;
		},
		6 => {
	pc = 0x821A1E4C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821A1E30: 821A2068  lwz r16, 0x2068(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8296 as u32) ) } as u64;
	// 821A1E34: 821A1E88  lwz r16, 0x1e88(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(7816 as u32) ) } as u64;
	// 821A1E38: 821A1E7C  lwz r16, 0x1e7c(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(7804 as u32) ) } as u64;
	// 821A1E3C: 821A1E70  lwz r16, 0x1e70(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(7792 as u32) ) } as u64;
	// 821A1E40: 821A1E64  lwz r16, 0x1e64(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(7780 as u32) ) } as u64;
	// 821A1E44: 821A1E58  lwz r16, 0x1e58(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(7768 as u32) ) } as u64;
	// 821A1E48: 821A1E4C  lwz r16, 0x1e4c(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(7756 as u32) ) } as u64;
            }
            0x821A1E4C => {
    //   block [0x821A1E4C..0x821A1E58)
	// 821A1E4C: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 821A1E50: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1E54: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x821A1E58; continue 'dispatch;
            }
            0x821A1E58 => {
    //   block [0x821A1E58..0x821A1E64)
	// 821A1E58: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 821A1E5C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1E60: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x821A1E64; continue 'dispatch;
            }
            0x821A1E64 => {
    //   block [0x821A1E64..0x821A1E70)
	// 821A1E64: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 821A1E68: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1E6C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x821A1E70; continue 'dispatch;
            }
            0x821A1E70 => {
    //   block [0x821A1E70..0x821A1E7C)
	// 821A1E70: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 821A1E74: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1E78: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x821A1E7C; continue 'dispatch;
            }
            0x821A1E7C => {
    //   block [0x821A1E7C..0x821A1E88)
	// 821A1E7C: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 821A1E80: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1E84: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x821A1E88; continue 'dispatch;
            }
            0x821A1E88 => {
    //   block [0x821A1E88..0x821A2020)
	// 821A1E88: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 821A1E8C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1E90: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1E94: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 821A1E98: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1E9C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A1EA0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A1EA4: 4839325C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
	// 821A1EA8: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A1EAC: 93DC0000  stw r30, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821A1EB0: 811F002C  lwz r8, 0x2c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A1EB4: 3949FFFF  addi r10, r9, -1
	ctx.r[10].s64 = ctx.r[9].s64 + -1;
	// 821A1EB8: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 821A1EBC: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 821A1EC0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A1EC4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 821A1EC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821A1ECC: 40990020  ble cr6, 0x821a1eec
	if !ctx.cr[6].gt {
	pc = 0x821A1EEC; continue 'dispatch;
	}
	// 821A1ED0: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 821A1ED4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A1ED8: 419A0014  beq cr6, 0x821a1eec
	if ctx.cr[6].eq {
	pc = 0x821A1EEC; continue 'dispatch;
	}
	// 821A1EDC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A1EE0: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A1EE4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821A1EE8: 4200FFF8  bdnz 0x821a1ee0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821A1EE0; continue 'dispatch;
	}
	// 821A1EEC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A1EF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A1EF4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A1EF8: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821A1EFC: 4800025D  bl 0x821a2158
	ctx.lr = 0x821A1F00;
	sub_821A2158(ctx, base);
	// 821A1F00: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A1F04: 419A016C  beq cr6, 0x821a2070
	if ctx.cr[6].eq {
	pc = 0x821A2070; continue 'dispatch;
	}
	// 821A1F08: 2B1D0100  cmplwi cr6, r29, 0x100
	ctx.cr[6].compare_u32(ctx.r[29].u32, 256 as u32, &mut ctx.xer);
	// 821A1F0C: 40980014  bge cr6, 0x821a1f20
	if !ctx.cr[6].lt {
	pc = 0x821A1F20; continue 'dispatch;
	}
	// 821A1F10: 7C00F22C  dcbt 0, r30
	// 821A1F14: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A1F18: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A1F1C: 483931E4  b 0x82535100
	sub_825350D0(ctx, base);
	return;
	// 821A1F20: 3D600004  lis r11, 4
	ctx.r[11].s64 = 262144;
	// 821A1F24: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A1F28: 41980008  blt cr6, 0x821a1f30
	if ctx.cr[6].lt {
	pc = 0x821A1F30; continue 'dispatch;
	}
	// 821A1F2C: 3FA00004  lis r29, 4
	ctx.r[29].s64 = 262144;
	// 821A1F30: 397E007F  addi r11, r30, 0x7f
	ctx.r[11].s64 = ctx.r[30].s64 + 127;
	// 821A1F34: 7D5DF214  add r10, r29, r30
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 821A1F38: 55690030  rlwinm r9, r11, 0, 0, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A1F3C: 554B0030  rlwinm r11, r10, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821A1F40: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821A1F44: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A1F48: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 821A1F4C: 419A0008  beq cr6, 0x821a1f54
	if ctx.cr[6].eq {
	pc = 0x821A1F54; continue 'dispatch;
	}
	// 821A1F50: 7C00F22C  dcbt 0, r30
	// 821A1F54: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821A1F58: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 821A1F5C: 41980080  blt cr6, 0x821a1fdc
	if ctx.cr[6].lt {
	pc = 0x821A1FDC; continue 'dispatch;
	}
	// 821A1F60: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 821A1F64: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1F68: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1F6C: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 821A1F70: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1F74: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 821A1F78: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1F7C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1F80: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 821A1F84: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1F88: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1F8C: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 821A1F90: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1F94: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1F98: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 821A1F9C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1FA0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1FA4: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 821A1FA8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1FAC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1FB0: 3940FC00  li r10, -0x400
	ctx.r[10].s64 = -1024;
	// 821A1FB4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1FB8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1FBC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821A1FC0: 394BFC00  addi r10, r11, -0x400
	ctx.r[10].s64 = ctx.r[11].s64 + -1024;
	// 821A1FC4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1FC8: 396BFC00  addi r11, r11, -0x400
	ctx.r[11].s64 = ctx.r[11].s64 + -1024;
	// 821A1FCC: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 821A1FD0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 821A1FD4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821A1FD8: 4098FF88  bge cr6, 0x821a1f60
	if !ctx.cr[6].lt {
	pc = 0x821A1F60; continue 'dispatch;
	}
	// 821A1FDC: 554ACF7E  rlwinm r10, r10, 0x19, 0x1d, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 821A1FE0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A1FE4: 2B0A0006  cmplwi cr6, r10, 6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 6 as u32, &mut ctx.xer);
	// 821A1FE8: 41990088  bgt cr6, 0x821a2070
	if ctx.cr[6].gt {
	pc = 0x821A2070; continue 'dispatch;
	}
	// 821A1FEC: 3D80821A  lis r12, -0x7de6
	ctx.r[12].s64 = -2112225280;
	// 821A1FF0: 398C2004  addi r12, r12, 0x2004
	ctx.r[12].s64 = ctx.r[12].s64 + 8196;
	// 821A1FF4: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821A1FF8: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821A1FFC: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821A2000: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x821A2068; continue 'dispatch;
		},
		1 => {
	pc = 0x821A205C; continue 'dispatch;
		},
		2 => {
	pc = 0x821A2050; continue 'dispatch;
		},
		3 => {
	pc = 0x821A2044; continue 'dispatch;
		},
		4 => {
	pc = 0x821A2038; continue 'dispatch;
		},
		5 => {
	pc = 0x821A202C; continue 'dispatch;
		},
		6 => {
	pc = 0x821A2020; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821A2004: 821A2068  lwz r16, 0x2068(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8296 as u32) ) } as u64;
	// 821A2008: 821A205C  lwz r16, 0x205c(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8284 as u32) ) } as u64;
	// 821A200C: 821A2050  lwz r16, 0x2050(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8272 as u32) ) } as u64;
	// 821A2010: 821A2044  lwz r16, 0x2044(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8260 as u32) ) } as u64;
	// 821A2014: 821A2038  lwz r16, 0x2038(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8248 as u32) ) } as u64;
	// 821A2018: 821A202C  lwz r16, 0x202c(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8236 as u32) ) } as u64;
	// 821A201C: 821A2020  lwz r16, 0x2020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8224 as u32) ) } as u64;
            }
            0x821A2020 => {
    //   block [0x821A2020..0x821A202C)
	// 821A2020: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 821A2024: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A2028: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821A202C; continue 'dispatch;
            }
            0x821A202C => {
    //   block [0x821A202C..0x821A2038)
	// 821A202C: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 821A2030: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A2034: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821A2038; continue 'dispatch;
            }
            0x821A2038 => {
    //   block [0x821A2038..0x821A2044)
	// 821A2038: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 821A203C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A2040: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821A2044; continue 'dispatch;
            }
            0x821A2044 => {
    //   block [0x821A2044..0x821A2050)
	// 821A2044: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 821A2048: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A204C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821A2050; continue 'dispatch;
            }
            0x821A2050 => {
    //   block [0x821A2050..0x821A205C)
	// 821A2050: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 821A2054: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A2058: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821A205C; continue 'dispatch;
            }
            0x821A205C => {
    //   block [0x821A205C..0x821A2068)
	// 821A205C: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 821A2060: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A2064: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821A2068; continue 'dispatch;
            }
            0x821A2068 => {
    //   block [0x821A2068..0x821A207C)
	// 821A2068: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 821A206C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A2070: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A2074: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A2078: 48393088  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A2080 size=212
    let mut pc: u32 = 0x821A2080;
    'dispatch: loop {
        match pc {
            0x821A2080 => {
    //   block [0x821A2080..0x821A2154)
	// 821A2080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A2088: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A208C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A2090: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A2094: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A2098: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A209C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821A20A0: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A20A4: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A20A8: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821A20AC: 813F002C  lwz r9, 0x2c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A20B0: 93C40000  stw r30, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821A20B4: 7D6B4396  divwu r11, r11, r8
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[8].u32;
	// 821A20B8: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A20BC: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 821A20C0: 7D694214  add r11, r9, r8
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821A20C4: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821A20C8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821A20CC: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A20D0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821A20D4: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 821A20D8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A20DC: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 821A20E0: 409A0034  bne cr6, 0x821a2114
	if !ctx.cr[6].eq {
	pc = 0x821A2114; continue 'dispatch;
	}
	// 821A20E4: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A20E8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A20EC: 40980028  bge cr6, 0x821a2114
	if !ctx.cr[6].lt {
	pc = 0x821A2114; continue 'dispatch;
	}
	// 821A20F0: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821A20F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821A20F8: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A20FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A2100: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821A2104: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 821A2108: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A210C: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 821A2110: 419AFFD4  beq cr6, 0x821a20e4
	if ctx.cr[6].eq {
	pc = 0x821A20E4; continue 'dispatch;
	}
	// 821A2114: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A2118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A211C: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821A2120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A2124: 419A000C  beq cr6, 0x821a2130
	if ctx.cr[6].eq {
	pc = 0x821A2130; continue 'dispatch;
	}
	// 821A2128: 480000E1  bl 0x821a2208
	ctx.lr = 0x821A212C;
	sub_821A2208(ctx, base);
	// 821A212C: 48000008  b 0x821a2134
	pc = 0x821A2134; continue 'dispatch;
	// 821A2130: 48000029  bl 0x821a2158
	ctx.lr = 0x821A2134;
	sub_821A2158(ctx, base);
	// 821A2134: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A2138: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 821A213C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A2140: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A2144: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A2148: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A214C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A2150: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A2158 size=172
    let mut pc: u32 = 0x821A2158;
    'dispatch: loop {
        match pc {
            0x821A2158 => {
    //   block [0x821A2158..0x821A2204)
	// 821A2158: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821A215C: 80830028  lwz r4, 0x28(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A2160: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A2164: 80C3002C  lwz r6, 0x2c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A2168: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A216C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A2170: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A2174: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A2178: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A217C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A2180: 40990074  ble cr6, 0x821a21f4
	if !ctx.cr[6].gt {
	pc = 0x821A21F4; continue 'dispatch;
	}
	// 821A2184: 5484003E  slwi r4, r4, 0
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A2188: 83E60000  lwz r31, 0(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A218C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A2190: 409A001C  bne cr6, 0x821a21ac
	if !ctx.cr[6].eq {
	pc = 0x821A21AC; continue 'dispatch;
	}
	// 821A2194: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A2198: 409A000C  bne cr6, 0x821a21a4
	if !ctx.cr[6].eq {
	pc = 0x821A21A4; continue 'dispatch;
	}
	// 821A219C: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 821A21A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A21A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A21A8: 48000024  b 0x821a21cc
	pc = 0x821A21CC; continue 'dispatch;
	// 821A21AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A21B0: 419A001C  beq cr6, 0x821a21cc
	if ctx.cr[6].eq {
	pc = 0x821A21CC; continue 'dispatch;
	}
	// 821A21B4: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821A21B8: 4099000C  ble cr6, 0x821a21c4
	if !ctx.cr[6].gt {
	pc = 0x821A21C4; continue 'dispatch;
	}
	// 821A21BC: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 821A21C0: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 821A21C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A21C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A21CC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821A21D0: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 821A21D4: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821A21D8: 4198FFB0  blt cr6, 0x821a2188
	if ctx.cr[6].lt {
	pc = 0x821A2188; continue 'dispatch;
	}
	// 821A21DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A21E0: 419A0014  beq cr6, 0x821a21f4
	if ctx.cr[6].eq {
	pc = 0x821A21F4; continue 'dispatch;
	}
	// 821A21E4: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821A21E8: 4099000C  ble cr6, 0x821a21f4
	if !ctx.cr[6].gt {
	pc = 0x821A21F4; continue 'dispatch;
	}
	// 821A21EC: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 821A21F0: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 821A21F4: 90E30014  stw r7, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 821A21F8: 90A30018  stw r5, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[5].u32 ) };
	// 821A21FC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821A2200: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A2208 size=192
    let mut pc: u32 = 0x821A2208;
    'dispatch: loop {
        match pc {
            0x821A2208 => {
    //   block [0x821A2208..0x821A22C8)
	// 821A2208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A220C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A2210: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A2214: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A2218: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A221C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A2220: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A2224: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A2228: 7D4A59D6  mullw r10, r10, r11
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 821A222C: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A2230: 7FEA5B96  divwu r31, r10, r11
	ctx.r[31].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 821A2234: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A2238: 419A0070  beq cr6, 0x821a22a8
	if ctx.cr[6].eq {
	pc = 0x821A22A8; continue 'dispatch;
	}
	// 821A223C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A2240: 48000201  bl 0x821a2440
	ctx.lr = 0x821A2244;
	sub_821A2440(ctx, base);
	// 821A2244: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821A2248: 40990024  ble cr6, 0x821a226c
	if !ctx.cr[6].gt {
	pc = 0x821A226C; continue 'dispatch;
	}
	// 821A224C: 7FE3F850  subf r31, r3, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[3].s64;
	// 821A2250: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A2254: 419A0054  beq cr6, 0x821a22a8
	if ctx.cr[6].eq {
	pc = 0x821A22A8; continue 'dispatch;
	}
	// 821A2258: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A225C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A2260: 480001E1  bl 0x821a2440
	ctx.lr = 0x821A2264;
	sub_821A2440(ctx, base);
	// 821A2264: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821A2268: 4199FFE4  bgt cr6, 0x821a224c
	if ctx.cr[6].gt {
	pc = 0x821A224C; continue 'dispatch;
	}
	// 821A226C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A2270: 419A0038  beq cr6, 0x821a22a8
	if ctx.cr[6].eq {
	pc = 0x821A22A8; continue 'dispatch;
	}
	// 821A2274: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A2278: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A227C: 480002BD  bl 0x821a2538
	ctx.lr = 0x821A2280;
	sub_821A2538(ctx, base);
	// 821A2280: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821A2284: 40990024  ble cr6, 0x821a22a8
	if !ctx.cr[6].gt {
	pc = 0x821A22A8; continue 'dispatch;
	}
	// 821A2288: 7FE3F850  subf r31, r3, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[3].s64;
	// 821A228C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A2290: 419A0018  beq cr6, 0x821a22a8
	if ctx.cr[6].eq {
	pc = 0x821A22A8; continue 'dispatch;
	}
	// 821A2294: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A2298: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A229C: 4800029D  bl 0x821a2538
	ctx.lr = 0x821A22A0;
	sub_821A2538(ctx, base);
	// 821A22A0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821A22A4: 4199FFE4  bgt cr6, 0x821a2288
	if ctx.cr[6].gt {
	pc = 0x821A2288; continue 'dispatch;
	}
	// 821A22A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A22AC: 4BFFFEAD  bl 0x821a2158
	ctx.lr = 0x821A22B0;
	sub_821A2158(ctx, base);
	// 821A22B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A22B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A22B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A22BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A22C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A22C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A22C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A22C8 size=196
    let mut pc: u32 = 0x821A22C8;
    'dispatch: loop {
        match pc {
            0x821A22C8 => {
    //   block [0x821A22C8..0x821A238C)
	// 821A22C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A22CC: 48392DE9  bl 0x825350b4
	ctx.lr = 0x821A22D0;
	sub_82535080(ctx, base);
	// 821A22D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A22D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A22D8: 3D40656D  lis r10, 0x656d
	ctx.r[10].s64 = 1701642240;
	// 821A22DC: 614A5F6F  ori r10, r10, 0x5f6f
	ctx.r[10].u64 = ctx.r[10].u64 | 24431;
	// 821A22E0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A22E4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A22E8: 409A009C  bne cr6, 0x821a2384
	if !ctx.cr[6].eq {
	pc = 0x821A2384; continue 'dispatch;
	}
	// 821A22EC: 3D407379  lis r10, 0x7379
	ctx.r[10].s64 = 1937309696;
	// 821A22F0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A22F4: 614A736D  ori r10, r10, 0x736d
	ctx.r[10].u64 = ctx.r[10].u64 | 29549;
	// 821A22F8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A22FC: 409A0088  bne cr6, 0x821a2384
	if !ctx.cr[6].eq {
	pc = 0x821A2384; continue 'dispatch;
	}
	// 821A2300: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A2304: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A2308: 419A007C  beq cr6, 0x821a2384
	if ctx.cr[6].eq {
	pc = 0x821A2384; continue 'dispatch;
	}
	// 821A230C: 83BF0020  lwz r29, 0x20(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A2310: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821A2314: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A2318: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A231C: 7D7D5850  subf r11, r29, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 821A2320: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A2324: 7D5D5050  subf r10, r29, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[29].s64;
	// 821A2328: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 821A232C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821A2330: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 821A2334: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A2338: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 821A233C: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 821A2340: 40990044  ble cr6, 0x821a2384
	if !ctx.cr[6].gt {
	pc = 0x821A2384; continue 'dispatch;
	}
	// 821A2344: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 821A2348: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A234C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A2350: 419A0020  beq cr6, 0x821a2370
	if ctx.cr[6].eq {
	pc = 0x821A2370; continue 'dispatch;
	}
	// 821A2354: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 821A2358: 419A0018  beq cr6, 0x821a2370
	if ctx.cr[6].eq {
	pc = 0x821A2370; continue 'dispatch;
	}
	// 821A235C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A2360: 7D5D5050  subf r10, r29, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[29].s64;
	// 821A2364: 7C6AF214  add r3, r10, r30
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 821A2368: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821A236C: 4BFFFF5D  bl 0x821a22c8
	ctx.lr = 0x821A2370;
	sub_821A22C8(ctx, base);
	// 821A2370: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A2374: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 821A2378: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 821A237C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A2380: 4198FFC8  blt cr6, 0x821a2348
	if ctx.cr[6].lt {
	pc = 0x821A2348; continue 'dispatch;
	}
	// 821A2384: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A2388: 48392D7C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A2390 size=176
    let mut pc: u32 = 0x821A2390;
    'dispatch: loop {
        match pc {
            0x821A2390 => {
    //   block [0x821A2390..0x821A2440)
	// 821A2390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2394: 48392D21  bl 0x825350b4
	ctx.lr = 0x821A2398;
	sub_82535080(ctx, base);
	// 821A2398: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A239C: 8363000C  lwz r27, 0xc(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A23A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821A23A4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821A23A8: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A23AC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821A23B0: 8383002C  lwz r28, 0x2c(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A23B4: 7D3BF1D6  mullw r9, r27, r30
	ctx.r[9].s64 = (ctx.r[27].s32 as i64) * (ctx.r[30].s32 as i64);
	// 821A23B8: 7D5BF9D6  mullw r10, r27, r31
	ctx.r[10].s64 = (ctx.r[27].s32 as i64) * (ctx.r[31].s32 as i64);
	// 821A23BC: 7CBBE9D6  mullw r5, r27, r29
	ctx.r[5].s64 = (ctx.r[27].s32 as i64) * (ctx.r[29].s32 as i64);
	// 821A23C0: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821A23C4: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A23C8: 48392789  bl 0x82534b50
	ctx.lr = 0x821A23CC;
	sub_82534B50(ctx, base);
	// 821A23CC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821A23D0: 40990068  ble cr6, 0x821a2438
	if !ctx.cr[6].gt {
	pc = 0x821A2438; continue 'dispatch;
	}
	// 821A23D4: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A23D8: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A23DC: 7CEAE214  add r7, r10, r28
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 821A23E0: 7CCBE214  add r6, r11, r28
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821A23E4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A23E8: 81070000  lwz r8, 0(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A23EC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821A23F0: 419A0024  beq cr6, 0x821a2414
	if ctx.cr[6].eq {
	pc = 0x821A2414; continue 'dispatch;
	}
	// 821A23F4: 2B080002  cmplwi cr6, r8, 2
	ctx.cr[6].compare_u32(ctx.r[8].u32, 2 as u32, &mut ctx.xer);
	// 821A23F8: 419A001C  beq cr6, 0x821a2414
	if ctx.cr[6].eq {
	pc = 0x821A2414; continue 'dispatch;
	}
	// 821A23FC: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 821A2400: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A2404: 7D6BD9D6  mullw r11, r11, r27
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[27].s32 as i64);
	// 821A2408: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A240C: 90680000  stw r3, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821A2410: 4BFFFEB9  bl 0x821a22c8
	ctx.lr = 0x821A2414;
	sub_821A22C8(ctx, base);
	// 821A2414: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 821A2418: 91060000  stw r8, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A241C: 90A70000  stw r5, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 821A2420: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821A2424: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821A2428: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 821A242C: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 821A2430: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821A2434: 409AFFB4  bne cr6, 0x821a23e8
	if !ctx.cr[6].eq {
	pc = 0x821A23E8; continue 'dispatch;
	}
	// 821A2438: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A243C: 48392CC8  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A2440 size=244
    let mut pc: u32 = 0x821A2440;
    'dispatch: loop {
        match pc {
            0x821A2440 => {
    //   block [0x821A2440..0x821A2534)
	// 821A2440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2444: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A2448: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A244C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A2450: 81230028  lwz r9, 0x28(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A2454: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 821A2458: 80C3002C  lwz r6, 0x2c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A245C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A2460: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 821A2464: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A2468: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821A246C: 40990040  ble cr6, 0x821a24ac
	if !ctx.cr[6].gt {
	pc = 0x821A24AC; continue 'dispatch;
	}
	// 821A2470: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 821A2474: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A2478: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A247C: 409A0018  bne cr6, 0x821a2494
	if !ctx.cr[6].eq {
	pc = 0x821A2494; continue 'dispatch;
	}
	// 821A2480: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821A2484: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821A2488: 40980014  bge cr6, 0x821a249c
	if !ctx.cr[6].lt {
	pc = 0x821A249C; continue 'dispatch;
	}
	// 821A248C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821A2490: 4800000C  b 0x821a249c
	pc = 0x821A249C; continue 'dispatch;
	// 821A2494: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821A2498: 40980014  bge cr6, 0x821a24ac
	if !ctx.cr[6].lt {
	pc = 0x821A24AC; continue 'dispatch;
	}
	// 821A249C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A24A0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821A24A4: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821A24A8: 4198FFCC  blt cr6, 0x821a2474
	if ctx.cr[6].lt {
	pc = 0x821A2474; continue 'dispatch;
	}
	// 821A24AC: 7F083800  cmpw cr6, r8, r7
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821A24B0: 40990008  ble cr6, 0x821a24b8
	if !ctx.cr[6].gt {
	pc = 0x821A24B8; continue 'dispatch;
	}
	// 821A24B4: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 821A24B8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A24BC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821A24C0: 419A005C  beq cr6, 0x821a251c
	if ctx.cr[6].eq {
	pc = 0x821A251C; continue 'dispatch;
	}
	// 821A24C4: 38A9FFFF  addi r5, r9, -1
	ctx.r[5].s64 = ctx.r[9].s64 + -1;
	// 821A24C8: 7D244214  add r9, r4, r8
	ctx.r[9].u64 = ctx.r[4].u64 + ctx.r[8].u64;
	// 821A24CC: 7F054800  cmpw cr6, r5, r9
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821A24D0: 4198004C  blt cr6, 0x821a251c
	if ctx.cr[6].lt {
	pc = 0x821A251C; continue 'dispatch;
	}
	// 821A24D4: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A24D8: 7D4B3214  add r10, r11, r6
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 821A24DC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A24E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A24E4: 419A001C  beq cr6, 0x821a2500
	if ctx.cr[6].eq {
	pc = 0x821A2500; continue 'dispatch;
	}
	// 821A24E8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821A24EC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 821A24F0: 419A0010  beq cr6, 0x821a2500
	if ctx.cr[6].eq {
	pc = 0x821A2500; continue 'dispatch;
	}
	// 821A24F4: 7F1F4000  cmpw cr6, r31, r8
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821A24F8: 4099001C  ble cr6, 0x821a2514
	if !ctx.cr[6].gt {
	pc = 0x821A2514; continue 'dispatch;
	}
	// 821A24FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A2500: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 821A2504: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 821A2508: 7F054800  cmpw cr6, r5, r9
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821A250C: 4098FFD0  bge cr6, 0x821a24dc
	if !ctx.cr[6].lt {
	pc = 0x821A24DC; continue 'dispatch;
	}
	// 821A2510: 4800000C  b 0x821a251c
	pc = 0x821A251C; continue 'dispatch;
	// 821A2514: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821A2518: 4BFFFE79  bl 0x821a2390
	ctx.lr = 0x821A251C;
	sub_821A2390(ctx, base);
	// 821A251C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A2520: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A2524: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A2528: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A252C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A2530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A2538 size=308
    let mut pc: u32 = 0x821A2538;
    'dispatch: loop {
        match pc {
            0x821A2538 => {
    //   block [0x821A2538..0x821A266C)
	// 821A2538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A253C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A2540: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A2544: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A2548: 80E30028  lwz r7, 0x28(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A254C: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 821A2550: 8103002C  lwz r8, 0x2c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A2554: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A2558: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 821A255C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A2560: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821A2564: 40990040  ble cr6, 0x821a25a4
	if !ctx.cr[6].gt {
	pc = 0x821A25A4; continue 'dispatch;
	}
	// 821A2568: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 821A256C: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A2570: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A2574: 409A0018  bne cr6, 0x821a258c
	if !ctx.cr[6].eq {
	pc = 0x821A258C; continue 'dispatch;
	}
	// 821A2578: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A257C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821A2580: 40980014  bge cr6, 0x821a2594
	if !ctx.cr[6].lt {
	pc = 0x821A2594; continue 'dispatch;
	}
	// 821A2584: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821A2588: 4800000C  b 0x821a2594
	pc = 0x821A2594; continue 'dispatch;
	// 821A258C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821A2590: 40980014  bge cr6, 0x821a25a4
	if !ctx.cr[6].lt {
	pc = 0x821A25A4; continue 'dispatch;
	}
	// 821A2594: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A2598: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 821A259C: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821A25A0: 4198FFCC  blt cr6, 0x821a256c
	if ctx.cr[6].lt {
	pc = 0x821A256C; continue 'dispatch;
	}
	// 821A25A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A25A8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A25AC: 419A00A8  beq cr6, 0x821a2654
	if ctx.cr[6].eq {
	pc = 0x821A2654; continue 'dispatch;
	}
	// 821A25B0: 7D245214  add r9, r4, r10
	ctx.r[9].u64 = ctx.r[4].u64 + ctx.r[10].u64;
	// 821A25B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A25B8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821A25BC: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821A25C0: 40980094  bge cr6, 0x821a2654
	if !ctx.cr[6].lt {
	pc = 0x821A2654; continue 'dispatch;
	}
	// 821A25C4: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A25C8: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821A25CC: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A25D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A25D4: 419A0060  beq cr6, 0x821a2634
	if ctx.cr[6].eq {
	pc = 0x821A2634; continue 'dispatch;
	}
	// 821A25D8: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 821A25DC: 419A0024  beq cr6, 0x821a2600
	if ctx.cr[6].eq {
	pc = 0x821A2600; continue 'dispatch;
	}
	// 821A25E0: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821A25E4: 40980008  bge cr6, 0x821a25ec
	if !ctx.cr[6].lt {
	pc = 0x821A25EC; continue 'dispatch;
	}
	// 821A25E8: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 821A25EC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821A25F0: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821A25F4: 41990050  bgt cr6, 0x821a2644
	if ctx.cr[6].gt {
	pc = 0x821A2644; continue 'dispatch;
	}
	// 821A25F8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821A25FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A2600: 3947FFFF  addi r10, r7, -1
	ctx.r[10].s64 = ctx.r[7].s64 + -1;
	// 821A2604: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A2608: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A260C: 409A0014  bne cr6, 0x821a2620
	if !ctx.cr[6].eq {
	pc = 0x821A2620; continue 'dispatch;
	}
	// 821A2610: 7D4BFA14  add r10, r11, r31
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821A2614: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821A2618: 41990008  bgt cr6, 0x821a2620
	if ctx.cr[6].gt {
	pc = 0x821A2620; continue 'dispatch;
	}
	// 821A261C: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 821A2620: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821A2624: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 821A2628: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821A262C: 4198FFA0  blt cr6, 0x821a25cc
	if ctx.cr[6].lt {
	pc = 0x821A25CC; continue 'dispatch;
	}
	// 821A2630: 48000014  b 0x821a2644
	pc = 0x821A2644; continue 'dispatch;
	// 821A2634: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821A2638: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821A263C: 41990008  bgt cr6, 0x821a2644
	if ctx.cr[6].gt {
	pc = 0x821A2644; continue 'dispatch;
	}
	// 821A2640: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821A2644: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821A2648: 419A000C  beq cr6, 0x821a2654
	if ctx.cr[6].eq {
	pc = 0x821A2654; continue 'dispatch;
	}
	// 821A264C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821A2650: 4BFFFD41  bl 0x821a2390
	ctx.lr = 0x821A2654;
	sub_821A2390(ctx, base);
	// 821A2654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A2658: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A265C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A2660: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A2664: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A2668: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A2670 size=240
    let mut pc: u32 = 0x821A2670;
    'dispatch: loop {
        match pc {
            0x821A2670 => {
    //   block [0x821A2670..0x821A2760)
	// 821A2670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2674: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A2678: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A267C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A2680: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 821A2684: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	// 821A2688: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A268C: 396B33D0  addi r11, r11, 0x33d0
	ctx.r[11].s64 = ctx.r[11].s64 + 13264;
	// 821A2690: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A2694: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A2698: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A269C: D1A40000  stfs f13, 0(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A26A0: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A26A4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A26A8: D1A40004  stfs f13, 4(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A26AC: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A26B0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A26B4: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A26B8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A26BC: D004000C  stfs f0, 0xc(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A26C0: 481C4A79  bl 0x82367138
	ctx.lr = 0x821A26C4;
	sub_82367138(ctx, base);
	// 821A26C4: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A26C8: C1BF000C  lfs f13, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A26CC: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821A26D0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A26D4: C19F0000  lfs f12, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A26D8: C17F0004  lfs f11, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A26DC: C15F0008  lfs f10, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A26E0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821A26E4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A26E8: C00BD218  lfs f0, -0x2de8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A26EC: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A2760 size=68
    let mut pc: u32 = 0x821A2760;
    'dispatch: loop {
        match pc {
            0x821A2760 => {
    //   block [0x821A2760..0x821A27A4)
	// 821A2760: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A2764: 419A0040  beq cr6, 0x821a27a4
	if ctx.cr[6].eq {
		sub_821A27A4(ctx, base);
		return;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A27A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A27A4 size=76
    let mut pc: u32 = 0x821A27A4;
    'dispatch: loop {
        match pc {
            0x821A27A4 => {
    //   block [0x821A27A4..0x821A27F0)
	// 821A27A4: C1A70004  lfs f13, 4(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A27A8: C0070000  lfs f0, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A27AC: EDAD0072  fmuls f13, f13, f1
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[1].f64) as f32) as f64);
	// 821A27B0: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 821A27B4: D1A1FFF4  stfs f13, -0xc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 821A27B8: C1A7000C  lfs f13, 0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A27BC: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 821A27C0: C0070008  lfs f0, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A27C4: D1A1FFFC  stfs f13, -4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821A27C8: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 821A27CC: D001FFF8  stfs f0, -8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821A27D0: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A27F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A27F0 size=140
    let mut pc: u32 = 0x821A27F0;
    'dispatch: loop {
        match pc {
            0x821A27F0 => {
    //   block [0x821A27F0..0x821A287C)
	// 821A27F0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A27F4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A27F8: 396B0D6C  addi r11, r11, 0xd6c
	ctx.r[11].s64 = ctx.r[11].s64 + 3436;
	// 821A27FC: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A2800: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A2804: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A2808: FF040000  fcmpu cr6, f4, f0
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[0].f64);
	// 821A280C: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A2810: 41990008  bgt cr6, 0x821a2818
	if ctx.cr[6].gt {
	pc = 0x821A2818; continue 'dispatch;
	}
	// 821A2814: FC806890  fmr f4, f13
	ctx.f[4].f64 = ctx.f[13].f64;
	// 821A2818: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 821A281C: 41990008  bgt cr6, 0x821a2824
	if ctx.cr[6].gt {
	pc = 0x821A2824; continue 'dispatch;
	}
	// 821A2820: FC406890  fmr f2, f13
	ctx.f[2].f64 = ctx.f[13].f64;
	// 821A2824: FF060000  fcmpu cr6, f6, f0
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[0].f64);
	// 821A2828: 41990008  bgt cr6, 0x821a2830
	if ctx.cr[6].gt {
	pc = 0x821A2830; continue 'dispatch;
	}
	// 821A282C: FCC06890  fmr f6, f13
	ctx.f[6].f64 = ctx.f[13].f64;
	// 821A2830: EDA11828  fsubs f13, f1, f3
	ctx.f[13].f64 = (((ctx.f[1].f64 - ctx.f[3].f64) as f32) as f64);
	// 821A2834: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A2838: FF070000  fcmpu cr6, f7, f0
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[0].f64);
	// 821A283C: D063008C  stfs f3, 0x8c(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821A2840: D0630088  stfs f3, 0x88(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821A2844: D0230090  stfs f1, 0x90(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821A2848: D0A30094  stfs f5, 0x94(r3)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821A284C: D08300A0  stfs f4, 0xa0(r3)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 821A2850: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 821A2854: D04300A4  stfs f2, 0xa4(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 821A2858: D0C300A8  stfs f6, 0xa8(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 821A285C: D0E300AC  stfs f7, 0xac(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 821A2860: EC0D2024  fdivs f0, f13, f4
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[4].f64) as f32) as f64;
	// 821A2864: D0030098  stfs f0, 0x98(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 821A2868: 419A000C  beq cr6, 0x821a2874
	if ctx.cr[6].eq {
	pc = 0x821A2874; continue 'dispatch;
	}
	// 821A286C: D0E3009C  stfs f7, 0x9c(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 821A2870: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A2874: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821A2878: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A2880 size=360
    let mut pc: u32 = 0x821A2880;
    'dispatch: loop {
        match pc {
            0x821A2880 => {
    //   block [0x821A2880..0x821A28B8)
	// 821A2880: 81430080  lwz r10, 0x80(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A2884: C1A30088  lfs f13, 0x88(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A2888: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 821A288C: 419900A0  bgt cr6, 0x821a292c
	if ctx.cr[6].gt {
	pc = 0x821A292C; continue 'dispatch;
	}
	// 821A2890: 3D80821A  lis r12, -0x7de6
	ctx.r[12].s64 = -2112225280;
	// 821A2894: 398C28A8  addi r12, r12, 0x28a8
	ctx.r[12].s64 = ctx.r[12].s64 + 10408;
	// 821A2898: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821A289C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821A28A0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821A28A4: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x821A2930; continue 'dispatch;
		},
		1 => {
	pc = 0x821A28B8; continue 'dispatch;
		},
		2 => {
	pc = 0x821A2930; continue 'dispatch;
		},
		3 => {
	pc = 0x821A2978; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821A28A8: 821A2930  lwz r16, 0x2930(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(10544 as u32) ) } as u64;
	// 821A28AC: 821A28B8  lwz r16, 0x28b8(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(10424 as u32) ) } as u64;
	// 821A28B0: 821A2930  lwz r16, 0x2930(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(10544 as u32) ) } as u64;
	// 821A28B4: 821A2978  lwz r16, 0x2978(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(10616 as u32) ) } as u64;
            }
            0x821A28B8 => {
    //   block [0x821A28B8..0x821A2930)
	// 821A28B8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A28BC: C0030098  lfs f0, 0x98(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A28C0: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A28C4: C1630090  lfs f11, 0x90(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A28C8: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A28CC: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 821A28D0: 7D8B542E  lfsx f12, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A28D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A28D8: EDA06B3A  fmadds f13, f0, f12, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 821A28DC: C14B1FF8  lfs f10, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A28E0: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 821A28E4: 4098000C  bge cr6, 0x821a28f0
	if !ctx.cr[6].lt {
	pc = 0x821A28F0; continue 'dispatch;
	}
	// 821A28E8: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 821A28EC: 40990014  ble cr6, 0x821a2900
	if !ctx.cr[6].gt {
	pc = 0x821A2900; continue 'dispatch;
	}
	// 821A28F0: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 821A28F4: 41980034  blt cr6, 0x821a2928
	if ctx.cr[6].lt {
	pc = 0x821A2928; continue 'dispatch;
	}
	// 821A28F8: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 821A28FC: 4198002C  blt cr6, 0x821a2928
	if ctx.cr[6].lt {
	pc = 0x821A2928; continue 'dispatch;
	}
	// 821A2900: C0030094  lfs f0, 0x94(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A2904: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821A2908: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 821A290C: C18300A8  lfs f12, 0xa8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(168 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A2910: C14300A4  lfs f10, 0xa4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(164 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A2914: FDA05890  fmr f13, f11
	ctx.f[13].f64 = ctx.f[11].f64;
	// 821A2918: D143009C  stfs f10, 0x9c(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 821A291C: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821A2920: EC006024  fdivs f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 821A2924: D0030098  stfs f0, 0x98(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 821A2928: D1A30088  stfs f13, 0x88(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821A292C: 4E800020  blr
	return;
            }
            0x821A2930 => {
    //   block [0x821A2930..0x821A2978)
	// 821A2930: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A2934: C1A3009C  lfs f13, 0x9c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A2938: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 821A293C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A2940: 612985D8  ori r9, r9, 0x85d8
	ctx.r[9].u64 = ctx.r[9].u64 | 34264;
	// 821A2944: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A2948: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A294C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821A2950: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A2954: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821A2958: 41990018  bgt cr6, 0x821a2970
	if ctx.cr[6].gt {
	pc = 0x821A2970; continue 'dispatch;
	}
	// 821A295C: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 821A2960: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 821A2964: 419A0008  beq cr6, 0x821a296c
	if ctx.cr[6].eq {
	pc = 0x821A296C; continue 'dispatch;
	}
	// 821A2968: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A296C: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821A2970: D003009C  stfs f0, 0x9c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 821A2974: 4E800020  blr
	return;
            }
            0x821A2978 => {
    //   block [0x821A2978..0x821A29E8)
	// 821A2978: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A297C: C0030098  lfs f0, 0x98(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A2980: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A2984: C1430094  lfs f10, 0x94(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A2988: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A298C: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 821A2990: 7D8B542E  lfsx f12, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A2994: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A2998: EDA06B3A  fmadds f13, f0, f12, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 821A299C: C16B1FF8  lfs f11, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A29A0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 821A29A4: 4198000C  blt cr6, 0x821a29b0
	if ctx.cr[6].lt {
	pc = 0x821A29B0; continue 'dispatch;
	}
	// 821A29A8: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 821A29AC: 40980014  bge cr6, 0x821a29c0
	if !ctx.cr[6].lt {
	pc = 0x821A29C0; continue 'dispatch;
	}
	// 821A29B0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 821A29B4: 4098FF74  bge cr6, 0x821a2928
	if !ctx.cr[6].lt {
	pc = 0x821A2928; continue 'dispatch;
	}
	// 821A29B8: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 821A29BC: 4199FF6C  bgt cr6, 0x821a2928
	if ctx.cr[6].gt {
	pc = 0x821A2928; continue 'dispatch;
	}
	// 821A29C0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A29C4: D1430088  stfs f10, 0x88(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821A29C8: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A29CC: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821A29D0: 409AFF5C  bne cr6, 0x821a292c
	if !ctx.cr[6].eq {
	pc = 0x821A292C; continue 'dispatch;
	}
	// 821A29D4: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821A29D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A29DC: 99630019  stb r11, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 821A29E0: 99430025  stb r10, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 821A29E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A29E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A29E8 size=356
    let mut pc: u32 = 0x821A29E8;
    'dispatch: loop {
        match pc {
            0x821A29E8 => {
    //   block [0x821A29E8..0x821A2B4C)
	// 821A29E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A29EC: 483926D1  bl 0x825350bc
	ctx.lr = 0x821A29F0;
	sub_82535080(ctx, base);
	// 821A29F0: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 821A29F4: 483935F5  bl 0x82535fe8
	ctx.lr = 0x821A29F8;
	sub_82535FB0(ctx, base);
	// 821A29F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A29FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A2A00: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821A2A04: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821A2A08: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 821A2A0C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821A2A10: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 821A2A14: FF802090  fmr f28, f4
	ctx.f[28].f64 = ctx.f[4].f64;
	// 821A2A18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A2A1C: FBDD0000  std r30, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821A2A20: 419A0114  beq cr6, 0x821a2b34
	if ctx.cr[6].eq {
	pc = 0x821A2B34; continue 'dispatch;
	}
	// 821A2A24: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A2A28: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A2A2C: 38EB0D44  addi r7, r11, 0xd44
	ctx.r[7].s64 = ctx.r[11].s64 + 3396;
	// 821A2A30: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A2A34: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A2A38: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A2A3C: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 821A2A40: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A2A44: 481C7A4D  bl 0x8236a490
	ctx.lr = 0x821A2A48;
	sub_8236A490(ctx, base);
	// 821A2A48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A2A4C: 419A000C  beq cr6, 0x821a2a58
	if ctx.cr[6].eq {
	pc = 0x821A2A58; continue 'dispatch;
	}
	// 821A2A50: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A2A54: 48000008  b 0x821a2a5c
	pc = 0x821A2A5C; continue 'dispatch;
	// 821A2A58: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821A2A5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A2A60: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A2A64: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821A2A68: 419A006C  beq cr6, 0x821a2ad4
	if ctx.cr[6].eq {
	pc = 0x821A2AD4; continue 'dispatch;
	}
	// 821A2A6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A2A70: FCC0F090  fmr f6, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[6].f64 = ctx.f[30].f64;
	// 821A2A74: FC80E890  fmr f4, f29
	ctx.f[4].f64 = ctx.f[29].f64;
	// 821A2A78: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821A2A7C: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 821A2A80: C0EB1FF8  lfs f7, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A2A84: FCA03890  fmr f5, f7
	ctx.f[5].f64 = ctx.f[7].f64;
	// 821A2A88: FC603890  fmr f3, f7
	ctx.f[3].f64 = ctx.f[7].f64;
	// 821A2A8C: 4BFFFD65  bl 0x821a27f0
	ctx.lr = 0x821A2A90;
	sub_821A27F0(ctx, base);
	// 821A2A90: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 821A2A94: 38E300C0  addi r7, r3, 0xc0
	ctx.r[7].s64 = ctx.r[3].s64 + 192;
	// 821A2A98: 392BBFC0  addi r9, r11, -0x4040
	ctx.r[9].s64 = ctx.r[11].s64 + -16448;
	// 821A2A9C: 396300B0  addi r11, r3, 0xb0
	ctx.r[11].s64 = ctx.r[3].s64 + 176;
	// 821A2AA0: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821A2AA4: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 821A2AA8: 39090D8C  addi r8, r9, 0xd8c
	ctx.r[8].s64 = ctx.r[9].s64 + 3468;
	// 821A2AAC: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 821A2AB0: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A2AB4: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821A2AB8: F90B0000  std r8, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 821A2ABC: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821A2AC0: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821A2AC4: E97F0000  ld r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 821A2AC8: F9690000  std r11, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821A2ACC: E97F0008  ld r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 821A2AD0: F9690008  std r11, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821A2AD4: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821A2AD8: E96ACB20  ld r11, -0x34e0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-13536 as u32) ) };
	// 821A2ADC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A2AE0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A2AE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A2AE8: 419A0030  beq cr6, 0x821a2b18
	if ctx.cr[6].eq {
	pc = 0x821A2B18; continue 'dispatch;
	}
	// 821A2AEC: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A2AF0: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A2AF4: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A2AF8: 409A0020  bne cr6, 0x821a2b18
	if !ctx.cr[6].eq {
	pc = 0x821A2B18; continue 'dispatch;
	}
	// 821A2AFC: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A2B00: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 821A2B04: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A2B08: 61298000  ori r9, r9, 0x8000
	ctx.r[9].u64 = ctx.r[9].u64 | 32768;
	// 821A2B0C: 990B0019  stb r8, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[8].u8 ) };
	// 821A2B10: 98EB0025  stb r7, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[7].u8 ) };
	// 821A2B14: B12B0014  sth r9, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u16 ) };
	// 821A2B18: E97D0000  ld r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 821A2B1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A2B20: F96ACB20  std r11, -0x34e0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(-13536 as u32), ctx.r[11].u64 ) };
	// 821A2B24: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A2B28: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 821A2B2C: 48393509  bl 0x82536034
	ctx.lr = 0x821A2B30;
	sub_82535FFC(ctx, base);
	// 821A2B30: 483925DC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
	// 821A2B34: FBDD0000  std r30, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821A2B38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A2B3C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A2B40: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 821A2B44: 483934F1  bl 0x82536034
	ctx.lr = 0x821A2B48;
	sub_82535FFC(ctx, base);
	// 821A2B48: 483925C4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A2B50 size=236
    let mut pc: u32 = 0x821A2B50;
    'dispatch: loop {
        match pc {
            0x821A2B50 => {
    //   block [0x821A2B50..0x821A2C3C)
	// 821A2B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2B54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A2B58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A2B5C: 4BFFFD25  bl 0x821a2880
	ctx.lr = 0x821A2B60;
	sub_821A2880(ctx, base);
	// 821A2B60: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A2B64: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A2B68: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 821A2B6C: 419900C0  bgt cr6, 0x821a2c2c
	if ctx.cr[6].gt {
	pc = 0x821A2C2C; continue 'dispatch;
	}
	// 821A2B70: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A2B74: C0030088  lfs f0, 0x88(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A2B78: C16300CC  lfs f11, 0xcc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A2B7C: C14300C0  lfs f10, 0xc0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A2B80: C12300C4  lfs f9, 0xc4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A2B84: C10300C8  lfs f8, 0xc8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821A2B88: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A2B8C: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 821A2B90: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821A2B94: 396BB900  addi r11, r11, -0x4700
	ctx.r[11].s64 = ctx.r[11].s64 + -18176;
	// 821A2B98: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A2B9C: ECEC0372  fmuls f7, f12, f13
	ctx.f[7].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A2BA0: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A2BA4: ECCC0372  fmuls f6, f12, f13
	ctx.f[6].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A2BA8: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A2BAC: ECAC0372  fmuls f5, f12, f13
	ctx.f[5].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A2BB0: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A2BB4: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A2BB8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A2BBC: EDAB383A  fmadds f13, f11, f0, f7
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 821A2BC0: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821A2BC4: ED6A303A  fmadds f11, f10, f0, f6
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64);
	// 821A2BC8: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821A2BCC: ED69283A  fmadds f11, f9, f0, f5
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[5].f64) as f32) as f64);
	// 821A2BD0: D1610054  stfs f11, 0x54(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821A2BD4: EC08603A  fmadds f0, f8, f0, f12
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A2BD8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821A2BDC: C00B2150  lfs f0, 0x2150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8528 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A2BE0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821A2BE4: 4198003C  blt cr6, 0x821a2c20
	if ctx.cr[6].lt {
	pc = 0x821A2C20; continue 'dispatch;
	}
	// 821A2BE8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A2BEC: 3D0082C0  lis r8, -0x7d40
	ctx.r[8].s64 = -2101346304;
	// 821A2BF0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821A2BF4: 3D4082D0  lis r10, -0x7d30
	ctx.r[10].s64 = -2100297728;
	// 821A2BF8: 394ABFC0  addi r10, r10, -0x4040
	ctx.r[10].s64 = ctx.r[10].s64 + -16448;
	// 821A2BFC: 9128BA9C  stw r9, -0x4564(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(-17764 as u32), ctx.r[9].u32 ) };
	// 821A2C00: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A2C04: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821A2C08: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821A2C0C: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821A2C10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A2C14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A2C18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A2C1C: 4E800020  blr
	return;
	// 821A2C20: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 821A2C24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A2C28: 916ABA9C  stw r11, -0x4564(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17764 as u32), ctx.r[11].u32 ) };
	// 821A2C2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A2C30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A2C34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A2C38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A2C40 size=24
    let mut pc: u32 = 0x821A2C40;
    'dispatch: loop {
        match pc {
            0x821A2C40 => {
    //   block [0x821A2C40..0x821A2C58)
	// 821A2C40: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A2C44: E96BCB20  ld r11, -0x34e0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-13536 as u32) ) };
	// 821A2C48: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821A2C4C: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821A2C50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A2C54: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A2C58 size=16
    let mut pc: u32 = 0x821A2C58;
    'dispatch: loop {
        match pc {
            0x821A2C58 => {
    //   block [0x821A2C58..0x821A2C68)
	// 821A2C58: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A2C5C: 8121FFF0  lwz r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 821A2C60: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A2C64: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A2C68 size=8
    let mut pc: u32 = 0x821A2C68;
    'dispatch: loop {
        match pc {
            0x821A2C68 => {
    //   block [0x821A2C68..0x821A2C70)
	// 821A2C68: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821A2C6C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A2C70 size=48
    let mut pc: u32 = 0x821A2C70;
    'dispatch: loop {
        match pc {
            0x821A2C70 => {
    //   block [0x821A2C70..0x821A2CA0)
	// 821A2C70: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 821A2C74: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A2C78: 3D0082C0  lis r8, -0x7d40
	ctx.r[8].s64 = -2101346304;
	// 821A2C7C: 396BB900  addi r11, r11, -0x4700
	ctx.r[11].s64 = ctx.r[11].s64 + -18176;
	// 821A2C80: 3D4082D0  lis r10, -0x7d30
	ctx.r[10].s64 = -2100297728;
	// 821A2C84: 394ABFC0  addi r10, r10, -0x4040
	ctx.r[10].s64 = ctx.r[10].s64 + -16448;
	// 821A2C88: 9128BA9C  stw r9, -0x4564(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(-17764 as u32), ctx.r[9].u32 ) };
	// 821A2C8C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A2C90: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821A2C94: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821A2C98: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821A2C9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A2CA0 size=524
    let mut pc: u32 = 0x821A2CA0;
    'dispatch: loop {
        match pc {
            0x821A2CA0 => {
    //   block [0x821A2CA0..0x821A2EAC)
	// 821A2CA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2CA4: 4839240D  bl 0x825350b0
	ctx.lr = 0x821A2CA8;
	sub_82535080(ctx, base);
	// 821A2CA8: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 821A2CAC: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 821A2CB0: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821A2CB4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A2CB8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821A2CBC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821A2CC0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821A2CC4: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 821A2CC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821A2CCC: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 821A2CD0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821A2CD4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A2CD8: FB5C0000  std r26, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[26].u64 ) };
	// 821A2CDC: 419A01B4  beq cr6, 0x821a2e90
	if ctx.cr[6].eq {
	pc = 0x821A2E90; continue 'dispatch;
	}
	// 821A2CE0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A2CE4: 419A01AC  beq cr6, 0x821a2e90
	if ctx.cr[6].eq {
	pc = 0x821A2E90; continue 'dispatch;
	}
	// 821A2CE8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A2CEC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821A2CF0: 396B4A00  addi r11, r11, 0x4a00
	ctx.r[11].s64 = ctx.r[11].s64 + 18944;
	// 821A2CF4: 38EA0D4C  addi r7, r10, 0xd4c
	ctx.r[7].s64 = ctx.r[10].s64 + 3404;
	// 821A2CF8: 394B0470  addi r10, r11, 0x470
	ctx.r[10].s64 = ctx.r[11].s64 + 1136;
	// 821A2CFC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A2D00: 3FBF0002  addis r29, r31, 2
	ctx.r[29].s64 = ctx.r[31].s64 + 131072;
	// 821A2D04: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A2D08: 3BBDBE64  addi r29, r29, -0x419c
	ctx.r[29].s64 = ctx.r[29].s64 + -16796;
	// 821A2D0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A2D10: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A2D14: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 821A2D18: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A2D1C: 897D0000  lbz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A2D20: 1D6B03C0  mulli r11, r11, 0x3c0
	ctx.r[11].s64 = ctx.r[11].s64 * 960;
	// 821A2D24: 7F6B5214  add r27, r11, r10
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A2D28: 481C7769  bl 0x8236a490
	ctx.lr = 0x821A2D2C;
	sub_8236A490(ctx, base);
	// 821A2D2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A2D30: 419A000C  beq cr6, 0x821a2d3c
	if ctx.cr[6].eq {
	pc = 0x821A2D3C; continue 'dispatch;
	}
	// 821A2D34: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A2D38: 48000008  b 0x821a2d40
	pc = 0x821A2D40; continue 'dispatch;
	// 821A2D3C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821A2D40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A2D44: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A2D48: 907C0004  stw r3, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821A2D4C: 419A005C  beq cr6, 0x821a2da8
	if ctx.cr[6].eq {
	pc = 0x821A2DA8; continue 'dispatch;
	}
	// 821A2D50: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A2D54: FCC0F090  fmr f6, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[6].f64 = ctx.f[30].f64;
	// 821A2D58: FC80E890  fmr f4, f29
	ctx.f[4].f64 = ctx.f[29].f64;
	// 821A2D5C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821A2D60: C0EB1FF8  lfs f7, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A2D64: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A2D68: FCA03890  fmr f5, f7
	ctx.f[5].f64 = ctx.f[7].f64;
	// 821A2D6C: FC603890  fmr f3, f7
	ctx.f[3].f64 = ctx.f[7].f64;
	// 821A2D70: C02BBA38  lfs f1, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A2D74: 4BFFFA7D  bl 0x821a27f0
	ctx.lr = 0x821A2D78;
	sub_821A27F0(ctx, base);
	// 821A2D78: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A2D7C: 93E300E0  stw r31, 0xe0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), ctx.r[31].u32 ) };
	// 821A2D80: 392300C0  addi r9, r3, 0xc0
	ctx.r[9].s64 = ctx.r[3].s64 + 192;
	// 821A2D84: 394B0DAC  addi r10, r11, 0xdac
	ctx.r[10].s64 = ctx.r[11].s64 + 3500;
	// 821A2D88: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821A2D8C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821A2D90: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A2D94: E95E0000  ld r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 821A2D98: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 821A2D9C: E95E0008  ld r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 821A2DA0: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821A2DA4: 48000008  b 0x821a2dac
	pc = 0x821A2DAC; continue 'dispatch;
	// 821A2DA8: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 821A2DAC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A2DB0: 895D0000  lbz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A2DB4: 38EBCA00  addi r7, r11, -0x3600
	ctx.r[7].s64 = ctx.r[11].s64 + -13824;
	// 821A2DB8: 554B183E  rotlwi r11, r10, 3
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A2DBC: 7D6B382A  ldx r11, r11, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) };
	// 821A2DC0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A2DC4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A2DC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A2DCC: 419A0058  beq cr6, 0x821a2e24
	if ctx.cr[6].eq {
	pc = 0x821A2E24; continue 'dispatch;
	}
	// 821A2DD0: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A2DD4: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A2DD8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A2DDC: 409A0048  bne cr6, 0x821a2e24
	if !ctx.cr[6].eq {
	pc = 0x821A2E24; continue 'dispatch;
	}
	// 821A2DE0: 394B00D0  addi r10, r11, 0xd0
	ctx.r[10].s64 = ctx.r[11].s64 + 208;
	// 821A2DE4: 392900D0  addi r9, r9, 0xd0
	ctx.r[9].s64 = ctx.r[9].s64 + 208;
	// 821A2DE8: E8CA0000  ld r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821A2DEC: F8C90000  std r6, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 821A2DF0: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821A2DF4: F9490008  std r10, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821A2DF8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A2DFC: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A2E00: 409A003C  bne cr6, 0x821a2e3c
	if !ctx.cr[6].eq {
	pc = 0x821A2E3C; continue 'dispatch;
	}
	// 821A2E04: A14B0014  lhz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A2E08: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 821A2E0C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821A2E10: 614A8000  ori r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 32768;
	// 821A2E14: 992B0019  stb r9, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[9].u8 ) };
	// 821A2E18: 990B0025  stb r8, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[8].u8 ) };
	// 821A2E1C: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 821A2E20: 4800001C  b 0x821a2e3c
	pc = 0x821A2E3C; continue 'dispatch;
	// 821A2E24: 397B0050  addi r11, r27, 0x50
	ctx.r[11].s64 = ctx.r[27].s64 + 80;
	// 821A2E28: 394900D0  addi r10, r9, 0xd0
	ctx.r[10].s64 = ctx.r[9].s64 + 208;
	// 821A2E2C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A2E30: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821A2E34: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821A2E38: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821A2E3C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A2E40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A2E44: 419A0014  beq cr6, 0x821a2e58
	if ctx.cr[6].eq {
	pc = 0x821A2E58; continue 'dispatch;
	}
	// 821A2E48: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A2E4C: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A2E50: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A2E54: 419A0008  beq cr6, 0x821a2e5c
	if ctx.cr[6].eq {
	pc = 0x821A2E5C; continue 'dispatch;
	}
	// 821A2E58: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821A2E5C: 395B0050  addi r10, r27, 0x50
	ctx.r[10].s64 = ctx.r[27].s64 + 80;
	// 821A2E60: E93C0000  ld r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 821A2E64: 390B00B0  addi r8, r11, 0xb0
	ctx.r[8].s64 = ctx.r[11].s64 + 176;
	// 821A2E68: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821A2E6C: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 821A2E70: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A2E74: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 821A2E78: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821A2E7C: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821A2E80: 897D0000  lbz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A2E84: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821A2E88: 7D2B392A  stdx r9, r11, r7
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), ctx.r[9].u64) };
	// 821A2E8C: 48000008  b 0x821a2e94
	pc = 0x821A2E94; continue 'dispatch;
	// 821A2E90: FB5C0000  std r26, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[26].u64 ) };
	// 821A2E94: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821A2E98: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821A2E9C: CBA1FFB0  lfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 821A2EA0: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821A2EA4: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821A2EA8: 48392258  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A2EB0 size=184
    let mut pc: u32 = 0x821A2EB0;
    'dispatch: loop {
        match pc {
            0x821A2EB0 => {
    //   block [0x821A2EB0..0x821A2F68)
	// 821A2EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2EB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A2EB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A2EBC: 4BFFF9C5  bl 0x821a2880
	ctx.lr = 0x821A2EC0;
	sub_821A2880(ctx, base);
	// 821A2EC0: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A2EC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A2EC8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 821A2ECC: 4199008C  bgt cr6, 0x821a2f58
	if ctx.cr[6].gt {
	pc = 0x821A2F58; continue 'dispatch;
	}
	// 821A2ED0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A2ED4: C0030088  lfs f0, 0x88(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A2ED8: C18300D0  lfs f12, 0xd0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A2EDC: 812300E0  lwz r9, 0xe0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(224 as u32) ) } as u64;
	// 821A2EE0: 6168BE64  ori r8, r11, 0xbe64
	ctx.r[8].u64 = ctx.r[11].u64 | 48740;
	// 821A2EE4: C16300D4  lfs f11, 0xd4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A2EE8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A2EEC: C14300D8  lfs f10, 0xd8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(216 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A2EF0: C12300C0  lfs f9, 0xc0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A2EF4: C10300C4  lfs f8, 0xc4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821A2EF8: C0E300C8  lfs f7, 0xc8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A2EFC: 7D0940AE  lbzx r8, r9, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821A2F00: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A2F04: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A2F08: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821A2F0C: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821A2F10: 394B4A00  addi r10, r11, 0x4a00
	ctx.r[10].s64 = ctx.r[11].s64 + 18944;
	// 821A2F14: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821A2F18: 392A04C0  addi r9, r10, 0x4c0
	ctx.r[9].s64 = ctx.r[10].s64 + 1216;
	// 821A2F1C: 1D4803C0  mulli r10, r8, 0x3c0
	ctx.r[10].s64 = ctx.r[8].s64 * 960;
	// 821A2F20: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 821A2F24: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A2F28: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821A2F2C: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A2F30: ED89603A  fmadds f12, f9, f0, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A2F34: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821A2F38: ED88583A  fmadds f12, f8, f0, f11
	ctx.f[12].f64 = (((ctx.f[8].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A2F3C: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821A2F40: EC07683A  fmadds f0, f7, f0, f13
	ctx.f[0].f64 = (((ctx.f[7].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 821A2F44: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821A2F48: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A2F4C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821A2F50: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821A2F54: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821A2F58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A2F5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A2F60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A2F64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A2F68 size=48
    let mut pc: u32 = 0x821A2F68;
    'dispatch: loop {
        match pc {
            0x821A2F68 => {
    //   block [0x821A2F68..0x821A2F98)
	// 821A2F68: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A2F6C: 814300E0  lwz r10, 0xe0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(224 as u32) ) } as u64;
	// 821A2F70: 6169BE64  ori r9, r11, 0xbe64
	ctx.r[9].u64 = ctx.r[11].u64 | 48740;
	// 821A2F74: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A2F78: 396BCA00  addi r11, r11, -0x3600
	ctx.r[11].s64 = ctx.r[11].s64 + -13824;
	// 821A2F7C: 7D2A48AE  lbzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A2F80: 552A183E  rotlwi r10, r9, 3
	ctx.r[10].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821A2F84: 7D6A582A  ldx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	// 821A2F88: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821A2F8C: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821A2F90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A2F94: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A2F98 size=16
    let mut pc: u32 = 0x821A2F98;
    'dispatch: loop {
        match pc {
            0x821A2F98 => {
    //   block [0x821A2F98..0x821A2FA8)
	// 821A2F98: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A2F9C: 8101FFF0  lwz r8, -0x10(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 821A2FA0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A2FA4: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A2FA8 size=8
    let mut pc: u32 = 0x821A2FA8;
    'dispatch: loop {
        match pc {
            0x821A2FA8 => {
    //   block [0x821A2FA8..0x821A2FB0)
	// 821A2FA8: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821A2FAC: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A2FB0 size=44
    let mut pc: u32 = 0x821A2FB0;
    'dispatch: loop {
        match pc {
            0x821A2FB0 => {
    //   block [0x821A2FB0..0x821A2FDC)
	// 821A2FB0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A2FB4: 1D2903C0  mulli r9, r9, 0x3c0
	ctx.r[9].s64 = ctx.r[9].s64 * 960;
	// 821A2FB8: 394B4A00  addi r10, r11, 0x4a00
	ctx.r[10].s64 = ctx.r[11].s64 + 18944;
	// 821A2FBC: 396300D0  addi r11, r3, 0xd0
	ctx.r[11].s64 = ctx.r[3].s64 + 208;
	// 821A2FC0: 394A04C0  addi r10, r10, 0x4c0
	ctx.r[10].s64 = ctx.r[10].s64 + 1216;
	// 821A2FC4: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821A2FC8: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A2FCC: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821A2FD0: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821A2FD4: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821A2FD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A2FE0 size=696
    let mut pc: u32 = 0x821A2FE0;
    'dispatch: loop {
        match pc {
            0x821A2FE0 => {
    //   block [0x821A2FE0..0x821A3298)
	// 821A2FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2FE4: 483920CD  bl 0x825350b0
	ctx.lr = 0x821A2FE8;
	sub_82535080(ctx, base);
	// 821A2FE8: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 821A2FEC: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 821A2FF0: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821A2FF4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A2FF8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821A2FFC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821A3000: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821A3004: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 821A3008: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821A300C: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 821A3010: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821A3014: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821A3018: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821A301C: FB7A0000  std r27, 0(r26)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 821A3020: 419A025C  beq cr6, 0x821a327c
	if ctx.cr[6].eq {
	pc = 0x821A327C; continue 'dispatch;
	}
	// 821A3024: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A3028: 419A0254  beq cr6, 0x821a327c
	if ctx.cr[6].eq {
	pc = 0x821A327C; continue 'dispatch;
	}
	// 821A302C: 2B1C0007  cmplwi cr6, r28, 7
	ctx.cr[6].compare_u32(ctx.r[28].u32, 7 as u32, &mut ctx.xer);
	// 821A3030: 4199024C  bgt cr6, 0x821a327c
	if ctx.cr[6].gt {
	pc = 0x821A327C; continue 'dispatch;
	}
	// 821A3034: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A3038: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A303C: 38EB0D54  addi r7, r11, 0xd54
	ctx.r[7].s64 = ctx.r[11].s64 + 3412;
	// 821A3040: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A3044: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A3048: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A304C: 386000D8  li r3, 0xd8
	ctx.r[3].s64 = 216;
	// 821A3050: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A3054: 481C743D  bl 0x8236a490
	ctx.lr = 0x821A3058;
	sub_8236A490(ctx, base);
	// 821A3058: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A305C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A3060: 419A000C  beq cr6, 0x821a306c
	if ctx.cr[6].eq {
	pc = 0x821A306C; continue 'dispatch;
	}
	// 821A3064: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A3068: 48000008  b 0x821a3070
	pc = 0x821A3070; continue 'dispatch;
	// 821A306C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821A3070: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A3074: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A3078: 93DA0004  stw r30, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821A307C: 419A0204  beq cr6, 0x821a3280
	if ctx.cr[6].eq {
	pc = 0x821A3280; continue 'dispatch;
	}
	// 821A3080: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A3084: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821A3088: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A308C: FCC0F090  fmr f6, f30
	ctx.f[6].f64 = ctx.f[30].f64;
	// 821A3090: FC80E890  fmr f4, f29
	ctx.f[4].f64 = ctx.f[29].f64;
	// 821A3094: C0EB1FF8  lfs f7, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A3098: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A309C: FCA03890  fmr f5, f7
	ctx.f[5].f64 = ctx.f[7].f64;
	// 821A30A0: FC603890  fmr f3, f7
	ctx.f[3].f64 = ctx.f[7].f64;
	// 821A30A4: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A30A8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A30AC: 4BFFF745  bl 0x821a27f0
	ctx.lr = 0x821A30B0;
	sub_821A27F0(ctx, base);
	// 821A30B0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821A30B4: 397E00C4  addi r11, r30, 0xc4
	ctx.r[11].s64 = ctx.r[30].s64 + 196;
	// 821A30B8: 394A0DCC  addi r10, r10, 0xdcc
	ctx.r[10].s64 = ctx.r[10].s64 + 3532;
	// 821A30BC: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 821A30C0: 38C00007  li r6, 7
	ctx.r[6].s64 = 7;
	// 821A30C4: 38E90D5C  addi r7, r9, 0xd5c
	ctx.r[7].s64 = ctx.r[9].s64 + 3420;
	// 821A30C8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A30CC: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A30D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A30D4: FB7E00B0  std r27, 0xb0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 821A30D8: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 821A30DC: 93BE00B8  stw r29, 0xb8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(184 as u32), ctx.r[29].u32 ) };
	// 821A30E0: 939E00BC  stw r28, 0xbc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(188 as u32), ctx.r[28].u32 ) };
	// 821A30E4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A30E8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A30EC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A30F0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A30F4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A30F8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821A30FC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A3100: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821A3104: 481C738D  bl 0x8236a490
	ctx.lr = 0x821A3108;
	sub_8236A490(ctx, base);
	// 821A3108: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A310C: 419A000C  beq cr6, 0x821a3118
	if ctx.cr[6].eq {
	pc = 0x821A3118; continue 'dispatch;
	}
	// 821A3110: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A3114: 48000008  b 0x821a311c
	pc = 0x821A311C; continue 'dispatch;
	// 821A3118: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821A311C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A3120: 917E00B0  stw r11, 0xb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 821A3124: 907E00B4  stw r3, 0xb4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(180 as u32), ctx.r[3].u32 ) };
	// 821A3128: 419A0118  beq cr6, 0x821a3240
	if ctx.cr[6].eq {
	pc = 0x821A3240; continue 'dispatch;
	}
	// 821A312C: 4BFFDF45  bl 0x821a1070
	ctx.lr = 0x821A3130;
	sub_821A1070(ctx, base);
	// 821A3130: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A3134: 419A010C  beq cr6, 0x821a3240
	if ctx.cr[6].eq {
	pc = 0x821A3240; continue 'dispatch;
	}
	// 821A3138: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A313C: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3140: 38830080  addi r4, r3, 0x80
	ctx.r[4].s64 = ctx.r[3].s64 + 128;
	// 821A3144: 386B4A00  addi r3, r11, 0x4a00
	ctx.r[3].s64 = ctx.r[11].s64 + 18944;
	// 821A3148: 39640070  addi r11, r4, 0x70
	ctx.r[11].s64 = ctx.r[4].s64 + 112;
	// 821A314C: 39440080  addi r10, r4, 0x80
	ctx.r[10].s64 = ctx.r[4].s64 + 128;
	// 821A3150: 3FBD0002  addis r29, r29, 2
	ctx.r[29].s64 = ctx.r[29].s64 + 131072;
	// 821A3154: 211C0008  subfic r8, r28, 8
	ctx.xer.ca = ctx.r[28].u32 <= 8 as u32;
	ctx.r[8].s64 = (8 as i64) - ctx.r[28].s64;
	// 821A3158: 3920EFEC  li r9, -0x1014
	ctx.r[9].s64 = -4116;
	// 821A315C: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821A3160: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821A3164: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A3168: 3BBDBE64  addi r29, r29, -0x419c
	ctx.r[29].s64 = ctx.r[29].s64 + -16796;
	// 821A316C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A3170: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821A3174: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A3178: 90EB0008  stw r7, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821A317C: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A3180: 90EB000C  stw r7, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 821A3184: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3188: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A318C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A3190: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821A3194: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A3198: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821A319C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A31A0: D3E40090  stfs f31, 0x90(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821A31A4: 9B640021  stb r27, 0x21(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(33 as u32), ctx.r[27].u8 ) };
	// 821A31A8: B1240022  sth r9, 0x22(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(34 as u32), ctx.r[9].u16 ) };
	// 821A31AC: 9904001F  stb r8, 0x1f(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(31 as u32), ctx.r[8].u8 ) };
	// 821A31B0: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 821A31B4: 897D0000  lbz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A31B8: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 821A31BC: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821A31C0: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A31C4: 38AB0002  addi r5, r11, 2
	ctx.r[5].s64 = ctx.r[11].s64 + 2;
	// 821A31C8: 481DB001  bl 0x8237e1c8
	ctx.lr = 0x821A31CC;
	sub_8237E1C8(ctx, base);
	// 821A31CC: 907E00C0  stw r3, 0xc0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(192 as u32), ctx.r[3].u32 ) };
	// 821A31D0: 895D0000  lbz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A31D4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A31D8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A31DC: 396BCA20  addi r11, r11, -0x35e0
	ctx.r[11].s64 = ctx.r[11].s64 + -13792;
	// 821A31E0: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 821A31E4: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A31E8: 7D4A582A  ldx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	// 821A31EC: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821A31F0: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A31F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A31F8: 419A002C  beq cr6, 0x821a3224
	if ctx.cr[6].eq {
	pc = 0x821A3224; continue 'dispatch;
	}
	// 821A31FC: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A3200: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A3204: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A3208: 409A001C  bne cr6, 0x821a3224
	if !ctx.cr[6].eq {
	pc = 0x821A3224; continue 'dispatch;
	}
	// 821A320C: A12A0014  lhz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A3210: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 821A3214: 9B6A0025  stb r27, 0x25(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(37 as u32), ctx.r[27].u8 ) };
	// 821A3218: 61298000  ori r9, r9, 0x8000
	ctx.r[9].u64 = ctx.r[9].u64 | 32768;
	// 821A321C: 990A0019  stb r8, 0x19(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(25 as u32), ctx.r[8].u8 ) };
	// 821A3220: B12A0014  sth r9, 0x14(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[9].u16 ) };
	// 821A3224: 895D0000  lbz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3228: E93A0000  ld r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	// 821A322C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A3230: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 821A3234: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A3238: 7D2A592A  stdx r9, r10, r11
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u64) };
	// 821A323C: 48000044  b 0x821a3280
	pc = 0x821A3280; continue 'dispatch;
	// 821A3240: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A3244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A3248: 419A0038  beq cr6, 0x821a3280
	if ctx.cr[6].eq {
	pc = 0x821A3280; continue 'dispatch;
	}
	// 821A324C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A3250: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3254: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A3258: 409A0028  bne cr6, 0x821a3280
	if !ctx.cr[6].eq {
	pc = 0x821A3280; continue 'dispatch;
	}
	// 821A325C: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A3260: A10B0014  lhz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A3264: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A3268: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A326C: 610A8000  ori r10, r8, 0x8000
	ctx.r[10].u64 = ctx.r[8].u64 | 32768;
	// 821A3270: 992B0025  stb r9, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[9].u8 ) };
	// 821A3274: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 821A3278: 48000008  b 0x821a3280
	pc = 0x821A3280; continue 'dispatch;
	// 821A327C: FB7A0000  std r27, 0(r26)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 821A3280: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821A3284: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821A3288: CBA1FFB0  lfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 821A328C: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821A3290: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821A3294: 48391E6C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A3298 size=120
    let mut pc: u32 = 0x821A3298;
    'dispatch: loop {
        match pc {
            0x821A3298 => {
    //   block [0x821A3298..0x821A3310)
	// 821A3298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A329C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A32A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A32A4: 4BFFF5DD  bl 0x821a2880
	ctx.lr = 0x821A32A8;
	sub_821A2880(ctx, base);
	// 821A32A8: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A32AC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A32B0: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 821A32B4: 4199004C  bgt cr6, 0x821a3300
	if ctx.cr[6].gt {
	pc = 0x821A3300; continue 'dispatch;
	}
	// 821A32B8: 816300B4  lwz r11, 0xb4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(180 as u32) ) } as u64;
	// 821A32BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A32C0: 419A0014  beq cr6, 0x821a32d4
	if ctx.cr[6].eq {
	pc = 0x821A32D4; continue 'dispatch;
	}
	// 821A32C4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A32C8: 812300B0  lwz r9, 0xb0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A32CC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A32D0: 419A0008  beq cr6, 0x821a32d8
	if ctx.cr[6].eq {
	pc = 0x821A32D8; continue 'dispatch;
	}
	// 821A32D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A32D8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821A32DC: C1A30088  lfs f13, 0x88(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A32E0: C00ABA38  lfs f0, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A32E4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821A32E8: D00B0110  stfs f0, 0x110(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 821A32EC: C00300CC  lfs f0, 0xcc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A32F0: C1A30088  lfs f13, 0x88(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A32F4: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A32F8: D00B00F8  stfs f0, 0xf8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 821A32FC: D00B0108  stfs f0, 0x108(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 821A3300: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A3304: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A3308: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A330C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3310 size=12
    let mut pc: u32 = 0x821A3310;
    'dispatch: loop {
        match pc {
            0x821A3310 => {
    //   block [0x821A3310..0x821A331C)
	// 821A3310: 816300B4  lwz r11, 0xb4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(180 as u32) ) } as u64;
	// 821A3314: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A3318: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A331C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A331C size=16
    let mut pc: u32 = 0x821A331C;
    'dispatch: loop {
        match pc {
            0x821A331C => {
    //   block [0x821A331C..0x821A332C)
	// 821A331C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A3320: 814300B0  lwz r10, 0xb0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A3324: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A3328: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A332C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A332C size=12
    let mut pc: u32 = 0x821A332C;
    'dispatch: loop {
        match pc {
            0x821A332C => {
    //   block [0x821A332C..0x821A3338)
	// 821A332C: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 821A3330: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A3334: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3338 size=80
    let mut pc: u32 = 0x821A3338;
    'dispatch: loop {
        match pc {
            0x821A3338 => {
    //   block [0x821A3338..0x821A3388)
	// 821A3338: 814300B4  lwz r10, 0xb4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(180 as u32) ) } as u64;
	// 821A333C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A3340: 419A0014  beq cr6, 0x821a3354
	if ctx.cr[6].eq {
	pc = 0x821A3354; continue 'dispatch;
	}
	// 821A3344: 816A0030  lwz r11, 0x30(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A3348: 812300B0  lwz r9, 0xb0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A334C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A3350: 419A0008  beq cr6, 0x821a3358
	if ctx.cr[6].eq {
	pc = 0x821A3358; continue 'dispatch;
	}
	// 821A3354: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A3358: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A335C: 812300B8  lwz r9, 0xb8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(184 as u32) ) } as u64;
	// 821A3360: 388A0080  addi r4, r10, 0x80
	ctx.r[4].s64 = ctx.r[10].s64 + 128;
	// 821A3364: 6168BE64  ori r8, r11, 0xbe64
	ctx.r[8].u64 = ctx.r[11].u64 | 48740;
	// 821A3368: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A336C: 386B4A00  addi r3, r11, 0x4a00
	ctx.r[3].s64 = ctx.r[11].s64 + 18944;
	// 821A3370: 7D6940AE  lbzx r11, r9, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821A3374: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 821A3378: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821A337C: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A3380: 38AB0002  addi r5, r11, 2
	ctx.r[5].s64 = ctx.r[11].s64 + 2;
	// 821A3384: 481DB09C  b 0x8237e420
	sub_8237E420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3388 size=4
    let mut pc: u32 = 0x821A3388;
    'dispatch: loop {
        match pc {
            0x821A3388 => {
    //   block [0x821A3388..0x821A338C)
	// 821A3388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3390 size=164
    let mut pc: u32 = 0x821A3390;
    'dispatch: loop {
        match pc {
            0x821A3390 => {
    //   block [0x821A3390..0x821A3434)
	// 821A3390: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821A3394: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A3398: 419A0094  beq cr6, 0x821a342c
	if ctx.cr[6].eq {
	pc = 0x821A342C; continue 'dispatch;
	}
	// 821A339C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A33A0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A33A4: 419A0088  beq cr6, 0x821a342c
	if ctx.cr[6].eq {
	pc = 0x821A342C; continue 'dispatch;
	}
	// 821A33A8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A33AC: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 821A33B0: 390BCA20  addi r8, r11, -0x35e0
	ctx.r[8].s64 = ctx.r[11].s64 + -13792;
	// 821A33B4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A33B8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A33BC: 6169BE64  ori r9, r11, 0xbe64
	ctx.r[9].u64 = ctx.r[11].u64 | 48740;
	// 821A33C0: 2F0A0008  cmpwi cr6, r10, 8
	ctx.cr[6].compare_i32(ctx.r[10].s32, 8, &mut ctx.xer);
	// 821A33C4: 40980068  bge cr6, 0x821a342c
	if !ctx.cr[6].lt {
	pc = 0x821A342C; continue 'dispatch;
	}
	// 821A33C8: 548B07FE  clrlwi r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 821A33CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A33D0: 419A004C  beq cr6, 0x821a341c
	if ctx.cr[6].eq {
	pc = 0x821A341C; continue 'dispatch;
	}
	// 821A33D4: 7D6348AE  lbzx r11, r3, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A33D8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821A33DC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A33E0: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A33E4: 7D6B402A  ldx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	// 821A33E8: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821A33EC: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821A33F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A33F4: 419A0028  beq cr6, 0x821a341c
	if ctx.cr[6].eq {
	pc = 0x821A341C; continue 'dispatch;
	}
	// 821A33F8: 80AB0030  lwz r5, 0x30(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A33FC: 83E1FFF0  lwz r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 821A3400: 7F05F840  cmplw cr6, r5, r31
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821A3404: 409A0018  bne cr6, 0x821a341c
	if !ctx.cr[6].eq {
	pc = 0x821A341C; continue 'dispatch;
	}
	// 821A3408: A0AB0014  lhz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A340C: 98CB0019  stb r6, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[6].u8 ) };
	// 821A3410: 60A58000  ori r5, r5, 0x8000
	ctx.r[5].u64 = ctx.r[5].u64 | 32768;
	// 821A3414: 98EB0025  stb r7, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[7].u8 ) };
	// 821A3418: B0AB0014  sth r5, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[5].u16 ) };
	// 821A341C: 5484F87E  srwi r4, r4, 1
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shr(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A3420: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A3424: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A3428: 409AFF98  bne cr6, 0x821a33c0
	if !ctx.cr[6].eq {
	pc = 0x821A33C0; continue 'dispatch;
	}
	// 821A342C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821A3430: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A3438 size=312
    let mut pc: u32 = 0x821A3438;
    'dispatch: loop {
        match pc {
            0x821A3438 => {
    //   block [0x821A3438..0x821A3570)
	// 821A3438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A343C: 48391C81  bl 0x825350bc
	ctx.lr = 0x821A3440;
	sub_82535080(ctx, base);
	// 821A3440: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A3444: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A3448: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821A344C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821A3450: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A3454: FBDD0000  std r30, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821A3458: 419A0108  beq cr6, 0x821a3560
	if ctx.cr[6].eq {
	pc = 0x821A3560; continue 'dispatch;
	}
	// 821A345C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A3460: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A3464: 38EB0D64  addi r7, r11, 0xd64
	ctx.r[7].s64 = ctx.r[11].s64 + 3428;
	// 821A3468: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A346C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A3470: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A3474: 386000B8  li r3, 0xb8
	ctx.r[3].s64 = 184;
	// 821A3478: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A347C: 481C7015  bl 0x8236a490
	ctx.lr = 0x821A3480;
	sub_8236A490(ctx, base);
	// 821A3480: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A3484: 419A000C  beq cr6, 0x821a3490
	if ctx.cr[6].eq {
	pc = 0x821A3490; continue 'dispatch;
	}
	// 821A3488: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A348C: 48000008  b 0x821a3494
	pc = 0x821A3494; continue 'dispatch;
	// 821A3490: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821A3494: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A3498: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A349C: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821A34A0: 419A004C  beq cr6, 0x821a34ec
	if ctx.cr[6].eq {
	pc = 0x821A34EC; continue 'dispatch;
	}
	// 821A34A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A34A8: C0EB2068  lfs f7, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A34AC: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821A34B0: FC403890  fmr f2, f7
	ctx.f[2].f64 = ctx.f[7].f64;
	// 821A34B4: C0CBD4CC  lfs f6, -0x2b34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11060 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821A34B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A34BC: C0ABBA38  lfs f5, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821A34C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821A34C4: FC602890  fmr f3, f5
	ctx.f[3].f64 = ctx.f[5].f64;
	// 821A34C8: C08B2934  lfs f4, 0x2934(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10548 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 821A34CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A34D0: C02B1FF8  lfs f1, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A34D4: 4BFFF31D  bl 0x821a27f0
	ctx.lr = 0x821A34D8;
	sub_821A27F0(ctx, base);
	// 821A34D8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A34DC: 93E300B0  stw r31, 0xb0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 821A34E0: 93C300B4  stw r30, 0xb4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), ctx.r[30].u32 ) };
	// 821A34E4: 396B0DEC  addi r11, r11, 0xdec
	ctx.r[11].s64 = ctx.r[11].s64 + 3564;
	// 821A34E8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A34EC: 3D5F0002  addis r10, r31, 2
	ctx.r[10].s64 = ctx.r[31].s64 + 131072;
	// 821A34F0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A34F4: 394ABE64  addi r10, r10, -0x419c
	ctx.r[10].s64 = ctx.r[10].s64 + -16796;
	// 821A34F8: 396BC9E0  addi r11, r11, -0x3620
	ctx.r[11].s64 = ctx.r[11].s64 + -13856;
	// 821A34FC: 892A0000  lbz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3500: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821A3504: 7D29582A  ldx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	// 821A3508: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821A350C: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A3510: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A3514: 419A0030  beq cr6, 0x821a3544
	if ctx.cr[6].eq {
	pc = 0x821A3544; continue 'dispatch;
	}
	// 821A3518: 81090030  lwz r8, 0x30(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A351C: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A3520: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821A3524: 409A0020  bne cr6, 0x821a3544
	if !ctx.cr[6].eq {
	pc = 0x821A3544; continue 'dispatch;
	}
	// 821A3528: A1090014  lhz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A352C: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 821A3530: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A3534: 61088000  ori r8, r8, 0x8000
	ctx.r[8].u64 = ctx.r[8].u64 | 32768;
	// 821A3538: 98E90019  stb r7, 0x19(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(25 as u32), ctx.r[7].u8 ) };
	// 821A353C: 98C90025  stb r6, 0x25(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(37 as u32), ctx.r[6].u8 ) };
	// 821A3540: B1090014  sth r8, 0x14(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[8].u16 ) };
	// 821A3544: 894A0000  lbz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3548: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A354C: E93D0000  ld r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 821A3550: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A3554: 7D2A592A  stdx r9, r10, r11
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u64) };
	// 821A3558: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A355C: 48391BB0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
	// 821A3560: FBDD0000  std r30, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821A3564: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A3568: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A356C: 48391BA0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A3570 size=508
    let mut pc: u32 = 0x821A3570;
    'dispatch: loop {
        match pc {
            0x821A3570 => {
    //   block [0x821A3570..0x821A376C)
	// 821A3570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A3574: 48391B45  bl 0x825350b8
	ctx.lr = 0x821A3578;
	sub_82535080(ctx, base);
	// 821A3578: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821A357C: 48392A69  bl 0x82535fe4
	ctx.lr = 0x821A3580;
	sub_82535FB0(ctx, base);
	// 821A3580: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A3584: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A3588: C37F0088  lfs f27, 0x88(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821A358C: 4BFFF2F5  bl 0x821a2880
	ctx.lr = 0x821A3590;
	sub_821A2880(ctx, base);
	// 821A3590: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A3594: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A3598: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821A359C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A35A0: C38A1FF8  lfs f28, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821A35A4: 419A0020  beq cr6, 0x821a35c4
	if ctx.cr[6].eq {
	pc = 0x821A35C4; continue 'dispatch;
	}
	// 821A35A8: 409901B4  ble cr6, 0x821a375c
	if !ctx.cr[6].gt {
	pc = 0x821A375C; continue 'dispatch;
	}
	// 821A35AC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821A35B0: 409900E8  ble cr6, 0x821a3698
	if !ctx.cr[6].gt {
	pc = 0x821A3698; continue 'dispatch;
	}
	// 821A35B4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A35B8: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821A35BC: 48392A75  bl 0x82536030
	ctx.lr = 0x821A35C0;
	sub_82535FFC(ctx, base);
	// 821A35C0: 48391B48  b 0x82535108
	sub_825350D0(ctx, base);
	return;
	// 821A35C4: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 821A35C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A35CC: 409A00CC  bne cr6, 0x821a3698
	if !ctx.cr[6].eq {
	pc = 0x821A3698; continue 'dispatch;
	}
	// 821A35D0: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A35D4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A35D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A35DC: 419A0014  beq cr6, 0x821a35f0
	if ctx.cr[6].eq {
	pc = 0x821A35F0; continue 'dispatch;
	}
	// 821A35E0: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A35E4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A35E8: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A35EC: 419A000C  beq cr6, 0x821a35f8
	if ctx.cr[6].eq {
	pc = 0x821A35F8; continue 'dispatch;
	}
	// 821A35F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A35F4: 48000008  b 0x821a35fc
	pc = 0x821A35FC; continue 'dispatch;
	// 821A35F8: 386A0090  addi r3, r10, 0x90
	ctx.r[3].s64 = ctx.r[10].s64 + 144;
	// 821A35FC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A3600: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A3604: 419A0014  beq cr6, 0x821a3618
	if ctx.cr[6].eq {
	pc = 0x821A3618; continue 'dispatch;
	}
	// 821A3608: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A360C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A3610: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A3614: 419A000C  beq cr6, 0x821a3620
	if ctx.cr[6].eq {
	pc = 0x821A3620; continue 'dispatch;
	}
	// 821A3618: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821A361C: 48000028  b 0x821a3644
	pc = 0x821A3644; continue 'dispatch;
	// 821A3620: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A3624: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A3628: 419A0014  beq cr6, 0x821a363c
	if ctx.cr[6].eq {
	pc = 0x821A363C; continue 'dispatch;
	}
	// 821A362C: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A3630: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A3634: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A3638: 419A0008  beq cr6, 0x821a3640
	if ctx.cr[6].eq {
	pc = 0x821A3640; continue 'dispatch;
	}
	// 821A363C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A3640: 3BAA0090  addi r29, r10, 0x90
	ctx.r[29].s64 = ctx.r[10].s64 + 144;
	// 821A3644: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A3648: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 821A364C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A3650: C14B2198  lfs f10, 0x2198(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8600 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A3654: 419A001C  beq cr6, 0x821a3670
	if ctx.cr[6].eq {
	pc = 0x821A3670; continue 'dispatch;
	}
	// 821A3658: C01F00A0  lfs f0, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A365C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A3660: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A3664: EC4002B2  fmuls f2, f0, f10
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 821A3668: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 821A366C: 4BFB1B8D  bl 0x821551f8
	ctx.lr = 0x821A3670;
	sub_821551F8(ctx, base);
	// 821A3670: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821A3674: 419A0020  beq cr6, 0x821a3694
	if ctx.cr[6].eq {
	pc = 0x821A3694; continue 'dispatch;
	}
	// 821A3678: C01F00A0  lfs f0, 0xa0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A367C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A3680: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A3684: EC4002B2  fmuls f2, f0, f10
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 821A3688: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A368C: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 821A3690: 4BFB1B69  bl 0x821551f8
	ctx.lr = 0x821A3694;
	sub_821551F8(ctx, base);
	// 821A3694: 939F00B4  stw r28, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[28].u32 ) };
	// 821A3698: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821A369C: C3FF0088  lfs f31, 0x88(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A36A0: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A36A4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A36A8: C3CABA38  lfs f30, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A36AC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A36B0: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 821A36B4: C3AA2074  lfs f29, 0x2074(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8308 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821A36B8: 419A0008  beq cr6, 0x821a36c0
	if ctx.cr[6].eq {
	pc = 0x821A36C0; continue 'dispatch;
	}
	// 821A36BC: EC3F0772  fmuls f1, f31, f29
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[29].f64) as f32) as f64);
	// 821A36C0: 3C6B0002  addis r3, r11, 2
	ctx.r[3].s64 = ctx.r[11].s64 + 131072;
	// 821A36C4: 3863CF2C  addi r3, r3, -0x30d4
	ctx.r[3].s64 = ctx.r[3].s64 + -12500;
	// 821A36C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A36CC: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821A36D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A36D4: 4E800421  bctrl
	ctx.lr = 0x821A36D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A36D8: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A36DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A36E0: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 821A36E4: 419A0008  beq cr6, 0x821a36ec
	if ctx.cr[6].eq {
	pc = 0x821A36EC; continue 'dispatch;
	}
	// 821A36E8: EC3F0772  fmuls f1, f31, f29
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[29].f64) as f32) as f64);
	// 821A36EC: 3C6B0002  addis r3, r11, 2
	ctx.r[3].s64 = ctx.r[11].s64 + 131072;
	// 821A36F0: 3863D044  addi r3, r3, -0x2fbc
	ctx.r[3].s64 = ctx.r[3].s64 + -12220;
	// 821A36F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A36F8: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821A36FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A3700: 4E800421  bctrl
	ctx.lr = 0x821A3704;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A3704: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A3708: FF1FE000  fcmpu cr6, f31, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[28].f64);
	// 821A370C: 3BCBC470  addi r30, r11, -0x3b90
	ctx.r[30].s64 = ctx.r[11].s64 + -15248;
	// 821A3710: 409A0024  bne cr6, 0x821a3734
	if !ctx.cr[6].eq {
	pc = 0x821A3734; continue 'dispatch;
	}
	// 821A3714: FF1BF800  fcmpu cr6, f27, f31
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[31].f64);
	// 821A3718: 419A001C  beq cr6, 0x821a3734
	if ctx.cr[6].eq {
	pc = 0x821A3734; continue 'dispatch;
	}
	// 821A371C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A3720: 809F00B0  lwz r4, 0xb0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A3724: 4BFFAB1D  bl 0x8219e240
	ctx.lr = 0x821A3728;
	sub_8219E240(ctx, base);
	// 821A3728: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A372C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A3730: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 821A3734: FF1BE000  fcmpu cr6, f27, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[28].f64);
	// 821A3738: 409A0024  bne cr6, 0x821a375c
	if !ctx.cr[6].eq {
	pc = 0x821A375C; continue 'dispatch;
	}
	// 821A373C: FF1BF800  fcmpu cr6, f27, f31
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[31].f64);
	// 821A3740: 419A001C  beq cr6, 0x821a375c
	if ctx.cr[6].eq {
	pc = 0x821A375C; continue 'dispatch;
	}
	// 821A3744: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A3748: 809F00B0  lwz r4, 0xb0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A374C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A3750: 4BFFACF1  bl 0x8219e440
	ctx.lr = 0x821A3754;
	sub_8219E440(ctx, base);
	// 821A3754: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A3758: 938B0018  stw r28, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[28].u32 ) };
	// 821A375C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A3760: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821A3764: 483928CD  bl 0x82536030
	ctx.lr = 0x821A3768;
	sub_82535FFC(ctx, base);
	// 821A3768: 483919A0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A3770 size=420
    let mut pc: u32 = 0x821A3770;
    'dispatch: loop {
        match pc {
            0x821A3770 => {
    //   block [0x821A3770..0x821A3914)
	// 821A3770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A3774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A3778: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A377C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A3780: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 821A3784: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 821A3788: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 821A378C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A3790: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A3794: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A3798: 6169BE64  ori r9, r11, 0xbe64
	ctx.r[9].u64 = ctx.r[11].u64 | 48740;
	// 821A379C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A37A0: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A37A4: 396BC9E0  addi r11, r11, -0x3620
	ctx.r[11].s64 = ctx.r[11].s64 + -13856;
	// 821A37A8: 7D2A48AE  lbzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A37AC: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821A37B0: 7D69582A  ldx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	// 821A37B4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A37B8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A37BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A37C0: 419A0130  beq cr6, 0x821a38f0
	if ctx.cr[6].eq {
	pc = 0x821A38F0; continue 'dispatch;
	}
	// 821A37C4: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A37C8: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A37CC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A37D0: 409A0120  bne cr6, 0x821a38f0
	if !ctx.cr[6].eq {
	pc = 0x821A38F0; continue 'dispatch;
	}
	// 821A37D4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821A37D8: 409A0118  bne cr6, 0x821a38f0
	if !ctx.cr[6].eq {
	pc = 0x821A38F0; continue 'dispatch;
	}
	// 821A37DC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A37E0: C3FF0094  lfs f31, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A37E4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A37E8: C3CBBA38  lfs f30, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A37EC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A37F0: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 821A37F4: C3AB2074  lfs f29, 0x2074(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821A37F8: 419A0008  beq cr6, 0x821a3800
	if ctx.cr[6].eq {
	pc = 0x821A3800; continue 'dispatch;
	}
	// 821A37FC: EC3F0772  fmuls f1, f31, f29
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[29].f64) as f32) as f64);
	// 821A3800: 3C6A0002  addis r3, r10, 2
	ctx.r[3].s64 = ctx.r[10].s64 + 131072;
	// 821A3804: 3863CF2C  addi r3, r3, -0x30d4
	ctx.r[3].s64 = ctx.r[3].s64 + -12500;
	// 821A3808: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A380C: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821A3810: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A3814: 4E800421  bctrl
	ctx.lr = 0x821A3818;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A3818: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A381C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A3820: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 821A3824: 419A0008  beq cr6, 0x821a382c
	if ctx.cr[6].eq {
	pc = 0x821A382C; continue 'dispatch;
	}
	// 821A3828: EC3F0772  fmuls f1, f31, f29
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[29].f64) as f32) as f64);
	// 821A382C: 3C6B0002  addis r3, r11, 2
	ctx.r[3].s64 = ctx.r[11].s64 + 131072;
	// 821A3830: 3863D044  addi r3, r3, -0x2fbc
	ctx.r[3].s64 = ctx.r[3].s64 + -12220;
	// 821A3834: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3838: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821A383C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A3840: 4E800421  bctrl
	ctx.lr = 0x821A3844;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A3844: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A3848: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A384C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A3850: 419A0014  beq cr6, 0x821a3864
	if ctx.cr[6].eq {
	pc = 0x821A3864; continue 'dispatch;
	}
	// 821A3854: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A3858: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A385C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A3860: 419A000C  beq cr6, 0x821a386c
	if ctx.cr[6].eq {
	pc = 0x821A386C; continue 'dispatch;
	}
	// 821A3864: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A3868: 48000008  b 0x821a3870
	pc = 0x821A3870; continue 'dispatch;
	// 821A386C: 386A0090  addi r3, r10, 0x90
	ctx.r[3].s64 = ctx.r[10].s64 + 144;
	// 821A3870: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A3874: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A3878: 419A0014  beq cr6, 0x821a388c
	if ctx.cr[6].eq {
	pc = 0x821A388C; continue 'dispatch;
	}
	// 821A387C: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A3880: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A3884: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A3888: 419A000C  beq cr6, 0x821a3894
	if ctx.cr[6].eq {
	pc = 0x821A3894; continue 'dispatch;
	}
	// 821A388C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821A3890: 48000028  b 0x821a38b8
	pc = 0x821A38B8; continue 'dispatch;
	// 821A3894: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A3898: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A389C: 419A0014  beq cr6, 0x821a38b0
	if ctx.cr[6].eq {
	pc = 0x821A38B0; continue 'dispatch;
	}
	// 821A38A0: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A38A4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A38A8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A38AC: 419A0008  beq cr6, 0x821a38b4
	if ctx.cr[6].eq {
	pc = 0x821A38B4; continue 'dispatch;
	}
	// 821A38B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A38B4: 3BCA0090  addi r30, r10, 0x90
	ctx.r[30].s64 = ctx.r[10].s64 + 144;
	// 821A38B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A38BC: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 821A38C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A38C4: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A38C8: 419A0010  beq cr6, 0x821a38d8
	if ctx.cr[6].eq {
	pc = 0x821A38D8; continue 'dispatch;
	}
	// 821A38CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A38D0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A38D4: 4BFB189D  bl 0x82155170
	ctx.lr = 0x821A38D8;
	sub_82155170(ctx, base);
	// 821A38D8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A38DC: 419A0014  beq cr6, 0x821a38f0
	if ctx.cr[6].eq {
	pc = 0x821A38F0; continue 'dispatch;
	}
	// 821A38E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A38E4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A38E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A38EC: 4BFB1885  bl 0x82155170
	ctx.lr = 0x821A38F0;
	sub_82155170(ctx, base);
	// 821A38F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A38F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A38F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A38FC: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821A3900: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821A3904: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 821A3908: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A390C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A3910: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3918 size=48
    let mut pc: u32 = 0x821A3918;
    'dispatch: loop {
        match pc {
            0x821A3918 => {
    //   block [0x821A3918..0x821A3948)
	// 821A3918: 548B057E  clrlwi r11, r4, 0x15
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000007FFu64;
	// 821A391C: 90A30008  stw r5, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 821A3920: 548A0428  rlwinm r10, r4, 0, 0x10, 0x14
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 821A3924: 7D680734  extsh r8, r11
	ctx.r[8].s64 = ctx.r[11].s16 as i64;
	// 821A3928: 2F0B0058  cmpwi cr6, r11, 0x58
	ctx.cr[6].compare_i32(ctx.r[11].s32, 88, &mut ctx.xer);
	// 821A392C: B1430004  sth r10, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 821A3930: B1030000  sth r8, 0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 821A3934: 41980050  blt cr6, 0x821a3984
	if ctx.cr[6].lt {
		sub_821A3984(ctx, base);
		return;
	}
	// 821A3938: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A393C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A3940: B1430002  sth r10, 2(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[10].u16 ) };
	// 821A3944: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3948 size=60
    let mut pc: u32 = 0x821A3948;
    'dispatch: loop {
        match pc {
            0x821A3948 => {
    //   block [0x821A3948..0x821A3984)
	// 821A3948: 396BFFA8  addi r11, r11, -0x58
	ctx.r[11].s64 = ctx.r[11].s64 + -88;
	// 821A394C: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821A3950: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A3954: 394A47D0  addi r10, r10, 0x47d0
	ctx.r[10].s64 = ctx.r[10].s64 + 18384;
	// 821A3958: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 821A395C: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 821A3960: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A3964: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A3968: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821A396C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3970: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821A3974: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A3978: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 821A397C: 4200FFF0  bdnz 0x821a396c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821A396C; continue 'dispatch;
	}
	// 821A3980: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3984(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3984 size=16
    let mut pc: u32 = 0x821A3984;
    'dispatch: loop {
        match pc {
            0x821A3984 => {
    //   block [0x821A3984..0x821A3994)
	// 821A3984: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821A3988: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A398C: B1430002  sth r10, 2(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[10].u16 ) };
	// 821A3990: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3994(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3994 size=84
    let mut pc: u32 = 0x821A3994;
    'dispatch: loop {
        match pc {
            0x821A3994 => {
    //   block [0x821A3994..0x821A39E8)
	// 821A3994: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 821A3998: B1050002  sth r8, 2(r5)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[5].u32.wrapping_add(2 as u32), ctx.r[8].u16 ) };
	// 821A399C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A39A0: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 821A39A4: 7D682E70  srawi r8, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 821A39A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A39AC: 7D080194  addze r8, r8
	tmp.s64 = ctx.r[8].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[8].u32);
	ctx.r[8].s64 = tmp.s64;
	// 821A39B0: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A39B4: B0E50000  sth r7, 0(r5)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 821A39B8: 55082834  slwi r8, r8, 5
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(5);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A39BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A39C0: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 821A39C4: 91450004  stw r10, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A39C8: 91450008  stw r10, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821A39CC: 9145000C  stw r10, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821A39D0: 91450010  stw r10, 0x10(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 821A39D4: 7D49282E  lwzx r10, r9, r5
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 821A39D8: 7CEB5830  slw r11, r7, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[7].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 821A39DC: 7D6B5038  and r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 821A39E0: 7D69292E  stwx r11, r9, r5
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32), ctx.r[11].u32) };
	// 821A39E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A39E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A39E8 size=188
    let mut pc: u32 = 0x821A39E8;
    'dispatch: loop {
        match pc {
            0x821A39E8 => {
    //   block [0x821A39E8..0x821A3AA4)
	// 821A39E8: A1630002  lhz r11, 2(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(2 as u32) ) } as u64;
	// 821A39EC: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A39F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A39F4: 419800B0  blt cr6, 0x821a3aa4
	if ctx.cr[6].lt {
		sub_821A3AA4(ctx, base);
		return;
	}
	// 821A39F8: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A39FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A3A00: 409A0028  bne cr6, 0x821a3a28
	if !ctx.cr[6].eq {
	pc = 0x821A3A28; continue 'dispatch;
	}
	// 821A3A04: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821A3A08: A1030000  lhz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3A0C: 392A47D0  addi r9, r10, 0x47d0
	ctx.r[9].s64 = ctx.r[10].s64 + 18384;
	// 821A3A10: 7D0A0734  extsh r10, r8
	ctx.r[10].s64 = ctx.r[8].s16 as i64;
	// 821A3A14: 394AFFA8  addi r10, r10, -0x58
	ctx.r[10].s64 = ctx.r[10].s64 + -88;
	// 821A3A18: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A3A1C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821A3A20: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A3A24: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821A3A28: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 821A3A2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A3A30: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A3A34: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 821A3A38: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 821A3A3C: 7D652E70  srawi r5, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 821A3A40: 55442834  slwi r4, r10, 5
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A3A44: 7D450194  addze r10, r5
	tmp.s64 = ctx.r[5].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[5].u32);
	ctx.r[10].s64 = tmp.s64;
	// 821A3A48: 7CA45850  subf r5, r4, r11
	ctx.r[5].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 821A3A4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A3A50: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A3A54: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A3A58: 7CE52830  slw r5, r7, r5
	if (ctx.r[5].u8 & 0x20) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = ((ctx.r[7].u32) << ((ctx.r[5].u8 & 0x1F) as u32)) as u64;
	}
	// 821A3A5C: 7CAA5038  and r10, r5, r10
	ctx.r[10].u64 = ctx.r[5].u64 & ctx.r[10].u64;
	// 821A3A60: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A3A64: 419A0008  beq cr6, 0x821a3a6c
	if ctx.cr[6].eq {
	pc = 0x821A3A6C; continue 'dispatch;
	}
	// 821A3A68: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 821A3A6C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A3A70: 2F0B0061  cmpwi cr6, r11, 0x61
	ctx.cr[6].compare_i32(ctx.r[11].s32, 97, &mut ctx.xer);
	// 821A3A74: 41980008  blt cr6, 0x821a3a7c
	if ctx.cr[6].lt {
	pc = 0x821A3A7C; continue 'dispatch;
	}
	// 821A3A78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A3A7C: 2F08FFFF  cmpwi cr6, r8, -1
	ctx.cr[6].compare_i32(ctx.r[8].s32, -1, &mut ctx.xer);
	// 821A3A80: 409A0010  bne cr6, 0x821a3a90
	if !ctx.cr[6].eq {
	pc = 0x821A3A90; continue 'dispatch;
	}
	// 821A3A84: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821A3A88: 2F060061  cmpwi cr6, r6, 0x61
	ctx.cr[6].compare_i32(ctx.r[6].s32, 97, &mut ctx.xer);
	// 821A3A8C: 4198FFA8  blt cr6, 0x821a3a34
	if ctx.cr[6].lt {
	pc = 0x821A3A34; continue 'dispatch;
	}
	// 821A3A90: 2F08FFFF  cmpwi cr6, r8, -1
	ctx.cr[6].compare_i32(ctx.r[8].s32, -1, &mut ctx.xer);
	// 821A3A94: B1630002  sth r11, 2(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[11].u16 ) };
	// 821A3A98: 409A0018  bne cr6, 0x821a3ab0
	if !ctx.cr[6].eq {
		sub_821A3AB0(ctx, base);
		return;
	}
	// 821A3A9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A3AA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3AA4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3AA4 size=12
    let mut pc: u32 = 0x821A3AA4;
    'dispatch: loop {
        match pc {
            0x821A3AA4 => {
    //   block [0x821A3AA4..0x821A3AB0)
	// 821A3AA4: A1630000  lhz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3AA8: 7D630734  extsh r3, r11
	ctx.r[3].s64 = ctx.r[11].s16 as i64;
	// 821A3AAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3AB0 size=8
    let mut pc: u32 = 0x821A3AB0;
    'dispatch: loop {
        match pc {
            0x821A3AB0 => {
    //   block [0x821A3AB0..0x821A3AB8)
	// 821A3AB0: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 821A3AB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3AB8 size=72
    let mut pc: u32 = 0x821A3AB8;
    'dispatch: loop {
        match pc {
            0x821A3AB8 => {
    //   block [0x821A3AB8..0x821A3B00)
	// 821A3AB8: A1630002  lhz r11, 2(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(2 as u32) ) } as u64;
	// 821A3ABC: 2B0B8000  cmplwi cr6, r11, 0x8000
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32768 as u32, &mut ctx.xer);
	// 821A3AC0: 40980040  bge cr6, 0x821a3b00
	if !ctx.cr[6].lt {
		sub_821A3B00(ctx, base);
		return;
	}
	// 821A3AC4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A3AC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A3ACC: 409A0028  bne cr6, 0x821a3af4
	if !ctx.cr[6].eq {
	pc = 0x821A3AF4; continue 'dispatch;
	}
	// 821A3AD0: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A3AD4: A1230000  lhz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3AD8: 394B47D0  addi r10, r11, 0x47d0
	ctx.r[10].s64 = ctx.r[11].s64 + 18384;
	// 821A3ADC: 7D2B0734  extsh r11, r9
	ctx.r[11].s64 = ctx.r[9].s16 as i64;
	// 821A3AE0: 396BFFA8  addi r11, r11, -0x58
	ctx.r[11].s64 = ctx.r[11].s64 + -88;
	// 821A3AE4: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A3AE8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821A3AEC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A3AF0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A3AF4: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3AF8: 7D630734  extsh r3, r11
	ctx.r[3].s64 = ctx.r[11].s16 as i64;
	// 821A3AFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3B00 size=8
    let mut pc: u32 = 0x821A3B00;
    'dispatch: loop {
        match pc {
            0x821A3B00 => {
    //   block [0x821A3B00..0x821A3B08)
	// 821A3B00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A3B04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3B08 size=48
    let mut pc: u32 = 0x821A3B08;
    'dispatch: loop {
        match pc {
            0x821A3B08 => {
    //   block [0x821A3B08..0x821A3B38)
	// 821A3B08: 2F040058  cmpwi cr6, r4, 0x58
	ctx.cr[6].compare_i32(ctx.r[4].s32, 88, &mut ctx.xer);
	// 821A3B0C: 4198002C  blt cr6, 0x821a3b38
	if ctx.cr[6].lt {
		sub_821A3B38(ctx, base);
		return;
	}
	// 821A3B10: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821A3B14: 3964FFA8  addi r11, r4, -0x58
	ctx.r[11].s64 = ctx.r[4].s64 + -88;
	// 821A3B18: 394A47D0  addi r10, r10, 0x47d0
	ctx.r[10].s64 = ctx.r[10].s64 + 18384;
	// 821A3B1C: 392A0002  addi r9, r10, 2
	ctx.r[9].s64 = ctx.r[10].s64 + 2;
	// 821A3B20: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A3B24: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A3B28: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A3B2C: 7D6B4A2E  lhzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A3B30: 7D630734  extsh r3, r11
	ctx.r[3].s64 = ctx.r[11].s16 as i64;
	// 821A3B34: 48000008  b 0x821a3b3c
	sub_821A3B38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3B38 size=156
    let mut pc: u32 = 0x821A3B38;
    'dispatch: loop {
        match pc {
            0x821A3B38 => {
    //   block [0x821A3B38..0x821A3BD4)
	// 821A3B38: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821A3B3C: 2F030017  cmpwi cr6, r3, 0x17
	ctx.cr[6].compare_i32(ctx.r[3].s32, 23, &mut ctx.xer);
	// 821A3B40: 419800A0  blt cr6, 0x821a3be0
	if ctx.cr[6].lt {
		sub_821A3BE0(ctx, base);
		return;
	}
	// 821A3B44: 2F03001F  cmpwi cr6, r3, 0x1f
	ctx.cr[6].compare_i32(ctx.r[3].s32, 31, &mut ctx.xer);
	// 821A3B48: 41990098  bgt cr6, 0x821a3be0
	if ctx.cr[6].gt {
		sub_821A3BE0(ctx, base);
		return;
	}
	// 821A3B4C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A3B50: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A3B54: 6169BEBC  ori r9, r11, 0xbebc
	ctx.r[9].u64 = ctx.r[11].u64 | 48828;
	// 821A3B58: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A3B5C: 394B0198  addi r10, r11, 0x198
	ctx.r[10].s64 = ctx.r[11].s64 + 408;
	// 821A3B60: 3963FFE9  addi r11, r3, -0x17
	ctx.r[11].s64 = ctx.r[3].s64 + -23;
	// 821A3B64: 7CA54A2E  lhzx r5, r5, r9
	ctx.r[5].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A3B68: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A3B6C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A3B70: 392B1308  addi r9, r11, 0x1308
	ctx.r[9].s64 = ctx.r[11].s64 + 4872;
	// 821A3B74: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A3B78: 390B1040  addi r8, r11, 0x1040
	ctx.r[8].s64 = ctx.r[11].s64 + 4160;
	// 821A3B7C: 54AB103E  rotlwi r11, r5, 2
	ctx.r[11].u64 = ((ctx.r[5].u32).rotate_left(2)) as u64;
	// 821A3B80: 3CA08286  lis r5, -0x7d7a
	ctx.r[5].s64 = -2105147392;
	// 821A3B84: 38A50540  addi r5, r5, 0x540
	ctx.r[5].s64 = ctx.r[5].s64 + 1344;
	// 821A3B88: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821A3B8C: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A3B90: 7D6A2214  add r11, r10, r4
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 821A3B94: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3B98: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821A3B9C: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 821A3BA0: 7D630734  extsh r3, r11
	ctx.r[3].s64 = ctx.r[11].s16 as i64;
	// 821A3BA4: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A3BA8: 7D6B4A2E  lhzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A3BAC: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A3BB0: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A3BB4: 7D6B422E  lhzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821A3BB8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A3BBC: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A3BC0: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 821A3BC4: 419A0008  beq cr6, 0x821a3bcc
	if ctx.cr[6].eq {
	pc = 0x821A3BCC; continue 'dispatch;
	}
	// 821A3BC8: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A3BCC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A3BD0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3BD4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3BD4 size=12
    let mut pc: u32 = 0x821A3BD4;
    'dispatch: loop {
        match pc {
            0x821A3BD4 => {
    //   block [0x821A3BD4..0x821A3BE0)
	// 821A3BD4: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3BD8: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3BDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3BE0 size=36
    let mut pc: u32 = 0x821A3BE0;
    'dispatch: loop {
        match pc {
            0x821A3BE0 => {
    //   block [0x821A3BE0..0x821A3C04)
	// 821A3BE0: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A3BE4: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A3BE8: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 821A3BEC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A3BF0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821A3BF4: 419A0008  beq cr6, 0x821a3bfc
	if ctx.cr[6].eq {
	pc = 0x821A3BFC; continue 'dispatch;
	}
	// 821A3BF8: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A3BFC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A3C00: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3C04(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3C04 size=72
    let mut pc: u32 = 0x821A3C04;
    'dispatch: loop {
        match pc {
            0x821A3C04 => {
    //   block [0x821A3C04..0x821A3C4C)
	// 821A3C04: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821A3C08: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3C0C: 6149BEB8  ori r9, r10, 0xbeb8
	ctx.r[9].u64 = ctx.r[10].u64 | 48824;
	// 821A3C10: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821A3C14: 394A54C8  addi r10, r10, 0x54c8
	ctx.r[10].s64 = ctx.r[10].s64 + 21704;
	// 821A3C18: 7D654A2E  lhzx r11, r5, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A3C1C: 5569103E  rotlwi r9, r11, 2
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 821A3C20: 2B0B0011  cmplwi cr6, r11, 0x11
	ctx.cr[6].compare_u32(ctx.r[11].u32, 17 as u32, &mut ctx.xer);
	// 821A3C24: 7DA9542E  lfsx f13, r9, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A3C28: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A3C2C: 409A0018  bne cr6, 0x821a3c44
	if !ctx.cr[6].eq {
	pc = 0x821A3C44; continue 'dispatch;
	}
	// 821A3C30: 2F030009  cmpwi cr6, r3, 9
	ctx.cr[6].compare_i32(ctx.r[3].s32, 9, &mut ctx.xer);
	// 821A3C34: 409A0010  bne cr6, 0x821a3c44
	if !ctx.cr[6].eq {
	pc = 0x821A3C44; continue 'dispatch;
	}
	// 821A3C38: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A3C3C: C1ABCFEC  lfs f13, -0x3014(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A3C40: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A3C44: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3C48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3C50 size=52
    let mut pc: u32 = 0x821A3C50;
    'dispatch: loop {
        match pc {
            0x821A3C50 => {
    //   block [0x821A3C50..0x821A3C84)
	// 821A3C50: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A3C54: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A3C58: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3C5C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A3C60: 396BBA38  addi r11, r11, -0x45c8
	ctx.r[11].s64 = ctx.r[11].s64 + -17864;
	// 821A3C64: 419A0020  beq cr6, 0x821a3c84
	if ctx.cr[6].eq {
		sub_821A3C84(ctx, base);
		return;
	}
	// 821A3C68: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A3C6C: D1A30000  stfs f13, 0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3C70: C1840004  lfs f12, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A3C74: D1830004  stfs f12, 4(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A3C78: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A3C7C: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A3C80: 48000010  b 0x821a3c90
	sub_821A3C84(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3C84(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3C84 size=72
    let mut pc: u32 = 0x821A3C84;
    'dispatch: loop {
        match pc {
            0x821A3C84 => {
    //   block [0x821A3C84..0x821A3CCC)
	// 821A3C84: D0030008  stfs f0, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A3C88: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A3C8C: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3C90: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A3C94: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A3C98: D1A3000C  stfs f13, 0xc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A3C9C: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A3CA0: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A3CA4: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A3CA8: D1A3001C  stfs f13, 0x1c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821A3CAC: 419A0020  beq cr6, 0x821a3ccc
	if ctx.cr[6].eq {
		sub_821A3CCC(ctx, base);
		return;
	}
	// 821A3CB0: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A3CB4: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A3CB8: 394A3CE8  addi r10, r10, 0x3ce8
	ctx.r[10].s64 = ctx.r[10].s64 + 15592;
	// 821A3CBC: 396B3CE8  addi r11, r11, 0x3ce8
	ctx.r[11].s64 = ctx.r[11].s64 + 15592;
	// 821A3CC0: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A3CC4: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A3CC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3CCC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3CCC size=28
    let mut pc: u32 = 0x821A3CCC;
    'dispatch: loop {
        match pc {
            0x821A3CCC => {
    //   block [0x821A3CCC..0x821A3CE8)
	// 821A3CCC: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A3CD0: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A3CD4: 394A3D08  addi r10, r10, 0x3d08
	ctx.r[10].s64 = ctx.r[10].s64 + 15624;
	// 821A3CD8: 396B3D40  addi r11, r11, 0x3d40
	ctx.r[11].s64 = ctx.r[11].s64 + 15680;
	// 821A3CDC: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A3CE0: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A3CE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3CE8 size=28
    let mut pc: u32 = 0x821A3CE8;
    'dispatch: loop {
        match pc {
            0x821A3CE8 => {
    //   block [0x821A3CE8..0x821A3D04)
	// 821A3CE8: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3CEC: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3CF0: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3CF4: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A3CF8: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3CFC: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A3D00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3D08 size=52
    let mut pc: u32 = 0x821A3D08;
    'dispatch: loop {
        match pc {
            0x821A3D08 => {
    //   block [0x821A3D08..0x821A3D3C)
	// 821A3D08: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3D0C: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3D10: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3D14: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A3D18: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3D1C: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A3D20: C0030010  lfs f0, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3D24: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3D28: C0030014  lfs f0, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3D2C: D0050004  stfs f0, 4(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A3D30: C0030018  lfs f0, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3D34: D0050008  stfs f0, 8(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A3D38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A3D40 size=156
    let mut pc: u32 = 0x821A3D40;
    'dispatch: loop {
        match pc {
            0x821A3D40 => {
    //   block [0x821A3D40..0x821A3DDC)
	// 821A3D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A3D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A3D48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A3D4C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A3D50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A3D54: 481C33E5  bl 0x82367138
	ctx.lr = 0x821A3D58;
	sub_82367138(ctx, base);
	// 821A3D58: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A3D5C: C19F0014  lfs f12, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A3D60: C17F0018  lfs f11, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A3D64: C15F0010  lfs f10, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A3D68: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3D6C: D004000C  stfs f0, 0xc(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A3D70: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A3D74: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A3D78: C13F0004  lfs f9, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A3D7C: C11F0008  lfs f8, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821A3D80: C0FF0000  lfs f7, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A3D84: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A3D88: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A3D8C: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A3D90: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3D94: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A3D98: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A3D9C: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A3DA0: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821A3DA4: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A3DA8: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A3DAC: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A3DB0: ED89637A  fmadds f12, f9, f13, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A3DB4: D1840004  stfs f12, 4(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A3DB8: ED685B7A  fmadds f11, f8, f13, f11
	ctx.f[11].f64 = (((ctx.f[8].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A3DBC: D1640008  stfs f11, 8(r4)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A3DC0: EC07037A  fmadds f0, f7, f13, f0
	ctx.f[0].f64 = (((ctx.f[7].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 821A3DC4: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3DC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A3DCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A3DD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A3DD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A3DD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3DE0 size=56
    let mut pc: u32 = 0x821A3DE0;
    'dispatch: loop {
        match pc {
            0x821A3DE0 => {
    //   block [0x821A3DE0..0x821A3E18)
	// 821A3DE0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A3DE4: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821A3DE8: 90A30008  stw r5, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 821A3DEC: 90C3000C  stw r6, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 821A3DF0: 409A0028  bne cr6, 0x821a3e18
	if !ctx.cr[6].eq {
		sub_821A3E18(ctx, base);
		return;
	}
	// 821A3DF4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A3DF8: 409A0044  bne cr6, 0x821a3e3c
	if !ctx.cr[6].eq {
		sub_821A3E3C(ctx, base);
		return;
	}
	// 821A3DFC: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A3E00: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A3E04: 394A3E78  addi r10, r10, 0x3e78
	ctx.r[10].s64 = ctx.r[10].s64 + 15992;
	// 821A3E08: 396B3E78  addi r11, r11, 0x3e78
	ctx.r[11].s64 = ctx.r[11].s64 + 15992;
	// 821A3E0C: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A3E10: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A3E14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3E18 size=36
    let mut pc: u32 = 0x821A3E18;
    'dispatch: loop {
        match pc {
            0x821A3E18 => {
    //   block [0x821A3E18..0x821A3E3C)
	// 821A3E18: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A3E1C: 409A003C  bne cr6, 0x821a3e58
	if !ctx.cr[6].eq {
		sub_821A3E58(ctx, base);
		return;
	}
	// 821A3E20: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A3E24: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A3E28: 394A3EC8  addi r10, r10, 0x3ec8
	ctx.r[10].s64 = ctx.r[10].s64 + 16072;
	// 821A3E2C: 396B3F60  addi r11, r11, 0x3f60
	ctx.r[11].s64 = ctx.r[11].s64 + 16224;
	// 821A3E30: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A3E34: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A3E38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3E3C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3E3C size=28
    let mut pc: u32 = 0x821A3E3C;
    'dispatch: loop {
        match pc {
            0x821A3E3C => {
    //   block [0x821A3E3C..0x821A3E58)
	// 821A3E3C: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A3E40: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A3E44: 394A4068  addi r10, r10, 0x4068
	ctx.r[10].s64 = ctx.r[10].s64 + 16488;
	// 821A3E48: 396B4100  addi r11, r11, 0x4100
	ctx.r[11].s64 = ctx.r[11].s64 + 16640;
	// 821A3E4C: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A3E50: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A3E54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3E58 size=28
    let mut pc: u32 = 0x821A3E58;
    'dispatch: loop {
        match pc {
            0x821A3E58 => {
    //   block [0x821A3E58..0x821A3E74)
	// 821A3E58: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A3E5C: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A3E60: 394A4208  addi r10, r10, 0x4208
	ctx.r[10].s64 = ctx.r[10].s64 + 16904;
	// 821A3E64: 396B43F0  addi r11, r11, 0x43f0
	ctx.r[11].s64 = ctx.r[11].s64 + 17392;
	// 821A3E68: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A3E6C: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A3E70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3E78 size=52
    let mut pc: u32 = 0x821A3E78;
    'dispatch: loop {
        match pc {
            0x821A3E78 => {
    //   block [0x821A3E78..0x821A3EAC)
	// 821A3E78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3E7C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A3E80: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A3E84: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A3E88: 419A001C  beq cr6, 0x821a3ea4
	if ctx.cr[6].eq {
	pc = 0x821A3EA4; continue 'dispatch;
	}
	// 821A3E8C: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3E90: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3E94: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3E98: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A3E9C: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3EA0: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A3EA4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A3EA8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3EAC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3EAC size=28
    let mut pc: u32 = 0x821A3EAC;
    'dispatch: loop {
        match pc {
            0x821A3EAC => {
    //   block [0x821A3EAC..0x821A3EC8)
	// 821A3EAC: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3EB0: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3EB4: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3EB8: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A3EBC: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3EC0: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A3EC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3EC8 size=124
    let mut pc: u32 = 0x821A3EC8;
    'dispatch: loop {
        match pc {
            0x821A3EC8 => {
    //   block [0x821A3EC8..0x821A3F44)
	// 821A3EC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3ECC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A3ED0: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A3ED4: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A3ED8: 419A0044  beq cr6, 0x821a3f1c
	if ctx.cr[6].eq {
	pc = 0x821A3F1C; continue 'dispatch;
	}
	// 821A3EDC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A3EE0: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3F44(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3F44 size=28
    let mut pc: u32 = 0x821A3F44;
    'dispatch: loop {
        match pc {
            0x821A3F44 => {
    //   block [0x821A3F44..0x821A3F60)
	// 821A3F44: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3F48: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3F4C: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3F50: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A3F54: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3F58: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A3F5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A3F60 size=260
    let mut pc: u32 = 0x821A3F60;
    'dispatch: loop {
        match pc {
            0x821A3F60 => {
    //   block [0x821A3F60..0x821A4064)
	// 821A3F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A3F64: 48391159  bl 0x825350bc
	ctx.lr = 0x821A3F68;
	sub_82535080(ctx, base);
	// 821A3F68: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A3F6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3F70: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 821A3F74: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A3F78: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821A3F7C: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A3F80: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A3F84: 7FEB3A14  add r31, r11, r7
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A3F88: 397F0030  addi r11, r31, 0x30
	ctx.r[11].s64 = ctx.r[31].s64 + 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A4068 size=124
    let mut pc: u32 = 0x821A4068;
    'dispatch: loop {
        match pc {
            0x821A4068 => {
    //   block [0x821A4068..0x821A40E4)
	// 821A4068: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A406C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A4070: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4074: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4078: 419A001C  beq cr6, 0x821a4094
	if ctx.cr[6].eq {
	pc = 0x821A4094; continue 'dispatch;
	}
	// 821A407C: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4080: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A4084: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4088: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A408C: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4090: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A4094: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A4098: 419A0044  beq cr6, 0x821a40dc
	if ctx.cr[6].eq {
	pc = 0x821A40DC; continue 'dispatch;
	}
	// 821A409C: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A40A0: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A40E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A40E4 size=28
    let mut pc: u32 = 0x821A40E4;
    'dispatch: loop {
        match pc {
            0x821A40E4 => {
    //   block [0x821A40E4..0x821A4100)
	// 821A40E4: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A40E8: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A40EC: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A40F0: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A40F4: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A40F8: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A40FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A4100 size=260
    let mut pc: u32 = 0x821A4100;
    'dispatch: loop {
        match pc {
            0x821A4100 => {
    //   block [0x821A4100..0x821A4204)
	// 821A4100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A4104: 48390FB9  bl 0x825350bc
	ctx.lr = 0x821A4108;
	sub_82535080(ctx, base);
	// 821A4108: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A410C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4110: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 821A4114: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A4118: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821A411C: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4120: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A4124: 7FEB3A14  add r31, r11, r7
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4128: 397F0030  addi r11, r31, 0x30
	ctx.r[11].s64 = ctx.r[31].s64 + 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A4208 size=152
    let mut pc: u32 = 0x821A4208;
    'dispatch: loop {
        match pc {
            0x821A4208 => {
    //   block [0x821A4208..0x821A42A0)
	// 821A4208: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A420C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A4210: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 821A4214: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4218: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 821A421C: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4220: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 821A4224: 419A0038  beq cr6, 0x821a425c
	if ctx.cr[6].eq {
	pc = 0x821A425C; continue 'dispatch;
	}
	// 821A4228: 80E30008  lwz r7, 8(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A42A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A42A0 size=28
    let mut pc: u32 = 0x821A42A0;
    'dispatch: loop {
        match pc {
            0x821A42A0 => {
    //   block [0x821A42A0..0x821A42BC)
	// 821A42A0: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A42A4: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A42A8: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A42AC: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A42B0: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A42B4: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A42B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A42C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A42C0 size=284
    let mut pc: u32 = 0x821A42C0;
    'dispatch: loop {
        match pc {
            0x821A42C0 => {
    //   block [0x821A42C0..0x821A43DC)
	// 821A42C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A42C4: 3941FFC0  addi r10, r1, -0x40
	ctx.r[10].s64 = ctx.r[1].s64 + -64;
	// 821A42C8: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821A42CC: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A42D0: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A42D4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821A42D8: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A42DC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821A42E0: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821A42E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A42E8: 4200FFF0  bdnz 0x821a42d8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821A42D8; continue 'dispatch;
	}
	// 821A42EC: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A42F0: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 821A42F4: C181FFC0  lfs f12, -0x40(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A42F8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A42FC: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4300: D181FFC0  stfs f12, -0x40(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), tmp.u32 ) };
	// 821A4304: C181FFC4  lfs f12, -0x3c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A4308: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A430C: D181FFC4  stfs f12, -0x3c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-60 as u32), tmp.u32 ) };
	// 821A4310: C1A1FFE0  lfs f13, -0x20(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4314: C181FFC8  lfs f12, -0x38(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A4318: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A431C: C141FFE4  lfs f10, -0x1c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-28 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A4320: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4324: D1A1FFE0  stfs f13, -0x20(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 821A4328: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A432C: D181FFC8  stfs f12, -0x38(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), tmp.u32 ) };
	// 821A4330: D141FFE4  stfs f10, -0x1c(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), tmp.u32 ) };
	// 821A4334: C1A1FFD0  lfs f13, -0x30(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4338: C181FFD4  lfs f12, -0x2c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-44 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A433C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4340: C161FFD8  lfs f11, -0x28(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A4344: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4348: C141FFE8  lfs f10, -0x18(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A434C: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4350: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4354: D1A1FFD0  stfs f13, -0x30(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), tmp.u32 ) };
	// 821A4358: D181FFD4  stfs f12, -0x2c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-44 as u32), tmp.u32 ) };
	// 821A435C: D161FFD8  stfs f11, -0x28(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), tmp.u32 ) };
	// 821A4360: D001FFE8  stfs f0, -0x18(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A43DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A43DC size=16
    let mut pc: u32 = 0x821A43DC;
    'dispatch: loop {
        match pc {
            0x821A43DC => {
    //   block [0x821A43DC..0x821A43EC)
	// 821A43DC: D1A60000  stfs f13, 0(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A43E0: D1860004  stfs f12, 4(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A43E4: D1660008  stfs f11, 8(r6)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A43E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A43F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A43F0 size=300
    let mut pc: u32 = 0x821A43F0;
    'dispatch: loop {
        match pc {
            0x821A43F0 => {
    //   block [0x821A43F0..0x821A451C)
	// 821A43F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A43F4: 48390CC9  bl 0x825350bc
	ctx.lr = 0x821A43F8;
	sub_82535080(ctx, base);
	// 821A43F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A43FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4400: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 821A4404: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A4408: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821A440C: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4410: 80C3000C  lwz r6, 0xc(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A4414: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 821A4418: 7FEB3A14  add r31, r11, r7
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A441C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A4520 size=452
    let mut pc: u32 = 0x821A4520;
    'dispatch: loop {
        match pc {
            0x821A4520 => {
    //   block [0x821A4520..0x821A46E4)
	// 821A4520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A4524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A4528: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A452C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A4530: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4534: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 821A4538: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821A453C: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4540: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821A4544: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4548: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821A454C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A4550: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821A4554: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821A4558: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A455C: 4200FFF0  bdnz 0x821a454c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821A454C; continue 'dispatch;
	}
	// 821A4560: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 821A4564: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4568: C1A10070  lfs f13, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A456C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A4570: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4574: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A46E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A46E8 size=60
    let mut pc: u32 = 0x821A46E8;
    'dispatch: loop {
        match pc {
            0x821A46E8 => {
    //   block [0x821A46E8..0x821A4724)
	// 821A46E8: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A46EC: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821A46F0: 90A30004  stw r5, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 821A46F4: 90C30008  stw r6, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 821A46F8: 90E3000C  stw r7, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 821A46FC: 409A0028  bne cr6, 0x821a4724
	if !ctx.cr[6].eq {
		sub_821A4724(ctx, base);
		return;
	}
	// 821A4700: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A4704: 409A0044  bne cr6, 0x821a4748
	if !ctx.cr[6].eq {
		sub_821A4748(ctx, base);
		return;
	}
	// 821A4708: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A470C: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A4710: 394A4780  addi r10, r10, 0x4780
	ctx.r[10].s64 = ctx.r[10].s64 + 18304;
	// 821A4714: 396B4780  addi r11, r11, 0x4780
	ctx.r[11].s64 = ctx.r[11].s64 + 18304;
	// 821A4718: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A471C: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A4720: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4724(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A4724 size=36
    let mut pc: u32 = 0x821A4724;
    'dispatch: loop {
        match pc {
            0x821A4724 => {
    //   block [0x821A4724..0x821A4748)
	// 821A4724: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A4728: 409A003C  bne cr6, 0x821a4764
	if !ctx.cr[6].eq {
		sub_821A4764(ctx, base);
		return;
	}
	// 821A472C: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A4730: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A4734: 394A4830  addi r10, r10, 0x4830
	ctx.r[10].s64 = ctx.r[10].s64 + 18480;
	// 821A4738: 396B4908  addi r11, r11, 0x4908
	ctx.r[11].s64 = ctx.r[11].s64 + 18696;
	// 821A473C: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A4740: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A4744: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A4748 size=28
    let mut pc: u32 = 0x821A4748;
    'dispatch: loop {
        match pc {
            0x821A4748 => {
    //   block [0x821A4748..0x821A4764)
	// 821A4748: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A474C: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A4750: 394A4A60  addi r10, r10, 0x4a60
	ctx.r[10].s64 = ctx.r[10].s64 + 19040;
	// 821A4754: 396B4B38  addi r11, r11, 0x4b38
	ctx.r[11].s64 = ctx.r[11].s64 + 19256;
	// 821A4758: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A475C: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A4760: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4764(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A4764 size=28
    let mut pc: u32 = 0x821A4764;
    'dispatch: loop {
        match pc {
            0x821A4764 => {
    //   block [0x821A4764..0x821A4780)
	// 821A4764: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A4768: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A476C: 394A4C88  addi r10, r10, 0x4c88
	ctx.r[10].s64 = ctx.r[10].s64 + 19592;
	// 821A4770: 396B4D80  addi r11, r11, 0x4d80
	ctx.r[11].s64 = ctx.r[11].s64 + 19840;
	// 821A4774: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A4778: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A477C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A4780 size=148
    let mut pc: u32 = 0x821A4780;
    'dispatch: loop {
        match pc {
            0x821A4780 => {
    //   block [0x821A4780..0x821A4814)
	// 821A4780: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4784: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A4788: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A478C: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4790: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A4794: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4798: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821A479C: 419A0050  beq cr6, 0x821a47ec
	if ctx.cr[6].eq {
	pc = 0x821A47EC; continue 'dispatch;
	}
	// 821A47A0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A47A4: C1AB0010  lfs f13, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A47A8: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A47AC: C16B0018  lfs f11, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A47B0: C14A0014  lfs f10, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A47B4: C12A0018  lfs f9, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A47B8: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A47BC: ED0D0032  fmuls f8, f13, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A47C0: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A47C4: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A47C8: C0E1FFFC  lfs f7, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A47CC: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A47D0: D0E6000C  stfs f7, 0xc(r6)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A47D4: EDAD403A  fmadds f13, f13, f0, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 821A47D8: D1A60000  stfs f13, 0(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A47DC: EDAA603A  fmadds f13, f10, f0, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A47E0: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A47E4: EC09583A  fmadds f0, f9, f0, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A47E8: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A47EC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A47F0: 419A001C  beq cr6, 0x821a480c
	if ctx.cr[6].eq {
	pc = 0x821A480C; continue 'dispatch;
	}
	// 821A47F4: C00B0030  lfs f0, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A47F8: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A47FC: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4800: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A4804: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4808: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A480C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A4810: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4814(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A4814 size=28
    let mut pc: u32 = 0x821A4814;
    'dispatch: loop {
        match pc {
            0x821A4814 => {
    //   block [0x821A4814..0x821A4830)
	// 821A4814: C00A0030  lfs f0, 0x30(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4818: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A481C: C00A0034  lfs f0, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4820: D0050004  stfs f0, 4(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A4824: C00A0038  lfs f0, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4828: D0050008  stfs f0, 8(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A482C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A4830 size=188
    let mut pc: u32 = 0x821A4830;
    'dispatch: loop {
        match pc {
            0x821A4830 => {
    //   block [0x821A4830..0x821A48EC)
	// 821A4830: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4834: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A4838: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A483C: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4840: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A4844: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4848: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821A484C: 419A0050  beq cr6, 0x821a489c
	if ctx.cr[6].eq {
	pc = 0x821A489C; continue 'dispatch;
	}
	// 821A4850: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A4854: C1AB0010  lfs f13, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4858: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A485C: C16B0018  lfs f11, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A4860: C14A0014  lfs f10, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A4864: C12A0018  lfs f9, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A4868: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A486C: ED0D0032  fmuls f8, f13, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4870: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4874: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4878: C0E1FFFC  lfs f7, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A487C: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4880: D0E6000C  stfs f7, 0xc(r6)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A4884: EDAD403A  fmadds f13, f13, f0, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 821A4888: D1A60000  stfs f13, 0(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A488C: EDAA603A  fmadds f13, f10, f0, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A4890: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A4894: EC09583A  fmadds f0, f9, f0, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A4898: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A489C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A48A0: 419A0044  beq cr6, 0x821a48e4
	if ctx.cr[6].eq {
	pc = 0x821A48E4; continue 'dispatch;
	}
	// 821A48A4: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A48A8: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A48EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A48EC size=28
    let mut pc: u32 = 0x821A48EC;
    'dispatch: loop {
        match pc {
            0x821A48EC => {
    //   block [0x821A48EC..0x821A4908)
	// 821A48EC: C00A0030  lfs f0, 0x30(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A48F0: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A48F4: C00A0034  lfs f0, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A48F8: D0050004  stfs f0, 4(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A48FC: C00A0038  lfs f0, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4900: D0050008  stfs f0, 8(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A4904: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A4908 size=340
    let mut pc: u32 = 0x821A4908;
    'dispatch: loop {
        match pc {
            0x821A4908 => {
    //   block [0x821A4908..0x821A4A5C)
	// 821A4908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A490C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A4910: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A4914: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4918: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A491C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A4920: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4924: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A4928: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A492C: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821A4930: 419A005C  beq cr6, 0x821a498c
	if ctx.cr[6].eq {
	pc = 0x821A498C; continue 'dispatch;
	}
	// 821A4934: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A4938: C1AB0010  lfs f13, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A493C: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A4940: C16B0018  lfs f11, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A4944: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821A4948: D1610068  stfs f11, 0x68(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821A494C: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4950: ED0D0032  fmuls f8, f13, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4954: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821A4958: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A495C: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4960: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4964: C14A0014  lfs f10, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A4968: C12A0018  lfs f9, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A496C: C0E1006C  lfs f7, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A4970: D0E6000C  stfs f7, 0xc(r6)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A4974: EDAD403A  fmadds f13, f13, f0, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 821A4978: D1A60000  stfs f13, 0(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A497C: EDAA603A  fmadds f13, f10, f0, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A4980: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A4984: EC09583A  fmadds f0, f9, f0, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A4988: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A498C: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A4990: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A4A60 size=148
    let mut pc: u32 = 0x821A4A60;
    'dispatch: loop {
        match pc {
            0x821A4A60 => {
    //   block [0x821A4A60..0x821A4AF4)
	// 821A4A60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4A64: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A4A68: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A4A6C: 556A3032  slwi r10, r11, 6
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A4A70: 552B3032  slwi r11, r9, 6
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4A74: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821A4A78: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4A7C: 419A0050  beq cr6, 0x821a4acc
	if ctx.cr[6].eq {
	pc = 0x821A4ACC; continue 'dispatch;
	}
	// 821A4A80: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A4A84: C1AA0010  lfs f13, 0x10(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4A88: C18A0014  lfs f12, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A4A8C: C16A0018  lfs f11, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A4A90: C14B0014  lfs f10, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A4A94: C12B0018  lfs f9, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A4A98: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4A9C: ED0D0032  fmuls f8, f13, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4AA0: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4AA4: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4AA8: C0E1FFFC  lfs f7, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A4AAC: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4AB0: D0E6000C  stfs f7, 0xc(r6)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A4AB4: EDAD403A  fmadds f13, f13, f0, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 821A4AB8: D1A60000  stfs f13, 0(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A4ABC: EDAA603A  fmadds f13, f10, f0, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A4AC0: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A4AC4: EC09583A  fmadds f0, f9, f0, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A4AC8: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A4ACC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A4AD0: 419A001C  beq cr6, 0x821a4aec
	if ctx.cr[6].eq {
	pc = 0x821A4AEC; continue 'dispatch;
	}
	// 821A4AD4: C00A0030  lfs f0, 0x30(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4AD8: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A4ADC: C00A0034  lfs f0, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4AE0: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A4AE4: C00A0038  lfs f0, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4AE8: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A4AEC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A4AF0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4AF4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A4AF4 size=68
    let mut pc: u32 = 0x821A4AF4;
    'dispatch: loop {
        match pc {
            0x821A4AF4 => {
    //   block [0x821A4AF4..0x821A4B38)
	// 821A4AF4: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A4AF8: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A4B38 size=336
    let mut pc: u32 = 0x821A4B38;
    'dispatch: loop {
        match pc {
            0x821A4B38 => {
    //   block [0x821A4B38..0x821A4C88)
	// 821A4B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A4B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A4B40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A4B44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4B48: C101005C  lfs f8, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821A4B4C: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A4B50: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A4B54: 556A3032  slwi r10, r11, 6
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A4B58: 552B3032  slwi r11, r9, 6
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4B5C: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821A4B60: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4B64: 419A0058  beq cr6, 0x821a4bbc
	if ctx.cr[6].eq {
	pc = 0x821A4BBC; continue 'dispatch;
	}
	// 821A4B68: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A4B6C: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4B70: C18A0014  lfs f12, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A4B74: C16A0018  lfs f11, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A4B78: C14B0014  lfs f10, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A4B7C: C12B0018  lfs f9, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A4B80: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4B84: ECED0032  fmuls f7, f13, f0
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4B88: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4B8C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4B90: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821A4B94: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4B98: D1410054  stfs f10, 0x54(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821A4B9C: D1210058  stfs f9, 0x58(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821A4BA0: D106000C  stfs f8, 0xc(r6)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A4BA4: EDAD383A  fmadds f13, f13, f0, f7
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 821A4BA8: D1A60000  stfs f13, 0(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A4BAC: EDAA603A  fmadds f13, f10, f0, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A4BB0: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A4BB4: EC09583A  fmadds f0, f9, f0, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A4BB8: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A4BBC: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A4BC0: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A4C88 size=188
    let mut pc: u32 = 0x821A4C88;
    'dispatch: loop {
        match pc {
            0x821A4C88 => {
    //   block [0x821A4C88..0x821A4D44)
	// 821A4C88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4C8C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A4C90: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A4C94: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4C98: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A4C9C: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4CA0: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821A4CA4: 419A0050  beq cr6, 0x821a4cf4
	if ctx.cr[6].eq {
	pc = 0x821A4CF4; continue 'dispatch;
	}
	// 821A4CA8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A4CAC: C1AB0010  lfs f13, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4CB0: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A4CB4: C16B0018  lfs f11, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A4CB8: C14A0014  lfs f10, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A4CBC: C12A0018  lfs f9, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A4CC0: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4CC4: ED0D0032  fmuls f8, f13, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4CC8: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4CCC: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4CD0: C0E1FFFC  lfs f7, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A4CD4: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4CD8: D0E6000C  stfs f7, 0xc(r6)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A4CDC: EDAD403A  fmadds f13, f13, f0, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 821A4CE0: D1A60000  stfs f13, 0(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A4CE4: EDAA603A  fmadds f13, f10, f0, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A4CE8: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A4CEC: EC09583A  fmadds f0, f9, f0, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A4CF0: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A4CF4: 38E00030  li r7, 0x30
	ctx.r[7].s64 = 48;
	// 821A4CF8: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 821A4CFC: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 821A4D00: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A4D04: 419A0038  beq cr6, 0x821a4d3c
	if ctx.cr[6].eq {
	pc = 0x821A4D3C; continue 'dispatch;
	}
	// 821A4D08: 80C30008  lwz r6, 8(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4D44(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A4D44 size=56
    let mut pc: u32 = 0x821A4D44;
    'dispatch: loop {
        match pc {
            0x821A4D44 => {
    //   block [0x821A4D44..0x821A4D7C)
	// 821A4D44: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A4D80 size=408
    let mut pc: u32 = 0x821A4D80;
    'dispatch: loop {
        match pc {
            0x821A4D80 => {
    //   block [0x821A4D80..0x821A4F18)
	// 821A4D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A4D84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A4D88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A4D8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4D90: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A4D94: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A4D98: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4D9C: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A4DA0: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4DA4: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821A4DA8: 419A0068  beq cr6, 0x821a4e10
	if ctx.cr[6].eq {
	pc = 0x821A4E10; continue 'dispatch;
	}
	// 821A4DAC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A4DB0: C1AB0010  lfs f13, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4DB4: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A4DB8: C16B0018  lfs f11, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A4DBC: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821A4DC0: D1610068  stfs f11, 0x68(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821A4DC4: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4DC8: ED0D0032  fmuls f8, f13, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4DCC: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821A4DD0: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4DD4: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4DD8: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4DDC: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821A4DE0: C14A0014  lfs f10, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A4DE4: C12A0018  lfs f9, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A4DE8: C0E1006C  lfs f7, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A4DEC: D1410054  stfs f10, 0x54(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821A4DF0: D1210058  stfs f9, 0x58(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821A4DF4: D0E6000C  stfs f7, 0xc(r6)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A4DF8: EDAD403A  fmadds f13, f13, f0, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 821A4DFC: D1A60000  stfs f13, 0(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A4E00: EDAA603A  fmadds f13, f10, f0, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A4E04: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A4E08: EC09583A  fmadds f0, f9, f0, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A4E0C: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A4E10: 80C30008  lwz r6, 8(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A4E14: 38E00030  li r7, 0x30
	ctx.r[7].s64 = 48;
	// 821A4E18: 80A3000C  lwz r5, 0xc(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A4F18 size=100
    let mut pc: u32 = 0x821A4F18;
    'dispatch: loop {
        match pc {
            0x821A4F18 => {
    //   block [0x821A4F18..0x821A4F7C)
	// 821A4F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A4F1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A4F20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A4F24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A4F28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A4F2C: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A4F30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A4F34: 419A0034  beq cr6, 0x821a4f68
	if ctx.cr[6].eq {
	pc = 0x821A4F68; continue 'dispatch;
	}
	// 821A4F38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A4F3C: 4E800421  bctrl
	ctx.lr = 0x821A4F40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A4F40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A4F44: 409A0024  bne cr6, 0x821a4f68
	if !ctx.cr[6].eq {
	pc = 0x821A4F68; continue 'dispatch;
	}
	// 821A4F48: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A4F4C: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A4F50: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821A4F54: 409A0014  bne cr6, 0x821a4f68
	if !ctx.cr[6].eq {
	pc = 0x821A4F68; continue 'dispatch;
	}
	// 821A4F58: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821A4F5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A4F60: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 821A4F64: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 821A4F68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A4F6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A4F70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A4F74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A4F78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A4F80 size=340
    let mut pc: u32 = 0x821A4F80;
    'dispatch: loop {
        match pc {
            0x821A4F80 => {
    //   block [0x821A4F80..0x821A50D4)
	// 821A4F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A4F84: 48390131  bl 0x825350b4
	ctx.lr = 0x821A4F88;
	sub_82535080(ctx, base);
	// 821A4F88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A4F8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A4F90: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821A4F94: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A4F98: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821A4F9C: 38EB0E0C  addi r7, r11, 0xe0c
	ctx.r[7].s64 = ctx.r[11].s64 + 3596;
	// 821A4FA0: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 821A4FA4: 38A00389  li r5, 0x389
	ctx.r[5].s64 = 905;
	// 821A4FA8: FBBE0000  std r29, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u64 ) };
	// 821A4FAC: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 821A4FB0: 481C54E1  bl 0x8236a490
	ctx.lr = 0x821A4FB4;
	sub_8236A490(ctx, base);
	// 821A4FB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A4FB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A4FBC: 419A000C  beq cr6, 0x821a4fc8
	if ctx.cr[6].eq {
	pc = 0x821A4FC8; continue 'dispatch;
	}
	// 821A4FC0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A4FC4: 48000008  b 0x821a4fcc
	pc = 0x821A4FCC; continue 'dispatch;
	// 821A4FC8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821A4FCC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A4FD0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A4FD4: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A4FD8: 419A00B0  beq cr6, 0x821a5088
	if ctx.cr[6].eq {
	pc = 0x821A5088; continue 'dispatch;
	}
	// 821A4FDC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A4FE0: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821A4FE4: 396B0E14  addi r11, r11, 0xe14
	ctx.r[11].s64 = ctx.r[11].s64 + 3604;
	// 821A4FE8: 3D00821A  lis r8, -0x7de6
	ctx.r[8].s64 = -2112225280;
	// 821A4FEC: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 821A4FF0: 390850D8  addi r8, r8, 0x50d8
	ctx.r[8].s64 = ctx.r[8].s64 + 20696;
	// 821A4FF4: 392951E8  addi r9, r9, 0x51e8
	ctx.r[9].s64 = ctx.r[9].s64 + 20968;
	// 821A4FF8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A4FFC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A5000: 93BF0080  stw r29, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 821A5004: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821A5008: B3BF0084  sth r29, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[29].u16 ) };
	// 821A500C: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A5010: B3BF0086  sth r29, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[29].u16 ) };
	// 821A5014: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A5018: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 821A501C: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A5020: FBBF00E0  std r29, 0xe0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[29].u64 ) };
	// 821A5024: 38BF00CC  addi r5, r31, 0xcc
	ctx.r[5].s64 = ctx.r[31].s64 + 204;
	// 821A5028: 394A6FC8  addi r10, r10, 0x6fc8
	ctx.r[10].s64 = ctx.r[10].s64 + 28616;
	// 821A502C: FBBF00E8  std r29, 0xe8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[29].u64 ) };
	// 821A5030: 1C9B0C60  mulli r4, r27, 0xc60
	ctx.r[4].s64 = ctx.r[27].s64 * 3168;
	// 821A5034: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821A5038: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821A503C: 9B9F001C  stb r28, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[28].u8 ) };
	// 821A5040: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A5044: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A5048: 4BFFCBE9  bl 0x821a1c30
	ctx.lr = 0x821A504C;
	sub_821A1C30(ctx, base);
	// 821A504C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5050: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A5054: 409A0044  bne cr6, 0x821a5098
	if !ctx.cr[6].eq {
	pc = 0x821A5098; continue 'dispatch;
	}
	// 821A5058: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A505C: 419A002C  beq cr6, 0x821a5088
	if ctx.cr[6].eq {
	pc = 0x821A5088; continue 'dispatch;
	}
	// 821A5060: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5064: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A5068: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A506C: 409A001C  bne cr6, 0x821a5088
	if !ctx.cr[6].eq {
	pc = 0x821A5088; continue 'dispatch;
	}
	// 821A5070: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A5074: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A5078: 9B8B0025  stb r28, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[28].u8 ) };
	// 821A507C: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A5080: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821A5084: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 821A5088: FBBE0000  std r29, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u64 ) };
	// 821A508C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A5090: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A5094: 48390070  b 0x82535104
	sub_825350D0(ctx, base);
	return;
	// 821A5098: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A509C: 419A0014  beq cr6, 0x821a50b0
	if ctx.cr[6].eq {
	pc = 0x821A50B0; continue 'dispatch;
	}
	// 821A50A0: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A50A4: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A50A8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A50AC: 419A0008  beq cr6, 0x821a50b4
	if ctx.cr[6].eq {
	pc = 0x821A50B4; continue 'dispatch;
	}
	// 821A50B0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821A50B4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A50B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A50BC: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 821A50C0: 915F00E8  stw r10, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 821A50C4: 937F00D0  stw r27, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[27].u32 ) };
	// 821A50C8: FBBF00E0  std r29, 0xe0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[29].u64 ) };
	// 821A50CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A50D0: 48390034  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A50D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A50D8 size=272
    let mut pc: u32 = 0x821A50D8;
    'dispatch: loop {
        match pc {
            0x821A50D8 => {
    //   block [0x821A50D8..0x821A51E8)
	// 821A50D8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A50DC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A50E0: 814BFAC0  lwz r10, -0x540(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A50E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A50E8: 419A0008  beq cr6, 0x821a50f0
	if ctx.cr[6].eq {
	pc = 0x821A50F0; continue 'dispatch;
	}
	// 821A50EC: 90EA0040  stw r7, 0x40(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(64 as u32), ctx.r[7].u32 ) };
	// 821A50F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A50F4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A50F8: 3D004020  lis r8, 0x4020
	ctx.r[8].s64 = 1075838976;
	// 821A50FC: 38A00120  li r5, 0x120
	ctx.r[5].s64 = 288;
	// 821A5100: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821A5104: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5108: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821A510C: 992A001E  stb r9, 0x1e(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(30 as u32), ctx.r[9].u8 ) };
	// 821A5110: 39200022  li r9, 0x22
	ctx.r[9].s64 = 34;
	// 821A5114: 396B8E40  addi r11, r11, -0x71c0
	ctx.r[11].s64 = ctx.r[11].s64 + -29120;
	// 821A5118: B0EA0084  sth r7, 0x84(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(132 as u32), ctx.r[7].u16 ) };
	// 821A511C: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 821A5120: B0EA0086  sth r7, 0x86(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(134 as u32), ctx.r[7].u16 ) };
	// 821A5124: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 821A5128: 916A0080  stw r11, 0x80(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821A512C: D00A00B0  stfs f0, 0xb0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821A5130: D00A00B4  stfs f0, 0xb4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821A5134: 910A00A8  stw r8, 0xa8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	// 821A5138: 90AA00A4  stw r5, 0xa4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 821A513C: 912A0094  stw r9, 0x94(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 821A5140: 908A0098  stw r4, 0x98(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(152 as u32), ctx.r[4].u32 ) };
	// 821A5144: 906A00A0  stw r3, 0xa0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(160 as u32), ctx.r[3].u32 ) };
	// 821A5148: 816A00D4  lwz r11, 0xd4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A514C: A16B0004  lhz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5150: D00A00B8  stfs f0, 0xb8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821A5154: 3D6B0504  addis r11, r11, 0x504
	ctx.r[11].s64 = ctx.r[11].s64 + 84148224;
	// 821A5158: 396B4000  addi r11, r11, 0x4000
	ctx.r[11].s64 = ctx.r[11].s64 + 16384;
	// 821A515C: 916A0090  stw r11, 0x90(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 821A5160: 812A00D0  lwz r9, 0xd0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A5164: 816A00CC  lwz r11, 0xcc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A5168: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821A516C: 40990074  ble cr6, 0x821a51e0
	if !ctx.cr[6].gt {
	pc = 0x821A51E0; continue 'dispatch;
	}
	// 821A5170: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821A5174: C169BA38  lfs f11, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A5178: 810A00D8  lwz r8, 0xd8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A517C: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 821A5180: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5184: C1A80004  lfs f13, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A5188: C1880008  lfs f12, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A518C: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821A5190: D16B000C  stfs f11, 0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A5194: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821A5198: 5508DFFE  rlwinm r8, r8, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 821A519C: 2F090020  cmpwi cr6, r9, 0x20
	ctx.cr[6].compare_i32(ctx.r[9].s32, 32, &mut ctx.xer);
	// 821A51A0: 910B002C  stw r8, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[8].u32 ) };
	// 821A51A4: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A51A8: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A51AC: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A51B0: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 821A51B4: D16B000C  stfs f11, 0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A51B8: 90EB002C  stw r7, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[7].u32 ) };
	// 821A51BC: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A51C0: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A51C4: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A51C8: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 821A51CC: 4099FFC0  ble cr6, 0x821a518c
	if !ctx.cr[6].gt {
	pc = 0x821A518C; continue 'dispatch;
	}
	// 821A51D0: 812A00D0  lwz r9, 0xd0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A51D4: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821A51D8: 7F064800  cmpw cr6, r6, r9
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821A51DC: 4198FF9C  blt cr6, 0x821a5178
	if ctx.cr[6].lt {
	pc = 0x821A5178; continue 'dispatch;
	}
	// 821A51E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A51E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A51E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A51E8 size=68
    let mut pc: u32 = 0x821A51E8;
    'dispatch: loop {
        match pc {
            0x821A51E8 => {
    //   block [0x821A51E8..0x821A522C)
	// 821A51E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A51EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A51F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A51F4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A51F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A51FC: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A5200: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A5204: 91430040  stw r10, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821A5208: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A520C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A5210: 419A0008  beq cr6, 0x821a5218
	if ctx.cr[6].eq {
	pc = 0x821A5218; continue 'dispatch;
	}
	// 821A5214: 4800001D  bl 0x821a5230
	ctx.lr = 0x821A5218;
	sub_821A5230(ctx, base);
	// 821A5218: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A521C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A5220: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A5224: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A5228: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A5230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A5230 size=648
    let mut pc: u32 = 0x821A5230;
    'dispatch: loop {
        match pc {
            0x821A5230 => {
    //   block [0x821A5230..0x821A54B8)
	// 821A5230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A5234: 4838FE65  bl 0x82535098
	ctx.lr = 0x821A5238;
	sub_82535080(ctx, base);
	// 821A5238: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 821A523C: 48390DA5  bl 0x82535fe0
	ctx.lr = 0x821A5240;
	sub_82535FB0(ctx, base);
	// 821A5240: 9421FA90  stwu r1, -0x570(r1)
	ea = ctx.r[1].u32.wrapping_add(-1392 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A5244: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821A5248: 817900E4  lwz r11, 0xe4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(228 as u32) ) } as u64;
	// 821A524C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5250: 419A0018  beq cr6, 0x821a5268
	if ctx.cr[6].eq {
	pc = 0x821A5268; continue 'dispatch;
	}
	// 821A5254: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5258: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 821A525C: 813900E0  lwz r9, 0xe0(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(224 as u32) ) } as u64;
	// 821A5260: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A5264: 419A0008  beq cr6, 0x821a526c
	if ctx.cr[6].eq {
	pc = 0x821A526C; continue 'dispatch;
	}
	// 821A5268: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821A526C: 817B0084  lwz r11, 0x84(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A5270: 82B900CC  lwz r21, 0xcc(r25)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A5274: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A5278: 409A000C  bne cr6, 0x821a5284
	if !ctx.cr[6].eq {
	pc = 0x821A5284; continue 'dispatch;
	}
	// 821A527C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821A5280: 4800000C  b 0x821a528c
	pc = 0x821A528C; continue 'dispatch;
	// 821A5284: 815B008C  lwz r10, 0x8c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A5288: 7F8A5A14  add r28, r10, r11
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A528C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821A5290: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821A5294: 419A0208  beq cr6, 0x821a549c
	if ctx.cr[6].eq {
	pc = 0x821A549C; continue 'dispatch;
	}
	// 821A5298: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 821A529C: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821A52A0: 3B0B33E0  addi r24, r11, 0x33e0
	ctx.r[24].s64 = ctx.r[11].s64 + 13280;
	// 821A52A4: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821A52A8: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821A52AC: 3AEBCFE0  addi r23, r11, -0x3020
	ctx.r[23].s64 = ctx.r[11].s64 + -12320;
	// 821A52B0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821A52B4: C347BA38  lfs f26, -0x45c8(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 821A52B8: 3D208288  lis r9, -0x7d78
	ctx.r[9].s64 = -2105016320;
	// 821A52BC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A52C0: 3ACBD000  addi r22, r11, -0x3000
	ctx.r[22].s64 = ctx.r[11].s64 + -12288;
	// 821A52C4: C3682098  lfs f27, 0x2098(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8344 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821A52C8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821A52CC: 3A9900F0  addi r20, r25, 0xf0
	ctx.r[20].s64 = ctx.r[25].s64 + 240;
	// 821A52D0: C389D4DC  lfs f28, -0x2b24(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821A52D4: 3BABCFF0  addi r29, r11, -0x3010
	ctx.r[29].s64 = ctx.r[11].s64 + -12304;
	// 821A52D8: C3AA1FF8  lfs f29, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821A52DC: 817B0098  lwz r11, 0x98(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A52E0: 395C0024  addi r10, r28, 0x24
	ctx.r[10].s64 = ctx.r[28].s64 + 36;
	// 821A52E4: 392B0020  addi r9, r11, 0x20
	ctx.r[9].s64 = ctx.r[11].s64 + 32;
	// 821A52E8: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A52EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A52F0: 409A000C  bne cr6, 0x821a52fc
	if !ctx.cr[6].eq {
	pc = 0x821A52FC; continue 'dispatch;
	}
	// 821A52F4: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A52F8: 48000020  b 0x821a5318
	pc = 0x821A5318; continue 'dispatch;
	// 821A52FC: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 821A5300: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5304: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A5308: 7C0047AE  stfiwx f0, 0, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 821A530C: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A5310: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A5314: 7DA85C2E  lfsx f13, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A5318: 817900D4  lwz r11, 0xd4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A531C: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 821A5320: 39090020  addi r8, r9, 0x20
	ctx.r[8].s64 = ctx.r[9].s64 + 32;
	// 821A5324: 392A0008  addi r9, r10, 8
	ctx.r[9].s64 = ctx.r[10].s64 + 8;
	// 821A5328: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A532C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A5330: 419A0070  beq cr6, 0x821a53a0
	if ctx.cr[6].eq {
	pc = 0x821A53A0; continue 'dispatch;
	}
	// 821A5334: 8148001C  lwz r10, 0x1c(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 821A5338: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A533C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A5340: 419A001C  beq cr6, 0x821a535c
	if ctx.cr[6].eq {
	pc = 0x821A535C; continue 'dispatch;
	}
	// 821A5344: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 821A5348: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A534C: 7C003FAE  stfiwx f0, 0, r7
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32, tmp.u32) };
	// 821A5350: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A5354: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821A5358: 7C07542E  lfsx f0, r7, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A535C: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 821A5360: 40980008  bge cr6, 0x821a5368
	if !ctx.cr[6].lt {
	pc = 0x821A5368; continue 'dispatch;
	}
	// 821A5364: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 821A5368: A0EB0012  lhz r7, 0x12(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A536C: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A5370: 7CEB07B4  extsw r11, r7
	ctx.r[11].s64 = ctx.r[7].s32 as i64;
	// 821A5374: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821A5378: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821A537C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 821A5380: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821A5384: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A5388: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821A538C: D8010068  stfd f0, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[0].u64 ) };
	// 821A5390: A161006E  lhz r11, 0x6e(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(110 as u32) ) } as u64;
	// 821A5394: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A5398: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A539C: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821A53A0: 8168002C  lwz r11, 0x2c(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A53A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A53A8: 409A000C  bne cr6, 0x821a53b4
	if !ctx.cr[6].eq {
	pc = 0x821A53B4; continue 'dispatch;
	}
	// 821A53AC: C3C90008  lfs f30, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A53B0: 48000020  b 0x821a53d0
	pc = 0x821A53D0; continue 'dispatch;
	// 821A53B4: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 821A53B8: C0090008  lfs f0, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A53BC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A53C0: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821A53C4: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A53C8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A53CC: 7FCA5C2E  lfsx f30, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A53D0: 817900D8  lwz r11, 0xd8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A53D4: C01C0184  lfs f0, 0x184(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A53D8: EC2D0732  fmuls f1, f13, f28
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[28].f64) as f32) as f64);
	// 821A53DC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A53E0: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821A53E4: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 821A53E8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821A53EC: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A53F0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 821A53F4: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A53F8: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A53FC: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A5400: 817B0094  lwz r11, 0x94(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A5404: 396B0006  addi r11, r11, 6
	ctx.r[11].s64 = ctx.r[11].s64 + 6;
	// 821A5408: EC41D82A  fadds f2, f1, f27
	ctx.f[2].f64 = ((ctx.f[1].f64 + ctx.f[27].f64) as f32) as f64;
	// 821A540C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A5410: 7FCBE214  add r30, r11, r28
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821A5414: 4800ACFD  bl 0x821b0110
	ctx.lr = 0x821A5418;
	sub_821B0110(ctx, base);
	// 821A5418: 7EC9B378  mr r9, r22
	ctx.r[9].u64 = ctx.r[22].u64;
	// 821A541C: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 821A5420: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 821A5424: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821A5428: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821A542C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821A5430: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821A5434: 4800AD65  bl 0x821b0198
	ctx.lr = 0x821A5438;
	sub_821B0198(ctx, base);
	// 821A5438: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 821A543C: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 821A5440: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 821A5444: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 821A5448: 4800AFE1  bl 0x821b0428
	ctx.lr = 0x821A544C;
	sub_821B0428(ctx, base);
	// 821A544C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821A5450: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 821A5454: FC60D090  fmr f3, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[26].f64;
	// 821A5458: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821A545C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 821A5460: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 821A5464: EC3F07B2  fmuls f1, f31, f30
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[30].f64) as f32) as f64);
	// 821A5468: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 821A546C: 4800BA7D  bl 0x821b0ee8
	ctx.lr = 0x821A5470;
	sub_821B0EE8(ctx, base);
	// 821A5470: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5474: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 821A5478: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 821A547C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A5480: 409A000C  bne cr6, 0x821a548c
	if !ctx.cr[6].eq {
	pc = 0x821A548C; continue 'dispatch;
	}
	// 821A5484: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821A5488: 4800000C  b 0x821a5494
	pc = 0x821A5494; continue 'dispatch;
	// 821A548C: 815B008C  lwz r10, 0x8c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A5490: 7F8A5A14  add r28, r10, r11
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A5494: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821A5498: 409AFE44  bne cr6, 0x821a52dc
	if !ctx.cr[6].eq {
	pc = 0x821A52DC; continue 'dispatch;
	}
	// 821A549C: 1D7A0042  mulli r11, r26, 0x42
	ctx.r[11].s64 = ctx.r[26].s64 * 66;
	// 821A54A0: 935900C8  stw r26, 0xc8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(200 as u32), ctx.r[26].u32 ) };
	// 821A54A4: 917900C4  stw r11, 0xc4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 821A54A8: 38210570  addi r1, r1, 0x570
	ctx.r[1].s64 = ctx.r[1].s64 + 1392;
	// 821A54AC: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 821A54B0: 48390B7D  bl 0x8253602c
	ctx.lr = 0x821A54B4;
	sub_82535FFC(ctx, base);
	// 821A54B4: 4838FC34  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A54B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A54B8 size=40
    let mut pc: u32 = 0x821A54B8;
    'dispatch: loop {
        match pc {
            0x821A54B8 => {
    //   block [0x821A54B8..0x821A54E0)
	// 821A54B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A54BC: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821A54C0: 38CB0090  addi r6, r11, 0x90
	ctx.r[6].s64 = ctx.r[11].s64 + 144;
	// 821A54C4: 394AC470  addi r10, r10, -0x3b90
	ctx.r[10].s64 = ctx.r[10].s64 + -15248;
	// 821A54C8: 38AB0080  addi r5, r11, 0x80
	ctx.r[5].s64 = ctx.r[11].s64 + 128;
	// 821A54CC: 80EB00CC  lwz r7, 0xcc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A54D0: 390A0060  addi r8, r10, 0x60
	ctx.r[8].s64 = ctx.r[10].s64 + 96;
	// 821A54D4: 808B00C8  lwz r4, 0xc8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 821A54D8: 806B00C4  lwz r3, 0xc4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 821A54DC: 481C87E4  b 0x8236dcc0
	sub_8236DCC0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A54E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A54E0 size=88
    let mut pc: u32 = 0x821A54E0;
    'dispatch: loop {
        match pc {
            0x821A54E0 => {
    //   block [0x821A54E0..0x821A5538)
	// 821A54E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A54E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A54E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A54EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A54F0: A164000C  lhz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A54F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A54F8: 4099002C  ble cr6, 0x821a5524
	if !ctx.cr[6].gt {
	pc = 0x821A5524; continue 'dispatch;
	}
	// 821A54FC: 481C1C3D  bl 0x82367138
	ctx.lr = 0x821A5500;
	sub_82367138(ctx, base);
	// 821A5500: A164000C  lhz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A5504: 7D435B96  divwu r10, r3, r11
	ctx.r[10].u32 = ctx.r[3].u32 / ctx.r[11].u32;
	// 821A5508: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 821A550C: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821A5510: 5563043E  clrlwi r3, r11, 0x10
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821A5514: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A5518: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A551C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A5520: 4E800020  blr
	return;
	// 821A5524: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A5528: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A552C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A5530: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A5534: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A5538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A5538 size=416
    let mut pc: u32 = 0x821A5538;
    'dispatch: loop {
        match pc {
            0x821A5538 => {
    //   block [0x821A5538..0x821A56D8)
	// 821A5538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A553C: 4838FB75  bl 0x825350b0
	ctx.lr = 0x821A5540;
	sub_82535080(ctx, base);
	// 821A5540: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A5544: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A5548: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821A554C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A5550: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821A5554: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 821A5558: 38EB0E34  addi r7, r11, 0xe34
	ctx.r[7].s64 = ctx.r[11].s64 + 3636;
	// 821A555C: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 821A5560: FBBE0000  std r29, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u64 ) };
	// 821A5564: 38A00289  li r5, 0x289
	ctx.r[5].s64 = 649;
	// 821A5568: 38600110  li r3, 0x110
	ctx.r[3].s64 = 272;
	// 821A556C: 481C4F25  bl 0x8236a490
	ctx.lr = 0x821A5570;
	sub_8236A490(ctx, base);
	// 821A5570: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A5574: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A5578: 419A000C  beq cr6, 0x821a5584
	if ctx.cr[6].eq {
	pc = 0x821A5584; continue 'dispatch;
	}
	// 821A557C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5580: 48000008  b 0x821a5588
	pc = 0x821A5588; continue 'dispatch;
	// 821A5584: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821A5588: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A558C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A5590: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A5594: 419A00B8  beq cr6, 0x821a564c
	if ctx.cr[6].eq {
	pc = 0x821A564C; continue 'dispatch;
	}
	// 821A5598: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A559C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821A55A0: 396B0E3C  addi r11, r11, 0xe3c
	ctx.r[11].s64 = ctx.r[11].s64 + 3644;
	// 821A55A4: 3D00821A  lis r8, -0x7de6
	ctx.r[8].s64 = -2112225280;
	// 821A55A8: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 821A55AC: 390856D8  addi r8, r8, 0x56d8
	ctx.r[8].s64 = ctx.r[8].s64 + 22232;
	// 821A55B0: 39295780  addi r9, r9, 0x5780
	ctx.r[9].s64 = ctx.r[9].s64 + 22400;
	// 821A55B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A55B8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A55BC: 93BF0080  stw r29, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 821A55C0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821A55C4: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A55C8: B3BF0084  sth r29, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[29].u16 ) };
	// 821A55CC: B3BF0086  sth r29, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[29].u16 ) };
	// 821A55D0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A55D4: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 821A55D8: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A55DC: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A55E0: FBBF00F0  std r29, 0xf0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[29].u64 ) };
	// 821A55E4: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A55E8: FBBF00F8  std r29, 0xf8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[29].u64 ) };
	// 821A55EC: 394A6FC8  addi r10, r10, 0x6fc8
	ctx.r[10].s64 = ctx.r[10].s64 + 28616;
	// 821A55F0: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821A55F4: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 821A55F8: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821A55FC: 38BF00CC  addi r5, r31, 0xcc
	ctx.r[5].s64 = ctx.r[31].s64 + 204;
	// 821A5600: 9B7F001C  stb r27, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 821A5604: 55643032  slwi r4, r11, 6
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A5608: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A560C: 4BFFC625  bl 0x821a1c30
	ctx.lr = 0x821A5610;
	sub_821A1C30(ctx, base);
	// 821A5610: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5614: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A5618: 409A0044  bne cr6, 0x821a565c
	if !ctx.cr[6].eq {
	pc = 0x821A565C; continue 'dispatch;
	}
	// 821A561C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5620: 419A002C  beq cr6, 0x821a564c
	if ctx.cr[6].eq {
	pc = 0x821A564C; continue 'dispatch;
	}
	// 821A5624: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5628: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A562C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A5630: 409A001C  bne cr6, 0x821a564c
	if !ctx.cr[6].eq {
	pc = 0x821A564C; continue 'dispatch;
	}
	// 821A5634: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A5638: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A563C: 9B6B0025  stb r27, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[27].u8 ) };
	// 821A5640: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A5644: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821A5648: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 821A564C: FBBE0000  std r29, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u64 ) };
	// 821A5650: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A5654: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A5658: 4838FAA8  b 0x82535100
	sub_825350D0(ctx, base);
	return;
	// 821A565C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5660: 419A0014  beq cr6, 0x821a5674
	if ctx.cr[6].eq {
	pc = 0x821A5674; continue 'dispatch;
	}
	// 821A5664: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5668: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A566C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A5670: 419A0008  beq cr6, 0x821a5678
	if ctx.cr[6].eq {
	pc = 0x821A5678; continue 'dispatch;
	}
	// 821A5674: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821A5678: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A567C: 393F00E0  addi r9, r31, 0xe0
	ctx.r[9].s64 = ctx.r[31].s64 + 224;
	// 821A5680: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 821A5684: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821A5688: 915F00F8  stw r10, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[10].u32 ) };
	// 821A568C: FBBF00F0  std r29, 0xf0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[29].u64 ) };
	// 821A5690: 939F00D0  stw r28, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[28].u32 ) };
	// 821A5694: 913F00D8  stw r9, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[9].u32 ) };
	// 821A5698: 419A0024  beq cr6, 0x821a56bc
	if ctx.cr[6].eq {
	pc = 0x821A56BC; continue 'dispatch;
	}
	// 821A569C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A56A0: 395F0100  addi r10, r31, 0x100
	ctx.r[10].s64 = ctx.r[31].s64 + 256;
	// 821A56A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A56A8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A56AC: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A56B0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821A56B4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A56B8: 4838FA48  b 0x82535100
	sub_825350D0(ctx, base);
	return;
	// 821A56BC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A56C0: 93BF0100  stw r29, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[29].u32 ) };
	// 821A56C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A56C8: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A56CC: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 821A56D0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A56D4: 4838FA2C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A56D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A56D8 size=164
    let mut pc: u32 = 0x821A56D8;
    'dispatch: loop {
        match pc {
            0x821A56D8 => {
    //   block [0x821A56D8..0x821A577C)
	// 821A56D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A56DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A56E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A56E4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A56E8: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A56EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A56F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A56F4: 419A0008  beq cr6, 0x821a56fc
	if ctx.cr[6].eq {
	pc = 0x821A56FC; continue 'dispatch;
	}
	// 821A56F8: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 821A56FC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A5700: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A5704: 3D004020  lis r8, 0x4020
	ctx.r[8].s64 = 1075838976;
	// 821A5708: 38E00120  li r7, 0x120
	ctx.r[7].s64 = 288;
	// 821A570C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821A5710: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5714: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 821A5718: 9923001E  stb r9, 0x1e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[9].u8 ) };
	// 821A571C: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 821A5720: 394A8E40  addi r10, r10, -0x71c0
	ctx.r[10].s64 = ctx.r[10].s64 + -29120;
	// 821A5724: B1630084  sth r11, 0x84(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u16 ) };
	// 821A5728: 39200022  li r9, 0x22
	ctx.r[9].s64 = 34;
	// 821A572C: B1630086  sth r11, 0x86(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(134 as u32), ctx.r[11].u16 ) };
	// 821A5730: 91430080  stw r10, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821A5734: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821A5738: D00300B4  stfs f0, 0xb4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821A573C: 910300A8  stw r8, 0xa8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	// 821A5740: 90E300A4  stw r7, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[7].u32 ) };
	// 821A5744: 91230094  stw r9, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 821A5748: 90C30098  stw r6, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[6].u32 ) };
	// 821A574C: 90A300A0  stw r5, 0xa0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[5].u32 ) };
	// 821A5750: 816300D4  lwz r11, 0xd4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A5754: A16B0004  lhz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5758: 3D6B0504  addis r11, r11, 0x504
	ctx.r[11].s64 = ctx.r[11].s64 + 84148224;
	// 821A575C: 396B4000  addi r11, r11, 0x4000
	ctx.r[11].s64 = ctx.r[11].s64 + 16384;
	// 821A5760: 91630090  stw r11, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 821A5764: 480018AD  bl 0x821a7010
	ctx.lr = 0x821A5768;
	sub_821A7010(ctx, base);
	// 821A5768: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A576C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A5770: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A5774: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A5778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A5780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A5780 size=68
    let mut pc: u32 = 0x821A5780;
    'dispatch: loop {
        match pc {
            0x821A5780 => {
    //   block [0x821A5780..0x821A57C4)
	// 821A5780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A5784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A5788: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A578C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A5790: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A5794: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A5798: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A579C: 91430040  stw r10, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821A57A0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A57A4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A57A8: 419A0008  beq cr6, 0x821a57b0
	if ctx.cr[6].eq {
	pc = 0x821A57B0; continue 'dispatch;
	}
	// 821A57AC: 4800001D  bl 0x821a57c8
	ctx.lr = 0x821A57B0;
	sub_821A57C8(ctx, base);
	// 821A57B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A57B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A57B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A57BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A57C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A57C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A57C8 size=892
    let mut pc: u32 = 0x821A57C8;
    'dispatch: loop {
        match pc {
            0x821A57C8 => {
    //   block [0x821A57C8..0x821A5B44)
	// 821A57C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A57CC: 4838F8CD  bl 0x82535098
	ctx.lr = 0x821A57D0;
	sub_82535080(ctx, base);
	// 821A57D0: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 821A57D4: 4839080D  bl 0x82535fe0
	ctx.lr = 0x821A57D8;
	sub_82535FB0(ctx, base);
	// 821A57D8: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A57DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A57E0: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 821A57E4: 817D00F4  lwz r11, 0xf4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(244 as u32) ) } as u64;
	// 821A57E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A57EC: 419A0018  beq cr6, 0x821a5804
	if ctx.cr[6].eq {
	pc = 0x821A5804; continue 'dispatch;
	}
	// 821A57F0: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A57F4: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 821A57F8: 813D00F0  lwz r9, 0xf0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(240 as u32) ) } as u64;
	// 821A57FC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A5800: 419A0008  beq cr6, 0x821a5808
	if ctx.cr[6].eq {
	pc = 0x821A5808; continue 'dispatch;
	}
	// 821A5804: 7E99A378  mr r25, r20
	ctx.r[25].u64 = ctx.r[20].u64;
	// 821A5808: 81790084  lwz r11, 0x84(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A580C: 83FD00CC  lwz r31, 0xcc(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A5810: 837900CC  lwz r27, 0xcc(r25)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A5814: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A5818: 409A000C  bne cr6, 0x821a5824
	if !ctx.cr[6].eq {
	pc = 0x821A5824; continue 'dispatch;
	}
	// 821A581C: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 821A5820: 4800000C  b 0x821a582c
	pc = 0x821A582C; continue 'dispatch;
	// 821A5824: 8159008C  lwz r10, 0x8c(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A5828: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A582C: 839D00D4  lwz r28, 0xd4(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A5830: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A5834: 7E95A378  mr r21, r20
	ctx.r[21].u64 = ctx.r[20].u64;
	// 821A5838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A583C: 419A02EC  beq cr6, 0x821a5b28
	if ctx.cr[6].eq {
	pc = 0x821A5B28; continue 'dispatch;
	}
	// 821A5840: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821A5844: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 821A5848: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821A584C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A5850: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A5854: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821A5858: C3A6BA38  lfs f29, -0x45c8(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821A585C: C367CFEC  lfs f27, -0x3014(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-12308 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821A5860: 3B400010  li r26, 0x10
	ctx.r[26].s64 = 16;
	// 821A5864: C388218C  lfs f28, 0x218c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8588 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821A5868: 3ACB14A0  addi r22, r11, 0x14a0
	ctx.r[22].s64 = ctx.r[11].s64 + 5280;
	// 821A586C: C3492278  lfs f26, 0x2278(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8824 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 821A5870: 3AE00030  li r23, 0x30
	ctx.r[23].s64 = 48;
	// 821A5874: C3CA1FF8  lfs f30, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A5878: 3B000020  li r24, 0x20
	ctx.r[24].s64 = 32;
	// 821A587C: A17E0010  lhz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A5880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5884: 419A0040  beq cr6, 0x821a58c4
	if ctx.cr[6].eq {
	pc = 0x821A58C4; continue 'dispatch;
	}
	// 821A5888: B29E0010  sth r20, 0x10(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[20].u16 ) };
	// 821A588C: A17C000C  lhz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A5890: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A5894: 40990024  ble cr6, 0x821a58b8
	if !ctx.cr[6].gt {
	pc = 0x821A58B8; continue 'dispatch;
	}
	// 821A5898: 481C18A1  bl 0x82367138
	ctx.lr = 0x821A589C;
	sub_82367138(ctx, base);
	// 821A589C: A17C000C  lhz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A58A0: 7D435B96  divwu r10, r3, r11
	ctx.r[10].u32 = ctx.r[3].u32 / ctx.r[11].u32;
	// 821A58A4: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 821A58A8: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821A58AC: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821A58B0: B17E0198  sth r11, 0x198(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(408 as u32), ctx.r[11].u16 ) };
	// 821A58B4: 4800024C  b 0x821a5b00
	pc = 0x821A5B00; continue 'dispatch;
	// 821A58B8: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 821A58BC: B17E0198  sth r11, 0x198(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(408 as u32), ctx.r[11].u16 ) };
	// 821A58C0: 48000240  b 0x821a5b00
	pc = 0x821A5B00; continue 'dispatch;
	// 821A58C4: 839D00D4  lwz r28, 0xd4(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A58C8: 391E003C  addi r8, r30, 0x3c
	ctx.r[8].s64 = ctx.r[30].s64 + 60;
	// 821A58CC: 80F90098  lwz r7, 0x98(r25)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A58D0: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A58D4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A58D8: 419A00C4  beq cr6, 0x821a599c
	if ctx.cr[6].eq {
	pc = 0x821A599C; continue 'dispatch;
	}
	// 821A58DC: 8167005C  lwz r11, 0x5c(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(92 as u32) ) } as u64;
	// 821A58E0: C0080000  lfs f0, 0(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A58E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A58E8: 419A001C  beq cr6, 0x821a5904
	if ctx.cr[6].eq {
	pc = 0x821A5904; continue 'dispatch;
	}
	// 821A58EC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821A58F0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A58F4: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821A58F8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A58FC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A5900: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5904: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 821A5908: 40980008  bge cr6, 0x821a5910
	if !ctx.cr[6].lt {
	pc = 0x821A5910; continue 'dispatch;
	}
	// 821A590C: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 821A5910: A17E0198  lhz r11, 0x198(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(408 as u32) ) } as u64;
	// 821A5914: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 821A5918: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A591C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A5920: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821A5924: A0CB0012  lhz r6, 0x12(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A5928: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A592C: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 821A5930: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821A5934: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821A5938: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821A593C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A5940: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A5944: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821A5948: D8010068  stfd f0, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[0].u64 ) };
	// 821A594C: A161006E  lhz r11, 0x6e(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(110 as u32) ) } as u64;
	// 821A5950: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A5954: 556B2AF4  rlwinm r11, r11, 5, 0xb, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 821A5958: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821A595C: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5960: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821A5964: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5968: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821A596C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5970: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821A5974: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5978: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821A597C: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5980: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821A5984: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5988: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821A598C: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5990: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821A5994: C00B001C  lfs f0, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5998: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821A599C: 8167006C  lwz r11, 0x6c(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A59A0: C0080008  lfs f0, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A59A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A59A8: 419A001C  beq cr6, 0x821a59c4
	if ctx.cr[6].eq {
	pc = 0x821A59C4; continue 'dispatch;
	}
	// 821A59AC: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 821A59B0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A59B4: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821A59B8: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A59BC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A59C0: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A59C4: 817900A0  lwz r11, 0xa0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A59C8: 556B018C  rlwinm r11, r11, 0, 6, 6
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A59CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A59D0: 419A0010  beq cr6, 0x821a59e0
	if ctx.cr[6].eq {
	pc = 0x821A59E0; continue 'dispatch;
	}
	// 821A59D4: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 821A59D8: 40990008  ble cr6, 0x821a59e0
	if !ctx.cr[6].gt {
	pc = 0x821A59E0; continue 'dispatch;
	}
	// 821A59DC: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 821A59E0: 817D00D8  lwz r11, 0xd8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A59E4: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 821A59E8: 38C1005C  addi r6, r1, 0x5c
	ctx.r[6].s64 = ctx.r[1].s64 + 92;
	// 821A59EC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821A59F0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821A59F4: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A59F8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A59FC: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821A5A00: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 821A5A04: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 821A5A08: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 821A5A0C: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A5A10: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 821A5A14: 4BFFE0F5  bl 0x821a3b08
	ctx.lr = 0x821A5A18;
	sub_821A3B08(ctx, base);
	// 821A5A18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A5A1C: 3964FFE9  addi r11, r4, -0x17
	ctx.r[11].s64 = ctx.r[4].s64 + -23;
	// 821A5A20: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 821A5A24: 4199000C  bgt cr6, 0x821a5a30
	if ctx.cr[6].gt {
	pc = 0x821A5A30; continue 'dispatch;
	}
	// 821A5A28: FFE0D890  fmr f31, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[27].f64;
	// 821A5A2C: 48000008  b 0x821a5a34
	pc = 0x821A5A34; continue 'dispatch;
	// 821A5A30: FFE0D090  fmr f31, f26
	ctx.f[31].f64 = ctx.f[26].f64;
	// 821A5A34: 817B0030  lwz r11, 0x30(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5A38: 387B0030  addi r3, r27, 0x30
	ctx.r[3].s64 = ctx.r[27].s64 + 48;
	// 821A5A3C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A5A40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A5A44: 4E800421  bctrl
	ctx.lr = 0x821A5A48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A5A48: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A5B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A5B48 size=852
    let mut pc: u32 = 0x821A5B48;
    'dispatch: loop {
        match pc {
            0x821A5B48 => {
    //   block [0x821A5B48..0x821A5E9C)
	// 821A5B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A5B4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A5B50: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A5B54: 3D6082C3  lis r11, -0x7d3d
	ctx.r[11].s64 = -2101149696;
	// 821A5B58: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821A5B5C: 394B5518  addi r10, r11, 0x5518
	ctx.r[10].s64 = ctx.r[11].s64 + 21784;
	// 821A5B60: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5B64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5B68: 419A0014  beq cr6, 0x821a5b7c
	if ctx.cr[6].eq {
	pc = 0x821A5B7C; continue 'dispatch;
	}
	// 821A5B6C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5B70: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A5B74: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A5B78: 419A0008  beq cr6, 0x821a5b80
	if ctx.cr[6].eq {
	pc = 0x821A5B80; continue 'dispatch;
	}
	// 821A5B7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A5B80: 396B0090  addi r11, r11, 0x90
	ctx.r[11].s64 = ctx.r[11].s64 + 144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A5EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A5EA0 size=356
    let mut pc: u32 = 0x821A5EA0;
    'dispatch: loop {
        match pc {
            0x821A5EA0 => {
    //   block [0x821A5EA0..0x821A6004)
	// 821A5EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A5EA4: 4838F211  bl 0x825350b4
	ctx.lr = 0x821A5EA8;
	sub_82535080(ctx, base);
	// 821A5EA8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A5EAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A5EB0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821A5EB4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A5EB8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821A5EBC: 38EB0E5C  addi r7, r11, 0xe5c
	ctx.r[7].s64 = ctx.r[11].s64 + 3676;
	// 821A5EC0: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 821A5EC4: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 821A5EC8: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821A5ECC: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 821A5ED0: 481C45C1  bl 0x8236a490
	ctx.lr = 0x821A5ED4;
	sub_8236A490(ctx, base);
	// 821A5ED4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A5ED8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A5EDC: 419A000C  beq cr6, 0x821a5ee8
	if ctx.cr[6].eq {
	pc = 0x821A5EE8; continue 'dispatch;
	}
	// 821A5EE0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5EE4: 48000008  b 0x821a5eec
	pc = 0x821A5EEC; continue 'dispatch;
	// 821A5EE8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821A5EEC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A5EF0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A5EF4: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A5EF8: 419A00B8  beq cr6, 0x821a5fb0
	if ctx.cr[6].eq {
	pc = 0x821A5FB0; continue 'dispatch;
	}
	// 821A5EFC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A5F00: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821A5F04: 396B0E3C  addi r11, r11, 0xe3c
	ctx.r[11].s64 = ctx.r[11].s64 + 3644;
	// 821A5F08: 3D00821A  lis r8, -0x7de6
	ctx.r[8].s64 = -2112225280;
	// 821A5F0C: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 821A5F10: 39086008  addi r8, r8, 0x6008
	ctx.r[8].s64 = ctx.r[8].s64 + 24584;
	// 821A5F14: 392960B0  addi r9, r9, 0x60b0
	ctx.r[9].s64 = ctx.r[9].s64 + 24752;
	// 821A5F18: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A5F1C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A5F20: 939F0080  stw r28, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 821A5F24: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821A5F28: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A5F2C: B39F0084  sth r28, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[28].u16 ) };
	// 821A5F30: B39F0086  sth r28, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[28].u16 ) };
	// 821A5F34: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A5F38: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 821A5F3C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A5F40: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A5F44: FB9F00F0  std r28, 0xf0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[28].u64 ) };
	// 821A5F48: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A5F4C: FB9F00F8  std r28, 0xf8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[28].u64 ) };
	// 821A5F50: 394A6FC8  addi r10, r10, 0x6fc8
	ctx.r[10].s64 = ctx.r[10].s64 + 28616;
	// 821A5F54: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821A5F58: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821A5F5C: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821A5F60: 38BF00CC  addi r5, r31, 0xcc
	ctx.r[5].s64 = ctx.r[31].s64 + 204;
	// 821A5F64: 9B7F001C  stb r27, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 821A5F68: 5564482C  slwi r4, r11, 9
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(9);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A5F6C: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A5F70: 4BFFBCC1  bl 0x821a1c30
	ctx.lr = 0x821A5F74;
	sub_821A1C30(ctx, base);
	// 821A5F74: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5F78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A5F7C: 409A0044  bne cr6, 0x821a5fc0
	if !ctx.cr[6].eq {
	pc = 0x821A5FC0; continue 'dispatch;
	}
	// 821A5F80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5F84: 419A002C  beq cr6, 0x821a5fb0
	if ctx.cr[6].eq {
	pc = 0x821A5FB0; continue 'dispatch;
	}
	// 821A5F88: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5F8C: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A5F90: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A5F94: 409A001C  bne cr6, 0x821a5fb0
	if !ctx.cr[6].eq {
	pc = 0x821A5FB0; continue 'dispatch;
	}
	// 821A5F98: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A5F9C: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A5FA0: 9B6B0025  stb r27, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[27].u8 ) };
	// 821A5FA4: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A5FA8: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821A5FAC: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 821A5FB0: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821A5FB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A5FB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A5FBC: 4838F148  b 0x82535104
	sub_825350D0(ctx, base);
	return;
	// 821A5FC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5FC4: 419A0014  beq cr6, 0x821a5fd8
	if ctx.cr[6].eq {
	pc = 0x821A5FD8; continue 'dispatch;
	}
	// 821A5FC8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5FCC: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A5FD0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A5FD4: 419A0008  beq cr6, 0x821a5fdc
	if ctx.cr[6].eq {
	pc = 0x821A5FDC; continue 'dispatch;
	}
	// 821A5FD8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821A5FDC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A5FE0: 393F00E0  addi r9, r31, 0xe0
	ctx.r[9].s64 = ctx.r[31].s64 + 224;
	// 821A5FE4: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 821A5FE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A5FEC: 915F00F8  stw r10, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[10].u32 ) };
	// 821A5FF0: FB9F00F0  std r28, 0xf0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[28].u64 ) };
	// 821A5FF4: 93BF00D0  stw r29, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[29].u32 ) };
	// 821A5FF8: 913F00D8  stw r9, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[9].u32 ) };
	// 821A5FFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A6000: 4838F104  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A6008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A6008 size=168
    let mut pc: u32 = 0x821A6008;
    'dispatch: loop {
        match pc {
            0x821A6008 => {
    //   block [0x821A6008..0x821A60B0)
	// 821A6008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A600C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A6010: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A6014: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A6018: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A601C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A6020: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A6024: 419A0008  beq cr6, 0x821a602c
	if ctx.cr[6].eq {
	pc = 0x821A602C; continue 'dispatch;
	}
	// 821A6028: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 821A602C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A6030: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A6034: 3D004020  lis r8, 0x4020
	ctx.r[8].s64 = 1075838976;
	// 821A6038: 38E00120  li r7, 0x120
	ctx.r[7].s64 = 288;
	// 821A603C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821A6040: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6044: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 821A6048: 9923001E  stb r9, 0x1e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[9].u8 ) };
	// 821A604C: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 821A6050: 394A8E40  addi r10, r10, -0x71c0
	ctx.r[10].s64 = ctx.r[10].s64 + -29120;
	// 821A6054: B1630084  sth r11, 0x84(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u16 ) };
	// 821A6058: 39200022  li r9, 0x22
	ctx.r[9].s64 = 34;
	// 821A605C: B1630086  sth r11, 0x86(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(134 as u32), ctx.r[11].u16 ) };
	// 821A6060: 91430080  stw r10, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821A6064: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821A6068: D00300B4  stfs f0, 0xb4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821A606C: 910300A8  stw r8, 0xa8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	// 821A6070: 90E300A4  stw r7, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[7].u32 ) };
	// 821A6074: 91230094  stw r9, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 821A6078: 90C30098  stw r6, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[6].u32 ) };
	// 821A607C: 90A300A0  stw r5, 0xa0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[5].u32 ) };
	// 821A6080: 816300D4  lwz r11, 0xd4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A6084: A16B0004  lhz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6088: D00300B8  stfs f0, 0xb8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821A608C: 3D6B0504  addis r11, r11, 0x504
	ctx.r[11].s64 = ctx.r[11].s64 + 84148224;
	// 821A6090: 396B4000  addi r11, r11, 0x4000
	ctx.r[11].s64 = ctx.r[11].s64 + 16384;
	// 821A6094: 91630090  stw r11, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 821A6098: 48000061  bl 0x821a60f8
	ctx.lr = 0x821A609C;
	sub_821A60F8(ctx, base);
	// 821A609C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A60A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A60A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A60A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A60AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A60B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A60B0 size=68
    let mut pc: u32 = 0x821A60B0;
    'dispatch: loop {
        match pc {
            0x821A60B0 => {
    //   block [0x821A60B0..0x821A60F4)
	// 821A60B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A60B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A60B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A60BC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A60C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A60C4: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A60C8: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A60CC: 91430040  stw r10, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821A60D0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A60D4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A60D8: 419A0008  beq cr6, 0x821a60e0
	if ctx.cr[6].eq {
	pc = 0x821A60E0; continue 'dispatch;
	}
	// 821A60DC: 480000ED  bl 0x821a61c8
	ctx.lr = 0x821A60E0;
	sub_821A61C8(ctx, base);
	// 821A60E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A60E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A60E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A60EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A60F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A60F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A60F8 size=204
    let mut pc: u32 = 0x821A60F8;
    'dispatch: loop {
        match pc {
            0x821A60F8 => {
    //   block [0x821A60F8..0x821A61C4)
	// 821A60F8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 821A60FC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A6100: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 821A6104: 814600D0  lwz r10, 0xd0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A6108: 810600D8  lwz r8, 0xd8(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A610C: 55471838  slwi r7, r10, 3
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821A6110: 816600CC  lwz r11, 0xcc(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A6114: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A6118: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821A611C: 554A402E  slwi r10, r10, 8
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A6120: C0080000  lfs f0, 0(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6124: C1A80004  lfs f13, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A6128: C1880008  lfs f12, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A612C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A6130: 40990078  ble cr6, 0x821a61a8
	if !ctx.cr[6].gt {
	pc = 0x821A61A8; continue 'dispatch;
	}
	// 821A6134: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821A6138: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821A613C: C16ABA38  lfs f11, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A6140: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 821A6144: D16B000C  stfs f11, 0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A6148: 910B002C  stw r8, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[8].u32 ) };
	// 821A614C: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A6150: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A6154: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A6158: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A615C: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 821A6160: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A6164: D16B000C  stfs f11, 0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A6168: 912B002C  stw r9, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 821A616C: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A6170: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A6174: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A6178: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 821A617C: D16B000C  stfs f11, 0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A6180: 912B002C  stw r9, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 821A6184: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A6188: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A618C: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A6190: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 821A6194: 409AFFB0  bne cr6, 0x821a6144
	if !ctx.cr[6].eq {
	pc = 0x821A6144; continue 'dispatch;
	}
	// 821A6198: 814600D0  lwz r10, 0xd0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A619C: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821A61A0: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A61A4: 4198FF9C  blt cr6, 0x821a6140
	if ctx.cr[6].lt {
	pc = 0x821A6140; continue 'dispatch;
	}
	// 821A61A8: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A61AC: 814600D0  lwz r10, 0xd0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A61B0: 55442036  slwi r4, r10, 4
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A61B4: C04BD468  lfs f2, -0x2b98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11160 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A61B8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A61BC: C02BD218  lfs f1, -0x2de8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A61C0: 48009CC0  b 0x821afe80
	sub_821AFE80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A61C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A61C8 size=636
    let mut pc: u32 = 0x821A61C8;
    'dispatch: loop {
        match pc {
            0x821A61C8 => {
    //   block [0x821A61C8..0x821A6444)
	// 821A61C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A61CC: 4838EECD  bl 0x82535098
	ctx.lr = 0x821A61D0;
	sub_82535080(ctx, base);
	// 821A61D0: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 821A61D4: 4838FE11  bl 0x82535fe4
	ctx.lr = 0x821A61D8;
	sub_82535FB0(ctx, base);
	// 821A61D8: 9421FDC0  stwu r1, -0x240(r1)
	ea = ctx.r[1].u32.wrapping_add(-576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A61DC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821A61E0: 817A00F4  lwz r11, 0xf4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(244 as u32) ) } as u64;
	// 821A61E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A61E8: 419A0018  beq cr6, 0x821a6200
	if ctx.cr[6].eq {
	pc = 0x821A6200; continue 'dispatch;
	}
	// 821A61EC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A61F0: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 821A61F4: 813A00F0  lwz r9, 0xf0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(240 as u32) ) } as u64;
	// 821A61F8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A61FC: 419A0008  beq cr6, 0x821a6204
	if ctx.cr[6].eq {
	pc = 0x821A6204; continue 'dispatch;
	}
	// 821A6200: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821A6204: 817A00D0  lwz r11, 0xd0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A6208: 831A00CC  lwz r24, 0xcc(r26)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A620C: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A6210: 815B0084  lwz r10, 0x84(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A6214: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821A6218: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 821A621C: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A6220: 7E8BC214  add r20, r11, r24
	ctx.r[20].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 821A6224: 409A000C  bne cr6, 0x821a6230
	if !ctx.cr[6].eq {
	pc = 0x821A6230; continue 'dispatch;
	}
	// 821A6228: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A622C: 4800000C  b 0x821a6238
	pc = 0x821A6238; continue 'dispatch;
	// 821A6230: 817B008C  lwz r11, 0x8c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A6234: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A6238: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821A623C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A6240: 419A01E0  beq cr6, 0x821a6420
	if ctx.cr[6].eq {
	pc = 0x821A6420; continue 'dispatch;
	}
	// 821A6244: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 821A6248: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A624C: 3AEB33F0  addi r23, r11, 0x33f0
	ctx.r[23].s64 = ctx.r[11].s64 + 13296;
	// 821A6250: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 821A6254: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A6258: 3ACB3400  addi r22, r11, 0x3400
	ctx.r[22].s64 = ctx.r[11].s64 + 13312;
	// 821A625C: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821A6260: C389D6C8  lfs f28, -0x2938(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821A6264: 3AABD020  addi r21, r11, -0x2fe0
	ctx.r[21].s64 = ctx.r[11].s64 + -12256;
	// 821A6268: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821A626C: C36A1FF8  lfs f27, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821A6270: 3B8BD010  addi r28, r11, -0x2ff0
	ctx.r[28].s64 = ctx.r[11].s64 + -12272;
	// 821A6274: 817B0098  lwz r11, 0x98(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A6278: 395F0024  addi r10, r31, 0x24
	ctx.r[10].s64 = ctx.r[31].s64 + 36;
	// 821A627C: 392B0020  addi r9, r11, 0x20
	ctx.r[9].s64 = ctx.r[11].s64 + 32;
	// 821A6280: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A6284: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6288: 409A000C  bne cr6, 0x821a6294
	if !ctx.cr[6].eq {
	pc = 0x821A6294; continue 'dispatch;
	}
	// 821A628C: C3AA0000  lfs f29, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821A6290: 48000020  b 0x821a62b0
	pc = 0x821A62B0; continue 'dispatch;
	// 821A6294: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 821A6298: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A629C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A62A0: 7C0047AE  stfiwx f0, 0, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 821A62A4: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A62A8: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A62AC: 7FA85C2E  lfsx f29, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821A62B0: 817A00D4  lwz r11, 0xd4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A62B4: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 821A62B8: 39090020  addi r8, r9, 0x20
	ctx.r[8].s64 = ctx.r[9].s64 + 32;
	// 821A62BC: 392A0008  addi r9, r10, 8
	ctx.r[9].s64 = ctx.r[10].s64 + 8;
	// 821A62C0: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A62C4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821A62C8: 419A0070  beq cr6, 0x821a6338
	if ctx.cr[6].eq {
	pc = 0x821A6338; continue 'dispatch;
	}
	// 821A62CC: 8148001C  lwz r10, 0x1c(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 821A62D0: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A62D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A62D8: 419A001C  beq cr6, 0x821a62f4
	if ctx.cr[6].eq {
	pc = 0x821A62F4; continue 'dispatch;
	}
	// 821A62DC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 821A62E0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A62E4: 7C003FAE  stfiwx f0, 0, r7
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32, tmp.u32) };
	// 821A62E8: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A62EC: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821A62F0: 7C07542E  lfsx f0, r7, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A62F4: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 821A62F8: 40980008  bge cr6, 0x821a6300
	if !ctx.cr[6].lt {
	pc = 0x821A6300; continue 'dispatch;
	}
	// 821A62FC: FC00D890  fmr f0, f27
	ctx.f[0].f64 = ctx.f[27].f64;
	// 821A6300: A0EB0012  lhz r7, 0x12(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A6304: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A6308: 7CEB07B4  extsw r11, r7
	ctx.r[11].s64 = ctx.r[7].s32 as i64;
	// 821A630C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821A6310: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821A6314: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821A6318: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A631C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A6320: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821A6324: D8010068  stfd f0, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[0].u64 ) };
	// 821A6328: A161006E  lhz r11, 0x6e(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(110 as u32) ) } as u64;
	// 821A632C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A6330: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A6334: 7FABEA14  add r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821A6338: 8168002C  lwz r11, 0x2c(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A633C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6340: 409A000C  bne cr6, 0x821a634c
	if !ctx.cr[6].eq {
	pc = 0x821A634C; continue 'dispatch;
	}
	// 821A6344: C3C90008  lfs f30, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A6348: 48000020  b 0x821a6368
	pc = 0x821A6368; continue 'dispatch;
	// 821A634C: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 821A6350: C0090008  lfs f0, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6354: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A6358: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821A635C: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A6360: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A6364: 7FCA5C2E  lfsx f30, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A6368: 817A00D8  lwz r11, 0xd8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A636C: C01F0184  lfs f0, 0x184(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6370: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 821A6374: 7EA9AB78  mr r9, r21
	ctx.r[9].u64 = ctx.r[21].u64;
	// 821A6378: 38FF0160  addi r7, r31, 0x160
	ctx.r[7].s64 = ctx.r[31].s64 + 352;
	// 821A637C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821A6380: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 821A6384: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A6388: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821A638C: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A6390: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A6394: D01C0004  stfs f0, 4(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A6398: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A639C: 817B0094  lwz r11, 0x94(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A63A0: 396B0006  addi r11, r11, 6
	ctx.r[11].s64 = ctx.r[11].s64 + 6;
	// 821A63A4: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A63A8: 7FCBFA14  add r30, r11, r31
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821A63AC: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 821A63B0: 48009DE9  bl 0x821b0198
	ctx.lr = 0x821A63B4;
	sub_821B0198(ctx, base);
	// 821A63B4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A63B8: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 821A63BC: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A63C0: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 821A63C4: 7C8BA214  add r4, r11, r20
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[20].u64;
	// 821A63C8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821A63CC: 4800A05D  bl 0x821b0428
	ctx.lr = 0x821A63D0;
	sub_821B0428(ctx, base);
	// 821A63D0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 821A63D4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821A63D8: EC5D0732  fmuls f2, f29, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = (((ctx.f[29].f64 * ctx.f[28].f64) as f32) as f64);
	// 821A63DC: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 821A63E0: EC3F07B2  fmuls f1, f31, f30
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[30].f64) as f32) as f64);
	// 821A63E4: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 821A63E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A63EC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821A63F0: 4800A5E1  bl 0x821b09d0
	ctx.lr = 0x821A63F4;
	sub_821B09D0(ctx, base);
	// 821A63F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A63F8: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 821A63FC: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 821A6400: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A6404: 409A000C  bne cr6, 0x821a6410
	if !ctx.cr[6].eq {
	pc = 0x821A6410; continue 'dispatch;
	}
	// 821A6408: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A640C: 4800000C  b 0x821a6418
	pc = 0x821A6418; continue 'dispatch;
	// 821A6410: 815B008C  lwz r10, 0x8c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A6414: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A6418: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A641C: 409AFE58  bne cr6, 0x821a6274
	if !ctx.cr[6].eq {
	pc = 0x821A6274; continue 'dispatch;
	}
	// 821A6420: 572B083C  slwi r11, r25, 1
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A6424: 933A00C8  stw r25, 0xc8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(200 as u32), ctx.r[25].u32 ) };
	// 821A6428: 7D795A14  add r11, r25, r11
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[11].u64;
	// 821A642C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A6430: 917A00C4  stw r11, 0xc4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 821A6434: 38210240  addi r1, r1, 0x240
	ctx.r[1].s64 = ctx.r[1].s64 + 576;
	// 821A6438: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 821A643C: 4838FBF5  bl 0x82536030
	ctx.lr = 0x821A6440;
	sub_82535FFC(ctx, base);
	// 821A6440: 4838ECA8  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A6448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A6448 size=356
    let mut pc: u32 = 0x821A6448;
    'dispatch: loop {
        match pc {
            0x821A6448 => {
    //   block [0x821A6448..0x821A65AC)
	// 821A6448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A644C: 4838EC69  bl 0x825350b4
	ctx.lr = 0x821A6450;
	sub_82535080(ctx, base);
	// 821A6450: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A6454: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A6458: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821A645C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A6460: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821A6464: 38EB0E64  addi r7, r11, 0xe64
	ctx.r[7].s64 = ctx.r[11].s64 + 3684;
	// 821A6468: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 821A646C: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 821A6470: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821A6474: 38600110  li r3, 0x110
	ctx.r[3].s64 = 272;
	// 821A6478: 481C4019  bl 0x8236a490
	ctx.lr = 0x821A647C;
	sub_8236A490(ctx, base);
	// 821A647C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A6480: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A6484: 419A000C  beq cr6, 0x821a6490
	if ctx.cr[6].eq {
	pc = 0x821A6490; continue 'dispatch;
	}
	// 821A6488: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A648C: 48000008  b 0x821a6494
	pc = 0x821A6494; continue 'dispatch;
	// 821A6490: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821A6494: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A6498: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A649C: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A64A0: 419A00B8  beq cr6, 0x821a6558
	if ctx.cr[6].eq {
	pc = 0x821A6558; continue 'dispatch;
	}
	// 821A64A4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A64A8: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821A64AC: 396B0E3C  addi r11, r11, 0xe3c
	ctx.r[11].s64 = ctx.r[11].s64 + 3644;
	// 821A64B0: 3D00821A  lis r8, -0x7de6
	ctx.r[8].s64 = -2112225280;
	// 821A64B4: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 821A64B8: 390865B0  addi r8, r8, 0x65b0
	ctx.r[8].s64 = ctx.r[8].s64 + 26032;
	// 821A64BC: 392966B8  addi r9, r9, 0x66b8
	ctx.r[9].s64 = ctx.r[9].s64 + 26296;
	// 821A64C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A64C4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A64C8: 939F0080  stw r28, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 821A64CC: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821A64D0: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A64D4: B39F0084  sth r28, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[28].u16 ) };
	// 821A64D8: B39F0086  sth r28, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[28].u16 ) };
	// 821A64DC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A64E0: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 821A64E4: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A64E8: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A64EC: FB9F00F0  std r28, 0xf0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[28].u64 ) };
	// 821A64F0: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A64F4: FB9F00F8  std r28, 0xf8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[28].u64 ) };
	// 821A64F8: 394A6FC8  addi r10, r10, 0x6fc8
	ctx.r[10].s64 = ctx.r[10].s64 + 28616;
	// 821A64FC: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821A6500: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821A6504: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821A6508: 38BF00CC  addi r5, r31, 0xcc
	ctx.r[5].s64 = ctx.r[31].s64 + 204;
	// 821A650C: 9B7F001C  stb r27, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 821A6510: 5564482C  slwi r4, r11, 9
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(9);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A6514: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A6518: 4BFFB719  bl 0x821a1c30
	ctx.lr = 0x821A651C;
	sub_821A1C30(ctx, base);
	// 821A651C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6520: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A6524: 409A0044  bne cr6, 0x821a6568
	if !ctx.cr[6].eq {
	pc = 0x821A6568; continue 'dispatch;
	}
	// 821A6528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A652C: 419A002C  beq cr6, 0x821a6558
	if ctx.cr[6].eq {
	pc = 0x821A6558; continue 'dispatch;
	}
	// 821A6530: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A6534: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6538: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A653C: 409A001C  bne cr6, 0x821a6558
	if !ctx.cr[6].eq {
	pc = 0x821A6558; continue 'dispatch;
	}
	// 821A6540: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A6544: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A6548: 9B6B0025  stb r27, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[27].u8 ) };
	// 821A654C: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A6550: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821A6554: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 821A6558: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821A655C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A6560: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A6564: 4838EBA0  b 0x82535104
	sub_825350D0(ctx, base);
	return;
	// 821A6568: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A656C: 419A0014  beq cr6, 0x821a6580
	if ctx.cr[6].eq {
	pc = 0x821A6580; continue 'dispatch;
	}
	// 821A6570: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A6574: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6578: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A657C: 419A0008  beq cr6, 0x821a6584
	if ctx.cr[6].eq {
	pc = 0x821A6584; continue 'dispatch;
	}
	// 821A6580: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821A6584: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6588: 393F00E0  addi r9, r31, 0xe0
	ctx.r[9].s64 = ctx.r[31].s64 + 224;
	// 821A658C: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 821A6590: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A6594: 915F00F8  stw r10, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[10].u32 ) };
	// 821A6598: FB9F00F0  std r28, 0xf0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[28].u64 ) };
	// 821A659C: 93BF00D0  stw r29, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[29].u32 ) };
	// 821A65A0: 913F00D8  stw r9, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[9].u32 ) };
	// 821A65A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A65A8: 4838EB5C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A65B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A65B0 size=260
    let mut pc: u32 = 0x821A65B0;
    'dispatch: loop {
        match pc {
            0x821A65B0 => {
    //   block [0x821A65B0..0x821A66B4)
	// 821A65B0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A65B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A65B8: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A65BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A65C0: 419A0008  beq cr6, 0x821a65c8
	if ctx.cr[6].eq {
	pc = 0x821A65C8; continue 'dispatch;
	}
	// 821A65C4: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821A65C8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A65CC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821A65D0: 3CE04020  lis r7, 0x4020
	ctx.r[7].s64 = 1075838976;
	// 821A65D4: 38C00120  li r6, 0x120
	ctx.r[6].s64 = 288;
	// 821A65D8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 821A65DC: C0091FF8  lfs f0, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A65E0: 3D208288  lis r9, -0x7d78
	ctx.r[9].s64 = -2105016320;
	// 821A65E4: 990B001E  stb r8, 0x1e(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(30 as u32), ctx.r[8].u8 ) };
	// 821A65E8: 39000022  li r8, 0x22
	ctx.r[8].s64 = 34;
	// 821A65EC: B14B0084  sth r10, 0x84(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u16 ) };
	// 821A65F0: 39298E40  addi r9, r9, -0x71c0
	ctx.r[9].s64 = ctx.r[9].s64 + -29120;
	// 821A65F4: B14B0086  sth r10, 0x86(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(134 as u32), ctx.r[10].u16 ) };
	// 821A65F8: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 821A65FC: 912B0080  stw r9, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 821A6600: D00B00B0  stfs f0, 0xb0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821A6604: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 821A6608: D00B00B4  stfs f0, 0xb4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821A660C: 90EB00A8  stw r7, 0xa8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), ctx.r[7].u32 ) };
	// 821A6610: 90CB00A4  stw r6, 0xa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), ctx.r[6].u32 ) };
	// 821A6614: 910B0094  stw r8, 0x94(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), ctx.r[8].u32 ) };
	// 821A6618: 90AB0098  stw r5, 0x98(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[5].u32 ) };
	// 821A661C: 814B00D4  lwz r10, 0xd4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A6620: A14A0004  lhz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6624: D00B00B8  stfs f0, 0xb8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821A6628: 3D4A0504  addis r10, r10, 0x504
	ctx.r[10].s64 = ctx.r[10].s64 + 84148224;
	// 821A662C: 394A4000  addi r10, r10, 0x4000
	ctx.r[10].s64 = ctx.r[10].s64 + 16384;
	// 821A6630: 914B0090  stw r10, 0x90(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 821A6634: 814B00D8  lwz r10, 0xd8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A6638: 812B00D0  lwz r9, 0xd0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A663C: 816B00CC  lwz r11, 0xcc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A6640: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821A6644: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6648: 2B290000  cmpldi cr6, r9, 0
	ctx.cr[6].compare_u64(ctx.r[9].u64, 0, &mut ctx.xer);
	// 821A664C: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A6650: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A6654: 40990058  ble cr6, 0x821a66ac
	if !ctx.cr[6].gt {
	pc = 0x821A66AC; continue 'dispatch;
	}
	// 821A6658: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821A665C: C16ABA38  lfs f11, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A6660: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 821A6664: 39000060  li r8, 0x60
	ctx.r[8].s64 = 96;
	// 821A6668: 7C085A2C  dcbt r8, r11
	// 821A666C: D16B000C  stfs f11, 0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A6670: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A6674: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A6678: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A667C: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 821A6680: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A6684: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 821A6688: D16B000C  stfs f11, 0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A668C: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A6690: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A6694: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A6698: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 821A669C: 4199FFC8  bgt cr6, 0x821a6664
	if ctx.cr[6].gt {
	pc = 0x821A6664; continue 'dispatch;
	}
	// 821A66A0: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 821A66A4: 2B290000  cmpldi cr6, r9, 0
	ctx.cr[6].compare_u64(ctx.r[9].u64, 0, &mut ctx.xer);
	// 821A66A8: 4199FFB8  bgt cr6, 0x821a6660
	if ctx.cr[6].gt {
	pc = 0x821A6660; continue 'dispatch;
	}
	// 821A66AC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A66B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A66B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A66B8 size=68
    let mut pc: u32 = 0x821A66B8;
    'dispatch: loop {
        match pc {
            0x821A66B8 => {
    //   block [0x821A66B8..0x821A66FC)
	// 821A66B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A66BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A66C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A66C4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A66C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A66CC: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A66D0: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A66D4: 91430040  stw r10, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821A66D8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A66DC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A66E0: 419A0008  beq cr6, 0x821a66e8
	if ctx.cr[6].eq {
	pc = 0x821A66E8; continue 'dispatch;
	}
	// 821A66E4: 4800001D  bl 0x821a6700
	ctx.lr = 0x821A66E8;
	sub_821A6700(ctx, base);
	// 821A66E8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A66EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A66F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A66F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A66F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A6700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A6700 size=692
    let mut pc: u32 = 0x821A6700;
    'dispatch: loop {
        match pc {
            0x821A6700 => {
    //   block [0x821A6700..0x821A69B4)
	// 821A6700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A6704: 4838E99D  bl 0x825350a0
	ctx.lr = 0x821A6708;
	sub_82535080(ctx, base);
	// 821A6708: DBC1FF98  stfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 821A670C: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 821A6710: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A6714: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821A6718: 817B00F4  lwz r11, 0xf4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(244 as u32) ) } as u64;
	// 821A671C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6720: 419A0018  beq cr6, 0x821a6738
	if ctx.cr[6].eq {
	pc = 0x821A6738; continue 'dispatch;
	}
	// 821A6724: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A6728: 7D775B78  mr r23, r11
	ctx.r[23].u64 = ctx.r[11].u64;
	// 821A672C: 813B00F0  lwz r9, 0xf0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(240 as u32) ) } as u64;
	// 821A6730: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A6734: 419A0008  beq cr6, 0x821a673c
	if ctx.cr[6].eq {
	pc = 0x821A673C; continue 'dispatch;
	}
	// 821A6738: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821A673C: 81770084  lwz r11, 0x84(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A6740: 82DB00CC  lwz r22, 0xcc(r27)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A6744: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A6748: 409A000C  bne cr6, 0x821a6754
	if !ctx.cr[6].eq {
	pc = 0x821A6754; continue 'dispatch;
	}
	// 821A674C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821A6750: 4800000C  b 0x821a675c
	pc = 0x821A675C; continue 'dispatch;
	// 821A6754: 8157008C  lwz r10, 0x8c(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A6758: 7FAA5A14  add r29, r10, r11
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A675C: 831B00D4  lwz r24, 0xd4(r27)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A6760: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821A6764: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821A6768: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821A676C: 419A0230  beq cr6, 0x821a699c
	if ctx.cr[6].eq {
	pc = 0x821A699C; continue 'dispatch;
	}
	// 821A6770: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821A6774: 3BEB14B0  addi r31, r11, 0x14b0
	ctx.r[31].s64 = ctx.r[11].s64 + 5296;
	// 821A6778: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A677C: C3CB1FF8  lfs f30, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A6780: A17D0010  lhz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A6784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6788: 419A003C  beq cr6, 0x821a67c4
	if ctx.cr[6].eq {
	pc = 0x821A67C4; continue 'dispatch;
	}
	// 821A678C: A178000C  lhz r11, 0xc(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A6790: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A6794: 40990024  ble cr6, 0x821a67b8
	if !ctx.cr[6].gt {
	pc = 0x821A67B8; continue 'dispatch;
	}
	// 821A6798: 481C09A1  bl 0x82367138
	ctx.lr = 0x821A679C;
	sub_82367138(ctx, base);
	// 821A679C: A178000C  lhz r11, 0xc(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A67A0: 7D435B96  divwu r10, r3, r11
	ctx.r[10].u32 = ctx.r[3].u32 / ctx.r[11].u32;
	// 821A67A4: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 821A67A8: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821A67AC: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821A67B0: B17D0198  sth r11, 0x198(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(408 as u32), ctx.r[11].u16 ) };
	// 821A67B4: 480001C4  b 0x821a6978
	pc = 0x821A6978; continue 'dispatch;
	// 821A67B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A67BC: B17D0198  sth r11, 0x198(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(408 as u32), ctx.r[11].u16 ) };
	// 821A67C0: 480001B8  b 0x821a6978
	pc = 0x821A6978; continue 'dispatch;
	// 821A67C4: 83980000  lwz r28, 0(r24)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A67C8: 393D003C  addi r9, r29, 0x3c
	ctx.r[9].s64 = ctx.r[29].s64 + 60;
	// 821A67CC: 81170098  lwz r8, 0x98(r23)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A67D0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821A67D4: 419A0084  beq cr6, 0x821a6858
	if ctx.cr[6].eq {
	pc = 0x821A6858; continue 'dispatch;
	}
	// 821A67D8: 8168005C  lwz r11, 0x5c(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(92 as u32) ) } as u64;
	// 821A67DC: C0090000  lfs f0, 0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A67E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A67E4: 419A001C  beq cr6, 0x821a6800
	if ctx.cr[6].eq {
	pc = 0x821A6800; continue 'dispatch;
	}
	// 821A67E8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821A67EC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A67F0: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821A67F4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A67F8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A67FC: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6800: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 821A6804: 40980008  bge cr6, 0x821a680c
	if !ctx.cr[6].lt {
	pc = 0x821A680C; continue 'dispatch;
	}
	// 821A6808: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 821A680C: A17D0198  lhz r11, 0x198(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(408 as u32) ) } as u64;
	// 821A6810: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 821A6814: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A6818: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A681C: 7D6BC214  add r11, r11, r24
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 821A6820: A0EB0012  lhz r7, 0x12(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A6824: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A6828: 7CEB07B4  extsw r11, r7
	ctx.r[11].s64 = ctx.r[7].s32 as i64;
	// 821A682C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821A6830: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821A6834: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821A6838: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A683C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A6840: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821A6844: D8010060  stfd f0, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[0].u64 ) };
	// 821A6848: A1610066  lhz r11, 0x66(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(102 as u32) ) } as u64;
	// 821A684C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A6850: 556B2AF4  rlwinm r11, r11, 5, 0xb, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 821A6854: 7F8BE214  add r28, r11, r28
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821A6858: 8168006C  lwz r11, 0x6c(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A685C: C0090008  lfs f0, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6864: 419A001C  beq cr6, 0x821a6880
	if ctx.cr[6].eq {
	pc = 0x821A6880; continue 'dispatch;
	}
	// 821A6868: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 821A686C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A6870: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821A6874: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A6878: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A687C: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6880: 81770094  lwz r11, 0x94(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A6884: 393D0060  addi r9, r29, 0x60
	ctx.r[9].s64 = ctx.r[29].s64 + 96;
	// 821A6888: 815B00D8  lwz r10, 0xd8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A688C: 391F0900  addi r8, r31, 0x900
	ctx.r[8].s64 = ctx.r[31].s64 + 2304;
	// 821A6890: 55672036  slwi r7, r11, 4
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821A6894: 7CE74A14  add r7, r7, r9
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821A6898: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A689C: 395F0910  addi r10, r31, 0x910
	ctx.r[10].s64 = ctx.r[31].s64 + 2320;
	// 821A68A0: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A68A4: E8C70000  ld r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 821A68A8: F8C80000  std r6, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 821A68AC: E8E70008  ld r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 821A68B0: F8E80008  std r7, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 821A68B4: 55672036  slwi r7, r11, 4
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821A68B8: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 821A68BC: 7CE74A14  add r7, r7, r9
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821A68C0: 38DF0A10  addi r6, r31, 0xa10
	ctx.r[6].s64 = ctx.r[31].s64 + 2576;
	// 821A68C4: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 821A68C8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A68CC: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821A68D0: E8C70000  ld r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 821A68D4: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821A68D8: F8C80000  std r6, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 821A68DC: E8E70008  ld r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 821A68E0: F8E80008  std r7, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 821A68E4: 4198FFD0  blt cr6, 0x821a68b4
	if ctx.cr[6].lt {
	pc = 0x821A68B4; continue 'dispatch;
	}
	// 821A68E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A68EC: 395F0A10  addi r10, r31, 0xa10
	ctx.r[10].s64 = ctx.r[31].s64 + 2576;
	// 821A68F0: 556B2636  rlwinm r11, r11, 4, 0x18, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 821A68F4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A68F8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821A68FC: 38A0000F  li r5, 0xf
	ctx.r[5].s64 = 15;
	// 821A6900: 389F0900  addi r4, r31, 0x900
	ctx.r[4].s64 = ctx.r[31].s64 + 2304;
	// 821A6904: 387F0600  addi r3, r31, 0x600
	ctx.r[3].s64 = ctx.r[31].s64 + 1536;
	// 821A6908: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A690C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821A6910: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821A6914: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821A6918: 80DB0100  lwz r6, 0x100(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(256 as u32) ) } as u64;
	// 821A691C: 4BFF6015  bl 0x8219c930
	ctx.lr = 0x821A6920;
	sub_8219C930(ctx, base);
	// 821A6920: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A6924: C03D0180  lfs f1, 0x180(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(384 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A6928: 38DF0600  addi r6, r31, 0x600
	ctx.r[6].s64 = ctx.r[31].s64 + 1536;
	// 821A692C: 38BF0900  addi r5, r31, 0x900
	ctx.r[5].s64 = ctx.r[31].s64 + 2304;
	// 821A6930: 389F0300  addi r4, r31, 0x300
	ctx.r[4].s64 = ctx.r[31].s64 + 768;
	// 821A6934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A6938: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 821A693C: 48009C8D  bl 0x821b05c8
	ctx.lr = 0x821A6940;
	sub_821B05C8(ctx, base);
	// 821A6940: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A6944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A6948: 48009F69  bl 0x821b08b0
	ctx.lr = 0x821A694C;
	sub_821B08B0(ctx, base);
	// 821A694C: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 821A6950: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821A6954: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A6958: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821A695C: 389F0300  addi r4, r31, 0x300
	ctx.r[4].s64 = ctx.r[31].s64 + 768;
	// 821A6960: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821A6964: 4800A745  bl 0x821b10a8
	ctx.lr = 0x821A6968;
	sub_821B10A8(ctx, base);
	// 821A6968: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A696C: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 821A6970: 7F4BD214  add r26, r11, r26
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 821A6974: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 821A6978: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A697C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A6980: 409A000C  bne cr6, 0x821a698c
	if !ctx.cr[6].eq {
	pc = 0x821A698C; continue 'dispatch;
	}
	// 821A6984: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821A6988: 4800000C  b 0x821a6994
	pc = 0x821A6994; continue 'dispatch;
	// 821A698C: 8157008C  lwz r10, 0x8c(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A6990: 7FAA5A14  add r29, r10, r11
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A6994: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821A6998: 409AFDE8  bne cr6, 0x821a6780
	if !ctx.cr[6].eq {
	pc = 0x821A6780; continue 'dispatch;
	}
	// 821A699C: 935B00C4  stw r26, 0xc4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(196 as u32), ctx.r[26].u32 ) };
	// 821A69A0: 933B00C8  stw r25, 0xc8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(200 as u32), ctx.r[25].u32 ) };
	// 821A69A4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821A69A8: CBC1FF98  lfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 821A69AC: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 821A69B0: 4838E740  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A69B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A69B8 size=556
    let mut pc: u32 = 0x821A69B8;
    'dispatch: loop {
        match pc {
            0x821A69B8 => {
    //   block [0x821A69B8..0x821A6BE4)
	// 821A69B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A69BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A69C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A69C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A69C8: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 821A69CC: 4838F60D  bl 0x82535fd8
	ctx.lr = 0x821A69D0;
	sub_82535FB0(ctx, base);
	// 821A69D0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A69D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A69D8: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 821A69DC: 3BDF0030  addi r30, r31, 0x30
	ctx.r[30].s64 = ctx.r[31].s64 + 48;
	// 821A69E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A69E4: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A69E8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A69EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A69F0: 4E800421  bctrl
	ctx.lr = 0x821A69F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A69F4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A69F8: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A69FC: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 821A6A00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A6A04: C3CB0030  lfs f30, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A6A08: C3AB0034  lfs f29, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821A6A0C: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A6A10: C38B0038  lfs f28, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821A6A14: D3C10080  stfs f30, 0x80(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821A6A18: D3A10084  stfs f29, 0x84(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821A6A1C: D3810088  stfs f28, 0x88(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821A6A20: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A6A24: 4E800421  bctrl
	ctx.lr = 0x821A6A28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A6A28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A6A2C: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 821A6A30: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 821A6A34: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 821A6A38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A6A3C: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6A40: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821A6A44: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6A48: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821A6A4C: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6A50: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 821A6A54: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A6BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A6BE8 size=392
    let mut pc: u32 = 0x821A6BE8;
    'dispatch: loop {
        match pc {
            0x821A6BE8 => {
    //   block [0x821A6BE8..0x821A6C40)
	// 821A6BE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A6BEC: 4838E4D1  bl 0x825350bc
	ctx.lr = 0x821A6BF0;
	sub_82535080(ctx, base);
	// 821A6BF0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821A6BF4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A6BF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A6BFC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821A6C00: 3D80821A  lis r12, -0x7de6
	ctx.r[12].s64 = -2112225280;
	// 821A6C04: 398C6C18  addi r12, r12, 0x6c18
	ctx.r[12].s64 = ctx.r[12].s64 + 27672;
	// 821A6C08: 54A0103A  slwi r0, r5, 2
	ctx.r[0].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821A6C0C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821A6C10: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821A6C14: 4E800420  bctr
	match ctx.r[31].u64 {
		0 => {
	pc = 0x821A6C40; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821A6C18: 821A6C40  lwz r16, 0x6c40(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27712 as u32) ) } as u64;
	// 821A6C1C: 821A6C80  lwz r16, 0x6c80(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27776 as u32) ) } as u64;
	// 821A6C20: 821A6CC0  lwz r16, 0x6cc0(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27840 as u32) ) } as u64;
	// 821A6C24: 821A6CC0  lwz r16, 0x6cc0(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27840 as u32) ) } as u64;
	// 821A6C28: 821A6D64  lwz r16, 0x6d64(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28004 as u32) ) } as u64;
	// 821A6C2C: 821A6D64  lwz r16, 0x6d64(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28004 as u32) ) } as u64;
	// 821A6C30: 821A6D64  lwz r16, 0x6d64(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28004 as u32) ) } as u64;
	// 821A6C34: 821A6D64  lwz r16, 0x6d64(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28004 as u32) ) } as u64;
	// 821A6C38: 821A6D64  lwz r16, 0x6d64(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28004 as u32) ) } as u64;
	// 821A6C3C: 821A6D30  lwz r16, 0x6d30(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27952 as u32) ) } as u64;
            }
            0x821A6C40 => {
    //   block [0x821A6C40..0x821A6D70)
	// 821A6C40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A6C44: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A6C48: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A6C4C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 821A6C50: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 821A6C54: C04BBA38  lfs f2, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A6C58: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A6C5C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821A6C60: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 821A6C64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821A6C68: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 821A6C6C: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 821A6C70: 48003D89  bl 0x821aa9f8
	ctx.lr = 0x821A6C74;
	sub_821AA9F8(ctx, base);
	// 821A6C74: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A6C78: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821A6C7C: 4838E490  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
	// 821A6C80: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A6C84: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A6C88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A6C8C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 821A6C90: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 821A6C94: C04BBA38  lfs f2, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A6C98: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A6C9C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821A6CA0: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 821A6CA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821A6CA8: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 821A6CAC: 38600016  li r3, 0x16
	ctx.r[3].s64 = 22;
	// 821A6CB0: 48003D49  bl 0x821aa9f8
	ctx.lr = 0x821A6CB4;
	sub_821AA9F8(ctx, base);
	// 821A6CB4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A6CB8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821A6CBC: 4838E450  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
	// 821A6CC0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A6CC4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821A6CC8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A6CCC: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 821A6CD0: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 821A6CD4: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A6CD8: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A6CDC: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821A6CE0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821A6CE4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821A6CE8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A6CEC: 3860000B  li r3, 0xb
	ctx.r[3].s64 = 11;
	// 821A6CF0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 821A6CF4: 48003D05  bl 0x821aa9f8
	ctx.lr = 0x821A6CF8;
	sub_821AA9F8(ctx, base);
	// 821A6CF8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A6CFC: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 821A6D00: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821A6D04: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 821A6D08: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A6D0C: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A6D10: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 821A6D14: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821A6D18: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 821A6D1C: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 821A6D20: 48003CD9  bl 0x821aa9f8
	ctx.lr = 0x821A6D24;
	sub_821AA9F8(ctx, base);
	// 821A6D24: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A6D28: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821A6D2C: 4838E3E0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
	// 821A6D30: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A6D34: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A6D38: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A6D3C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 821A6D40: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 821A6D44: C04BBA38  lfs f2, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A6D48: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A6D4C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821A6D50: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 821A6D54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821A6D58: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 821A6D5C: 38600017  li r3, 0x17
	ctx.r[3].s64 = 23;
	// 821A6D60: 48003C99  bl 0x821aa9f8
	ctx.lr = 0x821A6D64;
	sub_821AA9F8(ctx, base);
	// 821A6D64: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A6D68: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821A6D6C: 4838E3A0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A6D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A6D70 size=356
    let mut pc: u32 = 0x821A6D70;
    'dispatch: loop {
        match pc {
            0x821A6D70 => {
    //   block [0x821A6D70..0x821A6ED4)
	// 821A6D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A6D74: 4838E341  bl 0x825350b4
	ctx.lr = 0x821A6D78;
	sub_82535080(ctx, base);
	// 821A6D78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A6D7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A6D80: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821A6D84: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A6D88: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821A6D8C: 38EB0E6C  addi r7, r11, 0xe6c
	ctx.r[7].s64 = ctx.r[11].s64 + 3692;
	// 821A6D90: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 821A6D94: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 821A6D98: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821A6D9C: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 821A6DA0: 481C36F1  bl 0x8236a490
	ctx.lr = 0x821A6DA4;
	sub_8236A490(ctx, base);
	// 821A6DA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A6DA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A6DAC: 419A000C  beq cr6, 0x821a6db8
	if ctx.cr[6].eq {
	pc = 0x821A6DB8; continue 'dispatch;
	}
	// 821A6DB0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A6DB4: 48000008  b 0x821a6dbc
	pc = 0x821A6DBC; continue 'dispatch;
	// 821A6DB8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821A6DBC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A6DC0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A6DC4: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A6DC8: 419A00B8  beq cr6, 0x821a6e80
	if ctx.cr[6].eq {
	pc = 0x821A6E80; continue 'dispatch;
	}
	// 821A6DCC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A6DD0: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821A6DD4: 396B0E3C  addi r11, r11, 0xe3c
	ctx.r[11].s64 = ctx.r[11].s64 + 3644;
	// 821A6DD8: 3D00821A  lis r8, -0x7de6
	ctx.r[8].s64 = -2112225280;
	// 821A6DDC: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 821A6DE0: 39086ED8  addi r8, r8, 0x6ed8
	ctx.r[8].s64 = ctx.r[8].s64 + 28376;
	// 821A6DE4: 39296F80  addi r9, r9, 0x6f80
	ctx.r[9].s64 = ctx.r[9].s64 + 28544;
	// 821A6DE8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A6DEC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A6DF0: 939F0080  stw r28, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 821A6DF4: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821A6DF8: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A6DFC: B39F0084  sth r28, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[28].u16 ) };
	// 821A6E00: B39F0086  sth r28, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[28].u16 ) };
	// 821A6E04: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A6E08: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 821A6E0C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A6E10: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A6E14: FB9F00F0  std r28, 0xf0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[28].u64 ) };
	// 821A6E18: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A6E1C: FB9F00F8  std r28, 0xf8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[28].u64 ) };
	// 821A6E20: 394A6FC8  addi r10, r10, 0x6fc8
	ctx.r[10].s64 = ctx.r[10].s64 + 28616;
	// 821A6E24: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821A6E28: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821A6E2C: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821A6E30: 38BF00CC  addi r5, r31, 0xcc
	ctx.r[5].s64 = ctx.r[31].s64 + 204;
	// 821A6E34: 9B7F001C  stb r27, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 821A6E38: 55643032  slwi r4, r11, 6
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A6E3C: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A6E40: 4BFFADF1  bl 0x821a1c30
	ctx.lr = 0x821A6E44;
	sub_821A1C30(ctx, base);
	// 821A6E44: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6E48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A6E4C: 409A0044  bne cr6, 0x821a6e90
	if !ctx.cr[6].eq {
	pc = 0x821A6E90; continue 'dispatch;
	}
	// 821A6E50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6E54: 419A002C  beq cr6, 0x821a6e80
	if ctx.cr[6].eq {
	pc = 0x821A6E80; continue 'dispatch;
	}
	// 821A6E58: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A6E5C: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6E60: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A6E64: 409A001C  bne cr6, 0x821a6e80
	if !ctx.cr[6].eq {
	pc = 0x821A6E80; continue 'dispatch;
	}
	// 821A6E68: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A6E6C: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A6E70: 9B6B0025  stb r27, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[27].u8 ) };
	// 821A6E74: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A6E78: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821A6E7C: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 821A6E80: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821A6E84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A6E88: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A6E8C: 4838E278  b 0x82535104
	sub_825350D0(ctx, base);
	return;
	// 821A6E90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6E94: 419A0014  beq cr6, 0x821a6ea8
	if ctx.cr[6].eq {
	pc = 0x821A6EA8; continue 'dispatch;
	}
	// 821A6E98: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A6E9C: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6EA0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A6EA4: 419A0008  beq cr6, 0x821a6eac
	if ctx.cr[6].eq {
	pc = 0x821A6EAC; continue 'dispatch;
	}
	// 821A6EA8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821A6EAC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6EB0: 393F00E0  addi r9, r31, 0xe0
	ctx.r[9].s64 = ctx.r[31].s64 + 224;
	// 821A6EB4: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 821A6EB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A6EBC: 915F00F8  stw r10, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[10].u32 ) };
	// 821A6EC0: FB9F00F0  std r28, 0xf0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[28].u64 ) };
	// 821A6EC4: 93BF00D0  stw r29, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[29].u32 ) };
	// 821A6EC8: 913F00D8  stw r9, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[9].u32 ) };
	// 821A6ECC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A6ED0: 4838E234  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A6ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A6ED8 size=168
    let mut pc: u32 = 0x821A6ED8;
    'dispatch: loop {
        match pc {
            0x821A6ED8 => {
    //   block [0x821A6ED8..0x821A6F80)
	// 821A6ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A6EDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A6EE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A6EE4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A6EE8: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A6EEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A6EF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A6EF4: 419A0008  beq cr6, 0x821a6efc
	if ctx.cr[6].eq {
	pc = 0x821A6EFC; continue 'dispatch;
	}
	// 821A6EF8: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 821A6EFC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A6F00: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A6F04: 3D004020  lis r8, 0x4020
	ctx.r[8].s64 = 1075838976;
	// 821A6F08: 38E00120  li r7, 0x120
	ctx.r[7].s64 = 288;
	// 821A6F0C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821A6F10: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6F14: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 821A6F18: 9923001E  stb r9, 0x1e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[9].u8 ) };
	// 821A6F1C: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 821A6F20: 394A8E40  addi r10, r10, -0x71c0
	ctx.r[10].s64 = ctx.r[10].s64 + -29120;
	// 821A6F24: B1630084  sth r11, 0x84(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u16 ) };
	// 821A6F28: 39200022  li r9, 0x22
	ctx.r[9].s64 = 34;
	// 821A6F2C: B1630086  sth r11, 0x86(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(134 as u32), ctx.r[11].u16 ) };
	// 821A6F30: 91430080  stw r10, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821A6F34: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821A6F38: D00300B4  stfs f0, 0xb4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821A6F3C: 910300A8  stw r8, 0xa8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	// 821A6F40: 90E300A4  stw r7, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[7].u32 ) };
	// 821A6F44: 91230094  stw r9, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 821A6F48: 90C30098  stw r6, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[6].u32 ) };
	// 821A6F4C: 90A300A0  stw r5, 0xa0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[5].u32 ) };
	// 821A6F50: 816300D4  lwz r11, 0xd4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A6F54: A16B0004  lhz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6F58: D00300B8  stfs f0, 0xb8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821A6F5C: 3D6B0504  addis r11, r11, 0x504
	ctx.r[11].s64 = ctx.r[11].s64 + 84148224;
	// 821A6F60: 396B4000  addi r11, r11, 0x4000
	ctx.r[11].s64 = ctx.r[11].s64 + 16384;
	// 821A6F64: 91630090  stw r11, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 821A6F68: 480000A9  bl 0x821a7010
	ctx.lr = 0x821A6F6C;
	sub_821A7010(ctx, base);
	// 821A6F6C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A6F70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A6F74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A6F78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A6F7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A6F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A6F80 size=68
    let mut pc: u32 = 0x821A6F80;
    'dispatch: loop {
        match pc {
            0x821A6F80 => {
    //   block [0x821A6F80..0x821A6FC4)
	// 821A6F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A6F84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A6F88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A6F8C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A6F90: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A6F94: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A6F98: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A6F9C: 91430040  stw r10, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821A6FA0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A6FA4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A6FA8: 419A0008  beq cr6, 0x821a6fb0
	if ctx.cr[6].eq {
	pc = 0x821A6FB0; continue 'dispatch;
	}
	// 821A6FAC: 4800012D  bl 0x821a70d8
	ctx.lr = 0x821A6FB0;
	sub_821A70D8(ctx, base);
	// 821A6FB0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A6FB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A6FB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A6FBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A6FC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A6FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A6FC8 size=72
    let mut pc: u32 = 0x821A6FC8;
    'dispatch: loop {
        match pc {
            0x821A6FC8 => {
    //   block [0x821A6FC8..0x821A7010)
	// 821A6FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A6FCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A6FD0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A6FD4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A6FD8: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A6FDC: 388B00CC  addi r4, r11, 0xcc
	ctx.r[4].s64 = ctx.r[11].s64 + 204;
	// 821A6FE0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6FE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6FE8: 419A0014  beq cr6, 0x821a6ffc
	if ctx.cr[6].eq {
	pc = 0x821A6FFC; continue 'dispatch;
	}
	// 821A6FEC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A6FF0: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A6FF4: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A6FF8: 4BFFB089  bl 0x821a2080
	ctx.lr = 0x821A6FFC;
	sub_821A2080(ctx, base);
	// 821A6FFC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A7000: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A7004: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A7008: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A700C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A7010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A7010 size=48
    let mut pc: u32 = 0x821A7010;
    'dispatch: loop {
        match pc {
            0x821A7010 => {
    //   block [0x821A7010..0x821A7040)
	// 821A7010: 816300D8  lwz r11, 0xd8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A7014: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A7018: 80E300D4  lwz r7, 0xd4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A701C: 80C300D0  lwz r6, 0xd0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A7020: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 821A7024: 810300CC  lwz r8, 0xcc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A7028: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821A702C: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7030: 80C70000  lwz r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7034: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A7038: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A703C: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A7040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A7040 size=152
    let mut pc: u32 = 0x821A7040;
    'dispatch: loop {
        match pc {
            0x821A7040 => {
    //   block [0x821A7040..0x821A70D8)
	// 821A7040: 39680018  addi r11, r8, 0x18
	ctx.r[11].s64 = ctx.r[8].s64 + 24;
	// 821A7044: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821A7048: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821A704C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821A7050: C147BA38  lfs f10, -0x45c8(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A7054: C1681FF8  lfs f11, 0x1ff8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8184 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A7058: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A705C: 90AB0014  stw r5, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[5].u32 ) };
	// 821A7060: 914B00A4  stw r10, 0xa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), ctx.r[10].u32 ) };
	// 821A7064: 914B0074  stw r10, 0x74(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 821A7068: 914B0044  stw r10, 0x44(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u32 ) };
	// 821A706C: 409A0024  bne cr6, 0x821a7090
	if !ctx.cr[6].eq {
	pc = 0x821A7090; continue 'dispatch;
	}
	// 821A7070: D16B0008  stfs f11, 8(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A7074: D16B000C  stfs f11, 0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A7078: D14B0038  stfs f10, 0x38(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821A707C: D16B003C  stfs f11, 0x3c(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821A7080: D16B0068  stfs f11, 0x68(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821A7084: D14B006C  stfs f10, 0x6c(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821A7088: D14B0098  stfs f10, 0x98(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 821A708C: D14B009C  stfs f10, 0x9c(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 821A7090: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821A7094: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821A7098: D1ABFFFC  stfs f13, -4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821A709C: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A70A0: D00B0028  stfs f0, 0x28(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821A70A4: D1AB002C  stfs f13, 0x2c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821A70A8: D18B0030  stfs f12, 0x30(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821A70AC: D00B0058  stfs f0, 0x58(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821A70B0: D1AB005C  stfs f13, 0x5c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821A70B4: D18B0060  stfs f12, 0x60(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821A70B8: D00B0088  stfs f0, 0x88(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821A70BC: D1AB008C  stfs f13, 0x8c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821A70C0: D18B0090  stfs f12, 0x90(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821A70C4: 810300D0  lwz r8, 0xd0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A70C8: 396B00C0  addi r11, r11, 0xc0
	ctx.r[11].s64 = ctx.r[11].s64 + 192;
	// 821A70CC: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821A70D0: 4198FF88  blt cr6, 0x821a7058
	if ctx.cr[6].lt {
	pc = 0x821A7058; continue 'dispatch;
	}
	// 821A70D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A70D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A70D8 size=576
    let mut pc: u32 = 0x821A70D8;
    'dispatch: loop {
        match pc {
            0x821A70D8 => {
    //   block [0x821A70D8..0x821A7318)
	// 821A70D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A70DC: 4838DFD1  bl 0x825350ac
	ctx.lr = 0x821A70E0;
	sub_82535080(ctx, base);
	// 821A70E0: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821A70E4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A70E8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821A70EC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821A70F0: 817A00F4  lwz r11, 0xf4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(244 as u32) ) } as u64;
	// 821A70F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A70F8: 419A0018  beq cr6, 0x821a7110
	if ctx.cr[6].eq {
	pc = 0x821A7110; continue 'dispatch;
	}
	// 821A70FC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7100: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 821A7104: 813A00F0  lwz r9, 0xf0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(240 as u32) ) } as u64;
	// 821A7108: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A710C: 419A0008  beq cr6, 0x821a7114
	if ctx.cr[6].eq {
	pc = 0x821A7114; continue 'dispatch;
	}
	// 821A7110: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 821A7114: 817C0084  lwz r11, 0x84(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A7118: 83FA00CC  lwz r31, 0xcc(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A711C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A7120: 409A000C  bne cr6, 0x821a712c
	if !ctx.cr[6].eq {
	pc = 0x821A712C; continue 'dispatch;
	}
	// 821A7124: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 821A7128: 4800000C  b 0x821a7134
	pc = 0x821A7134; continue 'dispatch;
	// 821A712C: 815C008C  lwz r10, 0x8c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A7130: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A7134: 83BA00D4  lwz r29, 0xd4(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A7138: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 821A713C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A7140: 419A01C0  beq cr6, 0x821a7300
	if ctx.cr[6].eq {
	pc = 0x821A7300; continue 'dispatch;
	}
	// 821A7144: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A7148: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A714C: A17E0010  lhz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A7150: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7154: 419A0040  beq cr6, 0x821a7194
	if ctx.cr[6].eq {
	pc = 0x821A7194; continue 'dispatch;
	}
	// 821A7158: B33E0010  sth r25, 0x10(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[25].u16 ) };
	// 821A715C: A17D000C  lhz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A7160: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A7164: 40990024  ble cr6, 0x821a7188
	if !ctx.cr[6].gt {
	pc = 0x821A7188; continue 'dispatch;
	}
	// 821A7168: 481BFFD1  bl 0x82367138
	ctx.lr = 0x821A716C;
	sub_82367138(ctx, base);
	// 821A716C: A17D000C  lhz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A7170: 7D435B96  divwu r10, r3, r11
	ctx.r[10].u32 = ctx.r[3].u32 / ctx.r[11].u32;
	// 821A7174: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 821A7178: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821A717C: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821A7180: B17E0198  sth r11, 0x198(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(408 as u32), ctx.r[11].u16 ) };
	// 821A7184: 48000158  b 0x821a72dc
	pc = 0x821A72DC; continue 'dispatch;
	// 821A7188: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 821A718C: B17E0198  sth r11, 0x198(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(408 as u32), ctx.r[11].u16 ) };
	// 821A7190: 4800014C  b 0x821a72dc
	pc = 0x821A72DC; continue 'dispatch;
	// 821A7194: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7198: 391E003C  addi r8, r30, 0x3c
	ctx.r[8].s64 = ctx.r[30].s64 + 60;
	// 821A719C: 80FC0098  lwz r7, 0x98(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A71A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A71A4: 419A00C4  beq cr6, 0x821a7268
	if ctx.cr[6].eq {
	pc = 0x821A7268; continue 'dispatch;
	}
	// 821A71A8: 8167005C  lwz r11, 0x5c(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(92 as u32) ) } as u64;
	// 821A71AC: C0080000  lfs f0, 0(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A71B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A71B4: 419A001C  beq cr6, 0x821a71d0
	if ctx.cr[6].eq {
	pc = 0x821A71D0; continue 'dispatch;
	}
	// 821A71B8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821A71BC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A71C0: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821A71C4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A71C8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A71CC: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A71D0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821A71D4: 40980008  bge cr6, 0x821a71dc
	if !ctx.cr[6].lt {
	pc = 0x821A71DC; continue 'dispatch;
	}
	// 821A71D8: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 821A71DC: A17E0198  lhz r11, 0x198(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(408 as u32) ) } as u64;
	// 821A71E0: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 821A71E4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A71E8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A71EC: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821A71F0: A0CB0012  lhz r6, 0x12(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A71F4: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A71F8: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 821A71FC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821A7200: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821A7204: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821A7208: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A720C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A7210: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821A7214: D8010060  stfd f0, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[0].u64 ) };
	// 821A7218: A1610066  lhz r11, 0x66(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(102 as u32) ) } as u64;
	// 821A721C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A7220: 556B2AF4  rlwinm r11, r11, 5, 0xb, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 821A7224: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821A7228: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A722C: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821A7230: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7234: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821A7238: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A723C: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821A7240: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7244: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821A7248: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A724C: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821A7250: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7254: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821A7258: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A725C: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821A7260: C00B001C  lfs f0, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7264: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821A7268: 8167006C  lwz r11, 0x6c(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A726C: C0080008  lfs f0, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7274: 419A001C  beq cr6, 0x821a7290
	if ctx.cr[6].eq {
	pc = 0x821A7290; continue 'dispatch;
	}
	// 821A7278: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 821A727C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A7280: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821A7284: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A7288: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A728C: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7290: 815A00D8  lwz r10, 0xd8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A7294: 397E0060  addi r11, r30, 0x60
	ctx.r[11].s64 = ctx.r[30].s64 + 96;
	// 821A7298: 38DE0180  addi r6, r30, 0x180
	ctx.r[6].s64 = ctx.r[30].s64 + 384;
	// 821A729C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A72A0: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A72A4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A72A8: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821A72AC: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 821A72B0: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 821A72B4: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 821A72B8: 815C0094  lwz r10, 0x94(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A72BC: 390A0003  addi r8, r10, 3
	ctx.r[8].s64 = ctx.r[10].s64 + 3;
	// 821A72C0: 55492036  slwi r9, r10, 4
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A72C4: 550A2636  rlwinm r10, r8, 4, 0x18, 0x1b
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x0FFFFFFFu64;
	// 821A72C8: 7CA95A14  add r5, r9, r11
	ctx.r[5].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821A72CC: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A72D0: 48000049  bl 0x821a7318
	ctx.lr = 0x821A72D4;
	sub_821A7318(ctx, base);
	// 821A72D4: 3BFF00C0  addi r31, r31, 0xc0
	ctx.r[31].s64 = ctx.r[31].s64 + 192;
	// 821A72D8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 821A72DC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A72E0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A72E4: 409A000C  bne cr6, 0x821a72f0
	if !ctx.cr[6].eq {
	pc = 0x821A72F0; continue 'dispatch;
	}
	// 821A72E8: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 821A72EC: 4800000C  b 0x821a72f8
	pc = 0x821A72F8; continue 'dispatch;
	// 821A72F0: 815C008C  lwz r10, 0x8c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A72F4: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A72F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A72FC: 409AFE50  bne cr6, 0x821a714c
	if !ctx.cr[6].eq {
	pc = 0x821A714C; continue 'dispatch;
	}
	// 821A7300: 576B103A  slwi r11, r27, 2
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A7304: 937A00C8  stw r27, 0xc8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(200 as u32), ctx.r[27].u32 ) };
	// 821A7308: 917A00C4  stw r11, 0xc4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 821A730C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821A7310: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821A7314: 4838DDE8  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A7318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A7318 size=516
    let mut pc: u32 = 0x821A7318;
    'dispatch: loop {
        match pc {
            0x821A7318 => {
    //   block [0x821A7318..0x821A751C)
	// 821A7318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A731C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A7320: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A7324: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A7328: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A7520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A7520 size=40
    let mut pc: u32 = 0x821A7520;
    'dispatch: loop {
        match pc {
            0x821A7520 => {
    //   block [0x821A7520..0x821A7548)
	// 821A7520: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A7524: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821A7528: 38CB0090  addi r6, r11, 0x90
	ctx.r[6].s64 = ctx.r[11].s64 + 144;
	// 821A752C: 394AC470  addi r10, r10, -0x3b90
	ctx.r[10].s64 = ctx.r[10].s64 + -15248;
	// 821A7530: 38AB0080  addi r5, r11, 0x80
	ctx.r[5].s64 = ctx.r[11].s64 + 128;
	// 821A7534: 80EB00CC  lwz r7, 0xcc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A7538: 390A00E0  addi r8, r10, 0xe0
	ctx.r[8].s64 = ctx.r[10].s64 + 224;
	// 821A753C: 808B00C8  lwz r4, 0xc8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 821A7540: 806B00C4  lwz r3, 0xc4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 821A7544: 481C677C  b 0x8236dcc0
	sub_8236DCC0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


